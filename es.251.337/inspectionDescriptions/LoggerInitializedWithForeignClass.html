<html>
<body>
Reporta instancias de <code>Logger</code> donde la clase del literal <code>class</code> usado para la inicialización pertenece a una clase diferente de la que contiene el <code>Logger</code>. Esto puede ocurrir fácilmente al copiar y pegar código desde otra clase, y puede resultar en eventos registrados bajo categorías inesperadas y filtros aplicados incorrectamente.
<p>Se proporciona una corrección rápida para reemplazar el literal de clase externa con el literal de la clase contenedora.</p>
<p><b>Ejemplo:</b></p>
<pre><code>
  <b>public class</b> Paramount {
    <b>protected static final</b> Logger LOG = Logger.getLogger(Critical.class);
    // …otros campos y métodos
  }
</code></pre>
<p>Después de aplicar la corrección rápida:</p>
<pre><code>
  <b>public class</b> Paramount {
    <b>protected static final</b> Logger LOG = Logger.getLogger(Paramount.class);
    // …otros campos y métodos
  }
</code></pre>
<p>
  Configuración de la inspección:
</p>
<ul>
  <li>Use la tabla para especificar las clases y métodos de fábrica del logger que esta inspección debe reconocer.</li>
  <li>Use la opción <b>Ignorar loggers inicializados con superclase</b> para ignorar los loggers inicializados con la superclase de la clase que contiene el logger.</li>
  <li>Use <b>Ignorar loggers en clases no públicas</b> para emitir advertencias solo para loggers en clases <code>public</code>.</li>
  <li>Use <b>Ignorar loggers no inicializados en campos final</b> para reportar solo los loggers inicializados en campos final, ignorando otros casos.</li>
</ul>
</body>
</html>
