<html>
<body>
La expresión puede ser reemplazada por una llamada al método <code>Integer.compare()</code> o métodos similares de las clases <code>Long</code>, <code>Short</code>, <code>Byte</code>, <code>Double</code> o <code>Float</code> (en lugar de construcciones más verbosas o menos eficientes).
<p>Si <code>x</code> e <code>y</code> son enteros empaquetados (boxed), se recomienda usar <code>x.compareTo(y)</code>; si son primitivos, se recomienda usar <code>Integer.compare(x, y)</code>.</p>
<p><b>Ejemplo:</b></p>
<pre><code>
  public int compare(int x, int y) {
    return x > y ? 1 : x &lt; y ? -1 : 0;
  }
</code></pre>
<p>Después de aplicar la corrección rápida:</p>
<pre><code>
  public int compare(int x, int y) {
    return Integer.compare(x, y);
  }
</code></pre>
<p>
  Tenga en cuenta que <code>Double.compare</code> y <code>Float.compare</code> modifican ligeramente la semántica del código. En particular, permiten distinguir entre <code>-0.0</code> y <code>0.0</code> (<code>Double.compare(-0.0, 0.0)</code> produce -1).
  Además, manejan los valores <code>NaN</code> de manera consistente. En la mayoría de los casos, estos cambios semánticos realmente mejoran el código. Si estos cambios semánticos no son aceptables para su caso, use la casilla de verificación para deshabilitar esta inspección para números de punto flotante.
</p>
<p><small>Novedades de la versión 2017.2</small></p>
</body>
</html>
