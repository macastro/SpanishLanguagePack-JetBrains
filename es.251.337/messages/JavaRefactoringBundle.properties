0.already.contains.field.1={0} ya contiene el campo {1}
0.already.contains.inner.class.named.1={0} ya contiene una clase interna llamada {1}
0.already.has.parameter.named.1.use.this.name.anyway={0} ya tiene un parámetro llamado ''{1}''.\n¿Usar este nombre de todos modos?
0.contains.call.with.null.argument.for.parameter.1={0} contiene una llamada con argumento null para el parámetro {1}
0.implements.1={0} implementa {1}.
0.is.1.and.will.not.be.accessible.from.2.in.the.target.class={0} es {1} y no será accesible desde {2}.
0.is.a.part.of.method.hierarchy.do.you.want.to.delete.multiple.parameters={0} es parte de una jerarquía de métodos. ¿Desea eliminar múltiples parámetros?
0.is.a.part.of.method.hierarchy.do.you.want.to.delete.multiple.type.parameters={0} es parte de una jerarquía de métodos. ¿Desea eliminar múltiples parámetros de tipo?
0.is.an.interface.method.implementation.will.be.added.to.all.directly.implementing.classes={0} es una interfaz.\nLa implementación del método se añadirá a todas las clases que la implementen directamente.\n¿Continuar?
0.is.an.interface.that.has.no.implementing.classes={0} es una interfaz que no tiene clases que la implementen
0.is.not.a.legal.java.identifier=''{0}'' no es un identificador java válido
0.is.not.accessible.from.1.value.for.introduced.parameter.in.that.method.call.will.be.incorrect={0} no es accesible desde {1}. El valor para el parámetro introducido en esa llamada al método será incorrecto.
0.is.not.initialized.in.declaration.such.fields.are.not.allowed.in.interfaces={0} no está inicializado en la declaración. No se permiten estos campos en interfaces.
0.is.not.static.it.cannot.be.moved.to.the.interface={0} no es static. No se puede mover a la interfaz
0.is.not.visible.to.members.of.1={0} no es visible para los miembros de {1}
0.is.used.for.writing.in.1={0} se usa para escribir en {1}
0.refactoring.is.supported.only.for.final.fields=La refactorización {0} solo está soportada para campos final
0.upcasts.an.instance.of.1.to.2={0} hace upcast de una instancia de {1} a {2}
0.uses.1.of.an.instance.of.a.2={0} usa {1} de una instancia de {2}
0.uses.1.which.needs.class.instance={0} usa {1}, que necesita una instancia de clase
0.uses.a.package.local.1={0} usa {1} package-private
0.uses.non.static.1.which.is.not.passed.as.a.parameter={0} usa {1} no static, que no se pasa como parámetro
0.will.be.inaccessible.from.1={0} será inaccesible desde {1}
0.will.become.inaccessible.from.1={0} se volverá inaccesible desde {1}
0.will.hide.renamed.1={0} ocultará el {1} renombrado
0.will.no.longer.be.canonical.constructor=El constructor ya no será canónico
0.will.no.longer.be.record.component.accessor={0} ya no será el getter de {1}
0.will.no.longer.override.1={0} ya no sobrescribirá {1}
0.will.not.be.accessible.from.1.after.inlining={0} no será accesible desde {1} después del inlining
0.will.override.renamed.1={0} sobrescribirá el {1} renombrado
a.package.local.class.0.will.no.longer.be.accessible.from.1=La clase package-local {0} ya no será accesible desde {1}
accept.signature.change=Aceptar Cambio de Firma
add.object.as.a.parameter.to.constructors.with.name=Agregar &objeto como parámetro a constructores con nombre\:
add.parameters.for.fields=Agregar parámetros para cam&pos\:
add.parameters.for.fields.to.constructors=Agregar parámetros para cam&pos a constructores\:
all.candidate.variables.have.types.not.in.project=Todas las variables candidatas (parámetros de método y campos de la clase contenedora) tienen tipos que no están en el proyecto
all.candidate.variables.have.unknown.types=Todas las variables candidatas (parámetros de método y campos de la clase contenedora) tienen tipos desconocidos
all.invocations.and.remove.the.method=Hacer inline de tod&os los usos, eliminar el método
all.invocations.in.project=Hacer inline de tod&os los usos en el proyecto
all.invocations.keep.the.method=Hacer inline de todos los usos, conser&var el método
all.references.and.remove.super.class=Hacer inline de tod&as las referencias y eliminar la clase
all.references.and.remove.the.class=Hacer inline de tod&as las referencias y eliminar la clase
all.references.and.remove.the.field=Hacer inline de tod&os los usos, eliminar el campo
all.references.keep.field=Hacer inline de todos los usos, cons&ervar el campo
all.these.directories.will.be.moved.and.all.references.to.0.will.be.changed=Todos estos directorios serán movidos, y todas las referencias a {0}\nserán cambiadas.
analyze.and.replace.usages=Analizar y Reemplazar Usos
analyze.module.conflicts=Analizar Conflictos de Módulos…
annotate.field.as.nonnls.checkbox=Anotar cam&po como @NonNls
anonymous.class.description=clase anónima derivada de {0}
anonymous.class.text=Clase anónima
anonymous.to.inner.enum.constant.cannot.refactor.message=La constante enum no puede convertirse a clase interna
anonymousToInner.class.name.label.text=Nombre de clase\:
anonymousToInner.make.class.static.checkbox.text=Hacer la clase &static
anonymousToInner.no.inner.class.name=Se debe especificar el nombre de la clase
anonymousToInner.parameters.panel.border.title=Parámetros del Constructor
anonymousToInner.refactoring.name=Convertir Anónima a Interna
auto.rename.module.dialog.description=Renombrar los módulos Java con los siguientes nombres a\:
auto.rename.module.dialog.title=Renombrar Módulos Java
auto.rename.module.entity=Módulo Java
automatic.overload.renamer.entity.name=Sobrecarga
automatic.parameter.renamer.entity.name=Parámetro
boolean.method.result=resultado de método booleano
can.t.restore.context.for.method.extraction=No se puede restaurar el contexto para la extracción del método
cannot.find.or.create.destination.directory=No se puede encontrar o crear el directorio de destino
cannot.introduce.field.in.interface=No se permiten campos no constantes en una interfaz.
cannot.move=No se puede Mover
cannot.move.inner.class.0.into.itself=No se puede mover la clase interna {0} dentro de sí misma
cannot.move.package.into.itself=No se puede mover el paquete dentro de sí mismo
caret.position.warning.message=El cursor debe estar posicionado en el tipo del campo, variable, método o parámetro de método a refactorizar
change.method.signature.action.name=Cambiar Firma del Método
change.signature.default.value.missing.warning.message=Falta el valor por defecto. Las llamadas al método contendrán espacios en blanco en lugar del valor del nuevo parámetro.
change.signature.use.any.checkbox=&Usar Cualquier Var
changeClassSignature.Type.parameter.can.not.be.primitive=El parámetro de tipo no puede ser primitivo
changeClassSignature.already.contains.type.parameter=''{0}'' ya contiene el parámetro de tipo ''{1}''
changeClassSignature.bad.value=Valor {0} incorrecto\: ''{1}'' para el parámetro ''{2}''
changeClassSignature.class.label.text=Cambiar firma de <code>{0}</code>.
changeClassSignature.no.type.parameters=La clase no puede tener parámetros de tipo
changeClassSignature.parameters.panel.border.title=Parámetros\:
changeClassSignature.refactoring.name=Cambiar Firma de Clase
changeSignature.bound.value.column=Valor Límite
changeSignature.cannot.resolve.return.type=No se puede resolver el tipo de retorno ''{0}''.\n¿Continuar?
changeSignature.contract.converter.can.not.update.annotation=La anotación @Contract no puede actualizarse automáticamente\: {0}
changeSignature.contract.converter.definition.error=Error en la definición del contrato\: {0}
changeSignature.contract.converter.external.annotations=No se admite la actualización automática de anotaciones externas
changeSignature.contract.converter.inherited.annotation=La anotación se hereda del método base
changeSignature.contract.converter.invalid.clause=Cláusula de contrato inválida ''{0}''
changeSignature.contract.converter.invalid.return.reference=Referencia inválida en valor de retorno\: {0}
changeSignature.contract.converter.mutation.contract=La anotación contiene contrato de mutación
changeSignature.contract.converter.parameter.removed=Se eliminó el parámetro ''{0}'', pero la cláusula de contrato ''{1}'' depende de él
changeSignature.contract.converter.return.parameter.removed=Se eliminó el parámetro ''{0}'', pero la cláusula de contrato ''{1}'' lo retorna
changeSignature.default.value.column=Valor por Defecto
changeSignature.empty.callee.method.text=Aquí se mostraría el texto del método llamado
changeSignature.empty.caller.method.text=Aquí se mostraría el texto del método llamador con la llamada resaltada
changeSignature.exception.caller.chooser=Seleccionar Métodos Para Propagar Nuevas Excepciones
changeSignature.exceptions.panel.border.title=Excepciones
changeSignature.exceptions.wont.propagate=No se realizará la propagación recursiva de cambios de excepción
changeSignature.no.return.type=No se ha especificado el tipo de retorno
changeSignature.no.type.for.exception=Especifique tipo para la excepción
changeSignature.no.type.for.parameter=Especifique tipo {0} para el parámetro ''{1}''
changeSignature.not.throwable.type=Tipo incorrecto ''{0}'' para excepción, debe extender java.lang.Throwable
changeSignature.processing.changes.title=Procesando cambios…
changeSignature.propagate.exceptions.title=Propagar excepciones(&X)…
changeSignature.use.any.var=Usar cualquier variable.
changeSignature.validating.title=Validando…
changeSignature.vararg.not.last=El parámetro vararg debe ser el último en la firma del método
changeSignature.wrong.return.type=Tipo de retorno incorrecto\: ''{0}''
changeSignature.wrong.type.for.exception=Tipo incorrecto\: ''{0}'' para excepción
changeSignature.wrong.type.for.parameter=Tipo incorrecto\: ''{0}'' para el parámetro ''{1}''
checking.conflicts=Comprobando conflictos…
choose.the.ones.you.want.to.be.deleted=Elija los que desea eliminar
class.0.already.exists=La clase {0} ya existe
class.0.is.not.accessible.from.target.1=La clase {0} no es accesible desde el destino {1}
class.0.not.found=No se encuentra la clase {0}.
class.body.description=cuerpo de la clase {0}
class.description={1, choice, 0\#|1\#local }clase {0}
class.does.not.exist.in.the.project=La clase no existe en el proyecto. ¿Desea crearla?
class.does.not.have.base.classes.or.interfaces=La clase {0} no tiene clases base ni interfaces
class.does.not.have.implicit.default.constructor=La clase {0} no tiene constructor por defecto implícito
class.has.been.successfully.created=La clase {0} se ha creado correctamente
class.initializer.description=inicializador {0, choice, 0\#static|1\#de instancia}
class.is.abstract={0} es abstract.
class.is.anonymous.warning.message=No se puede realizar el refactoring porque las clases anónimas no pueden tener subclases
class.is.final.warning.message=No se puede realizar el refactoring porque la clase es final
class.is.interface={0} es una interfaz.
class.is.never.used=La clase nunca se utiliza
class.name.prompt=Nombre de la clase(&N)\:
collect.overloads=Recopilando sobrecargas…
comments.elements.header=Ocurrencias encontradas en comentarios, strings y archivos no código {0}
constructor.being.refactored.is.used.in.initializer.of.0=El constructor que se está refactorizando se utiliza en el inicializador de {0}. La factory no static de la clase interna {1} no se puede usar en este contexto. El código resultante no compilará.
constructor.description=constructor {0}
constructor.with.builder.new.setter.prefix.dialog.message=Nuevo prefijo de setter\:
constructor.with.builder.parameters.to.pass.to.the.builder.title=Parámetros para pasar al Builder
constructor.with.builder.rename.setters.prefix.action.name=Renombrar prefijo de Setters
convert.anonymous.or.local.to.inner.fix.name=Convertir clase anónima o local a interna
convert.anonymous.to.inner.action.name=Convertir anónima a interna…
convert.anonymous.to.inner.fix.name=Convertir clase anónima a interna
convert.local.to.field.title=Convertir local a campo
convert.local.to.inner.action.name=Convertir local a interna…
convert.local.to.inner.fix.name=Convertir clase local a interna
convert.to.instance.method.title=Convertir a método de instancia
convert.to.record.accessor.more.accessible={0} es {1}. Convertir a record hará que el método accessor implícito correspondiente sea {2}.
convert.to.record.ctor.more.accessible={0} es {1}. Convertir a record hará que el constructor canónico implícito correspondiente sea {2}.
convert.to.record.title=Convertir a clase Record
convertToInstanceMethod.all.reference.type.parameters.are.not.in.project=No se encuentra la clase destino para el método de instancia\: no se encontró ningún parámetro de método con un tipo que referencie una clase en el proyecto.
convertToInstanceMethod.all.reference.type.parameters.have.unknown.types=No se encuentra la clase destino para el método de instancia\: los tipos de parámetros del método son desconocidos.
convertToInstanceMethod.method.is.not.static=El método {0} no es static
convertToInstanceMethod.no.default.ctor=Además, la clase contenedora no tiene un constructor por defecto.
convertToInstanceMethod.no.parameters.with.reference.type=No hay parámetros que tengan tipo referencia.
copy.class.clone.0.1=Clonar {0} {1}
copy.class.copy.0.1=Copiar {0} {1}
copy.handler.clone.class=Clonar clase
copy.handler.copy.class=Copiar clase
copy.handler.copy.class.with.dialog=Copiar clase…
copy.handler.copy.classes.with.dialog=Copiar clases…
current.class=clase actual
dataflow.to.here.expand.progress=Expandiendo todos los nodos… {0}
dataflow.to.here.group.by.leaf.action.description=Determinar si null puede fluir hacia esta expresión
dataflow.to.here.group.by.leaf.action.text=Agrupar por nulidad de expresión hoja{0, choice, 1\#|2\# (Análisis en progreso)}
dataflow.to.here.variable.dereferenced.tooltip=Variable desreferenciada
declare.final=Declarar final(&F)
declare.generated.annotations=Generar anotaciones(&G)
declare.static.checkbox=Declarar static(&S)
declare.static.pass.fields.checkbox=Declarar static (pasar campos como parámetros)(&S)
declare.var.type=Declarar tipo var(&V)
declare.varargs.checkbox=Declarar varargs(&A)
default.visibility.border.title=Visibilidad por defecto
delete.variable.declaration=Eliminar declaración de variable(&D)
destination.directory.does.not.correspond.to.any.package=El directorio de destino no corresponde a ningún paquete
destination.package=Paquete de destino(&P)\:
dialog.message.0.would.hide.which.1.used.by.moved.2={0} ocultaría {1} que es utilizado por {2} movido.
dialog.message.caret.should.be.inside.method.or.constant=El cursor debe estar posicionado dentro de un método o constante
dialog.message.confirmation.to.process.only.implementation=Se encontró una implementación del método abstract\:<br><br><b>{0}</b><br><br>¿Desea hacer inline esta implementación?
dialog.message.enum.constant.0.won.t.be.compilable.in.1={0} no será compilable cuando se mueva a {1}.
dialog.message.field.doesnt.have.initializer=El campo {0} no tiene un inicializador
dialog.message.moving.directories.to=Moviendo directorios a ''{0}''
dialog.message.non.constant.will.not.be.compilable.in.interface=El no-constante {0} no será compilable cuando se mueva a una interfaz.
dialog.message.overriding.methods.with.weaken.visibility=¿Desea también reducir la visibilidad de los métodos sobrescritos a ''{0}''?
dialog.message.replace.duplicates.works.with.constants.only=Reemplazar duplicados solo funciona con constantes
dialog.message.static.class.initializers.are.not.allowed.in.interfaces=Los inicializadores de clase static no están permitidos en interfaces.
dialog.title.analyze.code.fragment.to.extract=Analizar código para extraer…
dialog.title.confirm.move=Confirmar movimiento
dialog.title.move.directory.to.source.root=Mover directorio a raíz de fuentes
dialog.title.resolving.method.implementation=Resolviendo implementación del método
different.name.expected=Se esperaba un nombre diferente
directory.0.already.contains.1.named.2=El directorio {0}\nya contiene {1} llamado ''{2}''
directory.0.already.contains.a.file.named.1=El directorio {0}\nya contiene un archivo llamado ''{1}''
do.not.replace=No reemplazar(&N)
do.not.show.this.message.in.the.future=No mostrar este mensaje en el futuro(&D)
do.you.want.to.process.overriding.methods.with.covariant.return.type=¿Desea procesar los métodos sobrescritos\ncon tipo de retorno covariante?
edit.migration.entry.title=Editar regla de migración de clase/paquete
edit.migration.map.ok.button=Guardar
edit.migration.map.title.existing=Editar mapa de migración
edit.migration.map.title.new=Nuevo mapa de migración
element.will.no.longer.be.accessible={0} ya no será accesible desde {1}
encapsulate.fields..encapsulated.fields.visibility.border.title=Visibilidad de campos encapsulados
encapsulate.fields..package.local.radio=Package local(&C)
encapsulate.fields.accessors.visibility.border.title=Visibilidad de accessors
encapsulate.fields.command.name=Encapsulando campos en {0}
encapsulate.fields.encapsulate.border.title=Encapsular
encapsulate.fields.existed.accessor.hidden=Ya existe un {0} que sería ocultado por el accessor generado
encapsulate.fields.existed.accessor.hides.generated=Ya existe un {0} que ocultaría el accessor generado para {1}
encapsulate.fields.expression.type.is.used=No se puede continuar con la expresión postfija/prefija cuando se usa su tipo de resultado
encapsulate.fields.field.column.name=Campo
encapsulate.fields.fields.to.be.encapsulated=Campos a encapsular
encapsulate.fields.fields.to.encapsulate.border.title=Campos a encapsular
encapsulate.fields.get.access.checkbox=Acceso get (&G)
encapsulate.fields.getter.column.name=Getter
encapsulate.fields.getter.exists=Ya existe un método {0} que difiere del getter {1} solo en el tipo de retorno
encapsulate.fields.no.target=No se encontró nada para encapsular
encapsulate.fields.nothing.todo.warning.message=La clase no tiene campos para encapsular
encapsulate.fields.private.radio=Privado(&I)
encapsulate.fields.protected.radio=Protected(&T)
encapsulate.fields.refactoring.cannot.be.applied.to.interface=La refactorización de encapsulación de campos no se puede aplicar a una interfaz
encapsulate.fields.set.access.checkbox=Acceso set (&S)
encapsulate.fields.setter.column.name=Setter
encapsulate.fields.setter.exists=Ya existe un método {0} que difiere del setter {1} solo en el tipo de retorno
encapsulate.fields.title=Encapsular campos
encapsulate.fields.use.accessors.even.when.field.is.accessible.checkbox=Usar accessors incluso cuando el campo es accesible
entity.name.accessor=Accessor
entity.name.constructor.parameter=Parámetro
entity.name.inheritor=Heredero
entity.name.test=Test
entity.name.variable=Variable
enum.constant.description=constante enum {0}
enum.description={1, choice, 0\#|1\#local }enum {0}
error.cannot.resolve=No se puede resolver {0}
error.incorrect.data=Datos incorrectos
error.not.supported.for.jsp=La refactorización {0} no está soportada para JSP
error.not.supported.for.local=Una clase que extiende una clase local no puede convertirse en una clase interna
error.not.supported.for.package.info=La refactorización {0} no está soportada para package-info.java
error.wrong.caret.position.anonymous=El cursor debe estar posicionado dentro de la clase anónima o local a refactorizar
error.wrong.caret.position.constructor=El cursor debe estar posicionado dentro del constructor a refactorizar
error.wrong.caret.position.local.or.expression.name=El cursor debe estar posicionado en el nombre de la variable local o expresión a refactorizar
error.wrong.caret.position.method=El cursor debe estar posicionado dentro del método a refactorizar
error.wrong.name.input=Nombre incorrecto\: {0}
expand.method.reference.warning=El método se usa en una o más referencias de método. Continuar convertirá estas referencias de método en expresiones lambda.
expression.result=resultado de la expresión
extract.chained.constructor.checkbox=Extraer constructor encadenado (&C)
extract.delegate.as.enum.checkbox=Extraer como enum
extract.delegate.create.nested.checkbox=Crear clase anidada
extract.delegate.generate.accessors.checkbox=Generar accessors(&G)
extract.delegate.unable.create.warning.message=No se puede crear una clase con el nombre dado
extract.method.checkbox.annotate=Anotar
extract.method.checkbox.make.static=Hacer static
extract.method.checkbox.make.static.and.pass.fields=Hacer static y pasar campos
extract.method.conflict.parameter=Nombre de parámetro en conflicto\: {0}
extract.method.conflict.variable=Ya existe una variable con nombre {0} en el ámbito seleccionado
extract.method.control.flow.analysis.failed=El código contiene errores de sintaxis. No se puede realizar el análisis necesario.
extract.method.dialog.separator.parameters=Parámetros(&P)
extract.method.error.annotation.value=No se puede extraer método del valor de anotación
extract.method.error.class.not.found=El bloque seleccionado debe ser parte de una clase java.
extract.method.error.class.outside.defined=La clase local está definida fuera del bloque seleccionado.
extract.method.error.class.outside.used=La clase local se usa fuera del bloque seleccionado.
extract.method.error.local.class.defined.outside=No se puede extraer el método porque el fragmento de código seleccionado usa clases locales definidas fuera del fragmento
extract.method.error.local.class.used.outside=No se puede extraer el método porque el fragmento de código seleccionado define clases locales usadas fuera del fragmento
extract.method.error.local.class.variable.used.outside=No se puede extraer el método porque el fragmento de código seleccionado define una variable de tipo clase local usada fuera del fragmento
extract.method.error.make.static=Error al hacer static
extract.method.error.many.exits=Hay múltiples puntos de salida.
extract.method.error.many.finals=Hay una asignación al campo final.
extract.method.error.many.outputs=Hay múltiples variables para retornar.
extract.method.error.method.conflict=Ya existe un método con la misma firma
extract.method.error.prefix=No se puede extraer el método.
extract.method.error.variable.in.expression=Hay una variable para retornar dentro de la expresión seleccionada.
extract.method.error.wrap.many.outputs=Hay varias variables de salida en el bloque de código seleccionado.\n El método puede extraerse si las agrupamos en {0}.
extract.method.error.wrap.many.outputs.class=un único objeto
extract.method.error.wrap.many.outputs.record=un nuevo record
extract.method.gotit.navigation.header=¿Desea cambiar la firma del método?
extract.method.gotit.navigation.message=Ir a la declaración del método para hacerlo\:<br/>{0} el nombre del método o presionar {1}.
extract.method.gotit.signature.header=Cambiar la firma del método
extract.method.gotit.signature.message=<html><p style\=''margin-bottom\:3px;''>1. Editar la firma</p><p style\=''margin-bottom\:3px;''>2. Actualizar usos\: clic en el icono del margen o presionar {0}</p><p><font color\=gray>Para reordenar parámetros, usar {1} o {2}.</font></p></html>
extract.method.link.label.more.options=Más opciones
extract.method.object=Extraer método objeto
extract.method.object.anonymous.make.varargs.option=Hacer varargs(&V)
extract.method.object.class.name=Nombre de clase(&C)\:
extract.method.object.create.anonymous.class=Crear clase anónima(&A)
extract.method.object.create.inner.class=Crear clase interna(&I)
extract.method.object.inner.class.visibility=Visibilidad\:
extract.method.object.inner.make.static.option=Hacer static(&S)
extract.method.object.inner.make.varargs.option=Hacer varargs(&V)
extract.method.object.inner.visibility.package.local=package local(&K)
extract.method.object.inner.visibility.private=private(&V)
extract.method.object.inner.visibility.protected=protected(&O)
extract.method.object.inner.visibility.public=public(&B)
extract.method.object.method.name=Nombre del método(&M)\:
extract.method.object.parameters=Parámetros
extract.method.object.signature.preview=Vista previa de la firma
extract.method.object.suggestion=¿Desea extraer el método objeto?
extract.method.preview.node.invalid.prefix=Inválido 
extract.method.progress.replace.duplicates=Reemplazando duplicados
extract.method.progress.search.duplicates=Buscando duplicados
extract.parameters.to.replace.duplicates=Extraer parámetros para reemplazar duplicados
extract.subclass.command=Extraer subclase
extractSuper.rename.original.class.to=Renombrar clase original a\: (&R)
extractSuperInterface.javadoc=JavaDoc
factory.method.name.label=Nombre del método factory\:
failed.to.re.run.refactoring=Error al volver a ejecutar la refactorización
field.0.is.already.defined.in.the.1=El campo {0} ya está definido en {1}
field.0.is.never.used=El campo {0} nunca se usa
field.0.is.not.accessible=El campo {0} no es accesible desde {1}
field.0.will.hide.field.1.of.the.base.class=El campo {0} ocultará \nun campo {1} de la base {2}
field.0.won.t.be.initialized.already.in.class.initializer=El campo ''{0}'' no se inicializará dentro del inicializador de clase
field.declaration.radio=Declaración de campo (&D)
field.description=campo {0}
field.name=Nombre del campo (&F)\:
fields.to.be.refactored.should.belong.to.the.same.class=Los campos a refactorizar deben pertenecer a la misma clase
functional.interface.broken=La expresión funcional requiere que la interfaz funcional tenga exactamente un método
generate.getter.for.delegated.component=Generar getter para componente delegado (&G)
generate.module.descriptors.analysing.message=Analizando Dependencias
generate.module.descriptors.build.required.message=No se pudieron generar los descriptores de módulo porque el proyecto aún no se ha construido
generate.module.descriptors.collecting.message=Recopilando Dependencias
generate.module.descriptors.command.title=Generar Descriptores module-info
generate.module.descriptors.io.exceptions.message=Problema al leer los archivos del módulo {0}
generate.module.descriptors.no.suitable.modules.message=No se encontraron módulos que puedan contener module-info
generate.module.descriptors.preparing.message=Preparando Código
generate.module.descriptors.rebuild.message=El proyecto necesita ser construido para una mayor precisión en el cálculo de dependencias.\n¿Iniciar la construcción antes de generar los descriptores module-info?
generate.module.descriptors.scanning.message=Escaneando Salida del Compilador
generate.module.descriptors.title=Generar Descriptores de Módulo
getter.and.setter.methods.found.for.the.field.0=Se encontraron métodos getter y setter para el campo {0}.\n¿{1} también?
getter.method.found.for.the.field.0=Se encontró método getter para el campo {0}.\n¿{1} el getter también?
idea.has.not.found.any.code.that.can.be.replaced.with.method.call={0} no ha encontrado ningún duplicado
ignore.button=Ignorar
implicit.last.parameter.warning=El último parámetro implícito no debe eliminarse
infer.class.type.args.warning=Imposible inferir argumentos de tipo de clase. Al continuar, se creará {0} sin procesar
information.title=Información
initializer.for.variable.cannot.be.a.constant.initializer=El inicializador para la variable {0} no puede ser un inicializador constante
inline.action.name=Inline
inline.anonymous.conflict.progress=Buscando herederos de la clase "{0}"…
inline.class.elements.header=Clase a hacer inline
inline.conflicts.progress=Comprobando si es posible hacer inline…
inline.constant.field.not.supported.for.enum.constants={0} no está soportado para constantes enum
inline.element.unknown.header=Elemento desconocido
inline.field.action.name=Hacer Inline de Campo…
inline.field.command=Hacer Inline del Campo {0}
inline.field.elements.header=Campo a hacer inline
inline.field.field.name.label=Hacer inline del campo ''{0}''\:
inline.field.field.occurrences=Hacer inline del campo ''{0}'' con {1} {1, choice, 1\#uso|2\#usos}\:
inline.field.initializer.is.not.accessible=El inicializador de campo hace referencia a {0}, que no es accesible en {1}
inline.field.title=Hacer Inline de Campo
inline.field.used.in.javadoc=El campo inlined se usa en javadoc
inline.field.used.in.reflection=El campo inlined se usa reflexivamente
inline.local.unable.try.catch.warning.message=No se puede hacer inline fuera de la declaración try/catch
inline.local.used.as.resource.cannot.refactor.message=La variable se usa como referencia de recurso
inline.local.variable.declared.outside.cannot.refactor.message=La variable está declarada fuera de un bloque de código
inline.method.calls.not.accessible.in=El método inlined llama a {0} que no será accesible en {1}
inline.method.calls.not.accessible.on.qualifier=El método inlined llama a {0} que no será accesible en el calificador {1}
inline.method.checking.tail.calls.progress=Comprobando usos de llamadas tail
inline.method.elements.header=Método a hacer inline
inline.method.method.label=Hacer inline del método ''{0}''\:
inline.method.method.occurrences=Hacer inline del método ''{0}'' con {1} {1, choice, 1\#uso|2\#usos}\:
inline.method.multiline.method.in.ctor.call=No se puede aplicar inline a método multilínea en llamada al constructor
inline.method.multiline.method.in.loop.condition=No se puede aplicar inline a método multilínea en condición de bucle
inline.method.object.action.name=Hacer Inline de Objeto
inline.method.object.suggestion.message=¿Desea hacer inline del objeto y la llamada subsiguiente?
inline.method.qualifier.usage.side.effect=El método inlined se usa en referencia de método con efectos secundarios en el calificador
inline.method.used.in.javadoc=El método inlined se usa en javadoc
inline.method.used.in.reflection=El método inlined se usa reflexivamente
inline.object.command.name=Hacer Inline de Objeto
inline.parameter.action.name=Hacer Inline de Parámetro…
inline.parameter.cannot.find.initializer.warning.message=No se puede encontrar el inicializador constante para el parámetro
inline.parameter.confirmation=¿Hacer inline del parámetro ''{0}'' con el inicializador ''{1}''?
inline.parameter.dependency.unavailable.in.static.method=El inicializador de parámetro depende de {0} que no está disponible dentro del método static
inline.parameter.depends.on.caller.parameter=El inicializador de parámetro depende del parámetro del llamador
inline.parameter.depends.on.non.static=El inicializador de parámetro depende de un miembro no static de otra clase
inline.parameter.depends.on.non.static.class=El inicializador de parámetro depende de una clase no static que no está disponible dentro del método static
inline.parameter.depends.on.this.inside.static.method=El inicializador de parámetro depende de this que no está disponible dentro del método static
inline.parameter.depends.on.unavailable.element.inside.method=El inicializador de parámetro depende de {0} que no está disponible dentro del método y no se puede hacer inline
inline.parameter.depends.on.unavailable.value=El inicializador de parámetro depende de un valor que no está disponible dentro del método
inline.parameter.error.hierarchy=No se admite hacer inline de parámetro cuando el método es parte de una jerarquía de herencia
inline.parameter.error.non.project.method=No se admite inline para métodos que no son del proyecto
inline.parameter.error.varargs=No se admite inline para parámetros varargs
inline.parameter.initializer.depends.on.inaccessible.value=El inicializador de parámetro depende de un valor que no está disponible dentro del método y no se puede hacer inline
inline.parameter.method.usages.progress=Buscando usos del método
inline.parameter.no.usages.warning.message=El método no tiene usos
inline.parameter.not.accessible.warning.message=El inicializador constante no es accesible en el cuerpo del método
inline.parameter.refactoring=Hacer Inline de Parámetro
inline.parameter.replace.with.local.checkbox=Reemplazar con variable local (&E)
inline.parameter.write.usages.warning.message=No se admite hacer inline de parámetro que tiene usos de escritura
inline.pattern.variable.title=Hacer Inline de Variable de Patrón
inline.popup.highlight=Resaltar {0} {0, choice, 1\#escritura conflictiva|2\#escrituras conflictivas}
inline.popup.ignore.conflicts=Ignorar escrituras y continuar
inline.super.class=Hacer Inline de Superclase
inline.super.class.action.name=Hacer Inline de Superclase…
inline.super.class.label=Clase {0}
inline.super.ctor.can.be.replaced=El constructor {0} puede ser reemplazado por cualquiera de {1}
inline.super.doc.panel.title=JavaDoc para Miembros Inlined
inline.super.expr.can.be.replaced={0} puede ser reemplazado por cualquiera de {1}
inline.super.no.anonymous.class=No se puede hacer inline en una clase anónima.
inline.super.no.ctor=No se encontró constructor que coincida con super
inline.super.no.inheritors.warning.message=No se puede hacer inline de una clase sin herederos
inline.super.no.inner.class=No se puede hacer inline en la clase interna. Mover ''{0}'' al nivel superior
inline.super.no.return.in.super.ctor=La refactorización no está soportada cuando la declaración return interrumpe el flujo de ejecución del constructor super
inline.super.no.substitution=No se encontró sustitución consistente para {0}. Se esperaba ''{1}'' pero se encontró ''{2}''.
inline.super.non.project.class.warning.message=No se puede hacer inline de una clase que no es del proyecto
inline.super.static.import.can.be.replaced=La importación static puede ser reemplazada por cualquiera de {0}
inline.super.target.instead.of.super.class=Se pasa una instancia del tipo objetivo a un lugar donde se espera la superclase.
inline.super.type.element.can.be.replaced={0} puede ser reemplazado por cualquiera de {1}
inline.super.type.params.differ=Los parámetros de tipo no coinciden en {0}. Se esperaba {1} pero se encontró {2}
inline.super.unknown.type=Tipo desconocido
inline.superclass.foreign.language.conflict.message=No se puede hacer inline a {0}
inline.to.anonymous.border.title=Inline
inline.to.anonymous.command.name=Inlinear clase {0}
inline.to.anonymous.name.label=Clase {0}
inline.to.anonymous.no.abstract=Las clases abstractas no se pueden inlinear
inline.to.anonymous.no.ctor.calls=La clase no se puede inlinear porque llama a su propio constructor
inline.to.anonymous.no.get.class.calls=El resultado de la invocación getClass() será modificado
inline.to.anonymous.no.method.calls=La clase no se puede inlinear porque accede a sus propios miembros en otra instancia
inline.to.anonymous.no.multiple.interfaces=Las clases que implementan múltiples interfaces no se pueden inlinear
inline.to.anonymous.no.superclass.and.interface=Las clases que tienen una superclase e implementan una interfaz no se pueden inlinear
inline.to.anonymous.refactoring=Inlinear a clase anónima
inline.vars.elements.header=Variable a inlinear
inline.warning.variables.used.in.initializer.are.updated=Inline inseguro\: Las variables usadas en el inicializador están actualizadas
inlined.method.implements.method.from.0=El método inlineado implementa el método de {0}
inlined.method.overrides.method.from.0=El método inlineado sobrescribe el método de {0}
inlined.method.will.be.transformed.to.single.return.form=El método inlineado se transformará a forma de retorno único
inner.class.0.is.already.defined.in.class.1=La clase interna {0} ya está definida en la clase {1}.\n¿Continuar de todos modos?
inner.class.0.is.not.static=La clase interna {0} no es static.\nLa refactorización {1} solo es compatible con miembros static.
inner.class.exists=La clase interna llamada ''{0}'' ya está definida\nen la clase ''{1}''
inner.class.name=Nombre de clase interna(&I)\:
instance.initializer.description=inicializador de instancia de {0}
instances.casted.to.java.lang.object=Instancias convertidas a java.lang.Object
instances.of.0.upcasted.to.1.were.found=Se encontraron instancias de {0} convertidas a {1}. Si continúa, se mostrarán en una pestaña Buscar separada.
instances.upcasted.to.java.lang.object.found=Se encontraron instancias convertidas a java.lang.Object
instances.upcasted.to.object=Instancias convertidas a Object
interface.0.does.not.have.inheritors=La interfaz {0} no tiene herederos
interface.description={1, choice, 0\#|1\#local }interfaz {0}
interface.does.not.have.base.interfaces=La interfaz {0} no tiene interfaces base
interface.has.been.successfully.created=La interfaz {0} se ha creado correctamente
introduce.constant.enum.cb=Extraer como constante enum (&E)
introduce.constant.field.of.type=Constante (campo static final) de tipo(&T)\:
introduce.constant.introduce.to.class=Extraer a clase (nombre completo cualificado)(&C)\:
introduce.constant.move.to.another.class.checkbox=Mover a otra clase(&M)
introduce.field.field.of.type=Campo de tipo\: (&T)
introduce.field.static.field.of.type=Campo static de tipo(&T)\:
introduce.functional.variable.pass.fields.checkbox=Pasar campos como parámetros(&F)
introduce.local.variable.to.reassign.title=Elegir variable para reasignar
introduce.parameter.command=Extrayendo parámetro a {0}
introduce.parameter.convert.lambda=Convertir a expresión funcional (&C)
introduce.parameter.duplicates.progress=Buscar duplicados de método…
introduce.parameter.elements.header=Agregando parámetro al método
introduce.parameter.object.create.inner.class=Crear clase interna(&I)
introduce.parameter.object.create.new.class=Crear nueva clase(&C)
introduce.parameter.object.error.class.does.not.exist=''{0}'' no existe
introduce.parameter.object.error.created.class.wont.be.accessible=La clase creada no será accesible
introduce.parameter.object.error.existing.class.misses.compatible.constructor=No hay constructor compatible en la clase existente
introduce.parameter.object.error.file.already.exits=El archivo ya existe\: {0}
introduce.parameter.object.error.inner.class.already.exist=Ya existe una clase interna con el nombre ''{0}''
introduce.parameter.object.error.invalid.inner.class.name=''{0}'' es un nombre de clase interna inválido
introduce.parameter.object.error.invalid.parameter.class.name=''{0}'' es un nombre de clase de parámetro inválido
introduce.parameter.object.error.invalid.parameter.class.package.name=''{0}'' es un nombre de paquete de clase de parámetro inválido
introduce.parameter.object.error.invalid.qualified.parameter.class.name=''{0}'' es un nombre de clase de parámetro cualificado inválido
introduce.parameter.object.error.no.field.associated.found=No se encontró ningún campo asociado con {0}
introduce.parameter.object.escalate.visibility.option=Escalar visibilidad(&E)
introduce.parameter.object.existing.class.name=Nombre(&N)
introduce.parameter.object.generate.accessors.option=Generar accesores(&G)
introduce.parameter.object.inner.class.name=Nombre(&N)
introduce.parameter.object.new.class.name=Nombre(&N)
introduce.parameter.object.new.class.package.name=Nombre del paquete(&P)
introduce.parameter.object.use.existing.class=Usar clase existente(&U)
introduce.parameter.super.method.checkbox=Refactorizar método super(&U)
introduce.variable.message.cannot.extract.in.implicit.class=No se puede extraer en una clase declarada implícitamente
introduce.variable.message.expression.refers.to.pattern.variable.declared.outside=La expresión hace referencia a la variable de patrón ''{0}'' declarada fuera
introduce.variable.no.matching.occurrences=No hay ocurrencias coincidentes
introduced.variable.will.conflict.with.0=La variable introducida entrará en conflicto con {0}
introducing.variable.may.break.code.logic=Introducir variable puede romper la lógica del código
invalid.expression.context=Contexto de expresión inválido.
invalid.package.name=Nombre de paquete inválido\: {0}
invalid.target.package.name.specified=Se especificó un nombre de paquete destino inválido
invert.boolean.foreach=El inicializador de parámetro Foreach no se puede invertir
invert.boolean.wrong.type=El tipo de retorno del método o tipo de la variable a refactorizar debe ser boolean
invocations.to.be.inlined=Invocaciones a inlinear {0}
is.modified.in.loop.body={0} se modifica en el cuerpo del bucle
java.safe.delete.caller.text=El texto del llamador con el método llamado resaltado se mostraría aquí
java.safe.delete.empty.callee.text=El texto del método llamado se mostraría aquí
javadoc.for.abstracts=JavaDoc para abstractos
keep.original.signature=Mantener firma original
lambda.to.reference.side.effect.warning.message=Se encontraron posibles efectos secundarios en el calificador de referencia del método.\n¿Introducir variable local?
local.variable.description=variable local {0}
local.will.be.hidden.renamed.description=El campo renombrado ocultará {0}
localToInner.refactoring.name=Convertir clase local a interna
locate.caret.inside.a.method=Ubicar cursor dentro de un miembro
locate.duplicates.action.name=Localizar duplicados
make.0.static=Hacer {0} static
make.method.static.title=Hacer método static
make.static.command=Haciendo {0} static
make.static.description.label=Hacer {0} {1} static
make.static.elements.header={0} a hacer static
make.static.method.references.progress=Buscar referencias de método
make.static.methods.to.propagate.dialog.title=Seleccionar métodos para propagar static
members.to.form.interface.title=Miembros para formar interfaz
members.to.form.superclass.title=Miembros para formar superclase
method.0.is.overridden.by.1=El método {0} es sobrescrito por {1}
method.0.will.hide.method.of.the.base.class=El método {0} ocultará \nel método de la clase base {1}
method.0.will.implement.method.of.the.base.class=El método {0} implementará \nun método de la clase base {1}
method.0.will.override.a.method.of.the.base.class=El método {0} sobrescribirá \nun método de la clase base {1}
method.call.would.be.linked.to.0.after.rename=La llamada al método se vinculará a "{0}" después de renombrar
method.column=Método
method.description=método {0}
method.does.not.have.a.body=El método {0} no tiene cuerpo
method.duplicates.found.message={0, choice, 1\#1 fragmento de código|2\#{0,number} fragmentos de código} encontrados
method.has.an.empty.body=El método {0} tiene un cuerpo vacío.
method.is.not.a.constructor=El método no es un constructor
migration.class=Clase
migration.dialog.alert.delete=Eliminar
migration.dialog.alert.name=Eliminar mapa de migración
migration.dialog.alert.text=¿Eliminar la migración ''{0}''?
migration.dialog.link.delete=Eliminar
migration.dialog.link.duplicate=Duplicar y editar…
migration.dialog.link.edit=Editar…
migration.dialog.ok.button.text=Ejecutar
migration.dialog.scope.label=Alcance\:
migration.dialog.scope.whole.project=Proyecto completo
migration.dialog.title=Migración de paquetes y clases
migration.edit.copy.existing=Copiar existente
migration.edit.duplicated.migration.name=Copia de {0}
migration.edit.empty.name=El nombre de la migración no puede estar vacío.
migration.edit.empty.table=La tabla de migración no puede estar vacía.
migration.edit.existing.name=Ya existe una migración con el mismo nombre.
migration.entry.class=Clase
migration.entry.new.name=Nuevo nombre\:
migration.entry.old.name=Nombre anterior\:
migration.entry.package=Paquete
migration.map.description.label=Descripción del mapa\:
migration.map.name.prompt=Nombre del mapa\:
migration.new.name.column.header=Nuevo nombre
migration.no.usages.found.in.the.project=No se encontraron usos en el proyecto
migration.old.name.column.header=Nombre anterior
migration.package=Paquete
migration.package.with.subpackages=Paquete con subpaquetes
migration.title=Migración
migration.type.column.header=Tipo
move.class=Mover clase…
move.class.or.package.build.directories=Construyendo lista de directorios
move.class.refactoring.cannot.be.applied.to.anonymous.classes=La refactorización Mover clase no se puede aplicar a clases anónimas
move.class.to.inner.command.name=Mover {0, choice, 1\#clase|2\#clases} {1} a {2}
move.class.to.inner.find.target.class.progress=Buscando clase destino…
move.class.to.inner.move.to.self.error=No está permitido mover una clase dentro de sí misma
move.class.to.inner.nonstatic.error=No está permitido mover una clase a una clase interna no static
move.class.to.new.file.or.make.inner.class.preview=Mover la clase ''{0}'' a un nuevo archivo en un paquete de su elección o convertirla en clase interna de una existente.
move.classes=Mover clases…
move.classes.and.packages=Mover clases y paquetes…
move.classes.command=Moviendo {0} al paquete {1}
move.classes.destination.make.inner=Convertir en clase interna de(&M)
move.classes.destination.package.prompt=Al paquete\:
move.classes.destination.to.package=Al paquete(&G)
move.classes.invalid.package.name.warning.message=Nombre de paquete no válido
move.classes.or.packages.different.modules.exports.conflict=Mover {0} del módulo {1} al módulo {2} puede ocultar su acceso
move.classes.or.packages.new.module.exports.conflict=Cambiar las declaraciones exports/opens del paquete {0} otorga acceso a otros tipos y sus miembros en el mismo paquete
move.classes.or.packages.title=Mover
move.classes.or.packages.unused.exports.action.name=Eliminar exports/opens sin usar
move.classes.or.packages.unused.exports.command.name=Eliminando exports/opens sin usar
move.classes.or.packages.unused.exports.notification.title=Se encontraron exports/opens sin usar<br>\nen {0,choice, 1\#descriptor|2\#descriptores} de módulo
move.enum.constant.cb=Mover como constantes enum si es posible(&E)
move.files.regrouping.command.name=Reagrupando…
move.files.to.new.directory.prompt=Al directorio\:
move.inner.class.action.name=Mover clase interna…
move.inner.class.command=Moviendo clase interna {0}
move.inner.class.to.another.class=Mover clase interna {0} a otra clase(&M)
move.inner.class.to.be.moved=Clase a mover
move.inner.class.to.upper.level=Mover clase interna {0} al nivel superior
move.inner.class.to.upper.level.action.name=Mover clase interna al nivel superior…
move.inner.class.to.upper.level.or.another.class.preview=Mover la clase interna ''{0}'' al nivel superior de un paquete de su elección o a otra clase.
move.inner.class.to.upper.level.preview=Mover la clase interna ''{0}'' al nivel superior de un paquete de su elección.
move.instance.method.delegate.title=Mover método de instancia…
move.instance.method.elements.header=Mover método de instancia
move.instance.method.handler.make.method.static=¿Desea hacer static el método ''{0}'' y luego moverlo?
move.label.text=Mover\:
move.member.write.access.in.interface.conflict=Se escribe en {0}, pero una interfaz solo puede contener constantes.
move.members.action.name=Mover miembros…
move.method.enter.a.valid.name.for.parameter=Por favor ingrese un nombre válido para el parámetro
move.method.is.not.supported.for.0=Mover método de instancia no está soportado para {0}
move.method.is.not.supported.for.constructors=Mover método no está soportado para constructores
move.method.is.not.supported.for.generic.classes=Mover método no está soportado para clases genéricas
move.method.is.not.supported.for.non.project.methods=Mover método no está soportado para métodos fuera del proyecto
move.method.this.parameter.label=Seleccione un nombre para el parámetro ''{0}.this''
move.methods.panel.title=Métodos a mover a la clase extraída(&M)
move.methods.used.in.extracted.block.only=Mover solo los métodos usados en el bloque extraído
move.nonstatic.class.from.jsp.not.supported=No se admite mover clases no static desde página JSP
move.package.or.directory=Mover paquete o directorio…
move.package.refactoring.cannot.be.applied.to.default.package=La refactorización Mover paquete no se puede aplicar al paquete por defecto
move.packages.or.directories=Mover paquetes o directorios…
move.single.class.or.package.name.label=Mover {0} {1}
move.specified.classes=Mover clases especificadas
move.specified.packages=Mover paquetes especificados
move.to.inner.duplicate.inner.class=La clase {0} ya contiene una clase interna llamada {1}
moving.local.classes.is.not.supported=No se admite mover clases locales.
no.class.name.specified=No se especificó nombre de clase
no.exact.method.duplicates.were.found=<html><b>Se encontraron {0,choice, 0\#0|1\#1|2\#{0}} {0,choice, 0\#duplicados exactos|1\#duplicado exacto|2\#duplicados exactos} del método</b>, aunque el método modificado como se muestra abajo tiene {1} {1,choice, 1\#duplicado más|2\#duplicados más}</html>
no.initializer.present.for.the.field=No hay inicializador presente para el campo
no.parameter.name.specified=No se especificó nombre de parámetro
no.usages.can.be.replaced=Ningún uso de {0} \npuede ser reemplazado con usos de {1}
occurrences.to.be.migrated=Ocurrencias a migrar {0}
ok.button=Aceptar
only.fields.variables.of.methods.of.valid.type.can.be.considered=Solo se pueden considerar campos, variables, parámetros de método o métodos de tipo válido.
package.description=paquete {0}
package.does.not.exist=El paquete {0} no existe.\n¿Desea crearlo?
package.does.not.exist.preview=El paquete {0} no existe.\nLa refactorización lo creará más tarde.
package.name.prompt=Nombre del paquete(&G)\:
parameter.description=parámetro {0}
parameter.initializer.contains.0.but.not.all.calls.to.method.are.in.its.class=El inicializador del parámetro contiene {0}, pero no todas las llamadas al método están en su clase
parameter.name.prompt=Nombre del parámetro(&M)\:
parameter.of.type=Parámetro de &tipo\:
parameter.type.table.column.title=Tipo
parameter.used.in.method.body.warning={0} se usa en el cuerpo del método
pass.outer.class.instance.as.parameter=Pasar instancia de clase externa como parámetro(&U)
pattern.variable.description=variable patrón {0}
please.enter.a.valid.target.package.name=Por favor ingrese un nombre válido para el paquete destino
popup.title.choose.class.to.introduce.constant=Elegir clase para introducir constante
popup.title.choose.class.to.introduce.field=Elegir clase para introducir campo
press.the.do.migrate.button=Presione el botón "Migrar" en la parte inferior del panel de resultados de búsqueda\npara migrar usando el mapa de migración "{0}"\n
preview.usages.to.be.changed=&Previsualizar usos a modificar (&P)
process.duplicates.change.signature.promt=Para reemplazar todas las ocurrencias se modificará la firma del método. ¿Continuar?
process.duplicates.title=Procesar Duplicados
process.methods.duplicates.title=Procesar Método {2} Duplicado ({0} de {1})
processing.progress.text=Procesando {0}
progress.title.collect.hierarchy=Recopilar jerarquía de ''{0}''
project.files.have.been.changed=Los archivos del proyecto han sido modificados.\n¿Desea ejecutar nuevamente el refactoring?
push.down.delete.warning.text={0}Mover los miembros hacia abajo resultará en su eliminación. ¿Desea continuar?
push.down.enum.no.constants.warning.text=La enumeración {0} no tiene constantes para hacer inline.
push.down.no.inheritors.class.warning.text=La clase {0} no tiene herederos.
push.down.no.inheritors.final.class.warning.text=La clase final {0} no tiene herederos.
push.down.unrelated.defaults.conflict={0} heredará valores predeterminados no relacionados de {1} y {2}
push.up.abstract.accessibility.in.subclass.conflict={0} usa {1} que no será accesible desde la subclase.
push.up.abstract.accessible.from.the.subclass.conflict=No se puede hacer {0} abstracto ya que no será accesible desde la subclase.
push.up.super.class.signature.conflict={0} en la superclase entraría en conflicto con un método {2} de {1}
re.run.refactoring=Re-ejecutar Refactoring
record.description={1, choice, 0\#|1\#local }record {0}
refactor.base.method.choice=Refactorizar {0, choice, 0\#métodos|1\#método} base
refactor.only.current.method.choice=Refactorizar solo el método actual
refactoring.cannot.be.applied.no.sources.attached=El refactoring "{0}" no puede aplicarse\: no hay fuentes adjuntas
refactoring.cannot.be.applied.to.abstract.methods=El refactoring {0} no puede aplicarse a métodos abstractos
refactoring.cannot.be.applied.to.inline.non.chaining.constructors=El refactoring {0} no puede aplicarse para hacer inline constructores no encadenados
refactoring.cannot.be.applied.to.native.methods=El refactoring {0} no puede aplicarse a métodos nativos
refactoring.cannot.be.applied.to.vararg.constructors=El refactoring {0} no puede aplicarse a constructores vararg
refactoring.extract.method.dialog.duplicates.count={0,choice, 1\#Un|2\#{0,number}} fragmento{0,choice, 1\#|2\#s} de código duplicado{0,choice, 1\#|2\#s} puede{0,choice, 1\#|2\#n} ser reemplazado{0,choice, 1\#|2\#s} por la llamada al método extraído
refactoring.extract.method.dialog.duplicates.pending=Buscando duplicados…
refactoring.extract.method.dialog.duplicates.progress=Buscando Duplicados
refactoring.extract.method.inner.class.defined=La clase interna {0} ya está definida en la clase {1}.
refactoring.extract.method.preview.button.refactor=&Refactorizar(&R)
refactoring.extract.method.preview.button.rerun=R&e-ejecutar Refactoring(&E)
refactoring.extract.method.preview.failed=Error al extraer método
refactoring.extract.method.preview.group.duplicates=Fragmentos de código duplicados
refactoring.extract.method.preview.group.method=Método a extraer
refactoring.extract.method.preview.group.original=Fragmento de código original
refactoring.extract.method.preview.preparing=Preparando Diff
refactoring.extract.method.preview.updating=Actualizando Diff
refactoring.extract.method.reference.to.change=Referencias a modificar
refactoring.introduce.variable.enum.in.label.message=No se puede extraer la constante enum en la etiqueta switch
refactoring.is.not.supported.for.jsp.classes=El refactoring no está soportado para clases JSP
refactoring.is.not.supported.in.the.current.context=El refactoring {0} no está soportado en el contexto actual
references.in.code.to.elements.from.migration.map=Referencias en el código a elementos del mapa de migración "{0}" {1}
references.to.0.to.be.replaced.with.references.to.1=Referencias a ''{0}'' que serán reemplazadas por referencias a ''{1}''{2}
remove.parameter.0.no.longer.used=Eliminar parámetro ''{0}'' que ya no se usa
removing.redundant.imports.progress.title=Eliminando imports redundantes
rename.accessors=Renombrar &accessors(&A)
rename.accessors.title=Renombrar Getters/Setters
rename.accessors.with.the.following.names.to=Renombrar accessors con los siguientes nombres a\:
rename.constructor.parameters.title=Renombrar Parámetros del Constructor
rename.constructor.parameters.with.the.following.names.to=Renombrar parámetros con los siguientes nombres a\:
rename.inheritors.with.the.following.names.to.title=Renombrar Herederos con los Siguientes Nombres a\:
rename.module.already.exists=El módulo ''{0}'' ya existe en el proyecto
rename.module.directory.command=Renombrar módulo y directorio a ''{0}''
rename.module.directory.title=Renombrar Módulo y &Directorio(&A)
rename.overloads=Renombrar s&obrecarga (&O)
rename.overloads.dialog.title=Renombrar Sobrecargas
rename.overloads.to.dialog.description=Renombrar sobrecargas a\:
rename.parameter.in.hierarchy.to.dialog.description=Renombrar parámetro en jerarquía a\:
rename.parameters.dialog.title=Renombrar Parámetros
rename.test.method=Renombrar método de test
rename.test.method.description=Renombrar métodos de test con los siguientes nombres a\:
rename.test.method.entity.name=Método de Test
rename.test.method.title=Renombrar Métodos de Test
rename.tests=Renombrar t&ests (&E)
rename.tests.title=Renombrar Tests
rename.tests.with.the.following.names.to=Renombrar tests con los siguientes nombres a\:
rename.variables=Renombrar &variables (&V)
rename.variables.title=Renombrar Variables
renamed.class.will.hide.0.in.1=La clase renombrada ocultará {0} en {1}
renaming.method.will.override.final.0=El método renombrado sobrescribirá el final "{0}"
replace.all.and.extract=Reemplazar todas las {0} ocurrencias y extraer como operación ''{1}''
replace.all.fields=&Reemplazar todos los campos (&R)
replace.all.occurrences.changes.semantics=Reemplazar todas las {0} ocurrencias (¡cambiará la semántica\!)
replace.all.occurrences.of.expression.0.occurrences=Reemplazar &todas las ocurrencias ({0})(&A)
replace.all.read.and.write=Reemplazar ocurrencias de lectura y escritura (¡cambiará la semántica\!)
replace.as.separate.operation=Extraer como operación ''{0}''
replace.constructor.0.with.a.factory.method=Reemplazar constructor {0} con un método factory
replace.constructor.builder.create.new=&Crear nuevo(&C)
replace.constructor.builder.default.value.table.title=Valor Predeterminado
replace.constructor.builder.error.builder.class.cannot.be.the.same=La clase {0} no puede ser su propia clase builder.
replace.constructor.builder.error.caret.position=El cursor debe estar posicionado dentro de la clase cuyos constructores se reemplazarán con builder.
replace.constructor.builder.error.class.with.chosen.name.already.exist=La clase {0} ya existe en el paquete {1}.
replace.constructor.builder.error.identifier.invalid=El identificador ''{0}'' no es válido
replace.constructor.builder.error.invalid.builder.class.name=''{0}'' no es un nombre de clase válido
replace.constructor.builder.error.invalid.builder.package.name=''{0}'' no es un nombre de paquete válido
replace.constructor.builder.error.invalid.builder.qualified.class.name=''{0}'' no es un nombre de clase completamente calificado válido
replace.constructor.builder.error.invalid.field.name=''{0}'' no es un nombre de campo válido
replace.constructor.builder.error.invalid.setter.name=''{0}'' no es un nombre de setter válido
replace.constructor.builder.error.no.constructor.chain=Los constructores de {0} no forman una cadena simple.
replace.constructor.builder.error.no.constructors=La clase actual no tiene constructores para reemplazar con builder.
replace.constructor.builder.error.selected.class.was.not.found=No se encontró la clase builder existente {0}.
replace.constructor.builder.field.name.table.title=Nombre del Campo
replace.constructor.builder.optional.setter.table.title=Setter Opcional
replace.constructor.builder.parameter.table.title=Parámetro
replace.constructor.builder.select.builder.class.chooser.title=Seleccionar Clase Builder
replace.constructor.builder.setter.name.table.title=Nombre del Setter
replace.constructor.builder.use.existing=Usar existente(&U)
replace.constructor.existing.builder.fqn=Nombre de clase Builder (nombre completo)(&B)
replace.constructor.factory.error.factory.method.already.exists=El método factory {0} ya existe y será usado en lugar del recién creado.
replace.constructor.factory.error.invalid.factory.method.name=''{0}'' no es un nombre válido para método factory
replace.constructor.new.builder.class.name=Nombre de clase Builder(&N)
replace.constructor.new.builder.package=Package para nuevo Builder(&P)
replace.constructor.with.builder=Reemplazar Constructor con Builder
replace.constructor.with.builder.text=Reemplazar constructor con builder
replace.constructor.with.factory.method=Reemplazar constructor con método factory
replace.constructor.with.factory.method.title=Reemplazar Constructor con Método Factory
replace.constructor.with.factory.target.fq.name=En (nombre completo)\:
replace.default.constructor.of.0.with.a.factory.method=Reemplazar constructor por defecto de {0} con un método factory
replace.default.constructor.with.factory.method=Reemplazar constructor por defecto con método factory
replace.fields.inaccessible.in.usage.context=Reemplazar campos inaccesibles en el contexto de uso(&I)
replace.fields.used.in.expressions.with.their.getters=Reemplazar campos usados en expresiones por sus getters(&U)
replace.inheritance.from=Reemplazar con herencia por delegación desde(&R)\:
replace.inheritance.with.delegation.command=Reemplazando herencia con delegación en {0}
replace.inheritance.with.delegation.delegate.members.title=Delegar miembros
replace.inheritance.with.delegation.elements.header=Reemplazar herencia con delegación
replace.inheritance.with.delegation.invalid.field=''{0}'' es un nombre de campo inválido para delegación
replace.inheritance.with.delegation.invalid.inner.class=''{0}'' es un nombre de campo inválido para delegación
replace.inheritance.with.delegation.title=Reemplazar Herencia con Delegación
replace.inside.current.lambda=Crear variable dentro del lambda actual
replace.instance.qualifiers.with.class.references=Reemplazar calificadores de instancia con referencias de clase
replace.lambda.chain.detected=Cadena lambda detectada
replace.method.code.duplicates.title=Reemplazar Código Duplicado
replace.method.duplicates.scope.chooser.message=Ámbito de análisis
replace.method.duplicates.scope.chooser.title=Especificar ámbito de {0}
replace.occurrences.inside.statement=Reemplazar {0} ocurrencias en el bloque{2, choice, 1\#|2\# externo} ''{1}''
replace.this.code.fragment.and.change.signature=La firma del método será cambiada a {0}
replace.this.code.fragment.and.make.method.static=(El método se convertirá en static)
replace.this.code.fragment.and.make.method.static.visible=(El método se convertirá en static y {0})
replace.this.code.fragment.and.make.method.visible=(El método será {0})
replace.with.method.call.does.not.work.for.constructors=Reemplazar con Llamada a Método no funciona para constructores
replace.write.access.occurrences=Reemplazar ocurrencias de acceso de escritura(&L)
replacing.inheritance.with.delegation=Reemplazando herencia con delegación
safe.delete.parameter.usage.warning={0} tiene un uso del lado del llamador que no es seguro eliminar.
safe.delete.search.for.caller.method.usages.progress=Buscando usos de métodos llamadores…
safe.delete.select.members.to.propagate.dialog.title=Seleccionar Miembros para Propagar Borrado Seguro
safe.delete.select.methods.to.propagate.delete.parameters.dialog.title=Seleccionar Métodos para Propagar Eliminación de Parámetros
select.source.root.chooser.title=Seleccionar Raíz de Código Fuente
selected.block.contains.invocation.of.another.class.constructor=El bloque seleccionado contiene una invocación al constructor de otra clase
selected.block.contains.statement.outside.of.class=El bloque seleccionado contiene una sentencia fuera de la clase
selected.block.should.represent.an.expression=El bloque seleccionado debe representar una expresión
selected.expression.cannot.be.a.constant.initializer=La expresión seleccionada no puede ser un inicializador constante
selected.expression.cannot.be.extracted=La expresión seleccionada no puede ser extraída
selected.expression.has.void.type=La expresión seleccionada tiene tipo 'void'
selected.expression.introduces.pattern.variable=La expresión seleccionada introduce la variable de patrón ''{0}''
setter.method.found.for.the.field.0=Se encontró método setter para el campo {0}. \n¿{1} también el setter?
side.effects.detected.title=Efectos Secundarios Detectados
source.folder.0.has.package.prefix.1=La carpeta fuente {0} tiene el prefijo de package ''{1}''\nEl package ''{2}'' no puede ser creado allí.
static.initializer.description=inicializador static de {0}
suggest.signature.preview.after.title=Después
suggest.signature.preview.method.call.prefix=llamada a método\:
suggest.signature.preview.title.before=Antes
superclass.cannot.be.accessed.in.subclass=La superclase no será accesible en la subclase
superclass.cannot.be.extracted.from.a.record=No se puede extraer superclase de un record
superclass.cannot.be.extracted.from.an.enum=No se puede extraer superclase de un enum
synthetic.jsp.class.is.referenced.in.the.method=La clase jsp sintética es referenciada en el método
target.0.is.not.accessible.from.1=El objetivo {0} no es accesible desde {1}
template.error.class.already.defined=Ya existe una clase llamada ''{0}'' en este ámbito
template.error.invalid.identifier.name=Nombre de identificador no válido
template.error.variable.already.defined=Ya existe una variable con ese nombre
there.are.going.to.be.multiple.destination.files.with.the.same.name=Habrá múltiples archivos de destino con el mismo nombre
there.are.multiple.exit.points.in.the.selected.code.fragment=Hay múltiples puntos de salida en el fragmento de código seleccionado
there.are.multiple.output.values.for.the.selected.code.fragment=Hay múltiples valores de salida para el fragmento de código seleccionado
there.are.no.variables.that.have.reference.type=No hay parámetros de método ni campos de clase contenedora que tengan tipo referencia
there.are.unused.methods.that.override.methods.you.delete=Existen métodos sin usar que sobrescriben los métodos que está eliminando
there.is.already.a.0.in.1=Ya existe un {0} en {1}
there.is.already.a.0.it.will.conflict.with.an.introduced.parameter=Ya existe un {0}. Entrará en conflicto con el parámetro introducido
there.is.already.a.0.it.will.conflict.with.the.renamed.1=Ya existe un {0} con el mismo nombre
there.is.already.type.parameter.in.0.with.name.1=Ya existe un parámetro de tipo en {0} con el nombre {1}
this.invocation.only.and.keep.the.method=Inline solo este uso y mantener el método(&K)
this.method=Este método
this.reference.only.and.keep.super.class=Inline solo esta referencia y mantener la superclase(&K)
this.reference.only.and.keep.the.class=Inline solo esta referencia y mantener la clase(&K)
this.reference.only.and.keep.the.field=Inline solo este uso y mantener el campo(&K)
title.rename.variables.with.the.following.names.to=Renombrar variables con los siguientes nombres a\:
tooltip.cannot.inline.pattern.variable=No se puede hacer inline de variable de patrón
turn.refs.to.super.command=Reemplazando usos de {0} por {1}
turnRefsToSuper.change.usages.to=Cambiar usos de {0} a\: (&C)
turnRefsToSuper.use.superclass.in.instanceof=Usar interfaz/superclase en instanceof (&U)
type.migration.action.name=Migración de tipos
type.migration.choose.scope.title=Elegir ámbito donde puede ocurrir el cambio de firma
type.migration.class.type.argument.label=Migrar argumento de tipo de clase {0} a
type.migration.conflicts.found=Se encontraron conflictos de migración
type.migration.error.hint.title=Migración de tipos
type.migration.exclude.action.text=Excluir (&E)
type.migration.include.action.text=Incluir(&I)
type.migration.migrate.button.text=Migrar (&M)
type.migration.no.conflicts.found=No se encontraron conflictos de migración
type.migration.no.scope.warning.message=No se ha seleccionado el ámbito
type.migration.reasons.to.migrate=Se encontraron razones para migrar
type.migration.rerun.button.text=Volver a ejecutar migración de tipos(&R)
type.migration.return.type.of.method.label=Migrar tipo de retorno {0} del método {1} a
type.migration.select.suggestion=Seleccione la raíz para encontrar razones para migrar
type.migration.type.of.field.label=Migrar tipo {0} del campo {1} a
type.migration.type.of.parameter.label=Migrar tipo {0} del parámetro {1} a
type.migration.type.of.pattern.variable.label=Migrar tipo {0} de la variable de patrón {1} a
type.migration.type.of.record.component.label=Migrar tipo {0} del componente de registro {1} a
type.migration.type.of.variable.label=Migrar tipo {0} de la variable {1} a
type.of.the.selected.expression.cannot.be.determined=No se puede determinar el tipo de la expresión seleccionada
unable.to.start.type.migration=No se puede iniciar la migración de tipos
unknown.expression.type=Tipo de expresión desconocido
unused.overriding.methods.title=Métodos de sobrescritura sin usar
use.interface.where.possible.title=Usar interfaz donde sea posible
use.super.references.prompt=En esta etapa, {0} puede analizar los usos de {1} \ny reemplazarlos con usos de {2} donde sea posible.\n¿Desea continuar?
use.variable.initializer.to.initialize.parameter=Usar inicializador de variable para inicializar parámetro(&I)
variable.0.is.changed.before.last.access=La variable ''{0}'' se modifica antes del último acceso a la variable ''{1}''
variable.does.not.have.an.initializer=La variable {0} no tiene un inicializador
variable.is.accessed.for.writing=Se accede a la variable ''{0}'' para escritura
variable.is.never.used.before.modification=La variable {0} nunca se usa antes de la modificación
variable.of.type=Variable de tipo(&T)\:
would.you.like.to.replace.default.constructor.of.0.with.factory.method=¿Desea reemplazar el constructor por defecto de {0} con un método factory?
wrap.return.value.create.inner.class=Crear clase interna(&I)
wrap.return.value.create.new.class=Crear nueva clase(&C)
wrap.return.value.existing.class.name=Nombre
wrap.return.value.inner.class.name=Nombre(&M)
wrap.return.value.new.class.name=Nombre(&N)
wrap.return.value.new.class.package.name=Nombre del paquete(&P)
wrap.return.value.use.existing.class=Usar clase existente(&U)
wrap.return.value.wrapper.field=Campo wrapper(&F)