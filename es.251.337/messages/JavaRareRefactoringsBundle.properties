action.Generify.description=Convertir código para utilizar tipos genéricos
action.Generify.text=Convertir tipo primitivo a genérico...
action.RemoveMiddleman.description=Inline delegate to selected field method
action.RemoveMiddleman.text=Eliminar intermediario...(_M)
action.ReplaceTempWithQuery.description=Reemplazar la variable seleccionada por el método
action.ReplaceTempWithQuery.text=Reemplazar temporal por consulta...(_Q)
action.WrapReturnValue.description=Envuelve el valor de retorno del método especificado con un objeto
action.WrapReturnValue.text=Envolver el valor devuelto del método...(_P)
cannot.replace.temp.with.query.in.interface=En la interfaz no se puede reemplazar temp con una consulta
constructor.returns.can.not.be.wrapped=No se puede envolver la devolución del constructor.
could.not.find.selected.wrapping.class=No se encontró clase de ajuste seleccionada
declaration.s.to.be.generified=Declaraciones(s) a convertir en genéricas {0}
delegating.field=Delegando campo
dialog.message.inner.class.with.name.already.exist=La clase interna con nombre ''{0}'' ya existe
dialog.message.invalid.inner.class.name=''{0}'' es un nombre de clase interna no válido
dialog.message.invalid.qualified.wrapper.class.name=''{0}'' es un nombre de clase envolvente calificado válido
dialog.message.invalid.wrapper.class.name=''{0}'' es un nombre de clase envoltorio inválido
dialog.message.invalid.wrapper.class.package.name=''{0}'' es un nombre de paquete para clase de contenedor no válido
dialog.message.wrapper.field.not.found=Campo wrapper no encontrado
error.wrong.caret.position.local.name=El cursor de texto debe situarse en el nombre de la variable local que se desea refactorizar
exposed.delegation.command.name=Se ha exposed la delegación a {0}
field.selected.is.not.used.as.a.delegate=El campo seleccionado no se utiliza como delegado
generify.title=Generar tipos genéricos desde tipos brutos
method.selected.returns.void=El método seleccionado devuelve 'void'.
method.to.wrap.returns.from.label=Método para encapsular un valor devuelto:
method.whose.return.are.to.wrapped=Método cuyo retorno se debe envolver
references.to.be.modified.usage.view=Referencias a ser modificadas {1, choice, 0#|1#en {1} archivo|2#en {1} archivos} {0, choice, 0# (no encontrado)|1# {0} referencia|2# {0} referencias}
references.to.expose.usage.view=Referencias a mostrar {0, choice, 0#(No se encontraron)|1#{0} referencia|2#{0} referencias}{1, choice, 0#|1# ubicada en {1} archivo|2# ubicadas en {1} archivos}
remove.middleman=Quitar middleman
remove.middleman.column.header=Eliminar
remove.middleman.deleted.hierarchy.conflict={0} se va a eliminar. La jerarquía se verá afectada
remove.middleman.field.header=Eliminar campo intermediario:
remove.middleman.methods.to.inline.title=Métodos a incrustar en línea(&M)
remove.middleman.title=Elimina intermediarios
remove.middleman.tooltip.warning=Eliminar destruirá la jerarquía de tipos
replace.temp.with.query.title=Reemplazar variables temporales con consultas
the.caret.should.be.positioned.at.the.name.of.the.field.to.be.refactored=El caret debería estar posicionado en el nombre del campo a refactorizar.
there.already.exists.a.class.with.the.selected.name=Ya existe una clase con el nombre seleccionado
type.cook.command=Generalizar
type.cook.drop.obsolete.casts=Eliminar casts obsoletos(&D)
type.cook.elements.header=Alcance de Generificación
type.cook.generify.objects=Generificar objetos(&O)
type.cook.leave.object.parameterized.types.raw=Dejar tipos parametrizados de objeto en raw(&L)
type.cook.perform.exhaustive.search=Realizar búsqueda exhaustiva(&E)
type.cook.preserve.raw.arrays=Preservar matrices crudas(&A)
type.cook.produce.wildcard.types=Generar tipos comodín(&W)
type.cook.ratio.generified=0,choice,-1#Sin calcular|0#{0,number}/{1}
type.cook.report=Elementos genéricos: {0}, casts eliminadas: {1}
wrap.return.value=Wrap valor return
wrap.return.value.title=Envuelve valor devuelto
wrapped.return.command.name=Wrapper de retorno como {0} de {1}()