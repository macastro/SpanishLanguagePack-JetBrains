0.is.not.an.identifier=No es un identificador
annotation.name.is.missing=El atributo de anotación debe ser en el formato 'name=value'
anonymous.class.context.display=Contexto de clase anónimo {0}
anonymous.class.derived.display=Clase anónima derivada de {0}
aux.context.display=de {0}
bad.return.type.in.lambda.expression=Tipo de retorno incorrecto en la expresión lambda: {0} no se puede convertir a {1}
bad.return.type.in.lambda.expression1=Tipo de retorno no válido en la expresión lambda: No se puede convertir {0} a void
bad.return.type.in.method.reference=El tipo de retorno en la referencia al método es incorrecto: no se puede convertir {0} en {1}
bound.not.expected=Vinculación no esperada
catch.without.try='catch' sin 'try'
class.context.display={0} en {1}
class.file.version=Versión {0}
class.literal.expected=.class esperado
command.name.insert.block.statement=Insertar bloque de código
conflicting.conjuncts=nulos
context.type.java.comment=comentario
context.type.string=cadena
default.language.level.description=Valor por defecto del SDK
diamond.error.anonymous.inner.classes=No se puede utilizar '<>' con clases internas anónimas
diamond.error.anonymous.inner.classes.non.private=No se puede usar '<>' debido a que un método no privado no sobrescribe ni implementa un método de un supertipo
diamond.error.cannot.infer.arguments=no se puede inferir argumentos
diamond.error.cannot.infer.arguments.unable.to.resolve.constructor=No se pueden inferir argumentos (no se puede resolver el constructor)
diamond.error.cannot.infer.type.arguments=No se pueden inferir los argumentos tipo {0}
diamond.error.explicit.type.parameters.for.constructor=No se pueden utilizar diamantes con parámetros de tipado explícitos para el constructor
element.abstract_method=Método abstracto
element.annotation=anotación
element.anonymous_class=clase anónima
element.class=clase
element.constant=constante
element.constructor=Constructor nulo
element.enum=Enum
element.enum_constant=Constante enumerada
element.expression=expresión
element.extends.list=Lista de extensiones
element.field=campo
element.initializer=inicializador nulo
element.interface=interfaz
element.kind.and.name={0} {1}
element.label=etiqueta
element.local_variable=Variable local
element.method=método
element.method.call=Llamada a método
element.module=módulo
element.package=paquete
element.package.statement=Frase de paquete
element.parameter=parámetro
element.pattern_variable=variable de patrón
element.permits.list=lista de permisos
element.receiver.parameter=Parámetro de receptor
element.record=registro
element.record_component=Componente de grabación
element.snippet_body=Cuerpo del fragmento
element.statement=sentencia
element.throws.list=lista throws
element.type.arguments=argumentos tipo
element.type.parameter=TipoParámetro
element.type.parameters=Parámetros de tipo
element.type.semicolon=Punto y coma
element.unknown=desconocido
element.variable=variable
else.without.if='else' sin 'if'
enum.constant.context=Constante de enumeración ''{0}'' en ''{1}''
error.incompatible.type={0} no es compatible con {1}
error.incompatible.type.bad.lambda.return.type=Tipo de retorno incorrecto en expresión lambda: {0} no se puede convertir a {1}
error.incompatible.type.declaration.for.the.method.reference.not.found=Falta la declaración de tipo compatible para la referencia al método
error.incompatible.type.expected.non.void.got.void.method.reference=error.incompatible.type.expected.non.void.got.void.method.reference=Tipo incompatible: se esperaba no void, pero la referencia del método tiene un tipo de valor devuelto void en la declaración de compilación
error.incompatible.type.expected.value.lambda=Tipo incompatible: no debe ser void, pero el cuerpo lambda es un bloque no compatible con el valor
error.incompatible.type.failed.to.resolve.argument=no ha podido resolver el argumento
error.incompatible.type.incompatible.equality.constraint=Restricción de igualdad incompatible: {0} y {1}
error.incompatible.type.incompatible.parameter.types.in.lambda=Parámetros de tipo incompatible en una lambda
error.incompatible.type.incompatible.parameter.types.in.method.reference=Tipos de parámetro incompatibles en la referencia de método
error.incompatible.type.incompatible.types.expected.not.void.got.void.method.reference=error.incompatible.type.incompatible.types.expected.not.void.got.void.method.reference
error.incompatible.type.incompatible.types.expected.void.lambda=Tipo incompatible: esperaba void, pero el cuerpo lambda no es ni una expresión de sentencia ni un bloque compatible con void
error.incompatible.type.no.type.variable=No hay ninguna instancia de variables de tipo para hacer {0}
error.incompatible.type.no.type.variable.0=No hay una instancia que sea variable de tipo {0} con la que {1} sea de tipo
error.incompatible.type.no.valid.function.type.found=No se encontró ningún tipo de función válido para {0}
error.incompatible.type.not.a.functional.interface={0} no es una interfaz funcional
error.incompatible.type.not.convertible=Tipo incompatible: no se puede convertir {0} a {1}
error.incompatible.type.parameter.type.is.not.yet.inferred=El tipo del parámetro aún no se ha inferido: {0}
error.incompatible.type.return.type.is.not.yet.inferred=El tipo de retorno aún no se ha inferido: {0}
error.incompatible.type.unhandled.exception=Excepción no tratada: {0}
error.incompatible.upper.bounds=Límite superior incompatible: {0}
error.inference.variable.has.incompatible.bounds=La variable de inferencia {0} tiene límites incompatibles.\n {1}: {2}\n{3}: {4}
error.message.wildcard.not.expected=Comodín inesperado
error.type.parameter.has.incompatible.upper.bounds=El parámetro de tipo {0} tiene límites superiores incompatibles: {1}
expected.array.initializer=Esperaba inicializador de array
expected.boolean.expression=Se esperaba la expresión booleana
expected.case.label.element=Se esperaba expresión, patrón, 'default' o 'null'
expected.catch.or.finally='catch' or 'finally' is expected
expected.class.or.interface=se esperaba 'class' o 'interface'
expected.class.reference=Se esperaba una referencia de clase
expected.colon=':' esperado
expected.colon.or.arrow=Se esperaba ':' o '->'
expected.comma="," esperada
expected.comma.or.rparen=Se esperaba ',' o ')'
expected.comma.or.semicolon=', o ;, esperado'
expected.dot='.' expected
expected.eq='=' esperado
expected.expression=Se esperaba expresión
expected.gt=debe ser '>'
expected.gt.or.comma='>' o ',' esperado
expected.identifier=Se esperaba un identificador
expected.identifier.or.semicolon=Se esperaba un identificador o ';'
expected.identifier.or.type=Se esperaba un identificador o un tipo
expected.lbrace='{' esperado
expected.lbrace.or.semicolon=Se esperaba '{' o ';'
expected.lbracket=[ esperado
expected.lparen=( esperado
expected.lparen.or.lbracket=Se espera '(' o '['
expected.lt.or.lparen='<' o '(' esperado
expected.module.declaration=Se esperaba una declaración de módulo
expected.module.statement=Se esperaba una directiva de módulo
expected.package.reference=Se espera una referencia de paquete
expected.parameter=Parámetro esperado
expected.parameter.or.rparen=Se esperaba un parámetro de anotación o ')'
expected.pattern=Patrón esperado
expected.rbrace='}'
expected.rbracket=Se esperaba ']'
expected.resource=Se espera definición de recurso
expected.rparen=Se esperaba ')'
expected.semicolon=Se esperaba ';'
expected.statement=Se espera una sentencia
expected.string=cadena de texto esperada
expected.switch.label='case', 'default' o '}' esperado
expected.switch.rule=Se esperaba expresión, bloque o una sentencia 'throw'
expected.template.fragment=Fragmento de plantilla esperado
expected.type=Tipo esperado
expected.type.parameter=Se espera un parámetro de tipo
expected.value=Valor esperado
expected.while=se esperaba 'while'
expected.with='with' esperado
feature.advanced.collection.api=Métodos Lambda en colecciones
feature.annotations=Anotaciones
feature.assertions=Aserciones
feature.binary.literals=Literales binarios
feature.classfile.api=ClassFile API
feature.collection.factories=Métodos de fábrica de colección
feature.diamond.types=Tipos de argumento
feature.effectively.final=Variables efectivamente finales
feature.enhanced.switch=Bloques 'switch' mejorados
feature.enum.qualified.name.in.switch=Enum calificado como constante en switch
feature.enums=Enumeraciones
feature.extension.methods=Métodos de extensión
feature.for.each=Bucles for-each
feature.foreign.functions=Funciones y memoria de API externas
feature.generics=Genéricos
feature.hex.fp.literals=Literales de punto flotante hexadecimales
feature.implicit.classes=Clases implícitamente declaradas
feature.implicit.import.in.implicit.classes=Importación implícita en clases implícitas
feature.inherited.static.main.method=Método main estático heredado
feature.inner.statics=Declaraciones estáticas en clases internas
feature.instance.main.method=Método main de la instancia
feature.intersections.in.casts=Tipos de intersección en cast
feature.javadoc.snippets=@snippet en Javadoc
feature.lambda.expressions=Expresiones lambda
feature.local.enums=Enumeraciones locales
feature.local.interfaces=Interfaces locales
feature.lvti=Inferencia del tipo de variables locales
feature.method.references=Referencias de método
feature.module.import.declarations=Declaraciones de importación de módulos
feature.modules=Módulos
feature.multi.catch=Multi capturas
feature.nestmates=Control de acceso basado en anidamiento
feature.no.this.capture=Las clases internas no capturan 'this'
feature.objects.class=java.util.Objects API
feature.override.interface=@Override en interfaces
feature.pattern.guard.and.record.patterns=Protecciones y patrones de registro
feature.patterns.in.switch=Patrones en switch
feature.patterns.instanceof=Patrones en 'instanceof'
feature.primitive.types.in.patterns=Tipos primitivos en patterns, instanceof y switch
feature.private.interface.methods=Métodos privados de interfaz
feature.record.patterns.in.for.each=Grabar patrones en bucles for-each
feature.records=Registros
feature.scoped.values=Valores de Alcance
feature.sealed.classes=Clases selladas
feature.sequenced.collections=Colecciones secuenciadas
feature.serial.annotation=@Serial anotación
feature.statements.before.super=Sentencias antes de super()
feature.static.imports=Importaciones estáticas
feature.static.interface.calls=Llamadas de métodos de interfaz estáticos
feature.stream.and.optional.api=API de corrientes y opcionales
feature.stream.gatherers=Recopiladores de flujo
feature.strictfp=Semántica de punto flotante siempre estricta
feature.string.switch=Cadenas en sentencias 'switch'
feature.string.templates=Plantillas de cadena
feature.structured.concurrency=Concurrencia estructurada
feature.switch.expressions='switch' expresiones
feature.text.block.escape.sequences='s' secuencias de escape
feature.text.blocks=Literales de bloque de texto
feature.try.with.resources=Prueba con recursos
feature.try.with.resources.refs=Referencias de recursos
feature.type.annotations=Anotaciones de tipo
feature.type.receivers=Parámetros de receptor
feature.underscores.in.literals=Subrayado en literales
feature.unnamed.vars=Patrones y variables sin nombrar
feature.utf8.property.files=Archivos de propiedades con codificación UTF-8
feature.var.lambda.parameter=parámetro 'var' en parámetros lambda
feature.varargs=Métodos de arity variable
feature.virtual.threads=Subprocesos Virtuales
feature.with.initial=ThreadLocal.withInitial()
filetype.class.description=Clase Java
filetype.class.display.name=Clase Java
filetype.java.description=Java
filetype.java.module.description=Módulo Java
filetype.java.module.display.name=Módulo Java
filetype.jshell.description=Fragmento de código JShell
finally.without.try='finally' sin 'try'
implicit.class.context.display=Contexto clase implícita
import.statement.identifier.or.asterisk.expected.=Se esperaba un identificador o '*'
java.terms.anonymous.class.base.ref=anónimo{0}
javadoc.exception.tag.class.is.not.throwable=La clase {0} no es subclase de Throwable
javadoc.exception.tag.exception.is.not.thrown={0} no está declarado para ser lanzado por el método {1}
javadoc.exception.tag.wrong.tag.value=valor de etiqueta incorrecto
javadoc.param.tag.parameter.name.expected=Se espera el nombre del parámetro
javadoc.param.tag.type.parameter.gt.expected=El parámetro '>' es requerido
javadoc.param.tag.type.parameter.name.expected=Se debe proporcionar el nombre del parámetro de tipo
javadoc.ref.tag.class.ref.expected=nula
javadoc.value.field.required=La etiqueta @value debe hacer referencia a un campo
javadoc.value.field.with.initializer.required=@value tag debe referenciar un campo con un inicializador constante
javadoc.value.static.field.required=La etiqueta @value debe hacer referencia a un campo estático
javadoc.value.tag.jdk15.required=El tag @value no puede tener argumentos cuando se utiliza JDK 1.4 o anterior
jdk.1.3.language.level.description=1.3 - Java clásico
jdk.1.4.language.level.description=1.4 - palabra clave 'assert'
jdk.1.5.language.level.description=5 - palabra clave 'enum', genéricos, autoboxing, etc.
jdk.1.6.language.level.description=6 - @Override en las interfaces
jdk.1.7.language.level.description=7 - Diamantes, ARM, multi-catch, etc.
jdk.1.8.language.level.description=8 - Lambdas, anotaciones de tipos, etc.
jdk.1.9.language.level.description=9 - Módulos, métodos privados en interfaces, etc.
jdk.10.language.level.description=10 - Inferencia de tipos de variables locales
jdk.11.language.level.description=11 - Sintaxis de variable local para parámetros lambda
jdk.12.language.level.description=12 - Sin nuevas características de idioma
jdk.13.language.level.description=13 - Sin nuevas funcionalidades de idioma
jdk.14.language.level.description=14 - Expresiones switch
jdk.15.language.level.description=15 - Bloques de texto
jdk.16.language.level.description=16 - Registros, patrones, enum de ámbito local y interfaces
jdk.17.language.level.description=17 - Tipos sellados, semántica de punto flotante siempre estricta
jdk.18.language.level.description=18 - Fragmentos de JavaDoc
jdk.19.language.level.description=19 - No hay nuevas funcionalidades de lenguaje
jdk.20.language.level.description=20 - Sin características de lenguaje nuevas
jdk.21.language.level.description=21 - Patrones de registro, comparación de patrones para switch
jdk.21.preview.language.level.description=21 (Previsualizar) - Plantillas de cadenas, clases sin nombre y métodos principales de instancia, etc.
jdk.22.language.level.description=22 - Variables y patrones sin nombre
jdk.22.preview.language.level.description=22 (vista previa): declaraciones antes de super(), plantillas de cadena (2.ª versión previa)
jdk.23.language.level.description=23 - Comentarios de documentación Markdown
jdk.23.preview.language.level.description=23 (Vista previa) - Tipos primitivos en patrones, clases declaradas implícitamente, etc. 
jdk.X.language.level.description=X - Funciones experimentales
jdk.unsupported.preview.language.level.description={0} (Vista previa)- No compatible
lambda.body.must.be.a.statement.expression=la expresión lambda debe ser una expresión de declaración
list.item.no.module=Sin módulo
local.class.preposition=local
method.context.display={0}() en {1}
missing.return.value.lambda=Falta valor de retorno
node.abstract.flag.tooltip=abstracto
node.annotation.tooltip=Anotación
node.anonymous.class.tooltip=clase anónima
node.class.tooltip=Clase
node.enum.tooltip=enumeración
node.exception.tooltip=excepción
node.field.tooltip=Campo
node.final.flag.tooltip=Final
node.interface.tooltip=Interfaz
node.junit.test.tooltip=Prueba JUnit
node.method.tooltip=método
node.record.tooltip=Registro
node.runnable.class.tooltip=Clase ejecutable
node.static.flag.tooltip=estático
psi.error.attempt.to.edit.class.file=Intentar editar el archivo de clase ya compilado ''{0}''
task.background.title.maven=Tarea Maven
type.can.be.converted={0} se puede convertir a {1}
type.conforms.to.constraint={0} cumple {1}
unexpected.identifier=Identificador inesperado
unexpected.return.value=valor de retorno inesperado
unexpected.token=Token inesperado
unexpected.tokens=Tokens inesperados