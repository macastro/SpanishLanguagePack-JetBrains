0.is.not.an.identifier=''{0}'' no es un identificador.
annotation.name.is.missing=El atributo de anotación debe tener el formato 'name\=value'
anonymous.class.context.display=Anónima en {0}
anonymous.class.derived.display=Clase anónima derivada de {0}
aux.context.display=de {0}
bad.return.type.in.lambda.expression=Tipo de retorno incorrecto en expresión lambda\: {0} no se puede convertir a {1}
bad.return.type.in.lambda.expression1=Tipo de retorno incorrecto en expresión lambda\: {0} no se puede convertir a void
bad.return.type.in.method.reference=Tipo de retorno incorrecto en referencia a método\: no se puede convertir {0} a {1}
bound.not.expected=Límite inesperado
catch.without.try='catch' sin 'try'
class.context.display={0} en {1}
class.file.version=Versión {0}
class.literal.expected=Se esperaba .class
command.name.insert.block.statement=Insertar Sentencia de Bloque
conflicting.conjuncts={0} y {1}
context.type.java.comment=Comentario
context.type.string=String
default.language.level.description=SDK por defecto
diamond.error.anonymous.inner.classes=No se puede usar '<>' con clases internas anónimas
diamond.error.anonymous.inner.classes.non.private=No se puede usar '<>' debido a método no privado que no sobrescribe ni implementa un método de un supertipo
diamond.error.cannot.infer.arguments=No se pueden inferir los argumentos
diamond.error.cannot.infer.arguments.unable.to.resolve.constructor=No se pueden inferir los argumentos (no se puede resolver el constructor)
diamond.error.cannot.infer.type.arguments=No se pueden inferir los argumentos de tipo para {0}
diamond.error.explicit.type.parameters.for.constructor=No se puede usar diamond con parámetros de tipo explícitos para el constructor
element.abstract_method=método abstract
element.annotation=anotación
element.anonymous_class=clase anónima
element.class=clase
element.constant=campo constante
element.constructor=constructor
element.enum=enum
element.enum_constant=constante enum
element.expression=expresión
element.extends.list=lista extends
element.field=campo
element.initializer=inicializador
element.interface=interface
element.kind.and.name={0} {1}
element.label=etiqueta
element.local_variable=variable local
element.method=método
element.method.call=llamada a método
element.module=módulo
element.package=paquete
element.package.statement=declaración package
element.parameter=parámetro
element.pattern_variable=variable de patrón
element.permits.list=lista permits
element.receiver.parameter=parámetro receptor
element.record=record
element.record_component=componente de record
element.snippet_body=cuerpo del snippet
element.statement=sentencia
element.throws.list=lista throws
element.type.arguments=argumentos de tipo
element.type.parameter=parámetro de tipo
element.type.parameters=parámetros de tipo
element.type.semicolon=punto y coma
element.unknown=elemento
element.variable=variable
else.without.if='else' sin 'if'
enum.constant.context=Constante enum ''{0}'' en ''{1}''
error.incompatible.type={0} no es compatible con {1}
error.incompatible.type.bad.lambda.return.type=Tipo de retorno incorrecto en expresión lambda\: {0} no se puede convertir a {1}
error.incompatible.type.declaration.for.the.method.reference.not.found=No se encuentra la declaración en tiempo de compilación para la referencia a método
error.incompatible.type.expected.non.void.got.void.method.reference=Tipos incompatibles\: se esperaba no void pero la declaración en tiempo de compilación para la referencia a método tiene tipo de retorno void
error.incompatible.type.expected.value.lambda=Tipos incompatibles\: se esperaba no void pero el cuerpo lambda es un bloque que no es compatible con valor
error.incompatible.type.failed.to.resolve.argument=No se pudo resolver el argumento
error.incompatible.type.incompatible.equality.constraint=Restricción de igualdad incompatible\: {0} y {1}
error.incompatible.type.incompatible.parameter.types.in.lambda=Número incorrecto de parámetros lambda\: se esperaban {0} pero se encontraron {1}
error.incompatible.type.incompatible.parameter.types.in.method.reference=Tipos de parámetros incompatibles en expresión de referencia a método
error.incompatible.type.incompatible.types.expected.not.void.got.void.method.reference=Tipos incompatibles\: se esperaba no void pero la declaración en tiempo de compilación para la referencia a método tiene tipo de retorno void
error.incompatible.type.incompatible.types.expected.void.lambda=Tipos incompatibles\: se esperaba void pero el cuerpo lambda no es ni una expresión de sentencia ni un bloque compatible con void
error.incompatible.type.no.type.variable=no existe(n) instancia(s) de variable(s) de tipo tal que {0}
error.incompatible.type.no.type.variable.0=no existe(n) instancia(s) de variable(s) de tipo {0} tal que {1}
error.incompatible.type.no.valid.function.type.found=No se puede encontrar un tipo de función válido para {0}
error.incompatible.type.not.a.functional.interface={0} no es una interface funcional
error.incompatible.type.not.convertible=Tipos incompatibles\: {0} no se puede convertir a {1}
error.incompatible.type.parameter.type.is.not.yet.inferred=El tipo de parámetro aún no se ha inferido\: {0}
error.incompatible.type.return.type.is.not.yet.inferred=El tipo de retorno aún no se ha inferido\: {0}
error.incompatible.type.unhandled.exception=Excepción no manejada\: {0}
error.incompatible.upper.bounds=Límites superiores incompatibles\: {0}
error.inference.variable.has.incompatible.bounds=La variable de inferencia {0} tiene límites incompatibles\:\n {1}\: {2}\n{3}\: {4}
error.message.wildcard.not.expected=Comodín inesperado
error.type.parameter.has.incompatible.upper.bounds=El parámetro de tipo {0} tiene límites superiores incompatibles\: {1}
expected.array.initializer=Se esperaba inicializador de array
expected.boolean.expression=Se esperaba expresión booleana
expected.case.label.element=Se esperaba expresión, patrón, 'default' o 'null'
expected.catch.or.finally=Se esperaba 'catch' o 'finally'
expected.class.or.interface=Se esperaba 'class' o 'interface'
expected.class.reference=Se esperaba referencia de clase
expected.colon=Se esperaba '\:'
expected.colon.or.arrow=Se esperaba '\:' o '->'
expected.comma=Se esperaba ','
expected.comma.or.rparen=Se esperaba ',' o ')'
expected.comma.or.semicolon=Se esperaba ',' o ';'
expected.dot=Se esperaba '.'
expected.eq=Se esperaba '\='
expected.expression=Se esperaba expresión
expected.gt=Se esperaba '>'
expected.gt.or.comma=Se esperaba '>' o ','
expected.identifier=Se esperaba identificador
expected.identifier.or.semicolon=se esperaba identificador o ';'
expected.identifier.or.type=Se esperaba identificador o tipo
expected.lbrace=Se esperaba '{'
expected.lbrace.or.semicolon=Se esperaba '{' o ';'
expected.lbracket=Se esperaba '['
expected.lparen=Se esperaba '('
expected.lparen.or.lbracket=Se esperaba '(' o '['
expected.lt.or.lparen=Se esperaba '<' o '('
expected.module.declaration=Se esperaba declaración de módulo
expected.module.statement=Se esperaba directiva de módulo
expected.package.reference=Se esperaba referencia de paquete
expected.parameter=Se esperaba parámetro
expected.parameter.or.rparen=se esperaba parámetro de anotación o ')'
expected.pattern=Se esperaba patrón
expected.rbrace=Se esperaba '}'
expected.rbracket=Se esperaba ']'
expected.resource=Se esperaba definición de recurso
expected.rparen=Se esperaba ')'
expected.semicolon=Se esperaba ';'
expected.statement=Se esperaba sentencia
expected.string=Se esperaba literal de cadena
expected.switch.label=Se esperaba 'case', 'default' o '}'
expected.switch.rule=Se esperaba expresión, bloque o sentencia throw
expected.template.fragment=Se esperaba fragmento de plantilla
expected.type=Se esperaba tipo
expected.type.parameter=Se esperaba parámetro de tipo
expected.value=Se esperaba valor
expected.while=Se esperaba 'while'
expected.with=Se esperaba 'with'
feature.advanced.collection.api=Métodos Lambda en colecciones
feature.annotations=Anotaciones
feature.assertions=Aserciones
feature.binary.literals=Literales binarios
feature.classfile.api=ClassFile API
feature.collection.factories=Métodos factory de colecciones
feature.diamond.types=Tipos Diamond
feature.effectively.final=Variables effectively final
feature.enhanced.switch=Bloque 'switch' mejorado
feature.enum.qualified.name.in.switch=Enums calificados como constantes en switch
feature.enums=Enums
feature.extension.methods=Métodos de extensión
feature.for.each=Bucle For-each
feature.foreign.functions=API de funciones externas y memoria
feature.generics=Genéricos
feature.hex.fp.literals=Literales hexadecimales de punto flotante
feature.implicit.classes=Clases implícitas
feature.implicit.import.in.implicit.classes=Import implícito en clases implícitas
feature.inherited.static.main.method=Método main static heredado
feature.inner.statics=Declaraciones static en clases internas
feature.instance.main.method=Método main de instancia
feature.intersections.in.casts=Tipos de intersección en casteos
feature.javadoc.snippets=@snippet en Javadoc
feature.lambda.expressions=Expresiones Lambda
feature.local.enums=Enums locales
feature.local.interfaces=Interfaces locales
feature.lvti=Inferencia de tipo de variable local
feature.method.references=Referencias a métodos
feature.module.import.declarations=Declaraciones de importación de módulos
feature.modules=Módulos
feature.multi.catch=Multi catch
feature.nestmates=Control de acceso basado en anidamiento
feature.no.this.capture=Clases internas no capturan 'this'
feature.objects.class=API java.util.Objects
feature.override.interface=@Override en interfaces
feature.pattern.guard.and.record.patterns=Guardas de patrón y patrones de registro
feature.patterns.in.switch=Patrones en switch
feature.patterns.instanceof=Patrones en 'instanceof'
feature.primitive.types.in.patterns=Tipos primitivos en patrones, instanceof y switch
feature.private.interface.methods=Métodos private en interfaces
feature.record.patterns.in.for.each=Patrones de registro en bucles for-each
feature.records=Records
feature.scoped.values=Valores con scope
feature.sealed.classes=Clases sealed
feature.sequenced.collections=Colecciones secuenciadas
feature.serial.annotation=Anotación @Serial
feature.statements.before.super=Sentencias antes de super()
feature.static.imports=Static import
feature.static.interface.calls=Llamadas a métodos static de interfaces
feature.stream.and.optional.api=API de Stream y Optional
feature.stream.gatherers=Stream Gatherer
feature.strictfp=Semántica de punto flotante siempre estricta
feature.string.switch=Strings en sentencias 'switch'
feature.string.templates=Templates de strings
feature.structured.concurrency=Concurrencia estructurada
feature.switch.expressions=Expresiones 'switch'
feature.text.block.escape.sequences=Secuencias de escape '\\s'
feature.text.blocks=Literales de bloque de texto
feature.try.with.resources=Try-with-resources
feature.try.with.resources.refs=Referencias de recursos
feature.type.annotations=Anotaciones de tipo
feature.type.receivers=Parámetros receptores
feature.underscores.in.literals=Guiones bajos en literales
feature.unnamed.vars=Patrones y variables sin nombre
feature.utf8.property.files=Archivos de propiedades en codificación UTF-8
feature.var.lambda.parameter='var' en parámetros lambda
feature.varargs=Métodos de aridad variable
feature.virtual.threads=Hilos virtuales
feature.with.initial=ThreadLocal.withInitial()
filetype.class.description=Clase Java
filetype.class.display.name=Clase Java
filetype.java.description=Java
filetype.java.module.description=Módulo Java
filetype.java.module.display.name=Módulo Java
filetype.jshell.description=Fragmento JShell
finally.without.try='finally' sin 'try'
implicit.class.context.display=Clase implícita
import.statement.identifier.or.asterisk.expected.=Se esperaba identificador o '*'
java.terms.anonymous.class.base.ref={0} anónimo
javadoc.exception.tag.class.is.not.throwable=La clase {0} no es descendiente de Throwable
javadoc.exception.tag.exception.is.not.thrown={0} no está declarado para ser lanzado por el método {1}
javadoc.exception.tag.wrong.tag.value=Valor de etiqueta incorrecto
javadoc.param.tag.parameter.name.expected=Se esperaba nombre de parámetro
javadoc.param.tag.type.parameter.gt.expected=Se esperaba '>'
javadoc.param.tag.type.parameter.name.expected=Se esperaba nombre de parámetro de tipo
javadoc.ref.tag.class.ref.expected=Se esperaba referencia de clase
javadoc.value.field.required=La etiqueta @value debe referenciar un campo
javadoc.value.field.with.initializer.required=La etiqueta @value debe referenciar un campo con un inicializador constante
javadoc.value.static.field.required=La etiqueta @value debe referenciar un campo static
javadoc.value.tag.jdk15.required=La etiqueta @value no puede tener argumentos cuando se usa JDK 1.4 o anterior
jdk.1.3.language.level.description=1.3 - Java clásico
jdk.1.4.language.level.description=1.4 - Palabra clave 'assert'
jdk.1.5.language.level.description=5 - Palabra clave 'enum', genéricos, autoboxing etc.
jdk.1.6.language.level.description=6 - @Override en interfaces
jdk.1.7.language.level.description=7 - Diamonds, ARM, multi-catch etc.
jdk.1.8.language.level.description=8 - Lambdas, anotaciones de tipo etc.
jdk.1.9.language.level.description=9 - Módulos, métodos private en interfaces etc.
jdk.10.language.level.description=10 - Inferencia de tipo de variable local
jdk.11.language.level.description=11 - Sintaxis de variable local para parámetros lambda
jdk.12.language.level.description=12 - Sin nuevas características de lenguaje
jdk.13.language.level.description=13 - Sin nuevas características de lenguaje
jdk.14.language.level.description=14 - Expresiones switch
jdk.15.language.level.description=15 - Bloques de texto
jdk.16.language.level.description=16 - Records, patrones, enums e interfaces locales
jdk.17.language.level.description=17 - Tipos sealed, semántica de punto flotante siempre estricta
jdk.18.language.level.description=18 - Fragmentos JavaDoc
jdk.19.language.level.description=19 - Sin nuevas características de lenguaje
jdk.20.language.level.description=20 - Sin nuevas características de lenguaje
jdk.21.language.level.description=21 - Patrones record, pattern matching para switch
jdk.21.preview.language.level.description=21 (Vista previa) - Plantillas de cadenas, clases sin nombre y métodos main de instancia etc.
jdk.22.language.level.description=22 - Variables y patrones sin nombre
jdk.22.preview.language.level.description=22 (Preview) - Sentencias antes de super(), templates de strings (segunda preview), etc.
jdk.23.language.level.description=23 - Comentarios de documentación Markdown
jdk.23.preview.language.level.description=23 (Preview) - Tipos primitivos en patrones, clases implícitas, etc.
jdk.X.language.level.description=X - Características experimentales
jdk.unsupported.preview.language.level.description={0} (Preview) - No soportado
lambda.body.must.be.a.statement.expression=El cuerpo lambda debe ser una expresión de sentencia
list.item.no.module=<sin módulo>
local.class.preposition=local
method.context.display={0}() en {1}
missing.return.value.lambda=Falta valor de retorno
node.abstract.flag.tooltip=abstract
node.annotation.tooltip=Anotación
node.anonymous.class.tooltip=Clase anónima
node.class.tooltip=Clase
node.enum.tooltip=Enum
node.exception.tooltip=Excepción
node.field.tooltip=Campo
node.final.flag.tooltip=Final
node.interface.tooltip=Interface
node.junit.test.tooltip=Test JUnit
node.method.tooltip=Método
node.record.tooltip=Record
node.runnable.class.tooltip=Clase Runnable
node.static.flag.tooltip=static
psi.error.attempt.to.edit.class.file=No se puede modificar el elemento compilado en el archivo ''{0}''
task.background.title.maven=Maven
type.can.be.converted={0} no se puede convertir a {1}
type.conforms.to.constraint={0} cumple con {1}
unexpected.identifier=Identificador inesperado
unexpected.return.value=Valor de retorno inesperado
unexpected.token=Token inesperado
unexpected.tokens=Tokens inesperados