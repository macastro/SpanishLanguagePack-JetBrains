DFAStrings.CppDFAArrayIndexOutOfBoundsDescription=Informa expresiones de acceso de variable de matriz o puntero donde el índice puede estar fuera de los límites de una matriz o búfer asignado
DFAStrings.CppDFAArrayIndexOutOfBoundsTitle=Expresiones de acceso a un arreglo donde el índice puede encontrarse fuera de límites
DFAStrings.CppDFAConstantConditionsDescription=Informa de condiciones que son siempre verdaderas o falsas y expresiones cuyo valor es estáticamente comprobado por ser constante
DFAStrings.CppDFAConstantConditionsTitle=Condiciones que son siempre verdaderas o falsas
DFAStrings.CppDFAConstantFunctionResultDescription=Informa sobre funciones donde el valor devuelto es siempre la misma constante
DFAStrings.CppDFAConstantFunctionResultTitle=Funciones cuyo valor de retorno es siempre la misma constante
DFAStrings.CppDFAConstantParameterDescription=Informa de los parámetros de función que siempre tienen el mismo valor
DFAStrings.CppDFAConstantParameterTitle=Parámetros de funciones que siempre tienen el mismo valor
DFAStrings.CppDFADeletedPointerDescription=Informa los usos de punteros que hacen referencia a memoria ya eliminada mediante el operador delete o la función free(void* ptr)
DFAStrings.CppDFADeletedPointerTitle=Usos de punteros que hacen referencia a memoria eliminada
DFAStrings.CppDFAEndlessLoopDescription=Informa sentencias 'for', 'while', 'do-while' y 'goto' que salen solo arrojando una excepción
DFAStrings.CppDFAEndlessLoopTitle=Sentencias de bucle infinito
DFAStrings.CppDFAInfiniteRecursionDescription=Informa sobre funciones que se llaman a sí mismas infinitamente a menos que se produzca una excepción
DFAStrings.CppDFAInfiniteRecursionTitle=Funciones que se llaman a sí mismas infinitamente
DFAStrings.CppDFAInvalidatedMemoryDescription=Informa referencias a los contenidos de contenedores invalidados
DFAStrings.CppDFAInvalidatedMemoryTitle=Referencias al contenido de contenedores no válidos
DFAStrings.CppDFALocalValueEscapesFunctionDescription=Informa las referencias a valores locales que escapan de la función mediante retornos, asignaciones a variables globales o campos
DFAStrings.CppDFALocalValueEscapesFunctionTitle=Referencias a valores locales que escapan de la función
DFAStrings.CppDFALocalValueEscapesScopeDescription=Reporta variables con referencias a las variables locales que escapan de su contexto
DFAStrings.CppDFALocalValueEscapesScopeTitle=Referencias a variables locales que se escapan de su alcance
DFAStrings.CppDFALoopConditionNotUpdatedDescription=Informa de condiciones de bucle no actualizadas dentro del bucle
DFAStrings.CppDFALoopConditionNotUpdatedTitle=Condiciones de bucle que no se actualizan dentro del bucle
DFAStrings.CppDFAMemoryLeakDescription=Informa sobre las asignaciones de memoria (usando 'new' o 'malloc()') que no fueron liberadas antes de ser inaccesibles
DFAStrings.CppDFAMemoryLeakTitle=Asignaciones de memoria que no fueron liberadas
DFAStrings.CppDFANotInitializedFieldDescription=Informa sobre los campos que pueden no haberse inicializado antes de usarse. La inicialización y el uso pueden ocurrir en funciones diferentes.
DFAStrings.CppDFANotInitializedFieldTitle=Campos que posiblemente no se hayan inicializado antes de su uso
DFAStrings.CppDFANullDereferenceDescription=Informa sobre cancelaciones de referencia de punteros que pueden contener un valor nulo
DFAStrings.CppDFANullDereferenceTitle=Desreferencias de punteros que pueden contener nullptr
DFAStrings.CppDFATimeOverDescription=La inspección de flujo de datos ha llegado a un límite de tiempo o memoria y no puede ser evaluada en modo sensible o insensible al contexto.
DFAStrings.CppDFATimeOverTitle=Inspección de flujo de datos agotada
DFAStrings.CppDFAUnreachableCodeDescription=Informa partes del código que nunca son ejecutadas en ningún flujo de control y que pueden eliminarse de forma segura
DFAStrings.CppDFAUnreachableCodeTitle=Código inalcanzable
DFAStrings.CppDFAUnreachableFunctionCallDescription=Informa las funciones cuyas llamadas nunca se utilizan. Tales funciones tampoco se ejecutan nunca.
DFAStrings.CppDFAUnreachableFunctionCallTitle=Funciones con llamadas que nunca se utilizan
DFAStrings.CppDFAUnreadVariableDescription=Reporta las variables locales que están declaradas pero nunca accedidas para lectura
DFAStrings.CppDFAUnreadVariableTitle=Variables locales declaradas pero nunca leídas
DFAStrings.CppDFAUnusedValueDescription=Variable no usada ni asignada
DFAStrings.CppDFAUnusedValueTitle=Valores de variables nunca usados después de ser asignados
Strings.AClassDefinitionCanBeMarkedAsFinalSoItCannotBeInheritedFrom=Una definición de clase puede ser marcada como final para evitar poder ser heredada
Strings.AClassIsNeverUsed=Clase no usada
Strings.ACoroutineRelatedFunctionWhichIsRequiredByTheCStandardCannotBeResolved=No se puede resolver una función relacionada con corrutinas que es necesaria para el estándar C++20
Strings.ADeclarationDoesNotDeclareAnything=Una declaración no declara nada
Strings.ADeclarationSpecifierIsIgnoredWhenThereAreNoDeclarators=Un especificador de declaración se ignora cuando no hay declaradores
Strings.ADeclaratorIsNeverUsed=El declarador no se utiliza nunca
Strings.ADeclaratorIsOnlyAssignedButNeverAccessed=Un declarador es solo asignado pero nunca accedido
Strings.ADeclaratorIsUsedOnlyInUnevaluatedContext=Un declarador solo se utiliza en un contexto no evaluado
Strings.AEnumeratorIsNeverUsed=Un enumerador nunca se utiliza
Strings.AFormatStringOfBoostFormatContainsALegacyPrintfLikeCodeTypeSpecifierIsNotTakenIntoAccount=Una cadena de formato de boost::format contiene un código tipo printf heredado; no se tiene en cuenta el especificador de tipo
Strings.AFormatStringOfBoostFormatContainsAnErroneousFormatCode=Una cadena de formato de boost::format contiene una directiva de formato errónea
Strings.AFunctionDefinitionInAHeaderFileThatWillCauseMultipleDefinitionLinkageError=Una definición de función en un archivo de encabezado que causará un error de vinculación de definición múltiple
Strings.AFunctionIsNotImplemented=Función no implementada
Strings.AFunctionOrALambdaWithNonVoidReturnTypeShouldReturnAValue=Una función o una lambda con un tipo de retorno no vacío debería devolver un valor
Strings.AFunctionOrALambdaWithNonVoidReturnTypeShouldReturnAValue8=Una función o una lambda con un tipo de retorno que no es vacío debe devolver un valor
Strings.ALambdaCaptureIsNeverUsed=Una captura lambda nunca se utiliza
Strings.ALocalDeclarationHidesAnotherLocalDeclaration=Una declaración local oculta otra declaración local
Strings.ALocalDeclarationInsideALambdaHidesAnUncapturedLocalDeclaration=Una declaración local dentro de una lambda oculta una declaración local no capturada
Strings.ALocalVariableMightNotBeInitialized=Una variable local puede no estar inicializada
Strings.ANonOverridingVirtualFunctionInAFinalOrSealedClassCannotBeOverriddenSoThevirtualSpecifierIsRedundant=Una función virtual no sobreescrita en una clase final o sellada no se puede sobrescribir, por lo que el especificador 'virtual' es redundante
Strings.ANumericTypeCanBeReplacedWithauto=Un tipo numérico se puede reemplazar por 'auto'
Strings.APolymorphicClassWithANonVirtualPublicDestructor=Clase polimórfica con un destructor público no-virtual
Strings.APrivateSpecialMemberFunctionShouldBeDefinedOrDeleted=Una función miembro privada especial debe definirse o eliminarse
Strings.AStandardAlgorithmAcceptingRangeIteratorsIsUsedInsteadOfTheVariantAcceptingAnIteratorAndACount=Se utiliza un algoritmo estándar que acepta iteradores de rango, en lugar de la variante que acepta un iterador y un conteo
Strings.ATemplateParameterFromAnOuterScopeIsShadowedByADeclarationWithTheSameName=Un parámetro de plantilla de un ámbito externo está sombreado por una declaración con el mismo nombre
Strings.ATypeAliasIsNeverUsed=Un alias de tipo nunca se utiliza
Strings.ATypeTraitCanBeSimplifiedUsingATemplateAliasOrAVariableTemplate=Un atributo de tipo puede simplificarse utilizando un alias de plantilla o una plantilla de variable
Strings.AVariableDefinitionInAHeaderFileThatWillCauseMultipleDefinitionLinkageError=Definición de variable en un archivo de encabezado que causará un error de vínculo de definición múltiple
Strings.AVirtualFunctionIsMarkedfinalAndDoesNotOverrideABaseFunction=Una función virtual está marcada como 'final' y no sobrescribe una función base
Strings.AbstractFinalClass=Clase final abstracta
Strings.AccessSpecifierDoesNotAffectAnyDeclaration=El especificador de acceso no afecta a ninguna declaración
Strings.AccessSpecifierDoesNotChangeAccessibilityLevel=Un especificador de acceso no cambia el nivel de accesibilidad
Strings.AddingCvQualifiersToReferencesHasNoEffect=Añadir cv-calificadores a referencias no tiene ningún efecto
Strings.AddingCvQualifiersToReferencesHasNoEffect9=Agregar calificadores cv a referencias no tiene efecto
Strings.AlgorithmAcceptingAnIteratorAndACountCanBeUsed=Algoritmo que acepta un iterador y un contador puede ser utilizado
Strings.AlgorithmAcceptingIteratorsIsUsedInsteadOfTheCorrespondingAlgorithmFromStdRanges=El algoritmo que acepta iteradores se usa en lugar del algoritmo correspondiente de std::ranges
Strings.AlgorithmOperatingOnRangesCanBeUsed=Se puede usar un algoritmo que opera en intervalos
Strings.AnAbstractFinalClassIsMarkedAsfinalOrsealed=Una clase final abstracta está marcada como 'final' o 'sealed'
Strings.AnAccessSpecifierDoesNotAffectAnyDeclarationAndIsRedundant=Un especificador de acceso no afecta a ninguna declaración y es redundante
Strings.AnAccessSpecifierDoesNotChangeAccessibilityLevelAndIsRedundant=Un especificador de acceso no cambia el nivel de accesibilidad y es redundante
Strings.AnArgumentOfBoostFormatShouldContainEitherPositionalNNOrSerialsArgumentsNotBoth=Un argumento de boost::format debe incluir argumentos seriales (%|...|, %s) o argumentos posicionales (%N%, %|N$...|), no ambos
Strings.AnIncompleteTypeIsUsedInsideATemplateDeclarationOrDefinition=Un tipo incompleto es usado en la declaración o definición de plantilla
Strings.AnObjectMemberMightNotBeInitialized=Es posible que el miembro de un objeto no haya sido inicializado
Strings.AnOverrideFunctionRedefinesADefaultParameterArgumentPreviouslyDefinedInABaseFunction=Una función de anulación redefine un argumento de parámetro predeterminado, previamente definido en una función base
Strings.AwaiterTypeIsNotAClass=El tipo Awaiter no es una clase
Strings.BackslashAndNewlineAreSeparatedBySpace=La barra invertida y el salto de línea están separados por espacio
Strings.BackslashIsNotALineContinuatorBecauseThereIsASpaceBetweenItAndTheEndOfTheLine=El carácter de barra invertida no es un continuador de línea porque hay un espacio entre él y el final de la línea
Strings.BadFormatCodeForBoostFormat=Directiva de formato incorrecta en boost::format
Strings.BinaryOperatorActsOnEqualOperands=Los operadores binarios operan sobre operandos iguales
Strings.BinaryOperatorActsOnEqualOperands40=El operador binario actúa en operandos iguales
Strings.BinaryOperatorActsOnIdenticalOperands=Operador binario actúa sobre operandos idénticos
Strings.BinaryOperatorActsOnIdenticalOperands39=El operador binario actúa sobre operandos idénticos
Strings.BindingRValueToLValueReferenceIsNonStandardMicrosoftCExtension=Enlazar un valor r a una referencia de l es una extensión no estándar de Microsoft C++
Strings.BindingRValueToLValueReferenceIsNonStandardMicrosoftCExtension2=Vincular un valor r a una referencia l es una extensión de Microsoft C++ no estándar
Strings.BracesCanBeSafelyRemovedWithoutChangingCodeSemantics=Las llaves se pueden eliminar de forma segura sin modificar la semántica del código
Strings.CStyleCastIsUsedInsteadOfACCast=Utilizar la conversión de tipo al estilo C en lugar de una conversión de tipo C++
Strings.CStyleCastIsUsedInsteadOfACCast1=Se usa una conversión de estilo C en lugar de una conversión de C++
Strings.CallOfDeletedCopyConstructorElidedDuringCopyInitializationThisIsNonStandardMicrosoftCExtension=Llamada al constructor de copia eliminado eliminada durante la inicialización de copia. Esta es una extensión de Microsoft C++ no estándar.
Strings.CallOfDeletedCopyConstructorElidedDuringCopyInitializationThisIsNonStandardMicrosoftCExtension5=Se omitió la llamada al constructor de copia eliminado durante la inicialización de copia. Esta es una extensión de Microsoft C++ no estándar.
Strings.CallToAVirtualFunctionInsideAConstructorDestructorIsResolvedAtCompileTime=La llamada a una función virtual en un constructor o destructor se resuelve en tiempo de compilación
Strings.CallToAVirtualFunctionInsideAConstructorDestructorWillResultInAPureVirtualFunctionCall=Llamada a una función virtual dentro de un constructor/destructor resultará en una llamada a una función virtual pura
Strings.CallsToPureVirtualFunctionsInsideConstructorsAndDestructorsAreARuntimeError=Las llamadas a funciones virtuales puras dentro de constructores y destructores generarán errores en tiempo de ejecución
Strings.CannotResolveARequiredCoroutineFunction=No se puede resolver una función corrutina obligatoria
Strings.CastIsRedundantAndCanBeDeleted=El cast es redundante y puede eliminarse
Strings.CastingFromNullptrToPointerTypeWithReinterpretCastIsNonStandardMicrosoftCExtension=Castear from nullptr a tipo puntero con reinterpretcast es una extensión de Microsoft C++ no estándar
Strings.CastingFromNullptrToPointerTypeWithReinterpretCastIsNonStandardMicrosoftCExtension1=Convertir de nullptr a tipo puntero con reinterpretcast es una extensión de Microsoft C++ no estándar
Strings.ClassCanBeMadeFinal=La clase puede ser final
Strings.ClassConstructorDoesntInitializeAFieldExplicitlyOrImplicitly=El constructor de clase no inicializa un campo explícita ni implícitamente
Strings.ClassIsAbstractButNotExplicitlyDeclaredAsSuch=La clase es abstracta, pero no se ha declarado explícitamente como tal
Strings.ClassIsNeverUsed=La clase no se usa nunca
Strings.ClassMemberFunctionHidesANonVirtualFunctionFromABaseClass=La función miembro de la clase oculta una función no virtual de una clase base
Strings.ClassMemberFunctionHidingANonVirtualFunctionFromABaseClass=Función miembro de la clase que oculta una función no virtual de una clase base
Strings.ClassShouldHaveAUserDefinedConstructorBecauseOfAnUninitializedDataMember=La clase debería tener un constructor definido por el usuario debido a un miembro de datos sin inicializar
Strings.ClassShouldHaveAUserDefinedConstructorBecauseOfAnUninitializedDataMember25=La clase debería tener un constructor definido por el usuario debido a un miembro de datos no inicializado.
Strings.ComparisonOfUnsignedExpressionWith=Comparación de expresión sin signo con 0
Strings.ComparisonOfUnsignedExpressionWith41=Comparación de la expresión sin signo con 0
Strings.CompileTimeConstantExpressionCanBeReplacedByEithertrueOrfalse=La expresión constante de tiempo de compilación puede sustituirse por 'true' o 'false'
Strings.CompileTimeIntegralConstantExpressionOrNullptrIsConvertedToBoolAndCanBeReplacedBytrueOrfalse=Expresión de constante integral en tiempo de compilación o nullptr se convierte a bool y puede ser reemplazada por 'true' o 'false'
Strings.ConceptIsNeverUsed=El concepto nunca es usado
Strings.ConstQualificationOfParametersHasAnEffectOnlyInFunctionDefinitions=La calificación `const` de parámetros sólo tiene efecto en las definiciones de funciones
Strings.ConstQualifiedParameterInAFunctionDeclaration=Parámetro calificado como constante en una declaración de función
Strings.ConstevalIfIsAlwaysConstantDescription=consteval if siempre es constante
Strings.ConstevalIfIsAlwaysConstantTitle=consteval if siempre es constante
Strings.ConstructorOfASmartPointerBoostStdSharedPtrUniquePtrIsUsedInsteadOfTheCorrespondingMakeSharedMakeUniqueMakeFunctionsAreExceptionSafeAndMoreEfficient=Se usa el constructor de un apuntador inteligente (boost/std::sharedptr/uniqueptr), en lugar del makeunique/makeshared correspondiente. Las funciones `make` son seguras para excepciones y más eficientes.
Strings.ConstructorOfSmartPointerIsUsedInsteadOfItsMakeFunction=Se usa el constructor del puntero inteligente en lugar de su función make
Strings.CppConditionalExpressionCanBeSimplifiedDescription=Se puede simplificar la expresión condicional
Strings.CppConditionalExpressionCanBeSimplifiedTitle=Se puede simplificar la expresión condicional
Strings.CppEvaluationFailureDescription=El valor de la expresión o del declarador no se evaluó como una constante debido a un error durante los cálculos 'constexpr'.
Strings.CppEvaluationFailureTitle=Error en la evaluación en tiempo de compilación
Strings.CppEvaluationInternalFailureTitle=[INTERNO] Error de evaluación en tiempo de compilación
Strings.CppRedundantComplexityInComparison=La expresión se puede simplificar
Strings.CppRedundantConditionalExpressionDescription=Expresión condicional redundante
Strings.CppRedundantConditionalExpressionTitle=Expresión condicional redundante
Strings.CppRedundantDereferencingAndTakingAddressDescription=Desreferencia y toma de dirección redundantes
Strings.CppRedundantDereferencingAndTakingAddressTitle=Obtención de dirección y desreferenciación redundantes
Strings.DeclarationAndAssignmentCanBeJoined=Se puede unir declaración y asignación
Strings.DeclarationDoesNotDeclareAnything=La declaración no declara nada
Strings.DeclarationOfANonOverridingVirtualFunctionInAFinalOrSealedClass=Declaración de una función virtual no anulable en una clase final o sellada
Strings.DeclarationOfAVariableAndAssignmentToItCanBeJoined=Declaración y asignación de una variable se puede unir
Strings.DeclarationSpecifierWithNoDeclarators=Especificador de declaración sin declaradores
Strings.DeclarationSpecifierlongCanNotBeCombinedWithfloat=El especificador de declaración 'long' no puede combinarse con 'float'
Strings.DeclaratorDisambiguatedAsAFunctionDeclaration=Declarador desambiguado como declaración de función
Strings.DeclaratorIsDisambiguatedAsAFunctionDeclarationMakeSureAVariableDefinitionIsNotIntendedInstead=Declarador se confunde con una declaración de función. Asegúrate de que no se quiera una definición de variable
Strings.DeclaratorIsNeverUsed=El declarador nunca se usa
Strings.DeclaratorIsOnlyAssignedButNeverAccessed=El declarador solo se asigna, pero nunca se accede
Strings.DeclaratorIsUsedOnlyInUnevaluatedContext=El declarador se utiliza sólo en un contexto no evaluado
Strings.DefaultCaseIsNotHandledInASwitchStatement=El caso predeterminado no está gestionado en una sentencia switch
Strings.DefaultCaseIsNotHandledInASwitchStatement20=El caso por defecto no está contemplado en la declaración de este switch
Strings.DefaultInitializationOfAConstQualifiedObjectOfATypeWithoutAUserProvidedDefaultConstructor=Inicialización por defecto de un objeto const de un tipo sin un constructor por defecto proporcionado por el usuario
Strings.DefaultInitializationOfAConstQualifiedObjectOfATypeWithoutAUserProvidedDefaultConstructor3=Inicialización predeterminada de un objeto const calificado de un tipo sin un constructor predeterminado proporcionado por el usuario
Strings.DefaultedSpecialMemberFunctionIsImplicitlyDeleted=Función miembro especial por defecto eliminada implícitamente
Strings.DeletingAVoidPointer=Eliminando apuntador nulo
Strings.DeletingAVoidPointerIsUndefinedBehavior=Eliminar un puntero vacío es un comportamiento indefinido
Strings.DependentTemplateWithouttemplateKeyword=Dependencia de plantilla sin clave 'template'
Strings.DependentTemplateWithouttemplateKeyword24=Plantilla dependiente sin la palabra clave "plantilla"
Strings.DependentTypeWithouttypenameKeyword=Tipo dependiente sin la palabra clave "typename"
Strings.DependentTypeWithouttypenameKeyword23=Tipo dependiente sin la palabra clave "typename"
Strings.DeprecatedregisterStorageClassSpecifier=Especificación de clase de almacenamiento 'register' obsoleta
Strings.DereferenceOperatorLimitIsExceeded=Se excedió el límite del operador de desreferenciación
Strings.DereferenceOperatorLimitIsExceeded10=Se sobrepasó el límite del operador de desreferenciación
Strings.DetectsLeakProneResourceAcquisitionFreeingConstructs=Detecta construcciones propensas a fugas en la adquisición/liberación de recursos
Strings.DontIntroduceANamespaceDefinitionOnlyForClassSpecializationSpecializationCanBeDefinedUsingQualifiedClassName=No introduzca una definición de espacio de nombres solo para la especialización de clases. La especialización se puede definir usando el nombre de clase calificado
Strings.DontIntroduceAVariableBeforeYouNeedToUseIt=No introduzcas una variable antes de que necesites utilizarla
Strings.ElaboratedTypeSpecifierIsRedundantAndCanBeDeleted=El especificador de tipo elaborado es redundante y puede eliminarse
Strings.EmptyParameterListInLambdaDeclaratorCanBeDeleted=Se puede eliminar la lista vacía de parámetros en el lambda declarator
Strings.EnforceBracesIndoWhileStatement=Hacer obligatorio el uso de llaves en sentencia 'do-while'
Strings.EnforceBracesInforStatement=Forzar llaves en declaración 'for'
Strings.EnforceBracesInifStatement=Exigir llaves en la sentencia 'if'
Strings.EnforceBracesInwhileStatement=Exigir llaves en la sentencia 'while'
Strings.EnforceFunctionDeclarationStyle=Forzar estilo de declaración de función
Strings.EnforceNestedNamespacesStyle=Aplicar estilo de espacios de nombres anidados
Strings.EnforceOverridingDestructorStyle=Aplicar estilo de sobreescritura de destructores
Strings.EnforceOverridingFunctionStyle=Exigir estilo de función de invalidación
Strings.EnforceTheOrderOfCvQualifiers=Imponer orden de los cv-calificadores
Strings.EnforceTheOrderOfCvQualifiers_Description=Imponer el orden de los calificadores cv
Strings.EnforceThePlacementOfCvQualifiers=Exigir la ubicación de cv-calificadores
Strings.EnforceThePlacementOfCvQualifiers_Description=Impone la ubicación de los calificadores cv
Strings.EnforceTheSyntaxUsedToDefineNestedNamespaces=Aplicar la sintaxis usada para definir espacios de nombres anidados
Strings.EnforceThevirtualAndoverrideSpecifiersOnOverridingDestructors=Exige los especificadores 'virtual' y 'override' en las destrucciones de anulación
Strings.EnforceThevirtualAndoverrideSpecifiersOnOverridingFunctions=Imponer especificadores 'virtual' y 'override' en funciones de anulación
Strings.EnforceTypeAliasCodeStyle=Forzar el estilo del código con alias de tipo
Strings.EnforceUsageOfTheTrailingReturnTypeOrTheRegularReturnTypeSyntax=Imponer el uso del tipo de retorno posterior o la sintaxis de tipo de retorno regular
Strings.EnforceUsageOfTypedefsOrTypeAliasesDependingOnTheSyntaxStyleSetting=Imponer el uso de typedefs o alias de tipo dependiendo de la configuración del estilo de sintaxis
Strings.EntityIsDeprecated=La entidad ha quedado obsoleta
Strings.EntityIsDeprecated37=La entidad está obsoleta
Strings.EnumeratorIsNeverUsed=El iterador nunca se utiliza
Strings.ExplicitSpecializationInNonNamespaceScope=Especialización explícita en ámbito sin namespace
Strings.ExplicitSpecializationsOfATemplateInNonNamespaceScope=Especializaciones explícitas de una plantilla en ámbito fuera del espacio de nombres
Strings.ExplicitlyDefaultedSpecialMemberFunctionIsImplicitlyDeleted=Función miembro especial con valor predeterminado explícito está implícitamente eliminada
Strings.ExpressionWhichEvaluatesToZeroIsUsedAsANullPointerConstant=Expresión que evalúa a cero se utiliza como una constante de puntero nulo
Strings.ExpressionWhichEvaluatesToZeroIsUsedAsANullPointerConstant27=Expresión que evalúa a cero es usada como constante de puntero nulo
Strings.FinalFunctionInAFinalClass=Función final en una clase final
Strings.FinalNonOverridingVirtualFunction=Función virtual final no sobreescribible
Strings.ForExampleWhenIteratingOnKeyValuePairsStdViewsKeysAllowsToIgnoreTheValues=Por ejemplo, a la hora de iterar sobre pares clave-valor, std::views::keys permite ignorar los valores.
Strings.ForLoopCanBeReplacedWithWhileLoop=El for-loop puede reemplazarse con un while-loop
Strings.ForLoopWithoutInitStatementAndUpdateExpressionIsEquivalentToWhileLoop=El for-loop sin instrucción de inicialización y expresión de actualización es equivalente al while-loop
Strings.FormatStringContainsAPotentialError=La cadena de formato contiene un error potencial
Strings.FormatStringContainsAnInvalidPrintfFormatSpecifier=La cadena de formato contiene un especificador de formato printf no válido
Strings.ForwardEnumDeclarationWithoutUnderlyingTypeDescription=ISO C++ prohíbe las declaraciones avanzadas de una enumeración sin un tipo base
Strings.ForwardEnumDeclarationWithoutUnderlyingTypeTitle=Declaración de enum sin tipo subyacente
Strings.FunctionIsNotImplemented=Función no implementada
Strings.FunctionParameterIsNeverUsed=El parámetro de la función nunca se utiliza
Strings.FunctionResultShouldBeUsedDescription=La función devuelve un valor de un tipo que debe ser manejado en el sitio de llamada
Strings.FunctionResultShouldBeUsedTitle=El resultado de la función debe ser usado
Strings.FunctionReturnsByConstValue=La función devuelve un valor de const
Strings.FunctionalStyleCastIsUsedInsteadOfACCast=Se usa conversión de estilo funcional en lugar de conversión en C++
Strings.FunctionalStyleCastIsUsedInsteadOfACCast2=Se usa el cast de estilo funcional en vez de un cast de C++
Strings.GuardedHeaderHasAlreadyBeenIncluded=Ya se ha incluido el header con guards
Strings.GuardedHeaderHasAlreadyBeenIncluded50=Ya se ha incluido la cabecera protegida
Strings.HidingAnUncapturedLocalDeclaration=Ocultando una declaración local no capturada
Strings.HidingLocalDeclaration=Ocultación de la declaración local
Strings.IfStatementWithConstantConditionCanBeReplacedByifConstexpr=La sentencia if con condición constante se puede reemplazar con 'if constexpr'
Strings.IfStatementWithConstantConditionCanBeReplacedByifConstexpr14=La sentencia if con una condición constante se puede reemplazar por "if constexpr"
Strings.IfStdIsConstantEvaluatedCanBeReplacedDescription="if" puede ser reemplazado por "if consteval"
Strings.IfStdIsConstantEvaluatedCanBeReplacedTitle='if' puede ser reemplazado por 'if consteval'
Strings.ImplicitConversionToIncompatiblePointerType=Conversión implícita a tipo de puntero incompatible
Strings.ImplicitConversionToIncompatiblePointerType32=Conversiones implícitas a tipo de puntero incompatible
Strings.ImplicitConversionToLessQualifiedPointerType=Conversión implícita a tipo puntero con pérdida de calificadores
Strings.ImplicitConversionToLessQualifiedPointerType33=Conversión implícita a tipo puntero con pérdida de calificadores
Strings.ImplicitDefaultConstructorIsNotAvailable=El constructor predeterminado implícito no está disponible
Strings.ImplicitDefaultConstructorIsNotAvailableBecauseABaseClassOrAClassMemberDoesNotHaveAnAccessibleDefaultConstructor=El constructor implícito por defecto no está disponible porque una clase base o un miembro de clase no tiene un constructor por defecto accesible
Strings.ImplicitIntegerToPointerConversion=Conversión implícita de entero a puntero
Strings.ImplicitIntegerToPointerConversion30=Conversión implícita de entero a puntero
Strings.ImplicitPointerToIntegerConversion=Conversión implícita de puntero a entero
Strings.ImplicitPointerToIntegerConversion31=Conversión implícita de puntero a entera
Strings.InHLSLoutParametersMustBeAssignedBeforeExitingTheFunction=En HLSL, los parámetros 'out' deben ser asignados antes de salir de la función
Strings.IncludeGuardIsNotFoundAtTheBeginningOfAHeaderFile=No se encontró la protección de includes al principio del archivo de cabecera
Strings.InconsistentNaming_Description=El nombre no coincide con el estilo de nombres definido para este tipo de símbolo
Strings.InconsistentNaming_Text=Nombres inconsistentes
Strings.IncorrectSpacing=Espaciado incorrecto
Strings.IncrementingExpressionOfTypeBool=Incrementa la expresión de tipo bool
Strings.IncrementingExpressionOfTypeBoolIsDeprecatedInCAndRemovedInC=El incremento de la expresión de tipo bool está desaprobado en C++11 y eliminado en C++17
Strings.InvalidPrintfFormatSpecifier=Especificador de formato printf no válido
Strings.KeyworddefaultIsUsedAsIdentifier=Se utiliza como identificador la palabra clave "default"
Strings.LambdaCanBeRewrittenToUseExplicitTemplateParameters=La lambda se puede reescribir para utilizar parámetros de plantilla explícitos
Strings.LambdaCanBeRewrittenToUseExplicitTemplateParameters19=Lambda se puede reescribir para usar parámetros de plantilla explícitos
Strings.LambdaCaptureIsNeverUsed=La captura lambda nunca se utiliza
Strings.LegacyFormatCodeForBoostFormat=Directiva de formato obsoleta en boost::format
Strings.LocalVariableCanBeMadeConst=Variable local puede declararse como constante
Strings.LocalVariableCanBeMadeConst8=La variable local puede ser const
Strings.LocalVariableIsNeverUsedButMayHaveSideEffectsInItsDestructor=Variable local nunca utilizada, pero puede tener efectos secundarios en su destructor
Strings.LocalVariableIsNeverUsedButMayHaveSideEffectsInItsDestructor4=Variable local nunca utilizada pero puede tener efectos colaterales en su destructor
Strings.LocalVariableMightNotBeInitialized=La variable local pudiera no estar inicializada
Strings.LocalVariableUsedWithoutBeingInitialized=Variable local utilizada sin ser inicializada
Strings.LocalVariableUsedWithoutBeingInitialized5=La variable local se usa sin inicializarse
Strings.MayBeMissingKeywordthrow=Puede que falte la palabra clave 'throw'
Strings.MemberFunctionCanBeMadeConst=La función miembro se puede hacer constante
Strings.MemberFunctionCanBeMadeConst6=Función miembro se puede hacer const
Strings.MemberFunctionCanBeMadeStatic=La función miembro puede hacerse estática
Strings.MemberFunctionCanBeMadeStatic7=La función miembro puede volverse static
Strings.MethodMustBePublicAndVirtualToImplementACCLIInterfaceMember=El método debe ser "public" y "virtual" para implementar un miembro de la interfaz de C++/CLI
Strings.MethodMustBePublicAndVirtualToImplementACCLIInterfaceMember29=El método debe ser público y virtual para implementar un miembro de la interfaz C++/CLI
Strings.MismatchedClassTags=Etiquetas de clase disparejas
Strings.MissingFunctionParameterDescriptionInADocumentationComment=Falta en un comentario de documentación la descripción del parámetro de función
Strings.MissingFunctionParameterDescriptionInADocumentationComment38=Falta la descripción del parámetro de la función en un comentario de documentación
Strings.MissingIncludeGuard=Falta protección de inclusión
Strings.MixedSerialAndPositionalArgumentsForBoostFormat=Argumentos posicionales y no posicionales en la misma llamada boost::format
Strings.MoreThanOneImplicitConversionAppliedDuringCopyInitializationThisIsNonStandardMicrosoftCExtension=Se aplicó más de una conversión implícita durante la inicialización de la copia. Esta es una extensión de Microsoft C++ que no es estándar.
Strings.MoreThanOneImplicitConversionAppliedDuringCopyInitializationThisIsNonStandardMicrosoftCExtension4=Se aplicó más de una conversión implícita durante la inicialización de copia. Esto es una extensión no estándar de Microsoft C++
Strings.MultiCharacterLiteralDescription=Literal de carácter multi-carácter
Strings.MultiCharacterLiteralTitle=Literal de caracteres múltiples
Strings.MultiCharacterWideLiteralDescription=Literal de carácter ancho de múltiples caracteres
Strings.MultiCharacterWideLiteralTitle=Literal de carácter ancho de varios caracteres
Strings.NamespaceDefinitionContainingSingleClassSpecialization=Definición de namespace que contiene una única especialización de clase
Strings.NoCorrespondingFileWithThePrecompiledHeaderPropertySetToCreateYcIsFound=No se encuentra el archivo correspondiente con la propiedad 'Encabezado precompilado' establecida como 'Crear' (/Yc)
Strings.NoReturnStatementInAFunctionOrALambdaReturningNonVoid=No hay declaración de retorno en una función o lambda que devuelve no nulo
Strings.NoReturnStatementInAFunctionOrALambdaWithNonVoidReturnType=No hay una instrucción de return en una función o una lambda con un tipo de retorno no void
Strings.NoTypeSpecifierFoundInADeclarationDefaultsToint=No se encontró especificador de tipo en una declaración. Por defecto 'int'.
Strings.NodiscardCannotBeAppliedToFunctionsWithoutAReturnValue=[[nodiscard]] no se puede aplicar a funciones sin un valor de retorno
Strings.NonExplicitConversionOperator=Operador de conversión no explícito
Strings.NonExplicitConversionOperator5=Operador de la conversión no explícita
Strings.NonExplicitConvertingConstructor=Constructor de conversión no explícito
Strings.NonExplicitConvertingConstructor4=Constructor de conversión no explícito
Strings.NonInlineFunctionDefinitionInAHeaderFile=Definición de función no en línea en un archivo de encabezado
Strings.NonInlineVariableDefinitionInAHeaderFile=Definición de variable no en línea en un archivo de encabezado
Strings.NonSafeResourceAcquisition=Adquisición de recursos no segura
Strings.NonStaticDataMemberIsUninitialized=El miembro de datos no estático no está inicializado
Strings.NonStaticDataMemberIsUninitialized26=El miembro de datos no estático no se ha inicializado
Strings.NonVirtualClassMemberFunctionHiddenInADerivedClass=Función miembro de clase no virtual oculta en una clase derivada
Strings.NonVirtualClassMemberFunctionIsHiddenInADerivedClass=La función miembro de clase no virtual se oculta en una clase derivada
Strings.NotAllControlPathsInsideAFunctionOrALambdaReturnAValue=No todos los caminos de control dentro de una función o lambda devuelven un valor
Strings.NotAllControlPathsReturnAValue=No todos los caminos de control retornan un valor
Strings.NotEnoughArgumentsInACallToBoostFormat=No se proporcionan suficientes argumentos en una llamada a boost::format
Strings.NotEnoughArgumentsInACallToBoostFormat36=Falta de argumentos en una llamada a boost::format
Strings.NotEnoughArgumentsInACallToPrintf=Número insuficiente de argumentos en una llamada a printf
Strings.NotEnoughArgumentsInACallToPrintfSomeFormatCodesDoNotHaveAMatchingArgument=Faltan argumentos en una llamada a printf. Algunas directivas de formato no tienen un argumento coincidente.
Strings.NotInitializedStaticConstLocalVariableOfScalarTypeThisIsNonStandardMicrosoftCExtension=Variable local const static no inicializada de tipo escalar. Esta es una extensión no estándar de Microsoft C++
Strings.NumericTypeCanBeReplacedWithAuto=El tipo numérico se puede reemplazar con automático
Strings.ObjectMemberMightNotBeInitialized=El miembro del objeto podría no estar inicializado
Strings.ObjectOfExceptionTypeIsCreatedButIsNotThrown=Se crea un objeto del tipo de excepción, pero no se lanza
Strings.OrderOfIncludeDirectivesDoesNotMatchCodeStyleSettings=El orden de las directivas #include no coincide con la configuración del estilo de código
Strings.OrderOfIncludeDirectivesDoesNotMatchCodeStyleSettings1=El orden de las directivas #include no coincide con la configuración del estilo del código
Strings.OrderOfMemberInitializersDoesNotMatchTheInitializationOrder=El orden de los inicializadores de miembros no coincide con el orden de inicialización
Strings.OrderOfMemberInitializersDoesNotMatchTheInitializationOrder3=El orden de los inicializadores de miembro no coincide con el orden de inicialización
Strings.OverrideFunctionRedefinesADefaultParameterArgument=La función sobreescrita redefine un argumento de parámetro predeterminado
Strings.ParameterCanBeMadeConst=El parámetro puede hacerse const
Strings.ParameterCanBeMadeConst9=El parámetro se puede hacer const
Strings.ParameterCanBeMadePointerReferenceToConst=El parámetro puede ser un puntero/referencia a const
Strings.ParameterCanBeMadePointerReferenceToConst11=El parámetro puede ser un puntero/referencia a const
Strings.ParameterIsNeverUsed=El parámetro nunca se usa
Strings.ParameterNamesDifferInDifferentDeclarationsOfTheSameFunction=Los nombres de los parámetros difieren en las distintas declaraciones de la misma función
Strings.ParameterNamesDoNotMatch=Los nombres de los parámetros no coinciden
Strings.ParenthesesDontChangeOrderOfOperationsAndCanBeDeleted=Los paréntesis no cambian el orden de las operaciones y pueden ser eliminados
Strings.PassValueParameterByConstReferenceDescription=El parámetro de un tipo cuyo copiado es costoso es pasado por valor, pero podría pasarse en cambio por referencia constante
Strings.PassValueParameterByConstReferenceTitle=Pasar parámetros de valor por referencia constante
Strings.PolymorphicClassWithNonVirtualPublicDestructor=Clase polimórfica con destructor público no virtual
Strings.PossiblyErroneousEmptyStatement=Posible instrucción vacía errónea
Strings.PossiblyErroneousEmptyStatementUsedInAControlStatement=Posible declaración vacía errónea usada en una declaración de control
Strings.PossiblyErroneousExpressionWithoutSideEffects=Expresión posiblemente errónea sin efectos secundarios
Strings.PossiblyErroneousExpressionWithoutSideEffects21=Posible expresión errónea sin efectos secundarios
Strings.PossiblyErroneousIncompleteSwitchStatement=Posible sentencia switch incompleta errónea
Strings.PossiblyInvalidPrintfFormatSpecifier=Especificador de formato printf posiblemente inválido
Strings.PossiblyUninitializedClassMember=Miembro de clase posiblemente no inicializado
Strings.PossiblyUninitializedDependentBaseClass=Clase base dependiente posiblemente no inicializada
Strings.PossiblyUnintendedIncompatibleReferenceTypeInRangeDeclaration=Posible tipo de referencia incompatible no intencionado en la declaración de rango
Strings.PossiblyUnintendedObjectSlicing=Posible corte de objeto no intencional
Strings.PossiblyUnintendedObjectSlicing28=Posible corte de objetos no intencional
Strings.PossiblyUnusedIncludeDirective=Directiva #include posiblemente sin uso
Strings.PossiblyUnusedIncludeDirective7=Directiva #include posiblemente sin uso
Strings.PragmaEndRegionIsMissingAMatchingEndRegionDescription=La directiva `#pragma endregion` no tiene una directiva `#pragma region` correspondiente
Strings.PragmaEndRegionIsMissingAMatchingEndRegionTitle=Falta una directiva de '#pragma region' coincidente
Strings.PragmaRegionIsMissingAMatchingEndRegionDescription=La directiva '#pragma region' no tiene una directiva '#pragma endregion' coincidente
Strings.PragmaRegionIsMissingAMatchingEndRegionTitle=Falta una directiva '#pragma endregion' correspondiente
Strings.PrecompiledHeaderIsNotFound=No se encontró encabezado precompilado
Strings.PrecompiledHeaderIsNotIncluded=El encabezado precompilado no está incluido
Strings.PrecompiledHeaderMustBeIncludedAtTheTopOfSourceFile=El encabezado precompilado se debe incluir en la parte superior del archivo de origen
Strings.PrivateSpecialMemberFunctionIsNotImplemented=Función miembro especial del ámbito privado no está implementada
Strings.ProhibitsTheUseOfTabulationCharacterEverywhereInFile=Prohíbe el uso de caracteres de tabulación en todo el archivo
Strings.QualifierIsRedundantAndCanBeDeleted=El prefijo es redundante y puede eliminarse
Strings.RedeclarationOfATemplateParameterFromAnOuterScope=Redeclaración de un parámetro de plantilla desde un ámbito externo
Strings.RedundantArgumentInConditionalExpression=Argumento redundante en la expresión condicional
Strings.RedundantArgumentInConditionalExpression54=Argumento redundante en la expresión condicional
Strings.RedundantBaseClassAccessSpecifier=Especificador de acceso de clase base redundante
Strings.RedundantBaseClassAccessSpecifier53=Especificador de acceso de clase base redundante
Strings.RedundantBaseClassInitializerDescription=Inicializador de clase base redundante en una lista de inicializadores de miembro
Strings.RedundantBaseClassInitializerTitle=Inicializador redundante de clase base
Strings.RedundantCastExpression=Expresión de conversión redundante
Strings.RedundantControlFlowJumpStatement=Sentencia redundante de salto de flujo de control
Strings.RedundantControlFlowJumpStatement47=Sentencia de salto de flujo de control redundante
Strings.RedundantElaboratedTypeSpecifier=Especificación de tipo elaborada redundante
Strings.RedundantEmptyDeclaration=Declaración vacía redundante
Strings.RedundantEmptyDeclaration49=Declaración vacía redundante
Strings.RedundantEmptyStatement=Sentencia vacía redundante
Strings.RedundantEmptyStatement48=Sentencia vacía redundante
Strings.RedundantExportKeywordMessage=La palabra clave 'export' es redundante, porque hay una declaración de exportación que la encierra
Strings.RedundantMemberInitializerInConstructorInitializationList=Inicializador de miembro redundante en la lista de inicialización de constructor
Strings.RedundantMemberInitializerInConstructorInitializationList56=Inicializador de miembro redundante en la lista de inicialización del constructor
Strings.RedundantParameterListInLambdaDeclarator=Lista de parámetros redundante en el declarador lambda
Strings.RedundantParentheses=Paréntesis redundantes
Strings.RedundantQualifier=Calificador redundante
Strings.RedundantStaticSpecifierOnThreadLocalLocalVariableDescription=Especificador 'static' redundante en una variable local 'threadlocal'
Strings.RedundantStaticSpecifierOnThreadLocalLocalVariableTitle=Especificador 'static' redundante en una variable local 'threadlocal'
Strings.RedundantTemplateArguments=Redundancia de argumentos de plantilla
Strings.RedundantVoidArgumentList=Lista de argumento vacío redundante
Strings.RedundantVoidArgumentList55=Lista de argumentos redundant void
Strings.RedundantWhitespaceCharactersAtTheEndOfALine=Caracteres en blanco redundantes al final de una línea
Strings.RedundantWhitespacesAtTheEndOfALine=Espacios en blanco redundantes al final de una línea
Strings.RedundantZeroInitializerInAggregateInitializationMessage=Inicializador de cero redundante en la inicialización de agregación
Strings.RedundantconstSpecifier=Especificador 'const' redundante
Strings.RedundantelseKeyword=Palabra clave 'else' redundante
Strings.RedundantelseKeyword45=Palabra clave redundante 'else'
Strings.RedundantelseKeywordInsideCompoundStatement=Redundante palabra clave 'else' dentro de la sentencia compuesta
Strings.RedundantelseKeywordInsideCompoundStatement46=Palabra clave 'else' redundante dentro de la sentencia compuesta
Strings.RedundantfinalSpecifierOnAFunctionInAFinalClass=Especificador 'final' redundante en una función de una clase final
Strings.RedundantinlineSpecifier=Especificador "inline" redundante
Strings.RedundantstaticSpecifierOnAMemberAllocationDeallocationFunction=Especificador "static" redundante en una función de asignación/liberación de miembro
Strings.RedundantstaticSpecifierOnAnAnonymousNamespaceMember=Especificador 'static' redundante en miembro de espacio de nombres anónimo
Strings.RedundantstaticSpecifierOnAnAnonymousNamespaceMember52=Especificador 'static' redundante en un miembro de espacio de nombres anónimo
Strings.RedundanttemplateKeyword=Palabra reservada 'template' redundante
Strings.RedundanttemplateKeyword43=Palabra clave 'template' redundante
Strings.RedundanttypenameKeyword=Palabra clave redundante 'typename'
Strings.RedundanttypenameKeyword42=Palabra clave 'typename' Redundante
Strings.ReferenceClassMemberWithmutableSpecifier=Miembro de clase de referencia con especificador 'mutable'
Strings.ReferenceClassMembersCannotHavemutableSpecifier=Los miembros de clase de referencia no pueden tener el especificador 'mutable'
Strings.ReinterpretCastIsUsedInsteadOfAStaticCast=Se usa reinterpretcast en lugar de staticcast
Strings.ReinterpretCastIsUsedInsteadOfAStaticCast3=Se utiliza reinterpretcast en lugar de staticcast
Strings.RemoveRedundantBraces=Eliminar llaves redundantes
Strings.ResultOfAPostfixOperatorIsDiscarded=El resultado de un operador postfix se ignora
Strings.ResultOfAPostfixOperatorIsDiscardedItMightBeMoreEfficientToUseAPrefixFormOfTheOperator=El resultado de un operador postfix se descarta. Podría ser más eficiente utilizar una forma de prefijo del operador.
Strings.ResultOfAssignmentIsUsedAsCondition=Resultado de asignación usado como condición
Strings.ResultOfNodiscardFunctionIsNotUsed=El resultado de la función nodiscard no se utiliza
Strings.ResultOfNodiscardFunctionIsNotUsed22=El resultado de la función nodiscard no se usa
Strings.ReturningFromAFunctionByConstValueIsUsuallyNotBeneficialConsiderReturningValuesAsNonConstToTakeAdvantageOfMoveSemantics=Por lo general no es beneficioso regresar desde una función por valor constante. Considera la posibilidad de regresar valores como no constantes para aprovechar las semánticas de movimiento.
Strings.SlashSymbolUsedInIncludeDirectiveDoesntMatchCodeStyleSettings=El símbolo de barra invertida utilizado en la directiva #include no coincide con la configuración del estilo de código
Strings.SlashSymbolUsedInIncludeDirectiveDoesntMatchCodeStyleSettings2=El símbolo de barra en la directiva #include no coincide con la configuración del estilo del código
Strings.SomeObjectMembersMightNotBeInitialized=Es posible que algunos miembros de objetos no estén inicializados
Strings.SpecialFunctionDoesntHaveAnyNoexceptSpecification=La función especial no tiene especificación noexcept
Strings.SpecialFunctionWithoutNoexceptSpecification=Función especial sin especificación de noexcept
Strings.StaticAssertFailedDescription=staticassert falló
Strings.StaticAssertFailedTitle=staticassert falló
Strings.StaticDataMemberInAnAnonymousClassIsNotAllowedByTheCStandard=Los miembros de datos estáticos en una clase anónima no están permitidos por el estándar C++
Strings.StaticDataMembersAreNotAllowedInAnonymousClasses=Los miembros estáticos de datos no se permiten en clases anónimas
Strings.StdIsConstantEvaluatedWillAlwaysEvaluateToConstantDescription='std::isconstantevaluated' siempre se evaluará como constante
Strings.StdIsConstantEvaluatedWillAlwaysEvaluateToConstantTitle='std::isconstantevaluated' siempre evaluará a constante
Strings.StdSizeCanBeUsed=se puede usar std::size
Strings.StdSizeIsTypeSafeAlternativeToCIdiomForArraySizeCalculation=std::size es una alternativa segura para el tipo C para el cálculo de tamaño de matriz
Strings.StdViewsKeysValuesCanBeUsed=std::views::keys/values se pueden utilizar
Strings.StringLiteralToCharPointerConversion=Conversión literal de cadena al puntero de carácter
Strings.StringLiteralToCharPointerConversion34=Conversión de cadena literal a puntero char
Strings.StructuredBindingCanBeUsed=Se puede utilizar la vinculación estructurada
Strings.StructuredBindingCanBeUsed15=Se puede utilizar la vinculación estructurada
Strings.StructuredBindingCanBeUsedInsteadOfTie=Se puede utilizar la vinculación estructurada en lugar de tie(..)
Strings.SyntaxErrorInADoxygenComment=Error de sintaxis en un comentario doxygen
Strings.SyntaxErrorInDoxygenComment=Error de sintaxis en comentario de doxygen
Strings.TabsAreProhibited=Las tabulaciones están prohibidas
Strings.TagsOfTheDeclaredClassDoNotMatchPreviousDeclarations=Las etiquetas de la clase declarada no coinciden con las declaraciones anteriores
Strings.TakingAnAddressOfClassRValueIsNonStandardMicrosoftCExtension=Tomar una dirección de clase r-valor es una extensión no estándar de Microsoft C++
Strings.TakingAnAddressOfClassRValueIsNonStandardMicrosoftCExtension3=Tomar una dirección de clase r-value es una extensión de Microsoft C++ no estándar
Strings.TemplateArgumentsCanBeDeduced=Los argumentos de la plantilla se pueden deducir
Strings.TemplateParameterIsNeverUsedDescription=Un parámetro de plantilla nunca se utiliza
Strings.TemplateParameterIsNeverUsedTitle=El parámetro de plantilla nunca se usa
Strings.TheAwaiterTypeMustBeAAClassAccordingToTheCStandard=El tipo de awaiter debe ser una clase según el estándar C++20
Strings.TheClassIsAbstractButNotExplicitlyDeclaredAsSuch=La clase es abstracta, pero no se ha declarado explícitamente como tal
Strings.TheNodiscardAttributeCannotBeAppliedToFunctionsWithoutAReturnValue=[[nodiscard]] El atributo no se puede aplicar a funciones sin valor de retorno
Strings.TheSwitchStatementDoesntCoverTheWholeRangeOfTheEnumerationUsed=La sentencia switch no cubre todo el rango de la enumeración usada
Strings.TheconstSpecifierOnAVariableDefinitionIsRedundant=El especificador 'const' en una definición de variable es redundante
Strings.TheinlineSpecifierOnAFunctionDefinitionIsRedundant=El especificador 'inline' en una definición de función es redundante
Strings.TheoutParameterMustBeAssigned=El parámetro 'out' debe ser asignado
Strings.TheregisterStorageClassSpecifierIsDeprecatedInCAndRemovedInC='register', el especificador de la clase de almacenamiento está obsoleto en C++11 y eliminado en C++17
Strings.ThestaticSpecifierIsOptionalForMemberAllocationDeallocationFunctions=El especificador 'static' es opcional para las funciones de asignación o liberación de miembro
Strings.ThrowExpressionCanBeReplacedWithARethrowExpression=La expresión throw se puede reemplazar con una expresión rethrow
Strings.ThrowExpressionCanBeReplacedWithARethrowExpression12=La expresión throw puede ser reemplazada por una expresión rethrow
Strings.TooManyArgumentsInACallToBoostFormat=Demasiados argumentos en una llamada a boost::format
Strings.TooManyArgumentsInACallToBoostFormatSomeOfTheArgumentsAreNotUsed=Demasiados argumentos en una llamada a boost::format. Algunos de los argumentos no se utilizan.
Strings.TooManyArgumentsInACallToPrintf=Demasiados argumentos en una llamada a printf
Strings.TooManyArgumentsInACallToPrintfSomeOfTheArgumentsAreNotUsed=Demasiados argumentos en una llamada a printf. Algunos de los argumentos no se utilizan.
Strings.TypeAliasIsNeverUsed=Alias de tipo nunca se usa
Strings.TypeCanBeReplacedWithAuto=Type se puede reemplazar con auto
Strings.TypeCanBeReplacedWithauto4=El tipo puede ser reemplazado con 'auto'
Strings.TypeSpecifierMissingDefaultsToInt=Especificador del tipo perdido, predeterminado a int
Strings.TypeTraitCanBeSimplifiedUsingATemplateAliasOrAVariableTemplate=El atributo de tipo se puede simplificar usando un alias de plantilla o una plantilla variable
Strings.UninitializedDependentBaseClass=Clase base dependiente no inicializada
Strings.UnionMemberOfReferenceType=Miembro de unión de tipo de referencia
Strings.UnionsCannotContainNonStaticDataMembersOfReferenceTypes=Los sindicatos no pueden contener miembros de datos no estáticos de tipos de referencia
Strings.UnnamedNamespaceInAHeaderFile=Espacio de nombres sin nombre en un archivo de cabecera
Strings.UnnamedNamespacesShouldNotBeUsedInHeaderFiles=Los namespaces sin nombre no deben usarse en archivos de cabecera
Strings.UnresolvedReferenceInADoxygenComment=Referencia no resuelta en un comentario doxygen
Strings.UnresolvedReferenceInDoxygenComment=Referencia no resuelta en el comentario de doxygen
Strings.UseBracesToSeparatedoWhileStatementBody=Utilizar llaves para separar el cuerpo de la sentencia 'do-while'
Strings.UseBracesToSeparateforStatementBody=Utilice llaves para separar el cuerpo de la sentencia 'for'
Strings.UseBracesToSeparateifStatementBody=Utiliza llaves para separar el cuerpo de la sentencia 'if'
Strings.UseBracesToSeparatewhileStatementBody=Utiliza llaves para separar el cuerpo de una sentencia 'while'
Strings.UseOfAnIncompleteTypeInsideATemplate=Uso de un tipo incompleto dentro de una plantilla
Strings.UsePreferredBracesStyle=Utilizar estilo de llaves preferido
Strings.UsePreferredCvQualifiersStyle=Usar estilo de cv-calificadores preferido
Strings.UsePreferredDeclarationStyle=Usar estilo de declaración preferido
Strings.UsePreferredIncludeDirectiveStyle=Usar el estilo de directiva de inclusión preferido
Strings.UsePreferredInitializationStyle=Usar estilo de inicialización preferido
Strings.UsePreferredOverridingFunctionStyle=Utilizar estilo de función de anulación preferida
Strings.UsePreferredautoStyle=Usar estilo preferido 'auto'
Strings.UserDefinedLiteralSuffixesMustStartWithAnUnderscore=Los sufijos literales definidos por el usuario deben comenzar con un guion bajo
Strings.UserDefinedLiteralSuffixesMustStartWithAnUnderscoreTheSuffixesThatDoNotBeginWithAnUnderscoreAreReservedForTheLiteralOperatorsProvidedByTheStandardLibrary=Los sufijos de literales definidos por el usuario deben comenzar con un guión bajo. Los sufijos que no comienzan con un guión bajo están reservados para los operadores literales proporcionados por la biblioteca estándar.
Strings.UsingAnIncompatibleReferenceTypeInTheRangeDeclarationIsLikelyToCauseUnwantedObjectCopying=El uso de un tipo de referencia incompatible en la declaración del rango puede causar una copia de objeto indeseada
Strings.VariableCanBeMadeConstexpr=La variable puede definirse como constexpr
Strings.VariableCanBeMadeConstexpr10=La variable puede ser constexpr
Strings.VariableCanBeMovedToInitStatement=La variable puede moverse a una instrucción init
Strings.VariableCanBeMovedToInnerScope=La variable puede ser movida a un ámbito más interno
Strings.VolatileQualificationOfParametersHasAnEffectOnlyInFunctionDefinitions=La cualificación volátil de parámetros solo tiene efecto en las definiciones de funciones
Strings.VolatileQualifiedParameterInAFunctionDeclaration=Parámetro calificado como volatile en la declaración de una función
Strings.WarningDirectiveDescription=#warning directiva del preprocesador
Strings.WarningDirectiveTitle=Directiva #warning
Strings.ZeroConstantCanBeReplacedWithNullptr=La constante cero puede ser reemplazada por nullptr
Strings.ZeroConstantCanBeReplacedWithNullptr13=Se puede reemplazar la constante cero con nullptr
Strings.ZeroInitializationCanBeUsedInsteadOfMemset=Se puede usar inicialización a cero en lugar de memset
Strings.ZeroInitializationCanBeUsedInsteadOfMemset16=Se puede usar inicialización a cero en lugar de memset
Strings.containsMemberFunctionCanBeUsed=Se puede usar la función miembro 'contains'
Strings.containsMemberFunctionCanBeUsed17=se puede usar la función miembro 'contains'
Strings.defaultIsAKeywordInTheCStandardAndCannotBeUsedAsAnIdentifier='default' es una palabra clave del estándar C++ y no se puede usar como un identificador
Strings.longFloatsAreNotAllowedByTheCStandard=Los flotantes 'long' no están permitidos por el estándar C++
Strings.stdErasestdEraseIfCanBeUsedInsteadOfTheRemoveEraseIdiom='std::erase'/'std::eraseif' se pueden utilizar en lugar del modismo remove-erase
Strings.stdErasestdEraseIfCanBeUsedInsteadOfTheRemoveEraseIdiom18='std::erase'/'std::eraseif' se puede usar en lugar del remove-erase idiom