GuiceClassAnnotator.popup.title=Seleccionar expresión para navegar
GuiceClassAnnotator.popup.tooltip.text=Navegar a expresión de binding Guice
ImplicitSubclassInspection.display.forMethod.annotated=Los métodos @Transactional no pueden ser private
binding.annotation.without.inject.display.name=Anotación de binding sin @Inject
binding.annotation.without.inject.problem.descriptor=Anotación de binding sin @Inject declarado \#ref \#loc
class.provided=Clase proporcionada\:
conflicting.annotations.display.name=Conflicto de anotaciones Guice
conflicting.annotations.problem.descriptor=La anotación \#ref conflicta con otras anotaciones declaradas \#loc
delete.binding=Eliminar binding
group.GuiceActionGroup.description=Componentes Google Guice
group.GuiceActionGroup.text=Google Guice
group.guice.inspections.name=Guice
guice.intentions=Guice
gutter.choose.injected.point=Seleccionar punto de inyección
gutter.navigate.to.injection.point=Navegar al punto de inyección
interception.annotation.without.runtime.retention.display.name=Anotación de intercepción sin retención en runtime
interception.annotation.without.runtime.retention.problem.descriptor=La anotación \#ref no tiene retención en runtime \#loc
invalid.implemented.by.display.name=Anotación @ImplementedBy inválida
invalid.implemented.by.problem.descriptor=La clase \#ref no implementa la clase anotada \#loc
invalid.provided.by.display.name=Anotación @ProvidedBy inválida
invalid.provided.by.problem.descriptor=La clase \#ref no proporciona la clase anotada \#loc
invalid.request.parameters.display.name=Tipo incorrecto para parámetros @RequestParameters
invalid.request.parameters.problem.descriptor=La variable o parámetro marcado con \#ref debe ser de tipo Map<String, String[]> \#loc
make.injection.mandatory=Hacer anotación obligatoria
make.injection.optional=Hacer anotación opcional
move.binding.scope.to.class.family.name=Mover scope de binding a clase
move.binding.scope.to.class.text=Mover scope de binding a clase
move.binding.to.class.family.name=Mover binding a clase
move.binding.to.class.text=Mover binding a clase
move.provider.binding.to.class.family.name=Mover provider binding a clase
move.provider.binding.to.class.text=Mover provider binding a clase
multiple.binding.annotations.display.name=Variable con múltiples anotaciones de binding
multiple.binding.annotations.problem.descriptor=La variable \#ref tiene múltiples anotaciones de binding \#loc
multiple.injected.constructors.for.class.display.name=Clase con múltiples constructores @Inject
multiple.injected.constructors.for.class.problem.descriptor=La clase \#ref tiene múltiples constructores @Inject \#loc
new.guice.binding.annotation.action.name=Crear anotación de binding Guice
new.guice.binding.annotation.error=No se puede crear anotación de binding Guice
new.guice.binding.annotation.name=Crear anotación de binding Guice\: {0}.{1}
new.guice.method.interceptor.action.name=Crear interceptor de método Guice
new.guice.method.interceptor.error=No se puede crear interceptor de método Guice
new.guice.method.interceptor.name=Crear interceptor de método Guice\: {0}.{1}
new.guice.module.action.name=Crear módulo Guice
new.guice.module.error=No se puede crear módulo Guice
new.guice.module.name=Crear módulo Guice\: {0}.{1}
new.guice.provider=Nuevo provider Guice
new.guice.provider.action.name=Crear provider Guice
new.guice.provider.error=No se puede crear provider Guice
new.guice.provider.name=Crear provider Guice\: {0}.{1}
new.guice.scope.annotation.action.name=Crear anotación de scope Guice
new.guice.scope.annotation.error=No se puede crear anotación de scope Guice
pointless.binding.display.name=Binding innecesario
pointless.binding.problem.descriptor=Binding innecesario, puede eliminarse \#loc
provider.class.name=Nombre de clase provider\:
redundant.scope.binding.display.name=Binding de scope redundante
redundant.scope.binding.problem.descriptor=Binding redundante con scope \#ref \#loc
redundant.to.binding.display.name=Binding redundante
redundant.to.binding.problem.descriptor=Binding redundante con clase \#ref \#loc
redundant.to.provider.binding.display.name=Binding de provider redundante
redundant.to.provider.binding.problem.descriptor=Binding redundante con clase \#ref \#loc
select.provided.class=Seleccionar clase a proporcionar
session.scoped.injects.request.scoped.display.name=Componente @SessionScoped inyecta componente @RequestScoped
session.scoped.injects.request.scoped.problem.descriptor=@Inject de clase @RequestScoped \#ref desde clase @SessionScoped \#loc
singleton.injects.scoped.display.name=Componente @Singleton inyecta componente con scope
singleton.injects.scoped.problem.descriptor=@Inject de clase con scope \#ref desde clase @Singleton \#loc
toggle.injection.required.family.name=Alternar inyección
toggle.required=Alternar 'optional'
uninstantiable.binding.display.name=Binding no instanciable
uninstantiable.binding.problem.descriptor=La clase \#ref no es instanciable y no puede ser vinculada \#loc
uninstantiable.implemented.by.class.display.name=Clase @ImplementedBy no instanciable
uninstantiable.implemented.by.class.problem.descriptor=La clase \#ref no es instanciable y no puede ser @ImplementedBy \#loc
uninstantiable.provided.by.class.display.name=Clase @ProvidedBy no instanciable
uninstantiable.provided.by.class.problem.descriptor=La clase \#ref no es instanciable y no puede ser @ProvidedBy \#loc
unnecessary.static.injection.display.name=Inyección static innecesaria
unnecessary.static.injection.problem.descriptor=La clase \#ref no tiene miembros static @Inject \#loc