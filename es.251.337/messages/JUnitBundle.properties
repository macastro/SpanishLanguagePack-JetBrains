action.AddToISuite.text=Agregar a suite de patrones JUnit
action.excludeFromSuite.text=Excluir de la suite
action.text.test.category=Pruebas de {0}
action.text.test.tags=Pruebas de {0}
action.text.test.unknown.target=Desconocido
async.stack.trace.for.exceptions.name=Imprimir traza de pila asíncrona para excepciones
cannot.browse.test.inheritors.dialog.title=No se pueden explorar los herederos de TestCase
category.interface.dialog.title=Interfaz de categoría
category.is.not.specified.error.message=Categoría no especificada
category.label=Categoría
change.list.label=Lista de cambios
class.isnt.inheritor.of.testcase.error.message={0} no es heredero de TestCase
class.not.test.error.message=La clase ''{0}'' no es una prueba
combobox.changelists.all=Todos
configuration.not.specified.message=Tipo de prueba de configuración no especificado\: {0}
create.setup.dialog.message=El método setUp ya existe pero no está anotado como {0}. ¿Anotar?
create.setup.dialog.title=Crear método setUp
default.junit.config.empty.category=Inválido
default.junit.config.name.all.in.module=Todo en {0}
default.junit.config.name.all.in.package.in.module={0} en {1}
default.junit.config.name.category=@Category({0})
default.junit.config.name.tags=Tags ({0})
default.junit.config.name.temp.suite=Suite temporal
default.junit.config.name.whole.project=Proyecto completo
default.junit.configuration.name=<sin-nombre>
dialog.message.failed.to.resolve.maven.id=No se pudo resolver {0}
dialog.message.no.unique.id.specified.exception=ID único no especificado
dialog.title.preparing.test=Preparando prueba
directory.0.is.not.found.error.message=No se encuentra el directorio ''{0}''
directory.is.not.specified.error.message=Directorio no especificado
directory.label=Directorio
directory.not.found.error.message=No se encuentra el directorio ''{0}''
expected.exception.never.thrown.display.name=Excepción esperada nunca lanzada en el cuerpo del método de prueba
expected.exception.never.thrown.problem.descriptor=La excepción esperada <code>\#ref</code> nunca fue lanzada en el cuerpo de ''{0}()'' \#loc
fix.data.provider.create.method.fix.name=Crear método proveedor de datos '@Parameters public static Iterable<Object> parameters()'
fix.data.provider.multiple.methods.problem=Múltiples métodos proveedores de datos @Parameters presentes en la clase <code>\#ref</code>
fix.data.provider.signature.family.name=Corregir firma del método proveedor de datos
fix.data.provider.signature.fix.name=Cambiar firma del método a ''{0}''
fix.data.provider.signature.incorrect.problem=El método proveedor de datos <code>\#ref()</code> tiene una firma incorrecta
fix.data.provider.signature.missing.method.problem=La clase de prueba parametrizada <code>\#ref</code> carece de método proveedor de datos anotado con '@Parameters'
fork.mode.label=Modo fork(&F)\:
fork.mode.name=Modo fork
inspection.parameterized.parameters.static.collection.display.name=Clase de prueba parametrizada sin método proveedor de datos
junit.config.with.parameter.0=\ con parámetro "{0}"
junit.configuration.across.module.dependencies.radio=A través de dependencias de módulos
junit.configuration.class.label=Clase\:
junit.configuration.description=Configuración de prueba JUnit
junit.configuration.display.name=JUnit
junit.configuration.fork.mode.class=Clase
junit.configuration.fork.mode.method=Método
junit.configuration.fork.mode.none=Ninguno
junit.configuration.fork.mode.repeat=Repetir
junit.configuration.in.single.module.radio=En módulo único
junit.configuration.in.whole.project.radio=En todo el proyecto
junit.configuration.kind.all.in.directory=Todo en el directorio
junit.configuration.kind.all.in.package=Todo en el paquete
junit.configuration.kind.by.pattern=Patrón
junit.configuration.kind.by.tags=Tags
junit.configuration.kind.by.unique.id=UniqueId
junit.configuration.kind.category=Categoría
junit.configuration.kind.class=Clase
junit.configuration.kind.method=Método
junit.configuration.method.label=Método\:
junit.configuration.package.label=Paquete\:
junit.configuration.repeat.mode.n.times=N veces
junit.configuration.repeat.mode.once=Una vez
junit.configuration.repeat.mode.until.failure=Hasta que falle
junit.configuration.repeat.mode.until.stopped=Hasta que se detenga
junit.configuration.repeat.mode.until.success=Hasta que tenga éxito
junit.configuration.search.for.tests.label=Buscar pruebas\:
junit.entry.point.suggest.package.private.visibility.junit5=Sugerir nivel de visibilidad package-private para pruebas junit 5
junit.inspections.group.name=JUnit
junit.not.found.in.module.error.message=No se encontró JUnit en el módulo ''{0}''
junit3.style.test.method.in.junit4.class.display.name=Método de prueba JUnit de estilo antiguo en clase JUnit 4
junit3.style.test.method.in.junit4.class.problem.descriptor=Método de prueba JUnit de estilo antiguo <code>\#ref()</code> en clase JUnit 4 \#loc
junit5.migration.description=Para transferir las anotaciones de prueba de JUnit 4 a las nuevas de jupiter, ¡puede resultar en código rojo\! Las aserciones no se migrarán. Consulte la inspección 'Java | Problemas JUnit | La prueba JUnit 4 puede ser JUnit 5' para migrar solo las pruebas que se pueden convertir completamente de forma automática.
jvm.inspections.junit.assertequals.may.be.assertsame.display.name='assertEquals()' podría ser 'assertSame()'
jvm.inspections.junit.assertequals.may.be.assertsame.problem.descriptor=<code>\#ref()</code> podría ser 'assertSame()' \#loc
jvm.inspections.junit.assertequals.on.array.display.name='assertEquals()' llamado en array
jvm.inspections.junit.assertequals.on.array.problem.descriptor=<code>\#ref()</code> llamado en array \#loc
jvm.inspections.junit.ignored.test.class.problem.descriptor=La clase de prueba ''{0}'' está ignorada/deshabilitada {1, choice, 1\#|2\#sin razón} \#loc
jvm.inspections.junit.ignored.test.display.name=Prueba JUnit anotada con '@Ignore'/'@Disabled'
jvm.inspections.junit.ignored.test.ignore.reason.option=Solo reportar anotaciones sin razón
jvm.inspections.junit.ignored.test.method.problem.descriptor=El método de prueba ''{0}()'' está ignorado/deshabilitado {1, choice, 1\#|2\#sin razón} \#loc
jvm.inspections.junit.malformed.annotated.double.descriptor={0, choice, 0\#Campo|1\#Método} <code>\#ref</code> anotado con ''@{1}'' debe ser {2} y {3}
jvm.inspections.junit.malformed.annotated.double.typed.descriptor={0, choice, 0\#Campo|1\#Método} <code>\#ref</code> anotado con ''@{1}'' debe ser {2}, {3} y de tipo ''{4}''
jvm.inspections.junit.malformed.annotated.method.double.param.double.descriptor=El método <code>\#ref</code> anotado con ''@{0}'' debe ser {1}, {2} y no declarar los parámetros ''{3}'' y ''{4}''
jvm.inspections.junit.malformed.annotated.method.double.param.single.descriptor=El método <code>\#ref</code> anotado con ''@{0}'' debe ser {1}, {2} y no declarar el parámetro ''{3}''
jvm.inspections.junit.malformed.annotated.method.double.typed.param.double.descriptor=El método <code>\#ref</code> anotado con ''@{0}'' debe ser {1}, {2}, de tipo ''{3}'' y no declarar los parámetros {4} y ''{5}''
jvm.inspections.junit.malformed.annotated.method.double.typed.param.single.descriptor=El método <code>\#ref</code> anotado con ''@{0}'' debe ser {1}, {2}, de tipo ''{3}'' y no declarar el parámetro ''{4}''
jvm.inspections.junit.malformed.annotated.method.param.double.descriptor=El método <code>\#ref</code> anotado con ''@{0}'' no debe declarar los parámetros {1} y ''{2}''
jvm.inspections.junit.malformed.annotated.method.param.single.descriptor=El método <code>\#ref</code> anotado con ''@{0}'' no debe declarar el parámetro ''{1}''
jvm.inspections.junit.malformed.annotated.method.single.param.double.descriptor=El método <code>\#ref</code> anotado con ''@{0}'' debe ser {1} y no declarar los parámetros ''{2}'' y ''{3}''
jvm.inspections.junit.malformed.annotated.method.single.param.single.descriptor=El método <code>\#ref</code> anotado con ''@{0}'' debe ser {1} y no declarar el parámetro ''{2}''
jvm.inspections.junit.malformed.annotated.method.single.typed.param.double.descriptor=El método <code>\#ref</code> anotado con ''@{0}'' debe ser {1}, de tipo ''{2}'' y no declarar los parámetros {3} y ''{4}''
jvm.inspections.junit.malformed.annotated.method.single.typed.param.single.descriptor=El método <code>\#ref</code> anotado con ''@{0}'' debe ser {1}, de tipo ''{2}'' y no declarar el parámetro ''{3}''
jvm.inspections.junit.malformed.annotated.method.typed.param.double.descriptor=El método <code>\#ref</code> anotado con ''@{0}'' debe ser de tipo ''{1}'' y no declarar los parámetros {2} y ''{3}''
jvm.inspections.junit.malformed.annotated.method.typed.param.single.descriptor=El método <code>\#ref</code> anotado con ''@{0}'' debe ser de tipo ''{1}'' y no declarar el parámetro ''{2}''
jvm.inspections.junit.malformed.annotated.single.descriptor={0, choice, 0\#Campo|1\#Método} <code>\#ref</code> anotado con ''@{1}'' debe ser {2}
jvm.inspections.junit.malformed.annotated.single.typed.descriptor={0, choice, 0\#Campo|1\#Método} <code>\#ref</code> anotado con ''@{1}'' debe ser {2} y de tipo ''{3}''
jvm.inspections.junit.malformed.annotated.suspend.function.descriptor=El método <code>\#ref</code> anotado con ''@{0}'' no debe ser una función suspendida
jvm.inspections.junit.malformed.annotated.typed.descriptor={0, choice, 0\#El campo|1\#El método} <code>\#ref</code> anotado con ''@{1}'' debe ser de tipo ''{2}''
jvm.inspections.junit.malformed.declaration.name=Declaración JUnit mal formada
jvm.inspections.junit.malformed.extension.class.level.descriptor={0} debe registrarse a nivel de clase
jvm.inspections.junit.malformed.fix.class.signature=Corregir firma de clase
jvm.inspections.junit.malformed.fix.class.signature.descriptor=Corregir firma de clase ''{0}''
jvm.inspections.junit.malformed.fix.class.signature.multi=Corregir firmas de clase
jvm.inspections.junit.malformed.fix.field.signature=Corregir firma de campo
jvm.inspections.junit.malformed.fix.field.signature.descriptor=Corregir firma del campo ''{0}''
jvm.inspections.junit.malformed.fix.method.signature=Corregir firma de método
jvm.inspections.junit.malformed.fix.method.signature.descriptor=Corregir firma del método ''{0}''
jvm.inspections.junit.malformed.missing.nested.annotation.descriptor=Los tests en la clase anidada no se ejecutarán
jvm.inspections.junit.malformed.no.arg.descriptor=El método <code>\#ref</code> debe ser {0}, {1}{2, choice, 0\# y no tener parámetros|1\#, no tener parámetros y ser de tipo void}
jvm.inspections.junit.malformed.option.ignore.test.parameter.if.annotated.by=Ignorar parámetro de test si está anotado por\:
jvm.inspections.junit.malformed.param.duplicated.enum.descriptor=Nombre de constante 'enum' duplicado
jvm.inspections.junit.malformed.param.empty.source.unsupported.descriptor=''@{0}'' no puede proporcionar un argumento al método porque el método tiene un parámetro no soportado de tipo ''{1}''
jvm.inspections.junit.malformed.param.exactly.one.type.of.input.must.be.provided.descriptor=Se debe proporcionar exactamente un tipo de entrada
jvm.inspections.junit.malformed.param.file.source.descriptor=No se puede resolver la fuente del archivo\: ''{0}''
jvm.inspections.junit.malformed.param.method.source.assignable.descriptor=No se encontró conversión implícita para convertir ''{0}'' a ''{1}''
jvm.inspections.junit.malformed.param.method.source.no.params.descriptor=La fuente del método ''{0}'' no debe tener parámetros
jvm.inspections.junit.malformed.param.method.source.return.type.descriptor=La fuente del método ''{0}'' debe tener uno de los siguientes tipos de retorno\: ''Stream<?>'', ''Iterator<?>'', ''Iterable<?>'' o ''Object[]''
jvm.inspections.junit.malformed.param.method.source.static.descriptor=La fuente del método ''{0}'' debe ser static
jvm.inspections.junit.malformed.param.method.source.unresolved.descriptor=No se puede resolver la fuente del método objetivo\: ''{0}''
jvm.inspections.junit.malformed.param.multiple.parameters.descriptor=Solo se puede proporcionar un único parámetro mediante ''@{0}''
jvm.inspections.junit.malformed.param.no.sources.are.provided.descriptor=No se proporcionan fuentes, la suite estaría vacía
jvm.inspections.junit.malformed.param.no.value.source.is.defined.descriptor=No se ha definido ninguna fuente de valor
jvm.inspections.junit.malformed.param.unresolved.enum.descriptor=No se puede resolver la referencia de constante 'enum'.
jvm.inspections.junit.malformed.param.wrapped.in.arguments.descriptor=Múltiples parámetros deben estar envueltos en 'Arguments'
jvm.inspections.junit.malformed.repetition.number.descriptor=El número de repeticiones debe ser mayor que cero
jvm.inspections.junit.malformed.source.without.params.descriptor=''@{0}'' no puede proporcionar un argumento al método porque el método no tiene parámetros
jvm.inspections.junit.malformed.suspend.function.descriptor=El método <code>\#ref</code> no debe ser una función suspendida
jvm.inspections.junit.malformed.test.combination.descriptor=Combinación sospechosa de {0} y ''@{1}''
jvm.inspections.junit.mixed.annotations.junit.descriptor=Método <code>\#ref()</code> anotado con ''@{0}'' dentro de una clase que extiende JUnit {1} TestCase \#loc
jvm.inspections.junit.mixed.annotations.name=Uso de API JUnit de múltiples versiones en un solo TestCase
jvm.inspections.junit3.super.teardown.display.name=No se llama a JUnit 3 'super.tearDown()' desde el bloque 'finally'
jvm.inspections.junit3.super.teardown.problem.descriptor=No se llama a <code>\#ref()</code> desde el bloque 'finally' \#loc
jvm.inspections.junit4.converter.display.name=El test JUnit 3 puede ser JUnit 4
jvm.inspections.junit4.converter.problem.descriptor=<code>\#ref</code> podría convertirse a caso de test JUnit4
jvm.inspections.junit4.converter.quickfix.conflict.call.compile=La llamada al método {0} no compilará cuando {1} se convierta a JUnit 4
jvm.inspections.junit4.converter.quickfix.conflict.name=El método {0} tendrá una colisión de nombres con su método super
jvm.inspections.junit4.converter.quickfix.conflict.semantics=La llamada al método {0} puede cambiar la semántica cuando {1} se convierta a JUnit 4
jvm.inspections.junit4.converter.quickfix.conflict.suite=La migración del método suite para {0} tiene efectos secundarios que serán eliminados
jvm.inspections.junit4.converter.quickfix.name=Convertir a caso de test JUnit 4
jvm.inspections.junit4.inherited.runwith.display.name=La anotación '@RunWith' ya existe en una clase padre
jvm.inspections.junit4.inherited.runwith.problem.descriptor=La anotación '@RunWith' ya existe en la clase {0}
jvm.inspections.junit5.assertions.converter.display.name=Assertions obsoletos de JUnit 5
jvm.inspections.junit5.assertions.converter.familyName=Reemplazar con llamada compatible con JUnit 5
jvm.inspections.junit5.assertions.converter.problem.descriptor=La llamada a <code>\#ref()</code> de ''{0}'' debe reemplazarse con una llamada a un método de ''{1}'' \#loc
jvm.inspections.junit5.assertions.converter.quickfix=Reemplazar con llamada al método ''{0}''
jvm.inspections.junit5.converter.display.name=El test JUnit 4 puede ser JUnit 5
jvm.inspections.junit5.converter.problem.descriptor=\#ref puede ser un test JUnit 5
jvm.inspections.junit5.converter.quickfix=Migrar a JUnit 5
jvm.inspections.junit5.converter.quickfix.conflict.inheritor=La clase {0} no puede convertirse a JUnit 5, debido a que hay herederos incompatibles\: {1}
jvm.inspections.junit5.converter.quickfix.presentation.text=Convertir Assertions
jvm.inspections.migrate.assert.to.matcher.description=La expresión de aserción <code>\#ref</code> puede reemplazarse con la llamada ''{0}'' \#loc
jvm.inspections.migrate.assert.to.matcher.option=Importar estáticamente los métodos del matcher
jvm.inspections.migrate.assertion.name=La aserción JUnit puede ser una llamada 'assertThat()'
jvm.inspections.unconstructable.test.case.junit3.descriptor=La clase de test <code>\#ref</code> no es construible porque no tiene un constructor 'public' sin argumentos o con un solo parámetro 'String' \#loc
jvm.inspections.unconstructable.test.case.junit4.descriptor=La clase de test <code>\#ref</code> no es construible porque debe tener exactamente un constructor 'public' sin argumentos \#loc
jvm.inspections.unconstructable.test.case.not.public.descriptor=La clase de test <code>\#ref</code> no es construible porque no es 'public' \#loc
method.name.not.specified.error.message=No se ha especificado el nombre del método
module.does.not.exists=El módulo ''{0}'' no existe en el proyecto ''{1}''
module.to.choose.classpath.not.specified.error.message=No se ha especificado el módulo del cual elegir el classpath
multiple.exceptions.declared.on.test.method.display.name=Múltiples excepciones declaradas en método de test
multiple.exceptions.declared.on.test.method.problem.descriptor=<code>\#ref</code> podría reemplazarse con 'throws Exception' \#loc
no.module.selected.error.message=No se ha seleccionado ningún módulo
no.pattern.error.message=No se ha seleccionado ningún patrón
no.test.class.specified.error.text=No se ha especificado ninguna clase de test
package.does.not.exist.error.message=El paquete ''{0}'' no existe
pattern.label=Patrón
progress.title.download.additional.dependencies=Descargando dependencias adicionales…
repeat.count.label=Contador de repetición(&R)\:
repeat.label=Repetir(&R)\:
repeat.name=Repetir
running.tests.disabled.during.index.update.error.message=La ejecución de tests está deshabilitada durante la actualización del índice
search.scope.module=En un solo módulo
search.scope.module.deps=A través de dependencias del módulo
search.scope.name=Buscar tests
search.scope.project=En todo el proyecto
tag.expression.label=Expresión de etiqueta
tag.name.0.must.be.syntactically.valid.warning=El nombre de etiqueta [{0}] debe ser sintácticamente válido
tags.are.not.specified.error.message=No se han especificado etiquetas
test.class.hint=El nombre completamente calificado de una clase que contiene tests
test.discovery.by.all.changes.combo.item=Todos
test.group=Tests
test.kind.hint=El tipo de recurso para buscar tests
test.method.doesnt.exist.error.message=El método de test ''{0}'' no existe
test.method.hint=El nombre completamente calificado de un método de test
test.package.hint=El nombre del paquete que contiene tests
test.pattern.hint=Una expresión regular para coincidir con los nombres de las clases que contienen tests
uniqueid.label=UniqueId
unused.declaration.junit.test.entry.point=Casos de test JUnit
usage.of.obsolete.assert.display.name=Uso de método obsoleto 'junit.framework.Assert'
use.of.obsolete.assert.problem.descriptor=La llamada a <code>\#ref()</code> de ''{0}'' debe reemplazarse con llamada a método de ''org.junit.Assert'' \#loc
use.of.obsolete.assert.quickfix=Reemplazar con llamada a método de 'org.junit.Assert'