action.AddToISuite.text=Agregar a la suite de patrones de JUnit
action.excludeFromSuite.text=Excluir de la suite
action.text.test.category=Pruebas de {0}
action.text.test.tags=Pruebas de {0}
action.text.test.unknown.target=Objetivo desconocido
cannot.browse.test.inheritors.dialog.title=No se puede explorar los herederos del TestCase
category.interface.dialog.title=Categoría de Interfaz
category.is.not.specified.error.message=Categoría no especificada
category.label=Categoría
change.list.label=Lista de cambios
class.isnt.inheritor.of.testcase.error.message={0} no es heredero de TestCase
class.not.test.error.message=La clase ''{0}'' no es una prueba
combobox.changelists.all=Todos
configuration.not.specified.message=Tipo de prueba de configuración no especificado: {0}
create.setup.dialog.message=El método setUp ya existe pero no está anotado como {0}. ¿Quieres anotarlo?
create.setup.dialog.title=Crear método setUp
default.junit.config.empty.category=Categoría no válida
default.junit.config.name.all.in.module=Todos en {0}
default.junit.config.name.all.in.package.in.module={0} en {1}
default.junit.config.name.category=@Category({0})
default.junit.config.name.tags=Etiquetas ({0})
default.junit.config.name.temp.suite=Suite temporal
default.junit.config.name.whole.project=Proyecto completo
default.junit.configuration.name=<sin nombre>
dialog.message.failed.to.resolve.maven.id=Error al resolver {0}
dialog.message.no.unique.id.specified.exception=No se especificó un identificador unívoco
dialog.title.preparing.test=Preparando la prueba
directory.0.is.not.found.error.message=No se encuentra el directorio ''{0}''
directory.is.not.specified.error.message=El directorio no está especificado
directory.label=Directorio
directory.not.found.error.message=No se encontró el directorio ''{0}''
expected.exception.never.thrown.display.name=Excepción esperada nunca lanzada en el cuerpo del método de prueba
expected.exception.never.thrown.problem.descriptor=Excepción esperada <code>#ref</code> nunca lanzada en el cuerpo de ''{0}()'' #loc
fix.data.provider.create.method.fix.name=Crear método de proveedor de datos '@Parameters public static Iterable<Object> parameters()'
fix.data.provider.multiple.methods.problem=Existen varios métodos del proveedor de datos @Parameters presentes en la clase <code>#ref</code>
fix.data.provider.signature.family.name=Corregir firma del método del proveedor de datos
fix.data.provider.signature.fix.name=Cambiar la firma del método a ''{0}''
fix.data.provider.signature.incorrect.problem=El método del proveedor de datos <code>#ref()</code> tiene una firma incorrecta
fix.data.provider.signature.missing.method.problem=La clase de pruebas parametrizada `#ref` carece de método proveedor de datos anotado con '@Parameters'
fork.mode.label=Modo de forked:(&F)
fork.mode.name=Modo de bifurcar
inspection.parameterized.parameters.static.collection.display.name=Clase de prueba parametrizada sin método proveedor de datos
junit.config.with.parameter.0=con el parámetro "{0}" 
junit.configuration.across.module.dependencies.radio=Entre dependencias de módulo(s)
junit.configuration.class.label=Clase:
junit.configuration.description=Configuración de pruebas JUnit
junit.configuration.display.name=JUnit
junit.configuration.fork.mode.class=Clase
junit.configuration.fork.mode.method=Método
junit.configuration.fork.mode.none=Ninguno
junit.configuration.fork.mode.repeat=Repetir
junit.configuration.in.single.module.radio=En módulo único
junit.configuration.in.whole.project.radio=En todo el proyecto
junit.configuration.kind.all.in.directory=Todos en el directorio
junit.configuration.kind.all.in.package=Todo en el paquete
junit.configuration.kind.by.pattern=Por patrón
junit.configuration.kind.by.tags=Por etiquetas
junit.configuration.kind.by.unique.id=UniqueId
junit.configuration.kind.category=Categoría
junit.configuration.kind.class=Clase
junit.configuration.kind.method=Método
junit.configuration.method.label=Método:
junit.configuration.package.label=Paquete:G
junit.configuration.repeat.mode.n.times=N veces
junit.configuration.repeat.mode.once=Una vez
junit.configuration.repeat.mode.until.failure=Hasta el fallo
junit.configuration.repeat.mode.until.stopped=Hasta detenerse
junit.configuration.repeat.mode.until.success=Hasta que tenga éxito
junit.configuration.search.for.tests.label=Buscar pruebas:
junit.entry.point.suggest.package.private.visibility.junit5=Sugerir nivel de visibilidad de paquete privado para pruebas de JUnit 5
junit.inspections.group.name=JUnit
junit.not.found.in.module.error.message=JUnit no encontrado en el módulo ''{0}''
junit3.style.test.method.in.junit4.class.display.name=Método de prueba JUnit de estilo antiguo en una clase JUnit 4
junit3.style.test.method.in.junit4.class.problem.descriptor=Método de prueba antiguo JUnit3 <code>#ref()</code> en clase JUnit4 #loc
junit5.migration.description=Para transferir las anotaciones de pruebas JUnit 4 a las nuevas Jupiter, puede que el código se ponga en rojo. ¡No se migrarán las afirmaciones!. Revise la inspección 'Java | Incidencias de JUnit | Los tests de JUnit 4 pueden ser JUnit 5' para migrar solo aquellas pruebas que puedan convertirse automáticamente.
jvm.inspections.junit.assertequals.may.be.assertsame.display.name='assertEquals()' puede ser 'assertSame()'
jvm.inspections.junit.assertequals.may.be.assertsame.problem.descriptor=<code>#ref()</code> puede ser 'assertSame()' #loc
jvm.inspections.junit.assertequals.on.array.display.name=Se llamó a 'assertEquals()' en el array
jvm.inspections.junit.assertequals.on.array.problem.descriptor=Se llama <code>#ref()</code> al arreglo #loc
jvm.inspections.junit.ignored.test.class.problem.descriptor=La clase de pruebas ''{0}'' se ha ignorado/deshabilitado {1, choice, 1#|2#sin motivo} #loc
jvm.inspections.junit.ignored.test.display.name=Prueba JUnit anotada con '@Ignore'/'@Disabled'
jvm.inspections.junit.ignored.test.ignore.reason.option=Reportar solo anotaciones sin razón
jvm.inspections.junit.ignored.test.method.problem.descriptor=El método de prueba ''{0}()'' está ignorado/deshabilitado {1, choice, 1#|2#sin razón} #loc
jvm.inspections.junit.malformed.annotated.double.descriptor={0, choice, 0#Campo|1#Método} <code>#ref</code> anotado con ''@{1}'' debe ser {2} y {3}
jvm.inspections.junit.malformed.annotated.double.typed.descriptor={0, choice, 0#Campo|1#Método} <code>#ref</code> anotado con ''@{1}'' debería ser {2}, {3} y de tipo ''{4}''
jvm.inspections.junit.malformed.annotated.method.double.param.double.descriptor=El método <code>#ref</code> anotado con ''@{0}'' debe ser {1}, {2} y no declarar los parámetros ''{3}'' y ''{4}''
jvm.inspections.junit.malformed.annotated.method.double.param.single.descriptor=Método <code>#ref</code> anotado con ''@{0}'' debería ser {1}, {2} y no declarar el parámetro ''{3}''
jvm.inspections.junit.malformed.annotated.method.double.typed.param.double.descriptor=El método <code>#ref</code> anotado con ''@{0}'' debe ser {1}, {2}, de tipo ''{3}'' y no declarar parámetros {4} y ''{5}''
jvm.inspections.junit.malformed.annotated.method.double.typed.param.single.descriptor=El método <code>#ref</code> anotado con ''@{0}'' debe ser {1}, {2}, de tipo ''{3}'' y no declarar el parámetro ''{4}''
jvm.inspections.junit.malformed.annotated.method.param.double.descriptor=El método <code>#ref</code> anotado con <code>''@{0}''</code> no debería declarar los parámetros {1} y ''{2}''
jvm.inspections.junit.malformed.annotated.method.param.single.descriptor=El método <code>#ref</code> anotado con ''@{0}'' no debe declarar el parámetro ''{1}''
jvm.inspections.junit.malformed.annotated.method.single.param.double.descriptor=El método <code>#ref</code> anotado con ''@{0}'' debe ser {1} y no declarar los parámetros ''{2}'' y ''{3}''
jvm.inspections.junit.malformed.annotated.method.single.param.single.descriptor=El método <code>#ref</code> anotado con ''@{0}'' debe ser {1} y no declarar el parámetro ''{2}''
jvm.inspections.junit.malformed.annotated.method.single.typed.param.double.descriptor=El método <code>#ref</code> anotado con ''@{0}'' debe ser {1} de tipo ''{2}'' y no declarar los parámetros {3} y ''{4}''
jvm.inspections.junit.malformed.annotated.method.single.typed.param.single.descriptor=El método <code>#ref</code> anotado con '@{0}' debe ser {1}, de tipo ''{2}'' y no declarar el parámetro ''{3}''
jvm.inspections.junit.malformed.annotated.method.typed.param.double.descriptor=El método <code>#ref</code> anotado con ''@{0}'' debe ser de tipo ''{1}'' y no declarar los parámetros {2} y ''{3}''
jvm.inspections.junit.malformed.annotated.method.typed.param.single.descriptor=El método `#ref` anotado con ''@{0}'' debe ser de tipo ''{1}'' y no declarar el parámetro ''{2}''
jvm.inspections.junit.malformed.annotated.single.descriptor=El {0, choice, 0#campo|1#método} <code>#ref</code> anotado con ''@{1}'' debe ser {2}
jvm.inspections.junit.malformed.annotated.single.typed.descriptor={0, choice, 0#Campo|1#Método} <code>#ref</code> anotado con ''@{1}'' debería ser {2} y de tipo ''{3}''
jvm.inspections.junit.malformed.annotated.suspend.function.descriptor=Método <code>#ref</code> anotado con ''@{0}'' no debería ser una función suspendida
jvm.inspections.junit.malformed.annotated.typed.descriptor=El campo <code>#ref</code>{0, choice, 0# o método} anotado con ''@{1}'' debería ser del tipo ''{2}''
jvm.inspections.junit.malformed.declaration.name=Declaración incorrecta de JUnit
jvm.inspections.junit.malformed.extension.class.level.descriptor={0} debe registrarse a nivel de clase
jvm.inspections.junit.malformed.fix.class.signature=Corregir firma de clase
jvm.inspections.junit.malformed.fix.class.signature.descriptor=Arreglar la firma de clase ''{0}''
jvm.inspections.junit.malformed.fix.class.signature.multi=Corregir firmas de clase
jvm.inspections.junit.malformed.fix.field.signature=Corregir firma de campo
jvm.inspections.junit.malformed.fix.field.signature.descriptor=Corregir la firma ''{0}'' del campo
jvm.inspections.junit.malformed.fix.method.signature=Arreglar firma de método
jvm.inspections.junit.malformed.fix.method.signature.descriptor=Arreglar firma del método ''{0}''
jvm.inspections.junit.malformed.missing.nested.annotation.descriptor=Las pruebas en clases anidadas no se ejecutarán
jvm.inspections.junit.malformed.no.arg.descriptor=El método <code>#ref</code> debe ser {0}, {1}{2, choice, 0# y no tener parámetros | 1#, no tener parámetros y de tipo void}
jvm.inspections.junit.malformed.option.ignore.test.parameter.if.annotated.by=Ignorar parámetros de prueba si están anotados por:
jvm.inspections.junit.malformed.param.duplicated.enum.descriptor=Nombre de constante 'enum' duplicado
jvm.inspections.junit.malformed.param.empty.source.unsupported.descriptor=''@{0}'' no puede proporcionar un argumento al método porque el método tiene un parámetro no compatible de tipo ''{1}''
jvm.inspections.junit.malformed.param.exactly.one.type.of.input.must.be.provided.descriptor=Debe proporcionarse exactamente un tipo de entrada
jvm.inspections.junit.malformed.param.file.source.descriptor=No puede resolver el origen del archivo: ''{0}''
jvm.inspections.junit.malformed.param.method.source.assignable.descriptor=No se encontró conversión implícita para convertir ''{0}'' en ''{1}''
jvm.inspections.junit.malformed.param.method.source.no.params.descriptor=El método fuente ''{0}'' no debería tener parámetros
jvm.inspections.junit.malformed.param.method.source.return.type.descriptor=El método de origen ''{0}'' debe tener uno de los siguientes tipos de retorno: ''Stream<?>'', ''Iterator<?>'', ''Iterable<?>'' u ''Object[]''
jvm.inspections.junit.malformed.param.method.source.static.descriptor=El método origen ''{0}'' debe ser estático
jvm.inspections.junit.malformed.param.method.source.unresolved.descriptor=No se puede resolver la fuente del método de destino: ''{0}''
jvm.inspections.junit.malformed.param.multiple.parameters.descriptor=Esta fuente no admite múltiples parámetros
jvm.inspections.junit.malformed.param.no.sources.are.provided.descriptor=No se proporcionaron fuentes, la suite estará vacía
jvm.inspections.junit.malformed.param.no.value.source.is.defined.descriptor=Sin valor definido para el origen
jvm.inspections.junit.malformed.param.unresolved.enum.descriptor=No se puede resolver la referencia a la constante 'enum'.
jvm.inspections.junit.malformed.param.wrapped.in.arguments.descriptor=Los múltiples parámetros deben estar encapsulados en 'Arguments'
jvm.inspections.junit.malformed.repetition.number.descriptor=El número de repeticiones debe ser mayor a cero
jvm.inspections.junit.malformed.source.without.params.descriptor=''{0}'' no puede proporcionar un argumento al método porque éste no tiene parámetros
jvm.inspections.junit.malformed.suspend.function.descriptor=El método <code>#ref</code> no debe ser una función suspendida
jvm.inspections.junit.malformed.test.combination.descriptor=Combinación sospechosa de {0} y ''@{1}''
jvm.inspections.junit.mixed.annotations.junit.descriptor=Método <code>#ref()</code> anotado con ''@{0}'' dentro de una clase que extiende #loc JUnit  {1} TestCase
jvm.inspections.junit.mixed.annotations.name=Uso de API de JUnit de múltiples versiones en un solo TestCase
jvm.inspections.junit3.super.teardown.display.name=No se llama a 'super.tearDown()' de JUnit 3 desde el bloque 'finally'
jvm.inspections.junit3.super.teardown.problem.descriptor=No se llama <code>#ref()</code> desde el bloque 'finally' #loc
jvm.inspections.junit4.converter.display.name=Los tests JUnit 3 pueden ser JUnit 4
jvm.inspections.junit4.converter.problem.descriptor=<code>#ref</code> se podría convertir a un caso de prueba JUnit4
jvm.inspections.junit4.converter.quickfix.conflict.call.compile=La llamada al método {0} no compilará cuando se convierta a JUnit 4 {1}
jvm.inspections.junit4.converter.quickfix.conflict.name=El método {0} tendrá un conflicto de nombre con su método super
jvm.inspections.junit4.converter.quickfix.conflict.semantics=La llamada al método {0} puede cambiar la semántica cuando se convierte {1} a JUnit 4
jvm.inspections.junit4.converter.quickfix.conflict.suite=La migración del método suite para {0} tiene efectos secundarios que se eliminarán
jvm.inspections.junit4.converter.quickfix.name=Convertir a caso de prueba JUnit 4
jvm.inspections.junit4.inherited.runwith.display.name='@RunWith' ya existe en una clase padre
jvm.inspections.junit4.inherited.runwith.problem.descriptor='La anotación @RunWith ya existe en la clase {0}'
jvm.inspections.junit5.assertions.converter.display.name=Asertos obsoletos de JUnit 5
jvm.inspections.junit5.assertions.converter.familyName=Reemplazar con llamada JUnit 5 compatible
jvm.inspections.junit5.assertions.converter.problem.descriptor=La llamada de <code>#ref()</code> a ''{0}'' debe reemplazarse por una llamada a un método de ''{1}'' #loc
jvm.inspections.junit5.assertions.converter.quickfix=Reemplazar con la llamada al método ''{0}''
jvm.inspections.junit5.converter.display.name=La prueba JUnit 4 puede ser de JUnit 5
jvm.inspections.junit5.converter.problem.descriptor=#ref puede ser una prueba de JUnit 5
jvm.inspections.junit5.converter.quickfix=Migrar a JUnit 5
jvm.inspections.junit5.converter.quickfix.conflict.inheritor=La clase {0} no se puede convertir a JUnit 5 porque existen herederos incompatibles: {1}
jvm.inspections.junit5.converter.quickfix.presentation.text=Convertir Aserciones
jvm.inspections.migrate.assert.to.matcher.description=La expresión assert <code>#ref</code> se puede reemplazar por la llamada a ''{0}'' #loc
jvm.inspections.migrate.assert.to.matcher.option=Importar estáticamente los métodos de Matcher
jvm.inspections.migrate.assertion.name=La aserción JUnit puede ser una llamada 'assertThat()'
jvm.inspections.unconstructable.test.case.junit3.descriptor=La clase de prueba <code>#ref</code> no es construible porque no tiene un constructor de parámetro 'público' sin argumentos o único 'String' #loc
jvm.inspections.unconstructable.test.case.junit4.descriptor=La clase <code>#ref</code> de la prueba no se puede construir porque debe tener únicamente un constructor "public" sin argumento #loc
jvm.inspections.unconstructable.test.case.not.public.descriptor=La clase de prueba <code>#ref</code> no es construible porque no es 'public' #loc
method.name.not.specified.error.message=Nombre del método no especificado
module.does.not.exists=El módulo ''{0}'' no existe en el proyecto ''{1}''
module.to.choose.classpath.not.specified.error.message=Módulo de donde seleccionar la ruta de acceso a la clase no especificado
multiple.exceptions.declared.on.test.method.display.name=Múltiples excepciones declaradas en el método de prueba
multiple.exceptions.declared.on.test.method.problem.descriptor=<code>#ref</code> podría reemplazarse con 'throws Exception' #loc
no.module.selected.error.message=Ningún módulo seleccionado
no.pattern.error.message=Ningún patrón seleccionado
no.test.class.specified.error.text=Clase de prueba no especificada
package.does.not.exist.error.message=El paquete ''{0}'' no existe
pattern.label=Patrón
progress.title.download.additional.dependencies=Descargando dependencias adicionales...
repeat.count.label=Contador de repeticiones:(&R)
repeat.label=Repetir:(&R)
repeat.name=Repetir
running.tests.disabled.during.index.update.error.message=Ejecución de pruebas deshabilitada durante la actualización del índice
search.scope.module=Sólo módulo
search.scope.module.deps=A través de dependencias de módulos
search.scope.name=Buscar pruebas
search.scope.project=En todo el proyecto
tag.expression.label=Expresión etiqueta
tag.name.0.must.be.syntactically.valid.warning=El nombre de etiqueta [{0}] debe ser sintácticamente válido
tags.are.not.specified.error.message=No se especificaron las etiquetas
test.class.hint=Nombre calificado de la clase que contiene pruebas
test.discovery.by.all.changes.combo.item=Todos
test.group=Pruebas
test.kind.hint=Tipo de recurso donde buscar las pruebas
test.method.doesnt.exist.error.message=El método de prueba ''{0}'' no existe
test.method.hint=El nombre completo cualificado de un método de prueba
test.package.hint=Nombre del paquete que contiene pruebas
test.pattern.hint=Expresión regular para identificar los nombres de las clases que contienen pruebas
uniqueid.label=UniqueId
unused.declaration.junit.test.entry.point=Casos de prueba JUnit
usage.of.obsolete.assert.display.name=Uso del método obsoleto 'junit.framework.Assert'
use.of.obsolete.assert.problem.descriptor=La llamada a `#ref()` desde ''{0}'' debe reemplazarse con una llamada al método de ''org.junit.Assert'' #loc
use.of.obsolete.assert.quickfix=Sustituir con llamada al método 'org.junit.Assert'