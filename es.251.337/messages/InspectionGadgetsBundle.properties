0.will.no.longer.be.overridable.by.1={0} ya no podrá ser sobrescrito por {1}
absolute.alignment.in.user.interface.display.name=Alineación absoluta en código AWT/Swing
absolute.alignment.in.user.interface.fix.family.name=Reemplazar con constante
absolute.alignment.in.user.interface.problem.descriptor=Se usa la constante de alineación absoluta <code>{0}.\#ref</code> \#loc
abstract.class.extends.concrete.class.display.name=Clase abstracta extiende clase concreta
abstract.class.extends.concrete.class.problem.descriptor=La clase <code>\#ref</code> está declarada como 'abstract' y extiende una clase concreta \#loc
abstract.class.naming.convention.element.description=Clase abstracta
abstract.class.never.implemented.display.name=Clase abstracta que no tiene subclase concreta
abstract.class.never.implemented.problem.descriptor=La clase abstracta <code>\#ref</code> no tiene subclase concreta \#loc
abstract.class.with.only.one.direct.inheritor.display.name=Clase abstracta con un único heredero directo
abstract.class.with.only.one.direct.inheritor.problem.descriptor=La clase abstracta <code>\#ref</code> tiene solo un heredero directo \#loc
abstract.class.without.abstract.methods.display.name=Clase abstracta sin métodos 'abstract'
abstract.class.without.abstract.methods.ignore.utility.class.option=Ignorar clases utilitarias
abstract.class.without.abstract.methods.problem.descriptor=La clase <code>\#ref</code> está declarada como 'abstract' y no tiene métodos 'abstract' \#loc
abstract.method.call.in.constructor.display.name=Método abstract llamado durante la construcción del objeto
abstract.method.call.in.constructor.problem.descriptor=Llamada al método 'abstract' <code>\#ref()</code> durante la construcción del objeto \#loc
abstract.method.overrides.abstract.method.display.name=Método abstract sobrescribe método abstract
abstract.method.overrides.abstract.method.ignore.different.javadoc.option=Ignorar métodos con Javadoc diferente al de sus super métodos
abstract.method.overrides.abstract.method.problem.descriptor=El método abstract <code>\#ref()</code> sobrescribe método abstract \#loc
abstract.method.overrides.abstract.method.remove.quickfix=Eliminar declaración redundante de método abstract
abstract.method.overrides.concrete.method.display.name=Método abstract sobrescribe método concreto
abstract.method.overrides.concrete.method.problem.descriptor=El método abstract <code>\#ref()</code> sobrescribe método concreto \#loc
abstract.method.with.missing.implementations.display.name=Método abstract con implementaciones faltantes
abstract.method.with.missing.implementations.problem.descriptor=El método abstract <code>\#ref()</code> no está implementado en todas las subclases \#loc
access.to.non.thread.safe.static.field.from.instance.class.chooser.title=Elegir Clase No Thread-Safe
access.to.non.thread.safe.static.field.from.instance.display.name=Acceso a campo 'static' no thread-safe
access.to.non.thread.safe.static.field.from.instance.field.problem.descriptor=Acceso a campo static no thread-safe <code>\#ref</code> de tipo ''{0}'' \#loc
access.to.non.thread.safe.static.field.from.instance.option.title=Clases no thread-safe\:
access.to.static.field.locked.on.instance.display.name=Acceso a campo 'static' bloqueado en datos de instancia
access.to.static.field.locked.on.instance.fix.name=Ignorar campos static con tipo ''{0}''
access.to.static.field.locked.on.instance.problem.descriptor=Acceso al campo static <code>\#ref</code> bloqueado en datos de instancia \#loc
accessing.non.public.field.of.another.object.display.name=Acceso a un campo no public de otro objeto
accessing.non.public.field.of.another.object.problem.descriptor=Acceso directo al campo no public <code>\#ref</code> de otro objeto \#loc
add.0.to.ignore.if.annotated.by.list.quickfix=Agregar ''{0}'' a la lista "Ignorar si está anotado por"
add.catch.section.fix.family.name=Agregar cláusula 'catch'
add.read.write.object.methods.fix.family.name=Agregar métodos 'readObject()' y 'writeObject()' que siempre lanzan una excepción
add.read.write.object.methods.fix.text=Agregar método 'writeObject()' que siempre lanza una excepción
add.read.write.object.methods.fix.text2=Agregar método 'readObject()' que siempre lanza una excepción
add.serialversionuidfield.quickfix=Agregar campo 'serialVersionUID'
add.this.qualifier.quickfix=Agregar calificador 'this'
add.throws.clause.fix.family.name=Corregir cláusula 'throws'
all.levels.option=todos los niveles de log
allow.resource.to.be.opened.inside.a.try.block=Permitir que el recurso se abra dentro de un bloque 'try'
ambiguous.field.access.display.name=El acceso a campo heredado parece acceso a elemento del código circundante
ambiguous.field.access.hides.field.problem.descriptor=El acceso al campo <code>\#ref</code> de la superclase ''{0}'' parece acceso a campo de la clase circundante \#loc
ambiguous.field.access.hides.local.variable.problem.descriptor=El acceso al campo <code>\#ref</code> de la superclase ''{0}'' parece acceso a variable local \#loc
ambiguous.field.access.hides.parameter.problem.descriptor=El acceso al campo <code>\#ref</code> de la superclase ''{0}'' parece acceso a parámetro \#loc
ambiguous.field.access.navigate.quickfix=Navegar a {0, choice, 1\#variable local|2\#parámetro|3\#campo} aparentemente accedido
ambiguous.field.access.quickfix=Agregar calificador 'super' al acceso del campo
ambiguous.method.call.display.name=La llamada al método heredado parece una llamada a método local
ambiguous.method.call.problem.descriptor=La llamada al método <code>\#ref()</code> de la superclase ''{0}'' parece una llamada al método de la clase ''{1}'' \#loc
ambiguous.method.call.quickfix=Agregar calificador 'super' a la llamada del método
annotation.class.display.name=Interfaz de anotación
annotation.class.problem.descriptor=Interfaz de anotación <code>\#ref</code> \#loc
annotation.display.name=Anotación
annotation.naming.convention.element.description=Interfaz de anotación
annotation.problem.descriptor=Anotación <code>\#ref</code> \#loc
anonymous.class.field.hides.containing.method.variable.problem.descriptor=El campo de clase anónima <code>\#ref</code> oculta variable en el método contenedor \#loc
anonymous.class.parameter.hides.containing.method.variable.problem.descriptor=El parámetro de clase anónima <code>\#ref</code> oculta variable en el método contenedor \#loc
anonymous.class.variable.hides.containing.method.variable.display.name=Variable de clase anónima oculta variable en el método contenedor
anonymous.class.variable.hides.containing.method.variable.problem.descriptor=La variable local de clase anónima <code>\#ref</code> oculta variable en el método contenedor \#loc
anonymous.extends.concrete.collection.problem.descriptor=La clase anónima extiende explícitamente ''{0}'' \#loc
anonymous.extends.thread.problem.descriptor=La clase anónima extiende directamente 'java.lang.Thread' \#loc
anonymous.extends.throwable.problem.descriptor=La clase anónima extiende directamente 'java.lang.Throwable' \#loc
anonymous.inner.class.display.name=La clase anónima puede ser reemplazada por clase interna
anonymous.inner.class.problem.descriptor=Clase anónima <code>\#ref</code> \#loc
anonymous.inner.class.with.too.many.methods.display.name=Clase anónima con demasiados métodos
anonymous.inner.class.with.too.many.methods.problem.descriptor=Clase anónima con demasiados métodos (cantidad de métodos \= {0}) \#loc
anonymous.inner.may.be.named.static.inner.class.display.name=La clase anónima podría ser una clase interna 'static' con nombre
anonymous.inner.may.be.named.static.inner.class.problem.descriptor=La clase anónima <code>\#ref</code> podría ser una clase interna 'static' con nombre \#loc
anonymous.inner.may.be.named.static.inner.class.quickfix=Convertir a clase interna 'static' con nombre
any.method.may.close.resource.argument=Cualquier método puede cerrar el argumento del recurso
array.allocation.zero.length.display.name=Asignación de array de longitud cero
array.allocation.zero.length.problem.descriptor=Asignación de array de longitud cero \#loc
array.can.be.replaced.with.enum.values=El array puede ser reemplazado con valores enum
array.can.be.replaced.with.enum.values.family.quickfix=Reemplazar array con EnumType.values()
array.can.be.replaced.with.enum.values.quickfix=Reemplazar array con {0}.values()
array.comparison.display.name=Comparación de arrays usando '\=\=' en lugar de 'Arrays.equals()'
array.comparison.problem.descriptor=Los objetos array se comparan usando <code>\#ref</code>, no 'Arrays.equals()' \#loc
array.creation.without.new.keyword.family.quickfix=Agregar expresión 'new'
array.creation.without.new.keyword.name=Creación de array sin expresión 'new'
array.creation.without.new.keyword.quickfix=Agregar ''new {0}''
array.equals.problem.descriptor=La comparación de arrays probablemente debería hacerse usando ''{0}''
array.hash.code.display.name='hashCode()' llamado en array
array.hash.code.fix.family.name=Reemplazar con llamada a 'Arrays.hashCode()'
array.hash.code.problem.descriptor=<code>\#ref()</code> llamado en array probablemente debería ser 'Arrays.hashCode()' \#loc
array.hashcode.problem.descriptor=El cálculo del hash code del array probablemente debería hacerse usando ''{0}''
array.length.in.loop.condition.display.name=Array.length en condición de bucle
array.length.in.loop.condition.problem.descriptor=Comprobación del array <code>\#ref</code> en condición de bucle \#loc
array.objects.equals.display.name=Uso de métodos superficiales o de 'Objects' con arrays
arrays.as.list.with.one.argument.problem.descriptor=Llamada a <code>\#ref()</code> con solo un argumento \#loc
arrays.as.list.with.zero.arguments.problem.descriptor=Llamada a <code>\#ref()</code> para crear una List vacía \#loc
arrays.as.list.with.zero.or.one.argument.display.name=Llamada a 'Arrays.asList()' con muy pocos argumentos
assert.can.be.if.quickfix=Reemplazar 'assert' con sentencia 'if'
assert.keyword.is.considered.an.assertion=La palabra clave 'assert' se considera una aserción
assert.message.not.string.display.name=El mensaje 'assert' no es un string
assert.message.not.string.only.warn.boolean.option=Solo advertir cuando el mensaje 'assert' es 'boolean' o 'java.lang.Boolean'
assert.message.of.type.boolean.problem.descriptor=Mensaje ''assert'' de tipo ''{0}'' \#loc
assert.statement.display.name=Sentencia 'assert'
assert.with.side.effects.call.mutates.expression=la llamada a ''{0}()'' modifica ''{1}''
assert.with.side.effects.call.mutates.field=la llamada a ''{0}()'' modifica el campo ''{1}''
assert.with.side.effects.call.performs.io=la llamada a ''{0}()'' realiza operación de entrada/salida
assert.with.side.effects.display.name=Sentencia 'assert' con efectos secundarios
assert.with.side.effects.problem.descriptor=<code>\#ref</code> tiene efectos secundarios\: {0} \#loc
assert.without.message.problem.descriptor=<code>\#ref()</code> sin mensaje \#loc
assert.without.message.quick.fix.family.name=Agregar mensaje de error
assertion.can.be.if.name=La aserción puede reemplazarse con sentencia 'if'
asserts.without.messages.display.name=Falta mensaje en la aserción
assignment.of.field.with.mutable.type.problem.descriptor=Asignación a campo {0} ''{1}'' desde parámetro <code>\#ref</code> \#loc
assignment.or.return.of.field.with.mutable.type.display.name=Asignación o retorno de campo con tipo mutable
assignment.replaceable.with.operator.assignment.display.name=La asignación puede reemplazarse con asignación de operador
assignment.replaceable.with.operator.assignment.ignore.conditional.operators.option=Ignorar operadores condicionales
assignment.replaceable.with.operator.assignment.ignore.obscure.operators.option=Ignorar los operadores oscuros ^ y %
assignment.replaceable.with.operator.assignment.problem.descriptor=<code>\#ref</code> puede simplificarse a ''{0}'' \#loc
assignment.to.catch.block.parameter.display.name=Asignación a parámetro de bloque 'catch'
assignment.to.catch.block.parameter.problem.descriptor=Asignación a parámetro de bloque 'catch' <code>\#ref</code> \#loc
assignment.to.for.loop.parameter.check.foreach.option=Verificar parámetros de bucle 'for' mejorado
assignment.to.for.loop.parameter.display.name=Asignación a parámetro de bucle 'for'
assignment.to.for.loop.parameter.problem.descriptor=Asignación a parámetro de bucle for <code>\#ref</code> \#loc
assignment.to.lambda.parameter.display.name=Asignación a parámetro lambda
assignment.to.lambda.parameter.problem.descriptor=Asignación a parámetro lambda <code>\#ref</code> \#loc
assignment.to.method.parameter.display.name=Asignación a parámetro de método
assignment.to.method.parameter.ignore.transformation.option=<html>Ignorar si la asignación es una transformación del parámetro original</html>
assignment.to.method.parameter.problem.descriptor=Asignación a parámetro de método <code>\#ref</code> \#loc
assignment.to.null.display.name=Asignación de 'null'
assignment.to.null.option=Ignorar asignaciones a campos
assignment.to.null.problem.descriptor='null' asignado a la variable <code>\#ref</code> \#loc
assignment.to.static.field.from.instance.method.display.name=Asignación a campo static desde contexto de instancia
assignment.to.static.field.from.instance.method.problem.descriptor=Asignación a campo static <code>\#ref</code> desde contexto de instancia \#loc
assignment.to.superclass.field.display.name=Constructor asigna valor a campo definido en superclase
assignment.to.superclass.field.problem.descriptor=Asignación a campo ''{0}'' definido en superclase ''{1}'' \#loc
assignment.used.as.condition.display.name=Asignación usada como condición
assignment.used.as.condition.problem.descriptor=Asignación <code>\#ref</code> usada como condición \#loc
atomic.field.updater.issues.display.name=Declaración inconsistente de 'AtomicFieldUpdater'
atomic.field.updater.not.static.final.display.name=Campo 'AtomicFieldUpdater' no declarado 'static final'
atomic.field.updater.not.static.final.problem.descriptor=Campo {0} <code>\#ref</code> no declarado como ''static final'' \#loc
auto.boxing.display.name=Auto-boxing
auto.boxing.ignore.added.to.collection.option=Ignorar expresiones agregadas a una colección
auto.boxing.make.boxing.explicit.quickfix=Hacer el boxing explícito
auto.boxing.problem.descriptor=Auto-boxing <code>\#ref</code> \#loc
auto.closeable.resource.display.name=AutoCloseable usado sin 'try'-with-resources
auto.closeable.resource.problem.descriptor=''{0}'' usado sin sentencia ''try''-with-resources \#loc
auto.closeable.resource.quickfix=Ignorar 'AutoCloseable' devuelto por este método
auto.closeable.resource.quickfix.preview=Agregar método <code>{0}</code> a la lista de métodos ignorados
auto.closeable.resource.returned.option=Ignorar instancias AutoCloseable devueltas de todas las llamadas a métodos
auto.unboxing.display.name=Auto-unboxing
auto.unboxing.make.unboxing.explicit.quickfix=Hacer el unboxing explícito
auto.unboxing.problem.descriptor=Auto-unboxing <code>\#ref</code> \#loc
await.not.in.loop.display.name='await()' no llamado en bucle
await.not.in.loop.problem.descriptor=Llamada a <code>\#ref()</code> no está en bucle \#loc
await.without.corresponding.signal.display.name='await()' sin 'signal()' correspondiente
await.without.corresponding.signal.problem.descriptor=Llamada a <code>\#ref()</code> sin <code>signal()</code> o <code>signalAll()</code> correspondiente \#loc
bad.exception.caught.display.name=Excepción prohibida 'Exception' capturada
bad.exception.caught.problem.descriptor=Excepción prohibida <code>\#ref</code> capturada \#loc
bad.exception.declared.display.name=Excepción prohibida declarada
bad.exception.declared.problem.descriptor=Excepción prohibida <code>\#ref</code> declarada \#loc
bad.exception.thrown.display.name=Excepción prohibida lanzada
bad.exception.thrown.problem.descriptor=Excepción prohibida ''{0}'' lanzada \#loc
bad.oddness.display.name=Verificación sospechosa de imparidad
bad.oddness.problem.descriptor=La verificación de imparidad fallará con valores negativos \#loc
big.decimal.equals.display.name='equals()' llamado en 'BigDecimal'
big.decimal.equals.problem.descriptor=<code>\#ref()</code> entre valores BigDecimal probablemente debería ser 'compareTo()' \#loc
big.decimal.method.without.rounding.called.display.name=Llamada a método 'BigDecimal' sin argumento de modo de redondeo
big.decimal.method.without.rounding.called.problem.descriptor='BigDecimal.\#ref()' llamado sin argumento de modo de redondeo
bigdecimal.legacy.method.display.name=Método legacy de 'BigDecimal' llamado
bigdecimal.legacy.method.problem.descriptor=La llamada a 'BigDecimal.\#ref()' puede usar constante enum 'RoundingMode'
bigdecimal.legacy.method.quickfix=Usar constante enum 'RoundingMode'
boolean.constructor.display.name=Llamada a constructor booleano
boolean.constructor.problem.descriptor=Llamada a constructor booleano \#loc
boolean.constructor.simplify.quickfix=Simplificar
boolean.expression.can.be.simplified.problem.descriptor=<code>\#ref</code> puede simplificarse a ''{0}'' \#loc
boolean.expression.does.not.modify.problem.descriptor=<code>\#ref</code> no modifica el valor de ''{0}'' \#loc
boolean.expression.may.be.conditional.display.name=La expresión booleana puede reemplazarse por expresión condicional
boolean.expression.remove.compound.assignment.quickfix=Eliminar asignación compuesta sin sentido
boolean.field.always.inverted.problem.descriptor=Campo booleano <code>\#ref</code> siempre invertido \#loc
boolean.method.name.must.start.with.question.display.name=El nombre del método booleano debe comenzar con palabra interrogativa
boolean.method.name.must.start.with.question.problem.descriptor=El nombre del método booleano <code>\#ref</code> no comienza con palabra interrogativa \#loc
boolean.method.name.must.start.with.question.table.label=Prefijos de nombres de métodos booleanos\:
boolean.parameter.constructor.problem.descriptor=Constructor 'public' <code>\#ref()</code> con parámetro 'boolean' \#loc
boolean.parameter.display.name=Método 'public' con parámetro 'boolean'
boolean.parameter.only.report.multiple.option=Solo reportar métodos con múltiples parámetros booleanos
boolean.parameter.problem.descriptor=Método 'public' <code>\#ref()</code> con parámetro 'boolean' \#loc
boolean.parameters.constructor.problem.descriptor=Constructor 'public' <code>\#ref()</code> con parámetros 'boolean' \#loc
boolean.parameters.problem.descriptor=Método 'public' <code>\#ref()</code> con parámetros 'boolean' \#loc
boolean.variable.always.inverted.display.name=Variable booleana siempre invertida
boolean.variable.always.inverted.problem.descriptor=Variable booleana <code>\#ref</code> siempre invertida \#loc
bounded.wildcard.contravariant.descriptor=Se puede generalizar a <code>? super \#ref</code> \#loc
bounded.wildcard.covariant.descriptor=Se puede generalizar a <code>? extends \#ref</code> \#loc
bounded.wildcard.display.name=Puede usar comodín acotado
bounded.wildcard.report.instance.option=Reportar métodos de instancia
bounded.wildcard.report.invariant.option=Reportar clases invariantes
bounded.wildcard.report.private.option=Reportar métodos private
boxing.boxed.value.display.name=Boxing de valor ya boxeado
boxing.boxed.value.problem.descriptor=Boxing de <code>\#ref</code> ya boxeado \#loc
boxing.boxed.value.quickfix=Eliminar boxing innecesario
break.statement.display.name=Sentencia 'break'
break.statement.with.label.display.name=Sentencia 'break' con etiqueta
break.statement.with.label.problem.descriptor=Sentencia <code>\#ref</code> con etiqueta \#loc
busy.wait.display.name=Espera activa
busy.wait.problem.descriptor=Llamada a <code>Thread.\#ref()</code> en un bucle, probablemente espera activa \#loc
c.style.array.declaration.display.name=Declaración de array estilo C
c.style.array.declaration.replace.quickfix=Reemplazar con declaración de array estilo Java
cached.number.constructor.call.display.name=Llamada a constructor Number con argumento primitivo
cached.number.constructor.call.ignore.string.arguments.option=Ignorar expresiones new number con argumento String
cached.number.constructor.call.problem.descriptor=Llamada a constructor Number con argumento primitivo \#loc
cached.number.constructor.call.report.only.deprecated=Reportar solo cuando el constructor está @Deprecated
call.to.date.tostring.display.name=Llamada a 'Date.toString()'
call.to.date.tostring.problem.descriptor=<code>Date.\#ref()</code> usado en un contexto internacionalizado \#loc
call.to.native.method.while.locked.display.name=Llamada a método 'native' mientras está bloqueado
call.to.native.method.while.locked.problem.descriptor=Llamada a método nativo <code>\#ref()</code> en un contexto sincronizado \#loc
call.to.numeric.tostring.display.name=Llamada a 'Number.toString()'
call.to.numeric.tostring.problem.descriptor=<code>Number.\#ref()</code> llamado en un contexto internacionalizado \#loc
call.to.private.setter.in.class.option=Solo reportar cuando el setter es 'private'
call.to.private.simple.getter.in.class.option=Solo reportar cuando el getter es 'private'
call.to.simple.getter.in.class.display.name=Llamada a getter simple desde dentro de la clase
call.to.simple.getter.in.class.ignore.option=Ignorar llamadas a getter en otros objetos
call.to.simple.getter.in.class.inline.quickfix=Inlinear llamada a getter
call.to.simple.getter.in.class.problem.descriptor=Llamada a getter simple <code>\#ref()</code> desde dentro de la clase \#loc
call.to.simple.setter.in.class.display.name=Llamada a setter simple desde dentro de la clase
call.to.simple.setter.in.class.ignore.option=Ignorar llamadas a setter en otros objetos
call.to.simple.setter.in.class.inline.quickfix=Inlinear llamada a setter
call.to.simple.setter.in.class.problem.descriptor=Llamada a setter simple <code>\#ref()</code> desde dentro de la clase \#loc
call.to.string.concat.can.be.replaced.by.operator.display.name=La llamada a 'String.concat()' puede reemplazarse por '+'
call.to.string.concat.can.be.replaced.by.operator.problem.descriptor=La llamada a <code>\#ref()</code> puede reemplazarse por expresión '+' \#loc
call.to.string.concat.can.be.replaced.by.operator.quickfix=Reemplazar llamada 'concat()' por '+'
call.to.suspicious.string.method.display.name=Llamada a método 'String' sospechoso
call.to.suspicious.string.method.problem.descriptor=<code>String.\#ref()</code> llamado en contexto internacionalizado \#loc
cast.conflicts.with.instanceof.display.name=Cast entra en conflicto con 'instanceof'
cast.conflicts.with.instanceof.problem.descriptor=El cast a tipo ''{0}'' entra en conflicto con la comprobación previa ''instanceof {1}''
cast.conflicts.with.instanceof.quickfix1=Reemplazar ''{0}'' por ''{1}'' en cast
cast.conflicts.with.instanceof.quickfix2=Reemplazar ''{0}'' por ''{1}'' en instanceof
cast.that.loses.precision.display.name=Cast numérico que pierde precisión
cast.that.loses.precision.negative.problem.descriptor=El cast de ''{0}'' a <code>\#ref</code> puede resultar en pérdida de precisión para argumento negativo \#loc
cast.that.loses.precision.option=Ignorar casts de int a char
cast.that.loses.precision.problem.descriptor=El cast de ''{0}'' a <code>\#ref</code> puede resultar en pérdida de precisión \#loc
cast.to.concrete.class.problem.descriptor=Cast a clase concreta <code>{0}</code> \#loc
casting.to.incompatible.interface.display.name=Cast a tipo incompatible
casting.to.incompatible.interface.problem.descriptor=Cast de expresión con tipo ''{1}'' a {0, choice, 1\#interfaz|2\#clase} incompatible <code>\#ref</code> \#loc
caught.exception.immediately.rethrown.display.name=La excepción capturada se relanza inmediatamente
caught.exception.immediately.rethrown.problem.descriptor=La excepción capturada <code>\#ref</code> se relanza inmediatamente \#loc
chain.of.class.equality.checks.problem.descriptor=La cadena de comprobaciones de igualdad de clase indica un fallo de abstracción \#loc
chain.of.instanceof.checks.display.name=Cadena de comprobaciones 'instanceof'
chain.of.instanceof.checks.problem.descriptor=La cadena de comprobaciones 'instanceof' indica un fallo de abstracción \#loc
chained.equality.comparisons.display.name=Comparaciones de igualdad encadenadas
chained.equality.comparisons.problem.descriptor=Comparación de igualdad encadenada <code>\#ref</code> \#loc
chained.method.call.display.name=Llamadas a método encadenadas
chained.method.call.ignore.option=Ignorar llamadas a método encadenadas en inicializadores de campo
chained.method.call.ignore.self.types.option=Ignorar llamadas a métodos que devuelven el mismo tipo que su clase contenedora
chained.method.call.problem.descriptor=Llamada a método encadenada <code>\#ref()</code> \#loc
change.modifier.fix.family.name=Cambiar modificador
change.modifier.package.private.quickfix=Hacer package-private
change.modifier.quickfix=Hacer ''{0}''
channel.opened.not.closed.display.name='Channel' abierto pero no cerrado de forma segura
char.used.in.arithmetic.content.cast.fix.family.name=Insertar cast
char.used.in.arithmetic.context.cast.quickfix=Insertar cast a {0}
char.used.in.arithmetic.context.display.name=Expresión 'char' usada en contexto aritmético
char.used.in.arithmetic.context.problem.descriptor='char' usado en contexto aritmético \#loc
char.used.in.arithmetic.context.quickfix=Convertir a literal String
character.comparison.display.name=Comparación de caracteres
character.comparison.problem.descriptor=Comparación de caracteres <code>\#ref</code> en un contexto internacionalizado \#loc
checkbox.ignore.null.on.wrong.side=Ignorar 'null' en el lado incorrecto
checked.exception.class.display.name=Clase de excepción verificada
checked.exception.class.problem.descriptor=Clase de excepción verificada <code>\#ref</code> \#loc
choose.autocloseable.type.to.ignore.title=Elegir Tipo de Recurso AutoCloseable a Ignorar
choose.class=Elegir Clase
choose.class.hierarchy.to.ignore.title=Elegir Jerarquía de Clase a Ignorar
choose.class.type.to.ignore=Elegir Clase a Ignorar
choose.exception.class=Elegir Clase de Excepción
choose.exception.label=Excepciones prohibidas\:
choose.io.resource.type.to.ignore=Elegir Tipo de Recurso I/O a Ignorar
choose.logger.class=Elegir Clase Logger
class.escapes.defined.scope.display.module.option=Reportar clases no exportadas expuestas en API de módulo (Java 9+)
class.escapes.defined.scope.display.name=La clase está expuesta fuera de su ámbito de visibilidad
class.escapes.defined.scope.display.package.option=Reportar clases privadas expuestas en API package-local
class.escapes.defined.scope.display.public.option=Reportar clases no accesibles expuestas en API pública
class.escapes.defined.scope.java9.modules.descriptor=La clase <code>\#ref</code> no está exportada desde el módulo ''{0}''
class.escapes.defined.scope.problem.descriptor=La clase <code>\#ref</code> está expuesta fuera de su ámbito de visibilidad definido \#loc
class.extends.utility.class.display.name=La clase extiende clase de utilidad
class.extends.utility.class.ignore.utility.class.option=Ignorar si la clase que sobrescribe es una clase de utilidad
class.extends.utility.class.problem.descriptor=La clase <code>\#ref</code> extiende la clase de utilidad ''{0}'' \#loc
class.independent.of.module.display.name=Clase independiente de su módulo
class.independent.of.module.problem.descriptor=La clase <code>\#ref</code> no tiene dependencias ni dependientes en su módulo \#loc
class.initializer.display.name=Inicializador no 'static'
class.initializer.may.be.static.display.name=El inicializador de clase puede ser 'static'
class.initializer.may.be.static.problem.descriptor=El inicializador de clase puede ser 'static' \#loc
class.initializer.move.code.to.constructor.quickfix=Mover código inicializador al constructor
class.initializer.option=Solo advertir cuando la clase tiene uno o más constructores
class.initializer.problem.descriptor=Inicializador no 'static' \#loc
class.loader.instantiation.display.name=Instanciación de 'ClassLoader'
class.loader.instantiation.problem.descriptor=La instanciación de <code>\#ref</code> puede presentar problemas de seguridad \#loc
class.may.be.interface.convert.quickfix=Convertir clase a interfaz
class.may.be.interface.display.name=La clase 'abstract' puede ser 'interface'
class.may.be.interface.java8.option=Reportar clases que contienen métodos no abstractos cuando se usa Java 8
class.may.be.interface.problem.descriptor=La clase abstracta <code>\#ref</code> puede ser una interfaz \#loc
class.name=Nombre de Clase
class.name.differs.from.file.name.display.name=El nombre de la clase difiere del nombre del archivo
class.name.differs.from.file.name.problem.descriptor=El nombre de clase <code>\#ref</code> difiere del nombre del archivo \#loc
class.name.prefixed.with.package.name.display.name=Nombre de clase con prefijo del nombre del paquete
class.name.prefixed.with.package.name.problem.descriptor=El nombre de clase <code>\#ref</code> comienza con su nombre de paquete \#loc
class.name.same.as.ancestor.name.display.name=Nombre de clase igual al nombre del ancestro
class.name.same.as.ancestor.name.problem.descriptor=El nombre de la clase <code>\#ref</code> es igual que uno de los nombres de su superclase \#loc
class.naming.convention.display.name=Convención de nomenclatura de clase
class.naming.convention.element.description=Clase
class.new.instance.display.name=Llamada insegura a 'Class.newInstance()'
class.new.instance.problem.descriptor=La llamada a <code>\#ref()</code> puede lanzar excepciones verificadas no declaradas \#loc
class.only.used.in.one.module.display.name=Clase usada solo desde otro módulo
class.only.used.in.one.module.problem.descriptor=La clase <code>\#ref</code> solo tiene dependencias y/o dependientes en el módulo ''{0}'' \#loc
class.only.used.in.one.package.display.name=Clase usada solo desde otro paquete
class.only.used.in.one.package.problem.descriptor=La clase <code>\#ref</code> solo tiene dependencias y/o dependientes en el paquete ''{0}'' \#loc
class.references.subclass.display.name=La clase hace referencia a una de sus subclases
class.references.subclass.problem.descriptor=La clase ''{0}'' hace referencia a la subclase <code>\#ref</code> \#loc
class.references.subclass.problem.descriptor.anonymous=La clase anónima hace referencia a la subclase <code>\#ref</code> \#loc
class.too.deep.display.name=Clase demasiado profunda en el árbol de herencia
class.too.deep.inheritance.depth.limit.option=Límite de profundidad de herencia\:
class.too.deep.problem.descriptor=<code>\#ref</code> está demasiado profunda en el árbol de herencia (profundidad de herencia \= {0}) \#loc
class.unconnected.to.package.display.name=Clase independiente de su paquete
class.unconnected.to.package.problem.descriptor=La clase <code>\#ref</code> no tiene dependencias ni dependientes en su paquete
class.with.only.private.constructors.display.name=Clase con solo constructores 'private' debería declararse 'final'
class.with.only.private.constructors.problem.descriptor=La clase <code>\#ref</code> con solo constructores 'private' debería declararse 'final'
class.with.too.many.dependencies.display.name=Clase con demasiadas dependencias
class.with.too.many.dependencies.max.option=Número máximo de dependencias
class.with.too.many.dependencies.problem.descriptor=La clase ''{0}'' tiene demasiadas dependencias ({1} > {2})
class.with.too.many.dependents.display.name=Clase con demasiados dependientes
class.with.too.many.dependents.max.option=Número máximo de dependientes
class.with.too.many.dependents.problem.descriptor=La clase ''{0}'' tiene demasiados dependientes ({1} > {2})
class.with.too.many.transitive.dependencies.display.name=Clase con demasiadas dependencias transitivas
class.with.too.many.transitive.dependencies.max.option=Número máximo de dependencias transitivas
class.with.too.many.transitive.dependencies.problem.descriptor=La clase ''{0}'' tiene demasiadas dependencias transitivas ({1} > {2})
class.with.too.many.transitive.dependents.display.name=Clase con demasiados dependientes transitivos
class.with.too.many.transitive.dependents.max.option=Número máximo de dependientes transitivos
class.with.too.many.transitive.dependents.problem.descriptor=La clase ''{0}'' tiene demasiadas dependencias transitivas ({1} > {2})
class.without.constructor.create.quickfix=Generar constructor vacío
class.without.constructor.display.name=Clase sin constructor
class.without.constructor.problem.descriptor=La clase <code>\#ref</code> no tiene constructor \#loc
class.without.logger.annotations.tab=Anotaciones
class.without.logger.loggers.tab=Loggers
class.without.no.arg.constructor.display.name=Clase sin constructor sin argumentos
class.without.no.arg.constructor.ignore.option=Ignorar si la clase tiene constructor por defecto
class.without.no.arg.constructor.problem.descriptor=La clase <code>\#ref</code> carece de un constructor sin argumentos \#loc
clone.doesnt.declare.clonenotsupportedexception.declare.quickfix=Agregar 'CloneNotSupportedException' a la cláusula throws
clone.doesnt.declare.clonenotsupportedexception.display.name='clone()' no declara 'CloneNotSupportedException'
clone.doesnt.declare.clonenotsupportedexception.problem.descriptor=<code>\#ref()</code> \#loc no declara 'CloneNotSupportedException'
clone.instantiates.new.array.problem.descriptor=''clone()'' crea nuevo array {0} \#loc
clone.instantiates.objects.with.constructor.display.name='clone()' instancia objetos con constructor
clone.instantiates.objects.with.constructor.problem.descriptor='clone()' crea nuevas instancias de <code>\#ref</code> \#loc
clone.method.in.non.cloneable.anonymous.class.problem.descriptor=<code>\#ref()</code> definido en clase anónima no Cloneable derivada de ''{0}'' \#loc
clone.method.in.non.cloneable.class.display.name=Método 'clone()' en clase no Cloneable
clone.method.in.non.cloneable.class.problem.descriptor=<code>\#ref()</code> definido en clase no Cloneable ''{0}'' \#loc
clone.method.in.non.cloneable.interface.problem.descriptor=<code>\#ref()</code> definido en interfaz no Cloneable ''{0}'' \#loc
clone.returns.class.type.display.name='clone()' debería tener tipo de retorno igual a la clase que lo contiene
clone.returns.class.type.family.quickfix=Cambiar tipo de retorno a tipo de clase
clone.returns.class.type.problem.descriptor=''clone()'' debería tener tipo de retorno ''{0}'' \#loc
clone.returns.class.type.quickfix=Cambiar tipo de retorno a ''{0}''
cloneable.class.in.secure.context.display.name=Clase clonable en contexto seguro
cloneable.class.in.secure.context.problem.descriptor=La clase <code>\#ref</code> puede ser clonada, comprometiendo la seguridad \#loc
cloneable.class.in.secure.context.quickfix=Generar método 'clone()' que siempre lance excepción
cloneable.class.without.clone.display.name=Clase Cloneable sin método 'clone()'
cloneable.class.without.clone.ignore.option=Ignorar clases clonables debido a herencia
cloneable.class.without.clone.ignore.when.clone.called.option=Ignorar si Cloneable es necesario para llamar al método clone() de una superclase
cloneable.class.without.clone.problem.descriptor=<code>\#ref</code> es 'Cloneable' pero no define el método 'clone()' \#loc
cloneable.class.without.clone.quickfix=Generar método 'clone()'
cloneable.class.without.clone.todo.message=TODO\: copiar estado mutable aquí, para que el clon no pueda cambiar los elementos internos del original
collection.added.to.self.display.name=Colección añadida a sí misma
collection.added.to.self.problem.descriptor=''{0}()'' llamado en la colección <code>\#ref</code> con sí misma como argumento \#loc
collection.declared.by.class.display.name=Colección declarada por clase, no por interfaz
collection.declared.by.class.ignore.locals.option=Ignorar variables locales
collection.declared.by.class.ignore.private.members.option=Ignorar campos y métodos 'private'
collection.declared.by.class.problem.descriptor=La declaración de <code>\#ref</code> probablemente debería debilitarse a ''{0}'' \#loc
collections.field.access.replaceable.by.method.call.display.name=La referencia al campo de colección vacía puede reemplazarse con llamada a método
collections.field.access.replaceable.by.method.call.fix.family.name=Reemplazar Collections.EMPTY_* con llamada
collections.field.access.replaceable.by.method.call.problem.descriptor=<code>\#ref</code> puede reemplazarse con ''Collections.{0}'' \#loc
collections.must.have.initial.capacity.display.name=Colección sin capacidad inicial
collections.must.have.initial.capacity.problem.descriptor=<code>new \#ref()</code> sin capacidad inicial \#loc
commented.out.code.delete.quickfix=Eliminar comentario
commented.out.code.uncomment.quickfix=Descomentar código
comments.as.content.option=Los comentarios cuentan como contenido
comparable.implemented.but.equals.not.overridden.display.name='Comparable' implementado pero 'equals()' no sobrescrito
comparable.implemented.but.equals.not.overridden.fix.add.note.name=Agregar nota JavaDoc 'ordering inconsistent with equals'
comparable.implemented.but.equals.not.overridden.fix.generate.equals.name=Generar método 'equals()'
comparable.implemented.but.equals.not.overridden.problem.descriptor=La clase <code>\#ref</code> implementa 'java.lang.Comparable' pero no sobrescribe 'equals()' \#loc
comparator.not.serializable.display.name=Clase 'Comparator' no declarada como 'Serializable'
comparator.not.serializable.problem.descriptor=La clase comparador <code>\#ref</code> no está declarada como Serializable \#loc
comparison.of.short.and.char.display.name=Comparación de valores 'short' y 'char'
comparison.of.short.and.char.problem.descriptor=Comparación de igualdad <code>\#ref</code> de valores short y char \#loc
comparison.to.nan.display.name=Comparación con 'Double.NaN' o 'Float.NaN'
comparison.to.nan.problem.descriptor1=La comparación con <code>\#ref</code> siempre es false \#loc
comparison.to.nan.problem.descriptor2=La comparación con <code>\#ref</code> siempre es true \#loc
concrete.class.method.parameter.problem.descriptor=Parámetro ''{0}'' de la clase concreta <code>\#ref</code> \#loc
concrete.class.use.display.name=Uso de clase concreta
condition.signal.display.name=Llamada a 'signal()' en lugar de 'signalAll()'
condition.signal.problem.descriptor=<code>\#ref</code> probablemente debería reemplazarse con 'signalAll()' \#loc
conditional.can.be.pushed.inside.expression.display.name=La condición puede moverse dentro de la expresión de rama
conditional.can.be.pushed.inside.expression.option=Ignorar cuando la condición será el único argumento de una llamada a método
conditional.can.be.pushed.inside.expression.problem.descriptor=La expresión condicional puede moverse dentro de la rama \#loc
conditional.can.be.pushed.inside.expression.quickfix=Mover expresión condicional dentro de la rama
conditional.expression.display.name=Expresión condicional
conditional.expression.expression.context.option=Ignorar lugares donde no es posible una sentencia if
conditional.expression.option=Ignorar para asignaciones y retornos simples
conditional.expression.problem.descriptor=Expresión condicional <code>\#ref</code> \#loc
conditional.expression.quickfix=Reemplazar con sentencia 'if'
conditional.expression.with.identical.branches.collapse.quickfix=Contraer expresión condicional
conditional.expression.with.identical.branches.display.name=Expresión condicional con ramas idénticas
conditional.expression.with.identical.branches.problem.descriptor=Expresión condicional <code>\#ref</code> con ramas idénticas \#loc
confusing.else.option=Informar cuando no hay más sentencias después de la sentencia 'if'
confusing.floating.point.literal.change.quickfix=Cambiar a forma canónica
confusing.floating.point.literal.display.name=Literal de punto flotante confuso
confusing.floating.point.literal.option=Ignorar literales de punto flotante en notación científica
confusing.floating.point.literal.problem.descriptor=Literal de punto flotante confuso <code>\#ref</code> \#loc
confusing.main.method.display.name=Método 'main()' confuso
confusing.main.method.problem.descriptor=El método <code>\#ref</code> no tiene la firma 'public static void main(String[])' \#loc
confusing.octal.escape.sequence.display.name=Secuencia de escape octal confusa
confusing.octal.escape.sequence.problem.descriptor=Secuencia de escape octal <code>\#ref</code> inmediatamente seguida por un dígito \#loc
connection.opened.not.safely.closed.display.name=Conexión abierta pero no cerrada de forma segura
consider.static.final.fields.constant.option=Considerar campos 'static final' como constantes
constant.assert.condition.display.name=Condición constante en sentencia 'assert'
constant.assert.condition.problem.descriptor=La condición assert <code>\#ref</code> es constante \#loc
constant.conditional.expression.display.name=Expresión condicional constante
constant.conditional.expression.problem.descriptor=<code>\#ref</code> puede simplificarse a ''{0}'' \#loc
constant.conditional.expression.simplify.quickfix=Simplificar
constant.conditional.expression.simplify.quickfix.sideEffect=Extraer efectos secundarios y simplificar
constant.declared.in.abstract.class.display.name=Constante declarada en clase 'abstract'
constant.declared.in.abstract.class.problem.descriptor=Constante <code>\#ref</code> declarada en clase abstracta \#loc
constant.declared.in.interface.display.name=Constante declarada en interfaz
constant.declared.in.interface.problem.descriptor=Constante <code>\#ref</code> declarada en interfaz \#loc
constant.for.zero.length.array.display.name=Uso innecesario de array de longitud cero
constant.for.zero.length.array.problem.descriptor=El array de longitud cero puede cambiarse a constante \#loc
constant.for.zero.length.array.quickfix.family=Reemplazar con constante
constant.junit.assert.argument.display.name=Argumento assert constante
constant.junit.assert.argument.problem.descriptor=El argumento <code>\#ref</code> es constante \#loc
constant.math.call.display.name=Llamada constante a 'Math'
constant.math.call.problem.descriptor=La llamada constante a <code>\#ref()</code> puede simplificarse \#loc
constant.naming.convention.element.description=Constante
constant.on.lhs.of.comparison.options.item.left=izquierda
constant.on.lhs.of.comparison.options.item.right=derecha
constant.on.lhs.of.comparison.problem.descriptor=Constante <code>\#ref</code> en el lado izquierdo de la comparación \#loc
constant.on.rhs.of.comparison.problem.descriptor=Constante <code>\#ref</code> en el lado derecho de la comparación \#loc
constant.on.side.of.comparison.display.name=Constante en el lado incorrecto de la comparación
constant.value.variable.use.display.name=Uso de variable cuyo valor se sabe que es constante
constant.value.variable.use.problem.descriptor=Se sabe que el valor de <code>\#ref</code> es constante \#loc
constant.with.mutable.field.naming.convention.element.description=Constante con tipo mutable
constructor.visibility.option=Ignorar constructores con visibilidad\:
continue.or.break.from.finally.block.display.name='continue' o 'break' dentro del bloque 'finally'
continue.or.break.from.finally.block.problem.descriptor=<code>\#ref</code> dentro del bloque 'finally' \#loc
continue.statement.display.name=Sentencia 'continue'
continue.statement.with.label.display.name=Sentencia 'continue' con etiqueta
continue.statement.with.label.problem.descriptor=Sentencia <code>\#ref</code> con etiqueta \#loc
control.flow.statement.without.braces.add.quickfix=Agregar llaves a la sentencia
control.flow.statement.without.braces.display.name=Sentencia de control de flujo sin llaves
control.flow.statement.without.braces.message=Agregar llaves a la sentencia ''{0}''
control.flow.statement.without.braces.problem.descriptor=<code>{0}</code> sin llaves \#loc
convert.double.unary.quickfix=Reemplazar con ''{0}{1}''
convert.empty.anonymous.to.new.fix.family.name=Eliminar '{}'
convert.octal.literal.to.decimal.literal.quickfix=Convertir literal octal a literal decimal
convert.octal.literals.to.decimal.literals.quickfix=Convertir literales octales a literales decimales
convert.system.out.to.log.call.family.name=Convertir llamada 'System.out' a llamada de log
convert.system.out.to.log.call.name=Convertir llamada ''System.out'' a llamada de ''{0}''
convert.to.variable.arity.method.quickfix=Convertir a método varargs
copy.constructor.misses.field.display.name=Constructor de copia omite campo
copy.constructor.misses.field.problem.descriptor.1=El constructor de copia no copia el campo ''{0}''
copy.constructor.misses.field.problem.descriptor.2=El constructor de copia no copia los campos ''{0}'' y ''{1}''
copy.constructor.misses.field.problem.descriptor.3=El constructor de copia no copia los campos ''{0}'', ''{1}'' y ''{2}''
copy.constructor.misses.field.problem.descriptor.many=El constructor de copia no copia {0} campos
covariant.equals.display.name=Covariante 'equals()'
covariant.equals.problem.descriptor=<code>\#ref()</code> debería tomar 'Object' como su argumento \#loc
create.default.branch.fix.family.name=Crear rama 'default'
create.missing.boolean.switch.branches.fix.family.name=Crear ramas switch booleanas faltantes
create.missing.branches.with.null.branch.fix.family.name=Crear ramas faltantes y rama 'null'
create.missing.enum.switch.branches.fix.family.name=Crear ramas switch enum faltantes
create.missing.record.deconstructions.switch.branches.fix.family.name=Crear ramas switch de deconstrucción de registro faltantes
create.missing.sealed.class.switch.branches.fix.family.name=Crear ramas switch de clase sellada faltantes
create.missing.switch.branch=Crear rama faltante {0}
create.missing.switch.branches=Crear ramas faltantes {0}
create.null.branch.fix.family.name=Crear rama 'null'
create.package.info.java.family.name=Crear 'package-info.java'
cstyle.array.method.declaration.problem.descriptor=El método <code>{0}()</code> tiene declaración de tipo de retorno array estilo C \#loc
cstyle.array.variable.declaration.problem.descriptor={0, choice, 1\#Campo|2\#Parámetro|3\#Componente de registro|4\#Variable local} <code>{1}</code> tiene declaración de tipo array estilo C \#loc
custom.classloader.display.name=Se ha declarado 'ClassLoader' personalizado
custom.classloader.problem.descriptor=Clase ClassLoader personalizada <code>\#ref</code> \#loc
custom.security.manager.display.name='SecurityManager' personalizado
custom.security.manager.problem.descriptor=Clase SecurityManager personalizada <code>\#ref</code> \#loc
cyclic.class.dependency.1.problem.descriptor=La clase ''{0}'' tiene dependencia cíclica con la clase ''{1}''
cyclic.class.dependency.2.problem.descriptor=La clase ''{0}'' tiene dependencia cíclica con las clases ''{1}'' y ''{2}''
cyclic.class.dependency.display.name=Dependencia cíclica de clase
cyclic.class.dependency.ignore.in.same.file=Ignorar ciclos entre clases ubicadas en el mismo archivo
cyclic.class.dependency.problem.descriptor=La clase ''{0}'' tiene dependencia cíclica con otras {1} clases
cyclic.package.dependency.1.problem.descriptor=El paquete ''{0}'' tiene dependencia cíclica con el paquete ''{1}''
cyclic.package.dependency.2.problem.descriptor=El paquete ''{0}'' tiene dependencia cíclica con los paquetes ''{1}'' y ''{2}''
cyclic.package.dependency.display.name=Dependencia cíclica de paquete
cyclic.package.dependency.problem.descriptor=El paquete ''{0}'' tiene dependencia cíclica con otros {1} paquetes
cyclomatic.complexity.display.name=Método excesivamente complejo
cyclomatic.complexity.limit.option=Límite de complejidad ciclomática\:
cyclomatic.complexity.problem.descriptor=Método excesivamente complejo <code>\#ref()</code> (complejidad ciclomática \= {0}) \#loc
dangling.javadoc.convert.line.comment.quickfix=Reemplazar con comentarios de línea
dangling.javadoc.convert.quickfix=Reemplazar con comentario de bloque
dangling.javadoc.delete.quickfix=Eliminar comentario colgante
dangling.javadoc.display.name=Comentario Javadoc colgante
dangling.javadoc.ignore.copyright.option=Ignorar comentario de encabezado de archivo en formato JavaDoc
dangling.javadoc.problem.descriptor=Comentario Javadoc colgante \#loc
debug.level.and.lower.option=nivel de debug e inferior
declare.collection.as.interface.fix.family.name=Debilitar tipo
declare.collection.as.interface.quickfix=Debilitar a ''{0}''
default.not.last.case.in.switch.display.name='default' no es el último case en 'switch'
default.not.last.case.in.switch.problem.descriptor=La rama ''default'' no es el último case en ''switch'' {0} \#loc
default.tostring.call.display.name=Llamada al 'toString()' por defecto
default.tostring.call.problem.descriptor=Llamada al 'toString()' por defecto en <code>\#ref</code> \#loc
delete.catch.section.fix.family.name=Eliminar sentencia catch
delete.catch.section.quickfix=Eliminar sección 'catch'
delete.import.quickfix=Eliminar importación innecesaria
delete.unnecessary.statement.fix.family.name=Eliminar sentencia redundante
deserializable.class.in.secure.context.problem.descriptor=La clase <code>\#ref</code> puede ser deserializada, comprometiendo la seguridad \#loc
design.for.extension.display.name=Diseño para extensión
design.for.extension.problem.descriptor=El método <code>\#ref()</code> puede ser sobreescrito y su funcionalidad ignorada \#loc
diamond.can.be.replaced.with.explicit.type.arguments.name=Diamond puede ser reemplazado con argumentos de tipo explícitos
diamond.can.be.replaced.with.explicit.type.arguments.quickfix=Reemplazar '<>' con argumentos de tipo explícitos
disjoint.package.display.name=Paquete con grafo de dependencias disjunto
disjoint.package.problem.descriptor=El paquete {0} puede descomponerse en {1} paquetes independientes
divide.by.zero.display.name=División por cero
divide.by.zero.problem.descriptor=División por cero \#loc
dollar.sign.in.name.display.name=Uso de '$' en identificador
dollar.sign.in.name.problem.descriptor=El identificador <code>\#ref</code> contiene '$' \#loc
double.brace.initialization.display.name=Inicialización de doble llave
double.brace.initialization.quickfix=Reemplazar con inicialización regular
double.checked.locking.display.name=Double-checked locking
double.checked.locking.fix.family.name=Hacer campo volatile
double.checked.locking.problem.descriptor=Double-checked locking \#loc
double.checked.locking.quickfix=Hacer ''{0}'' volatile
double.literal.may.be.float.literal.display.name=Cast a 'float' puede ser literal 'float'
double.negation.display.name=Doble negación
double.negation.problem.descriptor=Doble negación en <code>\#ref</code> \#loc
double.negation.quickfix=Eliminar doble negación
drivermanager.call.display.name=Uso de 'DriverManager' para obtener conexión JDBC
drivermanager.call.problem.descriptor=Llamada a <code>DriverManager.\#ref()</code> \#loc
dumpstack.call.display.name=Llamada a 'Thread.dumpStack()'
dumpstack.call.problem.descriptor=La llamada a <code>Thread.\#ref()</code> probablemente debería reemplazarse con logging más robusto \#loc
duplicate.condition.display.name=Condición duplicada
duplicate.condition.ignore.method.calls.option=Ignorar condiciones con posibles efectos secundarios
duplicate.condition.ignore.method.calls.option.description=Si está marcado, no se reportarán condiciones con efectos secundarios potenciales (por ejemplo, llamadas a métodos desconocidos). Los métodos que se sabe que producen efectos secundarios no se reportarán en ningún caso.
duplicate.condition.problem.descriptor=Condición duplicada <code>\#ref</code> \#loc
dynamic.regex.replaceable.by.compiled.pattern.display.name=La expresión regular dinámica puede ser reemplazada por 'Pattern' compilado
dynamic.regex.replaceable.by.compiled.pattern.problem.descriptor=<code>\#ref()</code> puede ser reemplazado con construcción 'java.util.regex.Pattern' compilada \#loc
dynamic.regex.replaceable.by.compiled.pattern.quickfix=Reemplazar con llamada al método de constante 'Pattern' compilada
empty.anonymous.class.problem.descriptor=La clase anónima está vacía \#loc
empty.class.display.name=Clase vacía
empty.class.file.without.class.problem.descriptor=El archivo Java no declara ninguna clase \#loc
empty.class.ignore.parameterization.option=Ignorar clase si es una parametrización de un supertipo
empty.class.initializer.delete.quickfix=Eliminar inicializador de clase vacío
empty.class.initializer.display.name=Inicializador de clase vacío
empty.class.initializer.problem.descriptor=Inicializador de clase vacío \#loc
empty.class.problem.descriptor=La clase <code>\#ref</code> está vacía \#loc
empty.enum.problem.descriptor=El enum <code>\#ref</code> está vacío \#loc
empty.finally.block.display.name=Bloque 'finally' vacío
empty.finally.block.problem.descriptor=Bloque <code>\#ref</code> vacío \#loc
empty.synchronized.statement.display.name=Sentencia 'synchronized' vacía
empty.synchronized.statement.problem.descriptor=Sentencia <code>\#ref</code> vacía \#loc
empty.try.block.display.name=Bloque 'try' vacío
empty.try.block.problem.descriptor=Bloque <code>\#ref</code> vacío \#loc
encapsulate.variable.fix.family.name=Encapsular campo
encapsulate.variable.quickfix=Encapsular campo ''{0}''
enum.singleton.problem.descriptor=El enum <code>\#ref</code> es un singleton \#loc
enum.switch.statement.which.misses.cases.display.name=Sentencia 'switch' de enum que omite casos
enum.switch.statement.which.misses.cases.option=Ignorar sentencias switch con rama default
enum.switch.statement.which.misses.cases.problem.descriptor=La sentencia <code>\#ref</code> sobre el tipo enum ''{0}'' omite los casos {1} \#loc
enum.switch.statement.which.misses.cases.problem.descriptor.single=La sentencia <code>\#ref</code> sobre el tipo enum ''{0}'' omite el caso ''{1}'' \#loc
enumerated.class.display.name=Clase enumerada
enumerated.class.naming.convention.element.description=Clase enum
enumerated.class.problem.descriptor=Clase enumerada <code>\#ref</code> \#loc
enumerated.constant.naming.convention.element.description=Constante enum
enumeration.can.be.iteration.display.name=La enumeración puede ser iteración
enumeration.can.be.iteration.problem.descriptor=<code>\#ref()</code> puede ser reemplazado con la construcción ''{0}'' \#loc
enumeration.can.be.iteration.quickfix=Reemplazar con construcción 'Iterator'
equality.to.safe.equals.quickfix=Reemplazar '\=\=' con 'equals()' seguro para null
equals.between.inconvertible.types.display.name='equals()' entre objetos de tipos no convertibles
equals.between.inconvertible.types.mutual.subclass.option=Advertir si no se encuentra una subclase mutua
equals.between.inconvertible.types.no.mutual.subclass.problem.descriptor=No se encontró ninguna clase que sea subtipo de ''{0}'' y ''{1}'' \#loc
equals.between.inconvertible.types.problem.descriptor=<code>\#ref</code> entre objetos de tipos no convertibles ''{0}'' y ''{1}'' \#loc
equals.called.on.array.display.name='equals()' llamado sobre un array
equals.called.on.array.problem.descriptor=<code>\#ref()</code> entre arrays probablemente debería ser 'Arrays.equals()' \#loc
equals.called.on.enum.constant.display.name='equals()' llamado sobre valor enum
equals.called.on.enum.constant.problem.descriptor=<code>\#ref()</code> llamado sobre valor enum \#loc
equals.called.on.suspicious.object.display.name='equals()' llamado en clases que no lo sobreescriben
equals.called.on.suspicious.object.fix.family.name=Reemplazar con una comparación de valores representativos
equals.called.on.suspicious.object.fix.name=Reemplazar con una comparación de resultados de llamada a ''{0}()''
equals.called.on.suspicious.object.problem.descriptor=Llamada sospechosa a ''equals()'' en objeto ''{0}''
equals.doesnt.check.class.parameter.display.name=Método 'equals()' que no verifica la clase de su parámetro
equals.doesnt.check.class.parameter.problem.descriptor=<code>\#ref()</code> debería verificar la clase de su parámetro \#loc
equals.replaceable.by.objects.call.display.name=Expresión 'equals()' reemplazable por expresión 'Objects.equals()'
equals.replaceable.by.objects.call.problem.descriptor=<code>\#ref</code> reemplazable por expresión 'Objects.equals()' \#loc
equals.replaceable.by.objects.check.not.null.option=Resaltar expresiones como 'a \!\= null \\&\\& a.equals(b)'
equals.with.itself.display.name='equals()' llamado sobre sí mismo
equals.with.itself.option=Ignorar posibles pruebas de contrato
equals.with.itself.option.description=Cuando está marcado, algunos casos como <code>assertEquals(myObj, myObj)</code> no serán reportados, para evitar advertencias en pruebas que verifican la corrección del método <code>equals()</code>.
equals.with.itself.problem.descriptor=<code>\#ref()</code> llamado sobre sí mismo
error.rethrown.display.name='Error' no relanzado
error.rethrown.problem.descriptor=Error <code>\#ref</code> no relanzado \#loc
exception.from.catch.which.doesnt.wrap.display.name='throw' dentro de bloque 'catch' que ignora la excepción capturada
exception.from.catch.which.doesnt.wrap.problem.descriptor=<code>\#ref</code> dentro del bloque 'catch' ignora la excepción capturada \#loc
exception.from.catch.which.doesntwrap.ignore.cant.wrap.option=Ignorar si la excepción lanzada no puede envolver una excepción
exception.from.catch.which.doesntwrap.ignore.option=Ignorar si se usa el resultado de la llamada al método de excepción
exception.name.doesnt.end.with.exception.display.name=El nombre de la clase de excepción no termina en 'Exception'
exception.name.doesnt.end.with.exception.problem.descriptor=El nombre de la clase de excepción <code>\#ref</code> no termina en 'Exception' \#loc
exception.package.display.name=Paquete de excepciones
exception.package.problem.descriptor=El paquete ''{0}'' contiene solo clases de excepción
explicit.array.to.string.problem.descriptor=Llamada a '\#ref()' en array \#loc
expression.can.be.replaced.no.quotes.problem.descriptor={0} puede ser reemplazado con {1}
expression.can.be.replaced.problem.descriptor=<code>\#ref</code> puede ser reemplazado con ''{0}'' \#loc
expression.may.be.factorized.display.name=La expresión puede ser factorizada
extend.exception.fix.family.name=Hacer que la clase extienda 'Exception'
extended.for.statement.display.name=Sentencia 'for' mejorada
extended.for.statement.problem.descriptor=Sentencia <code>\#ref</code> extendida \#loc
extended.for.statement.replace.quickfix=Reemplazar con sentencia 'for' de estilo antiguo
extends.annotation.display.name=Clase extiende interfaz de anotación
extends.annotation.interface.problem.descriptor=Interfaz ''{0}'' extiende interfaz de anotación <code>\#ref</code> \#loc
extends.annotation.problem.descriptor=Clase ''{0}'' implementa interfaz de anotación <code>\#ref</code> \#loc
extends.concrete.collection.display.name=Clase extiende explícitamente una clase 'Collection'
extends.concrete.collection.problem.descriptor=Clase <code>\#ref</code> extiende explícitamente ''{0}'' \#loc
extends.object.display.name=Clase extiende explícitamente 'Object'
extends.object.problem.descriptor=Clase <code>\#ref</code> extiende explícitamente 'java.lang.Object' \#loc
extends.object.remove.quickfix=Eliminar 'extends Object' redundante
extends.thread.display.name=Clase extiende directamente 'Thread'
extends.thread.problem.descriptor=Clase <code>\#ref</code> extiende directamente 'java.lang.Thread' \#loc
extends.throwable.display.name=Clase extiende directamente 'Throwable'
extends.throwable.problem.descriptor=Clase <code>\#ref</code> extiende directamente 'java.lang.Throwable' \#loc
externalizable.with.serialization.methods.display.name=Clase Externalizable con 'readObject()' o 'writeObject()'
externalizable.with.serialization.methods.problem.descriptor.both={0, choice, 1\#clase|2\#interfaz|3\#clase anónima derivada de|4\#tipo anotación|5\#enum|6\#record} Externalizable <code>\#ref</code> define 'readObject()' y 'writeObject()' \#loc
externalizable.with.serialization.methods.problem.descriptor.read={0, choice, 1\#clase|2\#interfaz|3\#clase anónima derivada de|4\#tipo anotación|5\#enum|6\#record} Externalizable <code>\#ref</code> define 'readObject()' \#loc
externalizable.with.serialization.methods.problem.descriptor.write={0, choice, 1\#clase|2\#interfaz|3\#clase anónima derivada de|4\#tipo anotación|5\#enum|6\#record} Externalizable <code>\#ref</code> define 'writeObject()' \#loc
externalizable.without.public.no.arg.constructor.display.name=Clase 'Externalizable' sin constructor 'public' sin argumentos
externalizable.without.public.no.arg.constructor.problem.descriptor=Clase Externalizable <code>\#ref</code> no tiene constructor 'public' sin argumentos \#loc
extract.method.quickfix=Extraer método
extract.parameter.as.local.variable.quickfix=Extraer parámetro como variable local
fallthru.in.switch.statement.display.name=Fallthrough en sentencia 'switch'
fallthru.in.switch.statement.problem.descriptor=Fallthrough en sentencia 'switch' \#loc
fallthru.in.switch.statement.quickfix=Agregar ''{0}''
feature.envy.display.name=Envidia de características
feature.envy.problem.descriptor=La clase ''{0}'' es accedida repetidamente en el método <code>\#ref()</code> \#loc
field.accessed.synchronized.and.unsynchronized.display.name=Campo accedido tanto en contextos 'synchronized' como no sincronizados
field.accessed.synchronized.and.unsynchronized.option=Los getters y setters simples también se consideran accesos a campos
field.accessed.synchronized.and.unsynchronized.problem.descriptor=Campo <code>\#ref</code> es accedido tanto en contextos sincronizados como no sincronizados \#loc
field.count.inspection.include.constant.fields.in.count.checkbox=Incluir campos constantes en el conteo
field.count.inspection.include.enum.constants.in.count=Incluir constantes enum en el conteo
field.count.inspection.static.final.fields.count.as.constant.checkbox=Campos 'static final' cuentan como constantes
field.has.setter.but.no.getter.display.name=Campo tiene setter pero no getter
field.has.setter.but.no.getter.problem.descriptor=Campo <code>\#ref</code> tiene setter pero no getter \#loc
field.has.static.modifier.problem.descriptor=El campo ''{0}'' tiene modificador ''static''
field.incorrect.type.problem.descriptor=El campo ''{0}'' no tiene tipo ''{1}''
field.may.be.final.display.name=Campo puede ser 'final'
field.may.be.final.problem.descriptor=Campo <code>\#ref</code> puede ser 'final' \#loc
field.may.be.static.display.name=Campo puede ser 'static'
field.may.be.static.problem.descriptor=Campo <code>\#ref</code> puede ser 'static' \#loc
field.missing.volatile.modifier.problem.descriptor=El campo ''{0}'' no tiene modificador ''volatile''
field.name.hides.in.superclass.display.name=Campo de subclase oculta campo de superclase
field.name.hides.in.superclass.ignore.option=Ignorar campos no accesibles
field.name.hides.in.superclass.ignore.static.field.option=Ignorar campos static que ocultan campos static
field.name.hides.in.superclass.problem.descriptor=El campo <code>\#ref</code> oculta campo en la superclase \#loc
field.naming.convention.display.name=Convención de nombres de campos
field.not.found.in.class.problem.descriptor=No se encontró campo llamado ''{0}'' en la clase ''{1}''
final.class.display.name=Clase cerrada a la herencia
final.class.problem.descriptor=Clase ''{0}'' declarada <code>\#ref</code> \#loc
final.method.display.name=Método no puede ser sobrescrito
final.method.in.final.class.display.name=Método 'final' en clase 'final'
final.method.in.final.class.problem.descriptor=Método declarado <code>\#ref</code> en clase 'final' \#loc
final.method.problem.descriptor=Método declarado <code>\#ref</code> \#loc
final.private.method.display.name=Método 'private' declarado como 'final'
final.private.method.problem.descriptor=Método 'private' declarado <code>\#ref</code> \#loc
final.static.method.display.name=Método 'static' declarado como 'final'
final.static.method.problem.descriptor=Método 'static' declarado <code>\#ref</code> \#loc
finalize.called.explicitly.display.name='finalize()' llamado explícitamente
finalize.called.explicitly.problem.descriptor=<code>\#ref()</code> llamado explícitamente \#loc
finalize.declaration.display.name='finalize()' no debería ser sobrescrito
finalize.declaration.problem.descriptor='finalize()' no debería ser sobrescrito \#loc
finalize.not.declared.protected.display.name='finalize()' debería ser protected, no public
finalize.not.declared.protected.problem.descriptor='finalize()' debería tener acceso protected, no public \#loc
finally.block.cannot.complete.normally.display.name=Bloque 'finally' que no puede completarse normalmente
finally.block.cannot.complete.normally.problem.descriptor=Bloque <code>\#ref</code> no puede completarse normalmente \#loc
fix.add.argument.family.name=Agregar argumento
fix.add.argument.name=Agregar argumento ''{0}''
fix.eliminate.folded.if.present.description=La llamada 'ifPresent()' plegada puede ser eliminada
fix.eliminate.folded.if.present.name=Eliminar llamada 'ifPresent()' plegada
fix.replace.map.with.flat.map.description='map()' puede ser reemplazado con 'flatMap()'
flip.comparison.quickfix=Invertir comparación
floating.point.equality.display.name=Comparación de igualdad de punto flotante
floating.point.equality.problem.descriptor=<code>\#ref</code>\: valores de punto flotante comparados por igualdad exacta \#loc
for.can.be.foreach.display.name=Bucle 'for' puede ser reemplazado por bucle for mejorado
for.can.be.foreach.fix.no.indexed=No reportar bucles indexados de 'java.util.List'
for.can.be.foreach.option=Reportar bucles indexados de 'java.util.List'
for.can.be.foreach.option2=No reportar iteraciones sobre colecciones sin tipo
for.can.be.foreach.problem.descriptor=Bucle <code>\#ref</code> puede ser reemplazado por 'for' mejorado \#loc
for.loop.replaceable.by.while.display.name=Bucle 'for' puede ser reemplazado por bucle 'while'
for.loop.replaceable.by.while.ignore.option=Ignorar bucles 'for' infinitos sin condiciones
for.loop.replaceable.by.while.problem.descriptor=Sentencia de bucle <code>\#ref</code> puede ser reemplazada por bucle 'while' \#loc
for.loop.with.missing.component.collection.loop.option=Ignorar iteraciones de colección
for.loop.with.missing.component.display.name=Bucle 'for' con componentes faltantes
for.loop.with.missing.component.problem.descriptor1=Sentencia <code>\#ref</code> carece de inicializador \#loc
for.loop.with.missing.component.problem.descriptor2=Sentencia <code>\#ref</code> carece de condición \#loc
for.loop.with.missing.component.problem.descriptor3=Sentencia <code>\#ref</code> carece de actualización \#loc
for.loop.with.missing.component.problem.descriptor4=Sentencia <code>\#ref</code> carece de inicializador y condición \#loc
for.loop.with.missing.component.problem.descriptor5=Sentencia <code>\#ref</code> carece de inicializador y actualización \#loc
for.loop.with.missing.component.problem.descriptor6=Sentencia <code>\#ref</code> carece de condición y actualización \#loc
for.loop.with.missing.component.problem.descriptor7=Sentencia <code>\#ref</code> carece de inicializador, condición y actualización \#loc
foreach.replace.quickfix=Reemplazar con 'for' mejorado
format.string.error.duplicate.flag=flag duplicado ''{0}'' en ''{1}''
format.string.error.flags.not.allowed={2, choice, 1\#flag|1<flags} ''{0}'' no permitido en ''{1}''
format.string.error.illegal.flag.combination=combinación ilegal de flags ''{0}'' y ''{1}'' en ''{2}''
format.string.error.illegal.position.specifier=especificador de posición ilegal ''{0}'' en ''{1}''
format.string.error.invalid.precision=precisión inválida especificada en ''{0}''
format.string.error.left.justify.no.width=se usó el flag de justificación izquierda ''-'' pero no se especificó ancho en ''{0}''
format.string.error.precision.not.allowed=precisión (''{0}'') no permitida en ''{1}''
format.string.error.previous.element.not.found=se usó el flag anterior ''<'' pero no se encontró especificador de formato previo para ''{0}''
format.string.error.unexpected.flag=carácter inesperado ''{0}'' en ''{1}''
format.string.error.unknown.conversion=conversión desconocida en ''{0}''
format.string.error.unnecessary.position.specifier=especificador de posición de argumento innecesario ''{0}'' en ''{1}''
format.string.error.width.not.allowed=ancho (''{0}'') no permitido en ''{1}''
format.string.error.zero.padding.no.width=se usó el flag de relleno con ceros ''0'' pero no se especificó ancho en ''{0}''
gc.call.display.name=Llamada a 'System.gc()' o 'Runtime.gc()'
gc.call.problem.descriptor=<code>\#ref</code> no debería llamarse en código de producción \#loc
generate.to.string.quick.fix.family.name=Generar
generate.to.string.quick.fix.text=Generar toString()
groups.of.modules.loaded.together.description=Cada línea especifica una lista de nombres de módulos separados por comas que se sabe que son cargados por el mismo classloader.\nNo se debe reportar el acceso a miembros package-private entre dichos módulos.
groups.of.modules.loaded.together.label=Grupos de módulos que se cargan juntos\:
hardcoded.file.separator.display.name=Separador de archivo hardcodeado
hardcoded.file.separator.ignore.methods.option=Ignorar argumentos para los siguientes métodos\:
hardcoded.file.separator.include.option=Incluir 'example/*' en tipos de medios MIME reconocidos
hardcoded.file.separator.problem.descriptor=Separador de archivo hardcodeado <code>\#ref</code> \#loc
hardcoded.line.separator.display.name=Separador de línea hardcodeado
hardcoded.line.separator.problem.descriptor=Separador de línea hardcodeado <code>\#ref</code> \#loc
hibernate.resource.opened.not.closed.display.name=Recurso Hibernate abierto pero no cerrado de forma segura
html.tag.can.be.javadoc.tag.display.name='<code>…</code>' puede ser reemplazado con '{@code …}'
html.tag.can.be.javadoc.tag.problem.descriptor=<code>\#ref...\\&lt;/code\\&gt;</code> puede ser reemplazado con '{@code …}' \#loc
i.o.resource.opened.not.closed.display.name=Recurso I/O abierto pero no cerrado de forma segura
if.can.be.assertion.name=La sentencia puede ser reemplazada con 'assert' u 'Objects.requireNonNull'
if.can.be.assertion.replace.with.assertion.quickfix=Reemplazar sentencia con sentencia 'assert'
if.can.be.assertion.replace.with.objects.requirenonnull.quickfix=Reemplazar sentencia con 'Objects.requireNonNull()'
if.can.be.switch.display.name='if' puede ser reemplazado con 'switch'
if.can.be.switch.enum.option=Sugerir switch en enums
if.can.be.switch.int.option=Sugerir switch en números
if.can.be.switch.minimum.branch.option=Número mínimo de ramas de condición 'if'\:
if.can.be.switch.null.safe.option=Solo sugerir en expresiones null-safe
if.can.be.switch.problem.descriptor=La sentencia <code>\#ref</code> puede ser reemplazada con sentencia 'switch' \#loc
if.may.be.conditional.problem.descriptor=<code>\#ref</code> puede ser reemplazado con expresión condicional \#loc
if.may.be.conditional.quickfix=Reemplazar con expresión condicional
if.may.be.factorized.problem.descriptor=<code>\#ref</code> puede ser factorizado \#loc
if.may.be.factorized.quickfix=Reemplazar con expresión factorizada
if.statement.with.identical.branches.display.name=Sentencia 'if' con ramas idénticas o partes comunes
if.statement.with.too.many.branches.display.name=Sentencia 'if' con demasiadas ramas
if.statement.with.too.many.branches.max.option=Número máximo de ramas\:
if.statement.with.too.many.branches.problem.descriptor=<code>\#ref</code> tiene demasiadas ramas ({0}) \#loc
ignore.accesses.from.equals.method=Ignorar accesos desde el método 'equals()'
ignore.accesses.from.the.same.class=Ignorar accesos desde la misma clase
ignore.anonymous.inner.classes=Ignorar clases anónimas
ignore.boolean.methods.in.an.interface.option=Ignorar métodos booleanos en una @&interface
ignore.branches.of.switch.statements=Ignorar ramas de sentencias 'switch'
ignore.calls.to.property.getters=Ignorar llamadas a getters de propiedades
ignore.calls.to.static.methods=Ignorar llamadas a métodos static
ignore.classes.annotated.by=Ignorar clases anotadas por\:
ignore.classes.in.hierarchy.column.name=Ignorar subclases de\:
ignore.cloneable.option=Ignorar 'java.lang.Cloneable'
ignore.constructor.method.references=Ignorar referencias a métodos constructores que producen AutoCloseable
ignore.enhanced.for.loop.statements=Ignorar bucles for mejorados
ignore.equals.hashcode.and.tostring=Ignorar métodos 'equals()', 'hashCode()' y 'toString()'
ignore.exceptions.declared.on.library.override.option=Ignorar excepciones declaradas en métodos que sobreescriben un método de &librería
ignore.for.equals.methods.option=Ignorar para métodos '&equals()'
ignore.getters.returning.resource=Ignorar getters que devuelven recurso
ignore.guard.clauses.option=Ignorar cláusulas de &guarda
ignore.if.annotated.by=Ignorar si está anotado por\:
ignore.in.module.statements.option=Ignorar en declaraciones de módulos Java 9
ignore.instanceof.on.library.classes=Ignorar instanceof en clases de librería
ignore.methods.in.anonymous.classes=Ignorar métodos en clases anónimas
ignore.methods.overriding.super.method=Ignorar métodos que s&obreescriben/implementan un método super
ignore.methods.with.boolean.return.type.option=Ignorar métodos con tipo de retorno 'java.lang.&Boolean'
ignore.overflowing.byte.casts.option=Ignorar conversiones de int 128-255 a byte
ignore.parentheses.around.single.no.formal.type.lambda.parameter=Ignorar paréntesis alrededor de parámetro lambda único sin tipo formal
ignore.private.methods.option=Ignorar asignaciones y retornos en métodos private
ignore.serializable.option=Ignorar 'java.io.Serializable'
ignore.single.field.static.imports.option=Ignorar imports static de campo único(&F)
ignore.single.method.static.imports.option=Ignorar imports static de método único(&M)
ignore.trivial.finalizers.option=Ignorar para implementaciones triviales de 'finalize()'
ignored.autocloseable.types.label=Tipos de recursos AutoCloseable ignorados\:
ignored.class.hierarchies.border.title=Ignorar subclases de\:
ignored.class.label=Clases ignoradas (incluyendo subclases)\:
ignored.class.names=Ignorar Clases (Incluyendo Subclases)
ignored.io.resource.types.label=Tipos de recursos I/O ignorados\:
implicit.array.to.string.display.name=Llamada a 'toString()' en array
implicit.array.to.string.fix.family.name=Hacer Array.toString() implícito
implicit.array.to.string.method.call.problem.descriptor=Llamada implícita a 'toString()' en array devuelto por la llamada a <code>\#ref</code> \#loc
implicit.array.to.string.problem.descriptor=Llamada implícita a 'toString()' en array <code>\#ref</code> \#loc
implicit.array.to.string.quickfix=Envolver con expresión ''{0}''
implicit.call.to.super.display.name=Llamada implícita a 'super()'
implicit.call.to.super.ignore.option=Ignorar para subclases directas de 'java.lang.Object'
implicit.call.to.super.make.explicit.quickfix=Hacer explícita la llamada a 'super()'
implicit.call.to.super.problem.descriptor=Llamada implícita a 'super()' \#loc
implicit.default.charset.usage.constructor.problem.descriptor=La llamada <code>new \#ref()</code> usa el charset predeterminado de la plataforma
implicit.default.charset.usage.display.name=Charset predeterminado de plataforma implícito
implicit.default.charset.usage.fix.family.name=Especificar charset UTF-8
implicit.default.charset.usage.problem.descriptor=La llamada a <code>\#ref()</code> usa el charset predeterminado de la plataforma
implicit.numeric.conversion.assignment.problem.descriptor=Conversión numérica implícita del valor resultado de ''{0}'' a ''{1}'' \#loc
implicit.numeric.conversion.display.name=Conversión numérica implícita
implicit.numeric.conversion.ignore.char.conversion.option=Ignorar conversiones desde y hacia 'char'
implicit.numeric.conversion.ignore.constant.conversion.option=Ignorar conversiones desde constantes y literales
implicit.numeric.conversion.ignore.widening.conversion.option=Ignorar conversiones de ampliación
implicit.numeric.conversion.make.explicit.quickfix=Hacer la conversión explícita
implicit.numeric.conversion.problem.descriptor=Conversión numérica implícita de <code>\#ref</code> de ''{0}'' a ''{1}'' \#loc
import.display.name=Import '*'
import.from.same.package.display.name=Import innecesario del mismo paquete
import.from.same.package.problem.descriptor=Import innecesario del mismo paquete <code>\#ref</code> \#loc
import.problem.descriptor=Import del paquete <code>\#ref</code> \#loc
include.java.system.classes.option=Incluir acoplamientos a clases del sistema Java
include.library.classes.option=Incluir acoplamientos a clases de biblioteca
incompatible.mask.operation.display.name=Operación de máscara de bits incompatible
incompatible.mask.operation.problem.descriptor.always.false=<code>\#ref</code> es siempre false \#loc
incompatible.mask.operation.problem.descriptor.always.true=<code>\#ref</code> es siempre true \#loc
incorrect.date.format.fix.family.name=Corregir formato de fecha incorrecto
increment.decrement.display.name=Resultado de '++' o '--' utilizado
increment.decrement.used.as.expression.fix.family.name=Extraer a sentencia separada
increment.decrement.used.as.expression.quickfix=Extraer ''{0}'' a sentencia separada
inequality.to.safe.not.equals.quickfix=Reemplazar '\!\=' con '\!equals()' seguro para null
infinite.loop.statement.display.name=Sentencia de bucle infinito
infinite.loop.statement.problem.descriptor=La sentencia <code>\#ref</code> no puede completarse sin lanzar una excepción \#loc
infinite.recursion.display.name=Recursión infinita
infinite.recursion.problem.descriptor=El método <code>\#ref()</code> recurre infinitamente y solo puede terminar lanzando una excepción \#loc
info.level.and.lower.option=nivel de información e inferior
inline.call.quickfix=Inlinear llamada
inline.variable.quickfix=Inlinear variable
inner.class.field.hides.outer.display.name=Campo de clase interna oculta campo de clase externa
inner.class.field.hides.outer.ignore.option=Ignorar campos externos no visibles desde la clase interna
inner.class.field.hides.outer.problem.descriptor=El campo de clase interna <code>\#ref</code> oculta campo de clase externa \#loc
inner.class.may.be.static.display.name=La clase interna puede ser 'static'
inner.class.may.be.static.problem.descriptor=La clase interna <code>\#ref</code> puede ser 'static' \#loc
inner.class.on.interface.display.name=Clase interna de interfaz
inner.class.on.interface.ignore.option=Ignorar interfaces internas de interfaces
inner.class.on.interface.problem.descriptor=La interfaz ''{0}'' tiene la clase interna <code>\#ref</code> \#loc
inner.class.referenced.via.subclass.display.name=Clase interna referenciada a través de subclase
inner.class.referenced.via.subclass.problem.descriptor=Clase interna <code>\#ref</code> declarada en la clase ''{0}'' pero referenciada a través de la subclase ''{1}'' \#loc
inner.class.referenced.via.subclass.quickfix=Racionalizar acceso a clase interna
inner.class.too.deeply.nested.display.name=Clase interna anidada demasiado profundamente
inner.class.too.deeply.nested.nesting.limit.option=Límite de anidamiento\:
inner.class.too.deeply.nested.problem.descriptor=<code>\#ref</code> está anidada demasiado profundamente (nivel de anidamiento \= {0}) \#loc
inspection.autocloseable.resource.ignored.methods.title=Ignorar instancias AutoCloseable devueltas por estos métodos\:
inspection.byte.array.output.stream.to.string.message=Conversión ineficiente desde ByteArrayOutputStream
inspection.case.mismatch.display.name=Mayúsculas/minúsculas no coincidentes en operación 'String'
inspection.case.mismatch.message.arg.is.lower=El método ''{0}()'' siempre devuelve {1}\: el argumento contiene un símbolo en minúscula mientras que el calificador no contiene símbolos en minúscula
inspection.case.mismatch.message.arg.is.upper=El método ''{0}()'' siempre devuelve {1}\: el argumento contiene un símbolo en mayúscula mientras que el calificador no contiene símbolos en mayúscula
inspection.case.mismatch.message.label.is.lower=Rama switch inalcanzable\: la etiqueta contiene un símbolo en minúscula mientras que el selector es solo mayúsculas
inspection.case.mismatch.message.label.is.upper=Rama switch inalcanzable\: la etiqueta contiene un símbolo en mayúscula mientras que el selector es solo minúsculas
inspection.cast.can.be.replaced.with.variable.display.name=El cast puede ser reemplazado con variable
inspection.cast.can.be.replaced.with.variable.family.name=Reemplazar cast con variable
inspection.cast.can.be.replaced.with.variable.message=La variable ''{0}'' puede ser usada en lugar de ''{1}''
inspection.catch.ignores.exception.display.name=El bloque catch puede ignorar la excepción
inspection.catch.ignores.exception.empty.message=Bloque <code>\#ref</code> vacío \#loc
inspection.catch.ignores.exception.option.comments=No advertir cuando el bloque 'catch' contiene un comentario
inspection.catch.ignores.exception.option.ignored.used=No advertir cuando la excepción nombrada 'ignore(d)' no está realmente ignorada
inspection.catch.ignores.exception.option.nonempty=No advertir cuando el bloque 'catch' no está vacío
inspection.catch.ignores.exception.unused.message=Parámetro 'catch' no utilizado <code>\#ref</code> \#loc
inspection.catch.ignores.exception.used.message=El parámetro 'catch' nombrado <code>\#ref</code> está en uso \#loc
inspection.catch.ignores.exception.vm.ignored.message=Excepción inesperada de VM como ''{0}'' podría ser ignorada en un bloque <code>\#ref</code> \#loc
inspection.collection.must.have.initial.capacity.initializers.option=No reportar inicializadores de campo
inspection.commented.out.code.disable.short.fragments=No reportar fragmentos tan cortos
inspection.commented.out.code.display.name=Código comentado
inspection.commented.out.code.min.lines.options=Mínimo de líneas de código
inspection.commented.out.code.problem.descriptor=Código comentado ({0} {0, choice, 1\#línea|1<líneas})
inspection.common.if.parts.description.complete.duplicate=Se puede Contraer la sentencia ''if''{0}
inspection.common.if.parts.description.complete.duplicate.side.effect=Se puede Contraer la sentencia 'if' con extracción de efecto secundario
inspection.common.if.parts.description.variables.only=Se pueden extraer variables de ''if''{0}
inspection.common.if.parts.description.whole.branch=Se puede extraer parte común eliminando rama{0}
inspection.common.if.parts.description.with.variables.extract=Se pueden extraer partes comunes con variables de ''if''{0}
inspection.common.if.parts.description.without.variables.extract=Se puede extraer parte común de ''if''{0}
inspection.common.if.parts.message.complete.duplicate=Contraer sentencia ''if''{0}
inspection.common.if.parts.message.complete.duplicate.side.effect=Contraer sentencia 'if' y extraer efecto secundario
inspection.common.if.parts.message.variables.only=Extraer variables de ''if''{0}
inspection.common.if.parts.message.whole.branch=Extraer parte común eliminando rama{0}
inspection.common.if.parts.message.with.variables.extract=Extraer parte común con variables de ''if''{0}
inspection.common.if.parts.message.without.variables.extract=Extraer parte común de ''if''{0}
inspection.common.subexpression.in.switch.display.name=La subexpresión común puede ser extraída de 'switch'
inspection.common.subexpression.in.switch.fix.family.name=Empujar hacia abajo expresión 'switch'
inspection.comparator.combinators.description=Puede ser reemplazado con cadena de 'Comparator'
inspection.comparator.combinators.description2=Puede ser reemplazado con ''{0}''
inspection.comparator.combinators.fix.chain=Reemplazar con cadena de 'Comparator'
inspection.condition.covered.by.further.condition.descr=Condición ''{0}'' cubierta por {1, choice, 1\#la condición ''''{2}''''|2\#las condiciones} siguiente
inspection.constant.expression.display.name=La expresión constante puede ser evaluada
inspection.constant.expression.fix.family.name=Calcular valor constante
inspection.constant.expression.fix.name=Calcular valor constante de ''{0}''
inspection.constant.expression.fix.name.short=Reemplazar con valor constante
inspection.constant.expression.message=La expresión constante puede ser evaluada a ''{0}''
inspection.constant.expression.report.compile.time=Reportar solo constantes en tiempo de compilación
inspection.constant.expression.report.compile.time.description=Por defecto, la inspección puede evaluar algunas constantes que involucran llamadas a métodos de biblioteca, o incluso deducir el valor constante basado en el código circundante. Marque esta opción para reportar solo constantes en tiempo de compilación, según la especificación del lenguaje Java.
inspection.constant.expression.skip.non.literal=No reportar expresiones que contengan referencias a constantes definidas
inspection.constant.expression.skip.non.literal.description=Ignorar expresiones que contengan referencias a operandos no literales, como campos y variables.
inspection.deconstruction.can.be.used.display.name=Se puede usar patrón de registro
inspection.deconstruction.can.be.used.fix.family.name=Reemplazar con patrón de registro
inspection.deconstruction.can.be.used.message=Puede ser reemplazado con patrón de registro
inspection.empty.catch.block.generate.body=Generar cuerpo de 'catch' desde plantilla
inspection.empty.class.ignore.subclasses.option=Ignorar subclases de {0}
inspection.enhanced.for.with.record.pattern.can.be.used.components.option=Número máximo de componentes de registro a deconstruir\:
inspection.enhanced.for.with.record.pattern.can.be.used.display.name=Se puede usar 'for' mejorado con un patrón de registro
inspection.enhanced.for.with.record.pattern.can.be.used.fix.family.name=Reemplazar con un patrón de registro
inspection.enhanced.for.with.record.pattern.can.be.used.level.option=Límite de profundidad de anidamiento\:
inspection.enhanced.for.with.record.pattern.can.be.used.maximum.depth.disabled=No sugerir para patrones con {0} y más patrones anidados
inspection.enhanced.for.with.record.pattern.can.be.used.maximum.number.disabled=No sugerir para registros con {0} o más componentes
inspection.enhanced.for.with.record.pattern.can.be.used.message=Puede ser reemplazado con 'for' mejorado con un patrón de registro
inspection.enhanced.for.with.record.pattern.can.be.used.not.used.option=Número máximo de componentes de registro no utilizados\:
inspection.excessive.range.check.fix.family.name=Simplificar comprobación de rango excesiva
inspection.excessive.range.check.message=Puede reemplazarse con ''{0}''
inspection.if.statement.missing.break.in.loop.description=El bucle puede terminarse después de cumplir la condición
inspection.if.statement.missing.break.in.loop.name=Salida temprana de bucle en condición 'if'
inspection.if.statement.missing.break.in.loop.quickfix=Agregar 'break'
inspection.incorrect.date.format.display.name=Patrón 'DateTimeFormat' incorrecto
inspection.incorrect.date.format.message.literal=Comilla simple de apertura ({0}) sin comilla simple de cierre
inspection.incorrect.date.format.message.padding=Modificador de relleno ''{0}'' sin letras consecutivas de patrón
inspection.incorrect.date.format.message.reserved.character=Uso de carácter reservado ''{0}''
inspection.incorrect.date.format.message.unpaired=Cierre de <code>\#ref</code> sin apertura previa ''{0}''
inspection.incorrect.date.format.message.unsupported=Letra de patrón ilegal ''{0}''
inspection.incorrect.date.format.too.few.letters=Muy pocas letras consecutivas de patrón ''{0}''; mínimo\: {1}; especificado\: {2}
inspection.incorrect.date.format.too.many.letters=Demasiadas letras consecutivas de patrón ''{0}''; máximo\: {1}; especificado\: {2}
inspection.incorrect.date.format.wrong.number.of.letters=Número incorrecto de letras consecutivas de patrón ''{0}''; permitido\: {1}; especificado\: {2}
inspection.incorrect.message.custom.classes.methods=Métodos personalizados de MessageFormat\:
inspection.incorrect.message.format.choice.limit.incorrect=Límite inferior ''{0}'' en patrón de elección es incorrecto
inspection.incorrect.message.format.choice.limit.not.found=Límite inferior vacío en patrón de elección
inspection.incorrect.message.format.display.name=Patrón 'MessageFormat' incorrecto
inspection.incorrect.message.format.incorrect.index=Índice incorrecto ''{0}''
inspection.incorrect.message.format.incorrect.order.choice=Límites inferiores no están en orden ascendente en patrón de elección
inspection.incorrect.message.format.incorrect.quotes.number=Probablemente número incorrecto de comillas, se imprimirá más de 1 comilla
inspection.incorrect.message.format.not.found.argument=No hay argumento para el índice ''{0}''
inspection.incorrect.message.format.not.found.arguments=No hay argumentos para los índices\: {0}
inspection.incorrect.message.format.not.used.argument=El argumento con índice ''{0}'' no se usa en el patrón
inspection.incorrect.message.format.pattern={0} en patrón de formato de mensaje ''{1}''
inspection.incorrect.message.format.quotes.around.parameter=El marcador ''{0}'' no será sustituido porque está entre comillas
inspection.incorrect.message.format.unclosed.brace=Llave sin cerrar
inspection.incorrect.message.format.unknown.format.type=Tipo de formato desconocido ''{0}''
inspection.incorrect.message.format.unmatched.brace=Llave sin coincidencia
inspection.incorrect.message.format.unpaired.quote=Comilla sin pareja en patrón de mensaje
inspection.list.remove.in.loop.display.name='List.remove()' llamado en bucle
inspection.list.remove.in.loop.message=Puede reemplazarse con 'List.subList().clear()'
inspection.lossy.conversion.compound.assignment.display.name=La conversión implícita de ''{0}'' a ''{1}'' en asignación compuesta puede tener pérdidas
inspection.lossy.conversion.compound.assignment.name=Posible conversión implícita con pérdida en asignación compuesta
inspection.meta.annotation.without.runtime.description={0} debería tener @Retention(RetentionPolicy.RUNTIME)
inspection.method.call.in.loop.ignore.known.methods.option=Ignorar métodos conocidos con efectos secundarios
inspection.new.object.equality.display.name=Nuevo objeto comparado usando '\=\='
inspection.new.object.equality.message=Nuevo objeto comparado usando ''{0}''
inspection.non.strict.comparison.equality.display.name=La desigualdad no estricta '>\=' o '<\=' puede reemplazarse con '\=\='
inspection.non.strict.comparison.equality.message=Puede reemplazarse con igualdad
inspection.note.may.change.semantics=puede cambiar la semántica
inspection.only.one.element.used.array=Solo se usa un elemento del array
inspection.only.one.element.used.display.name=Solo se usa un elemento
inspection.only.one.element.used.fix.family=Reemplazar con el elemento accedido
inspection.only.one.element.used.list=Solo se usa un elemento de la lista
inspection.only.one.element.used.string=Solo se usa un carácter de la cadena
inspection.option.ignore.as.initial.capacity=Ignorar capacidad inicial para StringBuilders y Collections
inspection.option.ignore.assert=Ignorar para argumentos de descripción de sentencias assert
inspection.option.ignore.constant.initializers=Ignorar para inicializadores de campos constantes
inspection.option.ignore.exceptions=Ignorar para argumentos del constructor de subclases de Throwable
inspection.option.ignore.in.annotations=Ignorar en anotaciones
inspection.option.ignore.in.hashcode=Ignorar constantes en métodos 'hashCode()'
inspection.option.ignore.in.tostring=Ignorar dentro de métodos toString()
inspection.option.ignore.nonnls=Ignorar cuando está anotado con @NonNls
inspection.option.ignore.system.err=Ignorar para argumentos de 'System.err.print'
inspection.option.ignore.system.out=Ignorar para argumentos de 'System.out.print'
inspection.pattern.variable.can.be.used.display.name=Se puede usar variable de patrón
inspection.pattern.variable.can.be.used.existing.cast.message=Se puede usar la variable de patrón existente ''{0}'' en lugar de la expresión de cast
inspection.pattern.variable.can.be.used.existing.fix.family.name=Reemplazar con variable de patrón existente
inspection.pattern.variable.can.be.used.existing.fix.name=Reemplazar ''{0}'' con variable de patrón existente ''{1}''
inspection.pattern.variable.can.be.used.existing.message=Se puede usar la variable de patrón existente ''{0}'' en lugar de ''{1}''
inspection.pattern.variable.can.be.used.fix.family.name=Reemplazar con variable de patrón
inspection.pattern.variable.can.be.used.fix.name=Reemplazar ''{0}'' con variable de patrón
inspection.pattern.variable.can.be.used.instead.of.cast.message=La expresión de cast puede reemplazarse con variable de patrón
inspection.pattern.variable.can.be.used.message=La variable ''{0}'' puede reemplazarse con variable de patrón
inspection.pattern.variable.can.be.used.report.cast.only=Reportar expresiones de cast que pueden reemplazarse con nuevas variables de patrón introducidas
inspection.pattern.variable.instead.of.cast.can.be.used.existing.fix.name=Reemplazar expresión de cast con variable de patrón existente ''{0}''
inspection.pattern.variable.instead.of.cast.can.be.used.fix.family.name=Reemplazar expresiones de cast con variable de patrón
inspection.redundant.arguments.message=Argumentos innecesarios
inspection.redundant.class.call.display.name=Llamada redundante a 'isInstance()' o 'cast()'
inspection.redundant.collection.operation.display.name=Operación redundante de 'Collection'
inspection.redundant.collection.operation.fix.family.name=Simplificar operación de colección
inspection.redundant.collection.operation.problem.arraycopy=Colección innecesaria creada para copiar un array
inspection.redundant.collection.removal.by.index.fix=Usar eliminación por objeto
inspection.redundant.collection.removal.by.index.problem=La eliminación por índice puede reemplazarse por eliminación por objeto
inspection.redundant.collection.unnecessary.contains.fix=Eliminar comprobación de ''{0}()''
inspection.redundant.collection.unnecessary.contains.problem=Comprobación innecesaria de ''{0}()''
inspection.redundant.compare.call.display.name=Llamada redundante al método 'compare()'
inspection.redundant.compare.call.fix.name=Inline llamada 'compare()'
inspection.redundant.embedded.expression.display.name=Expresión embebida redundante en plantilla de cadena
inspection.redundant.embedded.expression.fix.family.name=Inline expresión embebida
inspection.redundant.embedded.expression.message.empty=Expresión embebida vacía redundante
inspection.redundant.embedded.expression.message.literal=Literal embebido redundante
inspection.redundant.empty.string.argument.message=Argumento de cadena vacía innecesario
inspection.redundant.explicit.variable.type.description=Se puede omitir el tipo explícito de variable local
inspection.redundant.java.time.operation.compare.java.time.family.name=Simplificar expresión con llamada 'compareTo()' de 'java.time'
inspection.redundant.java.time.operation.compare.java.time.problem.descriptor=La expresión con llamada <code>\#ref()</code> de 'java.time' puede simplificarse
inspection.redundant.java.time.operation.creation.java.time.error.message=Creación redundante de objeto ''{0}''
inspection.redundant.java.time.operation.creation.java.time.error.remove.fix.message=Eliminar llamada a ''{0}''
inspection.redundant.java.time.operation.creation.java.time.error.replace.fix.message=Reemplazar con llamada a ''{0}''
inspection.redundant.java.time.operation.creation.java.time.family.name=Simplificar creación de objeto 'java.time'
inspection.redundant.java.time.operation.creation.java.time.redundant.call.message=Llamada redundante a ''{0}''
inspection.redundant.java.time.operation.creation.java.time.remove.family.name=Eliminar llamada innecesaria
inspection.redundant.java.time.operation.display.name=Operación redundante en objeto 'java.time'
inspection.redundant.java.time.operation.explicit.chrono.field.family.name=Simplificar llamadas con argumentos explícitos 'ChronoField' o 'ChronoUnit'
inspection.redundant.java.time.operation.explicit.chrono.field.problem.descriptor=Las llamadas con argumentos explícitos 'ChronoField' o 'ChronoUnit' pueden simplificarse
inspection.redundant.length.check.display.name=Comprobación redundante de longitud de array
inspection.redundant.string.call.message=La llamada a <code>\#ref()</code> es redundante \#loc
inspection.redundant.string.constructor.message=<code>new \#ref()</code> es redundante \#loc
inspection.redundant.string.fix.family.name=Eliminar llamada redundante
inspection.redundant.string.fix.remove.str.processor.description=La plantilla de cadena puede convertirse a literal de cadena simple
inspection.redundant.string.intern.on.constant.message=La llamada a <code>\#ref()</code> en constante en tiempo de compilación es innecesaria \#loc
inspection.redundant.string.length.argument.message=Argumento de longitud de string innecesario
inspection.redundant.string.new.array.message=<code>\#ref</code> es redundante \#loc
inspection.redundant.string.operation.display.name=Operación 'String' redundante
inspection.redundant.string.option.do.not.report.single.argument.substring=No reportar llamadas redundantes a substring() con un solo argumento
inspection.redundant.string.option.do.not.report.string.constructors=No reportar llamadas al constructor String
inspection.redundant.string.remove.argument.fix.name=Eliminar argumento
inspection.redundant.string.replace.with.arg.fix.name=Reemplazar con argumento
inspection.redundant.string.replace.with.empty.fix.name=Reemplazar con string vacío
inspection.redundant.zero.argument.message=Argumento cero innecesario
inspection.refused.bequest.super.annotated.option=Solo reportar cuando el método super está anotado por\:
inspection.remove.redundant.call.fix.name=Eliminar llamada redundante a ''{0}()''
inspection.replace.on.literal.display.name=La operación de reemplazo no tiene efecto
inspection.simplifiable.if.statement.display.name=La sentencia 'if' puede ser reemplazada con expresión condicional o booleana
inspection.simplifiable.if.statement.fix.family.name=Reemplazar 'if else' con expresión condicional
inspection.simplifiable.if.statement.fix.name=Reemplazar ''if else'' con ''{0}''
inspection.simplifiable.if.statement.message=La sentencia if puede ser reemplazada con ''{0}''
inspection.simplifiable.if.statement.option.dont.warn.on.ternary=No sugerir operador '?\:'
inspection.suspicious.date.format.display.name=Patrón de formato de fecha sospechoso
inspection.suspicious.date.format.message.lower=Se usa el patrón ''{0}'' ({1}) en minúsculas\: probablemente se intentaba usar ''{2}'' ({3})
inspection.suspicious.date.format.message.upper=Se usa el patrón ''{0}'' ({1}) en mayúsculas\: probablemente se intentaba usar ''{2}'' ({3})
inspection.suspicious.package.private.access.description={0} es {1}, pero está declarado en un módulo diferente ''{2}''
inspection.suspicious.package.private.access.problem={0} sobrescribe un método package-private de {1} que está declarado en un módulo diferente ''{2}''
inspection.test.method.without.assertion.list.name=Métodos de aserción\:
inspection.test.method.without.assertions.exceptions.option=Ignorar métodos de test que declaran excepciones
inspection.trivial.functional.expression.usage.description=La llamada al método puede ser simplificada
inspection.type.may.be.weakened.add.stop.class.family=Agregar clase de parada
inspection.type.may.be.weakened.add.stop.class.selection.popup=Seleccionar Clase de Parada
inspection.type.may.be.weakened.add.stop.class.selection.table=Clases de Parada
inspection.type.may.be.weakened.add.stop.class.selection.table.label=Clases de parada\:
inspection.type.may.be.weakened.add.stopper=Agregar como Clase de Parada para Debilitamiento
inspection.type.may.be.weakened.add.stopper.preview=La clase de parada será agregada a la lista de clases de parada para esta inspección.
inspection.type.may.be.weakened.add.stopper.single=Agregar {0} como clase de parada para debilitamiento
inspection.type.may.be.weakened.display.name=El tipo puede ser debilitado
inspection.type.may.be.weakened.do.not.weaken.inferred.variable.type=No sugerir debilitar variables declaradas como 'var'
inspection.type.may.be.weakened.field.problem.descriptor=El tipo del campo <code>\#ref</code> puede ser debilitado a {0} \#loc
inspection.type.may.be.weakened.method.problem.descriptor=El tipo de retorno del método <code>\#ref()</code> puede ser debilitado a {0} \#loc
inspection.type.may.be.weakened.only.weaken.to.an.interface=Solo debilitar a una interfaz
inspection.type.may.be.weakened.parameter.problem.descriptor=El tipo del parámetro <code>\#ref</code> puede ser debilitado a {0} \#loc
inspection.type.may.be.weakened.problem.descriptor=El tipo de la variable <code>\#ref</code> puede ser debilitado a {0} \#loc
inspection.type.may.be.weakened.quickfix=Debilitar tipo a ''{0}''
inspection.type.may.be.weakened.weaken.type.family=Debilitar tipo
inspection.unnecessary.string.escape.report.char.literals.option=Reportar literales char
inspection.unsupported.chrono.field.unit.call.display.name=Llamar métodos con 'java.time.temporal.ChronoUnit' y 'java.time.temporal.ChronoField' no soportados
inspection.unsupported.chrono.value.message=Valor de argumento no soportado\: {0}
inspection.unsupported.chrono.values.message=Valores de argumento no soportados\: {0}
inspection.use.of.private.field.inner.classes.option=Ignorar accesos desde clases internas
inspection.use.of.slash.s.display.name=Uso no terminal de secuencia de escape '\\s'
inspection.use.of.slash.s.fix.family=Reemplazar secuencias '\\s' con espacios
inspection.use.of.slash.s.message=Uso de la secuencia de escape '\\s' como espacio no final
inspection.use.of.slash.s.non.text.block.message=Uso de la secuencia de escape '\\s' fuera de bloques de texto
inspection.while.can.be.replaced.with.do.while.display.name='while' puede ser reemplazado con 'do while'
inspection.while.can.be.replaced.with.do.while.family.name=Reemplazar 'while' con 'do while'
inspection.while.can.be.replaced.with.do.while.message=Reemplazar 'while' con 'do while'
inspection.x.call.can.be.replaced.with.y=La llamada <code>\#ref()</code> puede ser reemplazada con ''{0}()''
instance.Variable.may.not.be.initialized.problem.descriptor.junit=El campo de instancia <code>\#ref</code> puede no estar inicializado durante la construcción del objeto o la llamada a 'setUp()' \#loc
instance.method.naming.convention.element.description=Método de instancia
instance.variable.may.not.be.initialized.display.name=El campo de instancia puede no estar inicializado
instance.variable.may.not.be.initialized.problem.descriptor=El campo de instancia <code>\#ref</code> puede no estar inicializado durante la construcción del objeto \#loc
instance.variable.naming.convention.element.description=Campo de instancia
instance.variable.of.concrete.class.problem.descriptor=Campo de instancia ''{0}'' de la clase concreta <code>\#ref</code> \#loc
instance.variable.used.before.initialized.display.name=Campo de instancia usado antes de la inicialización
instance.variable.used.before.initialized.problem.descriptor=Campo de instancia <code>\#ref</code> usado antes de inicializar \#loc
instanceof.catch.parameter.display.name='instanceof' en parámetro 'catch'
instanceof.catch.parameter.problem.descriptor='instanceof' en parámetro 'catch' <code>\#ref</code> \#loc
instanceof.check.for.this.display.name=Comprobación 'instanceof' para 'this'
instanceof.check.for.this.equality.problem.descriptor=Comparación de clase para 'this' \#loc
instanceof.check.for.this.problem.descriptor=Comprobación 'instanceof' para <code>\#ref</code> \#loc
instanceof.concrete.class.equality.problem.descriptor=Comparación de clase contra clase concreta <code>\#ref</code> \#loc
instanceof.concrete.class.pattern.problem.descriptor=Test de patrón contra una clase concreta <code>\#ref</code> \#loc
instanceof.concrete.class.problem.descriptor='instanceof' de clase concreta <code>\#ref</code> \#loc
instanceof.with.incompatible.interface.display.name='instanceof' con tipo incompatible
instanceof.with.incompatible.interface.problem.descriptor=''instanceof'' de expresión con tipo ''{1}'' con {0, choice, 1\#interfaz|2\#clase} incompatible <code>\#ref</code> \#loc
instantiating.datetimeformatter.without.locale.problem.descriptor=Llamando a <code>DateTimeFormatter.\#ref()</code> sin especificar un Locale en un contexto internacionalizado \#loc
instantiating.object.to.get.class.object.display.name=Instanciando objeto para obtener objeto 'Class'
instantiating.object.to.get.class.object.problem.descriptor=Instanciando objeto para obtener objeto Class \#loc
instantiating.object.to.get.class.object.replace.quickfix=Reemplazar con acceso directo al objeto class
instantiating.simpledateformat.without.locale.display.name='SimpleDateFormat' sin locale
instantiating.simpledateformat.without.locale.problem.descriptor=Instanciando un <code>\#ref</code> sin especificar un Locale en un contexto internacionalizado \#loc
instantiation.utility.class.display.name=Instanciación de clase de utilidad
instantiation.utility.class.problem.descriptor=Instanciación de clase de utilidad <code>\#ref</code> \#loc
int.literal.may.be.long.literal.display.name=La conversión a 'long' puede ser literal 'long'
int.literal.may.be.long.literal.problem.descriptor=<code>\#ref</code> puede ser reemplazado con ''{0}'' \#loc
integer.division.in.floating.point.context.display.name=División de enteros en contexto de punto flotante
integer.division.in.floating.point.context.fix.family.name=Convertir el numerador a tipo punto flotante
integer.division.in.floating.point.context.fix.name=Convertir el numerador a ''{0}''
integer.division.in.floating.point.context.problem.descriptor=<code>\#ref</code>\: división de enteros en contexto de punto flotante \#loc
integer.multiplication.implicit.cast.to.long.display.name=Multiplicación o desplazamiento de enteros convertido implícitamente a 'long'
integer.multiplication.implicit.cast.to.long.option=<html>Ignorar expresiones donde está probado estáticamente que el desbordamiento es imposible</html>
integer.multiplication.implicit.cast.to.long.problem.descriptor=\#ref\: multiplicación de enteros convertida implícitamente a long \#loc
integer.multiplication.implicit.cast.to.long.quickfix=Convertir a long
integer.shift.implicit.cast.to.long.problem.descriptor=\#ref\: desplazamiento de enteros convertido implícitamente a long \#loc
interface.clashes.with.object.class.display.name=El método de interfaz colisiona con método en 'Object'
interface.clashes.with.object.class.problem.descriptor=<code>\#ref()</code> colisiona con método en 'java.lang.Object'
interface.may.be.annotated.functional.display.name=La interfaz puede ser anotada como '@FunctionalInterface'
interface.may.be.annotated.functional.problem.descriptor=La interfaz <code>\#ref</code> puede ser anotada con @FunctionalInterface
interface.naming.convention.element.description=Interfaz
interface.never.implemented.display.name=Interfaz que no tiene subclase concreta
interface.never.implemented.option=Ignorar interfaces que solo declaran constantes
interface.never.implemented.problem.descriptor=La interfaz <code>\#ref</code> no tiene subclase concreta \#loc
interface.one.inheritor.display.name=Interfaz con un único heredero directo
interface.one.inheritor.problem.descriptor=La interfaz <code>\#ref</code> tiene solo un heredero directo \#loc
introduce.holder.class.quickfix=Introducir clase holder
introduce.variable.may.change.semantics.quickfix=Introducir variable (puede cambiar la semántica)
introduce.variable.quickfix=Introducir variable
invert.method.quickfix=Invertir método
invert.quickfix=Invertir ''{0}''
invert.quickfix.family.name=Invertir booleano
iterator.hasnext.which.calls.next.display.name='Iterator.hasNext()' que llama a 'next()'
iterator.hasnext.which.calls.next.problem.descriptor=<code>Iterator.{0}()</code> contiene llamada a ''\#ref()'' \#loc
iterator.next.does.not.throw.nosuchelementexception.display.name='Iterator.next()' que no puede lanzar 'NoSuchElementException'
iterator.next.does.not.throw.nosuchelementexception.problem.descriptor=<code>Iterator.\#ref()</code> que no puede lanzar 'NoSuchElementException' \#loc
java.lang.import.display.name=Import innecesario del paquete 'java.lang'
java.lang.import.problem.descriptor=Import innecesario del paquete 'java.lang' \#loc
jdbc.execute.with.non.constant.string.display.name=Llamada a 'Statement.execute()' con string no constante
jdbc.execute.with.non.constant.string.problem.descriptor=Llamada a <code>Statement.\#ref()</code> con argumento no constante \#loc
jdbc.prepare.statement.with.non.constant.string.display.name=Llamada a 'Connection.prepare*()' con string no constante
jdbc.prepare.statement.with.non.constant.string.problem.descriptor=Llamada a <code>Connection.\#ref()</code> con argumento no constante \#loc
jdbc.resource.opened.not.closed.display.name=Recurso JDBC abierto pero no cerrado de forma segura
jndi.resource.opened.not.closed.display.name=Recurso JNDI abierto pero no cerrado de forma segura
junit.abstract.test.class.naming.convention.element.description=Clase de test abstracta
junit.test.class.naming.convention.element.description=Clase de test
junit.test.suite.naming.convention.element.description=Suite de test
junit3.method.naming.convention.element.description=Método de test JUnit 3
junit4.method.naming.convention.element.description=Método de test JUnit 4+
key.set.iteration.may.use.entry.set.display.name=La iteración sobre 'keySet()' puede optimizarse
key.set.iteration.may.use.entry.set.problem.descriptor=La iteración sobre <code>\#ref</code> puede reemplazarse por iteración ''{0}'' \#loc
key.set.iteration.may.use.entry.set.quickfix=Optimizar iteración de Map
labeled.statement.display.name=Sentencia etiquetada
labeled.statement.problem.descriptor=Sentencia etiquetada <code>\#ref\:</code> \#loc
lambda.body.can.be.code.block.name=El cuerpo lambda puede ser un bloque de código
lambda.body.can.be.code.block.quickfix=Expandir cuerpo lambda a {...}
lambda.can.be.replaced.with.anonymous.name=Lambda puede reemplazarse con clase anónima
lambda.can.be.replaced.with.anonymous.quickfix=Reemplazar lambda con clase anónima
lambda.parameter.hides.member.variable.display.name=Parámetro lambda oculta campo
lambda.parameter.hides.member.variable.ignore.invisible.option=Ignorar campos no visibles realmente desde el lambda
lambda.parameter.hides.member.variable.problem.descriptor=Parámetro lambda <code>\#ref</code> oculta campo en la clase ''{0}'' \#loc
lambda.parameter.naming.convention.display.name=Convención de nomenclatura de parámetro lambda
lambda.parameter.naming.convention.element.description=Parámetro lambda
lambda.parameter.type.can.be.specified.descriptor=Los tipos de parámetros lambda pueden expandirse a {0}
lambda.parameter.type.can.be.specified.family.quickfix=Especificar tipo de parámetro lambda
lambda.parameter.type.can.be.specified.name=Se puede especificar el tipo de parámetro lambda
lambda.parameter.type.can.be.specified.quickfix=Expandir tipos de parámetros a {0}
lambda.unfriendly.constructor.overload.problem.descriptor=Sobrecarga no amigable con lambda del constructor <code>\#ref()</code>
lambda.unfriendly.method.overload.display.name=Sobrecarga de método no amigable con lambda
lambda.unfriendly.method.overload.problem.descriptor=Sobrecarga no amigable con lambda del método <code>\#ref()</code>
large.array.allocation.no.outofmemoryerror.display.name=Asignación de array grande sin comprobación de OutOfMemoryError
large.array.allocation.no.outofmemoryerror.maximum.number.of.elements.option=Número máximo de elementos\:
large.array.allocation.no.outofmemoryerror.problem.descriptor=Asignación de array grande sin comprobación de condición de memoria insuficiente \#loc
large.initializer.primitive.type.array.display.name=Inicializador demasiado grande para array de tipo primitivo
large.initializer.primitive.type.array.maximum.number.of.elements.option=Número máximo de elementos\:
large.initializer.primitive.type.array.problem.descriptor=Inicializador de array primitivo con demasiados elementos ({0}) \#loc
law.of.demeter.display.name=Ley de Demeter
law.of.demeter.field.problem.descriptor=Acceso a <code>\#ref</code> viola la Ley de Demeter \#loc
law.of.demeter.ignore.library.calls.option=Ignorar llamadas a métodos de biblioteca y acceso a campos de biblioteca
law.of.demeter.problem.descriptor=Llamada a <code>\#ref()</code> viola la Ley de Demeter \#loc
length.one.string.in.indexof.display.name=Argumento string de un solo carácter en llamada a 'String.indexOf()'
length.one.strings.in.concatenation.display.name=Concatenación de string de un solo carácter
length.one.strings.in.concatenation.replace.quickfix=Reemplazar con carácter
limited.scope.inner.class.display.name=Clase local
limited.scope.inner.class.problem.descriptor=Clase local <code>\#ref</code> \#loc
list.indexof.replaceable.by.contains.display.name=Expresión 'List.indexOf()' puede reemplazarse por 'contains()'
listener.may.use.adapter.display.name=La clase puede extender adapter en lugar de implementar listener
listener.may.use.adapter.emtpy.methods.option=Advertir solo cuando se encuentren métodos de implementación vacíos(&O)
listener.may.use.adapter.fix.family.name=Reemplazar con adapter
listener.may.use.adapter.problem.descriptor=La clase ''{0}'' puede extender ''{1}'' en lugar de implementar <code>\#ref</code> \#loc
literal.as.arg.to.string.equals.display.name=Literal string puede ser calificador de 'equals()'
literal.as.arg.to.string.equals.flip.quickfix=Invertir ''{0}()''
literal.as.arg.to.string.equals.problem.descriptor=Literal \#ref es argumento de ''{0}()'', en lugar de su calificador \#loc
load.library.with.non.constant.string.display.name=Llamada a 'System.loadLibrary()' con string no constante
load.library.with.non.constant.string.problem.descriptor=Llamada a <code>{0}.\#ref()</code> con argumento no constante \#loc
local.variable.hides.member.variable.display.name=Variable local oculta campo
local.variable.hides.member.variable.ignore.option=Ignorar variables locales en contexto static que ocultan campos no static
local.variable.hides.member.variable.problem.descriptor=Variable local <code>\#ref</code> oculta campo en la clase ''{0}'' \#loc
local.variable.naming.convention.display.name=Convención de nomenclatura de variable local
local.variable.naming.convention.element.description=Variable local
local.variable.naming.convention.ignore.catch.option=Ignorar parámetros de bloque 'catch'
local.variable.naming.convention.ignore.option=Ignorar parámetros de bucle for
local.variable.of.concrete.class.problem.descriptor=Variable local ''{0}'' de clase concreta <code>\#ref</code> \#loc
log.condition.text=Texto de Condición de Log
log.method.name=Nombre del Método de Logging
log.statement.guarded.by.log.condition.display.name=Llamada de logging no protegida por condición de log
log.statement.guarded.by.log.condition.flag.all.unguarded.option=Marcar todas las llamadas de logging no protegidas
log.statement.guarded.by.log.condition.problem.descriptor=Llamadas de logging <code>\#ref()</code> no protegidas por condición de log \#loc
log.statement.guarded.by.log.condition.quickfix=Rodear con condición de log
logger.class.name=Nombres de clase Logger\:
logger.factory.class.name=Nombre de la Clase Factory de Logger
logger.factory.method.name=Nombre del Método Factory de Logger
logger.initialized.with.foreign.class.display.name=Logger inicializado con clase externa
logger.initialized.with.foreign.class.fix.family.name=Reemplazar clase externa
logger.initialized.with.foreign.class.ignore.non.public.classes.option=Ignorar loggers en clases no públicas
logger.initialized.with.foreign.class.ignore.not.final.field=Ignorar loggers no inicializados en un campo final
logger.initialized.with.foreign.class.ignore.super.class.option=Ignorar loggers inicializados con una superclase
logger.initialized.with.foreign.class.problem.descriptor=Logger inicializado con clase externa <code>\#ref</code> \#loc
logger.name.option=Nombre de clase Logger(&C)\:
long.literals.ending.with.lowercase.l.display.name=Literal 'long' terminando con 'l' en lugar de 'L'
long.literals.ending.with.lowercase.l.problem.descriptor=Literal 'long' <code>\#ref</code> termina con 'l' minúscula \#loc
loop.condition.not.updated.inside.loop.display.name=Variable de bucle no actualizada dentro del bucle
loop.condition.not.updated.inside.loop.problem.descriptor=Condición '\#ref' no se actualiza dentro del bucle \#loc
loop.statements.that.dont.loop.display.name=Sentencia de bucle que no itera
loop.statements.that.dont.loop.problem.descriptor=La sentencia <code>\#ref</code> no itera \#loc
loop.variable.not.updated.inside.loop.option.nonlocal=Ignorar posibles cambios no locales
loop.variable.not.updated.inside.loop.problem.descriptor=La variable '\#ref' no se actualiza dentro del bucle \#loc
loop.with.implicit.termination.condition.display.name=Bucle con condición de terminación implícita
loop.with.implicit.termination.condition.dowhile.problem.descriptor=Bucle <code>\#ref-while</code> con condición de terminación implícita \#loc
loop.with.implicit.termination.condition.problem.descriptor=Bucle <code>\#ref</code> con condición de terminación implícita \#loc
loop.with.implicit.termination.condition.quickfix=Hacer la condición explícita
magic.character.display.name=Carácter mágico
magic.character.problem.descriptor=Carácter mágico <code>\#ref</code> en un contexto internacionalizado \#loc
magic.number.display.name=Número mágico
magic.number.problem.descriptor=Número mágico <code>\#ref</code> \#loc
make.class.final.fix.family.name=Hacer la clase final
make.class.final.fix.name=Hacer la clase ''{0}'' ''final''
make.constructor.public=Hacer el constructor 'public'
make.field.final.fix.family.name=Hacer final
make.field.final.quickfix=Hacer ''{0}'' ''final''
make.field.static.final.fix.family.name=Hacer static final
make.initialization.explicit.quickfix=Hacer la inicialización explícita
make.method.ctr.quickfix=Convertir método en constructor
make.method.final.fix.family.name=Hacer el método 'final'
make.method.final.fix.name=Hacer el método ''{0}()'' ''final''
make.package.private.fix.family.name=Hacer package-private
make.static.final.quickfix=Hacer ''{0}'' static final
make.static.quickfix=Hacer 'static'
malformed.format.string.display.name=Cadena de formato mal formada
malformed.format.string.problem.descriptor.arguments.do.not.match.type=El tipo de argumento ''{0}'' no coincide con el tipo del especificador de formato ''{1}'' \#loc
malformed.format.string.problem.descriptor.at.least.too.few.arguments=Muy pocos argumentos para la cadena de formato (encontrados\: {0}, mínimo esperado\: {1}) \#loc
malformed.format.string.problem.descriptor.illegal=Especificador de formato ilegal\: {0} \#loc
malformed.format.string.problem.descriptor.malformed=La cadena de formato <code>\#ref</code> está mal formada \#loc
malformed.format.string.problem.descriptor.too.few.arguments=Muy pocos argumentos para la cadena de formato (encontrados\: {0}, esperados\: {1}) \#loc
malformed.format.string.problem.descriptor.too.many.arguments=Demasiados argumentos para la cadena de formato (encontrados\: {0}, esperados\: {1}) \#loc
manual.array.copy.display.name=Copia manual de array
manual.array.copy.problem.descriptor=Copia manual de array \#loc
manual.array.to.collection.copy.display.name=Copia manual de array a colección
manual.array.to.collection.copy.problem.descriptor=Copia manual de array a colección \#loc
map.replaceable.by.enum.map.display.name='Map' puede ser reemplazado por 'EnumMap'
map.replaceable.by.enum.map.problem.descriptor=<code>\#ref</code> puede ser reemplazado por 'EnumMap' \#loc
mark.modules.as.loaded.together.fix.family.name=Marcar módulos como cargados juntos
mark.modules.as.loaded.together.fix.text=Marcar los módulos ''{0}'' y ''{1}'' como cargados juntos
markdown.documentation.comments.migration.display.name=El comentario Javadoc puede ser un comentario de documentación Markdown
markdown.documentation.comments.migration.fix=Convertir a comentario de documentación Markdown
marker.interface.display.name=Interfaz marcadora
marker.interface.problem.descriptor=Interfaz marcadora <code>\#ref</code> \#loc
masked.assertion.display.name=La aserción está suprimida por 'catch'
masked.assertion.problem.description=''{0}'' no puede fallar ya que está suprimido por un 'catch' circundante
math.random.cast.to.int.display.name=Conversión de 'Math.random()' a 'int'
math.random.cast.to.int.problem.descriptor=La conversión de <code>\#ref</code> a ''{0}'' siempre se redondea a ''0'' \#loc
math.random.cast.to.int.quickfix=Agregar paréntesis para realizar la multiplicación antes de la conversión
math.rounding.with.int.argument.display.name=Llamar a redondeo matemático con argumento 'int'
math.rounding.with.int.argument.family.name=Simplificar llamadas de redondeo
math.rounding.with.int.argument.problem.descriptor=<code>\#ref()</code> con argumento de tipo 'int' \#loc
math.rounding.with.int.argument.quickfix=Simplificar llamada a ''{0}()''
meta.annotation.without.runtime.retention=Anotación de prueba sin anotación '@Retention(RUNTIME)'
method.call.in.loop.condition.display.name=Llamada a método en condición de bucle
method.call.in.loop.condition.problem.descriptor=Llamada al método <code>\#ref()</code> en condición de bucle \#loc
method.can.be.variable.arity.method.display.name=El método puede tener parámetro varargs
method.can.be.variable.arity.method.ignore.all.primitive.arrays.option=Ignorar todos los tipos de arrays primitivos
method.can.be.variable.arity.method.ignore.byte.short.option=Ignorar parámetros con tipo byte[] o short[]
method.can.be.variable.arity.method.ignore.multidimensional.arrays.option=Ignorar parámetros de arrays multidimensionales
method.can.be.variable.arity.method.ignore.multiple.arrays.option=Ignorar métodos con múltiples parámetros array
method.can.be.variable.arity.method.problem.descriptor=<code>\#ref()</code> puede convertirse en método varargs \#loc
method.complexity.limit.option=Límite de complejidad del método\:
method.count.ignore.getters.setters.option=Ignorar métodos getter y setter simples(&I)
method.count.limit.option=Límite de conteo de métodos\:
method.coupling.display.name=Método excesivamente acoplado
method.coupling.limit.option=Límite de acoplamiento del método\:
method.coupling.problem.descriptor=<code>\#ref</code> está excesivamente acoplado (\# clases referenciadas \= {0}) \#loc
method.may.be.static.display.name=El método puede ser 'static'
method.may.be.static.empty.option=Ignorar métodos vacíos
method.may.be.static.ignore.default.methods.option=Ignorar métodos 'default'
method.may.be.static.only.option=Solo comprobar métodos 'private' o 'final'
method.may.be.static.problem.descriptor=El método <code>\#ref()</code> puede ser 'static' \#loc
method.may.be.static.replaces.qualifiers.with.class.references.option=La corrección rápida reemplaza los calificadores de instancia con referencias de clase
method.may.be.synchronized.display.name=El método con un solo bloque 'synchronized' puede reemplazarse por un método 'synchronized'
method.may.be.synchronized.problem.descriptor=El método <code>\#ref()</code> con bloque synchronized puede ser un método synchronized \#loc
method.may.be.synchronized.quickfix=Hacer el método synchronized y eliminar el bloque synchronized
method.name.regex=Expresión Regular para Nombre de Método
method.name.same.as.class.name.display.name=Nombre de método igual al nombre de la clase
method.name.same.as.class.name.problem.descriptor=El nombre del método <code>\#ref</code> es igual al nombre de su clase \#loc
method.name.same.as.parent.name.display.name=Nombre de método igual al nombre de la clase padre
method.name.same.as.parent.name.problem.descriptor=El nombre del método <code>\#ref</code> es igual al nombre de su clase padre \#loc
method.names.differ.only.by.case.display.name=Nombres de métodos que solo difieren en mayúsculas/minúsculas
method.names.differ.only.by.case.problem.descriptor=El nombre del método <code>\#ref</code> y el nombre del método ''{0}'' solo difieren en mayúsculas/minúsculas \#loc
method.only.used.from.inner.class.display.name=Método private solo usado desde clase interna
method.only.used.from.inner.class.ignore.option=Ignorar métodos llamados desde una clase anónima o local(&A)
method.only.used.from.inner.class.problem.descriptor=El método <code>\#ref()</code>\#loc solo se usa desde {0, choice, 1\#la clase interna |2\#la clase local |3\#}{1, choice, 1\#clase|2\#interfaz|3\#una clase anónima derivada de|4\#tipo de anotación|5\#enum|6\#record} ''{2}'' \#loc
method.overloads.display.name=Posible sobrecarga no intencionada de método de superclase
method.overloads.problem.descriptor=El método <code>\#ref()</code> sobrecarga un método compatible de una superclase, cuando posiblemente se pretendía sobrescribir \#loc
method.overloads.report.incompatible.option=Reportar incluso si los tipos de parámetros no son compatibles
method.overrides.inaccessible.method.display.name=El método sobrescribe un método inaccesible de la superclase
method.overrides.package.local.method.problem.descriptor=El método <code>\#ref()</code> sobrescribe un método package-private de una superclase ubicada en otro paquete \#loc
method.overrides.private.display.name.problem.descriptor=El método <code>\#ref()</code> sobrescribe un método 'private' de una superclase \#loc
method.overrides.static.display.name=El método intenta sobrescribir un método 'static' de la superclase
method.overrides.static.problem.descriptor=El método <code>\#ref()</code> intenta sobrescribir un método static de una superclase \#loc
method.ref.can.be.replaced.with.lambda.name=La referencia a método puede reemplazarse por lambda
method.ref.can.be.replaced.with.lambda.quickfix=Reemplazar referencia a método por lambda
method.return.always.constant.display.name=El método devuelve una constante por clase
method.return.always.constant.problem.descriptor=El método <code>\#ref()</code> y todos sus derivados siempre devuelven constantes
method.return.concrete.class.problem.descriptor=El método devuelve una clase concreta <code>\#ref</code> \#loc
method.with.multiple.loops.display.name=Método con múltiples bucles
method.with.multiple.loops.problem.descriptor=<code>\#ref</code> contiene {0} bucles \#loc
mismatched.read.write.array.display.name=Lectura y escritura no coincidentes del array
mismatched.read.write.array.problem.descriptor.read.not.write=El contenido del array <code>\#ref</code> se lee pero nunca se escribe \#loc
mismatched.read.write.array.problem.descriptor.write.not.read=El contenido del array <code>\#ref</code> se escribe pero nunca se lee \#loc
mismatched.string.builder.queried.problem.descriptor=El contenido de <code>{0} \#ref</code> se consulta pero nunca se actualiza \#loc
mismatched.string.builder.query.update.display.name=Consulta y actualización no coincidentes de 'StringBuilder'
mismatched.string.builder.updated.problem.descriptor=El contenido de <code>{0} \#ref</code> se actualiza pero nunca se consulta \#loc
mismatched.update.collection.display.name=Consulta y actualización no coincidentes de la colección
mismatched.update.collection.problem.description.queried.not.updated=El contenido de la colección <code>\#ref</code> se consulta pero nunca se actualiza \#loc
mismatched.update.collection.problem.descriptor.updated.not.queried=El contenido de la colección <code>\#ref</code> se actualiza pero nunca se consulta \#loc
misordered.assert.equals.arguments.display.name=Argumentos de 'assertEquals()' mal ordenados
misordered.assert.equals.arguments.flip.quickfix=Invertir argumentos comparados
misordered.assert.equals.arguments.problem.descriptor=Argumentos de <code>\#ref()</code> en orden incorrecto \#loc
missing.add.deprecated.javadoc.tag.quickfix=Agregar explicación de etiqueta Javadoc '@deprecated'
missing.deprecated.annotation.add.quickfix=Agregar anotación '@Deprecated'
missing.deprecated.annotation.display.name=Falta la anotación '@Deprecated'
missing.deprecated.annotation.problem.descriptor=Falta la anotación '@Deprecated' \#loc
missing.deprecated.tag.option=Advertir sobre la falta de explicación de la etiqueta Javadoc @deprecated
missing.deprecated.tag.problem.descriptor=Falta la explicación de la etiqueta Javadoc '@deprecated' \#loc
missing.override.annotation.display.name=Falta la anotación '@Override'
missing.override.annotation.in.overriding.problem.descriptor=Los métodos que sobrescriben no están anotados con '@Override'
missing.override.annotation.problem.descriptor=Falta la anotación '@Override' en <code>\#ref()</code> \#loc
missing.override.warn.on.super.option=Resaltar método cuando sus métodos de sobrescritura no tienen todos la anotación '@Override'
missing.package.html.problem.descriptor=Al paquete ''{0}'' le falta un archivo <code>package.html</code>
missing.package.info.display.name=Falta 'package-info.java'
missing.package.info.problem.descriptor=Al paquete ''{0}'' le falta un archivo <code>package-info.java</code>
missing.serial.annotation.display.name=Se puede usar la anotación '@Serial'
missing.serial.annotation.on.field.problem.descriptor=<code>\#ref</code> puede ser anotado con la anotación '@Serial'
missing.serial.annotation.on.method.problem.descriptor=<code>\#ref()</code> puede ser anotado con la anotación '@Serial'
missorted.modifiers.allowed.place=Las anotaciones TYPE_USE siguen las opciones de generación
missorted.modifiers.allowed.place.description=Cuando esta opción está habilitada, las anotaciones target TYPE_USE se reportan cuando no están posicionadas según la opción <pre>{0}</pre> en <pre>Configuración | Editor | Estilo de código | Java | Generación de código.</pre>Cuando esta opción está deshabilitada, las anotaciones target TYPE_USE están permitidas tanto directamente antes del tipo como antes de las palabras clave modificadoras.
missorted.modifiers.display.name=Modificadores mal ordenados
missorted.modifiers.problem.descriptor=Modificadores mal ordenados <code>{0}</code> \#loc
missorted.modifiers.require.option=Comprobar orden de anotaciones
missorted.modifiers.require.option.description=Use esta opción para reportar anotaciones en posición incorrecta\: anotaciones con <code>ElementType.TYPE_USE</code> <em>no</em> directamente antes del tipo y después de las palabras clave modificadoras, u otras anotaciones <em>no</em> antes de las palabras clave modificadoras. Cuando esta opción está deshabilitada, las anotaciones están permitidas tanto antes como después de las palabras clave modificadoras. Las anotaciones entre las palabras clave modificadoras siempre serán reportadas.
missorted.modifiers.sort.quickfix=Ordenar modificadores
misspelled.equals.display.name='equal()' en lugar de 'equals()'
misspelled.equals.problem.descriptor=El método <code>\#ref()</code> probablemente debería ser 'equals()' \#loc
module.with.too.few.classes.display.name=Módulo con muy pocas clases
module.with.too.few.classes.min.option=Número mínimo de clases\:
module.with.too.few.classes.problem.descriptor=El módulo ''{0}'' contiene muy pocas clases ({1} < {2})
module.with.too.many.classes.display.name=Módulo con demasiadas clases
module.with.too.many.classes.max.option=Número máximo de clases\:
module.with.too.many.classes.problem.descriptor=El módulo ''{0}'' contiene demasiadas clases ({1} > {2})
move.anonymous.to.inner.quickfix=Convertir a clase interna con nombre
move.class.quickfix=Mover clase
move.exception.to.javadoc.fix.family.name=Mover a Javadoc '@throws'
move.local.to.inner.quickfix=Convertir a clase interna
multi.catch.can.be.split.name=Multi-catch puede dividirse en bloques catch separados
multi.catch.can.be.split.quickfix=Dividir multi-catch en bloques 'catch' separados
multiple.declaration.array.only.option=Solo advertir sobre diferentes dimensiones de array en una única declaración
multiple.declaration.display.name=Múltiples variables en una declaración
multiple.declaration.ignore.for.option=Ignorar declaraciones de bucle 'for'
multiple.declaration.problem.descriptor=Múltiples variables en una declaración \#loc
multiple.loggers.display.name=Clase con múltiples loggers
multiple.loggers.problem.descriptor=La clase <code>\#ref</code> declara múltiples loggers \#loc
multiple.return.points.per.method.display.name=Método con múltiples puntos de retorno
multiple.return.points.per.method.problem.descriptor=<code>\#ref</code> tiene {0} puntos de retorno \#loc
multiple.top.level.classes.in.file.display.name=Múltiples clases de nivel superior en un solo archivo
multiple.top.level.classes.in.file.problem.descriptor=Múltiples clases de nivel superior en el archivo
multiple.typed.declaration.problem.descriptor=Variables con diferentes dimensiones de array en una declaración \#loc
multiply.or.divide.by.power.of.two.display.name=Multiplicación o división por potencia de dos
multiply.or.divide.by.power.of.two.divide.option=Comprobar también divisiones por potencia de dos
multiply.or.divide.by.power.of.two.replace.quickfix=Reemplazar con desplazamiento
naked.notify.display.name='notify()' o 'notifyAll()' sin cambio de estado correspondiente
naked.notify.problem.descriptor=Llamada a <code>\#ref()</code> sin cambio de estado correspondiente \#loc
naming.convention.problem.descriptor.long=El nombre {0} <code>\#ref</code> es demasiado largo ({1} > {2}) \#loc
naming.convention.problem.descriptor.regex.mismatch=El nombre {0} <code>\#ref</code> no coincide con la expresión regular ''{1}'' \#loc
naming.convention.problem.descriptor.short=El nombre {0} <code>\#ref</code> es demasiado corto ({1} < {2}) \#loc
native.method.display.name=Método nativo
native.method.naming.convention.element.description=método 'native'
native.method.problem.descriptor=Los métodos declarados <code>\#ref</code> no son portables \#loc
negated.conditional.display.name=Expresión condicional con condición negada
negated.conditional.expression.display.name=Expresión condicional negada
negated.conditional.expression.problem.descriptor=Negando expresión condicional \#loc
negated.conditional.expression.quickfix=Eliminar negación
negated.conditional.invert.quickfix=Invertir condición
negated.conditional.problem.descriptor=Expresión condicional con condición negada \#loc
negated.equality.expression.display.name=Expresión de igualdad negada
negated.equality.expression.problem.descriptor=Negando ''{0}'' \#loc
negated.equality.expression.quickfix=Eliminar negación
negated.if.else.display.name=Sentencia 'if' con condición negada
negated.if.else.ignore.negated.null.option=Ignorar comparaciones '\!\= null'
negated.if.else.ignore.negated.zero.option=Ignorar comparaciones '\!\= 0'
negated.if.else.invert.quickfix=Invertir condición 'if'
negated.if.else.problem.descriptor=Sentencia <code>\#ref</code> con condición negada \#loc
negative.int.constant.in.long.context.display.name=Constante hexadecimal int negativa en contexto long
negative.int.constant.in.long.context.fix.add.suffix=Agregar sufijo 'L' (cambia la semántica)
negative.int.constant.in.long.context.fix.convert=Convertir a constante long (preserva la semántica)
negatively.named.boolean.variable.display.name=Variable booleana con nombre negativo
negatively.named.boolean.variable.problem.descriptor=La variable booleana <code>\#ref</code> tiene nombre negativo \#loc
nested.assignment.display.name=Asignación anidada
nested.assignment.problem.descriptor=Se usa el resultado de la expresión de asignación \#loc
nested.conditional.expression.display.name=Expresión condicional anidada
nested.conditional.expression.problem.descriptor=Expresión condicional anidada <code>\#ref</code> \#loc
nested.method.call.display.name=Llamada a método anidada
nested.method.call.ignore.option=Ignorar llamadas a métodos anidadas en inicializadores de campos
nested.method.call.problem.descriptor=Llamada a método anidada <code>\#ref()</code> \#loc
nested.switch.statement.display.name=Sentencia 'switch' anidada
nested.switch.statement.problem.descriptor=<code>\#ref</code> anidado {0} \#loc
nested.synchronized.statement.display.name=Sentencia 'synchronized' anidada
nested.synchronized.statement.problem.descriptor=Sentencia <code>\#ref</code> anidada \#loc
nested.try.statement.display.name=Sentencia 'try' anidada
nested.try.statement.problem.descriptor=Sentencia <code>\#ref</code> anidada \#loc
nesting.depth.display.name=Método excesivamente anidado
nesting.depth.limit.option=Límite de profundidad de anidamiento\:
nesting.depth.problem.descriptor=<code>\#ref</code> está excesivamente anidado (profundidad máxima de anidamiento \= {0}) \#loc
new.exception.without.arguments.display.name=Constructor de excepción llamado sin argumentos
new.exception.without.arguments.problem.descriptor=<code>new \#ref()</code> sin argumentos \#loc
new.method.naming.convention.display.name=Convención de nombres de método
new.string.buffer.replaceable.by.string.problem.descriptor=<code>\#ref</code> puede ser reemplazado por 'String' \#loc
new.string.buffer.with.char.argument.display.name=Llamada al constructor StringBuilder con argumento 'char'
new.string.buffer.with.char.argument.problem.descriptor=<code>new \#ref()</code> con argumento de tipo 'char' \#loc
new.string.buffer.with.char.argument.quickfix=Reemplazar argumento char con literal String
no.logger.display.name=Clase sin logger
no.logger.problem.descriptor=La clase <code>\#ref</code> no declara un logger \#loc
non.atomic.operation.on.volatile.field.display.name=Operación no atómica en campo 'volatile'
non.atomic.operation.on.volatile.field.problem.descriptor=Operación no atómica en campo volatile <code>\#ref</code> \#loc
non.boolean.method.name.must.not.start.with.question.display.name=Nombre de método no booleano no debe comenzar con palabra interrogativa
non.boolean.method.name.must.not.start.with.question.problem.descriptor=Nombre de método no booleano <code>\#ref</code> comienza con palabra interrogativa \#loc
non.comment.source.statements.display.name=Método demasiado largo
non.comment.source.statements.limit.option=Límite de sentencias fuente sin comentarios\:
non.comment.source.statements.problem.descriptor=<code>\#ref</code> es demasiado largo (\# Sentencias fuente sin comentarios \= {0}) \#loc
non.constant.logger.display.name=Logger no constante
non.constant.logger.problem.descriptor=Campo logger no constante <code>\#ref</code> \#loc
non.exception.name.ends.with.exception.display.name=Nombre de clase no excepción termina en 'Exception'
non.exception.name.ends.with.exception.problem.descriptor=Nombre de clase no excepción <code>\#ref</code> termina en 'Exception' \#loc
non.exception.name.ends.with.exception.quickfix=Hacer que ''{0}'' extienda ''java.lang.Exception''
non.final.clone.display.name='clone()' no final en contexto seguro
non.final.clone.problem.descriptor=Método <code>\#ref()</code> no final, comprometiendo la seguridad \#loc
non.final.field.compareto.display.name=Campo no final referenciado en 'compareTo()'
non.final.field.compareto.problem.descriptor=Campo no final <code>\#ref</code> accedido en 'compareTo()' \#loc
non.final.field.in.enum.display.name=Campo no final en 'enum'
non.final.field.in.enum.problem.descriptor=Campo no final <code>\#ref</code> en enum ''{0}'' \#loc
non.final.field.in.enum.quickfix.option=Ignorar campos que no pueden hacerse 'final'
non.final.field.in.equals.display.name=Campo no final referenciado en 'equals()'
non.final.field.in.equals.problem.descriptor=Campo no final <code>\#ref</code> accedido en 'equals()' \#loc
non.final.field.in.hashcode.display.name=Campo no final referenciado en 'hashCode()'
non.final.field.in.hashcode.problem.descriptor=Campo no final <code>\#ref</code> accedido en 'hashCode()' \#loc
non.final.field.of.exception.display.name=Campo no final de clase 'Exception'
non.final.field.of.exception.problem.descriptor=Campo no final <code>\#ref</code> de clase de excepción \#loc
non.final.static.variable.initialization.display.name=Campo static no final usado durante la inicialización de clase
non.final.static.variable.initialization.problem.descriptor=Campo static no final <code>\#ref</code> usado durante la inicialización de clase \#loc
non.final.utility.class.display.name=Clase de utilidad no es 'final'
non.final.utility.class.problem.descriptor=Clase de utilidad <code>\#ref</code> no es 'final' \#loc
non.protected.constructor.in.abstract.class.display.name=Constructor public en clase abstracta
non.protected.constructor.in.abstract.class.ignore.option=Ignorar para clases no public
non.protected.constructor.in.abstract.class.problem.descriptor=El constructor <code>\#ref()</code> de una clase abstracta no debería declararse 'public' \#loc
non.public.clone.display.name=Método 'clone()' no 'public'
non.public.clone.problem.descriptor=Método <code>\#ref()</code> no es 'public' \#loc
non.reproducible.math.call.display.name=Llamada no reproducible a 'Math'
non.reproducible.math.call.problem.descriptor=<code>Math.\#ref()</code> puede producir resultados no reproducibles \#loc
non.reproducible.math.call.replace.quickfix=Reemplazar con llamada a 'StrictMath'
non.serializable.@interface.with.serialversionuid.problem.descriptor=@interface no serializable <code>\#ref</code> define un campo 'serialVersionUID' \#loc
non.serializable.anonymous.with.serialversionuid.problem.descriptor=Clase anónima no serializable derivada de <code>\#ref</code> define un campo 'serialVersionUID' \#loc
non.serializable.class.with.readwriteobject.display.name=Clase no serializable con 'readObject()' o 'writeObject()'
non.serializable.class.with.readwriteobject.problem.descriptor.both={0, choice, 1\#Clase|2\#Interfaz|3\#Clase anónima derivada de|4\#Tipo anotación|5\#Enum|6\#Record} no serializable <code>\#ref</code> define 'readObject()' y 'writeObject()' \#loc
non.serializable.class.with.readwriteobject.problem.descriptor.read={0, choice, 1\#Clase|2\#Interfaz|3\#Clase anónima derivada de|4\#Tipo anotación|5\#Enum|6\#Record} no serializable <code>\#ref</code> define 'readObject()' \#loc
non.serializable.class.with.readwriteobject.problem.descriptor.write={0, choice, 1\#Clase|2\#Interfaz|3\#Clase anónima derivada de|4\#Tipo anotación|5\#Enum|6\#Record} no serializable <code>\#ref</code> define 'writeObject()' \#loc
non.serializable.class.with.serialversionuid.problem.descriptor=Clase no serializable <code>\#ref</code> define un campo 'serialVersionUID' \#loc
non.serializable.component.in.serializable.record.problem.descriptor=Componente no serializable '\#ref' en record Serializable \#loc
non.serializable.field.in.serializable.class.display.name=Campo no serializable en clase 'Serializable'
non.serializable.field.in.serializable.class.problem.descriptor=Campo no serializable '\#ref' en clase Serializable \#loc
non.serializable.interface.with.serialversionuid.problem.descriptor=Interfaz no serializable <code>\#ref</code> define un campo 'serialVersionUID' \#loc
non.serializable.object.bound.to.http.session.display.name=Objeto no serializable vinculado a 'HttpSession'
non.serializable.object.bound.to.http.session.problem.descriptor=Objeto no serializable vinculado a HttpSession \#loc
non.serializable.object.passed.to.object.stream.display.name=Objeto no serializable pasado a 'ObjectOutputStream'
non.serializable.object.passed.to.object.stream.problem.descriptor=Objeto no serializable pasado a ObjectOutputStream \#loc
non.serializable.with.serialversionuid.display.name=Clase no serializable con 'serialVersionUID'
non.short.circuit.boolean.expression.display.name=Expresión booleana sin cortocircuito
non.short.circuit.boolean.expression.problem.descriptor=Expresión booleana sin cortocircuito <code>\#ref</code> \#loc
non.short.circuit.boolean.expression.replace.quickfix=Reemplazar con expresión de cortocircuito
non.synchronized.method.overrides.synchronized.method.display.name=Método no sincronizado sobrescribe método 'synchronized'
non.synchronized.method.overrides.synchronized.method.problem.descriptor=Método no sincronizado <code>\#ref()</code> sobrescribe método synchronized \#loc
non.thread.safe.lazy.initialization.display.name=Inicialización lazy no segura de campo 'static'
non.thread.safe.lazy.initialization.problem.descriptor=La inicialización lazy del campo 'static' <code>\#ref</code> no es thread-safe \#loc
none=ninguno
noop.method.in.abstract.class.display.name=Método sin operaciones en clase 'abstract'
noop.method.in.abstract.class.problem.descriptor=El método sin operaciones <code>\#ref()</code> debería ser abstract \#loc
normalize.declaration.quickfix=Dividir en declaraciones separadas
not.object.equals.can.be.equality.problem.descriptor=<code>\!\#ref()</code> puede ser reemplazado por '\!\='
notify.called.on.condition.display.name='notify()' o 'notifyAll()' llamado en objeto 'java.util.concurrent.locks.Condition'
notify.called.on.condition.problem.descriptor=Llamada a <code>\#ref()</code> en objeto Condition \#loc
notify.without.corresponding.wait.display.name='notify()' sin 'wait()' correspondiente
notify.without.corresponding.wait.problem.descriptor=Llamada a <code>\#ref()</code> sin <code>wait()</code> correspondiente \#loc
null.argument.to.var.arg.method.display.name=Argumento confuso para método varargs
null.argument.to.var.arg.method.problem.descriptor=Argumento confuso <code>\#ref</code>, no está claro si se desea una llamada varargs o no varargs \#loc
null.thrown.display.name='null' lanzado
null.thrown.problem.descriptor=<code>\#ref</code> lanzado \#loc
number.comparison.display.name=Comparación de números usando '\=\=' en lugar de 'equals()'
number.comparison.problem.descriptor=Los objetos Number se comparan usando <code>\#ref</code>, no 'equals()' \#loc
object.allocation.in.loop.display.name=Asignación de objeto en bucle
object.allocation.in.loop.new.descriptor=Asignación de objeto <code>new \#ref()</code> en bucle \#loc
object.allocation.in.loop.problem.array.initializer.descriptor=Asignación de array en bucle \#loc
object.allocation.in.loop.problem.call.descriptor=Asignación de objeto mediante llamada <code>\#ref()</code> en bucle \#loc
object.allocation.in.loop.problem.lambda.descriptor=Asignación de objeto mediante lambda de captura en bucle \#loc
object.allocation.in.loop.problem.methodref.descriptor=Asignación de objeto mediante referencia a método vinculado a instancia <code>\#ref()</code> en bucle \#loc
object.allocation.in.loop.problem.string.concat=Asignación de objeto mediante concatenación de strings en bucle \#loc
object.comparison.display.name=Comparación de objetos usando '\=\=' en lugar de 'equals()'
object.comparison.enumerated.ignore.option=Ignorar '\=\=' entre variables enum
object.comparison.klass.ignore.option=Ignorar '\=\=' entre tipos de clase final sin implementación de 'equals()'
object.comparison.problem.description=Los valores de objeto se comparan usando <code>\#ref</code>, no 'equals()' \#loc
object.equality.ignore.between.objects.of.a.type.with.only.private.constructors.option=Ignorar '\=\=' entre objetos de un tipo con solo constructores 'private'
object.equals.can.be.equality.display.name=La llamada a 'equals()' puede reemplazarse por '\=\='
object.equals.can.be.equality.problem.descriptor=<code>\#ref()</code> puede reemplazarse por '\=\='
object.instantiation.inside.equals.or.hashcode.display.name=Instanciación de objeto dentro de 'equals()' o 'hashCode()'
object.instantiation.inside.equals.or.hashcode.problem.descriptor=Instanciación de objeto dentro de ''{0}()'' \#loc
object.instantiation.inside.equals.or.hashcode.problem.descriptor2=Instanciación de objeto dentro de ''{0}()'' ({1})\#loc
object.notify.display.name=Llamada a 'notify()' en lugar de 'notifyAll()'
object.notify.problem.descriptor=<code>\#ref</code> probablemente debería reemplazarse con 'notifyAll()' \#loc
objects.hash.fix.family.name=Envolver con 'Arrays.hashCode()'
objects.hash.problem.descriptor=El array pasado a 'Objects.hash()' debe envolverse en 'Arrays.hashcode()'
octal.and.decimal.integers.in.same.array.display.name=Enteros octales y decimales en el mismo array
octal.and.decimal.integers.in.same.array.problem.descriptor=Enteros octales y decimales en el mismo inicializador de array \#loc
octal.literal.display.name=Entero octal
octal.literal.problem.descriptor=Entero octal <code>\#ref</code> \#loc
only.report.public.methods.option=Solo reportar métodos 'public'
only.report.qualified.static.usages.option=Solo reportar acceso estático calificado desde un contexto static
only.report.static.methods=S&olo reportar métodos 'static'
only.warn.on.protected.clone.methods=Solo advertir sobre métodos clone 'protected'
only.warn.on.public.clone.methods=Solo advertir sobre métodos clone 'public'
optional.contains.array.problem.descriptor='Optional' contiene array <code>\#ref</code>
optional.contains.collection.display.name='Optional' contiene array o colección
optional.contains.collection.problem.descriptor='Optional' contiene colección <code>\#ref</code>
optional.used.as.field.or.parameter.type.display.name='Optional' usado como tipo de campo o parámetro
optional.used.as.field.type.problem.descriptor=<code>\#ref</code> usado como tipo para el campo ''{0}''
optional.used.as.parameter.type.problem.descriptor=<code>\#ref</code> usado como tipo para el parámetro ''{0}''
options.label.ignored.classes=Clases ignoradas\:
options.title.ignored.classes=Clases Ignoradas
overloaded.methods.with.same.number.parameters.display.name=Métodos sobrecargados con el mismo número de parámetros
overloaded.methods.with.same.number.parameters.option=<html>Ignorar métodos sobrecargados cuyos tipos de parámetros son definitivamente incompatibles</html>
overloaded.methods.with.same.number.parameters.problem.descriptor=Múltiples métodos llamados <code>\#ref</code> con el mismo número de parámetros \#loc
overloaded.vararg.constructor.problem.descriptor=Constructor vararg sobrecargado <code>\#ref()</code> \#loc
overloaded.vararg.method.display.name=Método vararg sobrecargado
overloaded.vararg.method.problem.descriptor=Método vararg sobrecargado <code>\#ref()</code> \#loc
overloaded.vararg.method.problem.option=Ignorar métodos sobrecargados cuyos tipos de parámetros son definitivamente incompatibles
overly.broad.throws.clause.display.name=Cláusula 'throws' demasiado amplia
overly.broad.throws.clause.ignore.thrown.option=Ignorar excepciones que ocultan otras pero son lanzadas ellas mismas(&H)
overly.broad.throws.clause.problem.descriptor1=<code>throws \#ref</code> es demasiado amplia, enmascarando la excepción ''{0}'' \#loc
overly.broad.throws.clause.problem.descriptor2=<code>throws \#ref</code> es demasiado amplia, enmascarando las excepciones ''{0}'' y ''{1}'' \#loc
overly.broad.throws.clause.quickfix1=Agregar excepciones específicas
overly.broad.throws.clause.quickfix2=Reemplazar con excepciones específicas
overly.broad.throws.clause.threshold.option=Número máximo de excepciones ocultas a reportar\:
overly.complex.anonymous.inner.class.display.name=Clase anónima excesivamente compleja
overly.complex.anonymous.inner.class.problem.descriptor=Clase anónima excesivamente compleja (complejidad ciclomática \= {0}) \#loc
overly.complex.arithmetic.expression.display.name=Expresión aritmética excesivamente compleja
overly.complex.arithmetic.expression.max.number.option=Número máximo de términos\:
overly.complex.arithmetic.expression.problem.descriptor=Expresión aritmética excesivamente compleja \#loc
overly.complex.boolean.expression.display.name=Expresión booleana excesivamente compleja
overly.complex.boolean.expression.ignore.option=Ignorar conjunciones y disyunciones puras
overly.complex.boolean.expression.max.terms.option=Número máximo de términos\:
overly.complex.boolean.expression.problem.descriptor=Expresión booleana excesivamente compleja ({0} términos) \#loc
overly.complex.class.display.name=Clase excesivamente compleja
overly.complex.class.problem.descriptor=Clase excesivamente compleja <code>\#ref</code> (complejidad ciclomática \= {0}) \#loc
overly.coupled.class.class.coupling.limit.option=Límite de acoplamiento de clase\:
overly.coupled.class.display.name=Clase excesivamente acoplada
overly.coupled.class.problem.descriptor=<code>\#ref</code> está excesivamente acoplada (dependencias \= {0}) \#loc
overly.long.lambda.display.name=Expresión lambda demasiado larga
overly.long.lambda.problem.descriptor=La expresión lambda es demasiado larga (\# Declaraciones de código no comentadas \= {0}) \#loc
overly.strong.type.cast.display.name=Cast de tipo excesivamente fuerte
overly.strong.type.cast.ignore.in.matching.instanceof.option=Ignorar casts con una expresión instanceof coincidente
overly.strong.type.cast.problem.descriptor=El cast a <code>\#ref</code> puede debilitarse a ''{0}'' \#loc
overly.strong.type.cast.weaken.quickfix=Debilitar cast excesivamente fuerte
overridable.method.call.in.constructor.display.name=Método sobreescribible llamado durante la construcción del objeto
overridable.method.call.in.constructor.problem.descriptor=Llamada al método sobreescribible <code>\#ref()</code> durante la construcción del objeto \#loc
overridden.method.call.in.constructor.display.name=Método sobreescrito llamado durante la construcción del objeto
overridden.method.call.in.constructor.problem.descriptor=Llamada al método sobreescrito <code>\#ref()</code> durante la construcción del objeto \#loc
package.dot.html.may.be.package.info.convert.quickfix=Convertir a 'package-info.java'
package.dot.html.may.be.package.info.delete.quickfix=Eliminar 'package.html'
package.dot.html.may.be.package.info.display.name='package.html' puede convertirse a 'package-info.java'
package.dot.html.may.be.package.info.exists.problem.descriptor=<code>package.html</code> se ignora porque existe <code>package-info.java</code>
package.dot.html.may.be.package.info.problem.descriptor=<code>package.html</code> puede convertirse a <code>package-info.java</code>
package.in.multiple.modules.display.name=Paquete con clases en múltiples módulos
package.in.multiple.modules.problem.descriptor.many=El paquete ''{0}'' tiene clases en los módulos ''{1}'', ''{2}'' y otros {3} módulos
package.in.multiple.modules.problem.descriptor2=El paquete ''{0}'' tiene clases en los módulos ''{1}'' y ''{2}''
package.in.multiple.modules.problem.descriptor3=El paquete ''{0}'' tiene clases en los módulos ''{1}'', ''{2}'' y ''{3}''
package.info.java.without.package.display.name='package-info.java' sin declaración 'package'
package.info.without.package.family.quickfix=Agregar declaración package
package.info.without.package.problem.descriptor='package-info.java' no tiene una declaración 'package'
package.info.without.package.quickfix=Agregar ''package {0};''
package.local.field.not.accessible=El campo package-private ''{0}'' no es accesible desde aquí
package.local.private=package-private y private
package.naming.convention.display.name=Convención de nomenclatura de paquetes
package.naming.convention.problem.descriptor.long=El nombre del paquete <code>{0}</code> es demasiado largo
package.naming.convention.problem.descriptor.regex.mismatch=El nombre del paquete <code>{0}</code> no coincide con la expresión regular ''{1}''
package.naming.convention.problem.descriptor.short=El nombre del paquete <code>{0}</code> es demasiado corto
package.visible.field.display.name=Campo visible a nivel de paquete
package.visible.field.problem.descriptor=Campo visible a nivel de paquete <code>\#ref</code> \#loc
package.visible.inner.class.display.name=Clase anidada visible a nivel de paquete
package.visible.inner.class.ignore.enum.option=Ignorar enums internos visibles a nivel de paquete
package.visible.inner.class.ignore.interface.option=Ignorar interfaces internas visibles a nivel de paquete
package.visible.inner.class.problem.descriptor=Clase anidada visible a nivel de paquete <code>\#ref</code> \#loc
package.with.too.few.classes.display.name=Paquete con muy pocas clases
package.with.too.few.classes.min.option=Número mínimo de clases\:
package.with.too.few.classes.problem.descriptor=El paquete ''{0}'' contiene muy pocas clases ({1} < {2})
package.with.too.many.classes.display.name=Paquete con demasiadas clases
package.with.too.many.classes.max.option=Número máximo de clases\:
package.with.too.many.classes.problem.descriptor=El paquete ''{0}'' contiene demasiadas clases ({1} > {2})
parameter.hides.member.variable.display.name=Parámetro oculta campo
parameter.hides.member.variable.ignore.abstract.methods.option=Ignorar para métodos abstract
parameter.hides.member.variable.ignore.constructors.option=Ignorar para constructores
parameter.hides.member.variable.ignore.setters.option=Ignorar para setters de propiedades
parameter.hides.member.variable.ignore.static.parameters.option=Ignorar para parámetros de métodos static que ocultan campos de instancia
parameter.hides.member.variable.ignore.superclass.option=Ignorar campos de superclase no visibles desde subclase
parameter.hides.member.variable.problem.descriptor=Parámetro <code>\#ref</code> oculta campo en la clase ''{0}'' \#loc
parameter.limit.option=Límite de parámetros\:
parameter.name.differs.from.overridden.parameter.display.name=Nombre de parámetro difiere del parámetro en método sobreescrito o sobrecargado
parameter.name.differs.from.overridden.parameter.ignore.character.option=Ignorar si el parámetro sobreescrito contiene solo un carácter
parameter.name.differs.from.overridden.parameter.ignore.library.option=Ignorar si el parámetro sobreescrito es de una biblioteca
parameter.name.differs.from.overridden.parameter.problem.descriptor=Nombre de parámetro <code>\#ref</code> es diferente del parámetro ''{0}'' en el {1, choice, 1\#método super|2\#método sobrecargado|3\#constructor super|4\#constructor sobrecargado} \#loc
parameter.naming.convention.display.name=Convención de nombres de parámetros de método
parameter.naming.convention.element.description=Parámetro
parameter.type.prevents.overriding.display.name=Tipo de parámetro impide sobreescritura
parameter.type.prevents.overriding.family.quickfix=Cambiar tipo de parámetro
parameter.type.prevents.overriding.problem.descriptor=Tipo de parámetro <code>\#ref</code> está ubicado en ''{0}'' mientras que el tipo de parámetro del método super está ubicado en ''{1}'' impidiendo la sobreescritura \#loc
parameter.type.prevents.overriding.quickfix=Cambiar tipo de parámetro a ''{0}''
parameters.per.constructor.display.name=Constructor con demasiados parámetros
parameters.per.constructor.problem.descriptor=<code>\#ref()</code> tiene demasiados parámetros (número de parámetros \= {0}) \#loc
parameters.per.method.display.name=Método con demasiados parámetros
parameters.per.method.problem.descriptor=<code>\#ref()</code> tiene demasiados parámetros (número de parámetros \= {0}) \#loc
pattern.variable.hides.field.display.name=Variable de patrón oculta campo
pattern.variable.hides.field.problem.descriptor=Variable de patrón <code>\#ref</code> oculta campo en la clase ''{0}'' \#loc
pointless.arithmetic.expression.display.name=Expresión aritmética sin sentido
pointless.bitwise.expression.display.name=Expresión bit a bit sin sentido
pointless.bitwise.expression.simplify.quickfix=Simplificar
pointless.boolean.expression.display.name=Expresión booleana sin sentido
pointless.boolean.expression.ignore.option=Ignorar constantes con nombre al determinar expresiones sin sentido
pointless.indexof.comparison.always.false.problem.descriptor=<code>\#ref</code> es siempre false \#loc
pointless.indexof.comparison.always.true.problem.descriptor=<code>\#ref</code> es siempre true \#loc
pointless.indexof.comparison.display.name=Comparación 'indexOf()' sin sentido
pointless.nullcheck.display.name=Comprobación 'null' innecesaria antes de llamada a método
pointless.nullcheck.problem.descriptor.call=Comprobación ''null'' innecesaria antes de llamada a ''{0}()''
possible.throw.from.finally.block.problem.descriptor=<code>{0}</code> podría ser lanzado dentro del bloque ''finally'' \#loc
prefer.empty.array.options.mode.always=Siempre
prefer.empty.array.options.mode.always.never=Nunca (preferir array predimensionado)
prefer.empty.array.options.mode.by.level=Según nivel de lenguaje
prefer.empty.array.options.title=Preferir array vacío\:
prefix.operation.quickfix.family.name=Reemplazar con operador prefijo
press.escape.to.remove.highlighting.message=Presione Escape para quitar el resaltado
primitive.array.argument.to.var.arg.method.display.name=Argumento de array primitivo confuso para método varargs
primitive.array.argument.to.var.arg.method.problem.descriptor=Argumento de array primitivo confuso para método varargs \#loc
primitive.fields.ignore.option=Ignorar campos primitivos
printstacktrace.call.display.name=Llamada a 'printStackTrace()'
printstacktrace.call.problem.descriptor=La llamada a <code>\#ref()</code> probablemente debería reemplazarse con logging más robusto \#loc
private=private
private.field.not.accessible.problem.descriptor=Campo ''private'' ''{0}'' no es accesible desde aquí
private.member.access.between.outer.and.inner.classes.display.name=Llamada a accessor sintético
private.member.access.between.outer.and.inner.classes.make.constructor.package.local.quickfix=Hacer constructor ''{0}'' package-private
private.member.access.between.outer.and.inner.classes.make.local.quickfix=Hacer ''{0}'' package-private
private.member.access.between.outer.and.inner.classes.problem.descriptor=El acceso al miembro 'private' de la clase ''{0}'' requiere accessor sintético \#loc
problematic.varargs.method.display.name=Método no varargs sobreescribe método varargs
problematic.varargs.method.override.problem.descriptor=Método no varargs <code>\#ref()</code> sobreescribe método varargs \#loc
progress.text.analyzing.package.0=Analizando paquete {0}
properties.object.as.hashtable.display.name=Uso de objeto 'Properties' como 'Hashtable'
properties.object.as.hashtable.problem.descriptor=Llamada a <code>Hashtable.\#ref()</code> en objeto properties \#loc
property.value.set.to.itself.display.name=Valor de propiedad establecido a sí mismo
protected.field.display.name=Campo protected
protected.field.not.accessible.problem.descriptor=Campo ''protected'' ''{0}'' no es accesible desde aquí
protected.field.problem.descriptor=Campo protected <code>\#ref</code> \#loc
protected.inner.class.display.name=Clase anidada protected
protected.inner.class.ignore.enum.option=Ignorar enums internos 'protected'
protected.inner.class.ignore.interface.option=Ignorar interfaces internas 'protected'
protected.inner.class.problem.descriptor=Clase anidada protected <code>\#ref</code> \#loc
protected.member.in.final.class.display.name=Miembro 'protected' en clase 'final'
protected.member.in.final.class.problem.descriptor=Miembro de clase declarado <code>\#ref</code> en clase 'final' \#loc
protected.package.local.private=protected, package-private y private
public.constructor.display.name=Constructor 'public' puede ser reemplazado con método factory
public.constructor.in.non.public.class.display.name=Constructor 'public' en clase no public
public.constructor.in.non.public.class.problem.descriptor=Constructor declarado <code>\#ref</code> en clase no public ''{0}'' \#loc
public.constructor.in.non.public.class.quickfix=Hacer constructor private
public.constructor.problem.descriptor=Constructor public <code>\#ref()</code> \#loc
public.constructor.quickfix=Reemplazar constructor con método factory
public.default.constructor.problem.descriptor=La clase <code>\#ref</code> tiene constructor 'public' por defecto
public.field.accessed.in.synchronized.context.display.name=Campo no private accedido en contexto 'synchronized'
public.field.accessed.in.synchronized.context.problem.descriptor=Campo no private <code>\#ref</code> accedido en contexto sincronizado \#loc
public.field.display.name=Campo 'public'
public.field.ignore.enum.type.fields.option=Ignorar campos 'public final' de tipo enum
public.field.problem.descriptor=Campo 'public' <code>\#ref</code> \#loc
public.inner.class.display.name=Clase anidada 'public'
public.inner.class.ignore.enum.option=Ignorar enums internos 'public'
public.inner.class.ignore.interface.option=Ignorar interfaces internas 'public'
public.inner.class.problem.descriptor=Clase anidada 'public' <code>\#ref</code> \#loc
public.method.not.in.interface.display.name=Método 'public' no expuesto en interfaz
public.method.not.in.interface.option=<html>Ignorar si la clase contenedora no implementa una interfaz no perteneciente a biblioteca</html>
public.method.not.in.interface.problem.descriptor=Método 'public' <code>\#ref()</code> no está expuesto a través de una interfaz \#loc
public.method.without.logging.display.name=Método 'public' sin logging
public.method.without.logging.problem.descriptor=Método 'public' <code>\#ref()</code> no tiene llamada de logging \#loc
public.static.array.field.display.name=Campo array 'public static'
public.static.array.field.problem.descriptor=Campo array 'public static' <code>\#ref</code>, comprometiendo la seguridad \#loc
public.static.collection.field.display.name=Campo collection 'public static'
public.static.collection.field.problem.descriptor=Campo collection 'public static' <code>\#ref</code>, comprometiendo la seguridad \#loc
qualify.call.fix.family.name=Calificar llamada
query.label=Los nombres de consulta comienzan con\:
questionable.name.display.name=Nombre cuestionable
questionable.name.list.label=Nombres reportados\:
questionable.name.problem.descriptor=Nombre cuestionable <code>\#ref</code> \#loc
random.double.for.random.integer.display.name=Uso de 'Random.nextDouble()' para obtener entero aleatorio
random.double.for.random.integer.problem.descriptor=Uso de <code>Random.\#ref</code> para crear entero aleatorio \#loc
raw.use.of.parameterized.type.display.name=Uso raw de clase parametrizada
readobject.initialization.display.name=Campo de instancia puede no ser inicializado por 'readObject()'
readobject.initialization.problem.descriptor=El campo de instancia <code>\#ref</code> puede no estar inicializado durante la llamada a 'readObject()' \#loc
readresolve.writereplace.protected.display.name='readResolve()' o 'writeReplace()' no declarado como 'protected'
readresolve.writereplace.protected.problem.descriptor=<code>\#ref()</code> no declarado como 'protected' \#loc
readwriteobject.private.display.name='readObject()' o 'writeObject()' no declarado como 'private'
readwriteobject.private.problem.descriptor=<code>\#ref</code> no declarado como 'private' \#loc
recordstore.opened.not.safely.closed.display.name='RecordStore' abierto pero no cerrado de forma segura
redundant.as.list.for.iteration.fix.name=Desenvolver
redundant.as.list.for.iteration.problem=Llamada innecesaria a 'Arrays.asList()'
redundant.call.problem.descriptor=Llamada redundante a <code>\#ref()</code> \#loc
redundant.else.display.name='else' redundante
redundant.else.problem.descriptor=La rama <code>\#ref</code> puede ser desenvuelta, ya que la rama 'if' nunca se completa normalmente \#loc
redundant.else.unwrap.quickfix=Eliminar 'else' redundante
redundant.escape.in.regex.replacement.display.name=Escape redundante en cadena de reemplazo regex
redundant.escape.in.regex.replacement.problem.descriptor=Escape redundante de ''{0}''
redundant.escape.in.regex.replacement.quickfix=Eliminar escape redundante
redundant.explicit.var.type.display.name=El tipo de variable local puede omitirse
redundant.field.initialization.display.name=Inicialización de campo redundante
redundant.field.initialization.problem.descriptor=La inicialización del campo a <code>\#ref</code> es redundante \#loc
redundant.field.initialization.remove.quickfix=Eliminar inicializador
redundant.implements.display.name=Declaración de interfaz redundante
redundant.implements.problem.descriptor=Declaración de interfaz redundante <code>\#ref</code> \#loc
redundant.implements.remove.quickfix=Eliminar declaración de interfaz redundante
redundant.local.variable.annotation.option=Ignorar variables que tienen una anotación
redundant.local.variable.display.name=Variable local redundante
redundant.local.variable.ignore.option=Ignorar variables retornadas o lanzadas inmediatamente
redundant.method.override.delegate.quickfix=Reemplazar método con delegado a super
redundant.method.override.delegates.to.super.problem.descriptor=El método <code>\#ref()</code> solo delega a su método super \#loc
redundant.method.override.display.name=El método es idéntico a su método super
redundant.method.override.option.check.library.methods=Verificar métodos que sobrescriben métodos de library
redundant.method.override.option.ignore.delegates=Ignorar delegados a métodos super
redundant.method.override.problem.descriptor=El método <code>\#ref()</code> es idéntico a su método super \#loc
redundant.method.override.quickfix=Eliminar método redundante
redundant.string.format.call.display.name=Llamada redundante a 'String.format()'
redundant.string.format.call.quickfix=Eliminar llamada redundante a 'String.format()'
redundant.string.formatted.call.quickfix=Eliminar llamada redundante a 'String.formatted()'
referencing.subclass.0.from.superclass.1.initializer.might.lead.to.class.loading.deadlock=Referenciar la subclase {0} desde el inicializador de la superclase {1} podría llevar a un deadlock de carga de clase
reflection.for.unavailable.annotation.display.name=Acceso reflexivo a una anotación solo de fuente
reflection.for.unavailable.annotation.problem.descriptor=La anotación '\#ref' no se retiene para acceso reflexivo \#loc
refused.bequest.display.name=El método no llama al método super
refused.bequest.fix.family.name=Insertar llamada al método super
refused.bequest.ignore.default.super.methods.option=Ignorar métodos super 'default'
refused.bequest.ignore.empty.super.methods.option=Ignorar métodos super vacíos
refused.bequest.problem.descriptor=El método <code>\#ref()</code> no llama a 'super.\#ref()' \#loc
remove.annotation.parameter.0.fix.name=Eliminar parámetro de anotación ''{0}''
remove.call.fix.family.name=Eliminar llamada
remove.cloneable.quickfix=Eliminar 'Cloneable' de la cláusula 'implements'
remove.finally.block.quickfix=Eliminar bloque 'finally'
remove.leading.zero.to.make.decimal.quickfix=Eliminar cero inicial para hacer decimal
remove.leading.zeroes.to.make.decimals.quickfix=Eliminar ceros iniciales para hacer decimales
remove.loop.fix.family.name=Eliminar bucle
remove.modifier.fix.family.name=Eliminar modificador
remove.modifier.quickfix=Eliminar modificador ''{0}''
remove.redundant.polyadic.operand.fix.family.name=Eliminar condición innecesaria
remove.redundant.polyadic.operand.fix.name=Eliminar condición innecesaria ''{0}''
remove.redundant.string.fix.text=Usar ''{0}()'' y eliminar llamada redundante a ''{1}()''
remove.redundant.substring.fix.family.name=Eliminar llamada redundante a 'substring()'
remove.try.finally.block.quickfix=Eliminar bloque 'try-finally'
remove.unnecessary.0.call.quickfix=Eliminar llamada innecesaria a ''{0}()''
rename.quickfix=Renombrar
renameto.quickfix=Renombrar a ''{0}''
replace.all.dot.display.name=Argumento de expresión regex sospechoso
replace.all.dot.problem.descriptor=Expresión regex sospechosa \#ref en llamada a ''{0}()'' \#loc
replace.all.dot.quickfix=Escapar metacarácter regex
replace.all.file.separator.problem.descriptor=File.separator se usa como regex; no funcionará en Windows
replace.anonymous.with.lambda.body.fix.family.name=Reemplazar llamada con cuerpo del método
replace.case.default.null.with.null.default=Reemplazar 'case default, null' con 'case null, default'
replace.case.default.with.default=Reemplazar 'case default' con 'default'
replace.cast.fix.family.name=Reemplazar tipo de cast
replace.casted.literal.with.just.literal.fix.family.name=Reemplazar con literal {0}
replace.field.reference.fix.family.name=Reemplazar referencia de campo
replace.field.reference.fix.text=Reemplazar referencia de campo con ''{0}''
replace.inheritance.with.delegation.quickfix=Reemplazar herencia con delegación
replace.instanceof.fix.family.name=Reemplazar tipo instanceOf
replace.method.call.fix.family.name=Reemplazar llamada a método
replace.method.call.fix.text=Reemplazar llamada a método con ''{0}''
replace.method.ref.with.qualifier.fix.family.name=Reemplazar con calificador
replace.method.ref.with.qualifier.problem.lambda=Lambda puede reemplazarse con calificador de llamada
replace.method.ref.with.qualifier.problem.method=La referencia a método puede reemplazarse con calificador
replace.with.cast.fix.family.name=Reemplazar con cast
replace.with.catch.clause.for.runtime.exception.quickfix=Reemplazar con cláusula 'catch' para 'RuntimeException'
replace.with.comparator.fix.family.name=Simplificar comparador usando métodos static de 'Comparator'
replace.with.lambda.body.fix.family.name=Reemplazar llamada a método en lambda con cuerpo lambda
replace.with.method.ref.fix.family.name=Reemplazar lambda con referencia a método
replace.with.method.ref.fix.name.may.change.semantics=Reemplazar lambda con referencia a método (puede cambiar la semántica)
replace.with.method.reference.fix.family.name=Reemplazar llamada a método en referencia a método con llamada a método correspondiente
replace.with.var.fix.family.name=Reemplazar tipo explícito con 'var'
resource.opened.not.closed.problem.descriptor=''{0}'' debe abrirse antes de un bloque ''try'' y cerrarse en el bloque ''finally'' correspondiente \#loc
result.of.method.call.ignored.class.column.title=Nombre de clase
result.of.method.call.ignored.display.name=Resultado de llamada a método ignorado
result.of.method.call.ignored.non.library.option=Reportar todas las llamadas no-library ignoradas
result.of.method.call.ignored.problem.descriptor=El resultado de <code>{0}.\#ref()</code> está ignorado \#loc
result.of.object.allocation.fix.name=Ignorar asignaciones de objetos con tipo ''{0}''
result.of.object.allocation.ignored.display.name=Resultado de asignación de objeto ignorado
result.of.object.allocation.ignored.options.chooserTitle=Elegir clase para la cual se puede ignorar la asignación de objetos
result.of.object.allocation.ignored.problem.descriptor=El resultado de <code>new \#ref()</code> está ignorado \#loc
result.of.object.allocation.ignored.problem.descriptor.methodRef=El objeto asignado dentro de <code>\#ref</code> es descartado \#loc
return.from.finally.block.display.name='return' dentro del bloque 'finally'
return.from.finally.block.problem.descriptor='return' dentro del bloque 'finally' \#loc
return.of.anonymous.class.problem.descriptor=Retorno de instancia de clase anónima \#loc
return.of.collection.field.fix.family.name=Hacer que la colección retornada sea 'unmodifiable'
return.of.field.with.mutable.type.problem.descriptor=Retorno de campo {0} <code>{1}</code> \#loc
return.of.inner.class.display.name=Retorno de instancia de clase anónima, local o interna
return.of.inner.class.ignore.non.public.option=Ignorar retornos de métodos no public
return.of.inner.class.problem.descriptor=Retorno de instancia de clase interna no static <code>{0}</code> \#loc
return.of.local.class.problem.descriptor=Retorno de instancia de clase local <code>{0}</code> \#loc
return.of.null.arrays.option=Reportar métodos que retornan arrays
return.of.null.collections.option=Reportar métodos que retornan objetos de colección
return.of.null.display.name=Retorno de 'null'
return.of.null.ignore.private.option=Ignorar métodos 'private', clases anónimas y lambdas
return.of.null.objects.option=Reportar métodos que retornan objetos
return.of.null.problem.descriptor=Retorno de <code>\#ref</code> \#loc
return.point.limit.option=&Límite de puntos de retorno\:
return.this.display.name=Retorno de 'this'
return.this.problem.descriptor=Retorno de <code>\#ref</code> \#loc
reuse.of.local.variable.display.name=Reutilización de variable local
reuse.of.local.variable.problem.descriptor=Reutilización de variable local <code>\#ref</code> \#loc
reuse.of.local.variable.split.quickfix=Dividir variable local
runtime.exec.call.display.name=Llamada a 'Runtime.exec()'
runtime.exec.call.problem.descriptor=La llamada a <code>Runtime.\#ref()</code> no es portable \#loc
runtime.exec.with.non.constant.string.display.name=Llamada a 'Runtime.exec()' con string no constante
runtime.exec.with.non.constant.string.problem.descriptor=Llamada a <code>Runtime.\#ref()</code> con argumento no constante \#loc
safe.lock.display.name=Lock adquirido pero no liberado de forma segura
safe.lock.problem.descriptor=''{0}'' debe ser bloqueado antes de un bloque ''try'' y desbloqueado en el bloque ''finally'' correspondiente \#loc
serial.annotation.used.on.wrong.member.display.name=Anotación '@Serial' usada en miembro incorrecto
serial.annotation.used.on.wrong.member.problem.descriptor=El miembro anotado no es parte del mecanismo de serialización
serializable.anonymous.class.stores.non.serializable.problem.descriptor=Clase anónima serializable almacena implícitamente objeto no serializable de tipo ''{0}''
serializable.class.in.secure.context.display.name=Clase serializable en contexto seguro
serializable.class.in.secure.context.problem.descriptor=La clase <code>\#ref</code> puede ser serializada, comprometiendo la seguridad \#loc
serializable.deserializable.class.in.secure.context.problem.descriptor=La clase <code>\#ref</code> puede ser serializada y deserializada, comprometiendo la seguridad \#loc
serializable.has.serialization.methods.display.name=Clase serializable sin 'readObject()' y 'writeObject()'
serializable.has.serialization.methods.ignore.option=Ignorar clases que no definen campos de instancia
serializable.has.serialization.methods.problem.descriptor=La clase serializable <code>\#ref</code> no define 'readObject()' o 'writeObject()' \#loc
serializable.has.serialization.methods.problem.descriptor1=La clase serializable <code>\#ref</code> no define 'writeObject()' \#loc
serializable.has.serialization.methods.problem.descriptor2=La clase serializable <code>\#ref</code> no define 'readObject()' \#loc
serializable.inner.class.has.serial.version.uid.field.display.name=Clase interna no static serializable sin 'serialVersionUID'
serializable.inner.class.has.serial.version.uid.field.problem.descriptor=La clase interna <code>\#ref</code> no define un campo 'serialVersionUID' \#loc
serializable.inner.class.with.non.serializable.outer.class.display.name=Clase interna no 'static' serializable con clase externa no serializable
serializable.inner.class.with.non.serializable.outer.class.problem.descriptor=La clase interna <code>\#ref</code> es serializable mientras que su clase externa no lo es \#loc
serializable.lambda.stores.non.serializable.problem.descriptor=Lambda serializable almacena implícitamente objeto no serializable de tipo ''{0}''
serializable.local.class.stores.non.serializable.problem.descriptor=Clase local serializable ''{1}'' almacena implícitamente objeto no serializable de tipo ''{0}''
serializable.record.contains.ignored.field.problem.descriptor=<code>\#ref</code> será ignorado durante la serialización del record
serializable.record.contains.ignored.members.display.name='record' contiene miembros ignorados
serializable.record.contains.ignored.method.problem.descriptor=<code>\#ref()</code> será ignorado durante la serialización del record
serializable.stores.non.serializable.display.name=Objeto 'Serializable' almacena implícitamente objeto no 'Serializable'
serializable.with.unconstructable.ancestor.display.name=Clase serializable con ancestro no construible
serializable.with.unconstructable.ancestor.problem.descriptor=<code>\#ref</code> tiene un ancestro no serializable ''{0}'' sin constructor sin argumentos \#loc
serialpersistentfields.with.wrong.signature.display.name=Campo 'serialPersistentFields' no declarado como 'private static final ObjectStreamField[]'
serialpersistentfields.with.wrong.signature.problem.descriptor=El campo <code>\#ref</code> de una clase Serializable no está declarado como 'private static final ObjectStreamField[]' \#loc
serialversionuid.private.static.final.long.display.name=Campo 'serialVersionUID' no declarado como 'private static final long'
serialversionuid.private.static.final.long.problem.descriptor=El campo <code>\#ref</code> de una clase Serializable no está declarado como 'private static final long' \#loc
serialversionuid.private.static.final.long.quickfix=Hacer serialVersionUID 'private static final'
set.annotation.parameter.0.1.fix.name=Establecer parámetro de anotación {0} \= "{1}"
set.replaceable.by.enum.set.display.name='Set' puede ser reemplazado por 'EnumSet'
set.replaceable.by.enum.set.problem.descriptor=<code>\#ref</code> puede ser reemplazado por 'EnumSet' \#loc
shared.thread.local.random.display.name=La instancia de 'ThreadLocalRandom' podría ser compartida
shared.thread.local.random.problem.descriptor=La instancia de 'ThreadLocalRandom' podría ser compartida entre hilos
shift.operation.by.inappropriate.constant.display.name=Operación de desplazamiento por constante inapropiada
shift.operation.by.inappropriate.constant.problem.descriptor.negative=Operación de desplazamiento <code>\#ref</code> por valor de constante negativo {0} \#loc
shift.operation.by.inappropriate.constant.problem.descriptor.out.of.bounds=Operación de desplazamiento <code>\#ref</code> por valor fuera de rango {0}\#loc
shift.operation.by.inappropriate.constant.problem.descriptor.too.large=Operación de desplazamiento <code>\#ref</code> por valor de constante demasiado grande {0} \#loc
shift.out.of.range.fix.family.name=Corregir valor de desplazamiento
side.effects.method.ref.to.lambda.fix.family.name={0} (efectos secundarios)
signal.without.corresponding.await.display.name='signal()' sin 'await()' correspondiente
signal.without.corresponding.await.problem.descriptor=Llamada a <code>\#ref()</code> sin <code>await()</code> correspondiente \#loc
simplifiable.annotation.braces.problem.descriptor=Llaves innecesarias alrededor de <code>{0}</code> en anotación \#loc
simplifiable.annotation.display.name=Anotación simplificable
simplifiable.annotation.problem.descriptor=<code>\#ref</code> innecesario en anotación \#loc
simplifiable.annotation.quickfix=Simplificar anotación
simplifiable.annotation.whitespace.problem.descriptor=Espacio en blanco innecesario en anotación \#loc
simplifiable.boolean.expression.display.name=Expresión booleana simplificable
simplifiable.conditional.expression.display.name=Expresión condicional simplificable
simplifiable.conditional.expression.problem.descriptor=<code>{1}</code> puede simplificarse a ''{0}'' \#loc
simplifiable.equals.expression.display.name=Comprobación 'null' innecesaria antes de llamada a 'equals()'
simplifiable.equals.expression.option.non.constant=Reportar equals con argumento no nulo no constante
simplifiable.equals.expression.problem.descriptor=Comprobación ''null'' innecesaria antes de llamada a ''{0}()'' \#loc
simplifiable.equals.expression.quickfix=Invertir ''.{0}()'' y eliminar comprobación ''null'' innecesaria
simplifiable.junit.assertion.display.name=Aserción simplificable
simplifiable.junit.assertion.problem.descriptor=<code>\#ref()</code> puede simplificarse a ''{0}'' \#loc
simplify.junit.assertion.simplify.quickfix=Simplificar aserción
single.character.startswith.display.name='startsWith()' o 'endsWith()' de un solo carácter
single.character.startswith.problem.descriptor=<code>\#ref()</code> de un solo carácter puede reemplazarse con expresión 'charAt()' \#loc
single.character.startswith.quickfix=Reemplazar con expresión 'charAt()'
single.class.import.display.name=Importación de clase única
single.class.import.problem.descriptor=Importación de clase única <code>\#ref</code> \#loc
single.element.annotation.family.quickfix=Expandir anotación a forma normal
single.element.annotation.name=Anotación no normalizada
single.element.annotation.quickfix=Agregar 'value\='
single.statement.in.block.descriptor=''{0}'' contiene una única sentencia
single.statement.in.block.family.quickfix=Eliminar llaves de la sentencia
single.statement.in.block.name=Bloque de código contiene una única sentencia
single.statement.in.block.quickfix=Eliminar llaves de la sentencia ''{0}''
singleton.display.name=Singleton
singleton.problem.descriptor=La clase <code>\#ref</code> es un singleton \#loc
size.replaceable.by.isempty.display.name='size() \=\= 0' puede reemplazarse por 'isEmpty()'
size.replaceable.by.isempty.fix.ignore.calls=Ignorar llamadas ''.{0}()'' en tipo ''{1}''
size.replaceable.by.isempty.negation.ignore.option=Ignorar expresiones que serían reemplazadas por '\!isEmpty()'
sleep.while.holding.lock.display.name=Llamada a 'Thread.sleep()' durante sincronización
sleep.while.holding.lock.problem.descriptor=Llamada a <code>Thread.\#ref()</code> durante sincronización \#loc
smth.unnecessary.remove.quickfix=Eliminar ''{0}'' innecesario
socket.opened.not.closed.display.name=Socket abierto pero no cerrado de forma segura
standard.variable.names.display.name=Nombres de variables estándar
standard.variable.names.ignore.override.option=Ignorar nombres de parámetros idénticos a los parámetros del método super
standard.variable.names.problem.descriptor=La variable nombrada <code>\#ref</code> no tiene el tipo ''{0}'' \#loc
standard.variable.names.problem.descriptor2=La variable nombrada <code>\#ref</code> no tiene el tipo ''{0}'' ni ''{1}'' \#loc
statement.problem.descriptor=Sentencia <code>\#ref</code> \#loc
statement.with.empty.body.display.name=Sentencia con cuerpo vacío
statement.with.empty.body.include.option=Incluir cuerpos de sentencias que son bloques de código vacíos
statement.with.empty.body.problem.descriptor=La sentencia <code>\#ref</code> tiene un cuerpo vacío \#loc
static.collection.display.name=Colección static
static.collection.ignore.option=Ignorar colecciones o mapas static débiles
static.collection.problem.descriptor=Colección static <code>\#ref</code> \#loc
static.field.via.subclass.display.name=Campo static referenciado a través de subclase
static.field.via.subclass.problem.descriptor=Campo static <code>\#ref</code> declarado en la clase ''{0}'' pero referenciado a través de la subclase ''{1}'' \#loc
static.field.via.subclass.rationalize.quickfix=Racionalizar acceso a campo static
static.import.display.name=Import static
static.import.fix.ignore.class=Permitir imports static para la clase ''{0}''
static.import.options.border.title=Clases importables estáticamente\:
static.import.options.chooserTitle=Elegir Clase Importable Estáticamente
static.import.problem.descriptor=Import static <code>\#ref</code> \#loc
static.import.replace.quickfix=Reemplazar con import no static
static.inheritance.display.name=Herencia static
static.inheritance.fix.family.name=Reemplazar herencia con referencia calificada
static.inheritance.problem.descriptor=La interfaz <code>\#ref</code> está implementada solo para sus constantes static \#loc
static.inheritance.replace.quickfix=Reemplazar herencia con referencias calificadas en {0}
static.initializer.references.subclass.display.name=El inicializador static referencia a subclase
static.method.naming.convention.element.description=Método 'static'
static.method.only.used.in.one.anonymous.class.problem.descriptor=El {0, choice, 1\#método|2\#campo} static <code>\#ref{0, choice, 1\#()|2\#}</code> solo se usa desde una clase anónima derivada de ''{1}'' \#loc
static.method.only.used.in.one.class.display.name=Miembro static usado solo desde otra clase
static.method.only.used.in.one.class.ignore.anonymous.option=Ignorar cuando solo se usa desde una clase anónima
static.method.only.used.in.one.class.ignore.on.conflicts=Ignorar cuando el método no puede moverse sin conflictos
static.method.only.used.in.one.class.ignore.test.option=Ignorar cuando solo se usa desde una clase de test
static.method.only.used.in.one.class.ignore.utility.classes=Ignorar miembros ubicados en clases de utilidad
static.method.only.used.in.one.class.problem.descriptor=El {0, choice, 1\#método|2\#campo} static <code>\#ref{0, choice, 1\#()|2\#}</code> solo se usa desde la clase ''{1}'' \#loc
static.method.only.used.in.one.class.quickfix=Mover {0} a la clase de uso
static.method.only.used.in.one.class.quickfix.preview=Mueve el miembro static a la clase donde se usa.
static.method.via.subclass.display.name=Método static referenciado a través de subclase
static.method.via.subclass.problem.descriptor=Método static <code>\#ref()</code> declarado en la clase ''{0}'' pero referenciado a través de la subclase ''{1}'' \#loc
static.method.via.subclass.rationalize.quickfix=Racionalizar llamada a método static
static.non.final.field.display.name=Campo 'static', no 'final'
static.non.final.field.option=Solo reportar campos 'public'
static.non.final.field.problem.descriptor=Campo 'static' no 'final' <code>\#ref</code> \#loc
static.variable.may.not.be.initialized.display.name=El campo static puede no estar inicializado
static.variable.may.not.be.initialized.problem.descriptor=El campo static <code>\#ref</code> puede no inicializarse durante la inicialización de la clase \#loc
static.variable.naming.convention.element.description=Campo 'static'
static.variable.of.concrete.class.problem.descriptor=Campo static ''{0}'' de la clase concreta <code>\#ref</code> \#loc
static.variable.used.before.initialization.display.name=Campo static usado antes de la inicialización
static.variable.used.before.initialization.problem.descriptor=Campo static <code>\#ref</code> usado antes de la inicialización \#loc
string.buffer.must.have.initial.capacity.display.name='StringBuilder' sin capacidad inicial
string.buffer.must.have.initial.capacity.problem.descriptor=<code>new \#ref()</code> sin capacidad inicial \#loc
string.buffer.replaceable.by.string.builder.display.name='StringBuffer' puede ser 'StringBuilder'
string.buffer.replaceable.by.string.builder.problem.descriptor=<code>StringBuffer \#ref</code> puede declararse como 'StringBuilder' \#loc
string.buffer.replaceable.by.string.display.name='StringBuilder' puede reemplazarse por 'String'
string.buffer.replaceable.by.string.problem.descriptor=<code>{0} \#ref</code> puede reemplazarse por ''String'' \#loc
string.comparison.display.name=Comparación de String usando '\=\=' en lugar de 'equals()'
string.comparison.problem.descriptor=Los valores String se comparan usando <code>\#ref</code>, no 'equals()' \#loc
string.concatenation.argument.to.log.call.display.name=Concatenación de String no constante como argumento en llamada de logging
string.concatenation.argument.to.log.call.problem.descriptor=String no constante como argumento en llamada de logging <code>\#ref()</code> \#loc
string.concatenation.argument.to.log.call.quickfix=Reemplazar concatenación con mensaje de log parametrizado
string.concatenation.argument.to.log.message.format.call.quickfix=Reemplazar 'Message.format()' con mensaje de log parametrizado
string.concatenation.argument.to.log.string.format.call.quickfix=Reemplazar 'String.format()' con mensaje de log parametrizado
string.concatenation.display.name=Concatenación de String
string.concatenation.in.format.call.display.name=Concatenación de String como argumento en llamada a 'format()'
string.concatenation.in.format.call.fix.family.name=Reemplazar concatenación con argumento
string.concatenation.in.format.call.problem.descriptor=La llamada a ''{0}()'' tiene un argumento de concatenación de String
string.concatenation.in.format.call.quickfix=Reemplazar concatenación con argumento separado
string.concatenation.in.loops.display.name=Concatenación de String en bucle
string.concatenation.in.loops.problem.descriptor=Concatenación de String <code>\#ref</code> en bucle \#loc
string.concatenation.in.message.format.call.display.name=Concatenación de String como argumento en llamada a 'MessageFormat.format()'
string.concatenation.in.message.format.call.problem.descriptor=Concatenación de String como argumento en llamada a 'MessageFormat.format()' \#loc
string.concatenation.inside.string.buffer.append.display.name=Concatenación de String como argumento en llamada a 'StringBuilder.append()'
string.concatenation.inside.string.buffer.append.problem.descriptor=Concatenación de String como argumento en llamada a <code>{0}.\#ref()</code> \#loc
string.concatenation.inside.string.buffer.append.replace.quickfix=Reemplazar con llamadas encadenadas a 'append()'
string.concatenation.introduce.fix=Introducir StringBuilder
string.concatenation.introduce.fix.name=Introducir nuevo {1} para actualizar variable ''{0}''
string.concatenation.introduce.fix.name.null.safe=Introducir nuevo {1} para actualizar variable ''{0}'' (null-safe)
string.concatenation.missing.whitespace.display.name=Puede faltar espacio en blanco en la concatenación de String
string.concatenation.missing.whitespace.option=Ignorar concatenaciones con strings variables
string.concatenation.missing.whitespace.problem.descriptor=Puede faltar espacio en blanco en la concatenación de String \#loc
string.concatenation.problem.descriptor=Concatenación de String <code>\#ref</code> en un contexto internacionalizado \#loc
string.concatenation.replace.fix=Reemplazar con StringBuilder
string.concatenation.replace.fix.name=Convertir variable ''{0}'' de String a {1}
string.concatenation.replace.fix.name.null.safe=Convertir variable ''{0}'' de String a {1} (null-safe)
string.equals.char.sequence.display.name='String.equals()' llamado con argumento 'CharSequence'
string.equals.char.sequence.problem.descriptor=<code>String.equals()</code> llamado con argumento ''{0}'' \#loc
string.equals.empty.string.display.name='String.equals()' puede reemplazarse por 'String.isEmpty()'
string.equals.empty.string.fix.family.name=Simplificar comprobación de string vacío
string.equals.empty.string.is.empty.problem.descriptor=<code>\#ref("")</code> puede reemplazarse por 'isEmpty()' \#loc
string.equals.empty.string.option.do.not.add.null.check=No reportar cuando podría ser necesaria una comprobación de null
string.equals.empty.string.problem.descriptor=<code>\#ref("")</code> puede reemplazarse por 'length()\=\=0' \#loc
string.format.choose.class=Elegir Clase Formateadora
string.format.class.label=Clases formateadoras adicionales\:
string.format.class.method.label=Métodos formateadores adicionales\:
string.indexof.replaceable.by.contains.display.name=La expresión 'String.indexOf()' puede reemplazarse por 'contains()'
string.replace.quickfix=Eliminar operando de string vacío
string.replaceable.by.string.buffer.display.name='String' no constante puede reemplazarse por 'StringBuilder'
string.replaceable.by.string.buffer.in.loop.option=Solo advertir cuando se concatena en un bucle
string.replaceable.by.string.buffer.problem.descriptor=String no constante <code>\#ref</code> probablemente debería declararse como 'StringBuilder' \#loc
string.touppercase.tolowercase.without.locale.display.name=Llamada a 'String.toUpperCase()' o 'toLowerCase()' sin locale
string.touppercase.tolowercase.without.locale.problem.descriptor=<code>String.\#ref()</code> llamado sin especificar un Locale usando strings internacionalizados \#loc
stringbuffer.field.display.name=Campo 'StringBuilder'
stringbuffer.field.problem.descriptor=Campo ''{0}'' <code>\#ref</code> \#loc
subtraction.in.compareto.display.name=Resta en 'compareTo()'
subtraction.in.compareto.problem.descriptor=La resta <code>\#ref</code> en 'compareTo()' puede resultar en desbordamiento o pérdida de precisión \#loc
super.class.logger.option=Ignorar cuando la superclase tiene un logger accesible
suppress.for.tests.scope.quickfix=Suprimir para ámbito 'Tests'
suspicious.array.cast.display.name=Cast sospechoso de array
suspicious.array.cast.problem.descriptor=Cast sospechoso a <code>\#ref</code> \#loc
suspicious.comparator.compare.descriptor.min.value=No se recomienda devolver Integer.MIN_VALUE desde una función de comparación
suspicious.comparator.compare.descriptor.non.negative=El comparador nunca devuelve valores negativos
suspicious.comparator.compare.descriptor.non.positive=El comparador nunca devuelve valores positivos
suspicious.comparator.compare.descriptor.non.reflexive=El comparador no devuelve 0 para elementos iguales
suspicious.comparator.compare.descriptor.parameter.not.used=El parámetro ''{0}()'' <code>\#ref</code> no se usa \#loc
suspicious.comparator.compare.display.name=Implementación sospechosa de 'Comparator.compare()'
suspicious.getter.problem.descriptor=El getter <code>\#ref()</code> devuelve el campo ''{0}'' \#loc
suspicious.getter.setter.display.name=Getter/setter sospechoso
suspicious.indent.after.control.statement.display.name=Indentación sospechosa después de sentencia de control sin llaves
suspicious.indent.after.control.statement.problem.descriptor=Indentación sospechosa después de la sentencia ''{0}'' \#loc
suspicious.integer.div.assignment.display.name=Asignación sospechosa de división de enteros
suspicious.integer.div.assignment.problem.descriptor=El resultado de la división se trunca a entero
suspicious.integer.div.assignment.quickfix=Convertir a double
suspicious.literal.underscore.display.name=Guión bajo sospechoso en literal numérico
suspicious.literal.underscore.problem.descriptor=El grupo en literal numérico con guiones bajos no tiene longitud 3 \#loc
suspicious.package.private.access.display.name=Acceso package-private sospechoso
suspicious.setter.problem.descriptor=El setter <code>\#ref()</code> asigna el campo ''{0}'' \#loc
suspicious.system.arraycopy.display.name=Llamada sospechosa a 'System.arraycopy()'
suspicious.system.arraycopy.problem.descriptor.length.bigger.dest=La longitud es siempre mayor que ''dest.length - destPos'' {0}
suspicious.system.arraycopy.problem.descriptor.length.bigger.src=La longitud es siempre mayor que ''src.length - srcPos'' {0}
suspicious.system.arraycopy.problem.descriptor.ranges.intersect=Copiando al mismo array con rangos que se intersectan
suspicious.system.arraycopy.problem.descriptor4=<code>\#ref</code> no es de tipo array \#loc
suspicious.system.arraycopy.problem.descriptor5=<code>\#ref</code> no es de tipo array \#loc
suspicious.system.arraycopy.problem.descriptor6=El tipo del parámetro fuente ''{0}'' no es asignable al parámetro destino <code>\#ref</code> de tipo ''{1}'' \#loc
suspicious.to.array.call.display.name=Llamada sospechosa a 'Collection.toArray()'
suspicious.to.array.call.fix.family.name=Reemplazar con array apropiado
suspicious.to.array.call.problem.descriptor=Se esperaba array de tipo ''{0}[]'', se encontró ''{1}[]'' \#loc
swap.equals.fix.family.name=Invertir llamada a método
switch.expression.with.single.default.message=La expresión 'switch' solo tiene case 'default'
switch.expression.with.too.few.branches.problem.descriptor=La expresión ''switch'' tiene muy pocas etiquetas case ({0}), y probablemente debería reemplazarse con una sentencia ''if'' o un operador condicional \#loc
switch.statement.density.display.name=Sentencia 'switch' con densidad de ramas muy baja
switch.statement.density.min.option=Densidad mínima de ramas\: %
switch.statement.density.problem.descriptor=La densidad de ramas <code>\#ref</code> es muy baja ({0}%) \#loc
switch.statement.display.name=Sentencia 'switch'
switch.statement.with.confusing.declaration.display.name=Variable local usada y declarada en diferentes ramas 'switch'
switch.statement.with.confusing.declaration.problem.descriptor=Variable local <code>\#ref</code> declarada en una rama 'switch' y usada en otra \#loc
switch.statement.with.single.default.message=La sentencia 'switch' solo tiene case 'default'
switch.statement.with.too.few.branches.display.name=Mínimo de ramas 'switch'
switch.statement.with.too.few.branches.ignore.pattern.option=No reportar sentencias switch de patrón
switch.statement.with.too.few.branches.min.option=Número mínimo de ramas\:
switch.statement.with.too.few.branches.problem.descriptor=La sentencia ''switch'' tiene muy pocas etiquetas case ({0}), y probablemente debería reemplazarse con una sentencia ''if'' \#loc
switch.statement.with.too.many.branches.display.name=Máximo de ramas 'switch'
switch.statement.without.default.ignore.option=Ignorar sentencias switch exhaustivas
switch.statements.without.default.display.name=Sentencia 'switch' sin rama 'default'
switch.statements.without.default.problem.descriptor=Sentencia <code>\#ref</code> sin rama 'default' \#loc
synchronization.on.get.class.display.name=Sincronización en 'getClass()'
synchronization.on.get.class.problem.descriptor=Sincronización en <code>\#ref()</code> \#loc
synchronization.on.local.variable.or.method.parameter.display.name=Sincronización en variable local o parámetro de método
synchronization.on.local.variable.problem.descriptor=Sincronización en variable local <code>\#ref</code> \#loc
synchronization.on.method.parameter.problem.descriptor=Sincronización en parámetro de método <code>\#ref</code> \#loc
synchronization.on.static.field.display.name=Sincronización en campo 'static'
synchronization.on.static.field.problem.descriptor=Sincronización en campo 'static' <code>\#ref</code> \#loc
synchronize.on.class.problem.descriptor=Las operaciones de bloqueo en una clase pueden tener efectos secundarios imprevistos \#loc
synchronize.on.lock.display.name=Sincronización en un objeto 'Lock'
synchronize.on.lock.problem.descriptor=La sincronización en un objeto ''{0}'' probablemente no sea intencional \#loc
synchronize.on.non.final.field.display.name=Sincronización en un campo no final
synchronize.on.non.final.field.problem.descriptor=Sincronización en campo no final <code>\#ref</code> \#loc
synchronize.on.this.display.name=Sincronización en 'this'
synchronize.on.this.problem.descriptor=Las operaciones de bloqueo en 'this' pueden tener efectos secundarios imprevistos \#loc
synchronized.method.display.name=Método 'synchronized'
synchronized.method.ignore.synchronized.super.option=Ignorar métodos que sobrescriben un método synchronized
synchronized.method.include.option=Incluir métodos nativos
synchronized.method.move.quickfix=Mover sincronización al método
synchronized.method.problem.descriptor=Método ''{0}()'' declarado <code>\#ref</code> \#loc
synchronized.on.direct.literal.object.problem.descriptor=Sincronización en literal {0} <code>\#ref</code> \#loc
synchronized.on.literal.object.name=Sincronización en un objeto inicializado con un literal
synchronized.on.literal.object.problem.descriptor=Sincronización en {0} <code>\#ref</code> que está inicializado por un literal \#loc
synchronized.on.literal.object.warn.on.all.option=Advertir sobre todos los literales posibles
synchronized.on.possibly.literal.object.problem.descriptor=Sincronización en {0} <code>\#ref</code> \#loc
system.exit.call.display.name=Llamada a 'System.exit()' o métodos relacionados
system.exit.call.ignore.option=Ignorar en método main
system.exit.call.problem.descriptor=La llamada a <code>{0}.\#ref()</code> no es portable \#loc
system.getenv.call.display.name=Llamada a 'System.getenv()'
system.getenv.call.problem.descriptor=La llamada a <code>System.\#ref()</code> no es portable \#loc
system.properties.display.name=Acceso a propiedades del sistema
system.properties.problem.descriptor=La llamada a <code>Integer.\#ref()</code> puede presentar problemas de seguridad \#loc
system.properties.problem.descriptor1=La llamada a <code>Boolean.\#ref()</code> puede presentar problemas de seguridad \#loc
system.run.finalizers.on.exit.display.name=Llamada a 'System.runFinalizersOnExit()'
system.run.finalizers.on.exit.problem.descriptor=Llamada a <code>System.\#ref()</code> \#loc
system.set.problem.descriptor=La llamada a <code>System.\#ref()</code> puede presentar problemas de seguridad \#loc
system.set.security.manager.display.name=Llamada a 'System.setSecurityManager()'
system.set.security.manager.problem.descriptor=La llamada a <code>System.\#ref()</code> puede presentar problemas de seguridad \#loc
tail.recursion.display.name=Recursión de cola
tail.recursion.problem.descriptor=Llamada recursiva de cola <code>\#ref()</code> \#loc
tail.recursion.replace.quickfix=Reemplazar recursión de cola con iteración
text.label.in.switch.statement.display.name=Etiqueta de texto en sentencia 'switch'
text.label.in.switch.statement.problem.descriptor=Etiqueta de texto <code>\#ref\:</code> en {0, choice, 1\#sentencia|2\#expresión} ''switch'' \#loc
the.whole.project=el proyecto completo
this.class=esta clase
this.reference.escaped.in.construction.display.name=Referencia 'this' escapada en construcción de objeto
this.reference.escaped.in.construction.problem.descriptor=Escape de <code>\#ref</code> durante la construcción del objeto \#loc
thread.death.rethrown.display.name='ThreadDeath' no relanzado
thread.death.rethrown.problem.descriptor=ThreadDeath <code>\#ref</code> no relanzado \#loc
thread.local.not.static.final.display.name=Campo 'ThreadLocal' no declarado como 'static final'
thread.local.not.static.final.problem.descriptor=ThreadLocal <code>\#ref</code> no está declarado como 'static final' \#loc
thread.local.set.with.null.display.name='ThreadLocal.set()' con null como argumento
thread.local.set.with.null.problem.descriptor='ThreadLocal.set()' con null como argumento puede causar fuga de memoria
thread.local.set.with.null.quickfix=Reemplazar con llamada a 'ThreadLocal.remove()'
thread.priority.display.name=Llamada a 'Thread.setPriority()'
thread.priority.problem.descriptor=Llamada a <code>Thread.\#ref()</code> \#loc
thread.run.problem.descriptor=Las llamadas a <code>\#ref()</code> probablemente deberían reemplazarse con 'start()' \#loc
thread.start.in.construction.display.name=Llamada a 'Thread.start()' durante la construcción del objeto
thread.start.in.construction.problem.descriptor=Llamada a <code>\#ref()</code> durante la construcción del objeto \#loc
thread.stop.suspend.resume.display.name=Llamada a 'Thread.stop()', 'suspend()' o 'resume()'
thread.stop.suspend.resume.problem.descriptor=Llamada a <code>Thread.\#ref()</code> \#loc
thread.with.default.run.method.display.name=Instanciando un 'Thread' con método 'run()' por defecto
thread.with.default.run.method.problem.descriptor=Instanciando un <code>\#ref</code> con método 'run()' por defecto \#loc
thread.yield.display.name=Llamada a 'Thread.yield()'
thread.yield.problem.descriptor=Llamada a <code>Thread.\#ref()</code> \#loc
three.negations.per.method.display.name=Método con más de tres negaciones
three.negations.per.method.ignore.assert.option=Ignorar negaciones en sentencias 'assert'
three.negations.per.method.ignore.option=Ignorar negaciones en métodos 'equals()'
three.negations.per.method.problem.descriptor=<code>\#ref</code> contiene {0} negaciones \#loc
throw,from.finally.block.everywhere.option=Advertir en todos los lugares donde se puedan lanzar excepciones declaradas
throw.caught.locally.display.name='throw' capturado por la sentencia 'try' contenedora
throw.caught.locally.ignore.option=Ignorar excepciones relanzadas
throw.caught.locally.problem.descriptor=<code>\#ref</code> capturado por la sentencia 'try' contenedora \#loc
throw.from.finally.block.display.name='throw' dentro del bloque 'finally'
throw.from.finally.block.problem.descriptor=<code>\#ref</code> dentro del bloque 'finally' \#loc
throwable.instance.never.thrown.checked.exception.problem.descriptor=La instancia de excepción verificada <code>\#ref</code> no se lanza \#loc
throwable.instance.never.thrown.error.problem.descriptor=La instancia de error <code>\#ref</code> no se lanza \#loc
throwable.instance.never.thrown.problem.descriptor=La instancia de Throwable <code>\#ref</code> no se lanza \#loc
throwable.instance.never.thrown.runtime.exception.problem.descriptor=La instancia de excepción en tiempo de ejecución <code>new \#ref()</code> no se lanza \#loc
throwable.not.thrown.display.name='Throwable' no lanzado
throwable.printed.to.system.out.display.name='Throwable' impreso en 'System.out'
throwable.printed.to.system.out.problem.descriptor=Argumento ''Throwable'' <code>\#ref</code> en llamada a ''System.{0}.{1}()''
throwable.printed.to.system.out.problem.fix.level.option=Método de registro para corrección\:
throwable.result.of.method.call.ignored.problem.descriptor=El resultado de <code>\#ref()</code> no se lanza \#loc
throwable.supplier.only.throw.exception.name=El proveedor Throwable nunca devuelve un valor
throwable.supplier.only.throw.exception.problem.descriptor=El proveedor Throwable no devuelve ninguna excepción
throwable.supplier.only.throw.exception.quickfix=Reemplazar 'throw' con 'return' en lambda
thrown.exceptions.per.method.display.name=Método con demasiadas excepciones declaradas
thrown.exceptions.per.method.limit.option=Límite de excepciones lanzadas\:
thrown.exceptions.per.method.problem.descriptor=<code>\#ref</code> tiene demasiadas excepciones declaradas (número de excepciones \= {0}) \#loc
throws.runtime.exception.display.name=Excepción no verificada declarada en cláusula 'throws'
throws.runtime.exception.fix.family.name=Eliminar de la cláusula 'throws'
throws.runtime.exception.move.quickfix=Mover ''{0}'' a la etiqueta Javadoc ''@throws''
throws.runtime.exception.problem.descriptor=Excepción no verificada <code>\#ref</code> declarada en cláusula 'throws' \#loc
throws.runtime.exception.quickfix=Eliminar ''{0}'' de la cláusula ''throws''
time.tostring.call.display.name=Llamada a 'Time.toString()'
time.tostring.call.problem.descriptor=<code>Time.\#ref()</code> en un contexto internacionalizado \#loc
to.array.call.style.display.name=Estilo de llamada 'Collection.toArray()'
to.array.call.style.problem.descriptor.presized=Llamada a <code>\#ref()</code> con argumento de array predimensionado ''{0}'' \#loc
to.array.call.style.problem.descriptor.zero=Llamada a <code>\#ref()</code> con argumento de array vacío ''{0}'' \#loc
to.array.call.style.quickfix.family.name=Corregir tamaño del array pasado a la llamada 'toArray()'
to.array.call.style.quickfix.make.presized=Reemplazar argumento con array predimensionado
to.array.call.style.quickfix.make.zero=Reemplazar argumento con array vacío
too.broad.catch.display.name=Bloque 'catch' demasiado amplio
too.broad.catch.option=S&olo advertir sobre RuntimeException, Exception, Error o Throwable
too.broad.catch.problem.descriptor=El ''catch'' de <code>\#ref</code> es demasiado amplio, enmascarando la excepción ''{0}'' \#loc
too.broad.catch.problem.descriptor1=El ''catch'' de <code>\#ref</code> es demasiado amplio, enmascarando las excepciones ''{0}'' y ''{1}'' \#loc
too.broad.catch.quickfix=Agregar cláusula ''catch'' para ''{0}''
too.broad.scope.allow.option=<html>Reportar variables con una nueva expresión como inicializador<br>(potencialmente inseguro)</html>
too.broad.scope.display.name=El ámbito de la variable es demasiado amplio
too.broad.scope.inspection.fix.family.name=Reducir ámbito
too.broad.scope.narrow.quickfix=Mover la declaración de ''{0}'' más cerca de sus usos
too.broad.scope.only.blocks.option=Solo reportar variables que pueden moverse a bloques internos
too.broad.scope.problem.descriptor=El ámbito de la variable <code>\#ref</code> es demasiado amplio \#loc
too.many.constructors.count.limit.option=Límite de cantidad de constructores\:
too.many.constructors.display.name=Clase con demasiados constructores
too.many.constructors.ignore.deprecated.option=Ignorar constructores obsoletos
too.many.constructors.problem.descriptor=<code>\#ref</code> tiene demasiados constructores (cantidad de constructores \= {0}) \#loc
too.many.fields.count.limit.option=Límite de cantidad de campos\:
too.many.fields.display.name=Clase con demasiados campos
too.many.fields.problem.descriptor=<code>\#ref</code> tiene demasiados campos (cantidad de campos \= {0}) \#loc
too.many.methods.display.name=Clase con demasiados métodos
too.many.methods.problem.descriptor=<code>\#ref</code> tiene demasiados métodos (cantidad de métodos \= {0}) \#loc
trace.level.option=nivel de traza
transient.field.in.non.serializable.class.display.name=Campo transient en clase no serializable
transient.field.in.non.serializable.class.problem.descriptor=El campo ''{0}'' está marcado como <code>\#ref</code>, en una clase no serializable \#loc
transient.field.not.initialized.display.name=Campo transient no inicializado en la deserialización
transient.field.not.initialized.problem.descriptor=Campo transient <code>\#ref</code> no inicializado en la deserialización \#loc
trivial.if.display.name=Sentencia 'if' redundante
trivial.if.fix.family.name=Simplificar 'if else'
trivial.if.option.ignore.assert.statements=Ignorar sentencias 'if' con 'assert' trivial
trivial.if.option.ignore.chained=Ignorar sentencias 'if' encadenadas
trivial.if.problem.descriptor=La sentencia <code>\#ref</code> puede simplificarse \#loc
trivial.string.concatenation.display.name=Concatenación con cadena vacía
trivial.string.concatenation.option.only.necessary=Reportar solo donde las cadenas vacías pueden eliminarse sin otros cambios
trivial.string.concatenation.problem.descriptor=Cadena vacía en concatenación
try.finally.can.be.try.with.resources.display.name='try finally' puede reemplazarse con 'try-with-resources'
try.finally.can.be.try.with.resources.problem.descriptor=<code>\#ref</code> puede usar gestión automática de recursos \#loc
try.finally.can.be.try.with.resources.quickfix=Reemplazar con 'try-with-resources'
try.statement.with.multiple.resources.name=La sentencia 'try' con múltiples recursos puede dividirse
try.statement.with.multiple.resources.quickfix=Dividir sentencia 'try' con múltiples recursos
try.with.identical.catches.checkbox.different.comments=No reportar bloques catch con comentarios diferentes
try.with.identical.catches.display.name=Ramas 'catch' idénticas en sentencia 'try'
try.with.identical.catches.problem.descriptor=Rama ''catch'' idéntica a la rama ''{0}'' \#loc
try.with.identical.catches.quickfix=Contraer bloques 'catch'
type.parameter.extends.enum.type.parameter.problem.descriptor=El parámetro de tipo <code>\#ref</code> extiende implícitamente el enum final ''{0}'' \#loc
type.parameter.extends.enum.wildcard.problem.descriptor=El argumento de tipo comodín <code>\#ref</code> extiende implícitamente el enum final ''{0}'' \#loc
type.parameter.extends.final.class.display.name=Parámetro de tipo extiende clase 'final'
type.parameter.extends.final.class.quickfix=Reemplazar parámetro de tipo con clase actual
type.parameter.extends.final.class.type.parameter.problem.descriptor=El parámetro de tipo <code>\#ref</code> extiende la clase 'final' ''{0}'' \#loc
type.parameter.extends.final.class.wildcard.problem.descriptor=El argumento de tipo comodín <code>\#ref</code> extiende la clase 'final' ''{0}'' \#loc
type.parameter.extends.object.display.name=El parámetro de tipo extiende explícitamente 'Object'
type.parameter.extends.object.ignore.annotated=Ignorar cuando java.lang.Object está anotado
type.parameter.extends.object.problem.descriptor1=El parámetro de tipo <code>\#ref</code> extiende explícitamente 'java.lang.Object' \#loc
type.parameter.extends.object.problem.descriptor2=El argumento de tipo comodín <code>\#ref</code> extiende explícitamente 'java.lang.Object' \#loc
type.parameter.hides.type.parameter.problem.descriptor=El parámetro de tipo <code>\#ref</code> oculta el parámetro de tipo ''{0}'' \#loc
type.parameter.hides.visible.type.display.name=El parámetro de tipo oculta un tipo visible
type.parameter.hides.visible.type.problem.descriptor=El parámetro de tipo <code>\#ref</code> oculta el tipo visible ''{0}'' \#loc
type.parameter.naming.convention.element.description=Parámetro de tipo
unary.plus.display.name=Más unario
unary.plus.problem.descriptor=Operador unario <code>\#ref</code> \#loc
unary.plus.quickfix=Eliminar '+' unario
unchecked.exception.class.display.name=Clase 'Exception' sin verificar
unchecked.exception.class.problem.descriptor=Clase de excepción sin verificar <code>\#ref</code> \#loc
unclear.binary.expression.display.name=Múltiples operadores con diferente precedencia
unclear.binary.expression.problem.descriptor=La expresión podría usar paréntesis aclaratorios \#loc
unclear.binary.expression.quickfix=Agregar paréntesis aclaratorios
unconditional.wait.display.name=Llamada incondicional a 'wait()'
unconditional.wait.problem.descriptor=Llamada incondicional a <code>\#ref()</code> \#loc
unnecessarily.qualified.inner.class.access.display.name=Acceso a clase interna innecesariamente calificado
unnecessarily.qualified.inner.class.access.option=Ignorar referencias que necesitan un import
unnecessarily.qualified.inner.class.access.problem.descriptor=''{0}'' está innecesariamente calificado con <code>\#ref</code> \#loc
unnecessarily.qualified.inner.class.access.quickfix=Eliminar calificador
unnecessarily.qualified.static.usage.display.name=Acceso estático innecesariamente calificado
unnecessarily.qualified.static.usage.ignore.field.option=Ignorar accesos a campos innecesariamente calificados
unnecessarily.qualified.static.usage.ignore.method.option=Ignorar llamadas a métodos innecesariamente calificadas
unnecessarily.qualified.static.usage.problem.descriptor=Llamada innecesariamente calificada al método estático <code>{0}()</code> \#loc
unnecessarily.qualified.static.usage.problem.descriptor1=Acceso innecesariamente calificado al campo estático <code>{0}</code> \#loc
unnecessarily.qualified.statically.imported.element.display.name=Elemento importado estáticamente innecesariamente calificado
unnecessarily.qualified.statically.imported.element.problem.descriptor=El elemento importado estáticamente ''{0}'' está innecesariamente calificado con <code>\#ref</code> \#loc
unnecessarily.qualified.statically.imported.element.quickfix=Eliminar calificador innecesario
unnecessary.block.statement.problem.descriptor=Las llaves alrededor de esta sentencia son innecesarias \#loc
unnecessary.boxing.display.name=Boxing innecesario
unnecessary.boxing.inside.value.of.problem.descriptor=Boxing redundante, se puede usar la llamada <code>{0}.{1}()</code> en su lugar \#loc
unnecessary.boxing.problem.descriptor=Boxing innecesario \#loc
unnecessary.boxing.remove.quickfix=Eliminar boxing
unnecessary.boxing.superfluous.option=Solo reportar expresiones con boxing verdaderamente superfluo
unnecessary.break.display.name=Sentencia 'break' innecesaria
unnecessary.break.problem.descriptor=La sentencia <code>\#ref</code> es innecesaria \#loc
unnecessary.code.block.display.name=Bloque de código innecesario
unnecessary.code.block.unwrap.quickfix=Desenvolver bloque
unnecessary.constant.array.creation.expression.display.name=Expresión 'new' redundante en creación de array constante
unnecessary.constant.array.creation.expression.family.quickfix=Eliminar especificación de tipo de la expresión de nuevo array
unnecessary.constant.array.creation.expression.problem.descriptor=<code>\#ref</code> puede ser eliminado de la expresión de nuevo array \#loc
unnecessary.constructor.annotation.option=Ignorar constructores con anotación
unnecessary.constructor.display.name=Constructor sin argumentos redundante
unnecessary.constructor.problem.descriptor=El constructor sin argumentos <code>\#ref()</code> es redundante \#loc
unnecessary.constructor.remove.quickfix=Eliminar constructor redundante
unnecessary.continue.display.name=Sentencia 'continue' innecesaria
unnecessary.continue.problem.descriptor=<code>\#ref</code> es innecesario como última sentencia en un bucle \#loc
unnecessary.conversion.to.string.display.name=Conversión innecesaria a 'String'
unnecessary.default.display.name='default' innecesario para sentencia 'switch' de enum
unnecessary.default.expressions.option=Solo reportar expresiones switch
unnecessary.default.problem.descriptor=La rama <code>\#ref</code> es innecesaria \#loc
unnecessary.default.quickfix=Eliminar rama 'default'
unnecessary.enum.constructor.modifier.problem.descriptor=El modificador <code>\#ref</code> es redundante para constructores de enum \#loc
unnecessary.explicit.numeric.cast.display.name=Conversión numérica explícita innecesaria
unnecessary.explicit.numeric.cast.problem.descriptor=''{0}'' convertido innecesariamente a <code>\#ref</code> \#loc
unnecessary.explicit.numeric.cast.quickfix=Eliminar conversión
unnecessary.final.on.local.variable.or.parameter.display.name='final' innecesario en variable local o parámetro
unnecessary.final.on.local.variable.problem.descriptor=<code>\#ref</code> innecesario en la variable ''{0}'' \#loc
unnecessary.final.on.parameter.only.interface.option=Solo advertir en métodos abstractos o de interfaz
unnecessary.final.on.parameter.problem.descriptor=<code>\#ref</code> innecesario en el parámetro ''{0}'' \#loc
unnecessary.final.report.local.variables.option=Reportar variables locales
unnecessary.final.report.parameters.option=Reportar parámetros
unnecessary.final.report.pattern.variables.option=Reportar variables de patrón
unnecessary.fully.qualified.name.display.name=Nombre completamente calificado innecesario
unnecessary.fully.qualified.name.fix.family.name=Reemplazar nombre completamente calificado
unnecessary.fully.qualified.name.problem.descriptor1=El calificador <code>\#ref</code> es innecesario y puede ser reemplazado con un import \#loc
unnecessary.fully.qualified.name.problem.descriptor2=El calificador <code>\#ref</code> es innecesario y puede ser eliminado \#loc
unnecessary.fully.qualified.name.remove.quickfix=Eliminar calificación innecesaria
unnecessary.fully.qualified.name.replace.quickfix=Reemplazar nombre calificado con import
unnecessary.inherit.doc.class.invalid.problem.descriptor=<code>\#ref</code> no es válido en clases \#loc
unnecessary.inherit.doc.constructor.invalid.problem.descriptor=<code>\#ref</code> no es válido en constructores \#loc
unnecessary.inherit.doc.constructor.no.super.problem.descriptor=No se encontró método super del que heredar Javadoc \#loc
unnecessary.inherit.doc.display.name=Comentario Javadoc '{@inheritDoc}' innecesario
unnecessary.inherit.doc.field.invalid.problem.descriptor=<code>\#ref</code> no es válido en campos \#loc
unnecessary.inherit.doc.module.invalid.problem.descriptor=<code>\#ref</code> no es válido en declaraciones de módulo \#loc
unnecessary.inherit.doc.problem.descriptor=El comentario Javadoc que solo contiene <code>\#ref</code> es innecesario \#loc
unnecessary.inherit.doc.quickfix=Eliminar {@inheritDoc} innecesario
unnecessary.initcause.display.name=Llamada innecesaria a 'Throwable.initCause()'
unnecessary.initcause.problem.descriptor=Llamada innecesaria a <code>Throwable.\#ref()</code>
unnecessary.initcause.quickfix=Eliminar llamada a 'Throwable.initCause()'
unnecessary.inner.enum.modifier.problem.descriptor=El modificador <code>\#ref</code> es redundante para enums internos \#loc
unnecessary.inner.interface.modifier.problem.descriptor=El modificador <code>\#ref</code> es redundante para interfaces internas \#loc
unnecessary.inner.record.modifier.problem.descriptor=El modificador <code>\#ref</code> es redundante para records internos
unnecessary.interface.field.modifier.problem.descriptor=El modificador <code>\#ref</code> es redundante para campos de interfaz \#loc
unnecessary.interface.inner.class.modifier.problem.descriptor=El modificador <code>\#ref</code> es redundante para clases internas de interfaces \#loc
unnecessary.interface.member.modifier.problem.descriptor=El modificador <code>\#ref</code> es redundante para miembros de interfaz \#loc
unnecessary.interface.method.modifier.problem.descriptor=El modificador <code>\#ref</code> es redundante para métodos de interfaz \#loc
unnecessary.interface.modifier.problem.descriptor=El modificador <code>\#ref</code> es redundante para interfaces \#loc
unnecessary.java.doc.link.fix.family.name=Eliminar etiqueta redundante
unnecessary.javadoc.link.display.name=Enlace Javadoc innecesario
unnecessary.javadoc.link.option=Ignorar enlaces en línea a métodos super
unnecessary.javadoc.link.quickfix=Eliminar ''{0}'' innecesario
unnecessary.javadoc.link.super.method.problem.descriptor=<code>\#ref</code> que apunta al método super es innecesario \#loc
unnecessary.javadoc.link.this.class.problem.descriptor=<code>\#ref</code> que apunta a la clase contenedora es innecesario \#loc
unnecessary.javadoc.link.this.method.problem.descriptor=<code>\#ref</code> que apunta a este método es innecesario \#loc
unnecessary.label.on.break.statement.display.name=Etiqueta innecesaria en la sentencia 'break'
unnecessary.label.on.break.statement.problem.descriptor=Etiqueta innecesaria <code>\#ref</code> en sentencia break \#loc
unnecessary.label.on.continue.statement.display.name=Etiqueta innecesaria en sentencia 'continue'
unnecessary.label.on.continue.statement.problem.descriptor=Etiqueta innecesaria <code>\#ref</code> en sentencia continue \#loc
unnecessary.label.remove.quickfix=Eliminar etiqueta
unnecessary.local.variable.problem.descriptor=La variable local <code>\#ref</code> es redundante \#loc
unnecessary.modifier.display.name=Modificador innecesario
unnecessary.parentheses.conditional.option=Ignorar paréntesis alrededor de la condición en expresiones condicionales
unnecessary.parentheses.display.name=Paréntesis innecesarios
unnecessary.parentheses.option=Ignorar paréntesis aclaratorios
unnecessary.parentheses.problem.descriptor=Los paréntesis alrededor de <code>\#ref</code> son innecesarios \#loc
unnecessary.parentheses.remove.quickfix=Eliminar paréntesis innecesarios
unnecessary.qualifier.for.super.problem.descriptor=El calificador <code>\#ref</code> en 'super' es innecesario en este contexto \#loc
unnecessary.qualifier.for.this.display.name=Calificador innecesario para 'this' o 'super'
unnecessary.qualifier.for.this.problem.descriptor=El calificador <code>\#ref</code> en 'this' es innecesario en este contexto \#loc
unnecessary.qualifier.for.this.remove.quickfix=Eliminar calificador innecesario
unnecessary.record.modifier.problem.descriptor=El modificador <code>\#ref</code> es redundante para records
unnecessary.return.constructor.problem.descriptor=<code>\#ref</code> es innecesario como última sentencia en un constructor \#loc
unnecessary.return.display.name=Sentencia 'return' innecesaria
unnecessary.return.option=Ignorar en rama then de sentencia 'if' con rama 'else'
unnecessary.return.problem.descriptor=<code>\#ref</code> es innecesario como última sentencia en un método 'void' \#loc
unnecessary.semicolon.display.name=Punto y coma innecesario
unnecessary.semicolon.ignore.after.enum.constants.option=Ignorar puntos y coma innecesarios después de constantes enum
unnecessary.semicolon.problem.descriptor=Punto y coma innecesario <code>\#ref</code> \#loc
unnecessary.semicolon.remove.quickfix=Eliminar punto y coma innecesario
unnecessary.strictfp.modifier.problem.descriptor=El modificador <code>\#ref</code> es redundante en Java 17 y posteriores
unnecessary.string.escape.display.name=Carácter escapado innecesariamente
unnecessary.string.escape.problem.descriptor=<code>{0}</code> está escapado innecesariamente
unnecessary.string.escape.quickfix=Eliminar escape innecesario
unnecessary.super.constructor.display.name=Llamada innecesaria a 'super()'
unnecessary.super.constructor.problem.descriptor=<code>\#ref</code> es innecesario \#loc
unnecessary.super.constructor.remove.quickfix=Eliminar 'super()' innecesario
unnecessary.super.qualifier.display.name=Calificador 'super' innecesario
unnecessary.super.qualifier.problem.descriptor=El calificador <code>\#ref</code> es innecesario en este contexto \#loc
unnecessary.super.qualifier.quickfix=Eliminar calificador 'super' innecesario
unnecessary.temporary.object.fix.family.name=Reemplazar concatenación
unnecessary.temporary.on.conversion.from.string.display.name=Objeto temporal innecesario en conversión desde 'String'
unnecessary.temporary.on.conversion.to.string.display.name=Objeto temporal innecesario en conversión a 'String'
unnecessary.this.display.name=Calificador 'this' innecesario
unnecessary.this.ignore.assignments.option=Ignorar asignaciones de campo
unnecessary.this.problem.descriptor=<code>\#ref</code> es innecesario en este contexto \#loc
unnecessary.this.remove.quickfix=Eliminar calificador 'this' innecesario
unnecessary.tostring.call.display.name=Llamada innecesaria a 'toString()'
unnecessary.tostring.call.option.report.with.empty.string=Reportar llamadas que pueden reemplazarse con concatenación con cadena vacía
unnecessary.tostring.call.problem.descriptor=Llamada innecesaria a <code>\#ref()</code> \#loc
unnecessary.tostring.call.problem.empty.string.descriptor=Puede reemplazarse con concatenación con cadena vacía
unnecessary.transient.modifier.problem.descriptor=El modificador <code>\#ref</code> es redundante para un campo 'static'
unnecessary.unary.minus.display.name=Signo menos unario innecesario
unnecessary.unary.minus.problem.descriptor=Operador unario <code>\#ref</code> innecesario \#loc
unnecessary.unary.minus.quickfix=Eliminar signo menos unario e invertir signo de operación padre
unnecessary.unary.minus.remove.quickfix=Eliminar doble signo menos unario
unnecessary.unboxing.display.name=Unboxing innecesario
unnecessary.unboxing.problem.descriptor=Unboxing innecesario \#loc
unnecessary.unboxing.remove.quickfix=Eliminar unboxing
unnecessary.unboxing.superfluous.option=Solo reportar expresiones realmente superfluas de unboxing
unnecessary.unicode.escape.display.name=Secuencia de escape unicode innecesaria
unnecessary.unicode.escape.fix.family.name=Reemplazar con carácter
unnecessary.unicode.escape.fix.text=Reemplazar con carácter de salto de línea
unnecessary.unicode.escape.problem.descriptor=La secuencia de escape unicode <code>\#ref</code> puede reemplazarse con ''{0}'' \#loc
unnecessary.unicode.escape.problem.newline.descriptor=La secuencia de escape unicode <code>\#ref</code> puede reemplazarse con un carácter de salto de línea \#loc
unpredictable.big.decimal.constructor.call.display.name=Llamada impredecible al constructor de 'BigDecimal'
unpredictable.big.decimal.constructor.call.ignore.complex.literals.option=Ignorar llamadas al constructor con múltiples literales (ej. 0.1 + 0.2)
unpredictable.big.decimal.constructor.call.ignore.references.option=Ignorar llamadas al constructor con argumentos de variables o llamadas a métodos
unpredictable.big.decimal.constructor.call.problem.descriptor=Llamada impredecible a <code>new \#ref()</code> \#loc
unqualified,static.usage.only.report.static.usages.option=Solo reportar acceso static desde un contexto no static
unqualified.field.access.display.name=Acceso a campo de instancia no calificado con 'this'
unqualified.field.access.problem.descriptor=Acceso a campo de instancia <code>\#ref</code> no está calificado con 'this' \#loc
unqualified.inner.class.access.display.name=Acceso no calificado a clase interna
unqualified.inner.class.access.option=Ignorar referencias a clases internas locales
unqualified.inner.class.access.problem.descriptor=<code>\#ref</code> no está calificado con clase externa \#loc
unqualified.inner.class.access.quickfix=Calificar con clase externa
unqualified.method.access.display.name=Llamada a método de instancia no calificada con 'this'
unqualified.method.access.problem.descriptor=Llamada a método de instancia <code>\#ref()</code> no está calificada con 'this' \#loc
unqualified.static.access.fix.family.name=Calificar acceso static
unqualified.static.usage.display.name=Acceso estático no calificado
unqualified.static.usage.ignore.field.option=Ignorar accesos a campos no calificados
unqualified.static.usage.ignore.method.option=Ignorar llamadas a métodos no calificados
unqualified.static.usage.problem.descriptor=Llamada a método static no calificada <code>\#ref()</code> \#loc
unqualified.static.usage.problem.descriptor1=Acceso a campo static no calificado <code>\#ref</code> \#loc
unqualified.static.usage.qualify.field.quickfix=Calificar acceso a campo static
unqualified.static.usage.qualify.method.quickfix=Calificar llamada a método static
unrunnable.main.method.problem.descriptor=El método <code>\#ref()</code> no puede ejecutarse porque la clase contenedora no tiene un nombre completamente calificado
unsecure.random.number.generation.display.name=Generación insegura de números aleatorios
unsecure.random.number.generation.problem.descriptor1=Por motivos de seguridad, use 'java.security.SecureRandom' en lugar de <code>java.lang.Math.\#ref()</code> \#loc
unsecure.random.number.generation.problem.descriptor2=Por motivos de seguridad, use 'java.security.SecureRandom' en lugar de <code>java.util.\#ref</code> \#loc
unsecure.random.number.generation.problem.descriptor3=Por motivos de seguridad, use 'java.security.SecureRandom' en lugar de <code>\#ref</code> \#loc
unused.import.problem.descriptor=Import no utilizado <code>\#ref</code> \#loc
unused.label.display.name=Etiqueta no utilizada
unused.label.problem.descriptor=Etiqueta no utilizada <code>\#ref</code> \#loc
unused.label.remove.quickfix=Eliminar etiqueta no utilizada
update.label=Actualizar nombres que empiezan con\:
upper.case.field.name.not.constant.display.name=Campo no constante con nombre en mayúsculas
upper.case.field.name.not.constant.problem.descriptor=Campo no constante <code>\#ref</code> con nombre de estilo constante \#loc
use.0index.in.jdbc.prepared.statement.problem.descriptor=Uso de índice '0' en JDBC PreparedStatement \#loc
use.0index.in.jdbc.resultset.display.name=Uso de índice 0 en JDBC ResultSet
use.0index.in.jdbc.resultset.problem.descriptor=Uso de índice '0' en JDBC ResultSet \#loc
use.contentequals=Usar 'contentEquals()' para comparación con 'AbstractStringBuilder'
use.equalsignorecase.for.case.insensitive.comparison=Usar 'equalsIgnoreCase()' para comparación sin distinción de mayúsculas/minúsculas
use.isblank.to.check.if.string.is.whitespace.or.empty=Usar 'isBlank()' para verificar si una cadena está vacía o solo contiene espacios en blanco
use.obsolete.collection.type.display.name=Uso de tipo de colección obsoleto
use.obsolete.collection.type.ignore.library.arguments.option=Ignorar tipos de colección obsoletos donde sean requeridos
use.obsolete.collection.type.problem.descriptor=Tipo de colección obsoleto <code>\#ref</code> usado \#loc
use.of.awt.peer.class.display.name=Uso de clase peer de AWT
use.of.awt.peer.class.problem.descriptor=El uso de la clase peer de AWT <code>\#ref</code> no es portable \#loc
use.of.clone.call.method.problem.descriptor=Implementación de <code>\#ref()</code>
use.of.clone.call.problem.descriptor=Llamada a <code>\#ref()</code>
use.of.clone.display.name=Uso de 'clone()' o 'Cloneable'
use.of.clone.reference.problem.descriptor=Uso de <code>\#ref</code>
use.of.concrete.class.option.ignore.abstract=Ignorar tipo de clase abstracta
use.of.concrete.class.option.ignore.records=Ignorar records de Java
use.of.concrete.class.option.report.cast=Reportar tipo usado en expresión de cast
use.of.concrete.class.option.report.instance.fields=Reportar tipo de campo de instancia
use.of.concrete.class.option.report.instanceof=Reportar tipo usado en instanceof, patterns o comparación getClass()
use.of.concrete.class.option.report.local.variable=Reportar tipo de variable local
use.of.concrete.class.option.report.method.returns=Reportar tipo de retorno de método
use.of.concrete.class.option.report.parameter=Reportar tipo de parámetro de método
use.of.concrete.class.option.report.static.fields=Reportar tipo de campo static
use.of.concrete.jdbc.driver.class.display.name=Uso de clase concreta de driver JDBC
use.of.concrete.jdbc.driver.class.problem.descriptor=El uso de la clase concreta de driver JDBC <code>\#ref</code> no es portable \#loc
use.of.obsolete.date.time.api.display.name=Uso de API obsoleta de fecha-hora
use.of.obsolete.date.time.api.problem.descriptor=Tipo de fecha-hora obsoleto <code>\#ref</code> usado \#loc
use.of.properties.as.hashtable.fix.family.name=Corregir acceso a propiedades
use.processbuilder.class.display.name=Uso de la clase 'java.lang.ProcessBuilder'
use.processbuilder.class.problem.descriptor=El uso de <code>\#ref</code> no es portable \#loc
use.stringtokenizer.display.name=Uso de 'StringTokenizer'
use.stringtokenizer.problem.descriptor=<code>\#ref</code> en un contexto internacionalizado \#loc
use.sun.classes.display.name=Uso de clases 'sun.*'
use.sun.classes.problem.descriptor=El uso de la clase proporcionada por Sun <code>\#ref</code> no es portable \#loc
use.system.out.err.display.name=Uso de 'System.out' o 'System.err'
use.system.out.err.problem.descriptor=Los usos de <code>\#ref</code> probablemente deberían reemplazarse con logging más robusto \#loc
use.system.out.err.problem.fix.err.option=Método de logging para 'System.err'\:
use.system.out.err.problem.fix.out.option=Método de logging para 'System.out'\:
utility.class.can.be.enum.display.name=La clase de utilidad puede ser 'enum'
utility.class.code.can.be.enum.problem.descriptor=La clase de utilidad <code>\#ref</code> puede ser 'enum' \#loc
utility.class.code.can.be.enum.quickfix=Convertir a 'enum'
utility.class.display.name=Clase de utilidad
utility.class.problem.descriptor=La clase <code>\#ref</code> solo tiene miembros 'static', indicando construcción procedural \#loc
utility.class.with.public.constructor.display.name=Clase de utilidad con constructor 'public'
utility.class.with.public.constructor.fix.family.name=Hacer constructores no públicos
utility.class.with.public.constructor.make.private.quickfix=Hacer {0, choice, 1\#constructor|2\#constructores} ''private''
utility.class.with.public.constructor.make.protected.quickfix=Hacer {0, choice, 1\#constructor|2\#constructores} ''protected''
utility.class.with.public.constructor.problem.descriptor=La clase <code>\#ref</code> solo tiene miembros 'static' y un constructor 'public' \#loc
utility.class.without.private.constructor.cant.generate.constructor.message=La clase de utilidad tiene instanciaciones, no se creará constructor private
utility.class.without.private.constructor.create.quickfix=Generar constructor 'private' vacío
utility.class.without.private.constructor.display.name=Clase de utilidad sin constructor 'private'
utility.class.without.private.constructor.make.quickfix=Hacer constructor 'private'
utility.class.without.private.constructor.option=Ignorar clases que solo tienen método main
utility.class.without.private.constructor.problem.descriptor=La clase <code>\#ref</code> solo tiene miembros 'static' y carece de constructor 'private' \#loc
value.of.post.decrement.problem.descriptor=Se usa el valor de la expresión post-decremento <code>\#ref</code> \#loc
value.of.post.increment.problem.descriptor=Se usa el valor de la expresión post-incremento <code>\#ref</code> \#loc
value.of.pre.decrement.problem.descriptor=Se usa el valor de la expresión pre-decremento <code>\#ref</code> \#loc
value.of.pre.increment.problem.descriptor=Se usa el valor de la expresión pre-incremento <code>\#ref</code> \#loc
variable.argument.method.display.name=Método varargs
variable.argument.method.problem.descriptor=Método varargs <code>\#ref()</code> \#loc
variable.argument.method.quickfix=Convertir parámetro varargs a array
variable.not.used.inside.conditional.problem.descriptor=<code>\#ref</code> verificado por 'null' no se usa dentro del condicional \#loc
variable.not.used.inside.if.display.name=Referencia verificada por 'null' no se usa dentro del 'if'
variable.not.used.inside.if.problem.descriptor=<code>\#ref</code> verificado por 'null' no se usa dentro del 'if' \#loc
variable.type.can.be.explicit.display.name=El tipo de variable puede ser explícito
volatile.array.field.display.name=Campo de array volatile
volatile.field.problem.descriptor=Campo volatile <code>\#ref</code> de tipo ''{0}'' \#loc
wait.called.on.condition.display.name='wait()' llamado en objeto 'java.util.concurrent.locks.Condition'
wait.called.on.condition.problem.descriptor=Llamada a <code>\#ref()</code> en objeto Condition \#loc
wait.not.in.loop.display.name='wait()' no llamado en bucle
wait.not.in.loop.problem.descriptor=La llamada a <code>\#ref()</code> no está en un bucle \#loc
wait.notify.not.in.synchronized.context.display.name='wait()' o 'notify()' no está en contexto sincronizado
wait.notify.while.not.synchronized.on.problem.descriptor=Llamada a <code>\#ref</code> mientras no está sincronizado en ''{0}'' \#loc
wait.or.await.without.timeout.display.name='wait()' o 'await()' sin timeout
wait.or.await.without.timeout.problem.descriptor=<code>\#ref</code> sin timeout \#loc
wait.while.holding.two.locks.display.name='wait()' mientras se mantienen dos locks
wait.while.holding.two.locks.problem.descriptor=Se realiza llamada a <code>\#ref()</code> mientras se mantienen dos locks \#loc
wait.without.corresponding.notify.display.name='wait()' sin 'notify()' correspondiente
wait.without.corresponding.notify.problem.descriptor=Llamada a <code>\#ref()</code> sin <code>notify()</code> o <code>notifyAll()</code> correspondiente \#loc
warn.level.and.lower.option=nivel de advertencia e inferior
warn.on.label=Advertir sobre\:
weaken.visibility.quickfix=Debilitar visibilidad
while.can.be.foreach.display.name=El bucle 'while' puede reemplazarse con bucle 'for' mejorado
while.can.be.foreach.problem.descriptor=El bucle <code>\#ref</code> puede reemplazarse con 'for' mejorado \#loc
while.loop.spins.on.field.display.name=Bucle 'while' gira sobre campo
while.loop.spins.on.field.fix.family.name=Corregir bucle de giro
while.loop.spins.on.field.fix.spinwait=Agregar Thread.onSpinWait()
while.loop.spins.on.field.fix.volatile=Hacer ''{0}'' volatile
while.loop.spins.on.field.fix.volatile.spinwait=Hacer ''{0}'' volatile y agregar Thread.onSpinWait()
while.loop.spins.on.field.ignore.non.empty.loops.option=Solo advertir si el bucle está vacío
while.loop.spins.on.field.problem.descriptor=El bucle <code>\#ref</code> gira sobre campo \#loc
wrap.with.arrays.hash.code.quickfix=Envolver con ''{0}''
write.only.object.display.name=Objeto de solo escritura
write.only.object.option.ignore.impure.constructors=Ignorar constructores impuros