0.will.no.longer.be.overridable.by.1={0} no será más reemplazable por {1}
absolute.alignment.in.user.interface.display.name=Alineación absoluta en código AWT/Swing
absolute.alignment.in.user.interface.fix.family.name=Reemplazar con constante
absolute.alignment.in.user.interface.problem.descriptor=Se utilizó la constante de alineación absoluta <code>{0}.#ref</code> #loc
abstract.class.extends.concrete.class.display.name=Clase abstracta extiende a clase concreta
abstract.class.extends.concrete.class.problem.descriptor=La clase <code>#ref</code> está declarada como 'abstract' y extiende una clase concreta #loc
abstract.class.naming.convention.element.description=Clase abstracta
abstract.class.never.implemented.display.name=Clase abstracta sin subclase concreta
abstract.class.never.implemented.problem.descriptor=La clase abstracta <code>#ref</code> no tiene una subclase concreta #loc
abstract.class.with.only.one.direct.inheritor.display.name=Clase abstracta con un único heredero directo
abstract.class.with.only.one.direct.inheritor.problem.descriptor=La clase abstracta <code>#ref</code> tiene solo un heredero directo #loc
abstract.class.without.abstract.methods.display.name=Clase abstracta sin métodos 'abstractos'
abstract.class.without.abstract.methods.ignore.utility.class.option=Ignorar clases utilitarias
abstract.class.without.abstract.methods.problem.descriptor=La clase <code>#ref</code> está declarada como 'abstract' y no tiene métodos 'abstract' #loc
abstract.method.call.in.constructor.display.name=Llamada a método abstracto durante la construcción del objeto
abstract.method.call.in.constructor.problem.descriptor=Llamada al método 'abstracto' `#ref()` durante la construcción del objeto #loc
abstract.method.overrides.abstract.method.display.name=El método abstracto anula el método abstracto
abstract.method.overrides.abstract.method.ignore.different.javadoc.option=Ignorar métodos con Javadoc distinto al de sus métodos super
abstract.method.overrides.abstract.method.problem.descriptor=El método abstracto <code>#ref()</code> anula al método abstracto #loc
abstract.method.overrides.abstract.method.remove.quickfix=Quitar la declaración del método abstracto redundante
abstract.method.overrides.concrete.method.display.name=El método abstracto sobreescribe el método concreto
abstract.method.overrides.concrete.method.problem.descriptor=El método abstracto <code>#ref()</code> sobrescribe el método concreto #loc
abstract.method.with.missing.implementations.display.name=Método abstracto sin implementaciones
abstract.method.with.missing.implementations.problem.descriptor=método abstracto <code>#ref()</code> no está implementado en cada subclase #loc
access.to.non.thread.safe.static.field.from.instance.class.chooser.title=Elegir clase no segura para subprocesos
access.to.non.thread.safe.static.field.from.instance.display.name=Acceso a campo 'static' no seguro para subprocesos desde el nombre para mostrar de la instancia
access.to.non.thread.safe.static.field.from.instance.field.problem.descriptor=Acceso al campo estático no seguro para subprocesos <code>#ref</code> de tipo ''{0}'' #loc
access.to.non.thread.safe.static.field.from.instance.option.title=Clases no seguras para subprocesos:
access.to.static.field.locked.on.instance.display.name=Acceso a campo 'estático' bloqueado en datos de instancia
access.to.static.field.locked.on.instance.fix.name=Ignorar campos estáticos con tipo ''{0}''
access.to.static.field.locked.on.instance.problem.descriptor=Acceso al campo estático <code>#ref</code> bloqueado en los datos de instancia #loc
accessing.non.public.field.of.another.object.display.name=Acceso a un campo no público de otro objeto
accessing.non.public.field.of.another.object.problem.descriptor=Acceso directo al campo no público <code>#ref</code> de otro objeto #loc
add.0.to.ignore.if.annotated.by.list.quickfix=Añadir ''{0}'' a la lista de ''Ignorar si están anotados con''
add.catch.section.fix.family.name=Agregar cláusula 'catch'
add.read.write.object.methods.fix.family.name=Agregar 'readObject()' y 'writeObject()' métodos que siempre devuelven una excepción
add.read.write.object.methods.fix.text=Agrega método `writeObject()` que siempre lanza una excepción
add.read.write.object.methods.fix.text2=Agregar el método 'readObject()' que siempre arroja una excepción
add.serialversionuidfield.quickfix=Añadir el campo 'serialVersionUID'
add.this.qualifier.quickfix=Añadir calificador 'this'
add.throws.clause.fix.family.name=Reparar cláusula 'throws'
all.levels.option=todos los niveles de registro
allow.resource.to.be.opened.inside.a.try.block=Permitir que el recurso se abra dentro de un bloque 'try'
ambiguous.field.access.display.name=El acceso al campo heredado parece acceso al elemento desde código envolvente
ambiguous.field.access.hides.field.problem.descriptor=El acceso al campo <code>#ref</code> desde la superclase ''{0}'' parece como un acceso al campo desde la clase circundante #loc
ambiguous.field.access.hides.local.variable.problem.descriptor=El acceso al campo <code>#ref</code> de la superclase ''{0}'' parece el acceso a la variable local #loc
ambiguous.field.access.hides.parameter.problem.descriptor=El acceso del campo `#ref` desde la superclase ''{0}'' se ve como el acceso del parámetro #loc
ambiguous.field.access.navigate.quickfix=Navegar a la variable {0, choice, 1#local|2#parámetro|3#campo} a la cual se ha accedido aparentemente
ambiguous.field.access.quickfix=Agregar calificador 'super' para acceso al campo
ambiguous.method.call.display.name=La llamada al método heredado es similar a la llamada al método local
ambiguous.method.call.problem.descriptor=La llamada al método <code>#ref()</code> desde la superclase ''{0}'' parece una llamada al método de la clase ''{1}'' #loc
ambiguous.method.call.quickfix=Añade el calificador 'super' a la llamada del método
annotation.class.display.name=Interfaz de anotación
annotation.class.problem.descriptor=Interfaz de anotación <code>#ref</code> #loc
annotation.display.name=Anotación
annotation.naming.convention.element.description=Interfaz de anotaciones
annotation.problem.descriptor=Anotación <code>#ref</code> #loc
anonymous.class.field.hides.containing.method.variable.problem.descriptor=El campo de la clase anónima <code>#ref</code> oculta la variable del método contenedor #loc
anonymous.class.parameter.hides.containing.method.variable.problem.descriptor=El parámetro de la clase anónimo <code>#ref</code> esconde una variable en el método contenedor #loc
anonymous.class.variable.hides.containing.method.variable.display.name=Variable de clase anónima oculta variable en método contenedor
anonymous.class.variable.hides.containing.method.variable.problem.descriptor=Variable local de clase anónima <code>#ref</code> oculta la variable en el método contenedor #loc
anonymous.extends.concrete.collection.problem.descriptor=Clase anónima extiende explícitamente ''{0}'' #loc
anonymous.extends.thread.problem.descriptor=Clase anónima extiende directamente 'java.lang.Thread' #loc
anonymous.extends.throwable.problem.descriptor=La clase anónima extiende directamente 'java.lang.Throwable' #loc
anonymous.inner.class.display.name=La clase anónima se puede sustituir con una clase interna
anonymous.inner.class.problem.descriptor=Clase anónima `#ref` #loc
anonymous.inner.class.with.too.many.methods.display.name=Clase anónima con demasiados métodos
anonymous.inner.class.with.too.many.methods.problem.descriptor=Clase anónima con demasiados métodos (cuenta de métodos = {0}) #loc
anonymous.inner.may.be.named.static.inner.class.display.name=La clase interna anónima puede ser una clase interna 'estática' con nombre
anonymous.inner.may.be.named.static.inner.class.problem.descriptor=La clase anónima <code>#ref</code> puede ser una clase interna 'estática' con nombre #loc
anonymous.inner.may.be.named.static.inner.class.quickfix=Convertir en clase interna "estática" con nombre
any.method.may.close.resource.argument=Cualquier método puede cerrar el argumento del recurso
array.allocation.zero.length.display.name=Asignación de array de longitud cero
array.allocation.zero.length.problem.descriptor=Asignación de array de longitud cero #loc
array.can.be.replaced.with.enum.values=La matriz puede reemplazarse con valores de enumeración
array.can.be.replaced.with.enum.values.family.quickfix=Reemplazar array con EnumType.values()
array.can.be.replaced.with.enum.values.quickfix=Reemplazar el arreglo con {0}.values()
array.comparison.display.name=Arrays comparison usando '==', en vez de 'Arrays.equals()'
array.comparison.problem.descriptor=Los objetos de array se comparan mediante <code>#ref</code>, no 'Arrays.equals()' #loc
array.creation.without.new.keyword.family.quickfix=Añadir expresión 'new'
array.creation.without.new.keyword.name=Creación de array sin expresión 'new'
array.creation.without.new.keyword.quickfix=Añadir ''new {0}''
array.equals.problem.descriptor=La comparación de arrays se debería hacer usando ''{0}''
array.hash.code.display.name='hashCode()' llamada en array
array.hash.code.fix.family.name=Reemplazar con llamada a "Arrays.hashCode()"
array.hash.code.problem.descriptor=Probablemente <code>#ref()</code> en el array debería ser 'Arrays.hashCode()' #loc
array.hashcode.problem.descriptor=probablemente el cálculo del código hash de matriz deba ser hecho usando ''{0}''
array.length.in.loop.condition.display.name=array.length en condición de lazo
array.length.in.loop.condition.problem.descriptor=Verifica la longitud del array <code>#ref</code> en la condición del bucle #loc
array.objects.equals.display.name=Uso de métodos superficiales o de 'Objetos' con matrices
arrays.as.list.with.one.argument.problem.descriptor=Llamada a <code>#ref()</code> con solo un argumento #loc
arrays.as.list.with.zero.arguments.problem.descriptor=Llamada a <code>#ref()</code> para crear una lista vacía #loc
arrays.as.list.with.zero.or.one.argument.display.name=Llamada a 'Arrays.asList()' con muy pocos argumentos
assert.can.be.if.quickfix=Sustituir 'assert' con el enunciado 'if'
assert.keyword.is.considered.an.assertion='assert' es una palabra clave que se considera una aserción
assert.message.not.string.display.name='assert' message no está definida como una cadena
assert.message.not.string.only.warn.boolean.option=Solo avisar cuando el mensaje 'assert' sea 'boolean' o 'java.lang.Boolean'
assert.message.of.type.boolean.problem.descriptor=Mensaje de ''assert'' de tipo ''{0}'' #loc
assert.statement.display.name='sentencia assert'
assert.with.side.effects.call.mutates.expression=la llamada a ''{0}()'' muta ''{1}''
assert.with.side.effects.call.mutates.field=la llamada a ''{0}()'' muta el campo ''{1}''
assert.with.side.effects.call.performs.io=La llamada a ''{0}()'' realiza una operación de entrada/salida
assert.with.side.effects.display.name=Sentencia 'assert' con efectos secundarios
assert.with.side.effects.problem.descriptor=<code>#ref</code> tiene efectos colaterales: {0} #loc
assert.without.message.problem.descriptor=<code>#ref()</code> sin mensaje #loc
assert.without.message.quick.fix.family.name=Añadir mensaje de error
assertion.can.be.if.name=La afirmación puede ser reemplazada por una instrucción "if"
asserts.without.messages.display.name=Aserción sin mensaje
assignment.of.field.with.mutable.type.problem.descriptor=Asignación al campo {0} '{1}' desde el parámetro <code>#ref</code> #loc
assignment.or.return.of.field.with.mutable.type.display.name=Asignación o retorno de un campo con tipo mutable
assignment.replaceable.with.operator.assignment.display.name=La asignación podría reemplazarse con asignación de operador
assignment.replaceable.with.operator.assignment.ignore.conditional.operators.option=Ignorar operadores condicionales
assignment.replaceable.with.operator.assignment.ignore.obscure.operators.option=Ignorar los operadores ambiguos ^ y %
assignment.replaceable.with.operator.assignment.problem.descriptor=<code>#ref</code> se puede simplificar a ''{0}'' #loc
assignment.to.catch.block.parameter.display.name=Asignación al parámetro del bloque 'catch'
assignment.to.catch.block.parameter.problem.descriptor=Asignación al parámetro <code>#ref</code> del bloque 'catch' #loc
assignment.to.for.loop.parameter.check.foreach.option=Verificar parámetros de bucle 'for' mejorado
assignment.to.for.loop.parameter.display.name=Asignación al parámetro de bucle 'for'
assignment.to.for.loop.parameter.problem.descriptor=Asignación a parámetro de bucle for <code>#ref</code> #loc
assignment.to.lambda.parameter.display.name=Asignación a parámetro lambda
assignment.to.lambda.parameter.problem.descriptor=Asignación al parámetro lambda <code>#ref</code> #loc
assignment.to.method.parameter.display.name=Asignación a parámetro de método
assignment.to.method.parameter.ignore.transformation.option=<html>Ignorar si la asignación es una transformación del parámetro original</html>
assignment.to.method.parameter.problem.descriptor=Asignación al parámetro del método <code>#ref</code> #loc
assignment.to.null.display.name=Asignación al nulo
assignment.to.null.option=Ignorar asignaciones a campos
assignment.to.null.problem.descriptor=nulo asignado a la variable <code>#ref</code> #loc
assignment.to.static.field.from.instance.method.display.name=Asignación a campo estático desde contexto de instancia
assignment.to.static.field.from.instance.method.problem.descriptor=Asignación al campo estático <code>#ref</code> desde contexto de instancia #loc
assignment.to.superclass.field.display.name=El constructor asigna el valor al campo definido en la superclase
assignment.to.superclass.field.problem.descriptor=Asignación al campo ''{0}'' definido en superclase ''{1}'' #loc
assignment.used.as.condition.display.name=Asignación usada como condición
assignment.used.as.condition.problem.descriptor=Asignación <code>#ref</code> usada como condición #loc
atomic.field.updater.issues.display.name=Declaración incompatible de 'AtomicFieldUpdater'
atomic.field.updater.not.static.final.display.name=El campo 'AtomicFieldUpdater' no fue declarado 'static final'
atomic.field.updater.not.static.final.problem.descriptor={0} el campo <code>#ref</code> no está declarado ''static final'' #loc
auto.boxing.display.name=Desempaquetado automático
auto.boxing.ignore.added.to.collection.option=Ignorar expresiones añadidas a una colección
auto.boxing.make.boxing.explicit.quickfix=Convertir boxing en explícito
auto.boxing.problem.descriptor=Auto-boxing <code>#ref</code> #loc
auto.closeable.resource.display.name=AutoCloseable usado sin 'try'-with-resources
auto.closeable.resource.problem.descriptor=''{0}'' utilizado sin sentencia ''try''-con-recursos #loc
auto.closeable.resource.quickfix=Ignorar 'AutoCloseable' devuelto por este método
auto.closeable.resource.quickfix.preview=Añadir método <code>{0}</code> a la lista de métodos ignorados
auto.closeable.resource.returned.option=Ignorar instancias AutoCloseable devueltas de todas las llamadas de método
auto.unboxing.display.name=Auto-desempaquetado
auto.unboxing.make.unboxing.explicit.quickfix=Hacer desempaquetado explícito
auto.unboxing.problem.descriptor=Autodesempaquetado <code>#ref</code> #loc
await.not.in.loop.display.name='await()' no llamado en bucle
await.not.in.loop.problem.descriptor=La llamada a <code>#ref()</code> no está en el ciclo #loc
await.without.corresponding.signal.display.name=await() sin señal() correspondiente
await.without.corresponding.signal.problem.descriptor=Llamada a <code>#ref()</code> sin la correspondiente <code>signal()</code> o <code>signalAll()</code> #loc
bad.exception.caught.display.name=Excepción 'Exception' prohibida detectada
bad.exception.caught.problem.descriptor=Excepción prohibida <code>#ref</code> capturada #loc
bad.exception.declared.display.name=Excepción prohibida declarada
bad.exception.declared.problem.descriptor=Prohibido declarar excepción <code>#ref</code> #loc
bad.exception.thrown.display.name=Excepción prohibida lanzada
bad.exception.thrown.problem.descriptor=Prohibido lanzar excepción ''{0}'' #loc
bad.oddness.display.name=Comprobación de impar sospitoso
bad.oddness.problem.descriptor=La verificación de imparidad fallará en valores negativos
big.decimal.equals.display.name='equals()' llamado en 'BigDecimal'
big.decimal.equals.problem.descriptor=Probablemente <code>#ref()</code> entre valores BigDecimal debería ser 'compareTo()' #loc
big.decimal.method.without.rounding.called.display.name=Llamada al método 'BigDecimal' sin un argumento de modo de redondeo
big.decimal.method.without.rounding.called.problem.descriptor="BigDecimal.#ref()" llamado sin un argumento de modo de redondeo
bigdecimal.legacy.method.display.name='BigDecimal' método heredado llamado
bigdecimal.legacy.method.problem.descriptor=La llamada a 'BigDecimal.#ref()' puede utilizar la constante de enumeración 'RoundingMode'
bigdecimal.legacy.method.quickfix=Usa la constante RoundingMode
boolean.constructor.display.name=Llamada al constructor de booleanos
boolean.constructor.problem.descriptor=Constructor booleano invoca #loc
boolean.constructor.simplify.quickfix=Simplificar
boolean.expression.can.be.simplified.problem.descriptor=La expresión booleana <code>#ref</code> puede simplificarse a ''{0}'' #loc
boolean.expression.does.not.modify.problem.descriptor=<code>#ref</code> no modifica el valor de ''{0}'' #loc
boolean.expression.may.be.conditional.display.name=La expresión booleana se puede reemplazar con una expresión condicional
boolean.expression.remove.compound.assignment.quickfix=Quitar asignación compuesta innecesaria
boolean.field.always.inverted.problem.descriptor=El campo booleano <code>#ref</code> siempre está invertido #loc
boolean.method.name.must.start.with.question.display.name=El nombre del método booleano debe iniciarse con una palabra interrogativa
boolean.method.name.must.start.with.question.problem.descriptor=El nombre del método booleano <code>#ref</code> no empieza con un signo de interrogación #loc
boolean.method.name.must.start.with.question.table.label=Prefijos para nombres de métodos booleanos:
boolean.parameter.constructor.problem.descriptor='public' constructor <code>#ref()</code> con parámetro 'boolean' #loc
boolean.parameter.display.name=Método 'public' con parámetro 'boolean'
boolean.parameter.only.report.multiple.option=Solo reportar métodos con múltiples parámetros booleanos
boolean.parameter.problem.descriptor='public' método <code>#ref()</code> con parámetro 'boolean' #loc
boolean.parameters.constructor.problem.descriptor='constructor público <code>#ref()</code> con parámetros booleanos #loc
boolean.parameters.problem.descriptor="método 'public' <code>#ref()</code> con parámetros 'boolean' #loc
boolean.variable.always.inverted.display.name=La variable booleana siempre está invertida
boolean.variable.always.inverted.problem.descriptor=La variable booleana <code>#ref</code> está siempre invertida #loc
bounded.wildcard.contravariant.descriptor=Se puede generalizar a <code>? super #ref</code> #loc
bounded.wildcard.covariant.descriptor=Se puede generalizar a <code>? extends #ref</code> #loc
bounded.wildcard.display.name=Se pueden utilizar comodines limitados
bounded.wildcard.report.instance.option=Reportar métodos de instancia
bounded.wildcard.report.invariant.option=Informar sobre clases invariantes
bounded.wildcard.report.private.option=Reportar métodos privados
boxing.boxed.value.display.name=Boxing de un valor ya boxeado
boxing.boxed.value.problem.descriptor=Boxing de un <code>#ref</code> ya boxeado #loc
boxing.boxed.value.quickfix=Eliminar boxing innecesario
break.statement.display.name='break' declaración
break.statement.with.label.display.name=Sentencia 'break' con etiqueta
break.statement.with.label.problem.descriptor=Sentencia <code>#ref</code> con etiqueta #loc
busy.wait.display.name=Espera ocupada
busy.wait.problem.descriptor=Llamada a <code>Thread.#ref()</code> en un bucle, probablemente en espera activa #loc
c.style.array.declaration.display.name=Declaración de matriz estilo C
c.style.array.declaration.replace.quickfix=Reemplazar con declaración de matriz de estilo Java
cached.number.constructor.call.display.name=Llamada al constructor de número con argumento primitivo
cached.number.constructor.call.ignore.string.arguments.option=Ignorar nueva expresión de número con parámetro String
cached.number.constructor.call.problem.descriptor=Llamada al constructor Number con argumento primitivo #loc
cached.number.constructor.call.report.only.deprecated=Reportar solo si el constructor es @Deprecated
call.to.date.tostring.display.name=Llamada a 'Date.toString()'
call.to.date.tostring.problem.descriptor=<code>Date.#ref()</code> usado en un contexto internacionalizado #loc
call.to.native.method.while.locked.display.name=Llamada a método 'native' mientras se está bloqueado
call.to.native.method.while.locked.problem.descriptor=Llamada a método nativo <code>#ref()</code> en un contexto sincronizado #loc
call.to.numeric.tostring.display.name=Llamada a 'Number.toString()'
call.to.numeric.tostring.problem.descriptor=Se llamó a <code>Number.#ref()</code> en un contexto internacionalizado #loc
call.to.private.setter.in.class.option=Informar únicamente si el setter es 'private'
call.to.private.simple.getter.in.class.option=Informar solo si el getter es 'privado'
call.to.simple.getter.in.class.display.name=Llamada a getter simple desde dentro de la clase
call.to.simple.getter.in.class.ignore.option=Ignorar llamadas a getter en otros objetos
call.to.simple.getter.in.class.inline.quickfix=Inclusión en línea de llamada a getter
call.to.simple.getter.in.class.problem.descriptor=Llamada al método getter simple <code>#ref()</code> desde dentro de la clase #loc
call.to.simple.setter.in.class.display.name=Llamada a setter simple desde dentro de la clase
call.to.simple.setter.in.class.ignore.option=Ignorar las llamadas a setter en otros objetos
call.to.simple.setter.in.class.inline.quickfix=Llamar en línea a setter
call.to.simple.setter.in.class.problem.descriptor=Llamada a setter simple <code>#ref()</code> desde dentro de la clase #loc
call.to.string.concat.can.be.replaced.by.operator.display.name=La llamada a 'String.concat()' puede ser reemplazada con '+'
call.to.string.concat.can.be.replaced.by.operator.problem.descriptor=La llamada a #ref() puede reemplazarse con una expresión '+' #loc
call.to.string.concat.can.be.replaced.by.operator.quickfix=Reemplazar llamada 'concat()' con operador '+'
call.to.suspicious.string.method.display.name=Llamada al método sospechoso 'String'
call.to.suspicious.string.method.problem.descriptor=<code>String.#ref()</code> invocada en el contexto internacionalizado #loc
cast.conflicts.with.instanceof.display.name=Casteo conflictos con 'instanceof'
cast.conflicts.with.instanceof.problem.descriptor=El cast a tipo ''{0}'' conflicts con la comprobación de ''instanceof {1}'' anterior
cast.conflicts.with.instanceof.quickfix1=Reemplazar ''{0}'' con ''{1}'' en cast
cast.conflicts.with.instanceof.quickfix2=Reemplazar ''{0}'' con ''{1}'' en instanceof
cast.that.loses.precision.display.name=Conversión numérica que pierde precisión
cast.that.loses.precision.negative.problem.descriptor=El cast de ''{0}'' a <code>#ref</code> puede causar una pérdida de precisión para el argumento negativo #loc
cast.that.loses.precision.option=Ignorar conversiones de int a char
cast.that.loses.precision.problem.descriptor=Cast de ''{0}'' a <code>#ref</code> puede resultar en pérdida de precisión #loc
cast.to.concrete.class.problem.descriptor=Convertir a clase concreta <code>{0}</code> #loc
casting.to.incompatible.interface.display.name=Conversión a tipo incompatible
casting.to.incompatible.interface.problem.descriptor=Casteo de expresión con tipo ''{1}'' a {0, choice, 1#interfaz|2#clase} <code>#ref</code> incompatible #loc
caught.exception.immediately.rethrown.display.name=La excepción capturada es inmediatamente lanzada
caught.exception.immediately.rethrown.problem.descriptor=La excepción capturada <code>#ref</code> se vuelve a generar inmediatamente #loc
chain.of.class.equality.checks.problem.descriptor=Cadena de comprobaciones de igualdad de clases indica fallo en la abstracción #loc
chain.of.instanceof.checks.display.name=Cadena de verificaciones 'instanceof'
chain.of.instanceof.checks.problem.descriptor=Cadena de comprobaciones 'instanceof' indica fallo de abstracción #loc
chained.equality.comparisons.display.name=Comparaciones de igualdad encadenadas
chained.equality.comparisons.problem.descriptor=Comparaciones de igualdad encadenadas <code>#ref</code> #loc
chained.method.call.display.name=Llamadas a métodos encadenados
chained.method.call.ignore.option=Ignorar llamadas a métodos encadenados en inicializadores de campo
chained.method.call.ignore.self.types.option=Ignorar llamadas a métodos que retornan el mismo tipo que su clase contenedora
chained.method.call.problem.descriptor=Llamada a método encadenado <code>#ref()</code> #loc
change.modifier.fix.family.name=Cambiar modificador
change.modifier.package.private.quickfix=Convertir a paquete-privado
change.modifier.quickfix=Cambiar ''{0}''
channel.opened.not.closed.display.name=Canal abierto pero no cerrado de manera segura
char.used.in.arithmetic.content.cast.fix.family.name=Insertar conversión
char.used.in.arithmetic.context.cast.quickfix=Insertar conversión a {0}
char.used.in.arithmetic.context.display.name=expresión 'char' utilizada en contexto aritmético
char.used.in.arithmetic.context.problem.descriptor='char' in use in an arithmetic context
char.used.in.arithmetic.context.quickfix=Convertir a literal de cadena
character.comparison.display.name=Comparación de caracteres
character.comparison.problem.descriptor=Comparación de caracteres <code>#ref</code> en contexto internacionalizado #loc
checkbox.ignore.null.on.wrong.side=Ignorar 'null' en el lado equivocado
checked.exception.class.display.name=Clase de excepción comprobada
checked.exception.class.problem.descriptor=Clase de excepción marcada <code>#ref</code> #loc
choose.autocloseable.type.to.ignore.title=Elegir tipo de recurso de AutoCloseable para ignorar
choose.class=Seleccionar clase
choose.class.hierarchy.to.ignore.title=Selecciona jerarquía de clase a ignorar
choose.class.type.to.ignore=Elige la clase a ignorar
choose.exception.class=Escoge la clase de excepción
choose.exception.label=Excepciones prohibidas:
choose.io.resource.type.to.ignore=Seleccionar tipo de recurso de E/S a ignorar
choose.logger.class=Elegir clase Logger
class.escapes.defined.scope.display.module.option=Informar sobre clases no exportadas expuestas en la API del módulo (Java 9+)
class.escapes.defined.scope.display.name=La clase está expuesta fuera de su alcance de visibilidad
class.escapes.defined.scope.display.package.option=Informar de las clases privadas expuestas en API de paquete local
class.escapes.defined.scope.display.public.option=Informar sobre clases no accesibles expuestas en la API pública
class.escapes.defined.scope.java9.modules.descriptor=La clase <code>#ref</code> no se exporta desde el módulo ''{0}''
class.escapes.defined.scope.problem.descriptor=La clase <code>#ref</code> se expone fuera de su ámbito de visibilidad #loc
class.extends.utility.class.display.name=Clase extiende clase de utilidad
class.extends.utility.class.ignore.utility.class.option=Ignorar si la clase que sobreescribe es una clase de utilidad
class.extends.utility.class.problem.descriptor=La clase <code>#ref</code> extiende la clase de utilidad ''{0}'' #loc
class.independent.of.module.display.name=Clase independiente del módulo
class.independent.of.module.problem.descriptor=La class <code>#ref</code> no tiene dependencias ni depende de su módulo #loc
class.initializer.display.name=Inicializador no 'static'
class.initializer.may.be.static.display.name=El inicializador de clase puede ser "estático"
class.initializer.may.be.static.problem.descriptor=El inicializador de clase podría ser 'estático' #loc
class.initializer.move.code.to.constructor.quickfix=Mover código de inicializador al constructor
class.initializer.option=Solo advertir cuando la clase tiene uno o más constructores
class.initializer.problem.descriptor=Inicializador no 'static' #loc
class.loader.instantiation.display.name='Instanción de ClassLoader'
class.loader.instantiation.problem.descriptor=La instanciación de <code>#ref</code> puede plantear problemas de seguridad #loc
class.may.be.interface.convert.quickfix=Convertir clase en interfaz
class.may.be.interface.display.name=Clase 'abstracta' puede ser 'interfaz'
class.may.be.interface.java8.option=Informar de clases que contienen métodos no abstractos al utilizar Java 8
class.may.be.interface.problem.descriptor=La clase abstracta <code>#ref</code> puede ser una interfaz #loc
class.name=Nombre de la clase
class.name.differs.from.file.name.display.name=El nombre de la clase difiere del nombre del archivo
class.name.differs.from.file.name.problem.descriptor=El nombre de la clase <code>#ref</code> es diferente del nombre del archivo #loc
class.name.prefixed.with.package.name.display.name=Nombre de clase prefijado con nombre de paquete
class.name.prefixed.with.package.name.problem.descriptor=El nombre de la clase <code>#ref</code> inicia con el nombre del paquete #loc
class.name.same.as.ancestor.name.display.name=Nombre de clase igual al nombre del antepasado
class.name.same.as.ancestor.name.problem.descriptor=El nombre de la clase <code>#ref</code> es el mismo que el de una de sus superclases #loc
class.naming.convention.display.name=Convención de nomenclatura de clase
class.naming.convention.element.description=Clase
class.new.instance.display.name=Llamada no segura a "Class.newInstance()"
class.new.instance.problem.descriptor=La llamada a <code>#ref()</code> puede lanzar una excepción marcada no declarada #loc
class.only.used.in.one.module.display.name=Clase usada solo desde otro módulo
class.only.used.in.one.module.problem.descriptor=La clase <code>#ref</code> solo tiene dependencias y/o dependientes en el módulo ''{0}'' #loc
class.only.used.in.one.package.display.name=Clase solamente usada desde un paquete diferente
class.only.used.in.one.package.problem.descriptor=La clase <code>#ref</code> solo tiene dependencias o dependientes en el paquete ''{0}'' #loc
class.references.subclass.display.name=Clase referencia una de sus subclases
class.references.subclass.problem.descriptor=La clase ''{0}'' referencia a la subclase <code>#ref</code> #loc
class.references.subclass.problem.descriptor.anonymous=La clase anónima referencia a la subclase <code>#ref</code> #loc
class.too.deep.display.name=Clase muy profunda en árbol de herencia
class.too.deep.inheritance.depth.limit.option=Límite de profundidad de herencia:
class.too.deep.problem.descriptor=<code>#ref</code> está muy profundo en el árbol de herencia (profundidad de herencia = {0}) #loc
class.unconnected.to.package.display.name=Clase independiente del paquete
class.unconnected.to.package.problem.descriptor=La clase <code>#ref</code> no tiene dependencias ni dependientes en su paquete
class.with.only.private.constructors.display.name=La clase con únicos constructores 'privados' debería declararse como 'final'
class.with.only.private.constructors.problem.descriptor=La clase <code>#ref</code> con solo constructores 'private' debe ser declarada 'final'
class.with.too.many.dependencies.display.name=Clase con demasiadas dependencias
class.with.too.many.dependencies.max.option=Número máximo de dependencias
class.with.too.many.dependencies.problem.descriptor=La clase ''{0}'' tiene demasiadas dependencias ({1} > {2})
class.with.too.many.dependents.display.name=Clase con demasiadas dependencias
class.with.too.many.dependents.max.option=Máximo número de dependientes
class.with.too.many.dependents.problem.descriptor=La clase ''{0}'' tiene demasiados dependientes ({1} > {2})
class.with.too.many.transitive.dependencies.display.name=Clase con demasiadas dependencias transitivas
class.with.too.many.transitive.dependencies.max.option=Número máximo de dependencias transitivas
class.with.too.many.transitive.dependencies.problem.descriptor=La clase ''{0}'' tiene demasiadas dependencias transitivas ({1} > {2})
class.with.too.many.transitive.dependents.display.name=Clase con demasiadas dependencias transitivas
class.with.too.many.transitive.dependents.max.option=Número máximo de dependientes transitivos
class.with.too.many.transitive.dependents.problem.descriptor=La clase ''{0}'' tiene demasiadas dependencias transitivas ({1} > {2})
class.without.constructor.create.quickfix=Generar constructor vacío
class.without.constructor.display.name=Clase sin constructor
class.without.constructor.problem.descriptor=La clase <code>#ref</code> no tiene constructor #loc
class.without.logger.annotations.tab=Anotaciones
class.without.logger.loggers.tab=Registradores
class.without.no.arg.constructor.display.name=Clase sin constructor sin argumentos
class.without.no.arg.constructor.ignore.option=Ignorar si la clase tiene constructor por defecto
class.without.no.arg.constructor.problem.descriptor=La clase <code>#ref</code> no tiene un constructor sin argumentos #loc
clone.doesnt.declare.clonenotsupportedexception.declare.quickfix=Añade 'CloneNotSupportedException' a la cláusula 'throws'
clone.doesnt.declare.clonenotsupportedexception.display.name='clone()' no declara 'CloneNotSupportedException'
clone.doesnt.declare.clonenotsupportedexception.problem.descriptor=<code>#ref()</code> #loc no declara 'CloneNotSupportedException'
clone.instantiates.new.array.problem.descriptor=''clone()'' crea un nuevo arreglo de {0} #loc
clone.instantiates.objects.with.constructor.display.name='clone()' instancia objetos con el constructor
clone.instantiates.objects.with.constructor.problem.descriptor=clone() crea nuevas instancias #ref #loc
clone.method.in.non.cloneable.anonymous.class.problem.descriptor=<code>#ref()</code> definido en una clase anónima no Cloneable derivada de ''{0}'' #loc
clone.method.in.non.cloneable.class.display.name=Método 'clone()' en clase no Cloneable
clone.method.in.non.cloneable.class.problem.descriptor=<code>#ref()</code> definido en la clase ''{0}'' que no esCloneable #loc
clone.method.in.non.cloneable.interface.problem.descriptor=<code>#ref()</code> definido en interfaz no clonable "{0}" #loc
clone.returns.class.type.display.name='clone()' debe tener un tipo de retorno igual a la clase que contiene
clone.returns.class.type.family.quickfix=Cambiar tipo de retorno a tipo de clase
clone.returns.class.type.problem.descriptor=''clone()'' debe tener tipo de retorno ''{0}'' #loc
clone.returns.class.type.quickfix=Cambiar el tipo de retorno a ''{0}''
cloneable.class.in.secure.context.display.name=Clase cloneable en contexto seguro
cloneable.class.in.secure.context.problem.descriptor=La clase <code>#ref</code> puede clonarse comprometiendo la seguridad #loc
cloneable.class.in.secure.context.quickfix=Generar método 'clone()' que siempre lanza una excepción
cloneable.class.without.clone.display.name=Clase Cloneable sin método 'clonar()'
cloneable.class.without.clone.ignore.option=Ignorar clases clonables debido a la herencia
cloneable.class.without.clone.ignore.when.clone.called.option=Ignorar si Cloneable es neceasario para llamar al método clone() de una superclase
cloneable.class.without.clone.problem.descriptor=La clase <code>#ref</code> es 'Cloneable' pero no define el método 'clone()'#loc
cloneable.class.without.clone.quickfix=Generar el método 'clone()'
cloneable.class.without.clone.todo.message=TODO: Copia aquí el estado mutable, para que el clon no pueda cambiar el estado interno del original
collection.added.to.self.display.name=Colección añadida a sí misma
collection.added.to.self.problem.descriptor=''{0}()'' llamada en la colección <code>#ref</code> consigo mismo como argumento #loc
collection.declared.by.class.display.name=Colección declarada por clase, no por interfaz
collection.declared.by.class.ignore.locals.option=Ignorar variables locales
collection.declared.by.class.ignore.private.members.option=Ignorar campos y métodos 'private'
collection.declared.by.class.problem.descriptor=Probablemente la declaración de <code>#ref</code> se debería debilitar a ''{0}'' #loc
collections.field.access.replaceable.by.method.call.display.name=La referencia a un campo de colección vacío puede ser reemplazada con una llamada a un método
collections.field.access.replaceable.by.method.call.fix.family.name=Reemplazar Collections.EMPTY* con una llamada de método
collections.field.access.replaceable.by.method.call.problem.descriptor=<code>#ref</code> puede ser reemplazado con ''Collections.{0}'' #loc
collections.must.have.initial.capacity.display.name=Colección sin capacidad inicial
collections.must.have.initial.capacity.problem.descriptor=<code>new #ref()</code> sin capacidad inicial #loc
commented.out.code.delete.quickfix=Eliminar comentario
commented.out.code.uncomment.quickfix=Descomentar código
comments.as.content.option=Comentarios se cuentan como contenido
comparable.implemented.but.equals.not.overridden.display.name='Comparable' implementada pero 'equals()' no sobreescrita
comparable.implemented.but.equals.not.overridden.fix.add.note.name=Añadir la nota JavaDoc 'Orden inconsistente con la igualdad'
comparable.implemented.but.equals.not.overridden.fix.generate.equals.name=Generar método 'equals()'
comparable.implemented.but.equals.not.overridden.problem.descriptor=La clase <code>#ref</code> implementa 'java.lang.Comparable' pero no sobrescribe 'equals()' #loc
comparator.not.serializable.display.name='Comparator' clase no declarada 'Serializable'
comparator.not.serializable.problem.descriptor=La clase <code>#ref</code> de comparación no está declarada como serializable #loc
comparison.of.short.and.char.display.name=Comparación de valores 'short' y 'char'
comparison.of.short.and.char.problem.descriptor=Comparación de igualdad <code>#ref</code> de los valores short y char #loc
comparison.to.nan.display.name=Comparación con 'Double.NaN' o 'Float.NaN'
comparison.to.nan.problem.descriptor1=La comparación con <code>#ref</code> siempre es falsa #loc
comparison.to.nan.problem.descriptor2=La comparación con <code>#ref</code> siempre es verdadera #loc
concrete.class.method.parameter.problem.descriptor=Parámetro ''{0}'' de la clase concreta <code>#ref</code>, #loc
concrete.class.use.display.name=Uso de clase concreta
condition.signal.display.name=Llamada a 'signal()' en vez de 'signalAll()'
condition.signal.problem.descriptor=Se debe reemplazar <code>#ref</code> con 'signalAll()'
conditional.can.be.pushed.inside.expression.display.name=El condicional puede ser agregado dentro de la expresión de rama
conditional.can.be.pushed.inside.expression.option=Ignorar cuando el condicional sea sólo argumento para una llamada a método
conditional.can.be.pushed.inside.expression.problem.descriptor=La expresión condicional puede insertarse dentro de la rama #loc
conditional.can.be.pushed.inside.expression.quickfix=Empujar la expresión condicional dentro de la rama
conditional.expression.display.name=Expresión condicional
conditional.expression.expression.context.option=Ignorar sitios donde no es posible una sentencia if
conditional.expression.option=Ignorar para asignaciones y devoluciones simples
conditional.expression.problem.descriptor=Expresión condicional <code>#ref</code> #loc
conditional.expression.quickfix=Reemplazar con sentencia 'if'
conditional.expression.with.identical.branches.collapse.quickfix=Contrae expresión condicional
conditional.expression.with.identical.branches.display.name=Expresión condicional con ramas idénticas
conditional.expression.with.identical.branches.problem.descriptor=Expresión condicional <code>#ref</code> con ramas idénticas #loc
confusing.else.option=Reportar cuando no hay más sentencias después de la sentencia 'if'
confusing.floating.point.literal.change.quickfix=Cambiar a formato canónico
confusing.floating.point.literal.display.name=Literal de punto flotante confuso
confusing.floating.point.literal.option=Ignorar literales de punto flotante en notación científica
confusing.floating.point.literal.problem.descriptor=Literal de punto flotante confuso <code>#ref</code> #loc
confusing.main.method.display.name=Método 'main()' confuso
confusing.main.method.problem.descriptor=El método <code>#ref()</code> no tiene la firma 'public static void main(String[])' #loc
confusing.octal.escape.sequence.display.name=Secuencia de escape octal confusa
confusing.octal.escape.sequence.problem.descriptor=Secuencia de escape octal <code>#ref</code> inmediatamente seguida de un dígito #loc
connection.opened.not.safely.closed.display.name=Conexión abierta pero no cerrada de forma segura
consider.static.final.fields.constant.option=Considerar constantes los campos 'static final'
constant.assert.condition.display.name=Condición constante en la sentencia 'assert'
constant.assert.condition.problem.descriptor=La aserción condicionada <code>#ref</code> es constante #loc
constant.conditional.expression.display.name=Expresión condicional constante
constant.conditional.expression.problem.descriptor=<code>#ref</code> se puede simplificar a ''{0}'' #loc
constant.conditional.expression.simplify.quickfix=Simplificar
constant.conditional.expression.simplify.quickfix.sideEffect=Extraer efectos secundarios y simplificar
constant.declared.in.abstract.class.display.name=Constante declarada en clase 'abstracta'
constant.declared.in.abstract.class.problem.descriptor=Constante <code>#ref</code> declarada en una clase abstracta #loc
constant.declared.in.interface.display.name=Constante declarada en interfaz
constant.declared.in.interface.problem.descriptor=Constante <code>#ref</code> declarada en la interfaz #loc
constant.for.zero.length.array.display.name=Uso innecesario de arrays de longitud cero
constant.for.zero.length.array.problem.descriptor=Un array de longitud cero puede ser cambiado a constante #loc
constant.for.zero.length.array.quickfix.family=Reemplazar con constante
constant.junit.assert.argument.display.name=Argumento aserción constante
constant.junit.assert.argument.problem.descriptor=El argumento <code>#ref</code> es constante #loc
constant.math.call.display.name=Llamada constante a 'Math'
constant.math.call.problem.descriptor=La llamada constante a <code>#ref()</code> se puede simplificar #loc
constant.naming.convention.element.description=Constante
constant.on.lhs.of.comparison.options.item.left=izquierda
constant.on.lhs.of.comparison.options.item.right=derecha
constant.on.lhs.of.comparison.problem.descriptor=Constante <code>#ref</code> en el lado izquierdo de la comparación #loc
constant.on.rhs.of.comparison.problem.descriptor=Constante <code>#ref</code> en el lado derecho de la comparación #loc
constant.on.side.of.comparison.display.name=Constante en el lado incorrecto de la comparación
constant.value.variable.use.display.name=Uso de variables cuyo valor es conocido por ser constante
constant.value.variable.use.problem.descriptor=El valor de <code>#ref</code> es conocido por ser constante #loc
constant.with.mutable.field.naming.convention.element.description=Constante con tipo mutable
constructor.visibility.option=Ignorar constructores con visibilidad:
continue.or.break.from.finally.block.display.name='continuar' o 'romper' dentro del bloque 'finalmente'
continue.or.break.from.finally.block.problem.descriptor=<code>#ref</code> dentro del bloque 'finally' #loc
continue.statement.display.name='sentencia continue'
continue.statement.with.label.display.name='continue' con rótulo
continue.statement.with.label.problem.descriptor=Sentencia <code>#ref</code> con etiqueta #loc
control.flow.statement.without.braces.add.quickfix=Agregar llaves a la instrucción
control.flow.statement.without.braces.display.name=Sentencia de flujo de control sin llaves
control.flow.statement.without.braces.message=Agrega llaves a la sentencia ''{0}''
control.flow.statement.without.braces.problem.descriptor=<code>{0}</code> sin llaves #loc
convert.double.unary.quickfix=Reemplazar con ''{0}{1}''
convert.empty.anonymous.to.new.fix.family.name=Quitar '{}'
convert.octal.literal.to.decimal.literal.quickfix=Convertir literal octal a literal decimal
convert.octal.literals.to.decimal.literals.quickfix=Convertir los literales octales a literales decimales
convert.system.out.to.log.call.family.name='System.out' convertir llamada a log
convert.system.out.to.log.call.name=Convertir la llamada a ''System.out'' a una llamada a ''{0}''
convert.to.variable.arity.method.quickfix=convertir a método de arity variable
copy.constructor.misses.field.display.name=Falta campo en constructor copia
copy.constructor.misses.field.problem.descriptor.1=El constructor de copia no copia el campo ''{0}''
copy.constructor.misses.field.problem.descriptor.2=El constructor de copia no copia los campos ''{0}'' y ''{1}''
copy.constructor.misses.field.problem.descriptor.3=El constructor de copias no copia los campos ''{0}'', ''{1}'' y ''{2}''
copy.constructor.misses.field.problem.descriptor.many=El constructor de copia no copia {0} campos
covariant.equals.display.name=`equals()` covariante
covariant.equals.problem.descriptor=<code>#ref()</code> deberiacute;a tomar 'Object' como su argumento #loc
create.default.branch.fix.family.name=Insertar rama 'default'
create.missing.boolean.switch.branches.fix.family.name=Crear ramas switch booleanas faltantes
create.missing.branches.with.null.branch.fix.family.name=Crear ramas faltantes y rama 'null'
create.missing.enum.switch.branches.fix.family.name=Crear ramas de switch de enumeración faltantes
create.missing.record.deconstructions.switch.branches.fix.family.name=Crear missing record deconstrucion switch branches
create.missing.sealed.class.switch.branches.fix.family.name=Crear las ramas de switch faltantes para la clase sellada
create.missing.switch.branch=Crea una rama switch faltante ''{0}''
create.missing.switch.branches=Crear ramas faltantes: {0}
create.null.branch.fix.family.name=Insertar rama 'null'
create.package.info.java.family.name=Crear 'package-info.java'
cstyle.array.method.declaration.problem.descriptor=El método <code>{0}()</code> tiene una declaración de tipo de retorno de array de estilo C #loc
cstyle.array.variable.declaration.problem.descriptor={0, choice, 1#Campo|2#Parámetro|3#Componente de registro|4#Variable local} <code>{1}</code> tiene una declaración de tipo de matriz de estilo C #loc
custom.classloader.display.name=Se ha declarado un 'ClassLoader' personalizado
custom.classloader.problem.descriptor=Custom ClassLoader clase <code>#ref</code> #loc
custom.security.manager.display.name=Custom 'SecurityManager'
custom.security.manager.problem.descriptor=Clase <code>#ref</code> #loc de Custom SecurityManager
cyclic.class.dependency.1.problem.descriptor=La clase ''{0}'' es cíclicamente dependiente de la clase ''{1}''
cyclic.class.dependency.2.problem.descriptor=La clase ''{0}'' tiene dependencia cíclica de las clases ''{1}'' y ''{2}''
cyclic.class.dependency.display.name=Dependencia de clase cíclica
cyclic.class.dependency.ignore.in.same.file=Ignorar ciclos entre clases ubicadas en el mismo archivo
cyclic.class.dependency.problem.descriptor=La clase ''{0}'' tiene una dependencia cíclica con {1} otras clases
cyclic.package.dependency.1.problem.descriptor=El paquete ''{0}'' tiene una dependencia cíclica con el paquete ''{1}''
cyclic.package.dependency.2.problem.descriptor=El paquete ''{0}'' tiene una dependencia cíclica con los paquetes ''{1}'' y ''{2}''
cyclic.package.dependency.display.name=Dependencia cíclica de paquetes
cyclic.package.dependency.problem.descriptor=El paquete ''{0}'' es cíclicamente dependiente de {1} otros paquetes
cyclomatic.complexity.display.name=Método demasiado complejo
cyclomatic.complexity.limit.option=Límite de complejidad ciclomática:
cyclomatic.complexity.problem.descriptor=Método demasiado complejo <code>#ref()</code> (complejidad ciclomática = {0}) #loc
dangling.javadoc.convert.line.comment.quickfix=Reemplazar con comentarios de línea
dangling.javadoc.convert.quickfix=Reemplazar con comentario de bloque
dangling.javadoc.delete.quickfix=Eliminar comentario suspendido
dangling.javadoc.display.name=Comentario de Javadoc provisional
dangling.javadoc.ignore.copyright.option=Ignorar los comentarios del encabezado del archivo en formato JavaDoc
dangling.javadoc.problem.descriptor=Comentario Javadoc sin contenido #loc
debug.level.and.lower.option=Debug nivel y opciones inferiores
declare.collection.as.interface.fix.family.name=Debilitar tipo
declare.collection.as.interface.quickfix=Debilitar a ''{0}''
default.not.last.case.in.switch.display.name='default' no es el último caso en 'switch'
default.not.last.case.in.switch.problem.descriptor=''default'' rama no es el último caso en ''switch'' {0} #loc
default.tostring.call.display.name=Llamada al 'toString()' predeterminado
default.tostring.call.problem.descriptor=Llamada a 'toString()' predeterminada en <code>#ref</code> #loc
delete.catch.section.fix.family.name=Eliminar bloque catch
delete.catch.section.quickfix=Eliminar la sección 'catch'
delete.import.quickfix=Eliminar importación innecesaria
delete.unnecessary.statement.fix.family.name=Quitar sentencias redundantes
deserializable.class.in.secure.context.problem.descriptor=La clase <code>#ref</code> puede deserializarse, lo que compromete la seguridad #loc
design.for.extension.display.name=Diseño para extensión
design.for.extension.problem.descriptor=El método <code>#ref()</code> puede ser sobreescrito y no tenerse en cuenta su funcionalidad #loc
diamond.can.be.replaced.with.explicit.type.arguments.name=El diamante puede ser reemplazado con argumentos de tipo explícitos
diamond.can.be.replaced.with.explicit.type.arguments.quickfix=Reemplazar '<>' con argumentos de tipo explícitos
disjoint.package.display.name=Paquete con un grafo de dependencias disjunto
disjoint.package.problem.descriptor=El paquete {0} puede descomponerse en {1} paquetes independientes
divide.by.zero.display.name=División por cero
divide.by.zero.problem.descriptor=División por cero #loc
dollar.sign.in.name.display.name=Uso de '$' en el nombre de identificador
dollar.sign.in.name.problem.descriptor=El identificador <code>#ref</code> contiene '$' #loc
double.brace.initialization.display.name=Inicialización de doble llave
double.brace.initialization.quickfix=Reemplazar con inicialización regular
double.checked.locking.display.name=Bloqueo de doble verificación
double.checked.locking.fix.family.name=Convertir el campo a volatile
double.checked.locking.problem.descriptor=Bloqueo de doble verificación #loc
double.checked.locking.quickfix=Hacer ''{0}'' volátil
double.literal.may.be.float.literal.display.name=Se puede convertir a 'float' en un literal 'float'
double.negation.display.name=Doble negación
double.negation.problem.descriptor=Doble negación en <code>#ref</code> #loc
double.negation.quickfix=Quitar doble negación
drivermanager.call.display.name=Uso del 'DriverManager' para obtener la conexión JDBC
drivermanager.call.problem.descriptor=La llamada a `DriverManager.#ref()` #loc
dumpstack.call.display.name=Llamada a 'Thread.dumpStack()'
dumpstack.call.problem.descriptor=La llamada a <code>Thread.#ref()</code> debería reemplazarse por un registro más robusto #loc
duplicate.condition.display.name=Duplicar condición
duplicate.condition.ignore.method.calls.option=Ignorar condicionales con posibles efectos secundarios
duplicate.condition.ignore.method.calls.option.description=Si se marca, las condiciones con posibles efectos colaterales (por ejemplo, llamadas a métodos desconocidos) no serán informadas. Los métodos que se sabe que producen efectos colaterales no serán informados en ningún caso.
duplicate.condition.problem.descriptor=Condición duplicada <code>#ref</code> #loc
dynamic.regex.replaceable.by.compiled.pattern.display.name=La expresión regular dinámica se puede reemplazar por un 'Patrón' compilado
dynamic.regex.replaceable.by.compiled.pattern.problem.descriptor=Se puede reemplazar <code>#ref()</code> con una construcción compilada de 'java.util.regex.Pattern' #loc
dynamic.regex.replaceable.by.compiled.pattern.quickfix=Reemplazar con llamada al método del patrón constante compilado
empty.anonymous.class.problem.descriptor=La clase anónima está vacía #loc
empty.class.display.name=Clase Vacia
empty.class.file.without.class.problem.descriptor=Archivo Java no declara ninguna clase #loc
empty.class.ignore.parameterization.option=Ignorar clase si es parametrización de un súper tipo
empty.class.initializer.delete.quickfix=Eliminar inicializador de clase vacía
empty.class.initializer.display.name=Inicializador de clase vacía
empty.class.initializer.problem.descriptor=Inicializador de clase vacío #loc
empty.class.problem.descriptor=Clase <code>#ref</code> vacía #loc
empty.enum.problem.descriptor=El enum <code>#ref</code> está vacío #loc
empty.finally.block.display.name=Bloque 'finally' vacío
empty.finally.block.problem.descriptor=Bloque <code>#ref</code> vacío #loc
empty.synchronized.statement.display.name=Sentencia 'synchronized' vacía
empty.synchronized.statement.problem.descriptor=Sentencia <code>#ref</code> vacía #loc
empty.try.block.display.name=Bloque 'try' vacío
empty.try.block.problem.descriptor=Bloque <code>#ref</code> vacío #loc
encapsulate.variable.fix.family.name=Encapsular campo
encapsulate.variable.quickfix=Encapsular variable ''{0}''
enum.singleton.problem.descriptor=La enumeración <code>#ref</code> es singleton #loc
enum.switch.statement.which.misses.cases.display.name=Sentencia 'switch' de enumeración que omite casos
enum.switch.statement.which.misses.cases.option=Ignorar sentencias switch con una rama por defecto
enum.switch.statement.which.misses.cases.problem.descriptor=La sentencia <code>#ref</code> para el tipo enumeración ''{0}'' pierde casos: {1} #loc
enum.switch.statement.which.misses.cases.problem.descriptor.single=La sentencia <code>#ref</code> en el tipo enumerado ''{0}'' omite el caso ''{1}'' #loc
enumerated.class.display.name=Clase enumerada
enumerated.class.naming.convention.element.description=Clase de enumeración
enumerated.class.problem.descriptor=Clase enumerada <code>#ref</code> #loc
enumerated.constant.naming.convention.element.description=Constante enumerada
enumeration.can.be.iteration.display.name=La enumeración se puede iterar
enumeration.can.be.iteration.problem.descriptor=<code>#ref()</code> se puede reemplazar por la construcción ''{0}'' #loc
enumeration.can.be.iteration.quickfix=Reemplazar con la construcción 'Iterador'
equality.to.safe.equals.quickfix=Reemplazar '==' por 'equals()' de seguridad nula
equals.between.inconvertible.types.display.name='equals()' entre objetos de tipos inconvertibles
equals.between.inconvertible.types.mutual.subclass.option=Advertencia si no se encuentra subclase mutua
equals.between.inconvertible.types.no.mutual.subclass.problem.descriptor=No se encontró una clase que sea un subtipo de ''{0}'' y ''{1}'' #loc
equals.between.inconvertible.types.problem.descriptor=<code>#ref</code> entre objetos de tipos inconvertibles ''{0}'' y ''{1}'' #loc
equals.called.on.array.display.name=equals() llamada en array
equals.called.on.array.problem.descriptor=<code>#ref()</code> entre arreglos probablemente debería ser 'Arrays.equals()' #loc
equals.called.on.enum.constant.display.name='equals()' llamado en valor de enumeración
equals.called.on.enum.constant.problem.descriptor=<code>#ref()</code> llamado en el valor de enumeración #loc
equals.called.on.suspicious.object.display.name='equals()' llamado en clases que no lo sobreescriben
equals.called.on.suspicious.object.fix.family.name=Reemplazar por comparación de valores representativos
equals.called.on.suspicious.object.fix.name=Reemplazar por una comparación de resultados de llamada de ''{0}()''
equals.called.on.suspicious.object.problem.descriptor=Llamada sospechosa a ''equals()'' en el objeto ''{0}''
equals.doesnt.check.class.parameter.display.name='método equals()' que no comprueba la clase del parámetro
equals.doesnt.check.class.parameter.problem.descriptor=<code>#ref()</code> debe comprobar la clase del paraacute;metro #loc
equals.replaceable.by.objects.call.display.name='exppresión equals()' reemplazable por la expresión 'Objects.equals()'
equals.replaceable.by.objects.call.problem.descriptor=<code>#ref</code> reemplazable por expresión 'Objects.equals()' #loc
equals.replaceable.by.objects.check.not.null.option=Resaltar expresiones como 'a != null && a.equals(b)'
equals.with.itself.display.name='equals()' llamado en sí mismo
equals.with.itself.option=Avisar de assertions de test solamente en tipos de clase de librería final o primitivas
equals.with.itself.option.description=Si está marcada, se omitirán algunos casos como <code>assertEquals(myObj, myObj)</code> para evitar advertencias en las pruebas que verifican la corrección del método <code>equals()</code>.
equals.with.itself.problem.descriptor=<code>#ref()</code> invocado sobre sí mismo
error.rethrown.display.name='Error' no ha sido relanzado
error.rethrown.problem.descriptor=Error <code>#ref</code> no relanzado #loc
exception.from.catch.which.doesnt.wrap.display.name='throw' dentro del bloque 'catch' que ignora la excepción capturada
exception.from.catch.which.doesnt.wrap.problem.descriptor=<code>#ref</code> dentro del bloque 'catch' ignora la excepción capturada #loc
exception.from.catch.which.doesntwrap.ignore.cant.wrap.option=Ignorar si la excepción lanzada no puede envolver una excepción
exception.from.catch.which.doesntwrap.ignore.option=Ignorar si el resultado de la llamada al método de excepción está en uso
exception.name.doesnt.end.with.exception.display.name=El nombre de la clase de excepción no termina con 'Exception'
exception.name.doesnt.end.with.exception.problem.descriptor=El nombre de la clase de excepción <code>#ref</code> no termina con 'Exception' #loc
exception.package.display.name=Paquete de excepciones
exception.package.problem.descriptor=El paquete ''{0}'' sólo contiene clases Exception
explicit.array.to.string.problem.descriptor=Llamada a '#ref()' en el arreglo #loc
expression.can.be.replaced.no.quotes.problem.descriptor={0} puede reemplazarse con {1}
expression.can.be.replaced.problem.descriptor=<code>#ref</code> puede ser reemplazado con ''{0}'' #loc
expression.may.be.factorized.display.name=La expresión puede ser factorizada
extend.exception.fix.family.name=Hacer que clase extienda 'Excepción'
extended.for.statement.display.name=Sentencia 'for' extendida
extended.for.statement.problem.descriptor=Instrucción <code>#ref</code> extendida #loc
extended.for.statement.replace.quickfix=Reemplazar con sentencias 'for' clásicas
extends.annotation.display.name=Clase extiende interfaz anotación
extends.annotation.interface.problem.descriptor=La interfaz ''{0}'' hereda de la interfaz de anotación <code>#ref</code> #loc
extends.annotation.problem.descriptor=La clase ''{0}'' implementa la interfaz de anotación <code>#ref</code> #loc
extends.concrete.collection.display.name=Clase se extiende explícitamente de una clase 'Colección'
extends.concrete.collection.problem.descriptor=La clase <code>#ref</code> extiende de forma explícita ''{0}'' #loc
extends.object.display.name=La clase extiende 'Object' de forma explícita
extends.object.problem.descriptor=La clase <code>#ref</code> extiende 'java.lang.Object' explícitamente #loc
extends.object.remove.quickfix=Elimina la redundancia 'extends Object'
extends.thread.display.name=La clase extiende directamente 'Thread'
extends.thread.problem.descriptor=La clase <code>#ref</code> extiende de 'java.lang.Thread' directamente #loc
extends.throwable.display.name=La clase se extiende directamente desde 'Throwable'
extends.throwable.problem.descriptor=La clase <code>#ref</code> extiende directamente 'java.lang.Throwable' #loc
externalizable.with.serialization.methods.display.name=Clase externalizable con ‘readObject()' o ‘writeObject()'
externalizable.with.serialization.methods.problem.descriptor.both=Externalizable {0, choice, 1#clase|2#interfaz|3#clase anónima derivada de|4#tipo de anotación|5#enum|6#record} <code>#ref</code> define ''readObject()'' y ''writeObject()'' #loc
externalizable.with.serialization.methods.problem.descriptor.read=Externalizable {0, choice, 1#clase|2#interfaz|3#clase anónima derivada de|4#tipo de anotación|5#enumeración|6#registro} <code>#ref</code> define 'readObject()' #loc
externalizable.with.serialization.methods.problem.descriptor.write=Externalizable {0, choice, 1#clase|2#interfaz|3#clase anónima derivada de|4#tipo de anotación|5#enumeración|6#registro} <code>#ref</code> define ''writeObject()'' #loc
externalizable.without.public.no.arg.constructor.display.name=Clase 'Externalizable' sin un constructor 'public' sin argumentos
externalizable.without.public.no.arg.constructor.problem.descriptor=La clase externalizable <code>#ref</code> no tiene un constructor sin argumentos 'público' #loc
extract.method.quickfix=Extractar método
extract.parameter.as.local.variable.quickfix=Extraer parámetro como variable local
fallthru.in.switch.statement.display.name=Estructura case omitida en sentencia 'switch'
fallthru.in.switch.statement.problem.descriptor=Control pasante en instrucción 'switch' #loc
fallthru.in.switch.statement.quickfix=Agregar ''{0}''
feature.envy.display.name=Envidia de características
feature.envy.problem.descriptor=Clase ''{0}'' accedida repetidamente en método <code>#ref()</code> #loc
field.accessed.synchronized.and.unsynchronized.display.name=Campo accedido en contextos 'synchronized' y no sincronizados
field.accessed.synchronized.and.unsynchronized.option=Los getter y setter simples tambíen se consideran accesos a campos
field.accessed.synchronized.and.unsynchronized.problem.descriptor=El campo <code>#ref</code> se accede en contextos sincronizados y no sincronizados #loc
field.count.inspection.include.constant.fields.in.count.checkbox=Incluir campos constantes en el conteo
field.count.inspection.include.enum.constants.in.count=Incluir constantes de enumeración en el conteo
field.count.inspection.static.final.fields.count.as.constant.checkbox=Los campos 'static final' cuentan como constantes
field.has.setter.but.no.getter.display.name=Campo tiene setter, pero no getter
field.has.setter.but.no.getter.problem.descriptor=El campo <code>#ref</code> tiene setter pero ningún getter #loc
field.has.static.modifier.problem.descriptor=El campo ''{0}'' tiene un modificador ''static''
field.incorrect.type.problem.descriptor=El campo ''{0}'' no tiene el tipo ''{1}''
field.may.be.final.display.name=Campo puede ser 'final'
field.may.be.final.problem.descriptor=Campo <code>#ref</code> puede ser 'final' #loc
field.may.be.static.display.name=El campo se puede hacer 'estático'
field.may.be.static.problem.descriptor=El campo <code>#ref</code> puede ser 'estático' #loc
field.missing.volatile.modifier.problem.descriptor=El campo ''{0}'' no tiene modificador ''volatile''
field.name.hides.in.superclass.display.name=El campo de la subclase oculta el campo de la superclase
field.name.hides.in.superclass.ignore.option=Ignorar campos no accesibles
field.name.hides.in.superclass.ignore.static.field.option=Ignorar campos estáticos que ocultan campos estáticos
field.name.hides.in.superclass.problem.descriptor=El campo <code>#ref</code> oculta el campo <code>#loc</code> en la superclase
field.naming.convention.display.name=Convención de nombres de campos
field.not.found.in.class.problem.descriptor=No se encontró el campo llamado ''{0}'' en la clase ''{1}''
final.class.display.name=Clase no acepta herencia
final.class.problem.descriptor=Clase "{0}" declara <code>#ref</code> #loc
final.method.display.name=El método no se puede sobrecargar
final.method.in.final.class.display.name=método `final` en clase `final`
final.method.in.final.class.problem.descriptor=Método declarado <code>#ref</code> en clase 'final' #loc
final.method.problem.descriptor=El método está definido como <code>#ref</code> #loc
final.private.method.display.name=método 'privada' declarado 'final'
final.private.method.problem.descriptor=método 'private' declarado <code>#ref</code> #loc
final.static.method.display.name='static' método declarado 'final'
final.static.method.problem.descriptor=método 'estático' declarado <code>#ref</code> #loc
finalize.called.explicitly.display.name='finalize()' llamado explícitamente
finalize.called.explicitly.problem.descriptor=El método <code>#ref()</code> se llama explícitamente #loc
finalize.declaration.display.name='finalize()' no debería ser sobreescrito
finalize.declaration.problem.descriptor='finalize()' no debería ser sobreescrito #loc
finalize.not.declared.protected.display.name='finalize()' debe ser protegido, no público
finalize.not.declared.protected.problem.descriptor=finalize() debe tener acceso protected, no público #loc
finally.block.cannot.complete.normally.display.name=Bloque `finally` que no se puede completar normalmente
finally.block.cannot.complete.normally.problem.descriptor=El bloque <code>#ref</code> no puede completarse normalmente #loc
fix.add.argument.family.name=Añadir argumento
fix.add.argument.name=Añadir argumento ''{0}''
fix.eliminate.folded.if.present.description=La llamada 'ifPresent()' plegada se puede eliminar
fix.eliminate.folded.if.present.name=Eliminar llamada 'ifPresent()' plegada
fix.replace.map.with.flat.map.description='map()' puede ser reemplazado por 'flatMap()'
flip.comparison.quickfix=Invertir comparación
floating.point.equality.display.name=Comparación de igualdad de punto flotante
floating.point.equality.problem.descriptor=<code>#ref</code>: valores de punto flotante comparados por igualdad exacta #loc
for.can.be.foreach.display.name='for' bucle puede ser reemplazado por bucle 'foreach' mejorado
for.can.be.foreach.fix.no.indexed=No reportar bucles 'java.util.List' indexados
for.can.be.foreach.option=Informar bucles 'java.util.List' indexados
for.can.be.foreach.option2=No notificar iteraciones sobre colecciones sin tipos
for.can.be.foreach.problem.descriptor=Buble con <code>#ref</code> se puede reemplazar con 'for' mejorado #loc
for.loop.replaceable.by.while.display.name='for' puede sustituirse por un bucle 'while'
for.loop.replaceable.by.while.ignore.option=Ignorar bucles 'infinite' sin condiciones
for.loop.replaceable.by.while.problem.descriptor=El bucle <code>#ref</code> puede sustituirse por un bucle 'while' #loc
for.loop.with.missing.component.collection.loop.option=Ignorar iteraciones de colección
for.loop.with.missing.component.display.name=Bucle 'for' con componentes faltantes
for.loop.with.missing.component.problem.descriptor1=La sentencia <code>#ref</code> carece de inicializador #loc
for.loop.with.missing.component.problem.descriptor2=<code>#ref</code> la instrucción carece de condición #loc
for.loop.with.missing.component.problem.descriptor3=La declaración <code>#ref</code> carece de actualización #loc
for.loop.with.missing.component.problem.descriptor4=La declaración <code>#ref</code> carece de inicializador y condición #loc
for.loop.with.missing.component.problem.descriptor5=Declaración <code>#ref</code> carece de inicializador y actualización #loc
for.loop.with.missing.component.problem.descriptor6=La declaración <code>#ref</code> carece de una condición y actualización #loc
for.loop.with.missing.component.problem.descriptor7=La declaración <code>#ref</code> carece de inicializador, condición y actualización #loc
foreach.replace.quickfix=Sustituir con 'for' mejorado
format.string.error.duplicate.flag=bandera duplicada ''{0}'' en ''{1}''
format.string.error.flags.not.allowed={2, choice, 1#marcador|1<marcadores} ''{0}'' no permitido en ''{1}''
format.string.error.illegal.flag.combination=Combinación ilegal de parámetros {0} y {1} en {2}
format.string.error.illegal.position.specifier=Especificador de posición ilegal ''{0}'' en ''{1}''
format.string.error.invalid.precision=precisión no válida especificada en ''{0}''
format.string.error.left.justify.no.width=Se utilizó la bandera de justificación a la izquierda ''-'' pero no se especificó el ancho en ''{0}''
format.string.error.precision.not.allowed=precisión (''{0}'') no permitida en ''{1}''
format.string.error.previous.element.not.found=Se ha utilizado la marca anterior '<' pero no se encontró un especificador de formato anterior para ''{0}''
format.string.error.unexpected.flag=carácter inesperado ''{0}'' en ''{1}''
format.string.error.unknown.conversion=Conversión desconocida en ''{0}''
format.string.error.unnecessary.position.specifier=Especificador de posición de argumento innecesario ''{0}'' en ''{1}''
format.string.error.width.not.allowed=ancho (''{0}'') no permitido en ''{1}''
format.string.error.zero.padding.no.width=Se usa el indicador de relleno cero ''0'', pero no se especifica el ancho en ''{0}''
gc.call.display.name=Llamada a 'System.gc()' o 'Runtime.gc()'
gc.call.problem.descriptor=<code>#ref</code> no debería llamarse en el código de producción #loc
generate.to.string.quick.fix.family.name=Generar
generate.to.string.quick.fix.text=Generar toString()
groups.of.modules.loaded.together.description=Cada línea especifica una lista separada por comas de nombres de módulos que se sabe que son cargados por el mismo cargador de clases.
groups.of.modules.loaded.together.label=Grupos de módulos que se cargan juntos:
hardcoded.file.separator.display.name=Separador de archivos codificado de forma rígida
hardcoded.file.separator.ignore.methods.option=Ignorar argumentos para los siguientes métodos:
hardcoded.file.separator.include.option=Incluir 'example/*' en los tipos de medio MIME reconocidos
hardcoded.file.separator.problem.descriptor=Separador de archivos codificado <code>#ref</code> #loc
hardcoded.line.separator.display.name=Separador de línea codificado
hardcoded.line.separator.problem.descriptor=Separador de línea codificado <code>#ref</code> #loc
hibernate.resource.opened.not.closed.display.name=Recurso Hibernate abierto pero no cerrado de forma segura
html.tag.can.be.javadoc.tag.display.name='<code>...</code>' puede ser reemplazado con '{@code ...}'
html.tag.can.be.javadoc.tag.problem.descriptor=La etiqueta <code>#ref...&lt;/code&gt;</code> puede ser reemplazada por '{@code ...}' #loc
i.o.resource.opened.not.closed.display.name=Recurso de E/S abierto pero no cerrado de forma segura
if.can.be.assertion.name=La sentencia se puede reemplazar por 'assert' u 'Objects.requireNonNull'
if.can.be.assertion.replace.with.assertion.quickfix=Reemplasar declaración con declaración 'assert'
if.can.be.assertion.replace.with.objects.requirenonnull.quickfix=Reemplazar sentencia con 'Objects.requireNonNull()'
if.can.be.switch.display.name='if' puede reemplazarse por 'switch'
if.can.be.switch.enum.option=Sugerir switch en enumeraciones
if.can.be.switch.int.option=Sugerir switch en enteros
if.can.be.switch.minimum.branch.option=Cantidad mínima de ramas de la condición 'if':
if.can.be.switch.null.safe.option=Sugerir solo en expresiones null-safe
if.can.be.switch.problem.descriptor=La declaración <code>#ref</code> se puede reemplazar por una declaración 'switch' #loc
if.may.be.conditional.problem.descriptor=<code>#ref</code> se puede reemplazar con una expresión condicional #loc
if.may.be.conditional.quickfix=Reemplazar con expresión condicional
if.may.be.factorized.problem.descriptor=<code>#ref</code> se puede factorizar #loc
if.may.be.factorized.quickfix=Sustituir por expresión factorizada
if.statement.with.identical.branches.display.name='if' con ramas idénticas o partes comunes
if.statement.with.too.many.branches.display.name=sentencia `if` con demasiadas ramas
if.statement.with.too.many.branches.max.option=Número máximo de ramas:
if.statement.with.too.many.branches.problem.descriptor=<code>#ref</code> tiene demasiadas ramas ({0}) #loc
ignore.accesses.from.equals.method=Ignorar accesos del método 'equals()'
ignore.accesses.from.the.same.class=Ignorar accesos desde la misma clase
ignore.anonymous.inner.classes=Ignorar clases internas anónimas
ignore.boolean.methods.in.an.interface.option=Ignorar métodos booleanos en un @interface
ignore.branches.of.switch.statements=Ignorar ramas de sentencias 'switch'
ignore.calls.to.property.getters=Ignorar llamadas a getters de propiedad
ignore.calls.to.static.methods=Ignorar llamadas a métodos estáticos
ignore.classes.annotated.by=Ignorar clases anotadas por:
ignore.classes.in.hierarchy.column.name=Ignorar las subclases de:
ignore.cloneable.option=Ignorar 'java.lang.Cloneable'
ignore.constructor.method.references=Ignorar referencias a métodos de constructor que producen AutoCloseable
ignore.enhanced.for.loop.statements=Ignorar bucles for mejorados
ignore.equals.hashcode.and.tostring=Ignorar métodos 'equals()', 'hashCode()' y 'toString()'
ignore.exceptions.declared.on.library.override.option=Ignorar excepciones declaradas en métodos que sobreescriben un método de biblioteca(&L)
ignore.for.equals.methods.option=Ignorar para métodos 'equals()'(&E)
ignore.getters.returning.resource=Ignorar gets que devuelven recursos
ignore.guard.clauses.option=Ignorar cláusulas de protección
ignore.if.annotated.by=Ignorar si lo anota:
ignore.in.module.statements.option=Ignorar en sentencias de módulo Java 9
ignore.instanceof.on.library.classes=Ignorar instancia en clases de biblioteca
ignore.methods.in.anonymous.classes=Ignorar métodos en clases anónimas
ignore.methods.overriding.super.method=Ignorar métodos que sobrescriben/implementen un método super
ignore.methods.with.boolean.return.type.option=Ignorar métodos con tipo de retorno 'java.lang.Boolean'(&B)
ignore.overflowing.byte.casts.option=Ignorar conversiones de 128 a 255 en bytes
ignore.parentheses.around.single.no.formal.type.lambda.parameter=Ignorar paréntesis alrededor de un solo parámetro lambda sin tipo formal
ignore.private.methods.option=Ignorar asignaciones en y retornos de métodos privados
ignore.serializable.option=Ignorar 'java.io.Serializable'
ignore.single.field.static.imports.option=Ignorar importaciones estáticas de campos individuales(&F)
ignore.single.method.static.imports.option=Ignorar importaciones estáticas con un único método(&M)
ignore.trivial.finalizers.option=Ignorar para implementaciones triviales de "finalize()"
ignored.autocloseable.types.label=Tipos de recursos AutoCloseable ignorados:
ignored.class.hierarchies.border.title=Ignorar subclases de:
ignored.class.label=Clases ignoradas (incluidas las subclases):
ignored.class.names=Ignorar clases (incluyendo subclases)
ignored.io.resource.types.label=Tipos de recurso E/S ignorados:
implicit.array.to.string.display.name=La llamada a 'toString()' en el array
implicit.array.to.string.fix.family.name=Hacer Array.toString() implícito
implicit.array.to.string.method.call.problem.descriptor=Llamada implícita a 'toString()' en el array retornado por llamada a <code>#ref</code> #loc
implicit.array.to.string.problem.descriptor=Llamada implícita a 'toString()' en el array <code>#ref</code> #loc
implicit.array.to.string.quickfix=Envolver con expresión ''{0}''
implicit.call.to.super.display.name=Llamada implícita a 'super()'
implicit.call.to.super.ignore.option=Ignorar para subclases directas de 'java.lang.Object'
implicit.call.to.super.make.explicit.quickfix=Hacer explícita la llamada a 'super()'
implicit.call.to.super.problem.descriptor=Llamada implícita a 'super()' #loc
implicit.default.charset.usage.constructor.problem.descriptor=La llamada a <code>new #ref()</code> utiliza el charset predeterminado de la plataforma
implicit.default.charset.usage.display.name=Conjunto de caracteres por defecto implícito
implicit.default.charset.usage.fix.family.name=Especificar codificación UTF-8
implicit.default.charset.usage.problem.descriptor=La llamada a <code>#ref()</code> usa el juego de caracteres predeterminado de la plataforma
implicit.numeric.conversion.assignment.problem.descriptor=Conversión numérica implícita del valor de resultado de ''{0}'' a ''{1}'' #loc
implicit.numeric.conversion.display.name=Conversión numérica implícita
implicit.numeric.conversion.ignore.char.conversion.option=Ignorar las conversiones desde/hacia 'char'
implicit.numeric.conversion.ignore.constant.conversion.option=Ignorar las conversiones desde constantes y literales
implicit.numeric.conversion.ignore.widening.conversion.option=Ignorar conversiones implícitas de ampliación
implicit.numeric.conversion.make.explicit.quickfix=Hacer conversión explícita
implicit.numeric.conversion.problem.descriptor=Conversión numérica implícita de <code>#ref</code> de ''{0}'' a ''{1}'' #loc
import.display.name='*' importar
import.from.same.package.display.name=Importación innecesaria del mismo paquete
import.from.same.package.problem.descriptor=Importación innecesaria del mismo paquete <code>#ref</code> #loc
import.problem.descriptor=Importación de paquete <code>#ref</code> #loc
include.java.system.classes.option=Incluir acoplamientos a clases del sistema java
include.library.classes.option=Incluir adjuntes a las clases de la biblioteca
incompatible.mask.operation.display.name=Operación de máscara de bits incompatible
incompatible.mask.operation.problem.descriptor.always.false=<code>#ref</code> siempre es falso #loc
incompatible.mask.operation.problem.descriptor.always.true=<code>#ref</code> siempre es verdadero #loc
incorrect.date.format.fix.family.name=Corregir el formato de la fecha incorrecto
increment.decrement.display.name=Resultado usado para '++' o '--'
increment.decrement.used.as.expression.fix.family.name=Extraer a declaración separada
increment.decrement.used.as.expression.quickfix=Extraer ''{0}'' a declaración separada
inequality.to.safe.not.equals.quickfix=Reemplazar '!=' con null-safe '!equals()'
infinite.loop.statement.display.name=Sentencia de bucle infinito
infinite.loop.statement.problem.descriptor=La sentencia <code>#ref</code> no puede completarse sin arrojar una excepción #loc
infinite.recursion.display.name=Recursión infinita
infinite.recursion.problem.descriptor=El Método <code>#ref()</code> recursea infinitamente, y sólo puede terminar lanzando una excepción #loc
info.level.and.lower.option=nivel de información y niveles inferiores
inline.call.quickfix=Llamada en línea
inline.variable.quickfix=Variable en línea
inner.class.field.hides.outer.display.name=El campo de la clase interna oculta el nombre de visualización de la clase externa
inner.class.field.hides.outer.ignore.option=Ignorar campos externos no visibles desde la clase interna
inner.class.field.hides.outer.problem.descriptor=El campo de clase interna <code>#ref</code> oculta el campo de clase externa #loc
inner.class.may.be.static.display.name=La clase interna puede ser 'static'
inner.class.may.be.static.problem.descriptor=La clase interna <code>#ref</code> puede ser 'estática' #loc
inner.class.on.interface.display.name=Clase interna de la interfaz
inner.class.on.interface.ignore.option=Ignorar las interfaces internas de las interfaces
inner.class.on.interface.problem.descriptor=La interfaz ''{0}'' tiene la clase interna <code>#ref</code> #loc
inner.class.referenced.via.subclass.display.name=Clase interna referenciada a través de subclase
inner.class.referenced.via.subclass.problem.descriptor=Clase interna <code>#ref</code> declarada en la clase ''{0}'' pero referenciada vía la subclase ''{1}'' #loc
inner.class.referenced.via.subclass.quickfix=Racionalizar acceso a clase interna
inner.class.too.deeply.nested.display.name=La clase interna está anidada demasiado profundamente
inner.class.too.deeply.nested.nesting.limit.option=Límite de anidación:
inner.class.too.deeply.nested.problem.descriptor=<code>#ref</code> está anidada demasiado profundamente (nivel de anidación = {0}) #loc
inspection.autocloseable.resource.ignored.methods.title=Ignorar instancias AutoCloseable retornadas de estos métodos:
inspection.byte.array.output.stream.to.string.message=Conversión ineficiente de ByteArrayOutputStream
inspection.case.mismatch.display.name=Caso no coincidente en operación 'Cadena'
inspection.case.mismatch.message.arg.is.lower=El método ''{0}()'' siempre devuelve {1}: el argumento contiene un símbolo en minúsculas mientras que el calificador no contiene símbolos en minúsculas
inspection.case.mismatch.message.arg.is.upper=El método ''{0}()'' devuelve {1}: el argumento contiene un símbolo en mayúsculas mientras que el calificador no contiene símbolos en mayúsculas
inspection.case.mismatch.message.label.is.lower=El bloque switch no es alcanzable: la etiqueta contiene un símbolo en minúsculas mientras que el selector es solo en mayúsculas
inspection.case.mismatch.message.label.is.upper=La rama switch es inalcanzable: la etiqueta contiene un símbolo en mayúsculas mientras que el selector solo admite minúsculas
inspection.cast.can.be.replaced.with.variable.display.name=El cast puede reemplazarse por el nombre para mostrar de la variable
inspection.cast.can.be.replaced.with.variable.family.name=Sustituir conversión por variable
inspection.cast.can.be.replaced.with.variable.message=Se puede utilizar la variable ''{0}'' en lugar de ''{1}''
inspection.catch.ignores.exception.display.name=El bloque Catch puede ignorar la excepción
inspection.catch.ignores.exception.empty.message=Bloque <code>#ref</code> vacío #loc
inspection.catch.ignores.exception.option.comments=No advertir cuando el bloque 'catch' contiene un comentario
inspection.catch.ignores.exception.option.ignored.used=No mostrar advertencia cuando la excepción nombrada 'ignore(d)' no es ignorada realmente
inspection.catch.ignores.exception.option.nonempty=No advertir cuando el bloque 'catch' no está vacío
inspection.catch.ignores.exception.unused.message=Parámetro 'catch' no usado <code>#ref</code> #loc
inspection.catch.ignores.exception.used.message=El parámetro 'catch' llamado <code>#ref</code> se usa #loc
inspection.catch.ignores.exception.vm.ignored.message=Excepción inesperada de la máquina virtual como ''{0}'' se puede ignorar en un bloque <code>#ref</code> #loc
inspection.collection.must.have.initial.capacity.initializers.option=No reportar inicializadores de campo
inspection.commented.out.code.disable.short.fragments=No informar fragmentos cortos
inspection.commented.out.code.display.name=Código comentado
inspection.commented.out.code.min.lines.options=Líneas mínimas de código
inspection.commented.out.code.problem.descriptor=Código comentado ({0} {0, choice, 1#línea|1<líneas})
inspection.common.if.parts.description.complete.duplicate=La instrucción ''if'' se puede contraer{0}
inspection.common.if.parts.description.complete.duplicate.side.effect=La instrucción 'if' se puede colapsar con la extracción de efectos secundarios
inspection.common.if.parts.description.variables.only=Las variables se pueden extraer de ''si''{0}
inspection.common.if.parts.description.whole.branch=Se puede extraer la parte común eliminando la rama {0}
inspection.common.if.parts.description.with.variables.extract=Se pueden extraer a partir de ''if''{0} partes comunes con variables
inspection.common.if.parts.description.without.variables.extract=Se puede extraer la parte común del "if"{0}
inspection.common.if.parts.message.complete.duplicate=Contraer sentencia ''if''{0}
inspection.common.if.parts.message.complete.duplicate.side.effect=Contraer instrucción 'if' y extraer efecto secundario
inspection.common.if.parts.message.variables.only=Extraer variables desde ''if''{0}
inspection.common.if.parts.message.whole.branch=Extrae la parte común eliminando la rama{0}
inspection.common.if.parts.message.with.variables.extract=Extraer parte común con variables de ''if''{0}
inspection.common.if.parts.message.without.variables.extract=Extraer parte común del ''if''{0}
inspection.common.subexpression.in.switch.display.name=Subexpresión común extraíble desde 'switch'
inspection.common.subexpression.in.switch.fix.family.name=Bajar expresión 'switch'
inspection.comparator.combinators.description=Puede reemplazarse con una cadena 'Comparator'
inspection.comparator.combinators.description2=Puede reemplazarse por ''{0}''
inspection.comparator.combinators.fix.chain=Reemplazar con cadena 'Comparator'
inspection.condition.covered.by.further.condition.descr=La condición ''{0}'' está cubierta por {1, choice, 1#condición ''''{2}''''|2#condiciones} posteriores
inspection.constant.expression.display.name=Se puede evaluar una expresión constante
inspection.constant.expression.fix.family.name=Calcular valor constante
inspection.constant.expression.fix.name=Calcular valor constante de ''{0}''
inspection.constant.expression.fix.name.short=Reemplazar con valor constante
inspection.constant.expression.message=La expresión constante se puede evaluar como ''{0}''
inspection.constant.expression.report.compile.time=Solo reportar constantes de tiempo de compilación
inspection.constant.expression.report.compile.time.description=Por defecto, la inspección puede evaluar algunas constantes que implican llamadas a métodos de biblioteca, o incluso deducir el valor constante según el código circundante. Marca esta opción para informar sólo constantes en tiempo de compilación, según la especificación de lenguaje Java.
inspection.constant.expression.skip.non.literal=No reportar expresiones que contengan referencias a constantes definidas
inspection.constant.expression.skip.non.literal.description=Ignorar las expresiones que contengan referencias a operandos que no sean literales, como campos y variables.
inspection.deconstruction.can.be.used.display.name=Se puede utilizar el patrón de registro
inspection.deconstruction.can.be.used.fix.family.name=Reemplazar con patrón de registro
inspection.deconstruction.can.be.used.message=Puede reemplazarse con un patrón de registro
inspection.empty.catch.block.generate.body=Generar bloque 'catch' desde una plantilla
inspection.empty.class.ignore.subclasses.option=Ignorar subclases de {0}
inspection.enhanced.for.with.record.pattern.can.be.used.components.option=Máximo número de componentes de registro para deconstruir:
inspection.enhanced.for.with.record.pattern.can.be.used.display.name=Patrón Enhanced 'for' con un registro puede utilizarse
inspection.enhanced.for.with.record.pattern.can.be.used.fix.family.name=Reemplazar por un patrón de registro
inspection.enhanced.for.with.record.pattern.can.be.used.level.option=Límite de profundidad de anidamiento:
inspection.enhanced.for.with.record.pattern.can.be.used.maximum.depth.disabled=No sugerir para patrones con {0} y más patrones anidados
inspection.enhanced.for.with.record.pattern.can.be.used.maximum.number.disabled=No sugerir para registros con {0} o más Componentes
inspection.enhanced.for.with.record.pattern.can.be.used.message=Puede ser reemplazado con for mejorado con un patrón de registro
inspection.enhanced.for.with.record.pattern.can.be.used.not.used.option=Número máximo de componentes de registro no utilizados:
inspection.excessive.range.check.fix.family.name=Simplificar comprobación de rango excesivo
inspection.excessive.range.check.message=Se puede reemplazar con ''{0}''
inspection.explicit.chrono.field.display.name=Las llamadas a métodos 'java.time' con argumentos 'ChronoField' o 'ChronoUnit' explícitos pueden simplificarse
inspection.explicit.chrono.field.family.name=Simplifique las llamadas con los argumentos explícitos 'ChronoField' o 'ChronoUnit'
inspection.explicit.chrono.field.problem.descriptor=Las llamadas con argumentos explícitos 'ChronoField' o 'ChronoUnit' pueden simplificarse
inspection.if.statement.missing.break.in.loop.description=El bucle puede terminar después de que se cumpla la condición
inspection.if.statement.missing.break.in.loop.name=Salida anticipada en bucle en la condición 'if'
inspection.if.statement.missing.break.in.loop.quickfix=Añadir 'break'
inspection.incorrect.date.format.display.name=Patrón de "DateTimeFormat" incorrecto
inspection.incorrect.date.format.message.literal=Apertura de comilla simple ({0}) sin una comilla simple de cierre posterior
inspection.incorrect.date.format.message.padding=El modificador de relleno ''{0}'' no tiene letras de patrón consecutivas
inspection.incorrect.date.format.message.reserved.character=Utilización del carácter reservado ''{0}''
inspection.incorrect.date.format.message.unpaired=Cerrar el <code>#ref</code>sin abrir primero el ''{0}''
inspection.incorrect.date.format.message.unsupported=Carácter de patrón no admitido ''{0}''
inspection.incorrect.date.format.too.few.letters=Muy pocas letras consecutivas del patron ''{0}''; mínimo: {1}; especificado: {2}
inspection.incorrect.date.format.too.many.letters=Demasiadas letras de patrón consecutivas ''{0}''; máximo: {1}; especificado: {2}
inspection.incorrect.date.format.wrong.number.of.letters=Número incorrecto de letras consecutivas del patrón ''{0}''; permitido: {1}; especificado: {2}
inspection.incorrect.message.custom.classes.methods=Métodos MessageFormat personalizados:
inspection.incorrect.message.format.choice.limit.incorrect=El límite inferior ''{0}'' del patrón choice es incorrecto
inspection.incorrect.message.format.choice.limit.not.found=Límite inferior vacío en patrón choice
inspection.incorrect.message.format.display.name=Patrón 'MessageFormat' incorrecto
inspection.incorrect.message.format.incorrect.index=Índice ''{0}'' incorrecto
inspection.incorrect.message.format.incorrect.order.choice=Los límites inferiores no están en orden ascendente en el patrón de elección
inspection.incorrect.message.format.incorrect.quotes.number=Probablemente haya un número incorrecto de comillas. Se imprimirán más de una comilla
inspection.incorrect.message.format.not.found.argument=No se encontró el argumento para el índice ''{0}''
inspection.incorrect.message.format.not.found.arguments=No hay argumentos para los índices: {0}
inspection.incorrect.message.format.not.used.argument=El argumento con índice ''{0}'' no se ha usado en el patrón
inspection.incorrect.message.format.pattern={0} en patrón de formato de mensaje ''{1}''
inspection.incorrect.message.format.quotes.around.parameter=El parámetro ''{0}'' no se sustituirá porque está entre comillas.
inspection.incorrect.message.format.unclosed.brace=Llave no cerrada
inspection.incorrect.message.format.unknown.format.type=Tipo de formato desconocido ''{0}''
inspection.incorrect.message.format.unmatched.brace=Llaves no coincidentes
inspection.incorrect.message.format.unpaired.quote=Comilla sin par en el patrón de mensaje
inspection.list.remove.in.loop.display.name='List.remove()' invocado en un bucle
inspection.list.remove.in.loop.message=Se puede reemplazar con 'List.subList().clear()'
inspection.lossy.conversion.compound.assignment.display.name=Conversión con pérdida en la asignación compuesta de ''{0}'' a ''{1}''
inspection.lossy.conversion.compound.assignment.name=Posible conversión implícita con pérdida en la asignación compuesta
inspection.meta.annotation.without.runtime.description={0} debe tener @Retention(RetentionPolicy.RUNTIME)
inspection.method.call.in.loop.ignore.known.methods.option=Ignorar métodos conocidos con efectos secundarios
inspection.new.object.equality.display.name=Se compara un nuevo objeto mediante "=="
inspection.new.object.equality.message=Se compara el nuevo objeto utilizando ''{0}''
inspection.non.strict.comparison.equality.display.name=La desigualdad no estricta '>=' o '<=' puede reemplazarse con '=='
inspection.non.strict.comparison.equality.message=Puede reemplazarse con igualdad
inspection.note.may.change.semantics=cambio semántico
inspection.only.one.element.used.array=Solo se utiliza un elemento del array
inspection.only.one.element.used.display.name=Sólo se utiliza un elemento
inspection.only.one.element.used.fix.family=Reemplazar con un elemento accedido
inspection.only.one.element.used.list=Solo se usa un elemento de lista
inspection.only.one.element.used.string=Se usa un único carácter de cadena
inspection.option.ignore.as.initial.capacity=Ignorar capacidad inicial para StringBuilders y Collections
inspection.option.ignore.assert=Ignorar argumentos de descripción de sentencia assert
inspection.option.ignore.constant.initializers=Ignorar para inicializadores de campos constantes
inspection.option.ignore.exceptions=Ignorar para argumentos de constructor de subclases Throwable
inspection.option.ignore.in.annotations=Ignorar en anotaciones
inspection.option.ignore.in.hashcode=Ignorar constantes en métodos 'hashCode()'
inspection.option.ignore.in.tostring=Ignorar dentro de los métodos toString()
inspection.option.ignore.nonnls=Ignorar cuando está anotado vía @NonNls
inspection.option.ignore.system.err=Ignorar argumentos 'System.err.print'
inspection.option.ignore.system.out=Ignorar argumentos de 'System.out.print'
inspection.pattern.variable.can.be.used.display.name=La variable de patrón puede usarse
inspection.pattern.variable.can.be.used.existing.cast.message=Puedes usar la variable de patrón existente ''{0}'' en vez de la expresión de conversión
inspection.pattern.variable.can.be.used.existing.fix.family.name=Reemplazar por variable de patrón existente
inspection.pattern.variable.can.be.used.existing.fix.name=Reemplazar ''{0}'' con la variable de patrones existente ''{1}''
inspection.pattern.variable.can.be.used.existing.message=Se puede utilizar la variable de patrón existente ''{0}'' en lugar de ''{1}''
inspection.pattern.variable.can.be.used.fix.family.name=Reemplazar con variable de patrón
inspection.pattern.variable.can.be.used.fix.name=Reemplazar ''{0}'' con la variable de patrón
inspection.pattern.variable.can.be.used.instead.of.cast.message=La expresión de conversión puede reemplazarse por una variable de patrón
inspection.pattern.variable.can.be.used.message=La variable ''{0}'' se puede sustituir por una variable de patrón
inspection.pattern.variable.can.be.used.report.cast.only=Informar sobre expresiones de conversión que pueden reemplazarse por una nueva variable de patrón introducida
inspection.pattern.variable.instead.of.cast.can.be.used.existing.fix.name=Reemplazar la expresión de casteo por la variable de patrón existente ''{0}''
inspection.pattern.variable.instead.of.cast.can.be.used.fix.family.name=Familia de corrección: Se puede utilizar un patrón de variable en lugar de un cast
inspection.redundant.arguments.message=Argumentos superfluos
inspection.redundant.class.call.display.name=Llamada redundante 'isInstance()' o 'cast()'
inspection.redundant.collection.operation.display.name=Operación 'colección' redundante
inspection.redundant.collection.operation.fix.family.name=Simplificar operación de colección
inspection.redundant.collection.operation.problem.arraycopy=Colección innecesaria creada para copiar un arreglo
inspection.redundant.collection.removal.by.index.fix=Usar eliminación por objeto
inspection.redundant.collection.removal.by.index.problem=La eliminación por índice se puede reemplazar por eliminación por objeto
inspection.redundant.collection.unnecessary.contains.fix=Eliminar la comprobación ''{0}()''
inspection.redundant.collection.unnecessary.contains.problem=Comprobación innecesaria ''{0}()''
inspection.redundant.compare.call.display.name=Llamada al método 'compare()' redundante
inspection.redundant.compare.call.fix.name=Llamar a 'compare()' en línea
inspection.redundant.embedded.expression.display.name=Expresión incrustada redundante en la plantilla de cadena
inspection.redundant.embedded.expression.fix.family.name=Incrustar expresión embebida
inspection.redundant.embedded.expression.message.empty=Expresión incrustada redundante vacía
inspection.redundant.embedded.expression.message.literal=Literal embebida redundante
inspection.redundant.empty.string.argument.message=Argumento vacío de cadena innecesario
inspection.redundant.explicit.variable.type.description=El tipo explícito de variable local se puede omitir
inspection.redundant.java.time.operation.compare.java.time.family.name=Simplificar expresiones con llamadas a 'java.time' 'compareTo()'
inspection.redundant.java.time.operation.compare.java.time.problem.descriptor=La expresión con la llamada a  'java.time' <code>#ref()</code> puede simplificarse
inspection.redundant.java.time.operation.creation.java.time.error.message='Creación redundante del objeto ''{0}'''
inspection.redundant.java.time.operation.creation.java.time.error.remove.fix.message=Eliminar la llamada a ''{0}''
inspection.redundant.java.time.operation.creation.java.time.error.replace.fix.message=Reemplazar con la llamada a ''{0}''
inspection.redundant.java.time.operation.creation.java.time.family.name=Simplificar la creación de objetos 'java.time'
inspection.redundant.java.time.operation.creation.java.time.redundant.call.message=Llamada redundante a ''{0}''
inspection.redundant.java.time.operation.creation.java.time.remove.family.name=Eliminar llamada redundante
inspection.redundant.java.time.operation.display.name='Operación redundante de objeto `java.time`'
inspection.redundant.java.time.operation.explicit.chrono.field.family.name=Simplificar llamadas con argumentos explícitos de  'ChronoField' o 'ChronoUnit'
inspection.redundant.java.time.operation.explicit.chrono.field.problem.descriptor=Se puede simplificar la llamada con argumento explícito 'ChronoField' o 'ChronoUnit'.
inspection.redundant.length.check.display.name=Comprobación redundante de longitud de array
inspection.redundant.string.call.message=Llamada a <code>#ref()</code> es redundante #loc
inspection.redundant.string.constructor.message=<code>new #ref()</code> es redundante #loc
inspection.redundant.string.fix.family.name=Quitar llamada redundante
inspection.redundant.string.fix.remove.str.processor.description=La plantilla de cadena puede convertirse en un literal de cadena simple
inspection.redundant.string.intern.on.constant.message=La llamada a <code>#ref()</code> en la constante de tiempo de compilación no es necesaria #loc
inspection.redundant.string.length.argument.message=Argumento de longitud de cadena innecesario
inspection.redundant.string.new.array.message=<code>#ref</code> es redundante #loc
inspection.redundant.string.operation.display.name=Redundancia en la operación 'String'
inspection.redundant.string.option.do.not.report.single.argument.substring=No informar llamadas redundantes de substring() con un solo argumento
inspection.redundant.string.option.do.not.report.string.constructors=No informar llamadas de constructor String
inspection.redundant.string.remove.argument.fix.name=Eliminar argumento
inspection.redundant.string.remove.fix.name=Eliminar llamada redundante ''{0}()''
inspection.redundant.string.replace.with.arg.fix.name=Reemplazar con argumento
inspection.redundant.string.replace.with.empty.fix.name=Reemplazar con cadena vacía
inspection.redundant.zero.argument.message=Argumento cero redundante
inspection.refused.bequest.super.annotated.option=Informar solo cuando el método super sea anotado por:
inspection.remove.redundant.call.fix.name=Eliminar la llamada redundante ''{0}()''
inspection.replace.on.literal.display.name=La operación de reemplazo no tiene efecto
inspection.simplifiable.compare.java.time.display.name=La expresión con una llamada a "compareTo()" de "java.time" puede simplificarse
inspection.simplifiable.compare.java.time.family.name=Simplifica expresión con llamada 'compareTo()' de 'java.time'
inspection.simplifiable.compare.java.time.problem.descriptor=La expresión con la llamada a <code>#ref()</code> de 'java.time' se puede simplificar
inspection.simplifiable.if.statement.display.name='if' puede ser reemplazado con expresiones condicionales o booleanas
inspection.simplifiable.if.statement.fix.family.name=Reemplazar 'if else' por expresión condicional
inspection.simplifiable.if.statement.fix.name=Reemplazar ''if else'' por ''{0}''
inspection.simplifiable.if.statement.message=Sentencia if se puede reemplazar por ''{0}''
inspection.simplifiable.if.statement.option.dont.warn.on.ternary=No sugerir el operador '? :'
inspection.suspicious.date.format.display.name=Patrón de formato de fecha sospechoso
inspection.suspicious.date.format.message.lower=Se utiliza un patrón en minúsculas ''{0}'' ({1}): probablemente se pretendía ''{2}'' ({3})
inspection.suspicious.date.format.message.upper=Se usa el patrón ''{0}'' ({1}) en mayúsculas: probablemente se pretendía ''{2}'' ({3})
inspection.suspicious.package.private.access.description={0} es {1}, pero se declara en un módulo diferente ''{2}''
inspection.suspicious.package.private.access.problem={0} sobrescribe un método de acceso privado de paquete de {1} que está declarado en un módulo diferente ''{2}''
inspection.test.method.without.assertion.list.name=Métodos de aserción:
inspection.test.method.without.assertions.exceptions.option=Ignorar métodos de prueba que declaran excepciones
inspection.trivial.functional.expression.usage.description=Llamada de método se puede simplificar
inspection.type.may.be.weakened.add.stop.class.family=Agregar clase stop
inspection.type.may.be.weakened.add.stop.class.selection.popup=Seleccionar clase para detener
inspection.type.may.be.weakened.add.stop.class.selection.table=Detener clases
inspection.type.may.be.weakened.add.stop.class.selection.table.label=Parar clases:
inspection.type.may.be.weakened.add.stopper=Añadir como clase de parada para debilitar
inspection.type.may.be.weakened.add.stopper.preview=Se agregará la clase de detención a la lista de clases de detención para esta inspección.
inspection.type.may.be.weakened.add.stopper.single=Añadir {0} como clase de detención para debilitar
inspection.type.may.be.weakened.display.name=El tipo puede debilitarse
inspection.type.may.be.weakened.do.not.weaken.inferred.variable.type=No sugerir debilitar la variable declarada como 'var'
inspection.type.may.be.weakened.field.problem.descriptor=El tipo de campo <code>#ref</code> puede debilitarse a {0} #loc
inspection.type.may.be.weakened.method.problem.descriptor=El tipo de retorno del método "<code>#ref()</code>" puede debilitarse a {0} #loc
inspection.type.may.be.weakened.only.weaken.to.an.interface=Debilitar solo a una interfaz
inspection.type.may.be.weakened.parameter.problem.descriptor=El tipo de parámetro <code>#ref</code> puede debilitarse a {0} #loc
inspection.type.may.be.weakened.problem.descriptor=El tipo de la variable <code>#ref</code> puede debilitarse a {0} #loc
inspection.type.may.be.weakened.quickfix=Debilitar el tipo a ''{0}''
inspection.type.may.be.weakened.weaken.type.family=Debilitar el tipo
inspection.unnecessary.string.escape.report.char.literals.option=Reportar literales de caracteres
inspection.unsupported.chrono.field.unit.call.display.name=Llama a métodos con 'java.time.temporal.ChronoUnit' y 'java.time.temporal.ChronoField' sin soporte
inspection.unsupported.chrono.value.message=Valor del argumento no soportado: {0}
inspection.unsupported.chrono.values.message=No se aceptan valores de argumentos: {0}
inspection.use.of.private.field.inner.classes.option=Ignorar accesos de clases internas
inspection.use.of.slash.s.display.name=Uso no terminal de la secuencia de escape 's'
inspection.use.of.slash.s.fix.family=Reemplazar las secuencias 's' con espacios
inspection.use.of.slash.s.message=Uso de la secuencia de escape 's' como un espacio sin trailing
inspection.use.of.slash.s.non.text.block.message=Uso de la secuencia de escape 's' fuera de un bloque de texto
inspection.while.can.be.replaced.with.do.while.display.name='while' puede reemplazarse por 'do while'
inspection.while.can.be.replaced.with.do.while.family.name=Reemplace 'while' por 'do while'
inspection.while.can.be.replaced.with.do.while.message=Reemplazar 'while' por 'do while'
inspection.x.call.can.be.replaced.with.y=La llamada a <code>#ref()</code> puede ser reemplazada con ''{0}()''
instance.Variable.may.not.be.initialized.problem.descriptor.junit=El campo de instancia <code>#ref</code> puede no inicializarse durante la construcción del objeto o la llamada a 'setUp()' #loc
instance.method.naming.convention.element.description=Método de instancia
instance.variable.may.not.be.initialized.display.name=La variable de instancia podría no estar inicializada
instance.variable.may.not.be.initialized.problem.descriptor=El campo de instancia <code>#ref</code> podría no inicializarse durante la construcción del objeto #loc
instance.variable.naming.convention.element.description=Campo de instancia
instance.variable.of.concrete.class.problem.descriptor=Campo de instancia ''{0}'' de clase concreta <code>#ref</code> #loc
instance.variable.used.before.initialized.display.name=Campo de la instancia usado antes de inicialización
instance.variable.used.before.initialized.problem.descriptor=Campo de instancia <code>#ref</code> utilizado antes de inicializar #loc
instanceof.catch.parameter.display.name='instanceof' en el parámetro 'catch'
instanceof.catch.parameter.problem.descriptor='instanceof' en parámetro 'catch' <code>#ref</code> #loc
instanceof.check.for.this.display.name='this' verificación de 'instanceof'
instanceof.check.for.this.equality.problem.descriptor=Comparación de clases para 'this' #loc
instanceof.check.for.this.problem.descriptor='instanceof' check para <code>#ref</code> #loc
instanceof.concrete.class.equality.problem.descriptor=Comparación de clases frente a la clase concreta <code>#ref</code> #loc
instanceof.concrete.class.pattern.problem.descriptor=Pruebas de patrón de <code>#ref</code> clase concreta #loc
instanceof.concrete.class.problem.descriptor='instanceof' clase concreta <code>#ref</code> #loc
instanceof.with.incompatible.interface.display.name='instanceof' con tipo incompatible
instanceof.with.incompatible.interface.problem.descriptor='''instanceof'' de expresión con tipo ''{1}'' y una ''{0, choice, 1#interfaz|2#clase}'' incompatible <code>#ref</code> #loc
instantiating.datetimeformatter.without.locale.problem.descriptor=Llamada a <code>DateTimeFormatter.#ref()</code> sin especificar el valor local en un contexto internacionalizado #loc
instantiating.object.to.get.class.object.display.name=Instanciar objeto para obtener objeto 'Clase'
instantiating.object.to.get.class.object.problem.descriptor=Instanciando el objeto para obtener un objeto clase #loc
instantiating.object.to.get.class.object.replace.quickfix=Reemplazar con acceso de objeto de clase directo
instantiating.simpledateformat.without.locale.display.name='SimpleDateFormat' sin locale
instantiating.simpledateformat.without.locale.problem.descriptor=Crear una instancia de <code>#ref</code> sin especificar una configuración regional en un contexto internacional #loc
instantiation.utility.class.display.name=Instanciación de la clase utilitaria
instantiation.utility.class.problem.descriptor=Instanciación de la clase de utilidad <code>#ref</code> #loc
int.literal.may.be.long.literal.display.name=Convertir a 'long' puede ser el literal 'long'
int.literal.may.be.long.literal.problem.descriptor=El literal entero <code>#ref</code> puede ser reemplazado por ''{0}'' #loc
integer.division.in.floating.point.context.display.name=División entera en contexto de punto flotante
integer.division.in.floating.point.context.fix.family.name=Castear el numerador a un tipo de coma flotante
integer.division.in.floating.point.context.fix.name=Castea el numerador a ''{0}''
integer.division.in.floating.point.context.problem.descriptor=<code>#ref</code>: división entera en contexto de punto flotante #loc
integer.multiplication.implicit.cast.to.long.display.name=Multiplicación de enteros o desplazamiento convertido implícitamente a 'largo'
integer.multiplication.implicit.cast.to.long.option=<html>Ignorar expresiones donde se prueba estáticamente que el desbordamiento es imposible</html>
integer.multiplication.implicit.cast.to.long.problem.descriptor=#ref: La multiplicación de enteros se convierte implícitamente en long #loc
integer.multiplication.implicit.cast.to.long.quickfix=Convertir a long
integer.shift.implicit.cast.to.long.problem.descriptor=ref: desplazamiento entero implícitamente convertido a long #loc
interface.clashes.with.object.class.display.name=El método de interfaz entra en conflicto con el método de 'Object'
interface.clashes.with.object.class.problem.descriptor=<code>#ref()</code> choca con un método en 'java.lang.Object'
interface.may.be.annotated.functional.display.name=Interfaz puede ser anotada como '@FunctionalInterface'
interface.may.be.annotated.functional.problem.descriptor=La interfaz <code>#ref</code> puede estar anotada con @FunctionalInterface
interface.naming.convention.element.description=Interfaz
interface.never.implemented.display.name=Interfaz que no tiene una subclase concreta
interface.never.implemented.option=Ignorar interfaces que sólo declaran constantes
interface.never.implemented.problem.descriptor=La interfaz <code>#ref</code> no tiene subclase concreta #loc
interface.one.inheritor.display.name=Interfaz con un único heredero directo
interface.one.inheritor.problem.descriptor=La interfaz <code>#ref</code> solo tiene un heredero directo #loc
introduce.holder.class.quickfix=Introducir clase contenedora
introduce.variable.may.change.semantics.quickfix=Introducir variable (puede cambiar la semántica)
introduce.variable.quickfix=Introducir variable
invert.method.quickfix=Invertir método
invert.quickfix=Invertir ''{0}''
invert.quickfix.family.name=Invertir booleano
iterator.hasnext.which.calls.next.display.name='Iterator.hasNext()' que llama a 'next()'
iterator.hasnext.which.calls.next.problem.descriptor=<code>Iterator.{0}()</code> contiene llamada a ''#ref()'' #loc
iterator.next.does.not.throw.nosuchelementexception.display.name='Iterator.next()' que no puede lanzar 'NoSuchElementException'
iterator.next.does.not.throw.nosuchelementexception.problem.descriptor=<code>Iterator.#ref()</code> que no puede lanzar 'NoSuchElementException' #loc
java.lang.import.display.name=Importación innecesaria del paquete 'java.lang'
java.lang.import.problem.descriptor=Importación innecesaria del paquete 'java.lang' #loc
jdbc.execute.with.non.constant.string.display.name=Llamada a 'Statement.execute()' con cadena no constante
jdbc.execute.with.non.constant.string.problem.descriptor=Llamada a <code>Statement.#ref()</code> con el argumento no constante #loc
jdbc.prepare.statement.with.non.constant.string.display.name=Llamada a 'Connection.prepare*()' con una cadena no constante
jdbc.prepare.statement.with.non.constant.string.problem.descriptor=Llamada a <code>Connection.#ref()</code> con argumento no constante #loc
jdbc.resource.opened.not.closed.display.name=Recurso JDBC abierto, no cerrado de forma segura
jndi.resource.opened.not.closed.display.name=Recurso JNDI abierto pero no cerrado con seguridad
junit.abstract.test.class.naming.convention.element.description=Clase de prueba abstracta
junit.test.class.naming.convention.element.description=Clase de prueba
junit.test.suite.naming.convention.element.description=Test suite
junit3.method.naming.convention.element.description=Método de prueba de JUnit 3
junit4.method.naming.convention.element.description=Método de prueba de JUnit 4+
key.set.iteration.may.use.entry.set.display.name=La iteración sobre 'keySet()' puede optimizarse
key.set.iteration.may.use.entry.set.problem.descriptor=La iteración sobre <code>#ref</code> puede reemplazarse con la iteración ''{0}'' #loc
key.set.iteration.may.use.entry.set.quickfix=Optimice la iteración de Map
labeled.statement.display.name=Sentencia etiquetada
labeled.statement.problem.descriptor=Declaración de etiqueta <code>#ref:</code> #loc
lambda.body.can.be.code.block.name=El cuerpo de lambda puede ser bloque de código
lambda.body.can.be.code.block.quickfix=Ampliar cuerpo lambda a {...}
lambda.can.be.replaced.with.anonymous.name=Se puede reemplazar lambda con clase anónima
lambda.can.be.replaced.with.anonymous.quickfix=Reemplazar lambda con clase anónima
lambda.parameter.hides.member.variable.display.name=Parámetro Lambda oculta variable miembro
lambda.parameter.hides.member.variable.ignore.invisible.option=Ignorar campos no visibles desde lambda
lambda.parameter.hides.member.variable.problem.descriptor=El parámetro lambda <code>#ref</code> oculta a la variable miembro en la clase ''{0}'' #loc
lambda.parameter.naming.convention.display.name=Convención para nombrar parámetros lambda
lambda.parameter.naming.convention.element.description=Parámetro de lambda
lambda.parameter.type.can.be.specified.descriptor=Los tipos de los parámetros de las lambda se pueden expandir a {0}
lambda.parameter.type.can.be.specified.family.quickfix=Especificar tipo de parámetro de lambda
lambda.parameter.type.can.be.specified.name=El tipo de parámetro lambda puede especificarse
lambda.parameter.type.can.be.specified.quickfix=El tipo de parámetro puede expandirse a {0}
lambda.unfriendly.constructor.overload.problem.descriptor=Función constructora de lambda antipática <code>#ref()</code>
lambda.unfriendly.method.overload.display.name=Sobrecarga de método no amigable para lambda
lambda.unfriendly.method.overload.problem.descriptor=Sobrecarga de método <code>#ref()</code> no amigable con lambda
large.array.allocation.no.outofmemoryerror.display.name=Asignación de arrays grandes sin comprobación de OutOfMemoryError
large.array.allocation.no.outofmemoryerror.maximum.number.of.elements.option=Número máximo de elementos:
large.array.allocation.no.outofmemoryerror.problem.descriptor=Asignación de un array grande que no se verifica para condición de falta de memoria #loc
large.initializer.primitive.type.array.display.name=Inicializador demasiado grande para matrices de tipos primitivos
large.initializer.primitive.type.array.maximum.number.of.elements.option=Número máximo de elementos:
large.initializer.primitive.type.array.problem.descriptor=Inicializador de tipo primitivo con demasiados valores ( {0} ) #loc
law.of.demeter.display.name=Ley de Demeter
law.of.demeter.field.problem.descriptor=El acceso a <code>#ref</code> viola la Ley de Demeter #loc
law.of.demeter.ignore.library.calls.option=Ignorar llamadas a los métodos de la biblioteca y acceso a campos de la biblioteca
law.of.demeter.problem.descriptor=La llamada a <code>#ref()</code> viola la Ley de Deméter #loc
length.one.string.in.indexof.display.name=Argumento de cadena de un sólo carácter en la llamada 'String.indexOf()'
length.one.strings.in.concatenation.display.name=Concatenación de cadenas de un solo carácter
length.one.strings.in.concatenation.replace.quickfix=Reemplazar con carácter
limited.scope.inner.class.display.name=Clase local
limited.scope.inner.class.problem.descriptor=Clase local <code>#ref</code> #loc
list.indexof.replaceable.by.contains.display.name='La expresión de List.indexOf()' puede reemplazarse con 'contains()'
listener.may.use.adapter.display.name=Clase puede ampliar adaptador en lugar de implementar escuchador
listener.may.use.adapter.emtpy.methods.option=Sólo advertir cuando se encuentren métodos de implementación vacíos(&O)
listener.may.use.adapter.fix.family.name=Reemplazar con adaptador
listener.may.use.adapter.problem.descriptor=La clase ''{0}'' puede extender ''{1}'' en lugar de implementar <code>#ref</code> #loc
literal.as.arg.to.string.equals.display.name=Literal de cadena puede ser calificador 'equals()'
literal.as.arg.to.string.equals.flip.quickfix=Voltear ''{0}()''
literal.as.arg.to.string.equals.problem.descriptor=El literal #ref es argumento de ''{0}()'', en lugar de su calificador #loc
load.library.with.non.constant.string.display.name=Llamada a 'System.loadLibrary()' con una cadena no constante
load.library.with.non.constant.string.problem.descriptor=Llamada a <code>{0}.#ref()</code> con el argumento #loc no constante
local.variable.hides.member.variable.display.name=Variable local oculta variable de miembro
local.variable.hides.member.variable.ignore.option=Ignorar variables locales en un contexto estático que oculta variables que no son estáticas
local.variable.hides.member.variable.problem.descriptor=La variable local <code>#ref</code> oculta el elemento miembro en la clase ''{0}'' #loc
local.variable.naming.convention.display.name=Convención de nombres para variables locales
local.variable.naming.convention.element.description=Variable local
local.variable.naming.convention.ignore.catch.option=Ignorar parámetros de bloque 'catch'
local.variable.naming.convention.ignore.option=Ignorar parámetro de bucle for
local.variable.of.concrete.class.problem.descriptor=Variable local ''{0}'' de clase concreta <code>#ref</code> #loc
log.condition.text=Texto de Condición de Registro
log.method.name=Nombre del método de logging
log.statement.guarded.by.log.condition.display.name=Llamada de registro no protegida por la condición del registro
log.statement.guarded.by.log.condition.flag.all.unguarded.option=Marcar todas las llamadas de registro no protegidas
log.statement.guarded.by.log.condition.problem.descriptor=<code>#ref()</code> No se protegen las llamadas de registro por la condición de registro #loc
log.statement.guarded.by.log.condition.quickfix=Envolver con condición de registro
logger.class.name=Nombres de clase del registrador:
logger.factory.class.name=Nombre de clase de la fábrica de registros
logger.factory.method.name=Nombre del método de fábrica del registrador
logger.initialized.with.foreign.class.display.name=registrador inicializado con clase externa
logger.initialized.with.foreign.class.fix.family.name=Reemplazar clase externa
logger.initialized.with.foreign.class.ignore.non.public.classes.option=Ignorar registradores en clases no públicas
logger.initialized.with.foreign.class.ignore.not.final.field=Ignorar registradores no inicializados en campos final
logger.initialized.with.foreign.class.ignore.super.class.option=Ignorar registradores inicializados con una superclase
logger.initialized.with.foreign.class.problem.descriptor=El registrador se inicializó con la clase externa <code>#ref</code> #loc
logger.name.option=Nombre de la clase del registrador:(&C)
long.literals.ending.with.lowercase.l.display.name=literal 'long' termina con 'l' en vez de 'L'
long.literals.ending.with.lowercase.l.problem.descriptor='literal' largo <code>#ref</code> termina con 'l' minúscula #loc
loop.condition.not.updated.inside.loop.display.name=Variable de bucle no actualizada dentro del propio bucle
loop.condition.not.updated.inside.loop.problem.descriptor=La condición '#ref' no se actualiza dentro del bucle #loc
loop.statements.that.dont.loop.display.name=Sentencia de bucle que no buclea
loop.statements.that.dont.loop.problem.descriptor=La instrucción <code>#ref</code> no contiene bucles #loc
loop.variable.not.updated.inside.loop.option.nonlocal=Omitir posibles cambios no locales
loop.variable.not.updated.inside.loop.problem.descriptor=La variable '#ref' no se actualiza dentro del bucle #loc
loop.with.implicit.termination.condition.display.name=Bucle con condición de terminación implícita
loop.with.implicit.termination.condition.dowhile.problem.descriptor=Bucle <code>#ref-while</code> con condición de terminación implícita #loc
loop.with.implicit.termination.condition.problem.descriptor=Bucle <code>#ref</code> con condición de finalización implícita #loc
loop.with.implicit.termination.condition.quickfix=Convertir condición en explícita
magic.character.display.name=Carácter mágico
magic.character.problem.descriptor=Carácter mágico <code>#ref</code> en un contexto internacionalizado #loc
magic.number.display.name=Número mágico
magic.number.problem.descriptor=Número mágico <code>#ref</code> #loc
make.class.final.fix.family.name=Convertir la clase en final
make.class.final.fix.name=Convertir la clase ''{0}'' en ''final''
make.constructor.public=Hacer público el constructor
make.field.final.fix.family.name=Convertir a final
make.field.final.quickfix=Establecer ''{0}'' como ''final''
make.field.static.final.fix.family.name=Hacer estático y final
make.initialization.explicit.quickfix=Hacer la inicialización explícita
make.method.ctr.quickfix=Convertir método en constructor
make.method.final.fix.family.name=Transformar método en 'final'
make.method.final.fix.name=Hacer método ''{0}()'' ''final''
make.package.private.fix.family.name=Convertir a package-private
make.static.final.quickfix=Convertir ''{0}'' a static final
make.static.quickfix=Convertir en 'static'
malformed.format.string.display.name=Cadena de formato mal formada
malformed.format.string.problem.descriptor.arguments.do.not.match.type=El tipo de argumento ''{0}'' no coincide con el tipo del especificador de formato ''{1}'' #loc
malformed.format.string.problem.descriptor.at.least.too.few.arguments=Muy pocos argumentos para la cadena de formato (encontrado: {0}, se esperaban al menos: {1}) #loc
malformed.format.string.problem.descriptor.illegal=Especificador de cadena de formato ilegal: {0} #loc
malformed.format.string.problem.descriptor.malformed=Cadena de formato `#ref` con formato incorrecto #loc
malformed.format.string.problem.descriptor.too.few.arguments=Demasiados pocos argumentos para cadena de formato (encontrados: {0}, esperados: {1}) #loc
malformed.format.string.problem.descriptor.too.many.arguments=Demasiados argumentos para la cadena de formato (encontrados: {0}, esperados: {1}) #loc
manual.array.copy.display.name=Copia manual del arreglo
manual.array.copy.problem.descriptor=Copiar arreglo manualmente #loc
manual.array.to.collection.copy.display.name=Conversión manual de matriz a colección
manual.array.to.collection.copy.problem.descriptor=Copia manual del array a la colección #loc
map.replaceable.by.enum.map.display.name='Mapa' se puede reemplazar por 'EnumMap'
map.replaceable.by.enum.map.problem.descriptor=<code>#ref</code> puede ser reemplazado por 'EnumMap' #loc
mark.modules.as.loaded.together.fix.family.name=Marcar módulos cargados juntos
mark.modules.as.loaded.together.fix.text=Marcar módulos ''{0}'' y ''{1}'' como cargados juntos
markdown.documentation.comments.migration.display.name=Los comentarios Javadoc pueden ser comentarios de documentación Markdown
markdown.documentation.comments.migration.fix=Convertir a comentario de documentación Markdown
marker.interface.display.name=Interfaz de marcado
marker.interface.problem.descriptor=Interfaz de marcador <code>#ref</code> #loc
masked.assertion.display.name=La aseveración es suprimida por 'catch'
masked.assertion.problem.description=''{0}'' no puede fallar porque está suprimido por un ''catch'' envolvente
math.random.cast.to.int.display.name='Math.random()' conversión a 'int'
math.random.cast.to.int.problem.descriptor=La conversión <code>#ref</code> a ''{0}'' siempre se trunca a ''0'' #loc
math.random.cast.to.int.quickfix=Agregar paréntesis para realizar la multiplicación antes del conversión
math.rounding.with.int.argument.display.name=Llamar al redondeo de matemáticas con el argumento 'int'
math.rounding.with.int.argument.family.name=Simplificar llamadas de redondeo
math.rounding.with.int.argument.problem.descriptor=<code>#ref()</code> con argumentos de tipo 'int' #loc
math.rounding.with.int.argument.quickfix=Simplificar llamada ''{0}()''
meta.annotation.without.runtime.retention=meta.annotation.without.runtime.retention
method.call.in.loop.condition.display.name=Llamada de método en condición de bucle
method.call.in.loop.condition.problem.descriptor=Llamada al método <code>#ref()</code> en la condición de bucle #loc
method.can.be.variable.arity.method.display.name=El método puede tener un parámetro varargs
method.can.be.variable.arity.method.ignore.all.primitive.arrays.option=Ignorar todos los tipos de matrices primitivas
method.can.be.variable.arity.method.ignore.byte.short.option=Ignorar parámetros con tipo byte[] o short[]
method.can.be.variable.arity.method.ignore.multidimensional.arrays.option=Ignorar parámetros de matriz multidimensional
method.can.be.variable.arity.method.ignore.multiple.arrays.option=Ignorar métodos con múltiples parámetros array
method.can.be.variable.arity.method.problem.descriptor=<code>#ref()</code> puede convertirse a método vararg #loc
method.complexity.limit.option=Límite de complejidad de métodos:
method.count.ignore.getters.setters.option=Ignorar métodos getter y setter simples(&I)
method.count.limit.option=Límite de recuento de métodos:
method.coupling.display.name=Metodo con excesiva conexión
method.coupling.limit.option=Límite de acople de métodos:
method.coupling.problem.descriptor=<code>#ref</code> está excesivamente acoplado (# clases referenciadas = {0}) #loc
method.may.be.static.display.name=El método puede ser 'static'
method.may.be.static.empty.option=Ignorar métodos vacíos
method.may.be.static.ignore.default.methods.option=Ignorar métodos 'predeterminados'
method.may.be.static.only.option=Solo revisar métodos 'private' o 'final'
method.may.be.static.problem.descriptor=El método <code>#ref()</code> puede ser 'static' #loc
method.may.be.static.replaces.qualifiers.with.class.references.option=Arreglo rápido reemplaza calificadores de instancia por referencias de clase
method.may.be.synchronized.display.name=Un método con un solo bloque 'synchronized' se puede reemplazar con un método 'synchronized'
method.may.be.synchronized.problem.descriptor=El método <code>#ref()</code> con bloque sincronizado puede ser un método sincronizado #loc
method.may.be.synchronized.quickfix=Convertir el método en sincronizado y eliminar el bloque sincronizado
method.name.regex=Expresión regular del nombre del método
method.name.same.as.class.name.display.name=El nombre del método es el mismo que el nombre de la clase
method.name.same.as.class.name.problem.descriptor=El nombre del método <code>#ref</code> es el mismo que el nombre de su clase #loc
method.name.same.as.parent.name.display.name=El nombre del método es igual que el nombre de la clase padre
method.name.same.as.parent.name.problem.descriptor=El nombre del método <code>#ref</code> es igual que el nombre de su clase padre #loc
method.names.differ.only.by.case.display.name=Nombres de métodos que difieren sólo por mayúsculas/minúsculas
method.names.differ.only.by.case.problem.descriptor=El nombre del método <code>#ref</code> y el nombre del método ''{0}'' difieren sólo por el uso de mayúsculas y minúsculas #loc
method.only.used.from.inner.class.display.name=Método privado sólo utilizado desde clase interna
method.only.used.from.inner.class.ignore.option=Ignorar métodos llamados desde clases anónimas o locales(&A)
method.only.used.from.inner.class.problem.descriptor=El método <code>#ref()</code>#loc solo se utiliza desde {0, choice, 1#interna|2#local|3#}{1, choice, 1#clase|2#interfaz|3#una clase anónima derivada de|4#tipo de anotación|5#enumeración|6#registro} ''{2}'' #loc
method.overloads.display.name=Posible sobrecarga no intencionada del método de la superclase
method.overloads.problem.descriptor=El método <code>#ref()</code> sobrecarga un método compatible de una superclase, pudiendo haber previsto una anulación #loc
method.overloads.report.incompatible.option=Informar incluso si los tipos de parámetro no son compatibles
method.overrides.inaccessible.method.display.name=El método sobreescribe un método inaccesible de la superclase
method.overrides.package.local.method.problem.descriptor=Método <code>#ref()</code> sobreescribe un método package-private de una superclase localizada en otro paquete #loc
method.overrides.private.display.name.problem.descriptor=El método <code>#ref()</code> sobreescribe un método 'private' de una superclase #loc
method.overrides.static.display.name=El método intenta sobreescribir el método 'static' de la superclase
method.overrides.static.problem.descriptor=El método `#ref()` intenta sobreescribir un método estático de una superclase #loc
method.ref.can.be.replaced.with.lambda.name=Referencia de método puede ser reemplazada con lambda
method.ref.can.be.replaced.with.lambda.quickfix=Reemplazar referencia de método con lambda
method.return.always.constant.display.name=Método retorna una constante por clase
method.return.always.constant.problem.descriptor=Método <code>#ref()</code> y todas sus derivadas siempre devuelven constantes
method.return.concrete.class.problem.descriptor=El método devuelve una clase concreta <code>#ref</code> #loc
method.with.multiple.loops.display.name=Método con múltiples bucles
method.with.multiple.loops.problem.descriptor=<code>#ref</code> contiene {0} bucles #loc
mismatched.read.write.array.display.name=Lectura y escritura de matriz no coincidente
mismatched.read.write.array.problem.descriptor.read.not.write=El contenido del array <code>#ref</code> es leído, pero nunca es escrito en #loc
mismatched.read.write.array.problem.descriptor.write.not.read=Los contenidos del array <code>#ref</code> son leídos, pero nunca escritos #loc
mismatched.string.builder.queried.problem.descriptor=El contenido de <code>{0} #ref</code> está consultado, pero no actualizado #loc
mismatched.string.builder.query.update.display.name=Query y actualización no coinciden para 'StringBuilder'
mismatched.string.builder.updated.problem.descriptor=El contenido de <code>{0} #ref</code> se actualiza, pero nunca se consulta #loc
mismatched.update.collection.display.name=Consulta y actualización de la colección no coincidentes
mismatched.update.collection.problem.description.queried.not.updated=El contenido de la colección <code>#ref</code> se consultó, pero nunca se actualizó #loc
mismatched.update.collection.problem.descriptor.updated.not.queried=El contenido de la colección #ref está actualizado, pero nunca se ha consultado. #loc
misordered.assert.equals.arguments.display.name=Argumentos de 'assertEquals()' desordenados
misordered.assert.equals.arguments.flip.quickfix=Intercambio de argumentos comparados
misordered.assert.equals.arguments.problem.descriptor=Argumentos a <code>#ref()</code> en orden incorrecto #loc
missing.add.deprecated.javadoc.tag.quickfix=Agrega '@deprecated' etiqueta Javadoc
missing.deprecated.annotation.add.quickfix=Añadir anotación '@Deprecated'
missing.deprecated.annotation.display.name=Falta anotación '@Deprecated'
missing.deprecated.annotation.problem.descriptor=Falta la anotación '@Deprecated' #loc
missing.deprecated.tag.option=Avisar sobre la etiqueta faltante @deprecated Javadoc en la explicación
missing.deprecated.tag.problem.descriptor=Explicación de la etiqueta Javadoc '@deprecated' ausente #loc
missing.override.annotation.display.name=Falta anotación '@Override'
missing.override.annotation.in.overriding.problem.descriptor=Los métodos que anulan no están anotados con '@Override'
missing.override.annotation.problem.descriptor=Falta anotación '@Override' en <code>#ref()</code> #loc
missing.override.warn.on.super.option=Resalta el método cuando sus métodos de anulación no tienen todos la anotación '@Override'
missing.package.html.problem.descriptor=El paquete ''{0}'' carece de archivo <code>package.html</code>
missing.package.info.display.name=Faltan 'package-info.java'
missing.package.info.problem.descriptor=El paquete ''{0}'' no tiene un archivo <code>package-info.java</code>
missing.serial.annotation.display.name=Se puede usar la anotación '@Serial'
missing.serial.annotation.on.field.problem.descriptor=Se puede anotar <code>#ref</code> con la anotación '@Serial'
missing.serial.annotation.on.method.problem.descriptor=<code>#ref()</code> puede ser anotado con la anotación '@Serial'
missorted.modifiers.allowed.place=La anotación TYPE_USE objetivo debe colocarse según las opciones de generación
missorted.modifiers.allowed.place.description=La anotación TYPE_USE de destino debe colocarse de acuerdo con la opción <code>Configuración->Editor->Estilo de código->Java->Generación de código->Generar anotaciones permitidas para TYPE_USE directamente antes del tipo</code>, de lo contrario, se puede colocar en cualquier lugar permitido.
missorted.modifiers.display.name=Modificadores mal ordenados
missorted.modifiers.problem.descriptor=Modificadores no clasificados <code>{0}</code> #loc
missorted.modifiers.require.option=Comprobar orden de anotaciones
missorted.modifiers.require.option.description=Usa esta opción para reportar anotaciones mal ubicadas: Anotaciones sin `ElementType.TYPE_USE` *precisamente* antes del tipo y *justo* después de las palabras clave modificadoras, u otras anotaciones *sin* estar delante de las palabras clave modificadoras. Cuando esta opción está deshabilitada, cualquier anotación puede colocarse antes o después de las palabras clave modificadoras. Se reportará siempre una lista de modificadores con anotaciones entre palabras clave modificadoras.
missorted.modifiers.sort.quickfix=Ordenar modificadores
misspelled.equals.display.name='igual()' en lugar de 'equals()'
misspelled.equals.problem.descriptor=<code>#ref()</code> el método debería ser probablemente 'equals()' #loc
module.with.too.few.classes.display.name=Módulo con pocas clases
module.with.too.few.classes.min.option=Mínimo número de clases:
module.with.too.few.classes.problem.descriptor=El módulo ''{0}'' contiene muy pocas clases ({1} < {2})
module.with.too.many.classes.display.name=Módulo con demasiadas clases
module.with.too.many.classes.max.option=Máximo número de clases:
module.with.too.many.classes.problem.descriptor=El módulo ''{0}'' contiene demasiadas clases ({1} > {2})
move.anonymous.to.inner.quickfix=Convertir a clase interna con nombre
move.class.quickfix=Mover clase
move.exception.to.javadoc.fix.family.name=Mover a Javadoc '@throws'
move.local.to.inner.quickfix=Convertir a clase interna
multi.catch.can.be.split.name=El multi-catch puede dividirse en bloques catch separados
multi.catch.can.be.split.quickfix=Dividir multicaptura en bloques 'catch' separados
multiple.declaration.array.only.option=Solo avisar de dimensiones de matriz diferentes en una sola declaración
multiple.declaration.display.name=Varias variables en una declaración
multiple.declaration.ignore.for.option=Ignorar las declaraciones de bucles 'for'
multiple.declaration.problem.descriptor=Varias variables en una declaración #loc
multiple.loggers.display.name=Clase con múltiples registradores
multiple.loggers.problem.descriptor=La clase <code>#ref</code> declara múltiples registradores #loc
multiple.return.points.per.method.display.name=Método con múltiples puntos de retorno
multiple.return.points.per.method.problem.descriptor=<code>#ref</code> tiene {0} puntos de retorno #loc
multiple.top.level.classes.in.file.display.name=Múltiples clases de nivel superior en un solo archivo
multiple.top.level.classes.in.file.problem.descriptor=Múltiples clases de nivel superior en el archivo
multiple.typed.declaration.problem.descriptor=variables con diferente dimensión de array en una declaración #loc
multiply.or.divide.by.power.of.two.display.name=Multiplicación o división por potencia de dos
multiply.or.divide.by.power.of.two.divide.option=Comprobar también divisiones por una potencia de dos
multiply.or.divide.by.power.of.two.replace.quickfix=Reemplazar con desplazamiento
naked.notify.display.name=`notify()` o `notifyAll()` sin cambio de estado correspondiente
naked.notify.problem.descriptor=Llamada a <code>#ref()</code> sin cambio de estado correspondiente #loc
naming.convention.problem.descriptor.long={0} nombre <code>#ref</code> es demasiado largo ({1} > {2}) #loc
naming.convention.problem.descriptor.regex.mismatch={0} nombre <code>#ref</code> no coincide con la expresión regular ''{1}'' #loc
naming.convention.problem.descriptor.short={0} El nombre <code>#ref</code> es demasiado corto ({1} < {2}) #loc
native.method.display.name=Metodo nativo
native.method.naming.convention.element.description='método' nativo
native.method.problem.descriptor=Métodos declarados como <code>#ref</code> son no portables #loc
negated.conditional.display.name=Expresión condicional con condición negada
negated.conditional.expression.display.name=Expresión condicional negada
negated.conditional.expression.problem.descriptor=Expresión condicional negada #loc
negated.conditional.expression.quickfix=Eliminar negación
negated.conditional.invert.quickfix=Invertir condición
negated.conditional.problem.descriptor=Expresión condicional con condición negada #loc
negated.equality.expression.display.name=Expresión de igualdad negada
negated.equality.expression.problem.descriptor=Negando ''{0}'' #loc
negated.equality.expression.quickfix=Eliminar negación
negated.if.else.display.name=Sentencia "if" con condición negada
negated.if.else.ignore.negated.null.option=Ignorar comparaciones '!= nulo'
negated.if.else.ignore.negated.zero.option=Ignorar comparaciones '!= 0'
negated.if.else.invert.quickfix=Invertir condición 'if'
negated.if.else.problem.descriptor=Instrucción <code>#ref</code> con condición negada #loc
negative.int.constant.in.long.context.display.name=Constante hexadecimal entero negativa en contexto largo
negative.int.constant.in.long.context.fix.add.suffix=Añadir sufijo 'L' (cambia la semántica)
negative.int.constant.in.long.context.fix.convert=Convertir a constante long (preserva la semántica)
negatively.named.boolean.variable.display.name=Variable booleana con nombre negativo
negatively.named.boolean.variable.problem.descriptor=La variable booleana <code>#ref</code> tiene un nombre negativo #loc
nested.assignment.display.name=Asignación anidada
nested.assignment.problem.descriptor=El resultado de la expresión de asignación se usa #loc
nested.conditional.expression.display.name=Expresión condicional anidada
nested.conditional.expression.problem.descriptor=Expresión condicional anidada <code>#ref</code> #loc
nested.method.call.display.name=Llamada a método anidado
nested.method.call.ignore.option=Ignorar llamadas de método anidadas en inicializadores de campo
nested.method.call.problem.descriptor=Llamada a método anidado <code>#ref()</code> #loc
nested.switch.statement.display.name=Sentencia 'switch' anidada
nested.switch.statement.problem.descriptor=Declaración <code>#ref</code> {0} anidada #loc
nested.synchronized.statement.display.name=Sentencia 'synchronized' anidada
nested.synchronized.statement.problem.descriptor=Instrucción <code>#ref</code> anidada #loc
nested.try.statement.display.name=Bloque 'try' anidado
nested.try.statement.problem.descriptor=Sentencia try anidada: #ref #loc
nesting.depth.display.name=Método excesivamente anidado
nesting.depth.limit.option=Límite de profundidad de anidamiento:
nesting.depth.problem.descriptor=<code>#ref</code> está muy anidado (profundidad máxima de anidación = {0}) #loc
new.exception.without.arguments.display.name=Se llamó al constructor de la excepción sin argumentos
new.exception.without.arguments.problem.descriptor=<code>new #ref()</code> sin argumentos #loc
new.method.naming.convention.display.name=Convención de nomenclatura de métodos
new.string.buffer.replaceable.by.string.problem.descriptor=<code>#ref</code> puede reemplazarse con 'String' #loc
new.string.buffer.with.char.argument.display.name=Llamada del constructor StringBuilder con el argumento 'char'
new.string.buffer.with.char.argument.problem.descriptor=<code>new #ref()</code> con un argumento de tipo 'char' #loc
new.string.buffer.with.char.argument.quickfix=Reemplazar argumento char con literal de string
no.logger.display.name=clase sin registrador
no.logger.problem.descriptor=La clase <code>#ref</code> no declara un registrador #loc
non.atomic.operation.on.volatile.field.display.name=Operación no atómica sobre campo 'volatile'
non.atomic.operation.on.volatile.field.problem.descriptor=Operación no atómica en campo volátil <code>#ref</code> #loc
non.boolean.method.name.must.not.start.with.question.display.name=El nombre del método no-booleano no debe empezar con una palabra de pregunta
non.boolean.method.name.must.not.start.with.question.problem.descriptor=El nombre del método no booleano <code>#ref</code> empieza con una palabra interrogativa #loc
non.comment.source.statements.display.name=Método demasiado largo
non.comment.source.statements.limit.option=Límite de instrucciones fuente sin comentario:
non.comment.source.statements.problem.descriptor=<code>#ref</code> es demasiado grande (# Instrucciones del código fuente sin comentario = {0}) #loc
non.constant.logger.display.name=Registrador no constante
non.constant.logger.problem.descriptor=Campo registrador no constante <code>#ref</code> #loc
non.exception.name.ends.with.exception.display.name=El nombre de la clase, que no es de excepción, termina en 'Excepción'
non.exception.name.ends.with.exception.problem.descriptor=Nombre de clase que no es una excepción <code>#ref</code> termina con 'Exception' #loc
non.exception.name.ends.with.exception.quickfix=Hacer que ''{0}'' extenda ''java.lang.Exception''
non.final.clone.display.name=Clone() no final en contexto seguro
non.final.clone.problem.descriptor=El método <code>#ref()</code> no es final, comprometiendo la seguridad #loc
non.final.field.compareto.display.name=Campo no final referenciado en 'compareTo()'
non.final.field.compareto.problem.descriptor=Campo no final <code>#ref</code> accedido en 'compareTo()' #loc
non.final.field.in.enum.display.name=Campo no final en 'enum'
non.final.field.in.enum.problem.descriptor=Campo no final <code>#ref</code> en la enumeración ''{0}'' #loc
non.final.field.in.enum.quickfix.option=Ignorar campos que no se pueden hacer 'final'
non.final.field.in.equals.display.name=Campo no final referenciado en 'equals()'
non.final.field.in.equals.problem.descriptor=Campo no final <code>#ref</code> accedido en 'equals()' #loc
non.final.field.in.hashcode.display.name=Campo no final referenciado en 'hashCode()'
non.final.field.in.hashcode.problem.descriptor=Campo no final <code>#ref</code> accedido en 'hashCode()' #loc
non.final.field.of.exception.display.name=Campo no final del clase 'Excepción'
non.final.field.of.exception.problem.descriptor=Campo no-final <code>#ref</code> de clase de excepción #loc
non.final.static.variable.initialization.display.name=Se utiliza un campo static no final durante la inicialización de la clase
non.final.static.variable.initialization.problem.descriptor=Campo estático no final <code>#ref</code> usado durante la inicialización de clase #loc
non.final.utility.class.display.name=La clase de utilidad no es 'final'
non.final.utility.class.problem.descriptor=La clase de utilidad <code>#ref</code> no es 'final' #loc
non.protected.constructor.in.abstract.class.display.name=Constructor público en clase abstracta
non.protected.constructor.in.abstract.class.ignore.option=Ignorar para clases no públicas
non.protected.constructor.in.abstract.class.problem.descriptor=El constructor <code>#ref()</code> de una clase abstracta no debería estar declarado como 'public' #loc
non.public.clone.display.name='método clone()' no es 'public'
non.public.clone.problem.descriptor=Método <code>#ref()</code> no es 'público' #loc
non.reproducible.math.call.display.name=Llamada no reproducible a 'Math'
non.reproducible.math.call.problem.descriptor=''Math.#ref()'' puede producir resultados no reproducibles #loc
non.reproducible.math.call.replace.quickfix=Reemplazar con llamada 'StrictMath'
non.serializable.@interface.with.serialversionuid.problem.descriptor=@interface no serializable <code>#ref</code> define un campo 'serialVersionUID' #loc
non.serializable.anonymous.with.serialversionuid.problem.descriptor=La clase anónima no serializable derivada de <code>#ref</code> define un campo 'serialVersionUID' #loc
non.serializable.class.with.readwriteobject.display.name=Clase no serializable con "readObject()" o "writeObject()"
non.serializable.class.with.readwriteobject.problem.descriptor.both=La clase no serializable {0, choice, 1#|2#interfaz|3#clase anónima derivada de|4#tipo anotación|5#enumeración|6#registro} <code>#ref</code> define ''readObject()'' y ''writeObject()'' #loc
non.serializable.class.with.readwriteobject.problem.descriptor.read=Clase no serializable {0, choice, 1#|2#interfaz|3#clase anónima derivada de|4#tipo anotación|5#enumeración|6#registro} <code>#ref</code> define ''readObject( )'' #loc
non.serializable.class.with.readwriteobject.problem.descriptor.write=La clase no serializable {0, choice, 1#clase|2#interfaz|3#clase anónima derivada de|4#tipo de anotación|5#enumeración|6#registro} <code>#ref</code> define ''writeObject()'' #loc
non.serializable.class.with.serialversionuid.problem.descriptor=La clase no serializable <code>#ref</code> define un campo 'serialVersionUID' #loc
non.serializable.component.in.serializable.record.problem.descriptor=El registro serializable contiene un componente no serializable '#ref'#loc
non.serializable.field.in.serializable.class.display.name=Campo no serializable en clase 'Serializable'
non.serializable.field.in.serializable.class.problem.descriptor=Campo no serializable '#ref' en una clase Serializable #loc
non.serializable.interface.with.serialversionuid.problem.descriptor=La interfaz que no es serializable <code>#ref</code> define un campo de 'serialVersionUID' #loc
non.serializable.object.bound.to.http.session.display.name=Objeto no serializable asociado a 'HttpSession'
non.serializable.object.bound.to.http.session.problem.descriptor=Objeto no serializable vinculado a HttpSession #loc
non.serializable.object.passed.to.object.stream.display.name=Objeto no serializable pasado a `ObjectOutputStream`
non.serializable.object.passed.to.object.stream.problem.descriptor=Objeto no serializable pasado a ObjectOutputStream #loc
non.serializable.with.serialversionuid.display.name=Clase no serializable con 'serialVersionUID'
non.short.circuit.boolean.expression.display.name=Expresión booleana sin cortocircuito
non.short.circuit.boolean.expression.problem.descriptor=Expresión booleana no cortacircuito <code>#ref</code> #loc
non.short.circuit.boolean.expression.replace.quickfix=Reemplazar con expresión de cortocircuito
non.synchronized.method.overrides.synchronized.method.display.name=Método no sincornizado sobreescribe el método "sincronizado"
non.synchronized.method.overrides.synchronized.method.problem.descriptor=El método no sincronizado <code>#ref()</code> sobrescribe el método sincronizado #loc
non.thread.safe.lazy.initialization.display.name=Inicialización perezosa no segura del campo 'estático'
non.thread.safe.lazy.initialization.problem.descriptor=La inicialización de campo 'estático' <code>#ref</code> no es segura para subprocesos #loc
none=ninguno
noop.method.in.abstract.class.display.name=Método sin operación en clase 'abstracta'
noop.method.in.abstract.class.problem.descriptor=El método Sin operación <code>#ref()</code> debería hacerse abstracto #loc
normalize.declaration.quickfix=Separar en declaraciones independientes
not.object.equals.can.be.equality.problem.descriptor=Se puede reemplazar <code>!#ref()</code> con '!='
notify.called.on.condition.display.name='notify()' o 'notifyAll()' invocado en el objeto 'java.util.concurrent.locks.Condition'
notify.called.on.condition.problem.descriptor=Llamada a <code>#ref()</code> en objeto Condición #loc
notify.without.corresponding.wait.display.name='notify()' sin 'wait()' correspondiente
notify.without.corresponding.wait.problem.descriptor=Llamada a <code>#ref()</code> sin <code>wait()</code> correspondiente #loc
null.argument.to.var.arg.method.display.name=Argumento confuso para método varargs
null.argument.to.var.arg.method.problem.descriptor=Argumento confuso <code>#ref</code>, no está claro si se desea una llamada varargs o no varargs #loc
null.thrown.display.name='null' arrojado
null.thrown.problem.descriptor=Se lanzó <code>#ref</code> #loc
number.comparison.display.name=Comparación numérica usando '==', en lugar de 'equals()'
number.comparison.problem.descriptor=Objetos numéricos son comparados usando <code>#ref</code>, no 'equals()' #loc
object.allocation.in.loop.display.name=Asignación de objeto en bucle
object.allocation.in.loop.new.descriptor=Asignación de objeto <code>new #ref()</code> en el bucle #loc
object.allocation.in.loop.problem.array.initializer.descriptor=Asignación de arreglo en bucle #loc
object.allocation.in.loop.problem.call.descriptor=Asignación de objetos a través de llamada <code>#ref()</code> en bucle #loc
object.allocation.in.loop.problem.lambda.descriptor=Asignación de objeto mediante capturador lambda en bucle #loc
object.allocation.in.loop.problem.methodref.descriptor=Asignación de objeto mediante referencia al método ligado a instancia <code>#ref()</code> en bucle #loc
object.allocation.in.loop.problem.string.concat=Asignación de objetos mediante concatenación de cadenas en bucle #loc
object.comparison.display.name=Comparación de objetos usando '==', en vez de 'equals()'
object.comparison.enumerated.ignore.option=Ignorar '==' entre variables enum
object.comparison.klass.ignore.option=Ignorar '==' entre tipos de clase final sin implementación de 'equals()'
object.comparison.problem.description=Los valores de objeto se comparan usando `#ref`, no 'equals()' #loc
object.equality.ignore.between.objects.of.a.type.with.only.private.constructors.option=Ignorar '==' entre objetos de un tipo con constructores solo 'privados'
object.equals.can.be.equality.display.name=La llamada a 'equals()' puede reemplazarse con '=='
object.equals.can.be.equality.problem.descriptor=<code>#ref()</code> se puede reemplazar con '=='
object.instantiation.inside.equals.or.hashcode.display.name=Instanciación de objeto dentro de 'equals()' o 'hashCode()'
object.instantiation.inside.equals.or.hashcode.problem.descriptor=Instanciación de objeto dentro de ''{0}()'' #loc
object.instantiation.inside.equals.or.hashcode.problem.descriptor2=Creación de instancias de objetos dentro de ''{0}()'' ({1})#loc
object.notify.display.name=Llamada a 'notify()' en lugar de 'notifyAll()'
object.notify.problem.descriptor=<code>#ref</code> probablemente sea reemplazado por 'notifyAll()' #loc
objects.hash.fix.family.name=Rodear con 'Arrays.hashCode()'
objects.hash.problem.descriptor=El arreglo pasado a 'Objects.hash()' debería estar envuelto en 'Arrays.hashcode()'
octal.and.decimal.integers.in.same.array.display.name=Enteros Octales y Decimales en el mismo array
octal.and.decimal.integers.in.same.array.problem.descriptor=Enteros octales y decimales en el mismo inicializador de array #loc
octal.literal.display.name=Entero octal
octal.literal.problem.descriptor=Entero octal <code>#ref</code> #loc
only.report.public.methods.option=Sólo reportar métodos 'públicos'
only.report.qualified.static.usages.option=Solo informar uso estático cualificado desde contexto estático
only.report.static.methods=Sólo reportar métodos 'static'(&O)
only.warn.on.protected.clone.methods=Solo advertir en métodos clone 'protected'
only.warn.on.public.clone.methods=Sólo advertir en métodos clonar 'public'
optional.contains.array.problem.descriptor='Optional' contiene el arreglo <code>#ref</code>
optional.contains.collection.display.name='Optional' contiene una matriz o colección
optional.contains.collection.problem.descriptor='Optional' contiene la colección <code>#ref</code>
optional.used.as.field.or.parameter.type.display.name='Optional' utilizado como tipo de campo o parámetro
optional.used.as.field.type.problem.descriptor=<code>#ref</code> usado como tipo para el campo ''{0}''
optional.used.as.parameter.type.problem.descriptor=<code>#ref</code> usado como tipo para parámetro ''{0}''
options.label.ignored.classes=Clases ignoradas:
options.title.ignored.classes=Clases ignoradas
overloaded.methods.with.same.number.parameters.display.name=Métodos sobrecargados con el mismo número de parámetros
overloaded.methods.with.same.number.parameters.option=<html>Ignorar métodos sobrecargados cuyos tipos de parámetro son definitivamente incompatibles</html>
overloaded.methods.with.same.number.parameters.problem.descriptor=Existen varios métodos llamados `#ref` con el mismo número de parámetros #loc
overloaded.vararg.constructor.problem.descriptor=Constructor `#ref()`, varargs sobrecargados en #loc
overloaded.vararg.method.display.name=Método varargs sobrecargado
overloaded.vararg.method.problem.descriptor=Método <code>#ref()</code> varargs sobrecargado #loc
overloaded.vararg.method.problem.option=Ignorar métodos sobrecargados cuyos tipos de parámetro sean definitivamente incompatibles
overly.broad.throws.clause.display.name=Cláusula 'throws' demasiado amplia
overly.broad.throws.clause.ignore.thrown.option=Ignorar excepciones que ocultan las demás pero son lanzadas por sí mismas(&H)
overly.broad.throws.clause.problem.descriptor1=<code>throws #ref</code> es demasiado amplio, enmascarando la excepción ''{0}'' #loc
overly.broad.throws.clause.problem.descriptor2=<code>throws #ref</code> es demasiado genérica, enmascarando las excepciones ''{0}'' y ''{1}'' #loc
overly.broad.throws.clause.quickfix1=Añadir excepciones específicas
overly.broad.throws.clause.quickfix2=Reemplazar con excepciones específicas
overly.broad.throws.clause.threshold.option=Limite de excepciones ocultas a informar:
overly.complex.anonymous.inner.class.display.name=Clase interna anónima muy compleja
overly.complex.anonymous.inner.class.problem.descriptor=Clase interna anónima demasiado compleja (complejidad ciclomática = {0}) #loc
overly.complex.arithmetic.expression.display.name=Expresión aritmética demasiado compleja
overly.complex.arithmetic.expression.max.number.option=Máximo número de términos:
overly.complex.arithmetic.expression.problem.descriptor=Expresión aritmética demasiado compleja #loc
overly.complex.boolean.expression.display.name=Expresión booleana demasiado compleja
overly.complex.boolean.expression.ignore.option=Ignorar conjunciones y disyunciones puras
overly.complex.boolean.expression.max.terms.option=Máximo número de términos:
overly.complex.boolean.expression.problem.descriptor=Expresión booleana demasiado compleja ({0} términos) #loc
overly.complex.class.display.name=Clase demasiado compleja
overly.complex.class.problem.descriptor=Clase demasiado compleja <code>#ref</code> (complejidad ciclomática = {0}) #loc
overly.coupled.class.class.coupling.limit.option=Límite de acoplamiento de clase:
overly.coupled.class.display.name=Clase excesivamente acoplada
overly.coupled.class.problem.descriptor=<code>#ref</code> está sobreacoplado (dependencias = {0}) #loc
overly.long.lambda.display.name=Expresión lambda excesivamente larga
overly.long.lambda.problem.descriptor=La expresión lambda es demasiado larga (#Sentencias de origen sin comentarios = {0}) #loc
overly.strong.type.cast.display.name=Conversiones de tipo demasiado estrictas
overly.strong.type.cast.ignore.in.matching.instanceof.option=Ignorar conversiones con una expresión instanceof coincidente
overly.strong.type.cast.problem.descriptor=El cast a <code>#ref</code> se puede debilitar a ''{0}'' #loc
overly.strong.type.cast.weaken.quickfix=Debilitar conversión fuerte
overridable.method.call.in.constructor.display.name=Llamada a método sobreescribible durante la construcción de objetos
overridable.method.call.in.constructor.problem.descriptor=Llamada al método sobreescribible <code>#ref()</code> durante la construcción del objeto #loc
overridden.method.call.in.constructor.display.name=Llamada al método sobreescrito durante la construcción del objeto
overridden.method.call.in.constructor.problem.descriptor=Llamada al método sobreescrito <code>#ref()</code> durante la construcción del objeto #loc
package.dot.html.may.be.package.info.convert.quickfix=Convertir a 'package-info.java'
package.dot.html.may.be.package.info.delete.quickfix=Borrar 'package.html'
package.dot.html.may.be.package.info.display.name='package.html' se puede convertir a 'package-info.java'
package.dot.html.may.be.package.info.exists.problem.descriptor=Se ignora <code>package.html</code> porque existe <code>package-info.java</code>
package.dot.html.may.be.package.info.problem.descriptor=<code>package.html</code> puede convertirse a <code>package-info.java</code>
package.in.multiple.modules.display.name=Paquete con clases en múltiples módulos
package.in.multiple.modules.problem.descriptor.many=El paquete ''{0}'' tiene clases en módulos ''{1}''、''{2}'' y otros {3} módulos
package.in.multiple.modules.problem.descriptor2=El paquete ''{0}'' tiene clases en los módulos ''{1}'' y ''{2}''
package.in.multiple.modules.problem.descriptor3=El paquete ''{0}'' contiene clases en módulos ''{1}'', ''{2}'' y ''{3}''
package.info.java.without.package.display.name='package-info.java' sin sentencia 'package'
package.info.without.package.family.quickfix=Agregar instrucción package
package.info.without.package.problem.descriptor='package-info.java' no tiene una declaración 'package'
package.info.without.package.quickfix=Agregar ''package {0};''
package.local.field.not.accessible=El campo ''{0}'' privado del paquete no es accesible desde aquí
package.local.private=privado de paquete y privado
package.naming.convention.display.name=Convención de nombres del paquete
package.naming.convention.problem.descriptor.long=El nombre del paquete <code>{0}</code> es demasiado largo
package.naming.convention.problem.descriptor.regex.mismatch=Nombre del paquete <code>{0}</code> no coincide con la expresión regular ''{1}''
package.naming.convention.problem.descriptor.short=El nombre del paquete <code>{0}</code> es demasiado corto
package.visible.field.display.name=Campo visible del paquete
package.visible.field.problem.descriptor=Campo visible en el paquete <code>#ref</code> #loc
package.visible.inner.class.display.name=Clase anidada visible para el paquete
package.visible.inner.class.ignore.enum.option=Ignorar enums internas visibles del paquete
package.visible.inner.class.ignore.interface.option=Ignorar interfaces internas visibles del paquete
package.visible.inner.class.problem.descriptor=Clase interna visible para el paquete <code>#ref</code> #loc
package.with.too.few.classes.display.name=Paquete con muy pocas clases
package.with.too.few.classes.min.option=Número mínimo de clases:
package.with.too.few.classes.problem.descriptor=Paquete ''{0}'' contiene muy pocas clases ({1} < {2})
package.with.too.many.classes.display.name=Paquete con demasiadas clases
package.with.too.many.classes.max.option=Número máximo de clases:
package.with.too.many.classes.problem.descriptor=El paquete ''{0}'' contiene demasiadas clases ({1} > {2})
parameter.hides.member.variable.display.name=El parámetro oculta la variable miembro
parameter.hides.member.variable.ignore.abstract.methods.option=Ignorar para métodos abstractos
parameter.hides.member.variable.ignore.constructors.option=Ignorar para constructores
parameter.hides.member.variable.ignore.setters.option=Ignorar para los setters de propiedades
parameter.hides.member.variable.ignore.static.parameters.option=Ignorar para parámetros de métodos estáticos que ocultan campos de instancia
parameter.hides.member.variable.ignore.superclass.option=Ignorar campos de súper clase que no están visibles en subclase
parameter.hides.member.variable.problem.descriptor=El parámetro <code>#ref</code> oculta el campo en la clase ''{0}'' #loc
parameter.limit.option=Límite de parámetros:
parameter.name.differs.from.overridden.parameter.display.name=El nombre del parámetro difiere del parámetro en el método sobreescrito o sobrecargado
parameter.name.differs.from.overridden.parameter.ignore.character.option=Ignorar si el parámetro sobreescrito contiene solo un carácter
parameter.name.differs.from.overridden.parameter.ignore.library.option=Ignorar si el parámetro sobreescrito es de una biblioteca
parameter.name.differs.from.overridden.parameter.problem.descriptor=El nombre del parámetro <code>#ref</code> es diferente del parámetro ''{0}'' en el {1, choice, 1#supermétodo|2#método sobrecargado|3#superconstructor|4#constructor sobrecargado} #loc
parameter.naming.convention.display.name=Convención de nomenclatura para parámetros de método
parameter.naming.convention.element.description=Parámetro
parameter.type.prevents.overriding.display.name=El tipo de parámetro impide la anulación
parameter.type.prevents.overriding.family.quickfix=Cambiar tipo de parámetro
parameter.type.prevents.overriding.problem.descriptor=El tipo de parámetro <code>#ref</code> está en ''{0}'' mientras que el tipo de parámetro del método super está en ''{1}'' impidiendo el override #loc
parameter.type.prevents.overriding.quickfix=Cambiar tipo de parámetro a ''{0}''
parameters.per.constructor.display.name=Constructor con demasiados parámetros
parameters.per.constructor.problem.descriptor=<code>#ref()</code> tiene demasiados parámetros (número de parámetros = {0}) #loc
parameters.per.method.display.name=Método con demasiados parámetros
parameters.per.method.problem.descriptor=<code>#ref()</code> tiene demasiados parámetros (num. parámetros = {0}) #loc
pattern.variable.hides.field.display.name=La variable patrón oculta campo
pattern.variable.hides.field.problem.descriptor=La variable de patrón <code>#ref</code> oculta el campo en la clase ''{0}'' #loc
pointless.arithmetic.expression.display.name=Expresión aritmética trivial
pointless.bitwise.expression.display.name=Expresión de bits irrelevante
pointless.bitwise.expression.simplify.quickfix=Simplificar
pointless.boolean.expression.display.name=Expresión booleana inservible
pointless.boolean.expression.ignore.option=Ignorar constantes con nombre al determinar expresiones sin sentido
pointless.indexof.comparison.always.false.problem.descriptor=<code>#ref</code> siempre es falso #loc
pointless.indexof.comparison.always.true.problem.descriptor=<code>#ref</code> es siempre verdadero #loc
pointless.indexof.comparison.display.name=Comparación sin sentido de 'indexOf()'
pointless.nullcheck.display.name=Comprobación innecesaria de 'null' antes de la llamada al método
pointless.nullcheck.problem.descriptor.call=Comprobación nula innecesaria antes de la llamada ''{0}()''
possible.throw.from.finally.block.problem.descriptor=Es posible que se genere <code>{0}</code> dentro del bloque ''finally'' #loc
prefer.empty.array.options.mode.always=Siempre
prefer.empty.array.options.mode.always.never=Nunca (prefiera un arreglo predimensionado)
prefer.empty.array.options.mode.by.level=Según nivel de lenguaje
prefer.empty.array.options.title=Preferir array vacío:
prefix.operation.quickfix.family.name=Reemplazar con operador prefijo
press.escape.to.remove.highlighting.message=Presione Escape para eliminar el resaltado
primitive.array.argument.to.var.arg.method.display.name=Argumento de matriz primitiva confusa a método varargs
primitive.array.argument.to.var.arg.method.problem.descriptor=Argumento de array primitivo confuso al método varargs #loc
primitive.fields.ignore.option=Ignorar campos primitivos
printstacktrace.call.display.name=Llamada a 'printStackTrace()'
printstacktrace.call.problem.descriptor=La llamada a <code>#ref()</code> debería ser reemplazada por un registro más robusto #loc
private=privado
private.field.not.accessible.problem.descriptor=''private'' campo ''{0}'' no es accesible desde aquí
private.member.access.between.outer.and.inner.classes.display.name=Acceso sintético entre clases externas e internas
private.member.access.between.outer.and.inner.classes.make.constructor.package.local.quickfix=Hacer constructor ''{0}'' privado de paquete
private.member.access.between.outer.and.inner.classes.make.local.quickfix=Convertir ''{0}'' a paquete privado
private.member.access.between.outer.and.inner.classes.problem.descriptor=El acceso al miembro ''private'' de la clase ''{0}'' requiere un descriptor de acceso sintético #loc
problematic.varargs.method.display.name=El método no varargs reemplaza al método varargs
problematic.varargs.method.override.problem.descriptor=El método sin varargs <code>#ref()</code> sobreescribe al método #loc con varargs
progress.text.analyzing.package.0=Analizando paquete {0}
properties.object.as.hashtable.display.name=Uso del objeto 'Properties' como 'Hashtable'
properties.object.as.hashtable.problem.descriptor=Llamada a <code>Hashtable.#ref()</code> en el objeto de propiedades #loc
property.value.set.to.itself.display.name=Valor de propiedad definido para sí mismo
protected.field.display.name=Ámbito protegido
protected.field.not.accessible.problem.descriptor='''protected'' campo ''{0}'' no es accesible desde aquí
protected.field.problem.descriptor=Campo protegido <code>#ref</code> #loc
protected.inner.class.display.name=Clase protegida anidada
protected.inner.class.ignore.enum.option=Ignorar enums internas 'protected'
protected.inner.class.ignore.interface.option=Ignorar interfaces 'protected' internas
protected.inner.class.problem.descriptor=Clase interna protegida <code>#ref</code> #loc
protected.member.in.final.class.display.name='protected' miembro en clase 'final'
protected.member.in.final.class.problem.descriptor=Miembro de clase declarado como <code>#ref</code> en clase <code>'final'</code> #loc
protected.package.local.private=protegido, paquete-privado y privado
public.constructor.display.name="constructor público" puede reemplazarse con el método de fábrica
public.constructor.in.non.public.class.display.name='public' constructor en clase no pública
public.constructor.in.non.public.class.problem.descriptor=Constructor declarado como <code>#ref</code> en la clase no pública ''{0}'' #loc
public.constructor.in.non.public.class.quickfix=Convertir constructor en privado
public.constructor.problem.descriptor=Constructor público <code>#ref()</code> #loc
public.constructor.quickfix=Reemplazar constructor por método fábrica
public.default.constructor.problem.descriptor=La clase <code>#ref</code> tiene un constructor predeterminado 'público'
public.field.accessed.in.synchronized.context.display.name=Campo no privado accedido en un contexto 'sincronizado'
public.field.accessed.in.synchronized.context.problem.descriptor=Campo no privado <code>#ref</code> se accedió en un contexto sincronizado  #loc
public.field.display.name=campo 'public'
public.field.ignore.enum.type.fields.option=Ignorar campos 'public final' de un tipo de enumeración
public.field.problem.descriptor='public' campo <code>#ref</code> #loc
public.inner.class.display.name='public' clase anidada
public.inner.class.ignore.enum.option=Ignorar enums internos 'públicos'
public.inner.class.ignore.interface.option=Ignorar interfaces internas 'public'
public.inner.class.problem.descriptor='public' clase interior <code>#ref</code> #loc
public.method.not.in.interface.display.name=Método 'public' no expuesto en la interfaz
public.method.not.in.interface.option=<html>Ignorar si la clase contenedora no implementa una interfaz que no sea de biblioteca</html>
public.method.not.in.interface.problem.descriptor='método' público <code>#ref()</code> no está expuesto a través de una interfaz #loc
public.method.without.logging.display.name='público' método sin registro
public.method.without.logging.problem.descriptor='public' método <code>#ref()</code> no tiene llamada de registro #loc
public.static.array.field.display.name=public static' campo de array
public.static.array.field.problem.descriptor='public static' campo de matriz <code>#ref</code>, que compromete la seguridad #loc
public.static.collection.field.display.name='public static' campo de colección
public.static.collection.field.problem.descriptor=El campo <code>#ref</code> de colección 'public static' compromete la seguridad #loc
qualify.call.fix.family.name=Calificar llamada
query.label=Los nombres de consulta comienzan con:
questionable.name.display.name=Nombre sospechoso
questionable.name.list.label=Nombres reportados:
questionable.name.problem.descriptor=Nombre cuestionable <code>#ref</code> #loc
random.double.for.random.integer.display.name=Uso de 'Random.nextDouble()' para obtener un entero aleatorio
random.double.for.random.integer.problem.descriptor=Uso de <code>Random.#ref</code> para crear un entero aleatorio #loc
raw.use.of.parameterized.type.display.name=Uso bruto del tipo parametrizado
readobject.initialization.display.name=El campo de instancia podría no ser inicializado mediante 'readObject()'
readobject.initialization.problem.descriptor=El campo de la instancia `#ref` puede que no se inicialice durante la llamada a `readObject()` #loc
readresolve.writereplace.protected.display.name='readResolve()' o 'writeReplace()' no declarada como 'protected'
readresolve.writereplace.protected.problem.descriptor=<code>#ref()</code> no fue declarado como 'protected' #loc
readwriteobject.private.display.name='readObject()' o 'writeObject()' no declarados 'private'
readwriteobject.private.problem.descriptor=<code>#ref</code> no declarada como "privada". #loc
recordstore.opened.not.safely.closed.display.name='RecordStore' abierto pero no cerrado seguro
redundant.as.list.for.iteration.fix.name=Desempaquetar
redundant.as.list.for.iteration.problem=Llamada innecesaria 'Arrays.asList()'
redundant.call.problem.descriptor=Redundante llamada <code>#ref()</code> #loc
redundant.else.display.name=Sentencia 'else' redundante
redundant.else.problem.descriptor=La rama <code>#ref</code> se puede deshacer, ya que la rama 'if' nunca se completa normalmente #loc
redundant.else.unwrap.quickfix=Eliminar 'else' redundante
redundant.escape.in.regex.replacement.display.name=Escape redundante en cadena de sustitución de regex
redundant.escape.in.regex.replacement.problem.descriptor=Escape redundante de ''{0}''
redundant.escape.in.regex.replacement.quickfix=Eliminar escape redundante
redundant.explicit.var.type.display.name=El tipo de variable local se puede omitir
redundant.field.initialization.display.name=Inicialización de campo redundante
redundant.field.initialization.problem.descriptor=Redundante: inicialización del campo a <code>#ref</code> #loc
redundant.field.initialization.remove.quickfix=Eliminar inicialización de campo
redundant.implements.display.name=Declaración de interfaz redundante
redundant.implements.problem.descriptor=Declaración de interfaz redundante <code>#ref</code> #loc
redundant.implements.remove.quickfix=Eliminar declaración de interfaz redundante
redundant.local.variable.annotation.option=Ignorar variables que tienen una anotación
redundant.local.variable.display.name=Variable local redundante
redundant.local.variable.ignore.option=Ignorar variables que regresan o lanzan excepciones inmediatamente
redundant.method.override.delegate.quickfix=Reemplazar método con delegado a super
redundant.method.override.delegates.to.super.problem.descriptor=El método <code>#ref()</code> solo delega a su súper método #loc
redundant.method.override.display.name=El método es idéntico a su método super
redundant.method.override.option.check.library.methods=Verificar métodos que sobrescriben métodos de librerías
redundant.method.override.option.ignore.delegates=Ignorar delegados a supermétodos
redundant.method.override.problem.descriptor=El método <code>#ref()</code> es idéntico a su método super #loc
redundant.method.override.quickfix=Eliminar método redundante
redundant.string.format.call.display.name=Llamada redundante a "String.format()"
redundant.string.format.call.quickfix=Eliminar llamada redundante a 'String.format()'
redundant.string.formatted.call.quickfix=Eliminar la llamada redundante a 'String.formatted()'
referencing.subclass.0.from.superclass.1.initializer.might.lead.to.class.loading.deadlock=Referenciar la subclase {0} desde el inicializador de la superclase {1} podría provocar un punto muerto al cargar las clases
reflection.for.unavailable.annotation.display.name=Acceso reflexivo a una anotación de solo origen
reflection.for.unavailable.annotation.problem.descriptor=La annotation '#ref' no se retiene para acceso reflexivo #loc
refused.bequest.display.name=El método no llama al método súper
refused.bequest.fix.family.name=Inserta llamada al super método
refused.bequest.ignore.default.super.methods.option=Ignorar métodos super 'default'
refused.bequest.ignore.empty.super.methods.option=Ignorar métodos vacíos super
refused.bequest.problem.descriptor=Método <code>#ref()</code> no llama a 'super.#ref()' #loc
remove.annotation.parameter.0.fix.name=Quitar parámetro de anotación ''{0}''
remove.call.fix.family.name=Remover llamada
remove.cloneable.quickfix=Eliminar 'Cloneable' de la cláusula 'implements'
remove.finally.block.quickfix=Eliminar el bloque 'finally'
remove.leading.zero.to.make.decimal.quickfix=Quitar el cero inicial para crear decimal
remove.leading.zeroes.to.make.decimals.quickfix=Quitar ceros a la izquierda para formar decimales
remove.loop.fix.family.name=Eliminar bucle
remove.modifier.fix.family.name=Eliminar modificador
remove.modifier.quickfix=Eliminar el modificador ''{0}''
remove.redundant.polyadic.operand.fix.family.name=Quitar condición redundante
remove.redundant.polyadic.operand.fix.name=Elimine la redundante condición ''{0}''
remove.redundant.string.fix.text=Usa ''{0}()'' y elimina la llamada redundante ''{1}()''
remove.redundant.substring.fix.family.name=Eliminar llamada redundante 'substring()'
remove.try.finally.block.quickfix=Quitar bloque 'try-finally'
remove.unnecessary.0.call.quickfix=Eliminar llamada innecesaria ''{0}()''
rename.quickfix=Renombrar
renameto.quickfix=Renombrar a ''{0}''
replace.all.dot.display.name=Argumento de expresión regular sospechoso
replace.all.dot.problem.descriptor=Expresión regular sospechosa #ref en la llamada a ''{0}()'' #loc
replace.all.dot.quickfix=escapar metacaracteres de regex
replace.all.file.separator.problem.descriptor=File.separator usado como regex; no funcionará en Windows
replace.anonymous.with.lambda.body.fix.family.name=Reemplazar llamada con cuerpo de método
replace.case.default.null.with.null.default=Reemplazar 'case default, null' con 'case null, default'
replace.case.default.with.default=Reemplazar "case default" con "default"
replace.cast.fix.family.name=Reemplazar transformar el tipo
replace.casted.literal.with.just.literal.fix.family.name=Reemplazar con el literal {0}
replace.field.reference.fix.family.name=Corregir referencia de campo
replace.field.reference.fix.text=Reemplazar referencia de campo con ''{0}''
replace.inheritance.with.delegation.quickfix=Reemplazar herencia con delegación
replace.instanceof.fix.family.name=Reemplazar tipo instanceOf
replace.method.call.fix.family.name=Reemplazar llamada de método
replace.method.call.fix.text=Reemplazar llamada del método con ''{0}''
replace.method.ref.with.qualifier.fix.family.name=Reemplazar por calificador
replace.method.ref.with.qualifier.problem.lambda=Se puede reemplazar la lambda con el calificador de llamada
replace.method.ref.with.qualifier.problem.method=Referencia a método se puede sustituir con calificador
replace.with.cast.fix.family.name=Reemplazar con Cast
replace.with.catch.clause.for.runtime.exception.quickfix=Reemplazar con cláusula "catch" para "RuntimeException"
replace.with.comparator.fix.family.name=Simplificar comparador utilizando métodos estáticos 'Comparator'
replace.with.lambda.body.fix.family.name=Reemplazar llamada de método sobre lambda con cuerpo de lambda
replace.with.method.ref.fix.family.name=Reemplazar lambda por referencia de método
replace.with.method.ref.fix.name.may.change.semantics=Sustituir lambda por referencia de método (puede cambiar la semántica)
replace.with.method.reference.fix.family.name=Reemplazar llamada a método en referencia a método con llamada a método correspondiente
replace.with.var.fix.family.name=Reemplazar el tipo explícito con 'var'
resource.opened.not.closed.problem.descriptor=''{0}'' debe abrirse antes de un bloque ''try'' y cerrarse en el bloque ''finally'' correspondiente #loc
result.of.method.call.ignored.class.column.title=Nombre de la clase
result.of.method.call.ignored.display.name=Resultado de la llamada al método ignorado
result.of.method.call.ignored.non.library.option=Informar de todas las llamadas ignoradas que no están en la biblioteca
result.of.method.call.ignored.problem.descriptor=El resultado de la <code>{0}.#ref()</code> se ignora #loc
result.of.object.allocation.fix.name=Ignorar asignaciones de objetos con tipo ''{0}''
result.of.object.allocation.ignored.display.name=Resultado de asignación de objeto ignorado
result.of.object.allocation.ignored.options.chooserTitle=Elegir clase para la que se puede ignorar la asignación de objetos
result.of.object.allocation.ignored.problem.descriptor=El resultado de <code>new #ref()</code> es ignorado #loc
result.of.object.allocation.ignored.problem.descriptor.methodRef=Los objetos asignados en <code>#ref</code> están obsoletos #loc
return.from.finally.block.display.name=retorno dentro del bloque 'finally'
return.from.finally.block.problem.descriptor='return' dentro de bloque 'finally' #loc
return.of.anonymous.class.problem.descriptor=Regreso de instancia de clase anónima #loc
return.of.collection.field.fix.family.name=Convierte la colección de retorno en 'inmodificable'
return.of.field.with.mutable.type.problem.descriptor=Retorno del campo {0} `{#1}` #loc
return.of.inner.class.display.name=Retorno de instancia de clase anónima, local o interna
return.of.inner.class.ignore.non.public.option=Ignorar devoluciones de métodos no públicos
return.of.inner.class.problem.descriptor=Retorno de la instancia de la clase interna no estática <code>{0}</code> #loc
return.of.local.class.problem.descriptor=Retorno de instancia de la clase local <code>{0}</code> #loc
return.of.null.arrays.option=Informar métodos que devuelven matrices
return.of.null.collections.option=Informar métodos que devuelven objetos de colección
return.of.null.display.name=Retorno de 'null'
return.of.null.ignore.private.option=Ignorar métodos 'private', clases anónimas y lambdas
return.of.null.objects.option=Reportar métodos que retornan objetos
return.of.null.problem.descriptor=Retorno de <code>#ref</code> #loc
return.point.limit.option=Límite de punto de retorno:(&R)
return.this.display.name=Retorno de 'this'
return.this.problem.descriptor=Retorno de <code>#ref</code> #loc
reuse.of.local.variable.display.name=Reutilización de la variable local
reuse.of.local.variable.problem.descriptor=Reutilización de la variable local <code>#ref</code> #loc
reuse.of.local.variable.split.quickfix=Dividir variable local
runtime.exec.call.display.name=Llamada a 'Runtime.exec()'
runtime.exec.call.problem.descriptor=La llamada a <code>Runtime.#ref()</code> no es portable #loc
runtime.exec.with.non.constant.string.display.name=Llamada a 'Runtime.exec()' con string no constante
runtime.exec.with.non.constant.string.problem.descriptor=Llamada a <code>Runtime.#ref()</code> con argumento no constante #loc
safe.lock.display.name=Bloqueo adquirido pero no liberado de forma segura
safe.lock.problem.descriptor=''{0}'' debe bloquearse antes de un bloque ''try'' y desbloquearse en el bloque ''finally'' correspondiente #loc
serial.annotation.used.on.wrong.member.display.name='@Serial' annotation used on wrong member
serial.annotation.used.on.wrong.member.problem.descriptor=El miembro anotado no es parte del mecanismo de serialización
serializable.anonymous.class.stores.non.serializable.problem.descriptor=La clase anónima serializable almacena implícitamente un objeto no serializable de tipo ''{0}''
serializable.class.in.secure.context.display.name=Clase serializable en contexto seguro
serializable.class.in.secure.context.problem.descriptor=La clase <code>#ref</code> se puede serializar, comprometiendo la seguridad #loc
serializable.deserializable.class.in.secure.context.problem.descriptor=La clase <code>#ref</code> podría serializarse y deserializarse afectando a la seguridad #loc
serializable.has.serialization.methods.display.name=Clase serializable sin 'readObject()' y 'writeObject()'
serializable.has.serialization.methods.ignore.option=Ignorar clases que no definen campos de instancia
serializable.has.serialization.methods.problem.descriptor=La clase serializable <code>#ref</code> no define 'readObject()' o 'writeObject()' #loc
serializable.has.serialization.methods.problem.descriptor1=La clase serializable <code>#ref</code> no define 'writeObject()' #loc
serializable.has.serialization.methods.problem.descriptor2=La clase serializable <code>#ref</code> no define 'readObject()' #loc
serializable.inner.class.has.serial.version.uid.field.display.name=Clase interna no estática con 'serialVersionUID'
serializable.inner.class.has.serial.version.uid.field.problem.descriptor=La clase interna <code>#ref</code> no define el campo 'serialVersionUID' #loc
serializable.inner.class.with.non.serializable.outer.class.display.name=Clase interna serializable no 'static' con clase externa no serializable
serializable.inner.class.with.non.serializable.outer.class.problem.descriptor=La clase interna <code>#ref</code> es serializable mientras que su clase externa no #loc
serializable.lambda.stores.non.serializable.problem.descriptor=Lambda serializable almacena implícitamente objeto no serializable de tipo ''{0}''
serializable.local.class.stores.non.serializable.problem.descriptor=La clase local serializable ''{1}'' almacena implícitamente un objeto no serializable de tipo ''{0}''
serializable.record.contains.ignored.field.problem.descriptor=<code>#ref</code> se ignorará durante la serialización del registro
serializable.record.contains.ignored.members.display.name='record' contiene miembros ignorados
serializable.record.contains.ignored.method.problem.descriptor=Se ignorará <code>#ref()</code> durante la serialización de registros
serializable.stores.non.serializable.display.name='Objeto serializable' almacena implícitamente un objeto no 'serializable'
serializable.with.unconstructable.ancestor.display.name=Clase serializable con ancestro no construible
serializable.with.unconstructable.ancestor.problem.descriptor=<code>#ref</code> tiene un ancestro no serializable ''{0}'' sin constructor sin argumentos #loc
serialpersistentfields.with.wrong.signature.display.name='serialPersistentFields' campo no declarado 'private static final ObjectStreamField[]'
serialpersistentfields.with.wrong.signature.problem.descriptor=El campo <code>#ref</code> de una clase serializable no está declarado como 'private static final ObjectStreamField[]' #loc
serialversionuid.private.static.final.long.display.name=campo 'serialVersionUID' no declarado como 'private static final long'
serialversionuid.private.static.final.long.problem.descriptor=El campo <code>#ref</code> de una clase serializable no se ha declarado como 'private static final long' #loc
serialversionuid.private.static.final.long.quickfix=Establecer serialVersionUID como 'private static final'
set.annotation.parameter.0.1.fix.name=Establecer el parámetro de anotación {0} como "{1}"
set.replaceable.by.enum.set.display.name='Set' se puede reemplazar por 'EnumSet'
set.replaceable.by.enum.set.problem.descriptor=<code>#ref</code> puede reemplazarse con 'EnumSet' #loc
shared.thread.local.random.display.name=La instancia 'ThreadLocalRandom' se puede compartir
shared.thread.local.random.problem.descriptor='ThreadLocalRandom' instancia se puede compartir entre hilos
shift.operation.by.inappropriate.constant.display.name=Operación shift por constante inapropiado
shift.operation.by.inappropriate.constant.problem.descriptor.negative=Operación de corrimiento en <code>#ref</code> por constante negativa {0} #loc
shift.operation.by.inappropriate.constant.problem.descriptor.out.of.bounds=Operación de desplazamiento <code>#ref</code> con valor fuera de límites {0}#loc
shift.operation.by.inappropriate.constant.problem.descriptor.too.large=Operación de desplazamiento de <code>#ref</code> mediante un valor constante excesivamente grande {0} #loc
shift.out.of.range.fix.family.name=Arregalar el valor de desplazamiento
side.effects.method.ref.to.lambda.fix.family.name={0} (efectos secundarios)
signal.without.corresponding.await.display.name='signal()' sin el correspondiente 'await()'
signal.without.corresponding.await.problem.descriptor=Llamada a <code>#ref()</code> sin el correspondiente <code>await()</code> #loc
simplifiable.annotation.braces.problem.descriptor=Llaves innecesarias alrededor de <code>{0}</code> en la notación #loc
simplifiable.annotation.display.name=Anotación simplificable
simplifiable.annotation.problem.descriptor=Referencia innecesaria <code>#ref</code> en la anotación #loc
simplifiable.annotation.quickfix=Simplificar anotación
simplifiable.annotation.whitespace.problem.descriptor=Espacio en blanco innecesario en la anotación #loc
simplifiable.boolean.expression.display.name=Expresión booleana simplificable
simplifiable.conditional.expression.display.name=Expresión condicional simplificable
simplifiable.conditional.expression.problem.descriptor=<code>{1}</code> se puede simplificar a ''{0}'' #loc
simplifiable.equals.expression.display.name=Comprobación 'null' innecesaria antes de la llamada 'equals()'
simplifiable.equals.expression.option.non.constant=Informar sobre equals con argumentos no constantes no nulos
simplifiable.equals.expression.problem.descriptor=Verificación innecesaria de ''null'' antes de la llamada ''{0}()'' #loc
simplifiable.equals.expression.quickfix=Intercambiar ''.{0}()'' y eliminar comprobación innecesaria de ''null''
simplifiable.junit.assertion.display.name=Aserción simplificable
simplifiable.junit.assertion.problem.descriptor=<code>#ref()</code> puede simplificarse a ''{0}'' #loc
simplify.junit.assertion.simplify.quickfix=Simplificar aserción
single.character.startswith.display.name=Inicio o fin con un solo caracter 'startswith()' o 'endsWith()'
single.character.startswith.problem.descriptor=El carácter individual <code>#ref()</code> se puede reemplazar con la expresión 'charAt()' #loc
single.character.startswith.quickfix=Reemplazar con expresión 'charAt()'
single.class.import.display.name=Importación de clase única
single.class.import.problem.descriptor=Importación de clase única <code>#ref</code> #loc
single.element.annotation.family.quickfix=Expandir la anotación a una forma normal
single.element.annotation.name=Anotación no normalizada
single.element.annotation.quickfix=Añadir 'value='
single.statement.in.block.descriptor=''{0}'' contiene una única sentencia
single.statement.in.block.family.quickfix=Eliminar llaves de la sentencia
single.statement.in.block.name=El bloque de código contiene una única instrucción
single.statement.in.block.quickfix=Eliminar llaves de la sentencia ''{0}''
singleton.display.name=Singleton
singleton.problem.descriptor=La clase <code>#ref</code> es un singleton #loc
size.replaceable.by.isempty.display.name='size() == 0' puede reemplazarse con 'isEmpty()'
size.replaceable.by.isempty.fix.ignore.calls=Ignorar llamadas ''.{0}()'' en el tipo ''{1}''
size.replaceable.by.isempty.negation.ignore.option=Ignorar expresiones que serían reemplazadas por '!isEmpty()'
sleep.while.holding.lock.display.name=Llamada a 'Thread.sleep()' mientras se está sincronizando
sleep.while.holding.lock.problem.descriptor=Llamada a `Thread.#ref()` mientras se sincronizaba #loc
smth.unnecessary.remove.quickfix=Remover ''{0}'' innecesario
socket.opened.not.closed.display.name=Socket abierto pero no cerrado de forma segura
standard.variable.names.display.name=Nombres de variables estándar
standard.variable.names.ignore.override.option=Ignorar para nombres de parámetros idénticos a los de los parámetros del super método
standard.variable.names.problem.descriptor=La variable denominada <code>#ref</code> no tiene el tipo ''{0}'' #loc
standard.variable.names.problem.descriptor2=La variable denominada <code>#ref</code> no tiene el tipo ''{0}'' o ''{1}'' #loc
statement.problem.descriptor=<code>#ref</code> sentencia #loc
statement.with.empty.body.display.name=Sentencia con cuerpo vacío
statement.with.empty.body.include.option=Incluir cuerpos de declaración con bloques de código vacíos
statement.with.empty.body.problem.descriptor=La declaración <code>#ref</code> tiene un cuerpo vacío #loc
static.collection.display.name=Colección estática
static.collection.ignore.option=Ignorar colecciones o mapas débiles static
static.collection.problem.descriptor=Colección estática <code>#ref</code> #loc
static.field.via.subclass.display.name=Campo estático referenciado a través de subclase
static.field.via.subclass.problem.descriptor=Campo estático <code>#ref</code> declarado en la clase ''{0}'' pero referenciado a través de la subclase ''{1}'' #loc
static.field.via.subclass.rationalize.quickfix=Racionalizar el acceso al campo estático
static.import.display.name=Importación estática
static.import.fix.ignore.class=Permitir importaciones estáticas para la clase "{0}"
static.import.options.border.title=Clases imp importables estáticamente:
static.import.options.chooserTitle=Ventana seleccionadora de clases importables estáticamente
static.import.problem.descriptor=Importación estática <code>#ref</code>  #loc
static.import.replace.quickfix=Reemplazar con import no estático
static.inheritance.display.name=Herencia estática
static.inheritance.fix.family.name=Reemplazar herencia con referencia calificada
static.inheritance.problem.descriptor=La interfaz <code>#ref</code> se implementó solo para sus constantes estáticas #loc
static.inheritance.replace.quickfix=Reemplazar herencia con referencias calificadas en {0}
static.initializer.references.subclass.display.name=El inicializador estático hace referencia a la subclase
static.method.naming.convention.element.description=método 'static'
static.method.only.used.in.one.anonymous.class.problem.descriptor=El {0, choice, 1#método|2#campo} <code>#ref{0, choice, 1#()|2#}</code> estático se usa solo en una clase anónima derivada de ''{1}'' #loc
static.method.only.used.in.one.class.display.name=Miembro estático solo usado en una clase
static.method.only.used.in.one.class.ignore.anonymous.option=Ignorar cuando solo se use desde una clase anónima
static.method.only.used.in.one.class.ignore.on.conflicts=Ignorar cuando el método no se puede mover sin conflictos
static.method.only.used.in.one.class.ignore.test.option=Ignorar solo si es usado desde la clase de prueba
static.method.only.used.in.one.class.ignore.utility.classes=Ignorar miembros ubicados en clases de utilidad
static.method.only.used.in.one.class.problem.descriptor=El método o campo {0, choice, 1#estático|2#estático} <code>#ref{0, choice, 1#()|2#}</code> solo se usa en la clase ''{1}'' #loc
static.method.only.used.in.one.class.quickfix=Mover {0} a la clase de uso
static.method.only.used.in.one.class.quickfix.preview=Mueve el miembro estático a la clase en la que se utiliza.
static.method.via.subclass.display.name=Método estático referenciado a través de subclase
static.method.via.subclass.problem.descriptor=Método static <code>#ref()</code> declarado en la clase ''{0}'' pero referenciado mediante la subclase ''{1}'' #loc
static.method.via.subclass.rationalize.quickfix=Racionalizar llamada de método estático
static.non.final.field.display.name='static', campo no 'final'
static.non.final.field.option=Informar sólo los campos 'public'
static.non.final.field.problem.descriptor='campo' estático no 'final' <code>#ref</code> #loc
static.variable.may.not.be.initialized.display.name=El campo estático quizás no esté inicializado
static.variable.may.not.be.initialized.problem.descriptor=El campo estático <code>#ref</code> podría no inicializarse durante la inicialización de la clase #loc
static.variable.naming.convention.element.description=campo 'static'
static.variable.of.concrete.class.problem.descriptor=Campo estático ''{0}'' de la clase concreta <code>#ref</code> #loc
static.variable.used.before.initialization.display.name=Variable estática utilizada antes de su inicialización
static.variable.used.before.initialization.problem.descriptor=Campo estático <code>#ref</code> usado antes de su inicialización #loc
string.buffer.must.have.initial.capacity.display.name='StringBuilder' sin capacidad inicial
string.buffer.must.have.initial.capacity.problem.descriptor=<code>new #ref()</code> sin capacidad inicial #loc
string.buffer.replaceable.by.string.builder.display.name='StringBuffer' puede ser 'StringBuilder'
string.buffer.replaceable.by.string.builder.problem.descriptor=<code>StringBuffer #ref</code> puede declararse como 'StringBuilder' #loc
string.buffer.replaceable.by.string.display.name='StringBuilder' puede ser reemplazado con 'String'
string.buffer.replaceable.by.string.problem.descriptor=<code>{0} #ref</code> puede reemplazarse con ''String'' #loc
string.comparison.display.name=Comparación de cadenas usando '==', en lugar de 'equals()'
string.comparison.problem.descriptor=Los valores de cadenas se comparan usando <code>#ref</code>, no 'equals()' #loc
string.concatenation.argument.to.log.call.display.name=Concatenación de cadena no constante como argumento para llamada de registro
string.concatenation.argument.to.log.call.problem.descriptor=Concatenación de cadenas no constante como argumento a la llamada de registro <code>#ref()</code> #loc
string.concatenation.argument.to.log.call.quickfix=Reemplace concatenación con mensaje de registro parametrizado
string.concatenation.argument.to.log.message.format.call.quickfix=Reemplace "Message.format()" por un mensaje de registro parametrizado
string.concatenation.argument.to.log.string.format.call.quickfix='Reemplazar `String.format()` por un mensaje de registro parametrizado'
string.concatenation.display.name=Concatenación de cadenas
string.concatenation.in.format.call.display.name=Concatenación de cadenas como argumento para la llamada 'format()'
string.concatenation.in.format.call.fix.family.name=Reemplazo de concatenación con argumento
string.concatenation.in.format.call.problem.descriptor='' llamada ''{0}()'' tiene un argumento de concatenación de String
string.concatenation.in.format.call.quickfix=Reemplazar concatenación con argumento separado
string.concatenation.in.loops.display.name=Concatenación de cadena en bucle
string.concatenation.in.loops.problem.descriptor=Concatenación de textos <code>#ref</code> en bucle #loc
string.concatenation.in.message.format.call.display.name=Concatenación de cadenas como argumento a la llamada 'MessageFormat.format()'
string.concatenation.in.message.format.call.problem.descriptor=Concatenación de cadenas como argumento de llamada a 'MessageFormat.format()' #loc
string.concatenation.inside.string.buffer.append.display.name=La concatenación de cadena como argumento para llamar a 'StringBuilder.append()'
string.concatenation.inside.string.buffer.append.problem.descriptor=La concatenación de cadenas como argumento a la llamada <code>{0}.#ref()</code> #loc
string.concatenation.inside.string.buffer.append.replace.quickfix=Reemplazar con llamadas encadenadas 'append()'
string.concatenation.introduce.fix=Introducir StringBuilder
string.concatenation.introduce.fix.name=Introducir nueva {1} para actualizar variable ''{0}''
string.concatenation.introduce.fix.name.null.safe=Introducir un nuevo {1} para actualizar la variable ''{0}'' (segura para null)
string.concatenation.missing.whitespace.display.name=Puede faltar un espacio en blanco en la concatenación de cadenas
string.concatenation.missing.whitespace.option=Ignorar concatenaciones con string variables
string.concatenation.missing.whitespace.problem.descriptor=Es posible que falte el espacio en blanco en la concatenación de cadenas #loc
string.concatenation.problem.descriptor=Concatenación de cadenas <code>#ref</code> en un contexto internacionalizado #loc
string.concatenation.replace.fix=Reemplazar con StringBuilder
string.concatenation.replace.fix.name=Convertir la variable ''{0}'' de Cadena a {1}
string.concatenation.replace.fix.name.null.safe=Convertir la variable ''{0}'' de String a {1} (null-safe)
string.equals.char.sequence.display.name='String.equals()' llamado con argumento 'CharSequence'
string.equals.char.sequence.problem.descriptor=Se llamó a <code>String.equals()</code> con el argumento ''{0}'' #loc
string.equals.empty.string.display.name='String.equals()' se puede reemplazar por 'String.isEmpty()'
string.equals.empty.string.fix.family.name=Simplificar la comprobación de cadena vacía
string.equals.empty.string.is.empty.problem.descriptor=<code>#referencia("")</code> puede reemplazarse con 'isEmpty()' #loc
string.equals.empty.string.option.do.not.add.null.check=No reportar cuando puede ser necesario un chequeo de nulls
string.equals.empty.string.problem.descriptor=<code>#ref("")</code> puede ser reemplazado por 'length()==0' #loc
string.format.choose.class=Seleccionar clase formateadora
string.format.class.label=Clases de formateador adicionales:
string.format.class.method.label=Métodos de formateador adicionales:
string.indexof.replaceable.by.contains.display.name='String.indexOf()' expresión puede reemplazarse con 'contains()'
string.replace.quickfix=Eliminar operando de cadena vacía
string.replaceable.by.string.buffer.display.name='String's no constante puede ser reemplazado con 'StringBuilder'
string.replaceable.by.string.buffer.in.loop.option=Solo mostrar el aviso si la adición se realiza en un bucle
string.replaceable.by.string.buffer.problem.descriptor=La cadena no constante <code>#ref</code> probablemente debería declararse como 'StringBuilder' #loc
string.touppercase.tolowercase.without.locale.display.name=Llamada a 'String.toUpperCase()' o 'toLowerCase()' sin configuración regional
string.touppercase.tolowercase.without.locale.problem.descriptor=Se llamó a <code>String.#ref()</code> sin especificar un Locale mediante cadenas internacionalizadas #loc
stringbuffer.field.display.name=Campo StringBuilder
stringbuffer.field.problem.descriptor=''{0}'' campo <code>#ref</code> #loc
subtraction.in.compareto.display.name=Sustracción en 'compareTo()'
subtraction.in.compareto.problem.descriptor=La sustracción <code>#ref</code> en 'compareTo()' puede provocar un desbordamiento o una pérdida de precisión #loc
super.class.logger.option=Ignorar cuando la superclase tiene un logger accesible
suppress.for.tests.scope.quickfix=Suprimir para ámbito 'Tests'
suspicious.array.cast.display.name=Cast sospechoso de array
suspicious.array.cast.problem.descriptor=Conversión sospechosa a <code>#ref</code> #loc
suspicious.comparator.compare.descriptor.min.value=No se recomienda devolver Integer.MINVALUE de una función de comparación
suspicious.comparator.compare.descriptor.non.negative=El comparador nunca retorna valores negativos
suspicious.comparator.compare.descriptor.non.positive=El comparador nunca devuelve valores positivos
suspicious.comparator.compare.descriptor.non.reflexive=El comparador no devuelve 0 para elementos iguales
suspicious.comparator.compare.descriptor.parameter.not.used=''{0}()'' parámetro <code>#ref</code> no usado #loc
suspicious.comparator.compare.display.name=Implementación sospechosa 'Comparator.compare()'
suspicious.getter.problem.descriptor=Getter <code>#ref()</code> devuelve el campo ''{0}'' #loc
suspicious.getter.setter.display.name=Getter/setter sospechoso
suspicious.indent.after.control.statement.display.name=Indentación sospechosa después de una sentencia de control sin llaves
suspicious.indent.after.control.statement.problem.descriptor=Sangría sospechosa tras la sentencia ''{0}'' #loc
suspicious.integer.div.assignment.display.name=Asignación sospechosa de división entera
suspicious.integer.div.assignment.problem.descriptor=El resultado de la división se trunca a entero
suspicious.integer.div.assignment.quickfix=Lanzar a double
suspicious.literal.underscore.display.name=Guión bajo sospechoso en literal numérico
suspicious.literal.underscore.problem.descriptor=El grupo en el literal numérico con guiones bajos no tiene longitud 3 #loc
suspicious.package.private.access.display.name=Acceso sospechoso al paquete privado
suspicious.setter.problem.descriptor=Setter <code>#ref()</code> asigna el campo ''{0}'' #loc
suspicious.system.arraycopy.display.name=Llamada sospechosa a 'System.arraycopy()'
suspicious.system.arraycopy.problem.descriptor.length.bigger.dest=La longitud siempre es mayor que ''dest.length - destPos'' {0}
suspicious.system.arraycopy.problem.descriptor.length.bigger.src=La longitud es siempre más grande que ''src.length - srcPos'' {0}
suspicious.system.arraycopy.problem.descriptor.ranges.intersect=Copiando en la misma matriz con intervalos que se superponen
suspicious.system.arraycopy.problem.descriptor4=<code>#ref</code> no es de un tipo de arreglo #loc
suspicious.system.arraycopy.problem.descriptor5=<code>#ref</code> no es de un tipo de array #loc
suspicious.system.arraycopy.problem.descriptor6=El tipo de parámetro fuente ''{0}'' no se puede asignar al parámetro de destino `#ref` del tipo ''{1}'' #loc
suspicious.to.array.call.display.name=Llamada a 'Collection.toArray()' sospechosa
suspicious.to.array.call.fix.family.name=Reemplazar con arreglo adecuado
suspicious.to.array.call.problem.descriptor=Se esperaba un array de tipo ''{0}[]'', se encontró ''{1}[]'' #loc
swap.equals.fix.family.name=Voltear llamada al método
switch.expression.with.single.default.message='switch' expresión tiene sólo caso 'default'
switch.expression.with.too.few.branches.problem.descriptor=La expresión ''switch'' tiene muy pocas etiquetas de caso ({0}) y probablemente debería reemplazarse con una declaración ''if'' u un operador condicional #loc
switch.statement.density.display.name='switch' con densidad de rama demasiado baja
switch.statement.density.min.option=Densidad mínima de ramas: %
switch.statement.density.problem.descriptor=<code>#ref</code> tiene una densidad de ramificación demasiado baja ({0}%) #loc
switch.statement.display.name='switch' declaración
switch.statement.with.confusing.declaration.display.name=Variable local de tipo 'switch' usada y declarada en diferentes ramas
switch.statement.with.confusing.declaration.problem.descriptor=Variable local <code>#ref</code> declarada en una rama 'switch' y utilizada en otra #loc
switch.statement.with.single.default.message='switch' statement solo tiene un caso 'default'
switch.statement.with.too.few.branches.display.name=Mínimo de ramas 'switch'
switch.statement.with.too.few.branches.ignore.pattern.option=No reportar sentencias switch de patrón
switch.statement.with.too.few.branches.min.option=Cantidad mínima de ramas:
switch.statement.with.too.few.branches.problem.descriptor='Sentencia ''switch'' con muy pocas etiquetas de casos ({0}), y debería reemplazarse por una sentencia ''if'' #loc
switch.statement.with.too.many.branches.display.name=Máximos ramales de "switch"
switch.statement.without.default.ignore.option=Ignorar sentencias switch exhaustivas
switch.statements.without.default.display.name=Sentencia 'switch' sin rama 'default'
switch.statements.without.default.problem.descriptor="Declaración de <code>#ref</code> sin rama 'default'" #loc
synchronization.on.get.class.display.name=Sincronización en 'getClass()'
synchronization.on.get.class.problem.descriptor=Sincronización en <code>#ref()</code> #loc
synchronization.on.local.variable.or.method.parameter.display.name=Sincronización en variables o parámetros de métodos locales
synchronization.on.local.variable.problem.descriptor=Sincronización en la variable local <code>#ref</code> #loc
synchronization.on.method.parameter.problem.descriptor=Sincronización en el parámetro de método `#ref` #loc
synchronization.on.static.field.display.name=Sincronización sobre el campo 'estático'
synchronization.on.static.field.problem.descriptor=Sincronización en el campo 'static' <code>#ref</code> #loc
synchronize.on.class.problem.descriptor=Las operaciones de bloqueo en una clase pueden tener efectos secundarios no previstos #loc
synchronize.on.lock.display.name=Sincronizar en un objeto 'Lock'
synchronize.on.lock.problem.descriptor=La sincronización en un objeto ''{0}'' no parece intencional #loc
synchronize.on.non.final.field.display.name=Sincronización en un campo no final
synchronize.on.non.final.field.problem.descriptor=Sincronización en un campo no final <code>#ref</code> #loc
synchronize.on.this.display.name=Sincronización de 'this'
synchronize.on.this.problem.descriptor=Las operaciones de bloqueo sobre 'this' pueden causar efectos colaterales imprevistos #loc
synchronized.method.display.name='método synchronized'
synchronized.method.ignore.synchronized.super.option=Ignorar métodos que sobreescriben un método sincronizado
synchronized.method.include.option=Incluir métodos nativos
synchronized.method.move.quickfix=Mover bloqueo sincronizado al método
synchronized.method.problem.descriptor=El método ''{0}()'' fue declarado como <code>#ref</code> #loc
synchronized.on.direct.literal.object.problem.descriptor=Sincronización en {0} literal <code>#ref</code> #loc
synchronized.on.literal.object.name=Sincronización en un objeto inicializado con un literal
synchronized.on.literal.object.problem.descriptor=Sincronización en {0} <code>#ref</code> que se inicializa por un literal #loc
synchronized.on.literal.object.warn.on.all.option=Avisar en todos los literales posibles
synchronized.on.possibly.literal.object.problem.descriptor=Sincronización en {0} <code>#ref</code> #loc
system.exit.call.display.name=Llamada a 'System.exit()' o métodos relacionados
system.exit.call.ignore.option=Ignorar en el método main
system.exit.call.problem.descriptor=La llamada a <code>{0}.#ref()</code> no es portable #loc
system.getenv.call.display.name=Llamada a 'System.getenv()'
system.getenv.call.problem.descriptor=La llamada a `System.#ref()` no es portable #loc
system.properties.display.name=Acceso a propiedades del sistema
system.properties.problem.descriptor=La llamada a <code>Integer.#ref()</code> puede plantear problemas de seguridad #loc
system.properties.problem.descriptor1=La llamada a <code>Boolean.#ref()</code> puede generar problemas de seguridad #loc
system.run.finalizers.on.exit.display.name=Llamada a 'System.runFinalizersOnExit()'
system.run.finalizers.on.exit.problem.descriptor=Llamada a <code>System.#ref()</code> #loc
system.set.problem.descriptor=La llamada a `System.#ref()` puede generar problemas de seguridad #loc
system.set.security.manager.display.name=Llamada a 'System.setSecurityManager()'
system.set.security.manager.problem.descriptor=La llamada a <code>System.#ref()</code> puede generar problemas de seguridad #loc
tail.recursion.display.name=Recursión de cola
tail.recursion.problem.descriptor=Llamada recursiva final <code>#ref()</code> #loc
tail.recursion.replace.quickfix=Reemplazar Recursión de Cola con Iteración
text.label.in.switch.statement.display.name=Etiqueta de texto en sentencia 'switch'
text.label.in.switch.statement.problem.descriptor=Etiqueta de texto <code>#ref:</code> en cláusula ''switch'' {0, choice, 1#statement|2#expression} #loc
the.whole.project=todo el proyecto
this.class=esta clase
this.reference.escaped.in.construction.display.name='this' escapado en construcción del objeto
this.reference.escaped.in.construction.problem.descriptor=Escape de <code>#ref</code> durante la construcción del objeto #loc
thread.death.rethrown.display.name='ThreadDeath' no se vuelve a lanzar
thread.death.rethrown.problem.descriptor=ThreadDeath <code>#ref</code> no relanzado #loc
thread.local.not.static.final.display.name='ThreadLocal' campo no declarado como 'final estático'
thread.local.not.static.final.problem.descriptor=ThreadLocal <code>#ref</code> no está declarado 'static final' #loc
thread.local.set.with.null.display.name=ThreadLocal.set() con null como argumento
thread.local.set.with.null.problem.descriptor='ThreadLocal.set()' con null como argumento puede causar fuga de memoria
thread.local.set.with.null.quickfix=Reemplaza con 'ThreadLocal.remove()' llamada
thread.priority.display.name=Llamada a 'Thread.setPriority()'
thread.priority.problem.descriptor=Llamada a `Thread.#ref()` #loc
thread.run.problem.descriptor=Las llamadas a <code>#ref()</code> probablemente deberían ser reemplazadas por 'start()' #loc
thread.start.in.construction.display.name=Llamada a 'Thread.start()' durante la construcción del objeto
thread.start.in.construction.problem.descriptor=Llamada a <code>#ref()</code> durante la construcción del objeto #loc
thread.stop.suspend.resume.display.name=Llamada a 'Thread.stop()', 'suspend()' o 'resume()'
thread.stop.suspend.resume.problem.descriptor=Llamada a `Thread.#ref()` #loc
thread.with.default.run.method.display.name=Instanciando un 'Thread' con método 'run()' por defecto
thread.with.default.run.method.problem.descriptor=Se crea una instancia de <code>#ref</code> con el método predeterminado 'run()' #loc
thread.yield.display.name=Llamada a 'Thread.yield()'
thread.yield.problem.descriptor=Llamada a <code>Thread.#ref()</code> #loc
three.negations.per.method.display.name=Método con más de tres negaciones
three.negations.per.method.ignore.assert.option=Ignorar negaciones en sentencias 'assert'
three.negations.per.method.ignore.option=Ignorar negaciones en métodos 'equals()'
three.negations.per.method.problem.descriptor=<code>#ref</code> contiene {0} negaciones #loc
throw,from.finally.block.everywhere.option=Avisar si en cualquier lugar se pueden lanzar excepciones declaradas
throw.caught.locally.display.name='throw' capturado por la declaración 'try' contenedora
throw.caught.locally.ignore.option=Ignorar excepciones nuevas
throw.caught.locally.problem.descriptor=<code>#ref</code> capturado por la sentencia #loc de 'try' que contiene
throw.from.finally.block.display.name='throw' en bloque 'finally'
throw.from.finally.block.problem.descriptor=<code>#ref</code> en el bloque 'finally' #loc
throwable.instance.never.thrown.checked.exception.problem.descriptor=La instancia de excepción comprobada #ref no se ha lanzado ##loc
throwable.instance.never.thrown.error.problem.descriptor=La instancia de error <code>#ref</code> no se lanzó #loc
throwable.instance.never.thrown.problem.descriptor=La instancia Throwable <code>#ref</code> no se envía #loc
throwable.instance.never.thrown.runtime.exception.problem.descriptor=La instancia de la excepción en tiempo de ejecución <code>new #ref()</code> no se lanza #loc
throwable.not.thrown.display.name='Throwable' no lanzado
throwable.printed.to.system.out.display.name='Throwable' impreso en 'System.out'
throwable.printed.to.system.out.problem.descriptor=''Throwable'' argumento <code>#ref</code> a la llamada ''System.{0}.{1}()''
throwable.printed.to.system.out.problem.fix.level.option=Método de log para corrección:
throwable.result.of.method.call.ignored.problem.descriptor=El resultado de <code>#ref()</code> no se lanza #loc
throwable.supplier.only.throw.exception.name=El proveedor de Throwable nunca devuelve un valor
throwable.supplier.only.throw.exception.problem.descriptor=El proveedor de Throwable no devuelve una excepción
throwable.supplier.only.throw.exception.quickfix=Reemplazar 'throw' con 'return' en lambda
thrown.exceptions.per.method.display.name=Método con demasiadas excepciones declaradas
thrown.exceptions.per.method.limit.option=Excepciones lanzadas límite:
thrown.exceptions.per.method.problem.descriptor=<code>#ref</code> tiene demasiadas excepciones declaradas (cantidad de excepciones = {0}) #loc
throws.runtime.exception.display.name=Excepción no controlada declarada en la cláusula 'throws'
throws.runtime.exception.fix.family.name=Eliminar de la cláusula 'throws'
throws.runtime.exception.move.quickfix=Traslada ''{0}'' a la etiqueta ''@throws'' de Javadoc
throws.runtime.exception.problem.descriptor=Excepción no comprobada <code>#ref</code> declarada en la cláusula de 'throws' #loc
throws.runtime.exception.quickfix=Quitar ''{0}'' de la cláusula ''throws''
time.tostring.call.display.name=Llamada a 'Time.toString()'
time.tostring.call.problem.descriptor=<code>Time.#ref()</code> en un contexto internacionalizado #loc
to.array.call.style.display.name='Colección.toArray()' estilo de llamada
to.array.call.style.problem.descriptor.presized=Llamada a <code>#ref()</code> con el argumento de array predimensionado ''{0}'' #loc
to.array.call.style.problem.descriptor.zero=Llamada a <code>#ref()</code> con argumento de matriz vacío ''{0}'' #loc
to.array.call.style.quickfix.family.name=Corrige el tamaño del array pasado a la llamada 'toArray()'
to.array.call.style.quickfix.make.presized=Reemplazar el argumento por un array pre-dimensionado
to.array.call.style.quickfix.make.zero=Reemplazar argumento con arreglo vacío
too.broad.catch.display.name=Bloque 'catch' demasiado amplio
too.broad.catch.option=Advertencia sólo sobre RuntimeException, Exception, Error o Throwable(&O)
too.broad.catch.problem.descriptor=El ''catch'' de ''{0}'' es demasiado amplio, enmascarando la excepción ''{1}'' #loc
too.broad.catch.problem.descriptor1=''catch'' de <code>#ref</code> es demasiado amplia, enmascarando excepciones ''{0}'' y ''{1}'' #loc
too.broad.catch.quickfix=Añadir cláusula ''catch'' para ''{0}''
too.broad.scope.allow.option=<html>Informar variables con una nueva expresión cómo inicializador<br>(potencialmente inseguro)</html>
too.broad.scope.display.name=El alcance de la variable es muy amplio
too.broad.scope.inspection.fix.family.name=Restricción de scope
too.broad.scope.narrow.quickfix=Mover la declaración de ''{0}'' más cerca a los usos
too.broad.scope.only.blocks.option=Sólo informar variables que pueden ser movidas a bloques internos
too.broad.scope.problem.descriptor=El alcance de la variable <code>#ref</code> es demasiado amplio #loc
too.many.constructors.count.limit.option=Límite del número de constructores:
too.many.constructors.display.name=Clase con demasiados constructores
too.many.constructors.ignore.deprecated.option=Ignorar constructores en desuso
too.many.constructors.problem.descriptor=<code>#ref</code> tiene demasiados constructores (número de constructores = {0}) #loc
too.many.fields.count.limit.option=Límite de conteo de campos:
too.many.fields.display.name=Clase con demasiados campos
too.many.fields.problem.descriptor=`#ref` tiene demasiados campos (conteo de campos = {0}) #loc
too.many.methods.display.name=Clase con demasiados métodos
too.many.methods.problem.descriptor=<code>#ref</code> tiene demasiados métodos (recuento de métodos = {0}) #loc
trace.level.option=nivel de traza
transient.field.in.non.serializable.class.display.name=Campo transitivo en clase no serializable
transient.field.in.non.serializable.class.problem.descriptor=El campo ''{0}'' está marcado como <code>#ref</code>, en una clase no serializable #loc
transient.field.not.initialized.display.name=El campo transitorio no se inicializó en la deserialización
transient.field.not.initialized.problem.descriptor=Campo transitorio <code>#ref</code> no inicializado en la deserialización #loc
trivial.if.display.name=Sentencia 'if' redundante
trivial.if.fix.family.name=Simplificar 'if else'
trivial.if.option.ignore.assert.statements=Ignorar sentencias 'if' con 'assert' trivial
trivial.if.option.ignore.chained=Ignorar sentencias 'if' encadenadas
trivial.if.problem.descriptor=Expresión <code>#ref</code> se puede simplificar #loc
trivial.string.concatenation.display.name=Concatenación con cadena vacía
trivial.string.concatenation.option.only.necessary=Informar solo donde las cadenas vacías pueden ser eliminadas sin otros cambios
trivial.string.concatenation.problem.descriptor=Cadena vacía en concatenación
try.finally.can.be.try.with.resources.display.name='try finally' se puede reemplazar con try with resources
try.finally.can.be.try.with.resources.problem.descriptor=<code>#ref</code> puede utilizar administración automática de recursos #loc
try.finally.can.be.try.with.resources.quickfix=Reemplazar con 'try' con recursos
try.statement.with.multiple.resources.name=Se puede dividir la instrucción `try` con múltiples recursos
try.statement.with.multiple.resources.quickfix=Separar la sentencia 'try' con varios recursos
try.with.identical.catches.checkbox.different.comments=No informar de bloques catch con comentarios diferentes
try.with.identical.catches.display.name=Bloques 'catch' idénticos en una instrucción 'try'
try.with.identical.catches.problem.descriptor=rama ''catch'' idéntica a la rama ''{0}'' #loc
try.with.identical.catches.quickfix=Contraer bloques 'catch'
type.parameter.extends.enum.type.parameter.problem.descriptor=El parámetro de tipo <code>#ref</code> se extiende implícitamente del final de la enumeración ''{0}'' #loc
type.parameter.extends.enum.wildcard.problem.descriptor=El argumento del tipo comodín <code>#ref</code> extiende implícitamente la enumeración final ''{0}'' #loc
type.parameter.extends.final.class.display.name=Parámetro de tipo extiende clase 'final'
type.parameter.extends.final.class.quickfix=Reemplazar parámetro de tipo por clase actual
type.parameter.extends.final.class.type.parameter.problem.descriptor=Parámetro de tipo <code>#ref</code> extiende la clase ''final'' ''{0}'' #loc
type.parameter.extends.final.class.wildcard.problem.descriptor=El argumento de tipo comodín <code>#ref</code> amplía la clase ''final'' ''{0}'' #loc
type.parameter.extends.object.display.name=Parámetro de tipo extiende explícitamente 'Object'
type.parameter.extends.object.ignore.annotated=Ignorar cuando java.lang.Object esté anotado
type.parameter.extends.object.problem.descriptor1=El parámetro de tipo <code>#ref</code> extiende explícitamente 'java.lang.Object' #loc
type.parameter.extends.object.problem.descriptor2=El argumento de tipo comodín <code>#ref</code> extiende explícitamente 'java.lang.Object' #loc
type.parameter.hides.type.parameter.problem.descriptor=El parámetro de tipo <code>#ref</code> oculta el parámetro de tipo ''{0}'' #loc
type.parameter.hides.visible.type.display.name=El parámetro de tipo oculta el tipo visible
type.parameter.hides.visible.type.problem.descriptor=El parámetro de tipo <code>#ref</code> oculta el tipo visible ''{0}'' #loc
type.parameter.naming.convention.element.description=Tipo del parámetro
unary.plus.display.name=Suma unaria
unary.plus.problem.descriptor=Operador unario <code>#ref</code> #loc
unary.plus.quickfix=Eliminar unario '+'
unchecked.exception.class.display.name=Clase 'Exception' sin comprobar
unchecked.exception.class.problem.descriptor=Clase de excepción sin revisar <code>#ref</code> #loc
unclear.binary.expression.display.name=Múltiples operadores con diferente precedencia
unclear.binary.expression.problem.descriptor=Expresión podría usar paréntesis aclaratorios #loc
unclear.binary.expression.quickfix=Agregar paréntesis aclaratorios
unconditional.wait.display.name=Llamada incondicional a 'wait()'
unconditional.wait.problem.descriptor=Llamada incondicional a <code>#ref()</code> #loc
unnecessarily.qualified.inner.class.access.display.name=Acceso de clase interna innecesariamente calificado
unnecessarily.qualified.inner.class.access.option=Ignorar referencias para las que se necesita una importación
unnecessarily.qualified.inner.class.access.problem.descriptor=''{0}'' tiene calificación innecesaria con <code>#ref</code> #loc
unnecessarily.qualified.inner.class.access.quickfix=Eliminar calificador
unnecessarily.qualified.static.usage.display.name=Uso innecesario de acceso calificado estático
unnecessarily.qualified.static.usage.ignore.field.option=Ignorar accesos a campos innecesariamente calificados
unnecessarily.qualified.static.usage.ignore.method.option=Ignorar invocaciones a métodos innecesariamente calificados
unnecessarily.qualified.static.usage.problem.descriptor=Llamada calificada innecesariamente al método estático <code>{0}()</code> #loc
unnecessarily.qualified.static.usage.problem.descriptor1=Acceso calificado innecesario al campo estático <code>{0}</code> #loc
unnecessarily.qualified.statically.imported.element.display.name=Elemento importado estáticamente cualificado innecesariamente
unnecessarily.qualified.statically.imported.element.problem.descriptor=El elemento importado staticamente ''{0}'' está calificado innecesariamente con <code>#ref</code> #loc
unnecessarily.qualified.statically.imported.element.quickfix=Quitar el calificador innecesario
unnecessary.block.statement.problem.descriptor=Las llaves alrededor de esta declaración son innecesarias #loc
unnecessary.boxing.display.name=Boxing innecesario
unnecessary.boxing.inside.value.of.problem.descriptor=Boxing innecesario, se puede usar la llamada a <code>{0}.{1}()</code> en su lugar #loc
unnecessary.boxing.problem.descriptor=Boxing innecesario #loc
unnecessary.boxing.remove.quickfix=Eliminar boxing
unnecessary.boxing.superfluous.option=Solo informar expresiones superfluamente boxing
unnecessary.break.display.name=Sentencia 'break' innecesaria
unnecessary.break.problem.descriptor=La declaración <code>#ref</code> es innecesaria #loc
unnecessary.code.block.display.name=Bloque de código innecesario
unnecessary.code.block.unwrap.quickfix=Desenvolver bloque
unnecessary.constant.array.creation.expression.display.name=Expresión 'new' redundante en creación de matriz constante
unnecessary.constant.array.creation.expression.family.quickfix=Eliminar especificación de tipo de la expresión de la creación de una nueva matriz
unnecessary.constant.array.creation.expression.problem.descriptor=Se puede eliminar <code>#ref</code> de la nueva expresión de creación de matriz #loc
unnecessary.constructor.annotation.option=Ignorar constructores con anotaciones
unnecessary.constructor.display.name=Constructor redundante sin argumento
unnecessary.constructor.problem.descriptor=Constructor sin argumentos <code>#ref()</code> es redundante #loc
unnecessary.constructor.remove.quickfix=Eliminar constructor redundante
unnecessary.continue.display.name=Instrucción 'continue' innecesaria
unnecessary.continue.problem.descriptor=<code>#ref</code> es innecesario como la última declaración en un bucle #loc
unnecessary.conversion.to.string.display.name=Conversión innecesaria a 'String'
unnecessary.default.display.name=El 'default' es innecesario para la declaración enum 'switch'
unnecessary.default.expressions.option=Reportar solo expresiones de switch
unnecessary.default.problem.descriptor=La rama <code>#ref</code> es innecesaria #loc
unnecessary.default.quickfix=Eliminar rama 'default'
unnecessary.enum.constructor.modifier.problem.descriptor=El modificador `#ref` es redundante para los constructores de la enumeración #loc
unnecessary.explicit.numeric.cast.display.name=Lanzamiento numérico explícito innecesario
unnecessary.explicit.numeric.cast.problem.descriptor=''{0}'' convertido explícitamente a <code>#ref</code> de forma innecesaria #loc
unnecessary.explicit.numeric.cast.quickfix=Quitar conversión
unnecessary.final.on.local.variable.or.parameter.display.name=El modificador 'final' es innecesario en la variable local o el parámetro
unnecessary.final.on.local.variable.problem.descriptor=Variable local ''{0}'' con referencia <code>#ref</code> innecesaria #loc
unnecessary.final.on.parameter.only.interface.option=Solo avisar sobre métodos abstractos o de interfaz
unnecessary.final.on.parameter.problem.descriptor=#ref innecesario en el parámetro ''{0}'' #loc
unnecessary.final.report.local.variables.option=Reportar variables locales
unnecessary.final.report.parameters.option=Parametros de reporte
unnecessary.final.report.pattern.variables.option=Variables de patrón de reporte innecesario
unnecessary.fully.qualified.name.display.name=Nombre totalmente cualificado innecesario
unnecessary.fully.qualified.name.fix.family.name=Reemplazar el nombre completo del paquete
unnecessary.fully.qualified.name.problem.descriptor1=El calificador <code>#ref</code> es innecesario y puede ser reemplazado por una importación #loc
unnecessary.fully.qualified.name.problem.descriptor2=El calificador <code>#ref</code> es innecesario y puede ser eliminado #loc
unnecessary.fully.qualified.name.remove.quickfix=Eliminar calificación no necesaria
unnecessary.fully.qualified.name.replace.quickfix=Reemplazar nombre completo con importar
unnecessary.inherit.doc.class.invalid.problem.descriptor=<code>#ref</code> no es válido en las clases #loc
unnecessary.inherit.doc.constructor.invalid.problem.descriptor=<code>#ref</code> no es válido en constructores #loc
unnecessary.inherit.doc.constructor.no.super.problem.descriptor=No se encontró el método super para heredar Javadoc de #loc
unnecessary.inherit.doc.display.name=Comentario Javadoc '{@inheritDoc}' innecesario
unnecessary.inherit.doc.field.invalid.problem.descriptor=<code>#ref</code> no es válido en el campo #loc
unnecessary.inherit.doc.module.invalid.problem.descriptor=<code>#ref</code> no es válido en declaraciones de módulo #loc
unnecessary.inherit.doc.problem.descriptor=Javadoc con solo <code>#ref</code> es innecesaria #loc
unnecessary.inherit.doc.quickfix=Suprime {@inheritDoc} innecesario
unnecessary.initcause.display.name=Llamada innecesaria a 'Throwable.initCause()'
unnecessary.initcause.problem.descriptor=Llamada a <code>Throwable.#ref()</code> no necesaria
unnecessary.initcause.quickfix=Eliminar la llamada a 'Throwable.initCause()'
unnecessary.inner.enum.modifier.problem.descriptor=El modificador `#ref` es redundante para los enums internos #loc
unnecessary.inner.interface.modifier.problem.descriptor=Modificador <code>#ref</code> es redundante para interfaces internas #loc
unnecessary.inner.record.modifier.problem.descriptor=El modificador <code>#ref</code> es redundante para registros internos
unnecessary.interface.field.modifier.problem.descriptor=El modificador <code>#ref</code> es redundante para los campos de la interfaz #loc
unnecessary.interface.inner.class.modifier.problem.descriptor=El modificador <code>#ref</code> es redundante para las clases internas de las interfaces #loc
unnecessary.interface.member.modifier.problem.descriptor=El modificador #ref es redundante para los miembros de la interfaz #loc
unnecessary.interface.method.modifier.problem.descriptor=El modificador <code>#ref</code> es redundante para los métodos de la interfaz #loc
unnecessary.interface.modifier.problem.descriptor=El modificador de interfaz <code>#ref</code> es redundante. #loc
unnecessary.java.doc.link.fix.family.name=Eliminar etiqueta redundante
unnecessary.javadoc.link.display.name=Enlace Javadoc innecesario
unnecessary.javadoc.link.option=Ignorar vínculos en línea a supermétodos
unnecessary.javadoc.link.quickfix=Eliminar cierre ''{0}'' innecesario
unnecessary.javadoc.link.super.method.problem.descriptor=La referencia <code>#ref</code> que señala al método de la superclase es innecesaria #loc
unnecessary.javadoc.link.this.class.problem.descriptor=El <code>#ref</code> que apunta a la clase contenedora es innecesario #loc
unnecessary.javadoc.link.this.method.problem.descriptor=Enlace <code>#ref</code> a este método es innecesario #loc
unnecessary.label.on.break.statement.display.name=Etiqueta del operador 'break' innecesaria
unnecessary.label.on.break.statement.problem.descriptor=Etiqueta innecesaria <code>#ref</code> en la sentencia de break #loc
unnecessary.label.on.continue.statement.display.name=Etiqueta innecesaria en la sentencia 'continue'
unnecessary.label.on.continue.statement.problem.descriptor=Etiqueta innecesaria <code>#ref</code> en la sentencia continue #loc
unnecessary.label.remove.quickfix=Eliminar etiqueta
unnecessary.local.variable.problem.descriptor=La variable local <code>#ref</code> es redundante #loc
unnecessary.modifier.display.name=Modificador innecesario
unnecessary.parentheses.conditional.option=Ignorar paréntesis alrededor de la condición de expresiones condicionales
unnecessary.parentheses.display.name=Paréntesis innecesarios
unnecessary.parentheses.option=Ignorar paréntesis aclaratorios
unnecessary.parentheses.problem.descriptor=Los paréntesis alrededor de <code>#ref</code> son innecesarios #loc
unnecessary.parentheses.remove.quickfix=Quitar paréntesis innecesarios
unnecessary.qualifier.for.super.problem.descriptor=El calificador <code>#ref</code> en 'super' es innecesario en este contexto #loc
unnecessary.qualifier.for.this.display.name=Calificador innecesario para 'esto' o 'super'
unnecessary.qualifier.for.this.problem.descriptor=Calificador `#ref` en 'this' es innecesario en este contexto #loc
unnecessary.qualifier.for.this.remove.quickfix=Eliminar calificador innecesario
unnecessary.record.modifier.problem.descriptor=El modificador <code>#ref</code> es redundante para registros
unnecessary.return.constructor.problem.descriptor=El <code>#ref</code> es innecesario como última sentencia en el constructor #loc
unnecessary.return.display.name=Sentencia 'return' innecesaria
unnecessary.return.option=Ignorar en bloque de instrucción then de 'if' con bloque de instrucción 'else'
unnecessary.return.problem.descriptor=El <code>#ref</code> es innecesario ya que es la última frase en un método 'void' #loc
unnecessary.semicolon.display.name=Punto y coma innecesario
unnecessary.semicolon.ignore.after.enum.constants.option=Ignorar punto y coma innecesarios después constantes enum
unnecessary.semicolon.problem.descriptor=Punto y coma innecesario <code>#ref</code> #loc
unnecessary.semicolon.remove.quickfix=Eliminar punto y coma innecesario
unnecessary.strictfp.modifier.problem.descriptor=El modificador <code>#ref</code> es redundante en Java 17 y versiones posteriores
unnecessary.string.escape.display.name=Carácter de escape innecesario
unnecessary.string.escape.problem.descriptor=<code>{0}</code> se ha escapado innecesariamente
unnecessary.string.escape.quickfix=Quitar escape innecesario
unnecessary.super.constructor.display.name=Llamada innecesaria a 'super()'
unnecessary.super.constructor.problem.descriptor=<code>#ref</code> es innecesario #loc
unnecessary.super.constructor.remove.quickfix=Eliminar 'super()' innecesario
unnecessary.super.qualifier.display.name=Calificador 'super' innecesario
unnecessary.super.qualifier.problem.descriptor=El calificador <code>#ref</code> es innecesario en este contexto #loc
unnecessary.super.qualifier.quickfix=Quitar el calificador 'super' innecesario
unnecessary.temporary.object.fix.family.name=Reemplazar concatenación
unnecessary.temporary.on.conversion.from.string.display.name=Objeto temporal innecesario en la conversión de 'Cadena'
unnecessary.temporary.on.conversion.to.string.display.name=Objeto temporal innecesario al convertir a 'String'
unnecessary.this.display.name=Calificador 'this' innecesario
unnecessary.this.ignore.assignments.option=Ignorar asignaciones de campo
unnecessary.this.problem.descriptor=<code>#ref</code> es innecesario en este contexto #loc
unnecessary.this.remove.quickfix=Eliminar calificador 'this' innecesario
unnecessary.tostring.call.display.name=Llamada a 'toString()' innecesaria
unnecessary.tostring.call.option.report.with.empty.string=Reportar llamadas que pueden reemplazarse con concatenación con una cadena vacía
unnecessary.tostring.call.problem.descriptor=Llamada <code>#ref()</code> innecesaria #loc
unnecessary.tostring.call.problem.empty.string.descriptor=Puede reemplazarse con concatenación con cadena vacía
unnecessary.transient.modifier.problem.descriptor=El modificador `#ref` es redundante para un campo "estático"
unnecessary.unary.minus.display.name=Unarios negativos innecesarios
unnecessary.unary.minus.problem.descriptor=Operador unario <code>#ref</code> innecesario #loc
unnecessary.unary.minus.quickfix=Eliminar unario menos e invertir el signo de la operación padre
unnecessary.unary.minus.remove.quickfix=Eliminar doble menos (-) unitario
unnecessary.unboxing.display.name=Desempaquetado no necesario
unnecessary.unboxing.problem.descriptor=Desempaquetado innecesario #loc
unnecessary.unboxing.remove.quickfix=Quitar desempaquetado
unnecessary.unboxing.superfluous.option=Informar solo expresiones sin desempaquetar que sean verdaderamente superfluas
unnecessary.unicode.escape.display.name=Secuencia de escape unicode innecesaria
unnecessary.unicode.escape.fix.family.name=Reemplazar con caracter
unnecessary.unicode.escape.fix.text=Reemplazar con salto de línea
unnecessary.unicode.escape.problem.descriptor=La secuencia de escape Unicode <code>#ref</code> se puede reemplazar por ''{0}''
unnecessary.unicode.escape.problem.newline.descriptor=La secuencia de escape Unicode <code>#ref</code> puede ser remplazada por un salto de línea #loc
unpredictable.big.decimal.constructor.call.display.name=Llamada al constructor 'BigDecimal' impredecible
unpredictable.big.decimal.constructor.call.ignore.complex.literals.option=Ignorar llamadas a constructores con múltiples literales (por ejemplo, 0,1 + 0,2)
unpredictable.big.decimal.constructor.call.ignore.references.option=Ignorar llamadas de constructor con argumentos de llamada de método o variable
unpredictable.big.decimal.constructor.call.problem.descriptor=Llamada a <code>new #ref()</code> impredecible #loc
unqualified,static.usage.only.report.static.usages.option=Solo reportar acceso estático desde un contexto no estático
unqualified.field.access.display.name=Acceso al campo de la instancia no calificado con 'this'
unqualified.field.access.problem.descriptor=Acceso al campo de instancia <code>#ref</code> sin calificar con 'this' #loc
unqualified.inner.class.access.display.name=Acceso a clase interna no cualificada
unqualified.inner.class.access.option=Ignorar referencias a clases internas locales
unqualified.inner.class.access.problem.descriptor=<code>#ref</code> no es calificado con la clase externa #loc
unqualified.inner.class.access.quickfix=Calificar con clase externa
unqualified.method.access.display.name=Llamada a método de instancia no calificada con 'this'
unqualified.method.access.problem.descriptor=La llamada al método de instancia <code>#ref()</code> no está calificado con 'this' #loc
unqualified.static.access.fix.family.name=Calificar acceso estático
unqualified.static.usage.display.name=Acceso estático no calificado
unqualified.static.usage.ignore.field.option=Ignorar accesos a campos no calificados
unqualified.static.usage.ignore.method.option=Ignorar llamadas de método no cualificadas
unqualified.static.usage.problem.descriptor=Llamada a método estático no cualificado <code>#ref()</code> #loc
unqualified.static.usage.problem.descriptor1=Acceso a campo static no cualificado <code>#ref</code> #loc
unqualified.static.usage.qualify.field.quickfix=Calificar acceso a campo estático
unqualified.static.usage.qualify.method.quickfix=Calificar llamada de método estático
unrunnable.main.method.problem.descriptor=El método <code>#ref()</code> no se puede ejecutar porque la clase contenedora no tiene un nombre completamente calificado
unsecure.random.number.generation.display.name=Generación no segura de números aleatorios
unsecure.random.number.generation.problem.descriptor1=Por razones de seguridad, utilice 'java.security.SecureRandom' en lugar de <code>java.lang.Math.#ref()</code> #loc
unsecure.random.number.generation.problem.descriptor2=Por motivos de seguridad, utiliza 'java.security.SecureRandom', en lugar de <code>java.util.#ref</code> #loc
unsecure.random.number.generation.problem.descriptor3=Por motivos de seguridad, use `java.security.SecureRandom` en lugar de <code>#ref</code> #loc
unused.import.problem.descriptor=Importación no utilizada <code>#ref</code> #loc
unused.label.display.name=Etiqueta no utilizada
unused.label.problem.descriptor=Etiqueta sin usar <code>#ref</code> #loc
unused.label.remove.quickfix=Eliminar etiqueta no usada
update.label=Actualizar nombres que comiencen por:
upper.case.field.name.not.constant.display.name=Nombre de campo no constante en mayúsculas
upper.case.field.name.not.constant.problem.descriptor=Campo <code>#ref</code> no-constante con nombre de estilo constante #loc
use.0index.in.jdbc.prepared.statement.problem.descriptor=Uso del índice '0' en la declaración preparada de JDBC #loc
use.0index.in.jdbc.resultset.display.name=Uso de in índice 0 en JDBC ResultSet
use.0index.in.jdbc.resultset.problem.descriptor=Uso del índice '0' en JDBC ResultSet #loc
use.contentequals=Use 'contentEquals()' para comparar con 'AbstractStringBuilder'
use.equalsignorecase.for.case.insensitive.comparison=Utiliza 'equalsIgnoreCase()' para comparaciones sin distinguir mayúsculas y minúsculas
use.isblank.to.check.if.string.is.whitespace.or.empty=Usa 'isBlank()' para comprobar si una cadena está vacía o solo contiene espacios en blanco
use.obsolete.collection.type.display.name=Uso de tipo de colección obsoleto
use.obsolete.collection.type.ignore.library.arguments.option=Ignorar tipos de colección obsoletos cuando los argumentos de la librería lo requieran
use.obsolete.collection.type.problem.descriptor=Tipo de colección obsoleto <code>#ref</code> usada #loc
use.of.awt.peer.class.display.name=Uso de la clase peer de AWT
use.of.awt.peer.class.problem.descriptor=El uso de la clase peer de AWT <code>#ref</code> no es portable #loc
use.of.clone.call.method.problem.descriptor=Implementación de <code>#ref()</code>
use.of.clone.call.problem.descriptor=Llamada a <code>#ref()</code>
use.of.clone.display.name=Uso de 'clone()' o 'Cloneable'
use.of.clone.reference.problem.descriptor=Uso de <code>#ref</code>
use.of.concrete.class.option.ignore.abstract=Ignorar tipo de clase abstracto
use.of.concrete.class.option.ignore.records=Ignorar registros de Java
use.of.concrete.class.option.report.cast=Tipo usado en expresiones de conversión
use.of.concrete.class.option.report.instance.fields=Informar sobre el tipo de campo de instancia
use.of.concrete.class.option.report.instanceof=Tipo de informe usado en instanceof, patrones o comparación getClass()
use.of.concrete.class.option.report.local.variable=Reportar tipo de variables locales
use.of.concrete.class.option.report.method.returns=Reportar el tipo de retorno del método
use.of.concrete.class.option.report.parameter=Tipo de parámetro de método de informe
use.of.concrete.class.option.report.static.fields=Reportar el tipo de los campos estáticos
use.of.concrete.jdbc.driver.class.display.name=Uso de la clase de controlador JDBC concreta
use.of.concrete.jdbc.driver.class.problem.descriptor=El uso de la clase del controlador JDBC concreta <code>#ref</code> no es portable #loc
use.of.obsolete.date.time.api.display.name=Uso de API de fecha y hora obsoletas
use.of.obsolete.date.time.api.problem.descriptor=Tipo fecha-hora obsoleto <code>#ref</code>  utilizado #loc
use.of.properties.as.hashtable.fix.family.name=Corregir acceso a propiedades
use.processbuilder.class.display.name=Uso de la clase 'java.lang.ProcessBuilder'
use.processbuilder.class.problem.descriptor=Uso de <code>#ref</code> no es portable #loc
use.stringtokenizer.display.name=Uso de 'StringTokenizer'
use.stringtokenizer.problem.descriptor=<code>#ref</code> en un contexto internacionalizado #loc
use.sun.classes.display.name=Uso de clases 'sun.*'
use.sun.classes.problem.descriptor=El uso de la clase suministrada por Sun <code>#ref</code> no es portable #loc
use.system.out.err.display.name=Uso de 'System.out' o 'System.err'
use.system.out.err.problem.descriptor=El uso de <code>#ref</code> probablemente debería reemplazarse con un registro más robusto #loc
use.system.out.err.problem.fix.err.option='System.err' Metodo de registro para:
use.system.out.err.problem.fix.out.option='System.out' Método de registro para:
utility.class.can.be.enum.display.name=La clase de utilidad puede ser 'enum'
utility.class.code.can.be.enum.problem.descriptor=La clase de utilidad <code>#ref</code> puede ser 'enum' #loc
utility.class.code.can.be.enum.quickfix=Convertir a 'enum'
utility.class.display.name=Clase utilitaria
utility.class.problem.descriptor=La clase <code>#ref</code> sólo tiene miembros 'static', lo cual indica una construcción procedimental #loc
utility.class.with.public.constructor.display.name=Clase util con constructor 'public'
utility.class.with.public.constructor.fix.family.name=Hacer que todos los constructores no sean públicos
utility.class.with.public.constructor.make.private.quickfix=Convertir {0, choice, 1#constructor|2#constructores} a 'privada'
utility.class.with.public.constructor.make.protected.quickfix=Convertir {0, choice, 1#constructor|2#constructores} en 'protegido'
utility.class.with.public.constructor.problem.descriptor=La clase <code>#ref</code> solo tiene miembros 'static' y un constructor 'public' #loc
utility.class.without.private.constructor.cant.generate.constructor.message=La clase Utilidad tiene instanciaciones, no se creará el constructor privado
utility.class.without.private.constructor.create.quickfix=Generar constructor 'private' vacío
utility.class.without.private.constructor.display.name=Clase de utilidades sin constructor 'private'
utility.class.without.private.constructor.make.quickfix=Hacer 'private' el constructor
utility.class.without.private.constructor.option=Ignorar clases con un método principal solamente
utility.class.without.private.constructor.problem.descriptor=La clase <code>#ref</code> sólo tiene miembros 'estáticos', y carece de un constructor 'privado' #loc
value.of.post.decrement.problem.descriptor=El valor de la expresión <code>#ref</code> de post-decremento es utilizado #loc
value.of.post.increment.problem.descriptor=Se usa el valor de la expresión de incremento diferido <code>#ref</code> #loc
value.of.pre.decrement.problem.descriptor=Se usa el valor de la expresión predecremento <code>#ref</code> #loc
value.of.pre.increment.problem.descriptor=El valor de la expresión de preincremento <code>#ref</code> está en uso #loc
variable.argument.method.display.name=Método varargs
variable.argument.method.problem.descriptor=Método varargs <code>#ref()</code> #loc
variable.argument.method.quickfix=Convertir parámetro varargs en array
variable.not.used.inside.conditional.problem.descriptor=<code>#ref</code> verificado para 'null' no se usa dentro del condicional #loc
variable.not.used.inside.if.display.name=La referencia comprobada para 'null' no se usa dentro de 'if'
variable.not.used.inside.if.problem.descriptor=Comprobación de 'null' para <code>#ref</code> no usada dentro de 'si' #loc
variable.type.can.be.explicit.display.name=El tipo de variable puede ser explícito
volatile.array.field.display.name=Campo de matriz volátil
volatile.field.problem.descriptor=Campo volátil <code>#ref</code> de tipo ''{0}'' #loc
wait.called.on.condition.display.name=wait() llamado en el objeto 'java.util.concurrent.locks.Condition'
wait.called.on.condition.problem.descriptor=Llamada al <code>#ref()</code> en el objeto Condición #loc
wait.not.in.loop.display.name=wait() no llamado en bucle
wait.not.in.loop.problem.descriptor=La llamada a <code>#ref()</code> no está en bucle #loc
wait.notify.not.in.synchronized.context.display.name='wait()' o 'notify()' no están en un contexto sincronizado
wait.notify.while.not.synchronized.on.problem.descriptor=Llamada a <code>#ref</code> mientras no está sincronizado en ''{0}'' #loc
wait.or.await.without.timeout.display.name='wait()' o 'await()' sin tiempo de espera
wait.or.await.without.timeout.problem.descriptor=<code>#ref</code> sin tiempo de espera #loc
wait.while.holding.two.locks.display.name='wait()' en espera por dos bloqueos
wait.while.holding.two.locks.problem.descriptor=Se llama a <code>#ref()</code> mientras se mantienen dos bloqueos #loc
wait.without.corresponding.notify.display.name='wait()' sin 'notify()' correspondiente
wait.without.corresponding.notify.problem.descriptor=Llamada a <code>#ref()</code> sin la correspondiente <code>notify()</code> o <code>notifyAll()</code> #loc
warn.level.and.lower.option=nivel de advertencia y niveles inferiores
warn.on.label=Avisar sobre:
weaken.visibility.quickfix=Debilitar visibilidad
while.can.be.foreach.display.name='while' puede ser reemplazado por el bucle 'for' mejorado
while.can.be.foreach.problem.descriptor=Bucle <code>#ref</code> se puede reemplazar por 'for' #loc aumentado
while.loop.spins.on.field.display.name=los giros del bucle 'while' en el campo
while.loop.spins.on.field.fix.family.name=Corregir bucle de giro
while.loop.spins.on.field.fix.spinwait=Agregar Thread.onSpinWait()
while.loop.spins.on.field.fix.volatile=Declarar ''{0}'' como volatile
while.loop.spins.on.field.fix.volatile.spinwait=Hacer ''{0}'' volátil y agregar Thread.onSpinWait()
while.loop.spins.on.field.ignore.non.empty.loops.option=Sólo avisar si el bucle está vacío
while.loop.spins.on.field.problem.descriptor=El <code>#ref</code> del bucle gira en el campo #loc
wrap.with.arrays.hash.code.quickfix=Encapsular con ''{0}''
write.only.object.display.name=Objeto de sólo escritura
write.only.object.option.ignore.impure.constructors=Ignorar constructores impuros