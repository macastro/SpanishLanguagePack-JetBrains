Field.cannot.be.final.because.replaced.variable.has.lhs.usages=La variable seleccionada es utilizada para escribir
access.to.created.field.0.will.be.overridden.by.method.1=El acceso al campo {0} será sobrescrito por {1}
all.invocations.and.remove.the.method=Línea todos los invocados y elimina el método
all.invocations.in.project=Incrustar todas las invocaciones en el proyecto
cannot.find.a.single.definition.to.inline.field=No hay inicializadores presentes para el campo
cannot.find.a.single.definition.to.inline.local.var=No es posible encontrar una definición simple para incluir una variable local
cannot.inline.0.=No se puede corregir en línea {0}
cannot.inline.reference.0=No se puede incluir en línea la referencia ''{0}''
cannot.introduce.field.in.interface=No se puede introducir un campo en una interfaz
cannot.introduce.field.in.script=El ámbito de la clase no está definido
cannot.process.usage.in.language.{0}=No se puede procesar el uso en {0}
cannot.rename.property.0=No se puede renombrar la propiedad <bold>''{0}''</bold> que reemplaza al método <bold>''{1}''</bold>
cannot.rename.script.class.to.0=No se puede renombrar la clase de script ''{0}'' a ''{1}''
changeSignature.no.type.for.exception=Especifica un tipo para la excepción
changeSignature.not.throwable.type=Tipo equivocado: ''{0}'' para excepción, debería extender java.lang.Throwable
changeSignature.wrong.type.for.exception=Tipo incorrecto: ''{0}'' para la excepción
class.does.not.exist.in.the.module=La clase no existe en el módulo. ¿Quieres crearla?
class.language.is.not.groovy=El lenguaje de la clase objetivo no es Groovy
closure.uses.external.variables=El closure usa variables externas que no son constantes
convert.to.java.can.work.only.with.groovy=La refactorización de Convertir a Java funciona solo con archivos de Groovy
convert.to.java.refactoring.name=Convertir a Java
converting.files.to.java=Convirtiendo archivos a Java
converting.files.to.static=Está convirtiendo los archivos a @CompileStatic
declare.final.checkbox=Declarar final
error.wrong.caret.position.method.name=El cursor debe estar posicionado en el nombre del método a refactorizar.
expression.contains.errors=Expresión contiene errores
extract.method.dialog.explicit.return.checkbox=Utilice sentencia de retorno explicita
extract.method.title=Extraer método
field.0.is.already.defined=El campo {0} ya está definido
field.cannot.be.initialized.in.constructor(s)=El campo no puede inicializarse en el/los constructor(es)
field.cannot.be.initialized.in.field.declaration=El campo no puede ser inicializado en la declaración
field.is.not.accessible.form.context.0=El campo {0} usado en el método de llamada directa no es accesible desde el sitio de llamada
files.to.be.converted=Archivos a convertir
final.field.cant.be.initialized.in.cur.method=El campo final no se puede inicializar en el método actual
implicit.getter.will.by.overridden.by.method=El getter implícito de la propiedad {0} será sobreescrito por el método {1}
implicit.setter.will.by.overridden.by.method=El setter implícito de la propiedad {0} será sobreescrito por el método {1}
initialize.in.border.title=Inicializar en
initialize.in.class.constructor.choice=Clase constructor(es)
initialize.in.current.method.choice=Método actual(&M)
initialize.in.field.declaration.choice=Declaración de campo(&D)
initialize.in.label=Inicializar en:
initialize.in.setup.method.choice=Método setUp
inline.local.variable.prompt.0.1=¿Variable local en línea ''{0}''?
inline.method.border.title=En línea
inline.method.label=Método {0}
inline.method.title=Metodo en línea
inplace.introduce.constant.move.checkbox=Mover a otra clase
intention.converting.to.static=Aplicar conversión a @CompileStatic
intention.converting.to.static.family=Convertir a @CompileStatic
introduce.closure.parameter.elements.header=Adición de parámetro a un cierre
introduce.constant.class.label=Introducir a class (nombre completo):
introduce.variable.title=Introducir variable
introduced.variable.conflicts.with.parameter.0=La variable introducida entrará en conflicto con el parámetro {0}
introduced.variable.conflicts.with.variable.0=La variable introducida entrará en conflicto con la variable local {0}
local.variable.is.lvalue=La variable a ser inlineada tiene ocurrencia como lvalue en asignación
method.duplicate=El método con firma {0} ya está definido en {1}
method.is.already.defined.in.class=El método {0} ya está definido en la clase {1}.
method.is.already.defined.in.script=El método {0} ya está definido en el script {1}.
method.is.not.accessible.form.context.0=El método {0} usado en el método en línea no es accesible desde el sitio de llamada
multiple.output.values=Existen múltiples valores de salida para el fragmento de código seleccionado
name.is.wrong=El identificador ''{0}'' es incorrecto
name.label=Nombre:(&N)
no.occurrences.found=No se encontraron ocurrencias
only.in.groovy.files=Este refactor es válido solo en archivos Groovy
press.escape.to.remove.the.highlighting=Pulsa Escape para eliminar resaltado
ref.0.will.not.be.resolved.outside.of.current.context=La referencia ''{0}'' no se resolverá fuera del contexto actual
refactored.method.will.cover.closure.property=El método refactorizado reemplazará la propiedad de cierre ''{0}'' en {1}
refactoring.cannot.be.applied.no.sources.attached=Refactorización no puede ser aplicada: no hay código fuente adjunto
refactoring.cannot.be.applied.to.abstract.methods=El refactor no se puede aplicar a métodos abstractos
refactoring.cannot.be.applied.to.constructors=La refactorización no se puede aplicar a constructores
refactoring.is.available.only.for.method.calls=El refactorizado solo está disponible para llamadas de método
refactoring.is.not.supported.in.method.parameters=La refactorización no es compatible en parámetros de cierre o método
refactoring.is.not.supported.in.parameter.initializers=La refactorización no está soportada en los inicializadores de parámetros
refactoring.is.not.supported.in.the.current.context=La refactorización no está soportada en el contexto actual
refactoring.is.not.supported.when.return.statement.interrupts.the.execution.flow=No se admite la refactorización si la declaración return interrumpe el flujo de ejecución
reference.to.accessor.0.is.used=No se puede insertar en línea la referencia al descriptor de acceso <bold>{0}<bold>.
remove.parameter.0.no.longer.used=Eliminar el parámetro ''{0}'' que ya no se utiliza
rename.groovy.property=Renombrar propiedad Groovy
rename.is.not.applicable.to.implicit.elements=No se puede renombrar elementos implícitos
rename.member=Renombrar {0}
rename.property=Renombrar la propiedad ''{0}''
replace.all.occurrences.checkbox=Reemplazar todas las coincidencias
replace.getter.for.property=El getter predeterminado para la propiedad ''{0}'' se sobrescribirá
replace.setter.for.property=El setter por defecto para la propiedad '{0}' será sobrescrito
return.type.is.wrong=El tipo de retorno es incorrecto
selected.block.contains.invocation.of.another.class.constructor=El bloque seleccionado contiene invocación de otro constructor de clase
selected.block.should.represent.a.statement.set=El bloque seleccionado debe representar un conjunto de sentencias o una expresión
selected.block.should.represent.an.expression=El bloque seleccionado debe representar una expresión
selected.expression.has.void.type=La expresión seleccionada tiene tipo void
selected.expression.should.not.be.lvalue=La expresión seleccionada no debe estar a la izquierda de la asignación
selected.variable.is.used.for.write=La variable seleccionada se utiliza para escritura
signature.preview.border.title=Vista previa de firma
specify.default.value=Especifique un valor predeterminado o inicializador para el parámetro ''{0}''
specify.type.label=Especificar explícitamente el tipo de retorno(&T)
super.reference.is.used=La llamada a super utilizada en el método embutido no será válida tras la embutición.
target.class.must.not.be.script=La clase destino no puede ser un script
there.is.no.method.or.closure=No hay método o cierre contenedor
this.invocation.only.and.keep.the.method=Invocar solo esto y mantener el método(&T)
type.for.parameter.is.incorrect=El tipo del parámetro ''{0}'' es incorrecto
type.label=Tipo:(&T)
usage.will.be.overridden.by.method=El uso {0} será sobrescrito por el método {1}
variable.conflicts.with.field.0=El nombre elegido entrará en conflicto con el campo {0}
variable.conflicts.with.parameter.0=El nombre elegido entra en conflicto con el parámetro {0}
variable.conflicts.with.variable.0=El nombre elegido entrará en conflicto con la variable local {0}
variable.is.accessed.for.writing=Variable ''{0}'' se accede para escritura
visibility.border.title=Visibilidad
visibility.private.choice=Privado
visibility.property.choice=Propiedad(&R)
visibility.protected.choice=Protegido(&O)
visibility.public.choice=Public(&B)
you.cannot.pass.as.parameter.0.because.you.remove.1.from.base.method=No se puede pasar ''{0}'' como parámetro porque se eliminó el parámetro ''{1}'' asociado en el método. Se debe deseleccionar "Eliminar parámetro ''{0}'' que ya no se utiliza" o deseleccionar el parámetro ''{1}'' en la tabla de parámetros.