abstract.cannot.be.instantiated=''{0}'' es abstracto; no se puede instanciar
abstract.method.0.cannot.be.accessed.directly.method.reference.context=El método abstracto ''{0}'' no puede ser accedido directamente
abstract.method.in.non.abstract.class=Método abstracto en una clase no abstracta
abstract.methods.cannot.have.a.body=los métodos abstractos no pueden tener cuerpo
actual.type.argument.contradict.inferred.type=El tipo de argumento real y el tipo inferido son contradictorios
ambiguous.method.call=Llamada a método ambigua: coinciden ''{0}'' y ''{1}''
ambiguous.method.call.no.match=El método ''{0}'' no se puede resolver en ''{1}''
ambiguous.method.html.tooltip=<html><body><table border=0><tr><td colspan={0}>Llamada a método ambigua.</td></tr><tr>{1}<td>en <b>{2}</b>&nbsp;y</td></tr><tr>{3}<td>en <b>{4}</b>&nbsp;coinciden.</td></tr></table></body></html>
ambiguous.reference=La referencia a ''{0}'' es ambigua, coinciden ''{1}'' y ''{2}''
an.enclosing.instance.of.type.not.in.scope.method.reference.context=Una instancia adjunta de tipo {0} no está dentro del ámbito
annotation.annotation.type.expected=Se esperaba un tipo de anotación
annotation.cannot.be.local=No se permiten anotaciones locales
annotation.container.abstract=La anotación de contenedor ''{0}'' no tiene valor predeterminado para ''{1}''
annotation.container.bad.type=Anotación de contenedor inválida ''{0}'': El método ''value'' debe tener tipo ''{1}''
annotation.container.low.retention=La anotación de contenedor ''{0}'' tiene una retención ({''1}'') más corta que la anotación contenida
annotation.container.missed.annotation=La anotación de container ''{0}'' no tiene la anotación @{1} requerida
annotation.container.no.value=La anotación del contenedor ''{0}'' no es válida: no se declaró el método ''value''
annotation.container.not.applicable=La anotación de contenedor ''@{0}'' no es aplicable a {1}
annotation.container.wide.target=El objetivo de la anotación del contenedor ''{0}'' no es un subconjunto del objetivo de esta anotación
annotation.container.wrong.place=La anotación de contenedor ''{0}'' no debe estar presente al mismo tiempo que el elemento que contiene
annotation.cyclic.element.type=Tipo cíclico de elemento de anotación
annotation.duplicate.annotation=Anotación duplicada
annotation.duplicate.attribute=Atributo duplicado ''{0}''
annotation.duplicate.explained=Anotación duplicada. {0}
annotation.illegal.array.initializer=Inicializador ilegal para ''{0}''
annotation.interface.is.not.used=@interface ''{0}'' no se utiliza
annotation.interface.members.may.not.have.parameters=@interface los miembros pueden no tener parámetros
annotation.invalid.annotation.member.type=Tipo no válido ''{0}'' para el miembro de anotación
annotation.may.not.have.extends.list=@interface no puede tener extends en la lista
annotation.may.not.have.type.parameters=@interface no puede tener parámetros tipo
annotation.members.may.not.have.throws.list=@interface los miembros no pueden tener una lista de excepciones
annotation.missing.attribute={0} requerido, pero ausente
annotation.missing.method=No se encuentra el método ''{0}''
annotation.non.class.literal.attribute.value=El valor del atributo debe ser un literal de clase
annotation.non.constant.attribute.value=El valor del atributo debe ser una constante
annotation.non.enum.constant.attribute.value=El valor del atributo debe ser una constante de enumeración
annotation.non.repeatable=La declaración de ''{0}'' no tiene una annotation ''java.lang.annotation.Repeatable'' valida
annotation.not.allowed.class=No se puede anotar tipo literal de clase
annotation.not.allowed.here=Las anotaciones no están permitidas aquí
annotation.not.allowed.in.permit.list=Las anotaciones no están permitidas en las listas de permisos
annotation.not.allowed.ref=Anotación no aplicable a este tipo de referencia
annotation.not.allowed.static=El tipo de calificación de miembro estático no puede anotarse
annotation.not.allowed.var='var' tipo no puede ser anotado
annotation.not.allowed.void='void' tipo no debe ser anotado
annotation.not.applicable=''@{0}'' no aplicable a {1}
annotation.on.static.member.qualifying.type.family.name=Mover anotación de tipo
annotation.type.permits=Cláusula permits no permitida para tipo anotación
annotation.unknown.method=No se puede resolver el método ''{0}''
anonymous.class.implements.interface.cannot.have.qualifier=Clase anónima implementa una interfaz; no puede tener calificador para "new"
anonymous.class.implements.interface.cannot.have.type.arguments=La clase anónima, que implementa una interfaz, no puede tener argumentos de tipo
anonymous.classes.must.not.extend.sealed.classes=Las clases anónimas no deben extender clases cerradas
array.creation.with.type.arguments=No se puede crear un array con argumentos de tipo
array.initializer.not.allowed=Inicializador de array no permitido aquí
array.type.expected=Se esperaba el tipo de matriz; se encontró: ''{0}''
assert.identifier.warn=El uso de 'assert' como un identificador no es compatible con versiones posteriores a Java 1.4
assignment.to.final.variable=No se puede asignar un valor a la variable final ''{0}''
auto.closeable.resource=recurso autocerrable
bad.qualifier.in.super.method.reference.extended=Mal calificador de tipo en llamada super predeterminada: la interfaz redundante {0} está extendida por {1}
bad.qualifier.in.super.method.reference.overridden=Calificador de tipo incorrecto en llamada predeterminada super: el método {0} se reemplaza en {1}
bad.type.in.switch.expression=Tipo erróneo en la expresión switch: {0} no se puede convertir a {1}
binary.numbers.must.contain.at.least.one.hexadecimal.digit=Los números binarios deben contener como mínimo un dígito binario
binary.operator.not.applicable=El operador ''{0}'' no es aplicable a ''{1}'', ''{2}''
break.outside.switch.expr=No se permite ir a otra parte desde una expresión de cambio
break.outside.switch.or.loop=Break fuera de switch o loop
call.to.super.is.not.allowed.in.enum.constructor=No se permite la llamada a super en el constructor enum
cannot.access.member.on.type=Imposible acceder al miembro porque ''{0}'' tiene tipo básico {1}
cannot.be.referenced.from.static.context=No se puede hacer referencia a ''{0}'' desde un contexto estático
cannot.call.method.on.type=no es posible llamar a un método del tipo nulo ''{0}'' porque tiene tipo primitivo {1}
cannot.create.array.with.empty.diamond=no se puede crear un arreglo con diamante vacío
cannot.find.class=No se encuentra la clase {0}
cannot.infer.functional.interface.type=No se puede inferir el tipo de interfaz funcional
cannot.resolve.constructor=No se puede resolver el constructor ''{0}''
cannot.resolve.method=No se puede resolver el método ''{0}''
cannot.resolve.package=No se puede resolver el paquete {0}
cannot.resolve.symbol=No se puede resolver el símbolo ''{0}''
cannot.select.dot.class.from.type.variable=No se puede seleccionar desde una variable de tipo
cannot.select.from.a.type.parameter=No se puede seleccionar desde un parámetro de tipo
cannot.select.from.parameterized.type=No se puede seleccionar desde un tipo parametrizado
case.statement.outside.switch=Sentencia case fuera del switch
catch.without.try='catch' sin 'try'
clash.methods.message=''{0}'' choca con ''{1}''
clash.methods.message.show.classes=''{2}'' del ''{0}'' choca con ''{3}'' del ''{1}''
class.already.imported=''La clase {0} ya está definida en esta unidad de compilación
class.cannot.be.inherited.with.different.arguments={0} no se puede heredar con diferentes argumentos: {1}
class.cannot.extend.multiple.classes=Una clase no puede extender múltiples clases
class.cannot.inherit.from.its.type.parameter=La clase no puede heredar de su parámetro de tipo
class.clashes.with.package=La clase ''{0}'' entra en conflicto con el paquete del mismo nombre
class.expected=Se espera el nombre de la clase aquí
class.in.default.package=La clase ''{0}'' está en el paquete por defecto
class.is.already.defined.in.single.static.import=La clase ''{0}'' ya está definida en una importación estática única
class.is.ambiguous.in.single.static.import=La clase ''{0}'' es ambigua en una sola importación estática
class.is.not.used=La clase ''{0}'' nunca es usada
class.member.declared.outside=Miembro de clase declarado fuera de la clase
class.must.be.abstract=La clase ''{0}'' debe declararse abstracta o implementar el método abstracto ''{1}'' en ''{2}''
class.must.implement.method=La clase ''{0}'' debe implementar el método abstracto ''{1}'' de ''{2}''
class.name.expected=Se esperaba el nombre de la clase
class.not.allowed.to.extend.sealed.class.from.another.module=No se permite que la clase extienda la clase sellada de otro módulo
class.not.allowed.to.extend.sealed.class.from.another.package=No se permite que la clase extienda una clase sellada de otro paquete
classes.extends.prohibited.super=Las clases no pueden extender directamente ''{0}''
compact.constructor.in.regular.class=Se espera lista de parámetros
constant.expression.required=Se requiere expresión constante
constructor.call.must.be.first.statement=La llamada a ''{0}'' debe ser la primera instrucción en el cuerpo del constructor
constructor.call.must.be.top.level.statement=La llamada a ''{0}'' debe ser una declaración de nivel superior dentro del cuerpo del constructor
constructor.call.only.allowed.in.constructor=el constructor.call solo está permitido en el constructor
constructor.is.not.used=El constructor ''{0}'' nunca se usa
continue.outside.loop=Continuar fuera del bucle
continue.outside.switch.expr=Continuar afuera de la expresión de switch que la contiene
create.class.action.this.not.valid.java.qualified.name=Este no es un nombre calificado Java válido
cyclic.inheritance=Herencia cíclica con ''{0}''
declaration.not.allowed=Declaración no permitida aquí
declaration.or.variable.expected=Se esperaba una declaración, variable final o variable efectivamente final
deconstruction.pattern.requires.record=El patrón de deconstrucción solo se puede aplicar a registros. ''{0}'' no es un registro
deconstruction.pattern.type.contain.annotation=No se permiten anotaciones en tipos de patrones de desestructuración
default.label.must.not.contains.case.keyword=La etiqueta case por defecto no debe contener la palabra clave 'case'
default.label.not.allowed.here=La etiqueta predeterminada no está permitida aquí: 'default' solo se puede utilizar como etiqueta de caso individual o solo emparejado con 'null'
default.method.overrides.object.member=Método predeterminado ''{0}'' sobrescribe un miembro de ''java.lang.Object''
deprecated.default.constructor=El constructor por defecto en ''{0}'' está en desuso
deprecated.since.symbol=''{0}'' es obsoleto desde la versión {1}
deprecated.symbol=''{0}'' es obsoleto
diamond.operator.not.allowed.here=El operador Diamante no está permitido aquí
different.case.kinds.in.switch=Tipos de caso distintos usados en la instrucción switch
direct.abstract.method.access=El método abstracto ''{0}'' no puede ser accedido directamente
dot.expected.after.super.or.this='.' esperado
duplicate.class=Clase duplicada: ''{0}''
duplicate.class.in.other.file=Clase duplicada encontrada en el archivo ''{0}''
duplicate.default.switch.label=Etiqueta predeterminada duplicada
duplicate.label=La etiqueta ''{0}'' ya está en uso
duplicate.method=''{0}'' ya está definido en ''{1}''
duplicate.reference.in.list=''Referencia duplicada a ''{0}'' en la lista ''{1}''
duplicate.switch.label=Etiqueta duplicada ''{0}''
duplicate.unconditional.pattern.label=Patrón incondicional duplicado
else.without.if='else' sin 'if'
empty.character.literal=Literal de carácter vacío
enum.constant.must.implement.method=La constante de enumeración ''{0}'' debe implementar el método abstracto ''{1}'' en ''{2}''
enum.identifier.warn=Uso de 'enum' como identificador no se admite en versiones posteriores a Java 1.5
enum.is.not.used=La enumeración ''{0}'' nunca se usa
enum.types.cannot.be.instantiated=Los tipos enum no se pueden instanciar
error.cannot.infer.pattern.type=No se puede deducir el tipo de patrón: {0}
error.cannot.resolve.class=No se puede resolver la clase ''{0}''
error.cannot.resolve.class.or.package=No se puede resolver la clase o el paquete ''{0}''
error.extra.semicolons.between.import.statements.not.allowed=No se permiten puntos y coma adicionales entre las sentencias de importación
error.guard.allowed.after.patterns.only=Guard solo permitido después de los patrones
error.implicit.class.contains.no.main.method=La clase implícita declarada no contiene el método 'main'
error.implicit.class.has.invalid.file.name=El nombre del archivo de la clase implícita no es un identificador válido
error.initializers.are.not.allowed.in.implicit.classes=Los inicializadores no son válidos en las clases implícitas
error.interface.member.clashes=El miembro de la interfaz entra en conflicto con ''{0}'' en {1}
error.package.statement.not.allowed.for.implicit.class=La sentencia del paquete no está permitida para la clase implícita
error.raw.deconstruction=Patrón de desestructuración sin procesar no permitido
exception.already.caught=La excepción ''{0}'' ya ha sido capturada
exception.already.caught.warn=Sección inalcanzable: {1, choice, 0#excepción|2#excepciones} ''{0}'' {1, choice, 0#ya|2#ya} han sido atrapad{1, choice, 0#a|2#as}
exception.is.never.thrown=La excepción ''{0}'' nunca es lanzada en el método
exception.must.be.disjoint=Los tipos en multi-catch deben ser disjuntos: ''{0}'' es una subclase de ''{1}''
exception.never.thrown.try=Exception ''{0}'' nunca es lanzada en el bloque try correspondiente
expected.boolean.expression=Se esperaba una expresión booleana
expected.catch.or.finally='catch' o 'finally' esperado
expected.class.or.package=Clase o paquete esperado
expected.comma=Se espera ','
expected.expression=Se espera una expresión
expected.identifier=Se espera identificador
expected.identifier.or.type=Se esperaba un identificador o tipo
expected.lbrace='{' esperado
expected.lparen='(' es necesario
expected.lparen.or.lbracket='(' o '[' esperado
expected.parameter=Se esperaba parámetro
expected.rbrace=se esperaba '}'
expected.rbracket=se esperaba ']'
expected.rparen=Se esperaba ')'
expected.semicolon=Se esperaba ;
expected.statement=Se esperaba una instrucción
expected.switch.label='case', 'default' o '}' esperado
expected.switch.rule=Se esperaba expresión, bloque o declaración 'throw'
expected.while='while' esperado
expression.expected=Se esperaba expresión
expression.with.type.void.not.allowed.as.string.template.embedded.expression=La expresión con el tipo 'vacío' no se permite como expresión incrustada en la plantilla de la cadena
extends.after.enum=No se permite clásula extends para enum
extension.method.in.class=Los métodos de extensión sólo pueden utilizarse en una interfaz
extension.method.should.have.a.body=El método de extensión debería tener un cuerpo
field.is.already.defined.in.single.static.import=El campo ''{0}'' ya está definido en una importación estática simple
field.is.ambiguous.in.single.static.import=El campo ''{0}'' es ambiguo en una única importación estática
field.is.not.used=El campo ''{0}'' nunca se usa
field.is.not.used.for.reading={0} el campo ''{1}'' está asignado, pero nunca se accede a él
final.method.override=''{0}'' no puede overridear ''{1}'' en ''{2}''; el método overrideado es final
finally.without.try='finally' sin 'try'
floating.point.number.too.large=El número de punto flotante es demasiado grande
floating.point.number.too.small=Número decimal flotante muy pequeño
foreach.not.applicable=foreach no aplicable para tipo ''{0}''
formal.varargs.element.type.inaccessible.here=El tipo de elemento varargs formal {0} no es accesible aquí
functional.interface.must.not.be.sealed.error.description=La interfaz funcional no puede ser declarada como ''{0}''
generic.array.creation=Generación de matrices genéricas
generic.extend.exception=Las clases genéricas no pueden heredar 'java.lang.Throwable'
generics.annotation.members.may.not.have.type.parameters=@interface los miembros pueden no tener parámetros de tipo
generics.cannot.be.inherited.as.raw.and.generic=''{0}'' no puede ser heredado como un tipo raw con argumentos de tipo genérico ''{1}''
generics.cannot.be.inherited.with.different.type.arguments=''{0}'' no puede ser heredado con diferentes argumentos de tipo: ''{1}'' y ''{2}''
generics.cannot.catch.type.parameters=No se pueden capturar parámetros de tipo
generics.cannot.instanceof.type.parameters=Se esperaba una clase o un array
generics.diamond.not.applicable=El operador diamante no es aplicable a tipos no parametrizados
generics.duplicate.type.parameter=El parámetro de tipo ''{0}'' está duplicado
generics.enum.may.not.have.type.parameters=Enum no puede tener parámetros de tipo
generics.holder.method=Método
generics.holder.type=Tipo
generics.inferred.type.for.type.parameter.is.not.within.its.bound.extend=El tipo inferido ''{2}'' para el parámetro de tipo ''{0}'' no está dentro de su límite; debe extender ''{1}''
generics.inferred.type.for.type.parameter.is.not.within.its.bound.implement=Tipo inferido ''{2}'' para el parámetro de tipo ''{0}'' no está dentro de sus límites; debería implementar ''{1}''
generics.methods.have.same.erasure={0}; ambos metodos tienen el mismo borrado
generics.methods.have.same.erasure.hide={0}; ambos métodos tienen el mismo borrado, pero ninguno oculta al otro
generics.methods.have.same.erasure.override={0}; ambos métodos tienen el mismo borrado, pero ninguno reemplaza al otro
generics.reference.parameters.not.allowed=Los parámetros de referencia no están permitidos aquí
generics.select.static.class.from.parameterized.type=No se puede seleccionar la clase estática "{0}" del tipo parametrizado
generics.type.argument.cannot.be.of.primitive.type=El argumento de tipo no puede ser de tipo primitivo
generics.type.arguments.on.raw.method=Argumentos del tipo dados en un método específico
generics.type.arguments.on.raw.type=Se proporcionaron argumentos de tipo en un tipo sin formato
generics.type.or.method.does.not.have.type.parameters={0} ''{1}'' no tiene parámetros de tipo
generics.type.parameter.cannot.be.instantiated=El parámetro de tipo ''{0}'' no puede instanciarse directamente
generics.type.parameter.is.not.within.its.bound.extend=El parámetro de tipo ''{0}'' no está dentro de su límite; debe extender ''{1}''
generics.type.parameter.is.not.within.its.bound.implement=El parámetro de tipo ''{0}'' no está dentro de su límite; debería implementar ''{1}''
generics.unchecked.assignment=Asignación sin comprobar: ''{0}'' a ''{1}''
generics.unchecked.call=Llamada de método sin verificar ''{0}''
generics.unchecked.call.to.member.of.raw.type=Llamada no comprobada a ''{0}'' como miembro del tipo en bruto ''{1}''
generics.unchecked.cast=Lanzamiento no revisado: ''{0}'' a ''{1}''
generics.wildcard.not.expected=No se esperaba un comodín
generics.wildcards.may.be.used.only.as.reference.parameters=Los comodines pueden ser usados solo como parámetros de referencia
generics.wrong.number.of.type.arguments=Número incorrecto de argumentos de tipo: {0}; requeridos: {1}
guarded.pattern.variable.must.be.final=La variable usada en patrón protegido debe ser final o efectivamente final
hexadecimal.numbers.must.contain.at.least.one.hexadecimal.digit=Los números hexadecimales deben contener al menos un dígito hexadecimal
identifier.is.not.allowed.here=El identificador no está permitido aquí
illegal.escape.character.in.character.literal=Carácter de escape ilegal en el literal de carácter
illegal.escape.character.in.string.literal=Carácter de escape ilegal en el literal de cadena
illegal.forward.reference=Referencia directa ilegal
illegal.forward.reference.enum=No se puede hacer referencia a la constante ''{0}'' de enumeración antes de su definición
illegal.generic.type.for.instanceof=Tipo genérico ilegal para instanceof
illegal.initializer=Inicializador ilegal para ''{0}''
illegal.line.end.in.string.literal=Fin de línea ilegal en el literal de cadena
illegal.self.reference=Referencia automática ilegal
illegal.self.reference.enum=no se puede hacer referencia a las constantes de enumeración ''{0}'' desde su propia definición
illegal.to.access.static.member.from.enum.constructor.or.instance.initializer=Es ilegal acceder al miembro estático ''{0}'' desde el constructor de la enumeración o el inicializador de instancia
illegal.type.void=Tipo ilegal: 'void'
illegal.underscore=Guión bajo ilegal
illegal.unicode.escape=Secuencia de escape de Unicode no válida
implements.after.interface=No se admite cláusula implements para la interfaz
implicit.class.can.not.be.referenced=La clase implícita no puede ser referenciada ''{0}''
impossible.assign.declared.outside.guard=No se puede asignar el valor a la variable '{0}' porque está declarada fuera del guard
inaccessible.type=''{0}'' no es accesible aquí
incompatible.modifiers=Combinación ilegal de modificadores: ''{0}'' y ''{1}''
incompatible.parameter.types.in.lambda=Tipos de parámetro incompatibles en la expresión lambda: se esperaba {0} pero se encontró {1}
incompatible.parameter.types.in.lambda.wrong.number.of.parameters=Tipos de parámetros incompatibles en expresión lambda: número incorrecto de parámetros: se esperaba {0} pero se encontraron {1}
incompatible.return.type=tratando de utilizar un tipo de retorno incompatible
incompatible.switch.null.type=''{0}'' no se puede convertir a ''{1}''
incompatible.types=Tipos incompatibles. Encontrado: ''{1}'', requerido: ''{0}''
incompatible.types.html.tooltip=<html><body><table><tr><td style=''padding: 0px 16px 8px 4px;color: {5}''>Se esperaba tipo:</td><td style=''padding: 0px 4px 8px 0px;''>{0}</td>{1}</tr><tr><td style=''padding: 0px 16px 0px 4px;color: {5}''>Tipo proporcionado:</td><td style=''padding: 0px 4px 0px 0px;''>{2}</td>{3}</tr></table>{4}</body></html>
incompatible.types.reason.ambiguous.method.reference=<br/>razón: la referencia del método es ambigua: ''{0}'' y ''{1}'' coinciden
incomplete.project.state.pending.reference=No se resolverá hasta que el proyecto se cargue completamente
inconvertible.type.cast=tipos inconvertibles; no se puede convertir ''{0}'' a ''{1}''
incorrect.number.of.nested.patterns=No. de patrones anidados incorrecto: debe ser {0}, pero es {1}
inheritance.from.final.class=No se puede heredar de {1} ''{0}''
initializer.must.be.able.to.complete.normally=El inicializador debe poder completarse con normalidad
instance.method.cannot.override.static.method=El método de instancia ''{0}'' en ''{1}'' no puede sobreescribir el método estático ''{2}'' en ''{3}''
instanceof.pattern.equals=El tipo de patrón ''{0}'' es igual que el tipo de expresión
instanceof.pattern.supertype=El tipo de patrón ''{0}'' es un supertipo del tipo de expresión ''{1}''
insufficient.language.level={0} no son soportados en nivel de idioma ''{1}''
integer.number.too.large=Número entero demasiado grande
interface.expected=Se esperaba una interfaz aquí
interface.is.not.used=La interfaz ''{0}'' nunca se usa
interface.methods.cannot.have.body=Los métodos abstractos de la interfaz no pueden tener cuerpo
invalid.case.label.combination.constants.and.patterns=Combinación de etiquetas de caso no válida: una etiqueta de caso debe contener una lista de constantes de caso o un solo patrón de caso
invalid.case.label.combination.constants.and.patterns.unnamed=Combinación de etiqueta de caso no válida: una etiqueta de caso debe contener una lista de constantes de caso o una lista de patrones de caso
invalid.case.label.combination.several.patterns=Combinación de etiqueta de caso no válida: una etiqueta de caso no debe contener más de un patrón de caso
invalid.case.label.combination.several.patterns.unnamed=Combinación de etiqueta de caso invalida: varios patrones solo están permitidos cuando ningún patrón declara variable de patrón
invalid.default.and.null.order=orden inválido de etiquetas case: 'null' debe ser la primera, 'default' la segunda
invalid.package.annotation.containing.file=Las anotaciones de paquete deben estar en el archivo package-info.java
invalid.permits.clause=Cláusula de permits no válida: ''{0}'' debe estar sellada
invalid.permits.clause.direct.implementation=Cláusula de permisos no válida: ''{0}'' debe {1, choice, 1#extender|2#implementar} directamente ''{2}''
invalid.qualified.new=Nuevo calificado inválido
invalid.statement=sentencia inválida
is.not.an.enclosing.class=''{0}'' no es una clase envolvente
label.without.statement=Etiqueta sin instrucción
lambda.expression.not.expected=Se esperaba una expresión lambda
lambda.parameters.consistency.message=No se pueden mezclar parámetros explícitamente tipados y 'var' en una expresión lambda
lambda.variable.must.be.final=La variable usada en la expresión lambda debe ser final o efectivamente final
local.class.is.not.used=La clase local ''{0}'' no se utiliza
local.class.referenced.from.other.switch.branch=La clase local ''{0}'' no se puede referenciar desde otra rama de switch
local.classes.must.not.extend.sealed.classes=Las clases locales no deben extender las clases selladas
local.variable.is.never.used=La variable ''{0}'' nunca se utiliza
local.variable.is.not.assigned=La variable ''{0}'' nunca ha sido asignada
local.variable.is.not.used.for.reading=Variable ''{0}'' está asignada pero nunca llamada
long.number.too.large=Número entero largo demasiado grande
lvti.array='var' no es permitido como tipo de elemento de un array
lvti.compound='var' no está permitido en una declaración compuesta
lvti.lambda=No se puede inferir el tipo: la expresión lambda requiere un tipo de destino explícito
lvti.method.ref=No se puede inferir el tipo: la referencia al método necesita un tipo de destino explícito
lvti.no.initializer=No se puede inferir el tipo: 'var' en una variable sin inicializador
lvti.null=No se puede inferir el tipo: el inicializador de variable es 'null'
lvti.selfReferenced=No se puede inferir el tipo: el inicializador de variable es autorreferenciante
lvti.void=No se puede inferir el tipo: el inicializador de la variable es 'void'
malformed.floating.point.literal=Literal de punto flotante mal formado
marked.for.removal.default.constructor=Constructor predeterminado en ''{0}'' está obsoleto y marcado para su eliminación
marked.for.removal.symbol=''{0}'' está en desuso y marcado para su eliminación
marked.for.removal.symbol.since=''{0}'' está marcado como obsoleto y programado para ser eliminado desde la versión {1}
member.referenced.before.constructor.called=No se puede referenciar ''{0}'' hasta que se llame al constructor del supertipo
method.call.expected=Se esperaba una llamada a método
method.called.before.constructor.called=No se puede llamar a ''{0}'' antes de que se llame al constructor de la superclase
method.does.not.override.super=El método no invalida el método de la superclase
method.is.not.used=El método ''{0}'' nunca se usa
method.reference.expression.is.not.expected=Se espera una expresión de referencia de método aquí
missing.method.body=Cuerpo del método faltante, o declarar abstracto
missing.package.statement=Declaración de paquete faltante: ''{0}''
missing.package.statement.package.name.invalid=Falta la declaración del paquete, pero el nombre del paquete ''{0}'', que corresponde a la ruta del archivo, no es válido
missing.return.statement=Falta sentencia return
missing.return.type=Declaración de método inválida; se requiere tipo de retorno
missing.return.value=Falta valor de retorno
modifier.not.allowed=El modificador ''{0}'' no está permitido aquí
modifier.not.allowed.on.classes.without.sealed.super=el modificador "non-sealed" no está permitido en clases sin una superclase "sealed"
modifier.not.allowed.on.local.classes=El modificador ''{0}'' no está permitido en clases locales
modifiers.for.enum.constants=No se permiten modificadores para constantes de enumeración
module.access.bad.name=El paquete ''{0}'' está declarado en un módulo con nombre no válido (''{1}'')
module.access.does.not.read=El paquete ''{0}'' está declarado en el módulo ''{1}'', pero el módulo ''{2}'' no lo lee
module.access.from.named=El paquete ''{0}'' está declarado en el módulo ''{1}'', pero no exporta el paquete al módulo ''{2}''
module.access.from.unnamed=El paquete ''{0}'' se declara en el módulo ''{1}'', que no lo exporta al módulo no nombrado
module.access.not.in.graph=El paquete ''{0}'' está declarado en el módulo ''{1}'', que no está en el grafo de módulos
module.access.to.unnamed=El paquete ''{0}'' está declarado en el módulo sin nombre, pero el módulo ''{1}'' no lo lee
module.ambiguous=Referencia de módulo ambigua: {0}
module.bad.name=Nombre del módulo ''{0}'' no válido
module.conflicting.packages=El paquete ''{0}'' existe en otro módulo: {1}
module.conflicting.reads=El módulo ''{0}'' lee el paquete ''{1}'' tanto de ''{2}'' como de ''{3}''
module.cyclic.dependence=Dependencia cíclica: {0}
module.does.not.read=El módulo ''{0}'' no puede leer ''{1}''
module.duplicate.exports=Duplicar ''exports'': {0}
module.duplicate.exports.target=El objetivo de las ''exports'' está duplicado: {0}
module.duplicate.impl=Implementación duplicada: {0}
module.duplicate.opens=Módulo ''opens'' duplicado: {0}
module.duplicate.opens.target=Objetivo ''opens'' duplicado: {0}
module.duplicate.provides=Proporciona ''duplicado'': {0}
module.duplicate.requires=Duplicado ''requires'': {0}
module.duplicate.uses=Uso duplicado: {0}
module.file.duplicate='module-info.java' ya existe en el módulo
module.file.wrong.location=La declaración del módulo debe ubicarse en la raíz de origen del módulo
module.file.wrong.name=La declaración del módulo debe estar en un fichero llamado 'module-info.java'
module.no.package=Un archivo de módulo no debe tener sentencia 'package'
module.not.found=Módulo no encontrado: {0}
module.not.in.graph=El módulo ''{0}'' no se encuentra en el grafo de módulos
module.not.on.path=El módulo no se encuentra en las dependencias: {0}
module.open.duplicate.text=Ir al duplicado
module.opens.in.weak.module='opens' no está permitido en un módulo abierto
module.service.abstract=La implementación del servicio es una clase abstracta: {0}
module.service.alien=La implementación del servicio debe estar definida en el mismo módulo como la directiva provides
module.service.enum=La definición del servicio es una enumeración: {0}
module.service.impl=El tipo de implementación del servicio debe ser un subtipo del tipo de interfaz del servicio, o tener un método público estático 'provider' sin argumentos
module.service.inner=La implementación de servicio es una clase anidada: {0}
module.service.no.ctor=La implementación del servicio no tiene un constructor público predeterminado: {0}
module.service.provider.type=El tipo devuelto del método ''provider'' debe ser un subtipo del tipo de interfaz de servicio: {0}
module.service.unused=Interfaz de servicio proporcionada pero no exportada ni utilizada
module.unwanted.modifier.warn=Desde Java 10, los modificadores en 'requires java.base' están prohibidos en las versiones posteriores
multiple.non.overriding.abstract.methods.found.in.0=Se encontraron varios métodos abstractos sin sobreescritura en {0}
multiple.non.overriding.abstract.methods.found.in.interface.0=Múltiples métodos abstractos que no anulan en la interfaz {0}
multiple.switch.labels=Solo se permiten varias etiquetas switch en un grupo de sentencias etiquetado como switch si ninguna declara una variable de patrón
native.methods.cannot.have.a.body=Los métodos nativos no puede tener un cuerpo
no.default.constructor.available=No hay constructor por defecto disponible en ''{0}''
no.enclosing.instance.in.scope=No hay ninguna instancia de tipo ''{0}'' encerrando el ámbito
no.interface.expected=No se espera interfaz aquí
no.target.method.found=Método destino inexistente
non.static.method.cannot.be.referenced.from.a.static.context.method.reference.context=No se puede referenciar un método no estático desde un contexto estático
non.static.symbol.referenced.from.static.context=No se puede hacer referencia a {0} no estático ''{1}'' desde un contexto estático
not.a.functional.interface={0} no es una interfaz funcional
not.a.statement=No es una expresión
not.allowed.in.interface=No permitido en la interfaz
not.allowed.in.sealed.hierarchy={0} no se admite en la jerarquía sealed
not.inner.class=''{0}'' no es una clase interna
not.loop.label=Etiqueta de no bucle: ''{0}''
null.label.not.allowed.here=Combinación de etiquetas `case` no válida: `null` solo se puede usar como etiqueta `case` individual o únicamente emparejada con `default`
numeric.overflow.in.expression=Desbordamiento numérico en expresión
only.one.constructor.call.allowed.in.constructor=Solo se permite una llamada al constructor explícita en el constructor
overridden.method.does.not.throw={0}; el método sobreescrito no lanza ''{1}''
overrides.deprecated.method=Sobrescribe el método en desuso en ''{0}''
overrides.marked.for.removal.method=Sobreescribe el método que quedó en desuso y marcado para eliminación en ''{0}''
package.clashes.with.class=El paquete ''{0}'' entra en conflicto con una clase del mismo nombre
package.is.empty=El paquete está vacío: {0}
package.local.symbol=''{0}'' no es público en ''{1}''. No se puede acceder desde fuera del paquete
package.name.file.path.mismatch=El nombre del paquete ''{0}'' no corresponde a la ruta del archivo ''{1}''
package.not.found=Paquete no encontrado: {0}
parameter.excluding.hierarchy.disable.text=No resaltar parámetros de métodos heredados
parameter.is.not.used=El parámetro ''{0}'' nunca se utiliza
parameterized.qualifier.on.static.method.reference.context=Calificador parametrizado en referencia de método estático
pattern.is.not.exhaustive=El patrón ''{0}'' no es exhaustivo en ''{1}''
pattern.variable.is.not.used=La variable de patrón ''{0}'' nunca se utiliza
permit.list.must.contain.outside.inheritors=La cláusula permits de la clase sellada debe contener todas las subclases
permits.after.enum=No se admite la cláusula permits para enum
permits.list.generics.are.not.allowed=Los genéricos no están permitidos en la lista de permisos
permitted.subclass.must.have.modifier=Todas las subclases de la clase sellada deben ser final, selladas o no selladas
private.constructor.is.not.used=Constructor privado ''{0}'' nunca es usado
private.field.is.not.assigned=El campo privado ''{0}'' nunca se asigna
private.field.is.not.used=El campo privado ''{0}'' no se utiliza
private.inner.class.is.not.used=La clase interna privada ''{0}'' nunca se utiliza
private.inner.interface.is.not.used=La interfaz interna privada ''{0}'' nunca se usa
private.method.is.not.used=El método privado ''{0}'' nunca es utilizado
private.methods.in.interfaces.should.have.body=Los métodos privados en interfaces deberían tener cuerpo
private.symbol=''{0}'' tiene acceso privado en ''{1}''
processor.missing.from.string.template.expression=El procesador no se encuentra en la expresión de la plantilla de cadena
protected.symbol=''{0}'' cuenta con acceso protegido en ''{1}''
public.class.should.be.named.after.file=La clase ''{0}'' es pública, debe ser declarada en un archivo llamado ''{0}.java''
qualified.class.reference.not.allowed.in.qualified.new=Referencia de clase calificada no permitida en new calificada
qualified.enum.constant.in.switch=La etiqueta del caso switch enum debe ser el nombre no calificado de una constante de enumeración
qualified.enum.constant.in.switch.remove.fix=Eliminar Calificador
qualified.new.of.static.class=nuevo calificado de la clase estática
qualifier.must.be.expression=El calificador debe ser una expresión
raw.processor.type.not.allowed=Tipo de procesador sin procesar no permitido: {0}
receiver.name.mismatch=El nombre del receptor no coincide con el tipo de la clase envolvente
receiver.static.context=El receptor no se puede usar en un contexto estático
receiver.type.mismatch=El tipo de receptor no coincide con el tipo de clase que lo envuelve
receiver.wrong.context=Los receptores no están permitidos fuera de la lista de parámetros del método
receiver.wrong.position=El receptor debe ser el primer parámetro
record.accessor=Acceder a componentes de registro
record.accessor.wrong.return.type=Tipo de retorno del descriptor de componente incorrecto. Esperado: ''{0}'', encontrado: ''{1}''
record.canonical.constructor=Constructor canónico
record.canonical.constructor.wrong.parameter.name=Los nombres de los parámetros del constructor canónico deben coincidir con los nombres de los componentes del registro. Esperado: ''{0}'', encontrado: ''{1}''
record.canonical.constructor.wrong.parameter.type=Tipo incorrecto para el parámetro del componente de registro ''{0}''. Se esperaba: ''{1}'', se encontró: ''{2}''
record.compact.constructor=Constructor compacto
record.compact.constructor.return='La declaración `return` no está permitida en constructores compactos'
record.component.cstyle.declaration=La declaración de componente de registro al estilo C no está permitida
record.component.not.initialized=Componente de registro ''{0}'' no se pudo inicializar en el constructor canónico
record.component.restricted.name=Nombre de componente de registro ilegal ''{0}''
record.component.vararg.not.last=El componente vararg del record debe ser el último en la lista
record.constructor.call.in.canonical=El constructor canónico no puede delegar en otro constructor
record.extends=No se permite la cláusula extends para records
record.header.regular.class=Encabezado de registro declarado para una clase que no es registro
record.instance.field=El campo de instancia no está permitido en el registro
record.instance.initializer=No se permite inicializador de instancia en el registro
record.is.not.used=El registro ''{0}'' no es utilizado
record.no.constructor.call.in.non.canonical=El constructor de registro no canónico debe delegar en otro constructor
record.no.header=El registro no tiene un header declarado
record.permits=No se permite cláusula permits para el registro
record.special.method.non.public={0} debe ser ''public''
record.special.method.stronger.access={0} el nivel de acceso no puede ser más restrictivo que el nivel de acceso del registro (''{1}'')
record.special.method.throws={0} no puede declarar excepciones lanzadas
record.special.method.type.parameters={0} no puede tener parámetros de tipo
recursive.constructor.invocation=Invocación recursiva del constructor
redundant.semicolon.warn=El punto y coma redundante entre las sentencias import está desaprobado desde Java 21
remove.unused.imports.quickfix.text=Eliminar importaciones no usadas
repeated.annotation.target=Target de anotación repetido
repeated.interface=Interfaz repetida
repeated.modifier=Modificador repetido ''{0}''
resource.variable.must.be.final=Variable usada como recurso en un bloque try-with-resources debe ser final o efectivamente final
restricted.identifier=''{0}'' es un identificador restringido y no puede ser utilizado en declaraciones de tipo
restricted.identifier.reference=Referencia ilegal al tipo restringido ''{0}''
restricted.identifier.warn=No se admite el uso de ''{0}'' como nombre de clase en versiones posteriores a Java {1}
return.from.constructor=return desde el constructor
return.from.void.method=No se puede retornar un valor desde un método con tipo de retorno void
return.outside.method=Retorno fuera del método
return.outside.switch.expr=Return fuera de la expresión switch contenedora
return.statement.not.allowed.before.explicit.constructor.call=La sentencia ''return'' no está permitida antes de la llamada al constructor explícito de ''{0}''
safevararg.annotation.cannot.be.applied.for.record.component=La anotación @SafeVarargs no se puede aplicar a un componente de registro
safevarargs.not.allowed.non.final.instance.methods=@SafeVarargs no está permitido en métodos de instancia no finales
safevarargs.not.allowed.on.methods.with.fixed.arity=@SafeVarargs no está permitido en métodos con aridad fija
safevarargs.not.applicable.for.reifiable.types=@SafeVarargs no es aplicable para tipos reificables
safevarargs.not.suppress.potentially.unsafe.operations=Los @SafeVarargs no suprimen operaciones potencialmente no seguras
sealed.cannot.be.functional.interface=Las clases cerradas no pueden usarse como interfaz funcional
sealed.must.have.inheritors=La clase sellada debe tener subclases
sealed.type.inheritor.expected.modifiers=Se espera que el modificador sea ''{0}'', ''{1}'' o ''{2}''
sealed.type.inheritor.expected.modifiers2=Los modificadores esperados son: ''{0}'' or ''{1}''
single.import.class.conflict=''{0}'' ya esta definido en una importación de tipo único
statement.must.be.prepended.with.case.label=La sentencia debe estar precedida por una etiqueta de caso
static.interface.method.call.qualifier=El método estático solo puede invocarse en la clase de interfaz contenedor
static.member.accessed.via.instance.reference=Miembro estático ''{0}.{1}'' accedido a través de una referencia de instancia
static.method.cannot.be.annotated.with.override=Un método estático no puede ser anotado con @Override
static.method.cannot.override.instance.method=El método estático ''{0}'' en ''{1}'' no puede sobreescribir el método de instancia ''{2}'' en ''{3}''
static.method.referenced.through.non.static.qualifier.method.reference.context=Método estático referenciado a través de un calificador no estático
static.method.referenced.through.receiver.method.reference.context=Método estático referenciado a través de método de receptor
static.methods.in.interfaces.should.have.body=Los métodos estáticos de las interfaces deberían tener un cuerpo
suspicious.name.assignment=''{0}'' probablemente no debería asignarse a ''{1}''
suspicious.name.parameter=''{0}'' probablemente no debería pasar como parámetro ''{1}''
suspicious.name.return=''{0}'' probablemente no debio ser retornado desde el metodo ''{1}''
switch.class.or.array.type.expected=clase o matriz
switch.constant.expression.required=Expresión constante, patrón o null es obligatorio
switch.dominance.of.preceding.label=Etiqueta está dominada por una etiqueta de caso precedente ''{0}''
switch.expr.empty='expresión switch' no tiene cláusulas case
switch.expr.incomplete='switch', la expresión no cubre todos los valores de entrada posibles
switch.expr.no.result=La expresión switch no tiene expresiones de resultado
switch.expr.rule.should.produce.result=La regla de expresión switch debe producir un resultado en todas las rutas de ejecución
switch.expr.should.produce.result=La expresión switch debe producir un resultado en todas las rutas de ejecución
switch.expression.cannot.be.void=El tipo de destino para la expresión del switch no puede ser void
switch.illegal.fall.through.from=Caída ilegal desde un patrón
switch.illegal.fall.through.to=Caída ilegal a un patrón
switch.invalid.selector.types=El tipo de selector de ''{0}'' no es compatible
switch.pattern.expected=El selector de switch ''{0}'' debe tener un patrón
switch.statement.empty='Sentencia' switch no tiene ninguna cláusula case
switch.statement.incomplete='switch' no cubre todos los posibles valores de entrada
switch.unconditional.boolean.and.default.exist=El 'switch' tiene todos sus booleanos y label por defecto
switch.unconditional.boolean.and.unconditional.exist='switch' tiene todos los booleanos y un patrón incondicional
switch.unconditional.pattern.and.default.exist=el 'switch' tiene ambos un patrón incondicional y una etiqueta predeterminada
target.method.is.generic=Método objetivo es genérico
target.type.of.a.lambda.conversion.must.be.an.interface=El tipo destino de una conversión lambda debe ser una interfaz
text.block.new.line=Inicio de bloque de texto no válido: falta la nueva línea después de las comillas de apertura
text.block.unclosed=Bloque de texto sin cerrar
text.class.cannot.access=No se puede acceder a {0}
text.class.inherits.abstract.and.default={0} hereda abstracta y predeterminada para {1} de los tipos {2} y {3}
text.class.inherits.unrelated.defaults={0} hereda valores predeterminados no relacionados a {1} de los tipos {2}
text.class.is.not.accessible={0} no es accesible en el contexto actual
text.improper.formed.type=Tipo mal formado; faltan algunos parámetros de tipo
too.many.array.dimensions=Demasiadas dimensiones del array
too.many.characters.in.character.literal=Demasiados caracteres en el literal de carácter
two.methods.are.inherited.with.same.signature=Los métodos {0} de {1} y {2} de {3} se heredan con la misma firma
type.parameter.cannot.be.followed.by.other.bounds=El parámetro de tipo no puede ir seguido de otros límites
type.parameter.has.incompatible.upper.bounds=El parámetro de tipo {0} tiene límites superiores incompatibles: {1}
type.parameter.is.not.used=El parámetro de tipo ''{0}'' no se ha utilizado nunca
type.pattern.expected=Se necesita patrón de tipo
unary.operator.not.applicable=El operador ''{0}'' no se puede aplicar a ''{1}''
unchecked.overriding.incompatible.return.type=Anulación sin verificar: el tipo de retorno requiere conversión no verificada. Encontrado: ''{0}'', requerido: ''{1}''
unclosed.char.literal=Literal de carácter sin cerrar
unclosed.comment=Comentario no cerrado
underscore.identifier.error=A partir de Java 9, '_' es una palabra clave, y no puede usarse como identificador
underscore.identifier.error.unnamed=No se puede usar '_' como referencia
underscore.identifier.warn=El uso de _ como identificador no se admite en las versiones posteriores a Java 9
underscore.lambda.identifier=No se permite el uso de _ como nombre de parámetro lambda
unexpected.token=Token inesperado
unexpected.type=Tipo inesperado. Encontrado: ''{1}'', requerido: ''{0}''
unexpected.type.class.expected=Tipo inesperado: se esperaba una clase
unhandled.close.exceptions=Excepciones no manejadas {1, choice, 0#|1#|2#}: {0} de {2}
unhandled.exceptions=Excepciones no manejadas: {1, choice, 0#excepción|2#excepciones}: {0}
unknown.class=Clase desconocida: ''{0}''
unqualified.super.disallowed=Las referencias super no calificadas no se permiten en métodos de extensión
unreachable.statement=Sentencia inalcanzable
unreachable.statement.false.condition=El cuerpo del bucle es inalcanzable porque la condición del bucle siempre es falsa
unrelated.overriding.methods.return.types=Los métodos tienen tipos de retorno no relacionados
unresolved.label=Etiqueta no definida: ''{0}''
unsafe.cast.in.instanceof=''{0}'' no se puede convertir de forma segura a ''{1}''
valid.switch.1_7.selector.types=char, byte, short, int, Character, Byte, Short, Integer, String o enum
valid.switch.selector.types=byte, char, short o int
vararg.cstyle.array.declaration=No está permitida la declaración de matriz de estilo C dentro de argumentos varargs
vararg.not.last.parameter=El parámetro vararg debe ser el último de la lista
variable.already.assigned=La variable ''{0}'' puede haber sido ya asignada a
variable.already.defined=La variable ''{0}'' ya está definida en el ámbito
variable.assigned.in.loop=La variable ''{0}'' podría estar asignada en un bucle
variable.expected=Se esperaba una variable
variable.must.be.final=Variable ''{0}'' se accede desde de una clase interna, necesita ser declarada como final
variable.must.be.final.or.effectively.final=La variable ''{0}'' se accede desde la clase interna, necesita ser final o efectivamente final
variable.not.initialized=La variable ''{0}'' podría no estar inicializada
visibility.access.problem=No se puede acceder a ''{0}'' en ''{1}''
visibility.module.access.problem=El acceso a ''{0}'' en ''{1}'' está restringido por {2}
void.type.is.not.allowed=El tipo 'void' no está permitido aquí
weaker.privileges={0}; se intenta asignar privilegios de acceso más débiles ('{1}'); eran '{2}'
when.expression.is.false=Cuando la expresión es falsa este case tiene un guard que es una expresión constante con el valor 'false'
wildcard.type.cannot.be.instantiated=El tipo comodín ''{0}'' no se puede instanciar directamente
wrong.constructor.arguments=''{0}'' no se puede aplicar a ''{1}''
wrong.method.arguments=''{1}'' en ''{0}'' no se puede aplicar a ''{2}''
yield.unexpected=Expresión yield fuera del switch
yield.unqualified.method.warn=Llamada no calificada al método 'yield' no es compatible con las versiones desde Java 14
yield.void=El tipo de expresión no debe ser "void"