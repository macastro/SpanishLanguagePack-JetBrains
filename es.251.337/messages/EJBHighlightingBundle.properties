class.both.ejb.and.interceptor=La clase ''{0}'' no debe definirse simultáneamente como una clase EJB y una clase de interceptación
class.is.not.RMI.IIOP.compatible=La clase ''{0}'' no es compatible con RMI/IIOP
class.should.be.both.abstract.and.not.abstract=la clase ''{0}'' debería ser abstracta y no abstracta, el conflicto de EJB da como resultado que no sea abstracta
class.should.extend=La clase '{0}' debe extender '{1}'
class.should.implement=La clase ''{0}'' debe implementar ''{1}''
class.should.not.extend=La clase ''{0}'' no debe extender ''{1}''
class.should.not.implement=la clase ''{0}'' no debe implementar ''{1}''
cmp.field.getter.is.not.defined=CMP campo ''{0}'' getter no definido
cmp.field.setter.is.not.defined=El setter del campo CMP ''{0}'' no está definido
cmp1.entity.beans.not.authorized.to.define.method=Los Enterprise Bean CMP 1.1 no están autorizados a definir el método ''{0}''
cmr.field.getter.is.not.defined=El getter del campo CMR ''{0}'' no está definido
cmr.field.setter.is.not.defined=El setter de campo CMR ''{0}'' no está definido
cmr.field.setter.should.have.parameter=El setter del campo CMR debe tener un parámetro de tipo "{0}"
ejb.class.should.implement.interface.methods=La clase EJB ''{0}'' debe implementar los métodos de la interfaz ''{1}''
ejb.class.should.not.be.exposed=La clase EJB ''{0}'' no debe exponerse mediante la interfaz ''{1}''
ejb.class.should.not.define.method=La clase EJB no debe definir el método ''{0}''
ejb.enterprise.java.beans=EJB: Enterprise Java Beans
ejb.field.popup.tooltip.navigate.to.field.declaration=Navegar a la declaración del campo en XML
ejb.interfaces.should.not.be.exposed=La interfaz EJB ''{0}'' no debe estar expuesta por la interfaz de punto final del servicio ''{1}''
ejb.label.name=<nombre-ejb>:(&N)
ejb.library.not.linked=La clase {0} no está disponible. No es posible desarrollar EJB.
ejb.local.interfaces.should.not.be.exposed=La interfaz local de EJB ''{0}'' no debe exponerse a través de la interfaz ''{1}''
ejb.reference.bad.beanname=EJB ''{0}'' es referenciado por ''{1}''
ejb.reference.beaninterface.parameter.should.be.specified=Referencia EJB ambigua, se debe especificar 'beanName' o 'beanInterface' más preciso
ejb.reference.ejb.interface.not.found=El EJB ''{0}'' no tiene una interfaz ''{1}''
ejb.reference.no.interface.view.wrong.type=La vista sin interfaz solo puede usarse para beans de sesión
ejb.reference.no.interface.view.wrong.version={0} versiones no pueden usar vista sin interfaz
ejb.reference.not.found=No se encontró el EJB ''{0}'' que contiene la interfaz de componentes ''{1}''
ejb.references.popup.title.choose.ejb.class=Seleccionar clase EJB
ejb.references.popup.title.choose.query=Seleccionar consulta
ejb.references.popup.title.choose.resource=Seleccionar recurso
error.message.cmp.field.lowercase=En los beans de entidad CMP 2.x, el nombre de los campos CMP debe comenzar con una minúscula
error.message.cmr.field.lowercase=Los nombres de campo CMR deben comenzar con minúsculas
error.text.duplicate.query.method=El método de consulta ya está definido
error.text.ejb.does.not.have.component.interface=El EJB ''{0}'' no tiene interfaz de componente ''{1}''
error.text.no.cmp.fields.for.bmp.bean=El Bean BMP no debería contener campos CMP
error.text.no.cmp.version.for.bmp.bean=El Bean BMP no debe contener una versión CMP
error.text.no.primkey.for.bmp.bean=Se debe definir una clase de clave primaria para el bean BMP
error.text.no.primkeyfield.defined=Debe definir el campo de clave primaria
error.text.no.primkeyfield.or.primkeyclass.defined=El CMP debe definir un campo de clave principal o una clase de clave principal
error.text.primary.key.field.type.should.be.equal.to.primary.key.class=El tipo de campo de la clave primaria debe ser igual al de la clase clave primaria
field.should.have.modifier=''{0}'' el campo debe tener modificador {1}
field.should.not.have.modifier=El campo ''{0}'' no debería ser {1}
finder.recursive.panel.unknown=<Desconocido>
home.interface.should.define.create.method=La interfaz ''{0}'' debe definir al menos un método create.
home.interface.should.define.findbyprimarykey.method=La interfaz ''{0}'' debe definir exactamente un método ''findByPrimaryKey''.
injected.property.invalid.type=Tipo de recurso inyectado ''{0}'' inválido
injected.property.method.should.be.setter=La inyección de destino ''{0}'' debe ser una variable o un método setter
inspection.name.ejb.class=Inspección básica de clase EJB
inspection.name.ejb.class.entity=Inspección de clase EJB entidad
inspection.name.ejb.class.warnings=Advertencias EJB Class
inspection.name.entity.home.interface=Inspecciones de interfaces de inicio de la entidad
inspection.name.entity.interface=Inspección de interfaz EJB entidad
inspection.name.environment.problems=Inspección de entorno EJB
inspection.name.interceptor=Inspección de interceptores EJB
inspection.name.interceptor.warnings=Inspección de nombre de métodos de interceptores
inspection.name.interface.method.signature=Inspección de firma método interfaz EJB
inspection.name.interface.signature=Inspección de firma de interfaz EJB
inspection.name.prohibited.package.usage=Inspección de uso de paquete prohibido
inspection.name.remote.requirements=Inspección de requisiciones de distribución RMI
inspection.name.session.home.interface=inspección de interfaz de sesión de inicio
inspection.name.static.access=Inspección de acceso estático
inspection.name.this.reference='this' Inspección de uso de 'this'
intention.family.ejb.reference.type.fix=Reparar la interfaz de referencia EJB
intention.family.ejb.reference.type.fix.0=Crear clase de referencia EJB ''{0}''
intention.family.generate.interceptor.methods=Generar métodos interceptores
intention.family.remove.dependency.injection.settings=Quitar configuración de inyección de dependencias
intention.family.remove.interceptor.method.metadata=Quitar configuración del método interceptor
interceptor.class.has.no.annotated.methods=La clase ''{0}'' no tiene metodos anotados
interceptor.method.name.should.be.standard=''{0}'' el método del interceptor debería llamarse ''{1}''
interface.should.extend=La interfaz '{0}' debe extender '{1}'
interface.should.not.extend=La interfaz ''{0}'' no debería extender a ''{1}''
method.name.conflict=El método ''{0}'' no debe entrar en conflicto con el nombre definido en la arquitectura EJB
method.parameter.of.type.expected=El método "{0}" sólo debería aquí aceptar como parámetro tipos "{1}"
method.should.be.both.abstract.and.not.abstract=El método ''{0}'' debería ser abstracto y no abstracto, la EJB en conflicto lo vuelve no abstracto
method.should.have.modifier=El método ''{0}'' debería ser {1}
method.should.not.be.final.or.static=El método no debe ser final o estático
method.should.not.have.modifier=El método ''{0}'' no debe tener el modificador {1}
method.should.not.throw=Método ''{0}'' no debe arrojar ''{1}''
method.should.return=El método ''{0}'' debe devolver {1}
method.should.return.one.of=el método ''{0}'' debe devolver uno de {1}
method.should.throw=El método ''{0}'' debe arrojar ''{1}''
method.too.many.parameters=El método ''{0}'' debe recibir solo {1} argumentos
more.than.one.dependency.injection.configured.for.field=Se han configurado varias inyecciones de dependencia para el campo ''{0}''
more.than.one.dependency.injection.configured.for.method=Para el método ''{0}'' se ha configurado más de una inyección de dependencia
more.than.one.method.defined.for.interceptor.method.type=''{0}''=Se ha definido más de un método interceptor para el tipo de método ''{1}'' en la clase ''{2}''
prohibited.package.usage=El paquete ''{0}'' está prohibido en EJB
prohibited.static.field.access=El EJB no puede escribir en el campo estático '{0}'
public.no.args.constructor.required=La clase EJB debe proporcionar un constructor público sin argumentos
service.endpoint.interface.cannot.have.fields=La interfaz de punto final del servicio EJB no puede tener declaraciones de constantes
session.home.should.not.define.finder.methods=La interfaz principal del bean de sesión no debe utilizar ningún método de búsqueda
several.ranged.variable.declarations.are.not.supported=No se admiten varias declaraciones de variables con rangos. Utilice en su lugar declaraciones de miembros de recopilación (por ejemplo, 'IN(o.lineItems) l').
stateless.session.bean.class.should.define.exactly.one.ejbcreate.method=La clase de bean de sesión sin estado debe definir exactamente un método ejbCreate()
stateless.session.bean.home.interface.should.define.exactly.one.create.method=La interfaz principal del Bean de sesión sin estado debe definir solo un método create()
static.fields.only.recommended=Se recomienda utilizar solo campos estáticos finales
text.queries=Consultas
text.references=Referencias
text.remove.0=Eliminar ''{0}''
there.should.be.no.method.params.for.*.method=* El método no debería tener {0}
this.escaped.passed=Los EJB no deberían pasar 'this' como argumento de método
this.escaped.returned=EJB no debe pasar 'this' como resultado del método
warning.text.abstract.schema.name.should.not.be.empty=El nombre del esquema abstracto no debe estar vacío
warning.text.cmp.field.list.for.cmp.bean.should.not.be.empty=La lista del campo CMP para el CMP bean EJB no debería estar vacía
warning.text.primary.key.class.is.not.rmi.iiop.compatible=La clase de clave primaria no es compatible con RMI/IIOP