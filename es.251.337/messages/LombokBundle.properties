action.defaultLombokData.description=Acción para reemplazar métodos getter/setter/equals/hashcode/toString con la anotación @Data de Lombok
action.defaultLombokData.text=Defecto @Data
action.defaultLombokEqualsAndHashcode.description=Acción para reemplazar los métodos equals y hashcode con la anotación @EqualsAndHashcode de Lombok
action.defaultLombokEqualsAndHashcode.text=Default @EqualsAndHashcode
action.defaultLombokGetter.description=Acción para reemplazar todos los métodos getter con la anotación @Getter de lombok
action.defaultLombokGetter.text=Getter @Predeterminado
action.defaultLombokLogger.description=Acción para reemplazar el registrador con la anotación @Log de Lombok
action.defaultLombokLogger.text=@Log (y amigos)
action.defaultLombokSetter.description=Acción para reemplazar todos los métodos getter con anotación @Getter de lombok
action.defaultLombokSetter.text=@Setter predeterminado
action.defaultLombokToString.description=Acción para reemplazar el método toString con la anotación @ToString de Lombok
action.defaultLombokToString.text=Valor @ToString predeterminado
action.delombokAny.description=Acción para reemplazar cualquier anotación de Lombok con métodos Java convencionales
action.delombokAny.text=Todas las anotaciones de Lombok
action.delombokBuilder.description=Acción para reemplazar la anotación @Builder de lombok con métodos java vanilla
action.delombokBuilder.text=@Builder
action.delombokConstructor.description=Acción para reemplazar anotaciones @NoArgsConstructor, @RequiredArgsConstructor y @AllArgsConstructor de Lombok por métodos Java básicos
action.delombokConstructor.text=@Constructores
action.delombokData.description=Acción para reemplazar la anotación de lombok @Data con métodos java sin formato
action.delombokData.text=@Data
action.delombokDelegate.description=Acción para reemplazar la anotación @Delegate de Lombok con métodos Java sin procesar
action.delombokDelegate.text=@Delegado
action.delombokEqualsAndHashCode.description=Acción para reemplazar la anotación @EqualsAndHashCode de lombok con métodos Java vainilla
action.delombokEqualsAndHashCode.text=@EqualsAndHashCode
action.delombokFieldNameCostants.description=Acción para reemplazar la anotación @FieldNameConstants de lombok con campos java vanilla
action.delombokFieldNameCostants.text=@ConstantesNombreCampo
action.delombokGetter.description=Acción para reemplazar la anotación @Getter de Lombok con métodos getter vanilla
action.delombokGetter.text=@Getter
action.delombokLogger.description=Acción para reemplazar la anotación @Log (y otras) de Lombok con un campo de registro genérico
action.delombokLogger.text=@Log (y amigos)
action.delombokSetter.description=Acción para reemplazar la anotación @Setter de Lombok con métodos setter estándar
action.delombokSetter.text=@Setter
action.delombokStandardException.description=Acción para reemplazar la anotación @StandardException de Lombok con métodos de Java propiamente dichos
action.delombokStandardException.text=@StandardException
action.delombokSuperBuilder.description=Acción para reemplazar la anotación @SuperBuilder de Lombok con métodos Java estándar
action.delombokSuperBuilder.text=@SuperBuilder
action.delombokToString.description=Acción para reemplazar la anotación de lombok @ToString con métodos de Java puros
action.delombokToString.text=@ToString
action.delombokUtilityClass.description=Acción para reemplazar la anotación @UtilityClass de lombok con campos Java tradicionales
action.delombokUtilityClass.text=@ClaseUtilidad
action.delombokValue.description=Acción para reemplazar el Lombok @Value anotación con métodos Java vainilla
action.delombokValue.text=@Valor
action.delombokWither.description=Acción que reemplaza la anotación lombok @Wither con métodos java vainilla
action.delombokWither.text=@Wither
checkbox.settings.jps.fix=Añadir automáticamente la opción de compilación '-Djps.track.ap.dependencies=false' para versiones de lombok antiguas (lt;1.18.16)
checkbox.settings.version.warning=Habilitar la advertencia de la versión de Lombok para versiones de Lombok antiguas
color.settings.clear=Limpiar
color.settings.comment=Comentario
color.settings.key=Clave
color.settings.separator=Separador
color.settings.value=Valor
config.warn.annotation-processing.disabled.title=Lombok requiere procesamiento de anotaciones habilitado
config.warn.dependency.outdated.message=<br>El proyecto "{0}" parece tener una dependencia Lombok obsoleta.<br>La versión configurada es "{1}", pero ya se ha publicado al menos la versión "{2}"<br><a href="https://projectlombok.org/download">¿Quizás quieras actualizarla?</a> <br>
config.warn.dependency.outdated.title=Dependencia Lombok posiblemente obsoleta
configurable.name.lombok.config=Configuración de Lombok
dialog.message.logger.field.s.not.private.sfinal.field.named.s.refactor.anyway=Campo logger: "{0}" no es un campo {1, choice, 0#|1# static} final privado nombrado "{2}". ¿Refactorizar de todas formas?
dialog.message.this.element.cannot.be.renamed=No se puede renombrar este elemento.
dialog.title.attention=¡Atención!
filetype.lombok.config.description=Archivo de configuración Lombok
group.DelombokActionGroup.description=Refactorizar el código eliminando las anotaciones de Lombok
group.DelombokActionGroup.text=Delombok
group.LombokActionGroup.description=Refactoriza el código con anotaciones lombok
group.LombokActionGroup.text=Lombok
inspection.builder.static.import.name=Usar importación estática para métodos generados por Lombok
inspection.deprecated.lombok.display.name=Anotaciones Lombok en desuso
inspection.lombok.display.name=Anotaciones Lombok
inspection.lombok.getter.may.be.used.display.class.message=La clase ''{0}'' puede usar Lombok @Getter
inspection.lombok.getter.may.be.used.display.field.message=El campo ''{0}'' puede tener Lombok @Getter
inspection.lombok.getter.may.be.used.display.fix.family.name=Reemplazar el método getter explícito con Lombok @Getter
inspection.lombok.getter.may.be.used.display.fix.name=Se puede usar Lombok @Getter para ''{0}''
inspection.lombok.getter.may.be.used.display.name=Se puede usar Lombok @Getter
inspection.lombok.group.name.lombok=Lombok
inspection.lombok.group.name.redundant.definitions=Definiciones redundantes
inspection.lombok.group.name.redundant.modifiers=Modificadores redundantes
inspection.lombok.setter.may.be.used.display.class.message=La clase ''{0}'' puede usar Lombok @Setter
inspection.lombok.setter.may.be.used.display.field.message=El campo ''{0}'' puede tener Lombok @Setter
inspection.lombok.setter.may.be.used.display.fix.family.name=Reemplaza el método setter explícito con Lombok @Setter
inspection.lombok.setter.may.be.used.display.fix.name=Utilizar lombok @Setter para ''{0}''
inspection.lombok.setter.may.be.used.display.name=Se puede utilizar el Lombok @Setter
inspection.message.annotation.copy.duplicate=La anotación ''{0}'' ya está presente en el campo y se duplicará mediante la configuración onX
inspection.message.annotation.not.lombok.copyable=Lombok no copia la anotación ''{0}'' en el constructor
inspection.message.annotation.only.supported.on.class.or.enum.type={0} es sólo soportado en una clase o un enum.
inspection.message.builder.can.be.used.only=@Builder solo se admite en clases, registros, constructores y métodos.
inspection.message.builder.default.requires.builder.annotation=@Builder.Default requiere @Builder o @SuperBuilder en la clase para que tenga sentido.
inspection.message.builder.default.requires.initializing.expression=@Builder.Default requiere una expresión de inicialización (' = algo;').
inspection.message.builder.default.singular.cannot.be.mixed=@Builder.Default y @Singular no pueden mezclarse.
inspection.message.can.t.singularize.this.name=No se puede singularizar este nombre: ''{0}''; especifique la forma singular explícitamente (ej. @Singular("sheep"))
inspection.message.cleanup.legal.only.on.local.variable.declaration.inside.block=@Cleanup: es legal sólo en declaración de variable local dentro de un bloque
inspection.message.cleanup.legal.only.on.local.variable.declarations=@Cleanup sólo es legal en las declaraciones de variables locales
inspection.message.cleanup.method.s.not.found.on.target.class=@Cleanup: no se encontró el método ''{0}()'' en la clase de destino
inspection.message.cleanup.value.cannot.be.empty.string=@Limpieza: el valor no puede ser una cadena vacía
inspection.message.cleanup.variable.declarations.need.to.be.initialized=@Limpiar declaraciones de variables necesitan ser inicializadas.
inspection.message.constructor.noargs.needs.to.be.forced=La clase contiene campos obligatorios, debes forzar NoArgsConstructor.
inspection.message.constructor.with.d.parameters.already.defined=El constructor con ''{0}'' parámetros ya está definido
inspection.message.constructor.without.parameters.already.defined=El constructor sin parámetros ya está definido
inspection.message.custom.log.does.not.allow.topic=@CustomLog no permite un tópico.
inspection.message.custom.log.not.configured.correctly=El @CustomLog no está configurado correctamente; establezca log.custom.declaration en lombok.config.
inspection.message.custom.log.requires.topic=@CustomLog requiere un topic.
inspection.message.data.only.supported.on.class.type=@Data solo se admite en un tipo de clase
inspection.message.default.constructor.doesn.t.exist=El constructor por defecto no existe
inspection.message.delegate.can.only.use.concrete.class.types=@Delegate solo puede tipos de clase concretos, no comodines, arrays, variables tipos o primitivos. ''{0}'' es tipo de clase erroneo
inspection.message.delegate.does.not.support.recursion.delegating=Delegate no soporta recursión (delegando en un tipo que a su vez tiene @Delegate miembros). El miembro ''{0}'' es @Delegate en el tipo ''{1}''
inspection.message.delegate.legal.only.on.instance.fields=@Delegate es legal solo en campos de instancia o métodos de instancia sin argumentos.
inspection.message.delegate.legal.only.on.no.argument.methods=@Delegate es legal solo en métodos sin argumentos.
inspection.message.delegate.unknown.type.method=No se encuentra el método ''{0}''
inspection.message.equals.and.hashcode.only.supported.on.class.type=@EqualsAndHashCode solo está implementado para tipos de clase
inspection.message.exclude.are.mutually.exclusive.exclude.parameter.will.be.ignored=Los parámetros 'exclude' y 'of' son mutuamente excluyentes; el parámetro 'exclude' será ignorado
inspection.message.existing.builder.must.be.abstract.static.inner.class=El Builder existente debe ser una clase interna estática abstracta.
inspection.message.field.name.constants.inner.type=@FieldNameConstants El tipo interno ya existe pero asEnum={0} no coincide con el tipo existente
inspection.message.field.name.constants.only.supported.on.class.enum.or.field.type=@FieldNameConstants solo se admite en un tipo de clase, enumeración, registro o campo
inspection.message.field.name.constants.only.supported.on.class.or.enum=@FieldNameConstants solo está soportado en una clase, una enumeración o un registro.
inspection.message.field.s.does.not.exist=El campo ''{0}'' no existe.
inspection.message.field.s.does.not.exist.exclude=El campo ''{0}'' no existe
inspection.message.field.s.does.not.exist.field=El campo ''{0}'' no existe
inspection.message.field.s.would.have.been.excluded.anyway=El campo ''{0}'' se habría excluido de todos modos
inspection.message.generating.equals.hashcode.implementation=Generando implementación equals/hashCode sin que se llame a la superclase, incluso aunque esta clase no extienda java.lang.Object. Si es intencional, añade '(callSuper=false)' a tu tipo.
inspection.message.generating.equals.hashcode.with.super.call=Generar equals/hashCode con una superllamada a java.lang.Object es inútil.
inspection.message.getter.only.supported.on.class.enum.or.field.type=@Getter sólo se soporta en un tipo clase, enum o campo
inspection.message.jacksonized.builder.on.abstract.classes=Los constructores en clases abstractas no pueden ser @Jacksonized (el constructor nunca se utilizaría).
inspection.message.jacksonized.cannot.process.both.builder.superbuilder=@Jacksonized no puede procesar @Builder y @SuperBuilder en la misma clase.
inspection.message.jacksonized.jsondeserialize.already.exists=@JsonDeserialize ya existe en la clase. Eliminar @JsonDeserialize o eliminar @Jacksonized y configurar manualmente Jackson.
inspection.message.jacksonized.requires.builder.superbuilder=@Jacksonized requiere @Builder o @SuperBuilder para que tenga sentido.
inspection.message.lazy.does.not.work.with.access.level.none='lazy' no funciona con AccessLevel.NONE.
inspection.message.lazy.not.supported.for.getter.on.type='lazy' no es compatible con @Getter en una variable de tipo
inspection.message.lazy.requires.field.initialization='lazy' requiere la inicialización del campo.
inspection.message.lazy.requires.field.to.be.private.final='lazy' requiere que el campo sea private y final
inspection.message.lombok.annotation.deprecated.not.supported=La anotación ''{0}'' de Lombok está obsoleta y ya no es compatible con el plugin de Lombok. Utilice ''{1}'' en su lugar.
inspection.message.lombok.annotations.are.not.allowed.on.builder.class=Las anotaciones de Lombok no están permitidas en la clase de constructor.
inspection.message.lombok.builder.needs.proper.constructor.for.this.class=Lombok @Builder necesita un constructor apropiado para esta clase
inspection.message.lombok.does.not.know=Lombok no puede generar métodos builder en singular para el tipo ''{0}''
inspection.message.lombok.needs.default.constructor.in.base.class=Lombok necesita un constructor por defecto en la clase base
inspection.message.method.s.matched.static.constructor.name.already.defined=El método ''{0}'' que coincide con staticConstructorName ya se ha definido
inspection.message.method.s.with.d.parameters.matched.static.constructor.name.already.defined=El método ''{0}'' con ''{1}'' parámetros que coinciden con staticConstructorName ya está definido
inspection.message.not.allowed.in.old.style.for.loops=''{0}'' no está permitido en los bucles for de estilo antiguo
inspection.message.not.allowed.with.lambda.expressions=''{0}'' no está permitido para expresiones lambda.
inspection.message.not.compatible.with.array.initializer.expressions=''{0}'' no es compatible con las expresiones de inicialización de arreglos. Usar el formato completo (nuevo int[] ''{'' ... ''}'' en vez de solo ''{'' ... ''}'')
inspection.message.not.generated.s.method.with.same.name.already.exists=No generado ''{0}()'': Ya existe un método con el mismo nombre
inspection.message.not.generated.s.method.with.similar.name.s.already.exists=No generado ''{0}()'': Ya existe un método con nombre similar ''{0}''
inspection.message.not.generating.constant=No se genera constante para este campo: El nombre de la constante sería igual al nombre del campo.
inspection.message.not.generating.equals.hashcode=No generando equals ni hashCode: Ya existe un método con uno de esos nombres (o se generarán ambos métodos o ninguno).
inspection.message.not.generating.field.s.field.with.same.name.already.exists=No generando el campo ''{0}'': Ya existe un campo con el mismo nombre
inspection.message.not.generating.getter.for.this.field=No se está generando el getter para este campo: No encaja en tu lista de prefijos @Accessors.
inspection.message.not.generating.s.method.with.that.name.already.exists=No se genera ''{0}()'': Ya existe un método con ese nombre
inspection.message.not.generating.setter.for.this.field.it=No se genera el setter para este campo: No encaja en su lista de prefijos @Accessors.
inspection.message.not.generating.setter.for.this.field.setters=No se genera setter para este campo: no es posible generar setter para campos finales.
inspection.message.not.generating.wither=No se está generando "wither" para este campo: Los "withers" no pueden generarse para los campos estáticos.
inspection.message.not.generating.wither.for.this.field.withers=No se generará wither para este campo: Los withers no se pueden generar para campos que comienzan con $.
inspection.message.not.generating.wither.for.this.field.withers.cannot.be.generated=No se generó wither para este campo: Los withers no se pueden generar para campos finales e inicializados.
inspection.message.obtain.via.is.static.true.not.valid.unless.method.has.been.set=@ObtainVia(isStatic = true) no es válido a menos que se haya establecido 'method'.
inspection.message.on.local.variable.requires.initializer.expression=''{0}'' en una variable local requiere una expresión inicializadora
inspection.message.s.legal.only.on.classes.enums='@{0}' solo es legal en clases y enumeraciones
inspection.message.s.not.valid.identifier=''{0}'' no es un identificador válido
inspection.message.s.only.supported.on.class.or.field.type=''@{0}'' solo está soportado en un tipo de clase o campo
inspection.message.setter.only.supported.on.class.or.field.type=@Setter solo se admite en una clase o tipo de campo
inspection.message.slf4j.logger.defined.explicitly=Slf4j Logger está definido explícitamente. Usa la anotación Lombok @Slf4j en su lugar.
inspection.message.sneakythrows.calls.to.sibling.super.constructors.excluded=Las llamadas a constructores hermanos/superiores siempre se excluyen de @SneakyThrows; @SneakyThrows se ha ignorado porque no hay otro código en este constructor.
inspection.message.standardexception.accesslevel.none.not.valid=Access.NONE no es válido aquí
inspection.message.standardexception.class.only.supported.on.class=@StandardException solo se admite en una clase
inspection.message.standardexception.should.extend.throwable=@StandardException requiere que extiendas un tipo Throwable
inspection.message.superbuilder.can.be.used.on.classes.only=@SuperBuilder solo se puede usar en clases.
inspection.message.superbuilder.can.be.used.on.static.inner.classes.only=@SuperBuilder no se admite en clases anidadas no estáticas.
inspection.message.synchronized.field.is.not.static=El campo ''{0}'' no es estático, y no puede ser usado en este método estático
inspection.message.synchronized.legal.only.on.concrete.methods=@Synchronized es legal solo en métodos concretos.
inspection.message.synchronized.legal.only.on.methods.in.classes.enums=@Synchronized solo es legal para métodos en clases y enumeraciones.
inspection.message.syntax.either.obtain.via.field=La sintaxis es @ObtainVia(field = "fieldName") o @ObtainVia(method = "methodName").
inspection.message.to.string.only.supported.on.class.or.enum.type=@ToString sólo es compatible con un tipo de clase o enum
inspection.message.utility.class.already.marks.class.final=La clase @UtilityClass ya marca la clase como final.
inspection.message.utility.class.already.marks.fields.static=@UtilityClass ya marca campos como estáticos.
inspection.message.utility.class.already.marks.inner.classes.static=@UtilityClass marca las clases internas como estáticas.
inspection.message.utility.class.already.marks.methods.static=@UtilityClass marca los métodos como estáticos.
inspection.message.utility.class.automatically.makes.class.static=@UtilityClass convierte automáticamente la clase en estática, sin embargo, esta clase no puede convertirse en estática.
inspection.message.utility.class.cannot.be.placed=@UtilityClass no puede colocarse en una clase local de método, anónima interna o cualquier clase anidada en tal clase.
inspection.message.utility.class.only.supported.on.class=@UtilityClass sólo admitido en una clase (no puede ser una interfaz, enum o anotación).
inspection.message.utility.classes.cannot.have.declared.constructors=@Clases de Utilidad no pueden tener constructores declarados.
inspection.message.val.already.marks.variables.final='val' ya marca variables final.
inspection.message.val.works.only.on.local.variables='val' funciona únicamente en variables locales o en bucles foreach
inspection.message.value.already.marks.class.final=@Value ya marca la clase como final.
inspection.message.value.already.marks.non.static.fields.final=@Value marca como finales los campos no estáticos.
inspection.message.value.already.marks.non.static.package.local.fields.private=@Value ya marca los campos no estáticos, locales del paquete como privados.
inspection.message.value.only.supported.on.class.type=@Value solo es compatible con un tipo de clase
inspection.message.var.works.only.on.local.variables.on.for.foreach.loops='var' sólo funciona en variables locales y en bucles for/foreach
inspection.message.wither.needs.constructor.for.all.fields.d.parameters=@Wither necesita constructor para todos los campos (''{0}'' parámetros)
inspection.message.wither.only.supported.on.class.or.field=@Wither solo es compatible con una clase o un campo.
inspection.redundant.modifiers.utility.class.lombok.display.name=@UtilidadClass modificadores
inspection.redundant.modifiers.val.lombok.display.name=Final innecesario antes de 'val'
inspection.redundant.modifiers.value.lombok.display.name=Modificadores @Value
inspection.redundant.slf.4.j.definition.display.name=@Slf4j
inspection.springqualifiercopyable.lombok.display.name=@Qualifier no reproducible por Lombok
inspection.static.method.import.error=La importación estática de métodos generados por Lombok no funciona con javac
intention.category.lombok=Java/Lombok
intention.family.name.slf4j.annotation=Reemplazar el campo logger con anotación @Slf4j
intention.name.create.new.field.s=Crear nuevo campo ''{0}''
intention.name.replace.with.lombok=Reemplazar con Lombok
make.abstract.and.static.modifier.quickfix=Convertir ''{0}'' en abstracto y estático
make.abstract.and.static.modifier.quickfix.family.name=Cambiar modificador
notification.enable.annotation.processing=Habilitar procesamiento de anotaciones
notification.group.lombok=Problema de integración de Lombok
plugin.settings.title=Lombok
popup.content.java.annotation.processing.has.been.enabled=El procesamiento de anotaciones de Java se ha habilitado
replace.0.with.explicit.type.lombok=Reemplazar ''{0}'' con tipo explícito (Lombok)
replace.explicit.type.with.0.lombok=Reemplazar tipo explícito con ''{0}'' (Lombok)
replace.synchronized.lombok.intention=Reemplazar por Lombok @Synchronized
replace.with.annotations.lombok=Reemplazar con anotaciones (Lombok)