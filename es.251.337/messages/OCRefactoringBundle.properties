0.was.not.initialized={0} no fue inicializado
button.cancel=&Cancelar
button.extract=Extraer
button.inline=&Inline
button.inline.all.usages.file=Hacer inline &todos los usos{0, choice, 0\# en archivo|1\#}
button.inline.current.usage=Hacer inline uso actual(&U)
button.rename=&Renombrar
button.rename.all=&Renombrar todos los usos
button.rename.code=Renombrar solo usos de &código
button.view.usages=Mo&strar usos
can.t.extract.type.of.0.definition=No se puede extraer el tipo de la definición de {0}
can.t.inline.definition=No se puede hacer inline la definición de {0}
can.t.introduce.parameter.to.a.function.with.default.parameter.values=No se puede introducir parámetro a una función con valores de parámetro por defecto
can.t.refactor.the.compound.initializer=No se puede refactorizar el inicializador compuesto
cannot.determine.type.of.the.selected.expression=No se puede determinar el tipo de la expresión seleccionada
cannot.find.the.method.function=No se puede encontrar el método/función
cannot.inline.constructor.expression=No se puede hacer inline la expresión del constructor
cannot.inline.function.reference.in.non.call.expression=No se puede hacer inline la referencia a función en una expresión que no es llamada
cannot.inline.function.type=No se puede hacer inline el tipo de función
cannot.inline.method.reference.in.property.attribute=No se puede hacer inline la referencia al método en un atributo de propiedad
cannot.inline.method.reference.in.selector.expression=No se puede hacer inline la referencia al método en la expresión '@selector'
cannot.inline.method.reference.in.xml.file=No se puede hacer inline la referencia al método en un archivo XML
cannot.inline.recursive=No se puede hacer inline la llamada recursiva a {0}
cannot.inline.the.macro.inside.another.macro.definition=No se puede hacer inline la macro dentro de otra definición de macro
cannot.inline.usage.in.swift.code=No se puede hacer inline el uso en código Swift
cannot.inline.usages.inside.the.macro.substitutions=No se pueden hacer inline los usos dentro de las sustituciones de macro
cannot.perform.refactoring.selected.expression.has.void.type=No se puede realizar la refactorización porque la expresión seleccionada tiene tipo void.
declaration.must.have.one.declarator.to.introduce.the.type=La declaración debe tener un declarador para introducir el tipo
dialog.message.accessed.for.address={0} es accedido para obtener dirección
dialog.message.accessed.for.writing={0} es accedido para escritura
dialog.message.can.t.copy.to.itself=No se puede copiar ''{0}'' a sí mismo
dialog.message.can.t.move.to.itself=No se puede mover ''{0}'' a sí mismo
dialog.message.can.t.refactor.with.variable.arguments=No se puede refactorizar un {0} con argumentos variables
dialog.message.cannot.extract.there.are.multiple.exit.points.in.selected.code.fragment=No se puede extraer un {0}.\nHay múltiples puntos de salida en el fragmento de código seleccionado.
dialog.message.cannot.find.method.function=No se puede encontrar el método/función
dialog.message.cannot.inline.blocks=No se pueden hacer inline los bloques
dialog.message.cannot.inline.methods.with.return.statements.interrupting.execution.flow=No se pueden hacer inline métodos con sentencias return que interrumpan el flujo de ejecución
dialog.message.cannot.inline.parameters.blocks=No se pueden hacer inline los parámetros de bloques
dialog.message.cannot.inline.parameters.lambdas=No se pueden hacer inline los parámetros de lambdas
dialog.message.cannot.inline.protocol.method=No se puede hacer inline un método de protocolo
dialog.message.cannot.inline.with.empty.body=No se puede hacer inline un {0} con cuerpo vacío
dialog.message.cant.refactor.operators=No se pueden refactorizar operadores de C++
dialog.message.containing.class.invalid=La clase contenedora "{0}" no es válida
dialog.message.containing.class.outside.project=La clase contenedora "{0}" está fuera del proyecto
dialog.message.directory.already.exists.at=Ya existe un directorio en ''{0}''
dialog.message.do.you.want.to.proceed.refactoring=¿Continuar con la refactorización?
dialog.message.do.you.want.to.refactor.base.s=¿Refactorizar el {0} base?
dialog.message.elements.to=elementos para {0}
dialog.message.file.already.exists=El archivo ya existe
dialog.message.file.already.exists.at=Ya existe un archivo en ''{0}''
dialog.message.interface.was.not.implemented=La interfaz {0} no fue implementada
dialog.message.lambdas.cant.extract.dependent.types=No se pueden extraer expresiones con tipos dependientes a parámetro lambda
dialog.message.lambdas.cant.extract.functional.type=No se pueden extraer expresiones de tipo funcional a parámetro lambda
dialog.message.lambdas.cant.extract.initializer.list=No se puede extraer lista de inicializadores a parámetro lambda
dialog.message.lambdas.not.supported=Los lambdas no están soportados por el estándar actual del lenguaje
dialog.message.must.have.initializer={0} debe tener un inicializador
dialog.message.name.invalid=El nombre de {0} no es válido
dialog.message.no.inheritors.are.selected=No se han seleccionado herederos
dialog.message.no.selector.parts.for=No hay partes de selector para {0}
dialog.message.overrides.in.choice.which.out.project={0} sobrescribe {1} en {2}{3, choice, 0\# que está fuera del proyecto|1\#}.
dialog.message.paramer.default.value.invalid=''{0}'' no es una expresión
dialog.message.parameter.name.invalid=El nombre del parámetro ''{0}'' no es válido
dialog.message.return.type.invalid=El tipo de retorno de {0} no es válido
dialog.message.selected.statements.should.be.inside.function.choice.or.method=Las sentencias seleccionadas deben estar dentro de una función{0, choice, 0\# o método|1\#}
dialog.message.selector.part.invalid=La parte del selector ''{0}'' no es válida
dialog.message.several.call.sites.with.different.parameter.initializers=Hay varios puntos de llamada con diferentes inicializadores de parámetros
dialog.message.there.are.no.calls.in.project=No hay llamadas a {0} en el proyecto
dialog.message.there.are.no.usages=No hay usos de {0}
dialog.message.variable.must.be.const=La variable "{0}" debe ser constante
dialog.title.choose.containing.class=Elegir Clase Contenedora
dialog.title.extract.block.parameter=Extraer Parámetro de Bloque
dialog.title.extract.function=Extraer Función
dialog.title.extract.lambda.parameter=Extraer Parámetro Lambda
dialog.title.extract.method=Extraer Método
dialog.title.inline=Hacer inline {0}
element.has.inheritor={0} tiene {1, choice, 0\#métodos|1\#funciones} herederos
element.inherits.method={0} hereda un método de {1}
element.is.accessed.for.writing={0} es accedido para escritura
element.is.written.in.the.block={0} está escrito en el bloque
escalate.visibility.current.visibility.column=Visibilidad actual
escalate.visibility.member.column=Miembro
escalate.visibility.required.visibility.column=Visibilidad requerida
extract.dialog.button.extract=Ext&raer
extract.invalid.name.for.class.type.error=El nombre del {0} no es válido
file.0.already.exists.in.the.project=El archivo ''{0}'' ya existe en el proyecto
label.declaration.place=Lugar de declaración\:
message.never.used={0} nunca se usa
namespace.qualifier.should.be.resolved.to.the.class=El calificador de namespace debe resolverse a la clase
progress.title.inplace.rename.appending.additional.elements=Agregando elementos adicionales
progress.title.inplace.rename.preparing=Preparando renombrado
property.inplace.introducer.label.semantics=Semántica
push.down.inheritor.column=Heredero
question.inline.usage=¿Hacer inline {0} uso{1, choice, 0\#|1\#s} de {2}?
refactoring.change.signature.target.symbols.panel=Objetivos\:
refactoring.extract.category.title=Extraer Categoría
refactoring.extract.subclass.title=Extraer Subclase
refactoring.extract.super.protocol.title=Extraer Super Protocolo
refactoring.introduce.block.expression.represent.error=El bloque seleccionado debe representar {0}
refactoring.introduce.constant.auto.declaration=Declarar auto(&A)
refactoring.introduce.constant.constexpr.declaration=Declarar constexpr(&C)
refactoring.introduce.constant.name=Introducir Constante
refactoring.introduce.constant.static.declaration=Declarar static(&S)
refactoring.introduce.define.name=Introducir Define
refactoring.introduce.expressions.choose.dialog.title=Expresiones
refactoring.introduce.instance.variable.name=Introducir Variable de Instancia
refactoring.introduce.ivar.name=Introducir Ivar
refactoring.introduce.parameter.name=Introducir Parámetro
refactoring.introduce.property.name=Introducir Propiedad
refactoring.introduce.put.to.header=Poner en header(&H)
refactoring.introduce.typedef.name=Introducir Typedef
refactoring.introduce.variable.name=Introducir Variable
refactoring.introducer.declare.auto=Declarar auto(&A)
refactoring.introducer.declare.const=Declarar const(&C)
refactoring.ivar.inplace.introducer.declare.interface=Declarar en la interfaz(&I)
refactoring.ivar.inplace.introducer.generate.property=Generar propiedad(&P)
refactoring.move.cant.find.symbol=No se puede encontrar el símbolo para la clase seleccionada
refactoring.move.caret.position=El cursor debe estar posicionado dentro de una clase
refactoring.move.escalate.visibility.declare.in.interface=declarar en la interfaz
refactoring.move.file.has.no.members=El archivo "{0}" no tiene miembros para mover
refactoring.move.members.error.class.name.invalid=El nombre de la clase no es válido
refactoring.move.members.error.no.target.class.selected=No se ha seleccionado una clase destino
refactoring.move.members.error.not.in.project.sources={0} no está ubicado dentro del proyecto
refactoring.move.members.error.the.same.source.and.target=Las clases origen y destino deben ser diferentes
refactoring.move.members.message.target.does.not.exist=La clase destino "{0}" aún no existe.
refactoring.move.members.ok.button.text=Mover(&M)
refactoring.move.namespace.has.no.members=El namespace "{0}" no tiene miembros para mover
refactoring.move.no.members.are.selected.error=No hay miembros seleccionados
refactoring.move.pull.up.ok.button.text=Pull(&U)
refactoring.move.push.down.ok.button.text=Imp&ulsar
refactoring.parameter.introducer.refactor.super.method=Refactorizar super {0}(&S)
refactoring.property.introducer.generate.instance.variable=Generar variable de instancia(&I)
refactoring.property.introducer.generate.synthesize=Generar @synthesize(&S)
refactoring.property.introducer.make.readonly=Hacer readonly(&R)
refactoring.property.introducer.put.to.private.category=Poner en categoría privada(&P)
refactoring.rename=Renombrar {0}(&R)
refactoring.rename.0.already.exists.in.1={0} ya existe en {1}
refactoring.rename.0.already.exists.in.the.scope={0} ya existe en el ámbito
refactoring.rename.associated.file=Renombrar archivo asociado
refactoring.rename.class.aliases=Renombrar alias de clase(&R)
refactoring.rename.command.name=Renombrar
refactoring.symbol.has.no.members.to.move={0} no tiene miembros para mover
rename.multiple.macro.usages.message={0} tiene varios usos con diferentes mapeos para "{1}". El renombrado puede romper el código. ¿Continuar?
rename.non.code.usages.message=Se encontraron {0} {0, choice, 1\#uso|2\#usos} en comentarios y archivos que no son código.\n¿Desea renombrar{0, choice, 1\#lo|2\#los}?
rename.reference.command.name=Renombrar Referencia
rename.reference.invalid.dialog.button.yes=Continuar editando
rename.reference.invalid.dialog.title=Identificador Inválido
selected.expression.cannot.be.a.constant.initializer=La expresión seleccionada no puede ser un inicializador de constante
selected.expression.should.be.inside.a.block.statement=La expresión seleccionada debe estar dentro de un bloque de sentencias
selected.expression.should.be.inside.a.function.or.method=La expresión seleccionada debe estar dentro de una función o método
selected.expression.should.be.inside.an.instance.method=La expresión seleccionada debe estar dentro de un método de instancia
selected.expression.should.be.inside.an.instance.method1=La expresión seleccionada debe estar dentro de un método de instancia
several.definitions.of.0=Hay varias definiciones de {0}
text.parameter.initializer.not.available.in=El inicializador de parámetros no está disponible en {0}\: {1}.
the.address.of.is.taken=La dirección de {0} está tomada
the.type.is.empty=El tipo está vacío
there.are.several.definitions.of=Hay varias definiciones de {0}
there.are.usages.in.other.blocks=Hay usos en otros bloques
top.level.namespace.placeholder=namespace de nivel superior
trying.to.rename.0.to.existing.file.name.1=Intentando renombrar {0} al nombre de archivo existente {1}