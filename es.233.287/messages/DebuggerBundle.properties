### org/jetbrains/plugins/scala/debugger/ScalaFrameExtraVariablesProvider.scala
debug.process.is.detached=디버그 프로세스가 연결 해제되었습니다.

### org/jetbrains/plugins/scala/debugger/breakpoints/ScalaLineBreakpointType.scala
line.breakpoints.tab.title=Scala 줄 중단점
breakpoint.location.constructor.of={0}의 생성자
breakpoint.location.early.definitions.of={0}의 초기 정의
breakpoint.location.line.in.containing.block=포함 블록 내 줄
breakpoint.location.line.in.function=함수 {0} 내 줄
breakpoint.location.line.in.containing.file=포함 파일 내 줄

### org/jetbrains/plugins/scala/debugger/evaluation/ScalaEvaluatorBuilder.scala
evaluation.of.object.needs.compilation=객체를 평가하려면 컴파일이 필요합니다
evaluation.of.class.needs.compilation=클래스를 평가하려면 컴파일이 필요합니다
evaluation.of.trait.needs.compilation=특성을 평가하려면 컴파일이 필요합니다
evaluation.of.anonymous.class.needs.compilation=익명 클래스를 평가하려면 컴파일이 필요합니다
evaluation.of.type.alias.needs.compilation=타입 별칭을 평가하려면 컴파일이 필요합니다
evaluation.of.function.definition.needs.compilation=함수 정의를 평가하려면 컴파일이 필요합니다
evaluation.of.variable.declaration.needs.compilation=변수 선언을 평가하려면 컴파일이 필요합니다
evaluation.of.lazy.val.definition.needs.compilation=lazy val 정의를 평가하려면 컴파일이 필요합니다
evaluation.of.anonymous.function.needs.compilation=익명 함수를 평가하려면 컴파일이 필요합니다
evaluation.of.for.expression.needs.compilation=for 식을 평가하려면 컴파일이 필요합니다
evaluation.of.try.statement.needs.compilation=try 문을 평가하려면 컴파일이 필요합니다
evaluation.of.return.statement.needs.compilation=return 문을 평가하려면 컴파일이 필요합니다
evaluation.of.match.statement.needs.compilation=match 문을 평가하려면 컴파일이 필요합니다
evaluation.of.throw.statement.needs.compilation=throw 문을 평가하려면 컴파일이 필요합니다
evaluation.of.xml.expression.needs.compilation=xml 식을 평가하려면 컴파일이 필요합니다
evaluation.of.interpolated.string.needs.compilation=보간된 문자열을 평가하려면 컴파일이 필요합니다
cannot.find.by.name.parameter.with.such.name=다음 이름을 가진 by-name 매개변수를 찾을 수 없습니다. {0}
evaluation.of.expression.is.not.supported=표현식의 평가는 지원되지 않습니다. {0}
evaluation.of.element.is.not.supported=요소의 평가는 지원되지 않습니다. {0}

### org/jetbrains/plugins/scala/debugger/evaluation/ScalaEvaluatorBuilderUtil.scala
cannot.evaluate.imported.reference=가져온 참조를 평가할 수 없습니다
cannot.evaluate.local.method=지역 메서드를 평가할 수 없습니다
cannot.evaluate.parameter=매개변수 {0}을(를) 평가할 수 없습니다
cannot.evaluate.method=메서드 {0}을(를) 평가할 수 없습니다
cannot.evaluate.local.object=지역 객체 {0}을(를) 평가할 수 없습니다
cannot.evaluate.local.variable=지역 변수 {0}을(를) 평가할 수 없습니다
wrong.number.of.arguments=메서드 {0}의 인수 개수가 잘못되었습니다
array.instance.is.not.found=메서드 {0}을(를) 평가할 수 없습니다. 배열 인스턴스를 찾을 수 없습니다
array.method.not.supported=배열 메서드가 지원되지 않습니다
cannot.find.implicit.parameters=전달할 묵시적 매개변수를 찾을 수 없습니다
implicit.parameters.from.dependent.objects=종속 객체의 묵시적 매개변수는 지원되지 않습니다
implicit.conversions.from.dependent.objects=종속 객체의 묵시적 변환은 지원되지 않습니다
method.with.by-name.parameters=이름에 의한 호출 매개변수를 가진 메서드를 평가할 수 없습니다
wrong.number.of.expressions=인수를 평가할 수 없습니다. 일치하는 표현식 개수가 잘못되었습니다
tupling.not.supported=튜플화가 지원되지 않습니다. 튜플 표현식을 사용하세요.
not.used.from.for.statement=for 문의 변수 {0}은(는) 본문에서 사용되지 않으므로 평가할 수 없습니다
cannot.find.pattern=case 절의 패턴을 찾을 수 없습니다
cannot.find.expression.of.match=match 문의 표현식을 찾을 수 없습니다
invalid.case.clause=잘못된 case 절
assignent.without.expression=표현식이 없는 대입문을 평가할 수 없습니다
unapply.without.arguments=인수가 없는 unapply의 값을 추출할 수 없습니다
pattern.doesnot.resolves.to.unapply=패턴 참조 {0}이(가) unapply 또는 unapplySeq로 해결되지 않습니다
pattern.alternatives.cannot.bind.vars=패턴 대체가 변수를 바인드할 수 없습니다
xml.patterns.not.supported=XML 패턴이 지원되지 않습니다
kind.of.pattern.not.supported=이 패턴 종류는 지원되지 않습니다. {0}
anon.classes.not.supported=익명 클래스가 지원되지 않습니다
new.expression.without.class.reference=클래스 참조가 없는 new 식을 평가할 수 없습니다
new.expression.without.constructor.call=생성자 호출이 없는 표현식을 평가할 수 없습니다
new.expression.without.template.parents=템플릿 상위가 없는 표현식을 평가할 수 없습니다
could.not.resolve.constructor=생성자를 해결할 수 없습니다
if.statement.without.condition=조건이 없는 if 문을 평가할 수 없습니다
if.statement.without.if.branch=if 브랜치가 없는 if 문을 평가할 수 없습니다
while.statement.without.condition=조건이 없는 while 문을 평가할 수 없습니다
while.statement.without.body=본문이 없는 while 문을 평가할 수 없습니다
do.statement.without.condition=조건이 없는 do 문을 평가할 수 없습니다
do.statement.without.body=본문이 없는 do 문을 평가할 수 없습니다
method.call.implicitly.converted.qualifier=묵시적으로 변환된 한정자가 있는 메서드 호출을 평가할 수 없습니다. {0}
synchronized.statement.is.not.supported=동기화된 구문은 지원되지 않습니다
cannot.evaluate.synthetic.method=통합 메서드를 평가할 수 없습니다. {0}
by.name.parameter.expected=By-name 매개변수가 필요합니다
update.method.is.not.supported=Update 메서드는 지원되지 않습니다
variable.definition.needs.right.hand.side=변수 정의에는 오른쪽이 필요합니다. {0}
value.definition.needs.right.hand.side=값 정의에는 오른쪽이 필요합니다. {0}
new.synthetic.instantiation={0} ''{1}''은(는) abstract이므로 인스턴스화할 수 없습니다
missing.type.argument.synthetic.method=명시적 타입의 인수 없이 {0}이(가) 호출됨
constructor.param.inaccessible.outside.of.constructor=생성자 매개변수 ''{0}''은(는) 클래스 생성자 밖에서 액세스할 수 없습니다
array.constructor.unspecified.parameters=지정되지 않은 값 매개변수\: _length\: Int
array.constructor.too.many.arguments=생성자 Array(Int)의 인수가 너무 많습니다

### org/jetbrains/plugins/scala/debugger/evaluation/ScalaEvaluatorCompileHelper.scala
could.not.compile=컴파일할 수 없습니다\n{0}
compilation.failed=컴파일 실패

### org/jetbrains/plugins/scala/debugger/evaluation/evaluator/AsInstanceOfEvaluator.scala
error.cannot.cast.value.to.type=''{0}'' 타입의 값을 ''{1}'' 타입으로 형 변환할 수 없습니다

### org/jetbrains/plugins/scala/debugger/evaluation/evaluator/ClassOfEvaluator.scala
error.literal.type.is.not.class.type=리터럴 타입({0} \: {1})은(는) 클래스 타입이 아닙니다

### org/jetbrains/plugins/scala/debugger/evaluation/evaluator/IsInstanceOfEvaluator.scala
error.type.cannot.be.used.in.isinstanceof={0} {1}은(는) 런타임 타입 테스트에 사용할 수 없습니다
error.value.isinstanceof.reference={0} 타입의 값이 타입 {1}의 참조인지 테스트할 수 없습니다
error.isinstanceof.structural.type=구조 타입에 대한 런타임 타입 테스트가 선택 해제되어 있습니다

### org/jetbrains/plugins/scala/debugger/evaluation/evaluator/NewValueClassInstanceEvaluator.scala
error.cannot.resolve.value.class.primary.constructor=값 클래스 {0}의 기본 생성자를 해결할 수 없습니다

### org/jetbrains/plugins/scala/debugger/evaluation/evaluator/ScalaBoxingEvaluator.scala
cannot.perform.boxing.conversion.for.result={0}에 대한 박싱 변환을 수행할 수 없습니다

### org/jetbrains/plugins/scala/debugger/evaluation/evaluator/ScalaCompilingEvaluator.scala
could.not.compile.generated.class=생성된 클래스를 컴파일할 수 없습니다
error.during.generated.code.invocation=생성된 코드 호출 중 오류 발생\:\n {0}
error.creating.evaluation.class.loader=평가 클래스 로더 생성 중 오류 발생\:\n {0}
error.during.classes.definition=클래스 정의 중 오류 발생\:\n {0}

### org/jetbrains/plugins/scala/debugger/evaluation/evaluator/ScalaLiteralEvaluator.scala
unknown.type.of.literal=알 수 없는 리터럴 타입
literal.has.null.value=리터럴 {0}에 null 값이 있습니다

### org/jetbrains/plugins/scala/debugger/evaluation/evaluator/ScalaMethodEvaluator.scala
could.not.find.appropriate.constructor.for.name={0}에 대한 적절한 생성자를 찾을 수 없습니다
cannot.invoke.abstract.interface.method.name=추상 인터페이스 메서드 {0}을(를) 호출할 수 없습니다
method.methodname.cannot.be.invoked.on.array=메서드 {0}을(를) 배열에서 호출할 수 없습니다

### org/jetbrains/plugins/scala/debugger/evaluation/evaluator/ScalaThisEvaluator.scala
outer.this.not.available=외부 ''this''를 사용할 수 없습니다

### org/jetbrains/plugins/scala/debugger/evaluation/evaluator/compiling/GeneratedClass.scala
module.for.compilation.is.not.found=컴파일용 모듈을 찾을 수 없습니다
could.not.evaluate.due.to.a.change.in.a.source.file=소스 파일의 변경으로 인해 평가할 수 없습니다
could.not.compile.local.class.in.this.context=이 컨텍스트에서는 로컬 클래스를 컴파일할 수 없습니다

### org/jetbrains/plugins/scala/debugger/filters/ScalaDebuggerSettingsConfigurable.form
friendly.collection.display.enabled=디버거에 Scala 컬렉션 표시
dont.show.runtime.refs=디버거에 런타임 참조 표시 안 함
show.variables.from.outer.scopes.in.variables.view=변수 뷰에 외부 범위의 변수 표시

### org/jetbrains/plugins/scala/debugger/filters/ScalaDebuggerSettingsConfigurable.java
scala.debug.caption=Scala

### org/jetbrains/plugins/scala/debugger/filters/ScalaSteppingConfigurable.form
scala.debug.disable.specific.methods=특정 Scala 클래스로 스텝인투 안 함(&I)

### org/jetbrains/plugins/scala/debugger/ui/ScalaClassRenderer.scala
scala.class.renderer=Scala 객체

### org/jetbrains/plugins/scala/debugger/ui/ScalaCollectionRenderer.scala
scala.collection.renderer=Scala 컬렉션

### org/jetbrains/plugins/scala/debugger/ui/ScalaRuntimeRefRenderer.scala
scala.runtime.ref.renderer=Scala 런타임 참조

### org/jetbrains/plugins/scala/debugger/ui/descriptors.scala
could.not.find.bitmap.field=비트맵 필드 {0}을(를) 찾을 수 없습니다
could.not.find.accessor.method={0} 필드에 대한 접근자 메서드를 찾을 수 없습니다
initialize.lazy.val=초기화
lazy.val.not.initialized=<초기화되지 않음>
collection.element.descriptors.evaluation.not.supported="컬렉션 요소 설명자의 평가는 지원되지 않습니다"
