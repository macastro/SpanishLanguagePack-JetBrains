0.will.no.longer.be.overridable.by.1={0} ya no puede ser anulado por {1}.
absolute.alignment.in.user.interface.display.name=Usar alineación absoluta en el código AWT/Swing
absolute.alignment.in.user.interface.fix.family.name=Reemplazar con constante
absolute.alignment.in.user.interface.problem.descriptor=Constante de alineación absoluta <code> {0}.\# ref</code> utilizada.\#loc
abstract.class.extends.concrete.class.display.name=La clase abstracta extiende la clase concreta
abstract.class.extends.concrete.class.problem.descriptor=La clase <code>#ref</code> se declara 'abstracta' y extiende una clase concreta #loc
abstract.class.naming.convention.element.description=Clase abstracta
abstract.class.never.implemented.display.name=Clase abstracta que no tiene subclase concreta
abstract.class.never.implemented.problem.descriptor=La clase abstracta <code>#ref</code> no tiene una subclase concreta #loc
abstract.class.with.only.one.direct.inheritor.display.name=Clase abstracta que tiene un solo heredero directo
abstract.class.with.only.one.direct.inheritor.problem.descriptor=La clase abstracta <code>#ref</code> tiene solo un heredero directo #loc
abstract.class.without.abstract.methods.display.name=Clase abstracta sin métodos abstractos
abstract.class.without.abstract.methods.ignore.utility.class.option=Ignore utility classes
abstract.class.without.abstract.methods.problem.descriptor=La clase <code>#ref</code> se declara 'abstracta' y no tiene métodos 'abstractos' #loc
abstract.method.call.in.constructor.display.name=Método abstracto llamado durante la construcción del objeto
abstract.method.call.in.constructor.problem.descriptor=Llamada al método 'abstracto' <code>#ref()</code> durante la construcción del objeto #loc
abstract.method.overrides.abstract.method.display.name=El método abstracto anula el método abstracto
abstract.method.overrides.abstract.method.ignore.different.javadoc.option=Ignorar métodos con un Javadoc diferente al de sus súper métodos
abstract.method.overrides.abstract.method.problem.descriptor=El método abstracto <code>#ref()</code> anula el método abstracto #loc
abstract.method.overrides.abstract.method.remove.quickfix=Eliminar la declaración de método abstracto redundante
abstract.method.overrides.concrete.method.display.name=El método abstracto anula el método concreto
abstract.method.overrides.concrete.method.problem.descriptor=El método abstracto <code>#ref()</code> anula el método concreto #loc
abstract.method.with.missing.implementations.display.name=Método abstracto con implementaciones faltantes
abstract.method.with.missing.implementations.problem.descriptor=El método abstracto <code>#ref()</code> no está implementado en todas las subclases #loc
access.to.non.thread.safe.static.field.from.instance.class.chooser.title=Elija una clase no segura para subprocesos
access.to.non.thread.safe.static.field.from.instance.display.name=Acceso a campo estático no seguro para subprocesos
access.to.non.thread.safe.static.field.from.instance.field.problem.descriptor=Acceso al campo estático no seguro para subprocesos <code>#ref</code> de tipo ''{0}' '#loc
access.to.non.thread.safe.static.field.from.instance.option.title=Clases no seguras para subprocesos
access.to.static.field.locked.on.instance.display.name=Acceso al campo estático bloqueado en datos de instancia
access.to.static.field.locked.on.instance.fix.name=Ignorar campos estáticos de tipo ''{0}''
access.to.static.field.locked.on.instance.problem.descriptor=Acceso al campo estático <code>#ref</code> bloqueado en datos de instancia #loc
accessing.non.public.field.of.another.object.display.name=Accediendo a un campo no público de otro objeto
accessing.non.public.field.of.another.object.problem.descriptor=Acceso directo del campo no público <code>#ref</code> en otro objeto #loc
add.0.to.ignore.if.annotated.by.list.quickfix={0}'' a la lista '' ignorar si se anota con 
add.catch.section.fix.family.name=Agregar cláusula ''catch''
add.read.write.object.methods.fix.family.name=Agregar métodos '' readObject()'' y '' writeObject()'' que siempre arrojan una excepción
add.read.write.object.methods.fix.text=Agregar método '' writeObject()'' que siempre arroja una excepción
add.read.write.object.methods.fix.text2=Agregar método '' readObject()'' que siempre arroja una excepción
add.serialversionuidfield.quickfix=Agregar campo 'serialVersionUID'
add.this.qualifier.quickfix=Agregar 'este' calificador
add.throws.clause.fix.family.name=Modificar cláusula '' throws ''
all.levels.option=Todos los niveles de registro
allow.resource.to.be.opened.inside.a.try.block=Permitir que el recurso se abra dentro de un bloque 'try'
ambiguous.field.access.display.name=Los accesos de campos heredados parecen accesos de elementos en el código circundante
ambiguous.field.access.hides.field.problem.descriptor=El acceso al campo <code>\#ref</code> en la clase principal ''{0}'' parece el acceso a los campos de la clase circundante.\#loc
ambiguous.field.access.hides.local.variable.problem.descriptor=El acceso al campo <code>\#ref</code> en la clase principal ''{0}'' parece un acceso a la variable local.\#loc
ambiguous.field.access.hides.parameter.problem.descriptor=El acceso al campo <code>\#ref</code> en la clase principal ''{0}'' parece el acceso al parámetro.\#loc
ambiguous.field.access.navigate.quickfix=Navigate to apparently accessed {0, choice, 1#local variable|2#parameter|3#field}
ambiguous.field.access.quickfix=Agregar modificador '' super '' al acceso al campo.
ambiguous.method.call.display.name=La llamada al método heredado parece una llamada al método local
ambiguous.method.call.problem.descriptor=Llamada al método <code>#ref()</code> desde la superclase ''{0}'' parece una llamada al método desde la clase ''{1}'' #loc
ambiguous.method.call.quickfix=Agregar calificador 'super' a la llamada al método
annotation.class.display.name=Clase de anotación
annotation.class.problem.descriptor=Clase de anotación <code>#ref</code> #loc
annotation.display.name=Anotación
annotation.naming.convention.element.description=Anotación
annotation.problem.descriptor=Anotación <code>#ref</code> #loc
anonymous.class.field.hides.containing.method.variable.problem.descriptor=El campo de clase anónimo <code>#ref</code> oculta la variable en el método contenedor #loc
anonymous.class.parameter.hides.containing.method.variable.problem.descriptor=El parámetro de clase anónimo <code>#ref</code> oculta la variable en el método contenedor #loc
anonymous.class.variable.hides.containing.method.variable.display.name=La variable de clase anónima oculta la variable en el método contenedor
anonymous.class.variable.hides.containing.method.variable.problem.descriptor=La variable local de clase anónima <code>#ref</code> oculta la variable en el método contenedor #loc
anonymous.extends.concrete.collection.problem.descriptor=La clase anónima extiende explícitamente ''{0}'' #loc
anonymous.extends.thread.problem.descriptor=La clase anónima extiende directamente 'java.lang.Thread' #loc
anonymous.extends.throwable.problem.descriptor=La clase anónima extiende directamente '' java.lang.Throwable ''.\#loc
anonymous.inner.class.display.name=Clase interna anónima
anonymous.inner.class.problem.descriptor=Clase interna anónima <code>#ref</code> #loc
anonymous.inner.class.with.too.many.methods.display.name=Clase interna anónima con demasiados métodos
anonymous.inner.class.with.too.many.methods.problem.descriptor=Clase interna anónima con demasiados métodos (cuenta de métodos={0}) #loc
anonymous.inner.may.be.named.static.inner.class.display.name=La clase anónima puede ser una clase interna 'estática' con nombre
anonymous.inner.may.be.named.static.inner.class.problem.descriptor=La clase anónima <code>#ref</code> puede ser una clase interna 'estática' nombrada #loc
anonymous.inner.may.be.named.static.inner.class.quickfix=Convertir a clase interna 'estática' nombrada
any.method.may.close.resource.argument=Cualquier método puede cerrar el argumento del recurso
array.allocation.zero.length.display.name=Asignación de matriz de longitud cero
array.allocation.zero.length.problem.descriptor=Asignación de matriz de longitud cero #loc
array.can.be.replaced.with.enum.values=Puede reemplazar matrices con valores de enumeración.
array.can.be.replaced.with.enum.values.family.quickfix=Reemplace la matriz con EnumType.value ().
array.can.be.replaced.with.enum.values.quickfix=Reemplazar matriz con {0} .values ().
array.comparison.display.name=Compare matrices usando ''\=\= '' en lugar de '' Arrays.equals()''
array.comparison.problem.descriptor=Comparar objetos de matriz usando <code>\#ref</code>, no '' Arrays.equals()''.\#loc
array.creation.without.new.keyword.family.quickfix=Agregue la expresión '' new ''.
array.creation.without.new.keyword.name='' new '' Crea una matriz sin expresión
array.creation.without.new.keyword.quickfix=Agregue '' new {0} ''.
array.equals.problem.descriptor=Arrays comparison should probably be done using ''{0}''
array.hash.code.display.name=Llamar '' hashCode()'' en una matriz
array.hash.code.fix.family.name=Reemplazar con '' hashCode '' implícito
array.hash.code.problem.descriptor=<code>\#ref()</code> llamado en una matriz debe ser '' Arrays.hashCode()''.\#loc
array.hashcode.problem.descriptor=Array hash code calculation should probably be done using ''{0}''
array.length.in.loop.condition.display.name=Array.length en condición de bucle
array.length.in.loop.condition.problem.descriptor=Verificación de la matriz <code>#ref</code> en condición de bucle #loc
array.objects.equals.display.name=Llamar '' Objects.equals()'' en una matriz
arrays.as.list.with.one.argument.problem.descriptor=<code>\#ref()</code> llamado con un solo argumento\#loc
arrays.as.list.with.zero.arguments.problem.descriptor=<code>\#ref()</code> fue llamado para crear una lista vacía\#loc
arrays.as.list.with.zero.or.one.argument.display.name=Llamar a '' Arrays.asList()'' con muy pocos argumentos
assert.can.be.if.quickfix=Reemplace '' assert '' con una declaración '' if ''.
assert.keyword.is.considered.an.assertion=la palabra clave 'assert' se considera una aserción
assert.message.not.string.display.name=El mensaje '' assert '' no es una cadena
assert.message.not.string.only.warn.boolean.option=Advertir solo si el mensaje '' assert '' es '' booleano '' o '' java.lang.Boolean ''
assert.message.of.type.boolean.problem.descriptor=Mensaje '' assert '' de tipo ''{0}''\#loc
assert.statement.display.name=declaración 'assert'
assert.with.side.effects.call.mutates.expression= {0}()'' call mutates ''{1}
assert.with.side.effects.call.mutates.field= {0}()'' campo de mutaciones de llamada ''{1}
assert.with.side.effects.display.name=declaración 'assert' con efectos secundarios
assert.with.side.effects.problem.descriptor=<code>#ref</code> tiene efectos secundarios:{0}#loc
assert.without.message.problem.descriptor=<code>#ref()</code> without message #loc
assert.without.message.quick.fix.family.name=Agregar mensaje de error
assertion.can.be.if.name=Puede reemplazar la aserción con la declaración if
asserts.without.messages.display.name=Falta el mensaje en la afirmación
assignment.of.field.with.mutable.type.problem.descriptor=Asignado al {0} campo ''{1}'' en el parámetro <code>\#ref</code>.\#loc
assignment.or.return.of.field.with.mutable.type.display.name=Asignar o devolver un campo con un tipo mutable
assignment.replaceable.with.operator.assignment.display.name=Asignación reemplazable por asignación de operador
assignment.replaceable.with.operator.assignment.ignore.conditional.operators.option=Ignorar operadores condicionales
assignment.replaceable.with.operator.assignment.ignore.obscure.operators.option=Ignorar los operadores oscuros ^ y%
assignment.replaceable.with.operator.assignment.problem.descriptor=<code>#ref</code> podría simplificarse a ''{0}'' #loc
assignment.to.catch.block.parameter.display.name=Asignación al parámetro del bloque de captura
assignment.to.catch.block.parameter.problem.descriptor=Asignación al parámetro de bloque 'catch' <code>#ref</code> #loc
assignment.to.for.loop.parameter.check.foreach.option=Verifique los parámetros mejorados de bucle 'for'
assignment.to.for.loop.parameter.display.name=Asignación al parámetro de bucle 'for'
assignment.to.for.loop.parameter.problem.descriptor=Asignación al parámetro de bucle for <code>#ref</code> #loc
assignment.to.lambda.parameter.display.name=Asignación al parámetro lambda
assignment.to.lambda.parameter.problem.descriptor=Asignado al parámetro lambda <code>\#ref</code>.\#loc
assignment.to.method.parameter.display.name=Asignación al parámetro del método
assignment.to.method.parameter.ignore.transformation.option=<html>Ignorar si la asignación es una transformación del parámetro original</html>
assignment.to.method.parameter.problem.descriptor=Asignación al parámetro del método <code>#ref</code> #loc
assignment.to.null.display.name=asignación 'nula'
assignment.to.null.option=Ignorar asignaciones a campos
assignment.to.null.problem.descriptor='nulo' asignado a la variable <code>#ref</code> #loc
assignment.to.static.field.from.instance.method.display.name=Asignación a un campo estático desde el contexto de la instancia
assignment.to.static.field.from.instance.method.problem.descriptor=Asignación al campo estático <code>#ref</code> desde el contexto de la instancia #loc
assignment.to.superclass.field.display.name=El constructor asigna un valor al campo definido en la clase principal
assignment.to.superclass.field.problem.descriptor=Asignar al campo ''{0}'' definido en la superclase ''{1}''.\#loc
assignment.used.as.condition.display.name=Asignación utilizada como condición
assignment.used.as.condition.problem.descriptor=Asignación <code>#ref</code> usada como condición #loc
atomic.field.updater.issues.display.name=Problema de AtomicFieldUpdater
atomic.field.updater.not.static.final.display.name=El campo AtomicFieldUpdater no se declaró '' static final ''
atomic.field.updater.not.static.final.problem.descriptor=El campo {0} field <code>\#ref</code> no está declarado '' static final ''.\#loc
auto.boxing.display.name=Auto-boxing
auto.boxing.ignore.added.to.collection.option=Ignorar expresiones agregadas a una colección
auto.boxing.make.boxing.explicit.quickfix=Hacer explícito el boxeo
auto.boxing.problem.descriptor=Auto-boxing <code>#ref</code> #loc
auto.closeable.resource.display.name=Usar AutoCloseable sin '' intentar '' - con-recursos
auto.closeable.resource.problem.descriptor=''{0}'' se usó sin '' intentar '' - con-recursos.\#loc
auto.closeable.resource.quickfix=Ignorar '' AutoCloseable '' devuelto por este método.
auto.closeable.resource.quickfix.preview=Add method <code>{0}</code> to the list of ignored methods
auto.closeable.resource.returned.option=Ignorar instancias AutoCloseable devueltas de todas las llamadas a métodos
auto.unboxing.display.name=Auto-desempaquetado
auto.unboxing.make.unboxing.explicit.quickfix=Hacer explícito el unboxing
auto.unboxing.problem.descriptor=Desempaquetado automático <code>#ref</code> #loc
await.not.in.loop.display.name='await()' no está en el bucle
await.not.in.loop.problem.descriptor=La llamada a <code>#ref()</code> no se realiza en un bucle #loc
await.without.corresponding.signal.display.name=await()' sin la correspondiente 'señal()
await.without.corresponding.signal.problem.descriptor=Llamar a <code>#ref</code> sin el <code> signal()</code> o <code> signalAll()</code> correspondiente #loc
bad.exception.caught.display.name=Excepción prohibida capturada
bad.exception.caught.problem.descriptor=Excepción prohibida <code>#ref</code> capturada #loc
bad.exception.declared.display.name=Excepción prohibida declarada
bad.exception.declared.problem.descriptor=Excepción prohibida <code>#ref</code> declarada #loc
bad.exception.thrown.display.name=Se ha lanzado una excepción prohibida
bad.exception.thrown.problem.descriptor=Excepción prohibida ''{0}'' lanzada #loc
bad.oddness.display.name=Prueba sospechosa de rareza
bad.oddness.problem.descriptor=La prueba de rareza <code>#ref</code> fallará en valores negativos #loc
big.decimal.equals.display.name=equals()' llamado en 'java.math.BigDecimal
big.decimal.equals.problem.descriptor=<code>#ref()</code> entre los valores BigDecimal probablemente debería ser 'compareTo()' #loc
big.decimal.method.without.rounding.called.display.name=Llamar al método '' BigDecimal '' sin el argumento del modo de redondeo
big.decimal.method.without.rounding.called.problem.descriptor='' BigDecimal.\# ref()'' se llama sin argumento de modo de redondeo.
bigdecimal.legacy.method.display.name='' BigDecimal '' Llamar a un método existente
bigdecimal.legacy.method.problem.descriptor=Las llamadas '' BigDecimal.\# ref()'' pueden usar la constante de enumeración '' RoundingMode ''.
bigdecimal.legacy.method.quickfix=Utilice la constante de enumeración '' RoundingMode ''.
boolean.constructor.display.name=Llamada al constructor booleano
boolean.constructor.problem.descriptor=Llamada al constructor booleano #loc
boolean.constructor.simplify.quickfix=Simplificar
boolean.expression.can.be.simplified.problem.descriptor=<code>#ref</code> puede simplificarse a ''{0}'' #loc
boolean.expression.does.not.modify.problem.descriptor=<code>#ref</code> no modifica el valor de ''{0}'' #loc
boolean.expression.may.be.conditional.display.name=La expresión booleana podría reemplazarse con una expresión condicional
boolean.expression.remove.compound.assignment.quickfix=Eliminar asignación compuesta sin sentido
boolean.field.always.inverted.problem.descriptor=El campo booleano <code>\#ref</code> siempre está invertido.\#loc
boolean.method.name.must.start.with.question.display.name=El nombre del método booleano debe comenzar con la palabra pregunta
boolean.method.name.must.start.with.question.problem.descriptor=El nombre del método booleano <code>#ref</code> no comienza con la palabra de pregunta #loc
boolean.method.name.must.start.with.question.table.label=Boolean method name prefixes:
boolean.parameter.constructor.problem.descriptor=constructor '' público '' con parámetro '' booleano '' <code>\#ref()</code>\#loc
boolean.parameter.display.name='' método booleano '' público '' con parámetro
boolean.parameter.only.report.multiple.option=Informar solo métodos con múltiples parámetros booleanos
boolean.parameter.problem.descriptor=método '' público '' con parámetro '' booleano '' <code>\#ref()</code>\#loc
boolean.parameters.constructor.problem.descriptor=constructor '' público '' con parámetro '' booleano '' <code>\#ref()</code>\#loc
boolean.parameters.problem.descriptor=método '' público '' con parámetro '' booleano '' <code>\#ref()</code>\#loc
boolean.variable.always.inverted.display.name=Las variables booleanas siempre están invertidas
boolean.variable.always.inverted.problem.descriptor=La variable booleana <code>\#ref</code> siempre está invertida.\#loc
bounded.wildcard.contravariant.descriptor=¿Se puede generalizar a <code>? super#ref</code> #loc
bounded.wildcard.covariant.descriptor=¿Se puede generalizar a <code>? extiende#ref</code> #loc
bounded.wildcard.display.name=Puede usar comodines acotados
bounded.wildcard.report.instance.option=Métodos de instancia de informe
bounded.wildcard.report.invariant.option=Informar clases invariantes
bounded.wildcard.report.private.option=Informar métodos privados
boxing.boxed.value.display.name=Caja un valor ya en caja
boxing.boxed.value.problem.descriptor=Caja ya en caja <code>\#ref</code>.\#loc
boxing.boxed.value.quickfix=Elimina el boxeo innecesario.
break.statement.display.name=declaración 'break'
break.statement.with.label.display.name=declaración 'break' con etiqueta
break.statement.with.label.problem.descriptor=<code>#ref</code> declaración con etiqueta #loc
busy.wait.display.name=Espera ocupada
busy.wait.problem.descriptor=Llamada a <code>Thread. #ref()</code> en un bucle, probablemente ocupado esperando #loc
c.style.array.declaration.display.name=Declaración de matriz de estilo C
c.style.array.declaration.replace.quickfix=Reemplazar con declaración de matriz de estilo Java
cached.number.constructor.call.display.name=Llamada al constructor de números con argumento primitivo
cached.number.constructor.call.ignore.string.arguments.option=Ignorar nuevas expresiones numéricas con un argumento de cadena
cached.number.constructor.call.problem.descriptor=Llamada al constructor de números con argumento primitivo #loc
cached.number.constructor.call.report.only.deprecated=Informar solo cuando el constructor es @Deprecated
call.to.date.tostring.display.name=Llamar a 'Date.toString()'
call.to.date.tostring.problem.descriptor=<code> Date. #ref()</code> usado en un contexto internacionalizado #loc
call.to.native.method.while.locked.display.name=Llamar a un método nativo mientras está bloqueado
call.to.native.method.while.locked.problem.descriptor=Llamada al método nativo <code>#ref()</code> en un contexto sincronizado #loc
call.to.numeric.tostring.display.name=Llamar a numérico 'toString()'
call.to.numeric.tostring.problem.descriptor=<code>#ref()</code> numérico llamado en un contexto internacionalizado #loc
call.to.private.setter.in.class.option=Solo informar cuando el setter es 'privado'
call.to.private.simple.getter.in.class.option=Solo informar cuando getter es 'privado'
call.to.simple.getter.in.class.display.name=Llamar a un captador simple desde dentro de la clase
call.to.simple.getter.in.class.ignore.option=Ignorar las llamadas de getter en otros objetos
call.to.simple.getter.in.class.inline.quickfix=Llamada en línea al getter
call.to.simple.getter.in.class.problem.descriptor=Llamada al getter simple <code>#ref()</code> desde dentro de la clase #loc
call.to.simple.setter.in.class.display.name=Llamada a establecedor simple desde dentro de la clase
call.to.simple.setter.in.class.ignore.option=Ignorar las llamadas del setter en otros objetos
call.to.simple.setter.in.class.inline.quickfix=Llamada en línea a setter
call.to.simple.setter.in.class.problem.descriptor=Llamada a simple setter <code>#ref()</code> desde dentro de la clase #loc
call.to.string.concat.can.be.replaced.by.operator.display.name=La llamada a 'String.concat()' se puede reemplazar con '+'
call.to.string.concat.can.be.replaced.by.operator.problem.descriptor=La llamada a <code>#ref()</code> se puede reemplazar con la expresión '+' #loc
call.to.string.concat.can.be.replaced.by.operator.quickfix=Reemplazar la llamada 'concat()' con '+'
call.to.suspicious.string.method.display.name=Llamar al método de cadena sospechoso
call.to.suspicious.string.method.problem.descriptor=<code> String.\# ref()</code> se llama en un contexto internacionalizado.\#loc
cast.conflicts.with.instanceof.display.name=Cast entra en conflicto con 'instanceof'
cast.conflicts.with.instanceof.problem.descriptor=Cast <code>#ref</code> entra en conflicto con la comprobación 'instanceof' #loc circundante
cast.conflicts.with.instanceof.quickfix1=En cast, reemplace ''{0}'' por ''{1}''.
cast.conflicts.with.instanceof.quickfix2=Instanceof reemplazar ''{0}'' con ''{1}''.
cast.that.loses.precision.display.name=Reparto numérico que pierde precisión
cast.that.loses.precision.negative.problem.descriptor=La conversión de ''{0}'' a <code>#ref</code> puede resultar en la pérdida de precisión para el argumento negativo #loc
cast.that.loses.precision.option=Ignorar conversiones de int a char
cast.that.loses.precision.problem.descriptor=La conversión de ''{0}'' a <code>#ref</code> puede provocar una pérdida de precisión #loc
cast.to.concrete.class.problem.descriptor=Transmitir a clase concreta <code>{0}</code> #loc
casting.to.incompatible.interface.display.name=Transmitiendo a una interfaz incompatible
casting.to.incompatible.interface.problem.descriptor=Transmitir a interfaz incompatible <code>#ref</code> #loc
caught.exception.immediately.rethrown.display.name=La excepción capturada se vuelve a lanzar inmediatamente
caught.exception.immediately.rethrown.problem.descriptor=La excepción capturada <code>#ref</code> se vuelve a lanzar inmediatamente #loc
chain.of.class.equality.checks.problem.descriptor=La cadena de comprobaciones de igualdad de clases indica un fallo de abstracción #loc
chain.of.instanceof.checks.display.name=Cadena de comprobaciones 'instanceof'
chain.of.instanceof.checks.problem.descriptor=La cadena de comprobaciones 'instanceof' indica falla de abstracción #loc
chained.equality.comparisons.display.name=Comparaciones encadenadas de igualdad
chained.equality.comparisons.problem.descriptor=Comparación de igualdad encadenada <code>#ref</code> #loc
chained.method.call.display.name=Llamadas a métodos encadenados
chained.method.call.ignore.option=Ignorar llamadas a métodos encadenados en inicializadores de campo
chained.method.call.ignore.self.types.option=Ignorar las llamadas a los métodos que devuelven el mismo tipo que su clase adjunta
chained.method.call.problem.descriptor=Llamada al método encadenado <code>#ref()</code> #loc
change.modifier.fix.family.name=Cambiar modificador
change.modifier.package.private.quickfix=Make package-private
change.modifier.quickfix=Hacer ''{0}''
channel.opened.not.closed.display.name=Canal abierto pero no cerrado de forma segura
char.used.in.arithmetic.content.cast.fix.family.name=Insertar elenco
char.used.in.arithmetic.context.cast.quickfix=Insertar conversión en {0}
char.used.in.arithmetic.context.display.name='char' expresión utilizada en contexto aritmético
char.used.in.arithmetic.context.problem.descriptor='char' <code>#ref</code> usado en contexto aritmético #loc
char.used.in.arithmetic.context.quickfix=Convertir a literal de cadena
character.comparison.display.name=Comparación de personajes
character.comparison.problem.descriptor=Comparación de caracteres <code>#ref</code> en un contexto internacionalizado #loc
checkbox.ignore.null.on.wrong.side=Ignore 'null' on the wrong side
checked.exception.class.display.name=Clase de excepción marcada
checked.exception.class.problem.descriptor=Clase de excepción marcada <code>#ref</code> #loc
choose.autocloseable.type.to.ignore.title=Elija los tipos de recursos que se pueden cerrar automáticamente para ignorar
choose.class=Elige clase
choose.class.hierarchy.to.ignore.title=Elija la jerarquía de clases para ignorar
choose.class.type.to.ignore=Elija el tipo de clase para ignorar
choose.exception.class=Elija la clase de excepción
choose.exception.label=Prohibited exceptions:
choose.io.resource.type.to.ignore=Elija el tipo de recurso de E/S para ignorar
choose.logger.class=Elija la clase de registrador
class.escapes.defined.scope.display.module.option=La API del módulo expone clases no exportadas (Java 9+)
class.escapes.defined.scope.display.name=La clase no accesible está expuesta
class.escapes.defined.scope.display.package.option=La API local del paquete expone clases privadas
class.escapes.defined.scope.display.public.option=La API pública expone clases no accesibles
class.escapes.defined.scope.java9.modules.descriptor=La clase <code>#ref</code> no se exporta desde el módulo ''{0}''
class.escapes.defined.scope.problem.descriptor=La clase <code>#ref</code> está expuesta fuera de su alcance definido #loc
class.extends.utility.class.display.name=La clase extiende la clase de utilidad
class.extends.utility.class.ignore.utility.class.option=Ignorar si la clase de reemplazo es una clase de utilidad
class.extends.utility.class.problem.descriptor=Class <code>#ref</code> extiende la clase de utilidad ''{0}'' #loc
class.independent.of.module.display.name=Clase que no depende de este módulo
class.independent.of.module.problem.descriptor=El módulo de la clase <code>\#ref</code> no tiene dependencias ni dependencias.\#loc
class.initializer.display.name=Inicializador no 'estático'
class.initializer.may.be.static.display.name=El inicializador de clase puede ser 'estático'
class.initializer.may.be.static.problem.descriptor=El inicializador de clase puede ser 'estático' #loc
class.initializer.move.code.to.constructor.quickfix=Mover el código inicializador al constructor
class.initializer.option=Solo advertir cuando la clase tiene uno o más constructores
class.initializer.problem.descriptor=Inicializador no 'estático' #loc
class.loader.instantiation.display.name=instanciación de ClassLoader
class.loader.instantiation.problem.descriptor=La creación de instancias de <code>#ref</code> puede plantear problemas de seguridad #loc
class.may.be.interface.convert.quickfix=Convertir clase en interfaz
class.may.be.interface.display.name=La clase abstracta puede ser interfaz
class.may.be.interface.java8.option=Clases de informes con métodos no abstractos cuando se usa Java 8
class.may.be.interface.problem.descriptor=La clase abstracta <code>#ref</code> puede ser la interfaz #loc
class.name=Nombre de la clase
class.name.differs.from.file.name.display.name=El nombre de la clase difiere del nombre del archivo
class.name.differs.from.file.name.problem.descriptor=El nombre de la clase <code>#ref</code> difiere del nombre de archivo #loc
class.name.prefixed.with.package.name.display.name=Nombre de clase con el prefijo del nombre del paquete
class.name.prefixed.with.package.name.problem.descriptor=El nombre de la clase <code>#ref</code> comienza con su nombre de paquete #loc
class.name.same.as.ancestor.name.display.name=Nombre de clase igual al nombre del ancestro
class.name.same.as.ancestor.name.problem.descriptor=El nombre de la clase <code>#ref</code> es el mismo que uno de los nombres de su superclase #loc
class.naming.convention.display.name=Convención de nomenclatura de clases
class.naming.convention.element.description=Clase
class.new.instance.display.name=Llamada no segura a 'Class.newInstance()'
class.new.instance.problem.descriptor=La llamada a <code>#ref()</code> puede generar excepciones marcadas no declaradas #loc
class.only.used.in.one.module.display.name=Clase utilizada solo por otros módulos
class.only.used.in.one.module.problem.descriptor=El módulo ''{0}'' de la clase <code>\#ref</code> solo tiene dependencias y/o dependencias.\#loc
class.only.used.in.one.package.display.name=Clase solo utilizada por otro paquete
class.only.used.in.one.package.problem.descriptor=El paquete ''{0}'' de la clase <code>\#ref</code> solo tiene dependencias y/o dependencias.\#loc
class.references.subclass.display.name=La clase hace referencia a una de sus subclases
class.references.subclass.problem.descriptor=Class ''{0}'' hace referencia a la subclase <code>#ref</code> #loc
class.references.subclass.problem.descriptor.anonymous=Referencias de clase anónimas subclase <code>#ref</code> #loc
class.too.deep.display.name=Clase demasiado profunda en el árbol de herencia
class.too.deep.inheritance.depth.limit.option=Límite de profundidad de herencia:
class.too.deep.problem.descriptor=<code>#ref</code> está demasiado profundo en el árbol de herencia (profundidad de herencia={0}) #loc
class.unconnected.to.package.display.name=Clase independiente de su paquete
class.unconnected.to.package.problem.descriptor=Class <code>#ref</code> no tiene dependencias ni dependientes en su paquete
class.with.only.private.constructors.display.name= private '' Las clases con solo constructores deben declararse como '' finales 
class.with.only.private.constructors.problem.descriptor='' private '' La clase con solo constructor <code>\#ref</code> debe declararse como '' final ''.
class.with.too.many.dependencies.display.name=Clase con demasiadas dependencias
class.with.too.many.dependencies.max.option=Número máximo de dependencias
class.with.too.many.dependencies.problem.descriptor=La clase ''{0}'' tiene demasiadas dependencias ({1}> {2})
class.with.too.many.dependents.display.name=Clase con demasiados dependientes
class.with.too.many.dependents.max.option=Número máximo de dependientes
class.with.too.many.dependents.problem.descriptor=La clase ''{0}'' tiene demasiados dependientes ({1}> {2})
class.with.too.many.transitive.dependencies.display.name=Clase con demasiadas dependencias transitivas
class.with.too.many.transitive.dependencies.max.option=Número máximo de dependencias transitivas
class.with.too.many.transitive.dependencies.problem.descriptor=Class ''{0}'' tiene demasiadas dependencias transitivas ({1}> {2})
class.with.too.many.transitive.dependents.display.name=Clase con demasiados dependientes transitivos
class.with.too.many.transitive.dependents.max.option=Número máximo de dependientes transitivos
class.with.too.many.transitive.dependents.problem.descriptor=La clase ''{0}'' tiene demasiadas dependencias transitivas ({1}> {2})
class.without.constructor.create.quickfix=Generar constructor vacío
class.without.constructor.display.name=Clase sin constructor
class.without.constructor.problem.descriptor=Class <code>#ref</code> no tiene constructor #loc
class.without.logger.annotations.tab=Anotaciones
class.without.logger.loggers.tab=Registradores
class.without.no.arg.constructor.display.name=Clase sin constructor sin argumentos
class.without.no.arg.constructor.ignore.option=Ignorar si la clase tiene un constructor predeterminado
class.without.no.arg.constructor.problem.descriptor=<code>#ref</code> no tiene constructor sin argumentos #loc
clone.doesnt.declare.clonenotsupportedexception.declare.quickfix=Agregar 'CloneNotSupportedException' a la cláusula throws
clone.doesnt.declare.clonenotsupportedexception.display.name=clone()' no declara 'CloneNotSupportedException
clone.doesnt.declare.clonenotsupportedexception.problem.descriptor=<code>#ref()</code> #loc no declara 'CloneNotSupportedException'
clone.instantiates.new.array.problem.descriptor=''clone()'' crea una nueva matriz {0}#loc
clone.instantiates.objects.with.constructor.display.name='clone()' crea una instancia de los objetos con el constructor
clone.instantiates.objects.with.constructor.problem.descriptor='clone()' crea nuevas instancias de <code>#ref</code> #loc
clone.method.in.non.cloneable.anonymous.class.problem.descriptor=<code>#ref()</code> definido en una clase anónima no clonable derivada de ''{0}'' #loc
clone.method.in.non.cloneable.class.display.name=método 'clone()' en una clase no clonable
clone.method.in.non.cloneable.class.problem.descriptor=<code>#ref()</code> definido en la clase no clonable ''{0}'' #loc
clone.method.in.non.cloneable.interface.problem.descriptor=<code>#ref()</code> definido en la interfaz no clonable ''{0}'' #loc
clone.returns.class.type.display.name='' clone()'' debe tener el mismo tipo de retorno que la clase contenedora
clone.returns.class.type.family.quickfix=Cambiar el tipo de retorno a tipo de clase.
clone.returns.class.type.problem.descriptor='' Clone()'' debe tener el tipo de retorno ''{0}''.\#loc
clone.returns.class.type.quickfix=Cambiar el tipo de retorno a ''{0}''.
cloneable.class.in.secure.context.display.name=Clase clonable en contexto seguro
cloneable.class.in.secure.context.problem.descriptor=La clase <code>#ref</code> puede ser clonada, comprometiendo la seguridad #loc
cloneable.class.in.secure.context.quickfix=Genera el método 'clone()' que siempre arroja una excepción
cloneable.class.without.clone.display.name=Clase clonable sin método 'clone()'
cloneable.class.without.clone.ignore.option=Ignorar clases clonables debido a herencia
cloneable.class.without.clone.ignore.when.clone.called.option=Ignore if Cloneable is necessary to call the clone() method of a superclass
cloneable.class.without.clone.problem.descriptor=<code>#ref</code> no define 'clone()' #loc
cloneable.class.without.clone.quickfix=Generar método 'clone()'
cloneable.class.without.clone.todo.message=TODO: copy mutable state here, so the clone can't change the internals of the original
collection.added.to.self.display.name=Colección agregada a uno mismo
collection.added.to.self.problem.descriptor=''{0}()'' llamado en la colección <code>#ref</code> con él mismo como argumento #loc
collection.declared.by.class.display.name=Colección declarada por clase, no por interfaz
collection.declared.by.class.ignore.locals.option=Ignorar variables locales
collection.declared.by.class.ignore.private.members.option=Ignorar campos y métodos 'privados'
collection.declared.by.class.problem.descriptor=La declaración de <code>#ref</code> probablemente debería debilitarse a ''{0}'' #loc
collections.field.access.replaceable.by.method.call.display.name=Collections.EMPTY_ * acceso al campo reemplazable con la llamada al método 'Collections.empty *()'
collections.field.access.replaceable.by.method.call.fix.family.name=Reemplazar Collections.EMPTY_ * con una llamada
collections.field.access.replaceable.by.method.call.problem.descriptor=<code>#ref</code> reemplazable por '' Colecciones.{0}'' #loc
collections.must.have.initial.capacity.display.name=Colección sin capacidad inicial
collections.must.have.initial.capacity.problem.descriptor=<code>new#ref()</code> sin capacidad inicial #loc
commented.out.code.delete.quickfix=Eliminar comentario
commented.out.code.uncomment.quickfix=Código de descomentar
comments.as.content.option=Contar comentarios como contenido
comparable.implemented.but.equals.not.overridden.display.name=Comparable implementado pero 'equals()' no anulado
comparable.implemented.but.equals.not.overridden.fix.add.note.name=Se agregó la nota de JavaDoc 'Ordenado inconsistente con signos iguales'
comparable.implemented.but.equals.not.overridden.fix.generate.equals.name=Crear el método 'equals()'
comparable.implemented.but.equals.not.overridden.problem.descriptor=Class <code>#ref</code> implementa 'java.lang.Comparable' pero no anula 'equals()' #loc
comparator.not.serializable.display.name=Clase de comparador no declarada serializable
comparator.not.serializable.problem.descriptor=La clase de comparador <code>#ref</code> no se declara como serializable #loc
comparison.of.short.and.char.display.name=Comparación de valores 'short' y 'char'
comparison.of.short.and.char.problem.descriptor=Comparación de igualdad <code>#ref</code> de valores cortos y char #loc
comparison.to.nan.display.name=Comparación con Double.NaN o Float.NaN
comparison.to.nan.problem.descriptor1=La comparación con <code>#ref</code> es siempre falsa #loc
comparison.to.nan.problem.descriptor2=La comparación con <code>#ref</code> es siempre verdadera #loc
concrete.class.method.parameter.problem.descriptor=Parámetro ''{0}'' de la clase concreta <code>#ref</code> #loc
concrete.class.use.display.name=Use of concrete class
condition.signal.display.name=Llamada a 'signal()' en lugar de 'signalAll()'
condition.signal.problem.descriptor=<code>#ref</code> probablemente debería reemplazarse con 'signalAll()' #loc
conditional.can.be.pushed.inside.expression.display.name=El condicional se puede insertar dentro de la expresión de la rama
conditional.can.be.pushed.inside.expression.option=Ignorar cuando condicional será el único argumento de una llamada de método
conditional.can.be.pushed.inside.expression.problem.descriptor=La expresión condicional se puede insertar dentro de la rama #loc
conditional.can.be.pushed.inside.expression.quickfix=Insertar expresión condicional dentro de la rama
conditional.expression.display.name=Expresión condicional (? :)
conditional.expression.expression.context.option=Ignorar lugares donde una declaración if no es posible
conditional.expression.option=Ignorar para asignaciones simples y devoluciones
conditional.expression.problem.descriptor=Expresión condicional <code>#ref</code> #loc
conditional.expression.quickfix=Reemplazar con la declaración 'if'
conditional.expression.with.identical.branches.collapse.quickfix=Contraer expresión condicional
conditional.expression.with.identical.branches.display.name=Expresión condicional con ramas idénticas
conditional.expression.with.identical.branches.problem.descriptor=Expresión condicional <code>#ref</code> con ramas idénticas #loc
confusing.else.option=Informar que falta la sintaxis después de la declaración '' if ''
confusing.floating.point.literal.change.quickfix=Cambiar a forma canónica
confusing.floating.point.literal.display.name=Confuso literal de punto flotante
confusing.floating.point.literal.option=Ignorar literales de punto flotante en notación científica
confusing.floating.point.literal.problem.descriptor=Confuso literal de coma flotante <code>#ref</code> #loc
confusing.main.method.display.name=Método 'main()' confuso
confusing.main.method.problem.descriptor=Método llamado <code>#ref</code> sin firma 'public static void main (String [])' #loc
confusing.octal.escape.sequence.display.name=Secuencia de escape octal confusa
confusing.octal.escape.sequence.problem.descriptor=Secuencia de escape octal <code>#ref</code> seguida inmediatamente por el dígito #loc
connection.opened.not.safely.closed.display.name=Conexión abierta pero no cerrada de forma segura
consider.static.final.fields.constant.option=Los campos '' static final '' se consideran constantes
constant.assert.condition.display.name=la condición de la declaración 'assert' es constante
constant.assert.condition.problem.descriptor=Afirmar la condición <code>#ref</code> es constante #loc
constant.conditional.expression.display.name=Expresión condicional constante
constant.conditional.expression.problem.descriptor=<code>#ref</code> se puede simplificar a ''{0}'' #loc
constant.conditional.expression.simplify.quickfix=Simplificar
constant.conditional.expression.simplify.quickfix.sideEffect=Extrae efectos secundarios y simplifica
constant.declared.in.abstract.class.display.name=Constante declarada en clase abstracta
constant.declared.in.abstract.class.problem.descriptor=Constante <code>#ref</code> declarada en la clase abstracta #loc
constant.declared.in.interface.display.name=Constante declarada en la interfaz
constant.declared.in.interface.problem.descriptor=Constante <code>#ref</code> declarada en la interfaz #loc
constant.for.zero.length.array.display.name=Uso innecesario de matriz de longitud cero
constant.for.zero.length.array.problem.descriptor=La matriz de longitud cero se puede cambiar a constante #loc
constant.for.zero.length.array.quickfix.family=Reemplazar con constante
constant.junit.assert.argument.display.name=Argumento de aserción constante
constant.junit.assert.argument.problem.descriptor=El argumento <code>\#ref</code> es una constante.\#loc
constant.math.call.display.name=Llamada constante a 'java.lang.Math'
constant.math.call.problem.descriptor=La llamada constante a <code>#ref()</code> se puede simplificar #loc
constant.naming.convention.element.description=Constante
constant.on.lhs.of.comparison.options.item.left=Izquierda
constant.on.lhs.of.comparison.options.item.right=Derecha
constant.on.lhs.of.comparison.problem.descriptor=Constante <code>#ref</code> en el lado izquierdo de la comparación #loc
constant.on.rhs.of.comparison.problem.descriptor=Constante <code>#ref</code> en el lado derecho de la comparación #loc
constant.on.side.of.comparison.display.name=Constante en el lado equivocado de la comparación
constant.value.variable.use.display.name=Uso de variable cuyo valor se sabe que es constante
constant.value.variable.use.problem.descriptor=Se sabe que el valor de <code>#ref</code> es constante #loc
constant.with.mutable.field.naming.convention.element.description=Constante con tipo de campo mutable
constructor.visibility.option=Ignorar constructores con visibilidad:
continue.or.break.from.finally.block.display.name=continuar' o 'romper' dentro del bloque 'finalmente
continue.or.break.from.finally.block.problem.descriptor=<code>#ref</code> dentro del bloque 'finalmente' #loc
continue.statement.display.name=declaración 'continue'
continue.statement.with.label.display.name=declaración 'continue' con etiqueta
continue.statement.with.label.problem.descriptor=<code>#ref</code> declaración con etiqueta #loc
control.flow.statement.without.braces.add.quickfix=Agregar llaves a la declaración
control.flow.statement.without.braces.display.name=Declaración de flujo de control sin llaves
control.flow.statement.without.braces.message=Agregar llaves a la declaración ''{0}''
control.flow.statement.without.braces.problem.descriptor=<code>{0}</code> sin llaves #loc
convert.double.unary.quickfix=Replace with ''{0}{1}''
convert.empty.anonymous.to.new.fix.family.name=Eliminar '{}'
convert.octal.literal.to.decimal.literal.quickfix=Convertir literal octal en literal decimal
convert.octal.literals.to.decimal.literals.quickfix=Convertir literales octales en literales decimales
convert.system.out.to.log.call.family.name=Convert 'System.out' call to log call
convert.system.out.to.log.call.name=Convert ''System.out'' call to call of ''{0}''
convert.to.variable.arity.method.quickfix=Convierta al método vararg.
copy.constructor.misses.field.display.name=Falta un campo en el constructor de copias
copy.constructor.misses.field.problem.descriptor.1=El constructor de copia no copia el campo ''{0}''.
copy.constructor.misses.field.problem.descriptor.2=El constructor de copia no copia los campos ''{0}'', ''{1}''.
copy.constructor.misses.field.problem.descriptor.3=El constructor de copia no copia los campos ''{0}'', ''{1}'', ''{2}''.
copy.constructor.misses.field.problem.descriptor.many=El constructor de copia no copia los campos {0}.
covariant.equals.display.name=Covariante 'igual()'
covariant.equals.problem.descriptor=<code>#ref()</code> debe tomar 'Objeto' como argumento #loc
create.default.branch.fix.family.name='' predeterminado '' insertar rama
create.missing.enum.switch.branches.fix.family.name=Create missing enum switch branches
create.missing.record.deconstructions.switch.branches.fix.family.name=Create missing record deconstruction switch branches
create.missing.sealed.class.switch.branches.fix.family.name=Create missing sealed class switch branches
create.missing.switch.branch=Crear rama de interruptor faltante ''{0}''
create.missing.switch.branches=Crear ramas faltantes\: {0}
create.null.branch.fix.family.name=Insert 'null' branch
create.package.info.java.family.name= paquete-info.java 
cstyle.array.method.declaration.problem.descriptor=Declaración de matriz de estilo C del tipo de retorno del método <code>#ref()</code> #loc
cstyle.array.variable.declaration.problem.descriptor=Declaración de matriz de estilo C de {0, choice, 1#campo | 2#parámetro | 3#componente de registro | 4#variable local} <code>#ref</code> #loc
custom.classloader.display.name=Cargador de clases personalizado
custom.classloader.problem.descriptor=Clase ClassLoader personalizada <code>#ref</code> #loc
custom.security.manager.display.name=Administrador de seguridad personalizado
custom.security.manager.problem.descriptor=Clase de SecurityManager personalizada <code>#ref</code> #loc
cyclic.class.dependency.1.problem.descriptor=La clase ''{0}'' depende cíclicamente de la clase ''{1}''
cyclic.class.dependency.2.problem.descriptor=La clase ''{0}'' depende cíclicamente de las clases ''{1}'' y ''{2}''
cyclic.class.dependency.display.name=Dependencia de clase cíclica
cyclic.class.dependency.ignore.in.same.file=Ignore cycles between classes located in the same file
cyclic.class.dependency.problem.descriptor=La clase ''{0}'' depende cíclicamente de {1} otras clases
cyclic.package.dependency.1.problem.descriptor=El paquete ''{0}'' depende cíclicamente del paquete ''{1}''
cyclic.package.dependency.2.problem.descriptor=El paquete ''{0}'' depende cíclicamente de los paquetes ''{1}'' y ''{2}''
cyclic.package.dependency.display.name=Dependencia cíclica del paquete
cyclic.package.dependency.problem.descriptor=El paquete ''{0}'' depende cíclicamente de {1} otros paquetes
cyclomatic.complexity.display.name=Método demasiado complejo
cyclomatic.complexity.limit.option=Límite de complejidad ciclomática:
cyclomatic.complexity.problem.descriptor=Método demasiado complejo <code>#ref()</code> (complejidad ciclomática={0}) #loc
dangling.javadoc.convert.quickfix=Reemplazar con comentarios de bloque.
dangling.javadoc.delete.quickfix=Eliminar comentarios colgantes.
dangling.javadoc.display.name=Comentarios Javadoc colgado
dangling.javadoc.ignore.copyright.option=Ignore file header comment in JavaDoc format
dangling.javadoc.problem.descriptor=Comentarios ilegales de Javadoc\#loc
debug.level.and.lower.option=Por debajo del nivel de depuración
declare.collection.as.interface.fix.family.name=Tipo débil
declare.collection.as.interface.quickfix=Debilitado a ''{0}''
default.not.last.case.in.switch.display.name=default' no es el último caso en la declaración 'switch
default.not.last.case.in.switch.problem.descriptor=<code>#ref</code> rama no es el último caso en 'switch'{0}#loc
default.tostring.call.display.name=Llamar al valor predeterminado 'toString()'
default.tostring.call.problem.descriptor=Llamar al 'toString()' predeterminado en <code>#ref</code> #loc
delete.catch.section.fix.family.name=eliminar declaración de captura
delete.catch.section.quickfix=Eliminar la sección 'captura'
delete.import.quickfix=Eliminar importación innecesaria
delete.unnecessary.statement.fix.family.name=Eliminar declaraciones duplicadas
deserializable.class.in.secure.context.problem.descriptor=La clase <code>#ref</code> puede ser deserializada, comprometiendo la seguridad #loc
design.for.extension.display.name=Diseño para extensión
design.for.extension.problem.descriptor=El método <code>#ref()</code> puede ser anulado y su funcionalidad ignorada #loc
diamond.can.be.replaced.with.explicit.type.arguments.name=Puede reemplazar diamantes con argumentos de tipo explícito
diamond.can.be.replaced.with.explicit.type.arguments.quickfix=Reemplace '' <> '' con argumentos de tipo explícito.
disjoint.package.display.name=Paquete con gráfico de dependencia disjunto
disjoint.package.problem.descriptor=El paquete{0}se puede descomponer en {1} paquetes independientes
divide.by.zero.display.name=Dividir por cero
divide.by.zero.problem.descriptor=División por cero #loc
dollar.sign.in.name.display.name=Uso de '$' en el identificador
dollar.sign.in.name.problem.descriptor=El identificador <code>#ref</code> contiene '$' #loc
double.brace.initialization.display.name=Inicializar llaves dobles
double.brace.initialization.quickfix=Reemplazar con inicialización normal.
double.checked.locking.display.name=Bloqueo con doble verificación
double.checked.locking.fix.family.name=Establecer campo como volátil
double.checked.locking.problem.descriptor=Bloqueo con doble verificación #loc
double.checked.locking.quickfix=Hacer ''{0}'' volátil.
double.literal.may.be.float.literal.display.name='' double '' conversión literal a '' float '' puede convertirse en '' float '' literal
double.negation.display.name=Doble negación
double.negation.problem.descriptor=Doble negación en <code>#ref</code> #loc
double.negation.quickfix=Eliminar la doble negación
drivermanager.call.display.name=Uso de DriverManager para obtener la conexión JDBC
drivermanager.call.problem.descriptor=Llamar a <code> DriverManager. #ref()</code> #loc
dumpstack.call.display.name=Llamada a 'Thread.dumpStack()'
dumpstack.call.problem.descriptor=Llamada a <code> Thread. #ref()</code> probablemente debería reemplazarse con un registro más robusto #loc
duplicate.condition.display.name=Condición duplicada
duplicate.condition.ignore.method.calls.option=Ignorar condiciones con efectos secundarios
duplicate.condition.ignore.method.calls.option.description=If checked, conditions with potential side effects (for example, unknown method calls) will not be reported. Methods that are known to produce side effects will not be reported in any case.
duplicate.condition.problem.descriptor=Condición duplicada <code>#ref</code> #loc
dynamic.regex.replaceable.by.compiled.pattern.display.name=La expresión regular dinámica podría ser reemplazada por un patrón compilado
dynamic.regex.replaceable.by.compiled.pattern.problem.descriptor=<code>#ref()</code> podría reemplazarse con la construcción compilada 'java.util.regex.Pattern' #loc
dynamic.regex.replaceable.by.compiled.pattern.quickfix=Reemplazar con una llamada al método de la constante compilada 'Patrón'
empty.anonymous.class.problem.descriptor=La clase anónima está vacía #loc
empty.class.display.name=Clase vacía redundante
empty.class.file.without.class.problem.descriptor=El archivo Java no declara ninguna clase #loc
empty.class.ignore.parameterization.option=Ignorar clase si parametrización de supertipo
empty.class.initializer.delete.quickfix=Eliminar inicializador de clase vacío
empty.class.initializer.display.name=Inicializador de clase vacía
empty.class.initializer.problem.descriptor=Inicializador de clase vacía #loc
empty.class.problem.descriptor=La clase <code>#ref</code> está vacía #loc
empty.enum.problem.descriptor=Enum <code>#ref</code> está vacío #loc
empty.finally.block.display.name=Bloque 'finalmente' vacío
empty.finally.block.problem.descriptor=Bloque <code>#ref</code> vacío #loc
empty.synchronized.statement.display.name=Declaración vacía 'sincronizada'
empty.synchronized.statement.problem.descriptor=Vacío <code>#ref</code> declaración #loc
empty.try.block.display.name=Bloque vacío 'try'
empty.try.block.problem.descriptor=Bloque <code>#ref</code> vacío #loc
encapsulate.variable.fix.family.name=Encapsular campos
encapsulate.variable.quickfix=Encapsular campo ''{0}''
enum.singleton.problem.descriptor=Enum <code>#ref</code> es un singleton #loc
enum.switch.statement.which.misses.cases.display.name=Enum 'switch' statement que no usa mayúsculas y minúsculas
enum.switch.statement.which.misses.cases.option=Ignorar declaraciones de cambio con una rama predeterminada
enum.switch.statement.which.misses.cases.problem.descriptor=<code>#ref</code> declaración en el tipo de enumeración ''{0}'' casos de error: {1} #loc
enum.switch.statement.which.misses.cases.problem.descriptor.single=<code>#ref</code> declaración sobre el tipo de enumeración ''{0}'' falta caso ''{1}'' #loc
enumerated.class.display.name=Clase enumerada
enumerated.class.naming.convention.element.description=Enumeración
enumerated.class.problem.descriptor=Clase enumerada <code>#ref</code> #loc
enumerated.constant.naming.convention.element.description=Constante enumerada
enumeration.can.be.iteration.display.name=La enumeración puede ser iteración
enumeration.can.be.iteration.problem.descriptor=<code>#ref()</code> se puede reemplazar con ''{0}'' construct #loc
enumeration.can.be.iteration.quickfix=Reemplazar con la construcción 'Iterator'
equality.to.safe.equals.quickfix=Reemplazar '==' con nulo seguro 'equals()'
equals.between.inconvertible.types.display.name='equals()' entre objetos de tipos inconvertibles
equals.between.inconvertible.types.mutual.subclass.option=Advertir si no se encuentra ninguna subclase mutua
equals.between.inconvertible.types.no.mutual.subclass.problem.descriptor=No se encontró ninguna clase que sea un subtipo de ''{0}'' y ''{1}'' #loc
equals.between.inconvertible.types.problem.descriptor=<code>#ref</code> entre objetos de tipos inconvertibles ''{0}'' y ''{1}'' #loc
equals.called.on.array.display.name='equals()' llamado en la matriz
equals.called.on.array.problem.descriptor=<code>#ref()</code> entre matrices probablemente debería ser 'Arrays.equals()' #loc
equals.called.on.enum.constant.display.name='equals()' llamado en el valor Enum
equals.called.on.enum.constant.problem.descriptor=<code>#ref()</code> llamado en el valor Enum #loc
equals.called.on.suspicious.object.display.name='equals()' llamado en StringBuilder
equals.called.on.suspicious.object.fix.family.name=Replace with a comparison of representative values
equals.called.on.suspicious.object.fix.name=Replace with a comparison of ''{0}()'' call results
equals.called.on.suspicious.object.problem.descriptor=Llamada sospechosa '' es igual a '' en el objeto ''{0}''
equals.doesnt.check.class.parameter.display.name=método 'equals()' que no verifica la clase de parámetro
equals.doesnt.check.class.parameter.problem.descriptor=<code>#ref()</code> debe verificar la clase de su parámetro #loc
equals.replaceable.by.objects.call.display.name= equals()'' puede ser reemplazado por '' Objects.equals()
equals.replaceable.by.objects.call.problem.descriptor=Puede reemplazar <code>\#ref</code> con la expresión '' Objects.equals()''.\#loc
equals.replaceable.by.objects.check.not.null.option='' a \!\= null \\&\\& a.equals (b) '' para resaltar una expresión
equals.with.itself.display.name=Llama a '' equals()'' en ti mismo
equals.with.itself.option=Warn about test assertions only on final library class types or primitives
equals.with.itself.problem.descriptor=Llame a <code>\#ref()</code> en usted mismo
error.rethrown.display.name='java.lang.Error' no relanzado
error.rethrown.problem.descriptor=Error <code>#ref</code> no reiniciado #loc
exception.from.catch.which.doesnt.wrap.display.name='lanzar' dentro del bloque 'captura' que ignora la excepción detectada
exception.from.catch.which.doesnt.wrap.problem.descriptor=<code>#ref</code> dentro del bloque 'catch' ignora la excepción detectada #loc
exception.from.catch.which.doesntwrap.ignore.cant.wrap.option=Ignorar si la excepción lanzada no puede envolver una excepción
exception.from.catch.which.doesntwrap.ignore.option=Ignorar si se usa el resultado de la llamada al método de excepción
exception.name.doesnt.end.with.exception.display.name=El nombre de la clase de excepción no termina con 'Exception'
exception.name.doesnt.end.with.exception.problem.descriptor=El nombre de la clase de excepción <code>#ref</code> no termina con 'Exception' #loc
exception.package.display.name=Paquete de excepción
exception.package.problem.descriptor=El paquete ''{0}'' contiene solo clases de excepción
explicit.array.to.string.problem.descriptor=Llamada a '#ref()' en la matriz #loc
expression.can.be.replaced.no.quotes.problem.descriptor={0} se puede reemplazar con {1}
expression.can.be.replaced.problem.descriptor=<code>#ref</code> se puede reemplazar con ''{0}'' #loc
expression.may.be.factorized.display.name=Expression can be factorized
extend.exception.fix.family.name=Escribir extensión de clase como '' excepción ''
extended.for.statement.display.name=Extendido 'para' declaración
extended.for.statement.problem.descriptor=Extendida <code>#ref</code> declaración #loc
extended.for.statement.replace.quickfix=Reemplazar con la antigua declaración 'for'
extends.annotation.display.name=La clase extiende la interfaz de anotación
extends.annotation.interface.problem.descriptor=Interfaz ''{0}'' extiende la interfaz de anotaciones <code>#ref</code> #loc
extends.annotation.problem.descriptor=Class ''{0}'' implementa la interfaz de anotación <code>#ref</code> #loc
extends.concrete.collection.display.name=La clase extiende explícitamente una clase de Colección
extends.concrete.collection.problem.descriptor=Class <code>#ref</code> extiende explícitamente ''{0}'' #loc
extends.object.display.name=La clase extiende explícitamente 'java.lang.Object'
extends.object.problem.descriptor=Class <code>#ref</code> extiende explícitamente 'java.lang.Object' #loc
extends.object.remove.quickfix=Eliminar el 'objeto extendido' redundante
extends.thread.display.name=La clase extiende directamente 'java.lang.Thread'
extends.thread.problem.descriptor=Class <code>#ref</code> extiende directamente 'java.lang.Thread' #loc
extends.throwable.display.name=La clase extiende directamente '' java.lang.Throwable ''
extends.throwable.problem.descriptor=La clase <code>\#ref</code> extiende directamente '' java.lang.Throwable ''.\#loc
externalizable.with.serialization.methods.display.name=Clase externalizable con 'readObject()' o 'writeObject()'
externalizable.with.serialization.methods.problem.descriptor.both=La clase externalizable <code>#ref</code> define 'readObject()' y 'writeObject()' #loc
externalizable.with.serialization.methods.problem.descriptor.read=La clase externalizable <code>#ref</code> define 'readObject()' #loc
externalizable.with.serialization.methods.problem.descriptor.write=La clase externalizable <code>#ref</code> define 'writeObject()' #loc
externalizable.without.public.no.arg.constructor.display.name='' public '' clase externalizable sin constructor sin argumentos
externalizable.without.public.no.arg.constructor.problem.descriptor=La clase externalizable <code>\#ref</code> no tiene un constructor "público" sin argumentos.\#loc
extract.method.quickfix=Método de extracción
extract.parameter.as.local.variable.quickfix=Extraer parámetro como variable local
fallthru.in.switch.statement.display.name=Fallthrough en la declaración 'switch'
fallthru.in.switch.statement.problem.descriptor=Fallthrough in 'switch' statement #loc
fallthru.in.switch.statement.quickfix=Agregar 'descanso'
feature.envy.display.name=Característica envidia
feature.envy.problem.descriptor=Clase ''{0}'' a la que se accede repetidamente en el método <code>#ref()</code> #loc
field.accessed.synchronized.and.unsynchronized.display.name=Campo al que se accede tanto en contextos sincronizados como no sincronizados
field.accessed.synchronized.and.unsynchronized.option=Los getters y setters simples también se consideran accesos de campo
field.accessed.synchronized.and.unsynchronized.problem.descriptor=Se accede al campo <code>#ref</code> en contextos sincronizados y no sincronizados #loc
field.count.inspection.include.constant.fields.in.count.checkbox=Incluir campos constantes en el recuento
field.count.inspection.include.enum.constants.in.count=Incluir constantes de enumeración en el recuento
field.count.inspection.static.final.fields.count.as.constant.checkbox=los campos 'static final' cuentan como constantes
field.has.setter.but.no.getter.display.name=El campo tiene un setter pero no un getter
field.has.setter.but.no.getter.problem.descriptor=Field <code>#ref</code> tiene setter pero no getter #loc
field.has.static.modifier.problem.descriptor=El campo ''{0}'' tiene el modificador '' estático ''
field.incorrect.type.problem.descriptor=El campo ''{0}'' no tiene el tipo ''{1}''.
field.may.be.final.display.name=El campo puede ser 'final'
field.may.be.final.problem.descriptor=El campo <code>#ref</code> puede ser #loc 'final'
field.may.be.static.display.name=El campo puede ser 'estático'
field.may.be.static.problem.descriptor=El campo <code>#ref</code> puede ser #loc 'estático'
field.missing.volatile.modifier.problem.descriptor=El campo ''{0}'' no tiene el modificador '' volatile ''.
field.name.hides.in.superclass.display.name=El nombre del campo oculta el campo en la superclase
field.name.hides.in.superclass.ignore.option=Ignorar campos no accesibles
field.name.hides.in.superclass.ignore.static.field.option=Ignorar campos estáticos que ocultan campos estáticos
field.name.hides.in.superclass.problem.descriptor=Field <code>#ref</code> oculta el campo en la superclase #loc
field.naming.convention.display.name=Convención de nomenclatura de campos
field.not.found.in.class.problem.descriptor=El campo con el nombre ''{0}'' no se pudo encontrar en la clase ''{1}''.
final.class.display.name=clase 'final'
final.class.problem.descriptor=Clase declarada <code>#ref</code> #loc
final.method.display.name=método 'final'
final.method.in.final.class.display.name=método 'final' en la clase 'final'
final.method.in.final.class.problem.descriptor=Método declarado <code>#ref</code> en la clase 'final' #loc
final.method.problem.descriptor=Método declarado <code>#ref</code> #loc
final.private.method.display.name=método 'privado' declarado 'final'
final.private.method.problem.descriptor=método 'privado' declarado <code>#ref</code> #loc
final.static.method.display.name=método 'estático' declarado 'final'
final.static.method.problem.descriptor=método 'estático' declarado <code>#ref</code> #loc
finalize.called.explicitly.display.name='finalize()' llamado explícitamente
finalize.called.explicitly.problem.descriptor=<code>#ref()</code> llamado explícitamente #loc
finalize.declaration.display.name=declaración 'finalize()'
finalize.declaration.problem.descriptor=<code>#ref()</code> declarado #loc
finalize.not.declared.protected.display.name=finalize()' no declarado 'protegido
finalize.not.declared.protected.problem.descriptor=<code>#ref()</code> no declarado 'protegido' #loc
finally.block.cannot.complete.normally.display.name='finalmente' bloque que no se puede completar normalmente
finally.block.cannot.complete.normally.problem.descriptor=<code>#ref</code> el bloque no se puede completar normalmente #loc
fix.add.argument.family.name=Agregar argumento
fix.add.argument.name=''{0}'' Agregar argumento
fix.eliminate.folded.if.present.description=Puede eliminar la llamada '' ifPresent()'' doblada
fix.eliminate.folded.if.present.name=Eliminar llamada '' ifPresent()'' colapsada
fix.replace.map.with.flat.map.description=Puede reemplazar ''map()'' por ''flatMap()''.
flip.comparison.quickfix=Comparación de volteo
floating.point.equality.display.name=Comparación de igualdad de punto flotante
floating.point.equality.problem.descriptor=<code>#ref</code>: valores de punto flotante comparados para la igualdad exacta #loc
for.can.be.foreach.display.name=bucle 'for' reemplazable con bucle 'for' mejorado
for.can.be.foreach.fix.no.indexed=Do not report indexed 'java.util.List' loops
for.can.be.foreach.option=Informe indexado bucle '' java.util.List ''
for.can.be.foreach.option2=No reportar iteraciones de colección sin tipo
for.can.be.foreach.problem.descriptor=<code>#ref</code> bucle reemplazable con mejorado 'for' #loc
for.loop.replaceable.by.while.display.name=El bucle 'for' se puede reemplazar con el bucle 'while'
for.loop.replaceable.by.while.ignore.option=Ignorar 'infinito' para bucles sin condiciones
for.loop.replaceable.by.while.problem.descriptor=<code>#ref</code> La declaración de bucle se puede reemplazar por el bucle 'while' #loc
for.loop.with.missing.component.collection.loop.option=Ignorar iteraciones de colección
for.loop.with.missing.component.display.name=bucle 'for' con componentes faltantes
for.loop.with.missing.component.problem.descriptor1=La declaración <code>#ref</code> carece de inicializador #loc
for.loop.with.missing.component.problem.descriptor2=La declaración <code>#ref</code> carece de la condición #loc
for.loop.with.missing.component.problem.descriptor3=La declaración <code>#ref</code> carece de actualización #loc
for.loop.with.missing.component.problem.descriptor4=La declaración <code>#ref</code> carece de inicializador y condición #loc
for.loop.with.missing.component.problem.descriptor5=La declaración <code>#ref</code> carece de inicializador y actualización #loc
for.loop.with.missing.component.problem.descriptor6=La declaración <code>#ref</code> carece de condición y actualiza #loc
for.loop.with.missing.component.problem.descriptor7=La declaración <code>#ref</code> carece de inicializador, condición y actualización #loc
foreach.replace.quickfix=Reemplazar con mejorado 'for'
format.string.error.duplicate.flag=bandera duplicada ''{0}'' en ''{1}''
format.string.error.flags.not.allowed={2, choice, 1#flag | 1 <flags} ''{0}'' no permitido en ''{1}''
format.string.error.illegal.flag.combination=combinación de bandera ilegal ''{0}'' y ''{1}'' en ''{2}''
format.string.error.illegal.position.specifier=especificador de posición ilegal ''{0}'' en ''{1}''
format.string.error.invalid.precision=precisión no válida especificada en ''{0}''
format.string.error.left.justify.no.width=indicador de justificación a la izquierda '' - '' usado pero ancho no especificado en ''{0}''
format.string.error.precision.not.allowed=precisión (''{0}'') no permitido en ''{1}''
format.string.error.previous.element.not.found=bandera anterior '' <'' utilizada pero no se encontró un especificador de formato anterior para ''{0}''
format.string.error.unexpected.flag=carácter inesperado ''{0}'' en ''{1}''
format.string.error.unknown.conversion=conversión desconocida en ''{0}''
format.string.error.unnecessary.position.specifier=especificador de posición de argumento innecesario ''{0}'' en ''{1}''
format.string.error.width.not.allowed=width (''{0}'') no permitido en ''{1}''
format.string.error.zero.padding.no.width=marca de relleno cero ''0'' usada pero ancho no especificado en ''{0}''
gc.call.display.name=Llamadas a 'System.gc()' o 'Runtime.gc()'
gc.call.problem.descriptor=<code>#ref</code> no se debe llamar en el código de producción #loc
generate.to.string.quick.fix.family.name=toString ()
generate.to.string.quick.fix.text=toString() 생성
groups.of.modules.loaded.together.description=Cada línea especifica una lista separada por comas de los nombres de los módulos que se sabe que son cargados por el mismo cargador de clases y, por lo tanto, no se debe informar el acceso a los miembros privados del paquete entre dichos módulos.
groups.of.modules.loaded.together.label=Grupos de módulos que se cargan juntos:
hardcoded.file.separator.display.name=Separador de archivos codificado
hardcoded.file.separator.ignore.methods.option=Ignore arguments for the following methods:
hardcoded.file.separator.include.option=Incluir "ejemplo/*" en tipos de medios MIME reconocidos
hardcoded.file.separator.problem.descriptor=Separador de archivos codificado <code>#ref</code> #loc
hardcoded.line.separator.display.name=Separador de línea codificado
hardcoded.line.separator.problem.descriptor=Separador de línea codificado <code>#ref</code> #loc
hibernate.resource.opened.not.closed.display.name=Recurso de hibernación abierto pero no cerrado de forma segura
html.tag.can.be.javadoc.tag.display.name=Puede reemplazar <code>...</code> con {@code...}
html.tag.can.be.javadoc.tag.problem.descriptor=<code>\#ref... \\& lt;/code \\& gt;</code> a '' {@code...} ' 'se puede reemplazar con\#loc
i.o.resource.opened.not.closed.display.name=Recurso de E/S abierto pero no cerrado de forma segura
if.can.be.assertion.name=Puede reemplazar la sintaxis con '' assert '' o '' Objects.requireNonNull ''
if.can.be.assertion.replace.with.assertion.quickfix=Reemplace la sintaxis con la declaración '' assert ''.
if.can.be.assertion.replace.with.objects.requirenonnull.quickfix=Reemplace la sintaxis por '' Objects.requireNonNull()''.
if.can.be.switch.display.name= if '' puede ser reemplazado por ''switch
if.can.be.switch.enum.option=Sugerir cambio en enumeración
if.can.be.switch.int.option=Sugerir un cambio de números
if.can.be.switch.minimum.branch.option=Número mínimo de ramas condicionales '' if ''\:
if.can.be.switch.null.safe.option=null sugerido solo en expresiones seguras
if.can.be.switch.problem.descriptor=Puede reemplazar la instrucción <code>\#ref</code> por una instrucción ''switch''.\#loc
if.may.be.conditional.problem.descriptor=<code>#ref</code> podría reemplazarse con la expresión condicional #loc
if.may.be.conditional.quickfix=Reemplazar con expresión condicional
if.may.be.factorized.problem.descriptor=<code>#ref</code> can be factorized #loc
if.may.be.factorized.quickfix=Replace with factorized expression
if.statement.with.identical.branches.display.name=declaración 'if' con partes comunes
if.statement.with.too.many.branches.display.name=declaración 'if' con demasiadas ramas
if.statement.with.too.many.branches.max.option=Número máximo de ramas:
if.statement.with.too.many.branches.problem.descriptor=<code>#ref</code> tiene demasiadas ramas ({0}) #loc
ignore.accesses.from.equals.method=Ignorar accesos desde el método 'equals()'
ignore.accesses.from.the.same.class=Ignorar accesos de la misma clase
ignore.anonymous.inner.classes=Ignorar clases internas anónimas
ignore.boolean.methods.in.an.interface.option=Ignorar métodos booleanos en una interfaz @&
ignore.branches.of.switch.statements=Ignorar ramas de declaraciones 'switch'
ignore.calls.to.property.getters=Ignorar llamadas a captadores de propiedades
ignore.calls.to.static.methods=Ignorar llamadas a métodos estáticos
ignore.classes.annotated.by=Ignorar las siguientes clases anotadas
ignore.classes.in.hierarchy.column.name=Ignorar subclases de
ignore.cloneable.option=Ignorar 'java.lang.Cloneable'
ignore.constructor.method.references=Ignorando las referencias al método del constructor que crean AutoCloseable
ignore.enhanced.for.loop.statements=Ignorar bucles mejorados para
ignore.equals.hashcode.and.tostring=Ignorar los métodos 'equals()', 'hashCode()' y 'toString()'
ignore.exceptions.declared.on.library.override.option=Ignore las excepciones declaradas en los métodos que anulan un método &library
ignore.for.equals.methods.option=Ignorar los métodos '&equals()'
ignore.getters.returning.resource=Ignorar captadores que devuelven recursos
ignore.guard.clauses.option=Ignorar y proteger cláusulas
ignore.if.annotated.by=Ignorar si está anotado con
ignore.in.module.statements.option=Ignorar en las declaraciones del módulo Java 9
ignore.instanceof.on.library.classes=Ignorar instancia de clases de biblioteca
ignore.methods.in.anonymous.classes=Ignorar métodos en clases anónimas
ignore.methods.overriding.super.method=Ignorar el mét&odo para anular/implementar un súper método
ignore.methods.with.boolean.return.type.option=Ignorar métodos con el tipo de retorno 'java.lang. &Boolean'
ignore.overflowing.byte.casts.option=Ignorar conversiones de int 128-255 a byte
ignore.parentheses.around.single.no.formal.type.lambda.parameter=Ignore los paréntesis que rodean los parámetros lambda de tipo único sin escribir
ignore.private.methods.option=Ignorar la asignación y devolución de métodos privados
ignore.serializable.option=Ignorar 'java.io.Serializable'
ignore.single.field.static.imports.option=Ignorar importaciones estáticas individuales y de campo
ignore.single.method.static.imports.option=Ignorar importaciones estáticas de un solo &método
ignore.trivial.finalizers.option=Ignorar las implementaciones triviales de 'finalize()'
ignored.autocloseable.types.label=Ignored AutoCloseable resource types:
ignored.class.hierarchies.border.title=Ignore las siguientes subclases
ignored.class.label=Ignored classes (including subclasses):
ignored.class.names=Ignorar clases (incluidas subclases)
ignored.io.resource.types.label=Ignored I/O resource types:
implicit.array.to.string.display.name=Llamar a 'toString()' en la matriz
implicit.array.to.string.fix.family.name=escribir implícitamente Array.toString ()
implicit.array.to.string.method.call.problem.descriptor=Llamada implícita a 'toString()' en la matriz devuelta por la llamada a <code>#ref</code> #loc
implicit.array.to.string.problem.descriptor=Llamada implícita a 'toString()' en la matriz <code>#ref</code> #loc
implicit.array.to.string.quickfix=Ajustar con expresión ''{0}''
implicit.call.to.super.display.name=Llamada implícita a 'super()'
implicit.call.to.super.ignore.option=Ignorar las subclases directas de 'java.lang.Object'
implicit.call.to.super.make.explicit.quickfix=Hacer una llamada a 'super()' explícita
implicit.call.to.super.problem.descriptor=Llamada implícita a 'super()' #loc
implicit.default.charset.usage.constructor.problem.descriptor=Las llamadas <code> new\#ref()</code> utilizan el juego de caracteres predeterminado de la plataforma.
implicit.default.charset.usage.display.name=Uso implícito del juego de caracteres predeterminado de la plataforma
implicit.default.charset.usage.fix.family.name=especificación del juego de caracteres UTF-8
implicit.default.charset.usage.problem.descriptor=Las llamadas <code>\#ref()</code> utilizan el juego de caracteres predeterminado de la plataforma.
implicit.numeric.conversion.assignment.problem.descriptor=Conversión numérica implícita del valor del resultado de ''{0}'' a ''{1}'' #loc
implicit.numeric.conversion.display.name=Conversión numérica implícita
implicit.numeric.conversion.ignore.char.conversion.option=Ignorar conversiones desde y hacia char
implicit.numeric.conversion.ignore.constant.conversion.option=Ignorar conversiones de constantes y literales
implicit.numeric.conversion.ignore.widening.conversion.option=Ignorar conversiones de ampliación
implicit.numeric.conversion.make.explicit.quickfix=Hacer explícita la conversión
implicit.numeric.conversion.problem.descriptor=Conversión numérica implícita de <code>#ref</code> de ''{0}'' a ''{1}'' #loc
import.display.name=Importar '*'
import.from.same.package.display.name=Importar desde el mismo paquete
import.from.same.package.problem.descriptor=Importación innecesaria desde el mismo paquete <code>#ref</code> #loc
import.problem.descriptor=Importación de paquete <code>#ref</code> #loc
include.java.system.classes.option=Incluir acoplamientos a las clases del sistema java
include.library.classes.option=Incluir acoplamientos a las clases de la biblioteca
incompatible.mask.operation.display.name=Operación de máscara bit a bit incompatible
incompatible.mask.operation.problem.descriptor.always.false=<code>#ref</code> es siempre falso #loc
incompatible.mask.operation.problem.descriptor.always.true=<code>#ref</code> es siempre verdadero #loc
incorrect.date.format.fix.family.name=Corregir formato de fecha incorrecto
increment.decrement.display.name=Valor de ++ o - usado
increment.decrement.used.as.expression.fix.family.name=Extraer con sintaxis separada
increment.decrement.used.as.expression.quickfix=Extraer ''{0}'' a una declaración separada
inequality.to.safe.not.equals.quickfix=Reemplazar '! =' con null-safe '! equals()'
infinite.loop.statement.display.name=Declaración de bucle infinito
infinite.loop.statement.problem.descriptor=<code>#ref</code> declaración no se puede completar sin lanzar una excepción #loc
infinite.recursion.display.name=Recursión infinita
infinite.recursion.problem.descriptor=El método <code>#ref()</code> se repite infinitamente y solo puede terminar lanzando una excepción #loc
info.level.and.lower.option=Nivel inferior al de información
inline.call.quickfix=Llamada en línea
inline.variable.quickfix=Variable en línea
inner.class.field.hides.outer.display.name=El campo de clase interior oculta el campo de clase exterior
inner.class.field.hides.outer.ignore.option=Ignorar los campos externos no visibles desde la clase interna
inner.class.field.hides.outer.problem.descriptor=El campo de clase interior <code>#ref</code> oculta el campo de clase exterior #loc
inner.class.may.be.static.display.name=La clase interna puede ser 'estática'
inner.class.may.be.static.problem.descriptor=La clase interna <code>#ref</code> puede ser 'estática' #loc
inner.class.on.interface.display.name=Clase interna de interfaz
inner.class.on.interface.ignore.option=Ignorar interfaces internas de interfaces
inner.class.on.interface.problem.descriptor=La interfaz ''{0}'' tiene una clase interna <code>#ref</code> #loc
inner.class.referenced.via.subclass.display.name=Clase interna referenciada a través de subclase
inner.class.referenced.via.subclass.problem.descriptor=Clase interna <code>\#ref</code> declarada en la clase ''{0}'' pero subclase ''{1}'' Referenciada a través de\#loc
inner.class.referenced.via.subclass.quickfix=Optimice el acceso a las clases internas.
inner.class.too.deeply.nested.display.name=Clase interna demasiado anidada
inner.class.too.deeply.nested.nesting.limit.option=Límite de anidamiento:
inner.class.too.deeply.nested.problem.descriptor=<code>#ref</code> está demasiado anidado (nivel de anidamiento={0}) #loc
inspection.autocloseable.resource.ignored.methods.title=Ignorar instancias AutoCloseable devueltas por este método
inspection.byte.array.output.stream.to.string.message=Conversión ineficiente de ByteArrayOutputStream
inspection.case.mismatch.display.name=discrepancia de casos en la operación de cadena
inspection.case.mismatch.message.arg.is.lower=El método '' {0}()'' siempre devuelve {1}. Los argumentos tienen símbolos en minúsculas, pero solo calificadores en mayúsculas
inspection.case.mismatch.message.arg.is.upper=El método '' {0}()'' siempre devuelve {1}. Los argumentos tienen símbolos en mayúsculas, pero los calificadores son solo en minúsculas
inspection.case.mismatch.message.label.is.lower=Switch branch is unreachable: the label contains a lowercase symbol while the selector is uppercase-only
inspection.case.mismatch.message.label.is.upper=Switch branch is unreachable: the label contains an uppercase symbol while the selector is lowercase-only
inspection.cast.can.be.replaced.with.variable.display.name=Cast can be replaced with variable
inspection.cast.can.be.replaced.with.variable.family.name=Replace cast with variable
inspection.cast.can.be.replaced.with.variable.message=Variable ''{0}'' can be used instead of ''{1}''
inspection.catch.ignores.exception.display.name=el bloque de captura puede ignorar las excepciones
inspection.catch.ignores.exception.empty.message=Bloque <code>\#ref</code> vacío\#loc
inspection.catch.ignores.exception.option.comments=No advertir si el bloque ''catch'' contiene comentarios
inspection.catch.ignores.exception.option.ignored.used=No advertir si la excepción '' ignore (d) '' no se ignora realmente
inspection.catch.ignores.exception.option.nonempty=No advertir si el bloque ''catch'' tiene un comentario vacío
inspection.catch.ignores.exception.unused.message=parámetro '' captura '' obsoleto <code>\#ref</code>\#loc
inspection.catch.ignores.exception.used.message=Se utilizó el parámetro ''catch'' con el nombre <code>\#ref</code>.\#loc
inspection.catch.ignores.exception.vm.ignored.message=Algunas excepciones importantes pueden ignorarse en el bloque <code>\#ref</code>.\#loc
inspection.collection.must.have.initial.capacity.initializers.option=No reportar inicializadores de campo
inspection.commented.out.code.disable.short.fragments=Do not report such short fragments
inspection.commented.out.code.display.name=Código comentado
inspection.commented.out.code.min.lines.options=Líneas mínimas de código
inspection.commented.out.code.problem.descriptor=Código comentado ({0} {0, choice, 1\#line | 1 <line})
inspection.common.if.parts.description.complete.duplicate=La declaración ''if'' se puede contraer {0}
inspection.common.if.parts.description.complete.duplicate.side.effect=La declaración 'if' se puede contraer con la extracción de efectos secundarios
inspection.common.if.parts.description.variables.only=Las variables se pueden extraer de ''if'' {0}
inspection.common.if.parts.description.whole.branch=La parte común se puede extraer quitando la rama {0}
inspection.common.if.parts.description.with.variables.extract=Las partes comunes con variables se pueden extraer de ''if'' {0}
inspection.common.if.parts.description.without.variables.extract=La parte común se puede extraer de ''if'' {0}
inspection.common.if.parts.message.complete.duplicate=Contraer la instrucción ''if'' {0}
inspection.common.if.parts.message.complete.duplicate.side.effect=Contraer la declaración "si" y extraer el efecto secundario
inspection.common.if.parts.message.variables.only=Extraer variables de ''if'' {0}
inspection.common.if.parts.message.whole.branch=Extraer parte común quitando rama {0}
inspection.common.if.parts.message.with.variables.extract=Extraer parte común con variables de ''if'' {0}
inspection.common.if.parts.message.without.variables.extract=Extraer parte común de ''if'' {0}
inspection.common.subexpression.in.switch.display.name=Common subexpression can be extracted from 'switch'
inspection.common.subexpression.in.switch.fix.family.name=Push down 'switch' expression
inspection.comparator.combinators.description=Puede ser reemplazado por una cadena Comparator
inspection.comparator.combinators.description2=puede ser reemplazado por {0}
inspection.comparator.combinators.fix.chain=Cadena comparadora
inspection.condition.covered.by.further.condition.descr=Condición '' {0} realizada por {1, choice, 1\#condition '' ''{2}'' '' | 2\#condition} 'subsiguiente '
inspection.constant.expression.display.name=La expresión constante se puede evaluar
inspection.constant.expression.fix.family.name=Calcular valor constante
inspection.constant.expression.fix.name=Calculando el valor constante de la ''{0}''
inspection.constant.expression.fix.name.short=Replace with constant value
inspection.constant.expression.message=La expresión constante se puede evaluar como ''{0}''.
inspection.constant.expression.report.compile.time=컴파일타임 상수만 보고
inspection.constant.expression.report.compile.time.description=By default, the inspection can evaluate some constants that involve Duplicar llamada al método '' compare()''
inspection.constant.expression.skip.non.literal=Don't report expressions containing references to defined constants
inspection.constant.expression.skip.non.literal.description=Ignore the expressions which contain references to non-literal operands, Report only compile-time constants
inspection.deconstruction.can.be.used.display.name=Record pattern can be used
inspection.deconstruction.can.be.used.fix.family.name=Replace with record pattern
inspection.deconstruction.can.be.used.message=Can be replaced with record pattern
inspection.empty.catch.block.generate.body=Generar cuerpo 'captura' a partir de plantilla
inspection.empty.class.ignore.subclasses.option=Ignorar {0} subclases
inspection.enhanced.for.with.record.pattern.can.be.used.components.option=Maximum number of record components to deconstruct:
inspection.enhanced.for.with.record.pattern.can.be.used.display.name=Enhanced 'for' with a record pattern can be used
inspection.enhanced.for.with.record.pattern.can.be.used.fix.family.name=Replace with a record pattern
inspection.enhanced.for.with.record.pattern.can.be.used.level.option=Nesting depth limit:
inspection.enhanced.for.with.record.pattern.can.be.used.maximum.depth.disabled=Don''t suggest for patterns with {0} and more nested patterns
inspection.enhanced.for.with.record.pattern.can.be.used.maximum.number.disabled=Don''t suggest for records with {0} or more components
inspection.enhanced.for.with.record.pattern.can.be.used.message=Can be replaced with enhanced 'for' with a record pattern
inspection.enhanced.for.with.record.pattern.can.be.used.not.used.option=Maximum number of not-used record components:
inspection.excessive.range.check.fix.family.name=Simplifique la verificación de rango excesivo
inspection.excessive.range.check.message=se puede reemplazar con ''{0}''.
inspection.explicit.chrono.field.display.name=Calls of 'java.time' methods with explicit 'ChronoField' or 'ChronoUnit' arguments can be simplified
inspection.explicit.chrono.field.family.name=Simplify calls with explicit 'ChronoField' or 'ChronoUnit' arguments
inspection.explicit.chrono.field.problem.descriptor=Calls with explicit 'ChronoField' or 'ChronoUnit' arguments call can be simplified
inspection.if.statement.missing.break.in.loop.description=Loop can be terminated after condition is met
inspection.if.statement.missing.break.in.loop.name=Puede salir del ciclo después de que se cumpla la condición.
inspection.if.statement.missing.break.in.loop.quickfix=Agregue '' break ''.
inspection.incorrect.date.format.display.name=Incorrect 'DateTimeFormat' pattern
inspection.incorrect.date.format.message.literal=Opening single quote ({0}) without following closing single quote
inspection.incorrect.date.format.message.padding=Padding modifier ''{0}'' without consecutive pattern letters
inspection.incorrect.date.format.message.reserved.character=Use of reserved character ''{0}''
inspection.incorrect.date.format.message.unpaired=Closing <code>#ref</code> without previous opening ''{0}''
inspection.incorrect.date.format.message.unsupported=Illegal pattern letter ''{0}''
inspection.incorrect.date.format.too.few.letters=Too few consecutive pattern letters ''{0}''; minimum: {1}; specified: {2}
inspection.incorrect.date.format.too.many.letters=Too many consecutive pattern letters ''{0}''; maximum: {1}; specified: {2}
inspection.incorrect.date.format.wrong.number.of.letters=Wrong number of consecutive pattern letters ''{0}''; allowed: {1}; specified: {2}
inspection.incorrect.message.format.choice.limit.incorrect=Lower bound ''{0}'' in choice pattern is incorrect
inspection.incorrect.message.format.choice.limit.not.found=Empty lower bound in choice pattern
inspection.incorrect.message.format.display.name=Incorrect 'MessageFormat' pattern
inspection.incorrect.message.format.incorrect.index=Incorrect index ''{0}''
inspection.incorrect.message.format.incorrect.order.choice=Lower bounds not in ascending order in choice pattern
inspection.incorrect.message.format.incorrect.quotes.number=Probably incorrect number of quotes, more than 1 quote will be printed
inspection.incorrect.message.format.not.found.argument=No argument for index ''{0}''
inspection.incorrect.message.format.not.found.arguments=No arguments for indexes: {0}
inspection.incorrect.message.format.not.used.argument=Argument with index ''{0}'' is not used in the pattern
inspection.incorrect.message.format.pattern={0} in message format pattern ''{1}''
inspection.incorrect.message.format.quotes.around.parameter=Placeholder ''{0}'' won''t be substituted because it is enclosed in quotes
inspection.incorrect.message.format.unclosed.brace=Unclosed brace
inspection.incorrect.message.format.unknown.format.type=Unknown format type ''{0}''
inspection.incorrect.message.format.unmatched.brace=Unmatched brace
inspection.incorrect.message.format.unpaired.quote=Unpaired quote in message pattern
inspection.list.remove.in.loop.display.name=Llamar '' List.remove()'' en bucle
inspection.list.remove.in.loop.message= List.subList (). clear()
inspection.lossy.conversion.compound.assignment.display.name=Implicit cast from ''{0}'' to ''{1}'' in compound assignment can be lossy
inspection.lossy.conversion.compound.assignment.name=Possibly lossy implicit cast in compound assignment
inspection.meta.annotation.without.runtime.description={0} debe contener @Retention (RetentionPolicy.RUNTIME).
inspection.method.call.in.loop.ignore.known.methods.option=Ignore métodos conocidos con efectos secundarios
inspection.new.object.equality.display.name=Comparar el nuevo objeto usando ''\=\= ''
inspection.new.object.equality.message=Objeto nuevo comparado mediante ''{0}''
inspection.non.strict.comparison.equality.display.name=Non-strict inequality '>=' or '<=' can be replaced with '=='
inspection.non.strict.comparison.equality.message=Can be replaced with equality
inspection.note.may.change.semantics=puede cambiar la semántica
inspection.only.one.element.used.array=Only one array element is used
inspection.only.one.element.used.display.name=Only one element is used
inspection.only.one.element.used.fix.family=Replace with an accessed element
inspection.only.one.element.used.list=Only one list element is used
inspection.only.one.element.used.string=Only one string character is used
inspection.option.ignore.as.initial.capacity=Ignorar la capacidad inicial para StringBuilders y Colecciones
inspection.option.ignore.assert=Ignorar los argumentos de descripción de la declaración de afirmación
inspection.option.ignore.constant.initializers=Ignorar para inicializadores de campos constantes
inspection.option.ignore.exceptions=Ignorar los argumentos del constructor de las subclases Throwable
inspection.option.ignore.in.annotations=Ignorar en anotaciones
inspection.option.ignore.in.hashcode=Ignorar constantes en métodos 'hashCode()'
inspection.option.ignore.in.tostring=Ignorar dentro de los métodos toString()
inspection.option.ignore.nonnls=Ignorar cuando se anota a través de @NonNls
inspection.option.ignore.system.err=Ignorar los argumentos 'System.err.print'
inspection.option.ignore.system.out=Ignorar los argumentos de 'System.out.print'
inspection.pattern.variable.can.be.used.display.name=Variable de patrón disponible
inspection.pattern.variable.can.be.used.existing.cast.message=Existing pattern variable ''{0}'' can be used instead of cast expression
inspection.pattern.variable.can.be.used.existing.fix.family.name=Replace with existing pattern variable
inspection.pattern.variable.can.be.used.existing.fix.name=Replace ''{0}'' with existing pattern variable ''{1}''
inspection.pattern.variable.can.be.used.existing.message=Existing pattern variable ''{0}'' can be used instead of ''{1}''
inspection.pattern.variable.can.be.used.fix.family.name=Reemplazar con variable de patrón
inspection.pattern.variable.can.be.used.fix.name=Reemplazar ''{0}'' con la variable de patrón
inspection.pattern.variable.can.be.used.instead.of.cast.message=Cast expression can be replaced with pattern variable
inspection.pattern.variable.can.be.used.message=La variable ''{0}'' se puede reemplazar con una variable de patrón.
inspection.pattern.variable.can.be.used.report.cast.only=Report cast expressions which can be replaced with new pattern variables
inspection.pattern.variable.instead.of.cast.can.be.used.existing.fix.name=Replace cast expression with existing pattern variable ''{0}''
inspection.pattern.variable.instead.of.cast.can.be.used.fix.family.name=Replace cast expressions with pattern variable
inspection.redundant.arguments.message=Unnecessary arguments
inspection.redundant.class.call.display.name=Duplicar llamadas '' isInstance()'' o '' cast()''
inspection.redundant.collection.operation.display.name=Operaciones de cobranza duplicadas
inspection.redundant.collection.operation.fix.family.name=Simplificar la operación de recolección
inspection.redundant.collection.operation.problem.arraycopy=Se creó una colección innecesaria para copiar la matriz.
inspection.redundant.collection.removal.by.index.fix=Habilitar la eliminación por objeto.
inspection.redundant.collection.removal.by.index.problem=Eliminar por índice se puede reemplazar con Eliminar por objeto.
inspection.redundant.collection.unnecessary.contains.fix='' {0}()'' Eliminar inspección
inspection.redundant.collection.unnecessary.contains.problem=Inspección '' {0}()'' innecesaria
inspection.redundant.compare.call.display.name=중복 'compare()' 메서드 호출
inspection.redundant.compare.call.fix.name='' compare()'' llamada en línea
inspection.redundant.embedded.expression.display.name=Redundant embedded expression in string template
inspection.redundant.embedded.expression.fix.family.name=Inline embedded expression
inspection.redundant.embedded.expression.message.empty=Redundant empty embedded expression
inspection.redundant.embedded.expression.message.literal=Redundant embedded literal
inspection.redundant.empty.string.argument.message=Argumento de cadena vacía innecesario.
inspection.redundant.explicit.variable.type.description=Se puede omitir el tipo explícito de variable local
inspection.redundant.length.check.display.name=Redundant array length check
inspection.redundant.string.call.message=Duplicar <code>\#ref()</code> llamada\#loc
inspection.redundant.string.constructor.message=Duplicar <code>\#ref</code>.\#loc
inspection.redundant.string.fix.family.name=Eliminar llamadas duplicadas
inspection.redundant.string.fix.remove.str.processor.description=String template can be converted to a plain string literal
inspection.redundant.string.intern.on.constant.message=Llamar a <code>\#ref()</code> de constantes de tiempo de compilación es innecesario\#loc
inspection.redundant.string.length.argument.message=Argumento de longitud de cadena innecesario
inspection.redundant.string.new.array.message=<code>#ref</code> is redundant #loc
inspection.redundant.string.operation.display.name=Operación String redundante
inspection.redundant.string.option.do.not.report.single.argument.substring=Do not report redundant single argument substring() calls
inspection.redundant.string.option.do.not.report.string.constructors=No reportar constructores de cadenas
inspection.redundant.string.remove.argument.fix.name=Eliminar argumento
inspection.redundant.string.remove.fix.name=Eliminar llamada duplicada '' {0}()''
inspection.redundant.string.replace.with.arg.fix.name=Reemplazar con argumentos
inspection.redundant.string.replace.with.empty.fix.name=Reemplazar con una cadena vacía
inspection.redundant.zero.argument.message=Argumento cero innecesario
inspection.refused.bequest.super.annotated.option=Informar solo si el método principal está anotado con\:
inspection.replace.on.literal.display.name=Replacement operation has no effect
inspection.simplifiable.compare.java.time.display.name=Expression with 'java.time' 'compareTo()' call can be simplified
inspection.simplifiable.compare.java.time.family.name=Simplify expression with 'java.time' 'compareTo()' call
inspection.simplifiable.compare.java.time.problem.descriptor=Expression with 'java.time' <code>#ref()</code> call can be simplified
inspection.simplifiable.if.statement.display.name=si las sentencias se pueden reemplazar con expresiones?\:, \\& \\&, ||,\=\= o \!\=
inspection.simplifiable.if.statement.fix.family.name=Reemplace '' si más '' con expresión condicional
inspection.simplifiable.if.statement.fix.name=Reemplazar '' si más '' por ''{0}''
inspection.simplifiable.if.statement.message=si la declaración se puede reemplazar con ''{0}''.
inspection.simplifiable.if.statement.option.dont.warn.on.ternary=''?\: '' operador obsoleto
inspection.suspicious.date.format.display.name=Patrón de formato de fecha sospechoso
inspection.suspicious.date.format.message.lower=Se utiliza el patrón en minúsculas ''{0}''({1}). ''{2}'' ({3}) puede ser intencional.
inspection.suspicious.date.format.message.upper=Se usa el patrón ''{0}''({1}) en mayúsculas. ''{2}'' ({3}) puede ser intencional.
inspection.suspicious.package.private.access.description={0} es {1} pero se declara en otro módulo ''{2}''.
inspection.suspicious.package.private.access.problem={0} anula el método de paquete privado en {1} declarado en otro módulo ''{2}''.
inspection.test.method.without.assertion.list.name=Assertion methods:
inspection.test.method.without.assertions.exceptions.option=Ignore los métodos de prueba que declaran excepciones
inspection.trivial.functional.expression.usage.description=Puede simplificar las llamadas a métodos
inspection.type.may.be.weakened.add.stop.class.family=detener agregar clase
inspection.type.may.be.weakened.add.stop.class.selection.popup=detener la selección de clase
inspection.type.may.be.weakened.add.stop.class.selection.table=clase de parada
inspection.type.may.be.weakened.add.stop.class.selection.table.label=Stop classes:
inspection.type.may.be.weakened.add.stopper=Agregar como clase de parada para debilitar
inspection.type.may.be.weakened.add.stopper.preview=The stop class will be added to the list of stop classes for this inspection.
inspection.type.may.be.weakened.add.stopper.single=Agregar {0} como clase de parada para debilitar
inspection.type.may.be.weakened.display.name=El tipo puede estar debilitado
inspection.type.may.be.weakened.do.not.weaken.inferred.variable.type=No sugiera que las variables debilitadas se declaren como '' var ''
inspection.type.may.be.weakened.field.problem.descriptor=El tipo de campo <code>\#ref</code> puede debilitarse a {0}.\#loc
inspection.type.may.be.weakened.method.problem.descriptor=El tipo de retorno del método <code>\#ref()</code> puede debilitarse a {0}.\#loc
inspection.type.may.be.weakened.only.weaken.to.an.interface=Debilitado solo con interfaz
inspection.type.may.be.weakened.parameter.problem.descriptor=El tipo de parámetro <code>\#ref</code> puede debilitarse a {0}.\#loc
inspection.type.may.be.weakened.problem.descriptor=El tipo de variable <code>\#ref</code> puede debilitarse a {0}.\#loc
inspection.type.may.be.weakened.quickfix=Tipo debilitado a ''{0}''.
inspection.type.may.be.weakened.weaken.type.family=Tipo debilitado
inspection.unnecessary.string.escape.report.char.literals.option=informe de cadena de caracteres
inspection.unsupported.chrono.field.unit.call.display.name=Call methods with unsupported 'java.time.temporal.ChronoUnit' and 'java.time.temporal.ChronoField'
inspection.unsupported.chrono.value.message=Unsupported argument value: {0}
inspection.unsupported.chrono.values.message=Unsupported argument values: {0}
inspection.use.of.private.field.inner.classes.option=Ignorar el acceso de las clases internas
inspection.use.of.slash.s.display.name=Non-terminal use of '\\s' escape sequence
inspection.use.of.slash.s.fix.family=Replace '\\s' sequences with spaces
inspection.use.of.slash.s.message=Use of the escape sequence '\\s' as a non-trailing space
inspection.use.of.slash.s.non.text.block.message=Use of the escape sequence '\\s' outside of text blocks
inspection.while.can.be.replaced.with.do.while.display.name=while' can be replaced with 'do while
inspection.while.can.be.replaced.with.do.while.family.name=Replace 'while' with 'do while'
inspection.while.can.be.replaced.with.do.while.message=Replace 'while' with 'do while'
inspection.x.call.can.be.replaced.with.y=La llamada ''{0}'' se puede reemplazar con ''{1}''
instance.Variable.may.not.be.initialized.problem.descriptor.junit=El campo de instancia <code>#ref</code> no se puede inicializar durante la construcción del objeto o la llamada 'setUp()' #loc
instance.method.naming.convention.element.description=Instancia
instance.variable.may.not.be.initialized.display.name=El campo de instancia no se puede inicializar
instance.variable.may.not.be.initialized.problem.descriptor=El campo de instancia <code>#ref</code> puede no inicializarse durante la construcción del objeto #loc
instance.variable.naming.convention.element.description=Campo de instancia
instance.variable.of.concrete.class.problem.descriptor=El tipo de campo ''{0}'' es clase concreta <code>#ref</code> #loc
instance.variable.used.before.initialized.display.name=Campo de instancia usado antes de la inicialización
instance.variable.used.before.initialized.problem.descriptor=Campo de instancia <code>#ref</code> usado antes de inicializado #loc
instanceof.catch.parameter.display.name=instanceof' en el parámetro 'catch
instanceof.catch.parameter.problem.descriptor='instanceof' en el parámetro 'catch' <code>#ref</code> #loc
instanceof.check.for.this.display.name=instancia de' verificar 'esto
instanceof.check.for.this.equality.problem.descriptor=Comparación de clases para 'esto' #loc
instanceof.check.for.this.problem.descriptor='instancia de' verificar <code>#ref</code> #loc
instanceof.concrete.class.equality.problem.descriptor=Comparación de clases contra clases concretas <code>#ref</code> #loc
instanceof.concrete.class.pattern.problem.descriptor=Pattern test against a concrete class <code>#ref</code> #loc
instanceof.concrete.class.problem.descriptor='instancia de' clase concreta <code>#ref</code> #loc
instanceof.with.incompatible.interface.display.name='instanceof' con interfaz incompatible
instanceof.with.incompatible.interface.problem.descriptor='instancia de' interfaz incompatible <code>#ref</code> #loc
instantiating.datetimeformatter.without.locale.problem.descriptor=Calling <code>DateTimeFormatter.#ref()</code> without specifying a Locale in an internationalized context #loc
instantiating.object.to.get.class.object.display.name=Creación de instancias de objeto para obtener un objeto de clase
instantiating.object.to.get.class.object.problem.descriptor=Creación de instancias del objeto para obtener el objeto Class #loc
instantiating.object.to.get.class.object.replace.quickfix=Reemplazar con acceso directo al objeto de clase
instantiating.simpledateformat.without.locale.display.name=Creación de una instancia de SimpleDateFormat sin una configuración regional
instantiating.simpledateformat.without.locale.problem.descriptor=Crear una instancia de un <code>#ref</code> sin especificar un Locale en un contexto internacionalizado #loc
instantiation.utility.class.display.name=Creación de instancias de la clase de utilidad
instantiation.utility.class.problem.descriptor=Instanciación de la clase de utilidad <code>#ref</code> #loc
int.literal.may.be.long.literal.display.name=int' literal convertido a 'long' podría ser literal 'long
int.literal.may.be.long.literal.problem.descriptor=<code>#ref</code> podría reemplazarse con ''{0}'' #loc
integer.division.in.floating.point.context.display.name=División entera en contexto de punto flotante
integer.division.in.floating.point.context.fix.family.name=Cast the numerator to a floating-point type
integer.division.in.floating.point.context.fix.name=Cast the numerator to ''{0}''
integer.division.in.floating.point.context.problem.descriptor=<code>#ref</code>: división de enteros en contexto de punto flotante #loc
integer.multiplication.implicit.cast.to.long.display.name=Multiplicación de enteros o cambio de conversión implícita a largo
integer.multiplication.implicit.cast.to.long.option=<html>Ignore las expresiones en las que se haya comprobado estáticamente que el desbordamiento es imposible</html>
integer.multiplication.implicit.cast.to.long.problem.descriptor=# ref: multiplicación de enteros convertida implícitamente en long #loc
integer.multiplication.implicit.cast.to.long.quickfix=Lanzar demasiado
integer.shift.implicit.cast.to.long.problem.descriptor=# ref: integer shift implícitamente convertido a long #loc
interface.clashes.with.object.class.display.name=El método de la interfaz entra en conflicto con el método en '' java.lang.Object ''
interface.clashes.with.object.class.problem.descriptor=<code>\#ref()</code> entra en conflicto con un método en '' java.lang.Object ''.
interface.may.be.annotated.functional.display.name=La interfaz se puede anotar con @FunctionalInterface
interface.may.be.annotated.functional.problem.descriptor=La interfaz <code>\#ref</code> se puede anotar con @FunctionalInterface
interface.naming.convention.element.description=Interfaz
interface.never.implemented.display.name=Interfaz que no tiene una subclase concreta
interface.never.implemented.option=Ignorar interfaces que solo declaran constantes
interface.never.implemented.problem.descriptor=Interface <code>#ref</code> no tiene una subclase concreta #loc
interface.one.inheritor.display.name=Interfaz que tiene un solo heredero directo
interface.one.inheritor.problem.descriptor=La interfaz <code>#ref</code> tiene solo un heredero directo #loc
introduce.holder.class.quickfix=clase titular
introduce.variable.may.change.semantics.quickfix=Introducir variable (puede cambiar la semántica)
introduce.variable.quickfix=Introducir variable
invert.method.quickfix=Método de inversión.
invert.quickfix=Invertir ''{0}''.
invert.quickfix.family.name=Invertir booleano
iterator.hasnext.which.calls.next.display.name=Iterator.hasNext()' que llama a 'next()
iterator.hasnext.which.calls.next.problem.descriptor=<code>Iterator. {0}()</code> contiene la llamada a ''#ref()'' #loc
iterator.next.does.not.throw.nosuchelementexception.display.name=Iterator.next()' que no puede lanzar 'NoSuchElementException
iterator.next.does.not.throw.nosuchelementexception.problem.descriptor=<code>Iterator. #ref()</code> que no puede lanzar 'NoSuchElementException' #loc
java.lang.import.display.name=importación 'java.lang'
java.lang.import.problem.descriptor=Importación innecesaria del paquete 'java.lang' #loc
jdbc.execute.with.non.constant.string.display.name=Llamada a 'Statement.execute()' con una cadena no constante
jdbc.execute.with.non.constant.string.problem.descriptor=Llamada a <code>Statement. #ref()</code> con argumento no constante #loc
jdbc.prepare.statement.with.non.constant.string.display.name=Llamada a 'Connection.prepare *()' con una cadena no constante
jdbc.prepare.statement.with.non.constant.string.problem.descriptor=Llamada a <code>Connection. #ref()</code> con argumento no constante #loc
jdbc.resource.opened.not.closed.display.name=recurso JDBC abierto pero no cerrado de forma segura
jndi.resource.opened.not.closed.display.name=Recurso JNDI abierto pero no cerrado de forma segura
junit.abstract.test.class.naming.convention.element.description=Prueba abstracta
junit.test.class.naming.convention.element.description=Prueba
junit.test.suite.naming.convention.element.description=Conjunto de pruebas
junit3.method.naming.convention.element.description=JUnit 3 pruebas
junit4.method.naming.convention.element.description=JUnit 4+ pruebas
key.set.iteration.may.use.entry.set.display.name=La iteración sobre 'keySet()' puede optimizarse
key.set.iteration.may.use.entry.set.problem.descriptor=La iteración sobre <code>#ref</code> se puede reemplazar con ''{0}'' iteración #loc
key.set.iteration.may.use.entry.set.quickfix=Optimizar iteración del mapa
labeled.statement.display.name=Declaración etiquetada
labeled.statement.problem.descriptor=Instrucción etiquetada <code> #ref:</code> #loc
lambda.body.can.be.code.block.name=El cuerpo de Lambda puede ser un bloque de código
lambda.body.can.be.code.block.quickfix=Expanda el cuerpo lambda a {...}.
lambda.can.be.replaced.with.anonymous.name=Puede reemplazar lambda con una clase anónima
lambda.can.be.replaced.with.anonymous.quickfix=Reemplazar lambda con una clase anónima.
lambda.parameter.hides.member.variable.display.name=El parámetro Lambda oculta el campo
lambda.parameter.hides.member.variable.ignore.invisible.option=Ignorar campos no visibles en lambda
lambda.parameter.hides.member.variable.problem.descriptor=El parámetro Lambda <code>\#ref</code> oculta el campo de la clase ''{0}''.\#loc
lambda.parameter.naming.convention.display.name=Convención de nomenclatura de parámetros Lambda
lambda.parameter.naming.convention.element.description=Parámetros Lambda
lambda.parameter.type.can.be.specified.descriptor=Los tipos de parámetros Lambda se pueden expandir a {0}
lambda.parameter.type.can.be.specified.family.quickfix=Especifica el tipo de parámetro lambda.
lambda.parameter.type.can.be.specified.name=Puede especificar un tipo de parámetro lambda
lambda.parameter.type.can.be.specified.quickfix=Expandir el tipo de parámetro a {0}.
lambda.unfriendly.constructor.overload.problem.descriptor=La sobrecarga en el constructor <code>\#ref()</code> no es compatible con lambda.
lambda.unfriendly.method.overload.display.name=Sobrecarga de método no compatible con lambda
lambda.unfriendly.method.overload.problem.descriptor=La sobrecarga del método <code>\#ref()</code> no es compatible con lambda.
large.array.allocation.no.outofmemoryerror.display.name=Asignación de matriz grande sin verificación de OutOfMemoryError
large.array.allocation.no.outofmemoryerror.maximum.number.of.elements.option=Número máximo de elementos:
large.array.allocation.no.outofmemoryerror.problem.descriptor=Asignación de matriz grande que no se comprueba para la condición de falta de memoria #loc
large.initializer.primitive.type.array.display.name=Inicializador demasiado grande para una matriz de tipo primitivo
large.initializer.primitive.type.array.maximum.number.of.elements.option=Número máximo de elementos:
large.initializer.primitive.type.array.problem.descriptor=Inicializador de matriz primitivo con demasiados elementos ({0}) #loc
law.of.demeter.display.name=La llamada al método viola la ley de Demeter
law.of.demeter.field.problem.descriptor=Access of <code>#ref</code> violates Law of Demeter #loc
law.of.demeter.ignore.library.calls.option=Ignorar las llamadas a los métodos de la biblioteca
law.of.demeter.problem.descriptor=<code>#ref()</code> la llamada viola la ley de Demeter #loc
length.one.string.in.indexof.display.name=Argumento de cadena de un solo carácter en la llamada 'String.indexOf()'
length.one.strings.in.concatenation.display.name=Concatenación de cadena de un solo carácter
length.one.strings.in.concatenation.replace.quickfix=Reemplazar con carácter
limited.scope.inner.class.display.name=Clase interna de alcance limitado
limited.scope.inner.class.problem.descriptor=Clase interna de alcance limitado <code>#ref</code> #loc
list.indexof.replaceable.by.contains.display.name=La expresión 'List.indexOf()' es reemplazable por 'contains()'
listener.may.use.adapter.display.name=La clase puede extender el adaptador en lugar de implementar el oyente
listener.may.use.adapter.emtpy.methods.option=&Advertir solo cuando se encuentran métodos de implementación vacíos
listener.may.use.adapter.fix.family.name=Reemplazar con adaptador
listener.may.use.adapter.problem.descriptor=Class ''{0}'' puede extender ''{1}'' en lugar de implementar <code>#ref</code> #loc
literal.as.arg.to.string.equals.display.name=expresión.equals ("literal")' en lugar de '"literal" .equals (expresión)
literal.as.arg.to.string.equals.flip.quickfix=Voltear '' {0}() ''
literal.as.arg.to.string.equals.problem.descriptor=El <code>#ref</code> literal es el argumento de '' {0}() '', en lugar de su calificador #loc
load.library.with.non.constant.string.display.name=Llamada a 'System.loadLibrary()' con una cadena no constante
load.library.with.non.constant.string.problem.descriptor=Llamada a <code>{0}. #ref()</code> con argumento no constante #loc
local.variable.hides.member.variable.display.name=La variable local oculta el campo
local.variable.hides.member.variable.ignore.option=Ignorar variables locales en un contexto estático ocultando campos no estáticos
local.variable.hides.member.variable.problem.descriptor=La variable local <code>#ref</code> oculta el campo en la clase ''{0}'' #loc
local.variable.naming.convention.display.name=Convención de nomenclatura de variables locales
local.variable.naming.convention.element.description=Variable local
local.variable.naming.convention.ignore.catch.option=Ignorar los parámetros del bloque 'catch'
local.variable.naming.convention.ignore.option=Ignorar parámetros de bucle for
local.variable.of.concrete.class.problem.descriptor=Variable local ''{0}'' de clase concreta <code>#ref</code> #loc
log.condition.text=texto de condición de registro
log.method.name=Nombre del método de registro
log.statement.guarded.by.log.condition.display.name=Llamada de registro no protegida por la condición de registro
log.statement.guarded.by.log.condition.flag.all.unguarded.option=Marcar todas las llamadas de registro no vigiladas
log.statement.guarded.by.log.condition.problem.descriptor=<code>#ref()</code> registro de llamadas no protegido por la condición de registro #loc
log.statement.guarded.by.log.condition.quickfix=Rodear con condición de registro
logger.class.name=Nombre de la clase del registrador
logger.factory.class.name=Nombre de clase de la fábrica de registradores
logger.factory.method.name=Nombre del método de fábrica del registrador
logger.initialized.with.foreign.class.display.name=Logger inicializado con clase extranjera
logger.initialized.with.foreign.class.fix.family.name=Reemplazar clase extranjera
logger.initialized.with.foreign.class.ignore.non.public.classes.option=Ignore loggers in non-public classes
logger.initialized.with.foreign.class.ignore.super.class.option=Ignore loggers initialized with a superclass
logger.initialized.with.foreign.class.problem.descriptor=Registrador inicializado con clase extranjera <code>#ref</code> #loc
logger.name.option=Registrador y nombre de clase:
long.literals.ending.with.lowercase.l.display.name=long' literal que termina con 'l' en lugar de 'L
long.literals.ending.with.lowercase.l.problem.descriptor='long' literal <code>#ref</code> termina en minúscula 'l' #loc
loop.condition.not.updated.inside.loop.display.name=Variable de bucle no actualizada dentro del bucle
loop.condition.not.updated.inside.loop.problem.descriptor=La condición '#ref' no se actualiza dentro del bucle #loc
loop.statements.that.dont.loop.display.name=Declaración de bucle que no se repite
loop.statements.that.dont.loop.problem.descriptor=La declaración <code>#ref</code> no se repite #loc
loop.variable.not.updated.inside.loop.option.nonlocal=Ignorar posibles cambios no locales
loop.variable.not.updated.inside.loop.problem.descriptor=La variable '#ref' no se actualiza dentro del bucle #loc
loop.with.implicit.termination.condition.display.name=Bucle con condición de terminación implícita
loop.with.implicit.termination.condition.dowhile.problem.descriptor=<code>#ref-while</code> loop con condición de terminación implícita #loc
loop.with.implicit.termination.condition.problem.descriptor=<code>#ref</code> bucle con condición de terminación implícita #loc
loop.with.implicit.termination.condition.quickfix=Hacer explícita la condición
magic.character.display.name=Personaje mágico
magic.character.problem.descriptor=Carácter mágico <code>#ref</code> en un contexto internacionalizado #loc
magic.number.display.name=Número mágico
magic.number.problem.descriptor=Número mágico <code>#ref</code> #loc
make.class.final.fix.family.name=Hacer que la clase sea final
make.class.final.fix.name=Hacer clase ''{0}'' ''final''
make.constructor.public=Establecer constructor en '' público ''
make.field.final.fix.family.name=Hágalo final.
make.field.final.quickfix=Hacer ''{0}'' ''final''
make.field.static.final.fix.family.name=static final
make.initialization.explicit.quickfix=Hacer explícita la inicialización
make.method.ctr.quickfix=Crear constructor de método
make.method.final.fix.family.name=Establecer método en '' final ''
make.method.final.fix.name=Crear método ''{0}()'' ''final''
make.package.private.fix.family.name=Cree package-private
make.static.final.quickfix=Hacer ''{0}'' estático final
make.static.quickfix=Hacer 'estático'
malformed.format.string.display.name=Cadena de formato incorrecto
malformed.format.string.problem.descriptor.arguments.do.not.match.type=El tipo de argumento ''{0}'' no coincide con el tipo del especificador de formato ''{1}'' #loc
malformed.format.string.problem.descriptor.at.least.too.few.arguments=Too few arguments for format string (found: {0}, expected at least: {1}) #loc
malformed.format.string.problem.descriptor.illegal=Especificador de cadena de formato ilegal:{0}#loc
malformed.format.string.problem.descriptor.malformed=La cadena de formato <code>#ref</code> está mal formada #loc
malformed.format.string.problem.descriptor.too.few.arguments=Muy pocos argumentos para la cadena de formato (encontrado: {0}, esperado: {1}) #loc
malformed.format.string.problem.descriptor.too.many.arguments=Demasiados argumentos para la cadena de formato (encontrado: {0}, esperado: {1}) #loc
manual.array.copy.display.name=Copia manual de matriz
manual.array.copy.problem.descriptor=Copia manual de matriz #loc
manual.array.to.collection.copy.display.name=Copia manual de matriz a colección
manual.array.to.collection.copy.problem.descriptor=Matriz manual a copia de colección #loc
map.replaceable.by.enum.map.display.name=Mapa reemplazable con EnumMap
map.replaceable.by.enum.map.problem.descriptor=<code>#ref</code> reemplazable por 'EnumMap' #loc
mark.modules.as.loaded.together.fix.family.name=Marcar módulos para cargar juntos
mark.modules.as.loaded.together.fix.text=''{0}'' y ''{1}'' marcan los módulos para que se carguen juntos
marker.interface.display.name=Interfaz de marcador
marker.interface.problem.descriptor=Interfaz de marcador <code>#ref</code> #loc
masked.assertion.display.name=La afirmación está siendo suprimida por 'captura'
masked.assertion.problem.description=''{0}'' no puede fallar porque está suprimido por un ''catch'' adjunto
math.random.cast.to.int.display.name=emitir '' Math.random()'' a '' int ''
math.random.cast.to.int.problem.descriptor=<code>\#ref</code> se convierte en ''{0}'' siempre se descarta como '' 0 ''.\#loc
math.random.cast.to.int.quickfix=Agrega paréntesis para hacer la multiplicación antes de lanzar.
math.rounding.with.int.argument.display.name=Call math rounding with 'int' argument
math.rounding.with.int.argument.family.name=Simplify rounding calls
math.rounding.with.int.argument.problem.descriptor=<code>#ref()</code> with argument of type 'int' #loc
math.rounding.with.int.argument.quickfix=Simplify ''{0}()'' call
meta.annotation.without.runtime.retention=Anotaciones que no son de tiempo de ejecución para usar en la reflexión
method.call.in.loop.condition.display.name=Llamada al método en condición de bucle
method.call.in.loop.condition.problem.descriptor=Llamada al método <code>#ref()</code> en condición de bucle #loc
method.can.be.variable.arity.method.display.name=El método puede ser un método vararg
method.can.be.variable.arity.method.ignore.all.primitive.arrays.option=Ignorar todos los tipos de matrices primitivas
method.can.be.variable.arity.method.ignore.byte.short.option=Ignorar parámetros con tipo byte [] o short []
method.can.be.variable.arity.method.ignore.multidimensional.arrays.option=Ignorar parámetros de matriz de varios tamaños
method.can.be.variable.arity.method.ignore.multiple.arrays.option=Ignorar métodos con múltiples parámetros de matriz
method.can.be.variable.arity.method.problem.descriptor=Puede convertir <code>\#ref()</code> en un método vararg.\#loc
method.complexity.limit.option=Límite de complejidad del método:
method.count.ignore.getters.setters.option=&Ignorar métodos simples getter y setter
method.count.limit.option=Límite de recuento de métodos:
method.coupling.display.name=Método demasiado acoplado
method.coupling.limit.option=Límite de acoplamiento del método:
method.coupling.problem.descriptor=<code>#ref</code> está demasiado acoplado (# clases referenciadas={0}) #loc
method.may.be.static.display.name=El método puede ser 'estático'
method.may.be.static.empty.option=Ignorar métodos vacíos
method.may.be.static.ignore.default.methods.option=Ignorar método '' predeterminado ''
method.may.be.static.only.option=Solo verifique los métodos 'privados' o 'finales'
method.may.be.static.problem.descriptor=El método <code>#ref()</code> puede ser 'estático' #loc
method.may.be.static.replaces.qualifiers.with.class.references.option=El arreglo rápido reemplaza los calificadores de instancia con referencias de clase.
method.may.be.synchronized.display.name=El método con bloque sincronizado podría ser un método sincronizado
method.may.be.synchronized.problem.descriptor=El método <code>#ref()</code> con bloque sincronizado podría sincronizarse método #loc
method.may.be.synchronized.quickfix=Hacer que el método esté sincronizado y eliminar el bloque sincronizado
method.name.regex=Nombre del método regex
method.name.same.as.class.name.display.name=El nombre del método es el mismo que el de la clase
method.name.same.as.class.name.problem.descriptor=El nombre del método <code>#ref</code> es el mismo que su nombre de clase #loc
method.name.same.as.parent.name.display.name=El nombre del método es el mismo que el de la clase principal
method.name.same.as.parent.name.problem.descriptor=El nombre del método <code>#ref</code> es el mismo que el nombre de la clase principal #loc
method.names.differ.only.by.case.display.name=Los nombres de los métodos difieren solo por caso
method.names.differ.only.by.case.problem.descriptor=El nombre del método <code>#ref</code> y el nombre del método ''{0}'' difieren solo en el caso #loc
method.only.used.from.inner.class.display.name=Método privado solo usado desde la clase interna
method.only.used.from.inner.class.ignore.option=Ignorar los métodos a los que se accede desde una clase &anónima
method.only.used.from.inner.class.problem.descriptor=El método <code>#ref()</code> #loc solo se usa desde la clase interna ''{0}'' #loc
method.overloads.display.name=El método sobrecarga el método de la superclase
method.overloads.problem.descriptor=El método <code>#ref()</code> sobrecarga un método compatible de una superclase, cuando podría haber sido la anulación #loc
method.overloads.report.incompatible.option=Informe incluso si los tipos de parámetros no son compatibles
method.overrides.inaccessible.method.display.name=El método anula el método inaccesible de la superclase
method.overrides.package.local.method.problem.descriptor=El método <code>#ref()</code> anula un método privado de paquete de una superclase ubicada en otro paquete #loc
method.overrides.private.display.name.problem.descriptor=El método <code>#ref()</code> anula un método 'privado' de una superclase #loc
method.overrides.static.display.name=El método intenta anular el método estático de la superclase
method.overrides.static.problem.descriptor=El método <code>#ref()</code> intenta anular un método estático de una superclase #loc
method.ref.can.be.replaced.with.lambda.name=Puede reemplazar la referencia del método con lambda
method.ref.can.be.replaced.with.lambda.quickfix=Reemplazar la referencia del método con lambda.
method.return.always.constant.display.name=El método devuelve constante por clase
method.return.always.constant.problem.descriptor=El método <code>#ref()</code> y todas sus derivables siempre devuelven constantes
method.return.concrete.class.problem.descriptor=El método devuelve una clase concreta <code>#ref</code> #loc
method.with.multiple.loops.display.name=Método con múltiples bucles
method.with.multiple.loops.problem.descriptor=<code>#ref</code> contiene{0}bucles #loc
mismatched.read.write.array.display.name=Lectura y escritura de matriz no coincidentes
mismatched.read.write.array.problem.descriptor.read.not.write=El contenido de la matriz <code>#ref</code> se lee, pero nunca se escribe en #loc
mismatched.read.write.array.problem.descriptor.write.not.read=El contenido de la matriz <code>#ref</code> se escribe, pero nunca se lee #loc
mismatched.string.builder.queried.problem.descriptor={0} El contenido de <code>\#ref</code> se consulta pero no se actualiza.\#loc
mismatched.string.builder.query.update.display.name=La consulta y la actualización no coinciden en StringBuilder
mismatched.string.builder.updated.problem.descriptor={0} El contenido de <code>\#ref</code> se actualiza pero no se consulta.\#loc
mismatched.update.collection.display.name=Consulta y actualización de colección no coincidentes
mismatched.update.collection.problem.description.queried.not.updated=Se consulta el contenido de la colección <code>#ref</code>, pero nunca se actualiza #loc
mismatched.update.collection.problem.descriptor.updated.not.queried=El contenido de la colección <code>#ref</code> se actualizó, pero nunca se consultó #loc
misordered.assert.equals.arguments.display.name=Argumentos 'assertEquals()' mal ordenados
misordered.assert.equals.arguments.flip.quickfix=Cambiar argumentos comparados
misordered.assert.equals.arguments.problem.descriptor=Argumentos para <code>#ref()</code> en orden incorrecto #loc
missing.add.deprecated.javadoc.tag.quickfix=Agregar etiqueta Javadoc '@deprecated'
missing.deprecated.annotation.add.quickfix=Agregar anotación @Deprecated
missing.deprecated.annotation.display.name=Falta anotación @Deprecated
missing.deprecated.annotation.problem.descriptor=Falta la anotación '@Deprecated' #loc
missing.deprecated.tag.option=Advertir sobre la explicación de la etiqueta Javadoc @deprecated que falta
missing.deprecated.tag.problem.descriptor=Falta la explicación de la etiqueta Javadoc '@deprecated' #loc
missing.override.annotation.display.name=Falta la anotación @Override
missing.override.annotation.in.overriding.problem.descriptor=Los métodos anulados no se anotan con '@Override'
missing.override.annotation.problem.descriptor=Falta la anotación '@Override' en <code>#ref()</code> #loc
missing.override.warn.on.super.option=Highlight method when its overriding methods do not all have the '@Override' annotation
missing.package.html.problem.descriptor=Falta el archivo <code> package.html</code> del paquete ''{0}''.
missing.package.info.display.name=Falta el '' paquete-info.java ''
missing.package.info.problem.descriptor=Falta el archivo <code> package-info.java</code> en el paquete ''{0}''.
missing.serial.annotation.display.name=Anotación '@Serial' disponible
missing.serial.annotation.on.field.problem.descriptor=Puede agregar la anotación '@Serial' a <code>\#ref</code>
missing.serial.annotation.on.method.problem.descriptor=Puede agregar la anotación '@Serial' a <code>\#ref()</code>
missorted.modifiers.display.name=Modificadores mal clasificados
missorted.modifiers.problem.descriptor=Modificadores mal clasificados <code>{0}</code> #loc
missorted.modifiers.require.option=Verificar el orden de las anotaciones
missorted.modifiers.sort.quickfix=Modificadores de clasificación
missorted.modifiers.typeuse.before.type.option=Las anotaciones de TYPE_USE de destino siempre van antes del tipo
misspelled.equals.display.name=equal()' en lugar de 'equals()
misspelled.equals.problem.descriptor=<code>#ref()</code> método probablemente debería ser 'equals()' #loc
module.with.too.few.classes.display.name=Módulo con muy pocas clases
module.with.too.few.classes.min.option=Número mínimo de clases:
module.with.too.few.classes.problem.descriptor=El módulo ''{0}'' contiene muy pocas clases ({1} <{2})
module.with.too.many.classes.display.name=Módulo con demasiadas clases
module.with.too.many.classes.max.option=Número máximo de clases:
module.with.too.many.classes.problem.descriptor=El módulo ''{0}'' contiene demasiadas clases ({1}> {2})
move.anonymous.to.inner.quickfix=Convertir a clase interna con nombre
move.class.quickfix=Mover clase
move.exception.to.javadoc.fix.family.name=Javadoc Mover a la etiqueta '' @throws ''
move.local.to.inner.quickfix=Convert to inner class
multi.catch.can.be.split.name=Puede dividir múltiples capturas en bloques de capturas individuales
multi.catch.can.be.split.quickfix=Dividir múltiples capturas en bloques de '' captura '' individuales.
multiple.declaration.array.only.option=Advertir solo sobre diferentes tamaños de matriz en una sola declaración
multiple.declaration.display.name=Varias variables en una declaración
multiple.declaration.ignore.for.option=Ignorar la declaración de bucle '' for ''
multiple.declaration.problem.descriptor=Varias variables en una declaración #loc
multiple.loggers.display.name=Clase con varios registradores
multiple.loggers.problem.descriptor=Class <code>#ref</code> declara múltiples registradores #loc
multiple.return.points.per.method.display.name=Método con múltiples puntos de retorno
multiple.return.points.per.method.problem.descriptor=<code>#ref</code> tiene{0}puntos de retorno #loc
multiple.top.level.classes.in.file.display.name=Varias clases de nivel superior en un solo archivo
multiple.top.level.classes.in.file.problem.descriptor=Varias clases de nivel superior en el archivo
multiple.typed.declaration.problem.descriptor=Variables con diferente dimensión de matriz en una declaración #loc
multiply.or.divide.by.power.of.two.display.name=Multiplicar o dividir por potencia de dos
multiply.or.divide.by.power.of.two.divide.option=Verifica las divisiones por una potencia de dos también
multiply.or.divide.by.power.of.two.replace.quickfix=Reemplazar con turno
naked.notify.display.name='notificar()' o 'notificar a todos()' sin el cambio de estado correspondiente
naked.notify.problem.descriptor=Llamar a <code>#ref()</code> sin el cambio de estado correspondiente #loc
naming.convention.problem.descriptor.long={0} name <code>#ref</code> is too long ({1}> {2}) #loc
naming.convention.problem.descriptor.regex.mismatch={0} name <code>#ref</code> no coincide con regex ''{1}'' #loc
naming.convention.problem.descriptor.short={0} name <code>#ref</code> is too short ({1} <{2}) #loc
native.method.display.name=Método nativo
native.method.naming.convention.element.description=native
native.method.problem.descriptor=Los métodos declarados <code>#ref</code> no son portátiles #loc
negated.conditional.display.name=Expresión condicional con condición negada
negated.conditional.expression.display.name=Expresión condicional negativa
negated.conditional.expression.problem.descriptor=La expresión condicional no es válida.\#loc
negated.conditional.expression.quickfix=Eliminar negación
negated.conditional.invert.quickfix=Condición de inversión
negated.conditional.problem.descriptor=Expresión condicional con condición negada #loc
negated.equality.expression.display.name=expresión de igualdad negada
negated.equality.expression.problem.descriptor=''{0}'' está negado\#loc
negated.equality.expression.quickfix=Eliminar negación
negated.if.else.display.name=declaración 'if' con condición negada
negated.if.else.ignore.negated.null.option=Ignorar comparaciones '!=null'
negated.if.else.ignore.negated.zero.option=Ignore '!=0' comparaciones
negated.if.else.invert.quickfix=Invertir la condición 'if'
negated.if.else.problem.descriptor=<code>#ref</code> declaración con condición negada #loc
negative.int.constant.in.long.context.display.name=Negative int hexadecimal constant in long context
negative.int.constant.in.long.context.fix.add.suffix=Add 'L' suffix (changes semantics)
negative.int.constant.in.long.context.fix.convert=Convert to long constant (preserves semantics)
negatively.named.boolean.variable.display.name=Variable booleana con nombre negativo
negatively.named.boolean.variable.problem.descriptor=La variable booleana <code>\#ref</code> fue nombrada negativamente.\#loc
nested.assignment.display.name=Resultado de la asignación utilizada
nested.assignment.problem.descriptor=Resultado de la expresión de asignación utilizada #loc
nested.conditional.expression.display.name=Expresión condicional anidada
nested.conditional.expression.problem.descriptor=Expresión condicional anidada <code>#ref</code> #loc
nested.method.call.display.name=Llamada al método anidado
nested.method.call.ignore.option=Ignorar las llamadas a métodos anidados en los inicializadores de campo
nested.method.call.problem.descriptor=Llamada al método anidado <code>#ref()</code> #loc
nested.switch.statement.display.name='interruptor' anidado
nested.switch.statement.problem.descriptor=<code>#ref</code> anidado{0}#loc
nested.synchronized.statement.display.name=Declaración 'sincronizada' anidada
nested.synchronized.statement.problem.descriptor=instrucción <code>#ref</code> anidada #loc
nested.try.statement.display.name=Declaración 'try' anidada
nested.try.statement.problem.descriptor=Instrucción <code>#ref</code> anidada #loc
nesting.depth.display.name=Método demasiado anidado
nesting.depth.limit.option=Límite de profundidad de anidación:
nesting.depth.problem.descriptor=<code>#ref</code> está demasiado anidado (profundidad máxima de anidamiento={0}) #loc
new.exception.without.arguments.display.name=Llamar al constructor de excepciones sin argumentos
new.exception.without.arguments.problem.descriptor=<code> new\#ref()</code>\#loc sin argumentos
new.method.naming.convention.display.name=Convención de nomenclatura de métodos
new.string.buffer.replaceable.by.string.problem.descriptor=<code>#ref</code> se puede reemplazar con 'String' #loc
new.string.buffer.with.char.argument.display.name=Llamada al constructor StringBuilder con argumento 'char'
new.string.buffer.with.char.argument.problem.descriptor=<code> new#ref()</code> con argumento de tipo 'char' #loc
new.string.buffer.with.char.argument.quickfix=Reemplazar el argumento char con el literal String
no.logger.display.name=Clase sin registrador
no.logger.problem.descriptor=Class <code>#ref</code> no declara un registrador #loc
non.atomic.operation.on.volatile.field.display.name=Operación no atómica en campo volátil
non.atomic.operation.on.volatile.field.problem.descriptor=Operación no atómica en campo volátil <code>#ref</code> #loc
non.boolean.method.name.must.not.start.with.question.display.name=El nombre del método no booleano no debe comenzar con una palabra de pregunta
non.boolean.method.name.must.not.start.with.question.problem.descriptor=El nombre del método no booleano <code>#ref</code> comienza con una palabra de pregunta #loc
non.comment.source.statements.display.name=Método demasiado largo
non.comment.source.statements.limit.option=Límite de declaraciones de fuentes sin comentarios:
non.comment.source.statements.problem.descriptor=<code>#ref</code> es demasiado largo (# declaraciones de origen sin comentarios={0}) #loc
non.constant.logger.display.name=Registrador no constante
non.constant.logger.problem.descriptor=Campo de registrador no constante <code>#ref</code> #loc
non.exception.name.ends.with.exception.display.name=El nombre de la clase que no es una excepción termina con 'Exception'
non.exception.name.ends.with.exception.problem.descriptor=El nombre de clase sin excepción <code>#ref</code> termina con 'Exception' #loc
non.exception.name.ends.with.exception.quickfix=Hacer ''{0}'' extender '' java.lang.Exception ''
non.final.clone.display.name='clone()' no final en contexto seguro
non.final.clone.problem.descriptor=Método <code>#ref()</code> no final, comprometiendo la seguridad #loc
non.final.field.compareto.display.name=Campo no final referenciado en 'compareTo()'
non.final.field.compareto.problem.descriptor=Campo no final <code>#ref</code> al que se accede en 'compareTo()' #loc
non.final.field.in.enum.display.name=Campo de enumeración no '' final ''
non.final.field.in.enum.problem.descriptor=Enum ''{0}'' tiene un campo <code>\#ref</code> que no es '' final ''.\#loc
non.final.field.in.enum.quickfix.option=Ignore fields that cannot be made 'final'
non.final.field.in.equals.display.name=Campo no final referenciado en 'equals()'
non.final.field.in.equals.problem.descriptor=Campo no final <code>#ref</code> al que se accede en 'equals()' #loc
non.final.field.in.hashcode.display.name=Campo no final referenciado en 'hashCode()'
non.final.field.in.hashcode.problem.descriptor=Campo no final <code>#ref</code> al que se accede en 'hashCode()' #loc
non.final.field.of.exception.display.name=Campo no final de la clase de excepción
non.final.field.of.exception.problem.descriptor=Campo no final <code>#ref</code> de la clase de excepción #loc
non.final.static.variable.initialization.display.name=El campo estático no final se usa durante la inicialización de la clase
non.final.static.variable.initialization.problem.descriptor=Campo estático no final <code>#ref</code> utilizado durante la inicialización de la clase #loc
non.final.utility.class.display.name=Clase de utilidad no '' final ''
non.final.utility.class.problem.descriptor=La clase de utilidad <code>\#ref</code> no es '' final ''.\#loc
non.protected.constructor.in.abstract.class.display.name=constructor 'público' en clase 'abstracta'
non.protected.constructor.in.abstract.class.ignore.option=Ignorar para clases no públicas
non.protected.constructor.in.abstract.class.problem.descriptor=El constructor <code>#ref()</code> no está declarado 'protegido' en la clase 'abstracta' #loc
non.public.clone.display.name=el método '' clone()'' no es '' público ''
non.public.clone.problem.descriptor=El método <code>\#ref()</code> no es "público".\#loc
non.reproducible.math.call.display.name=Llamada no reproducible a 'java.lang.Math'
non.reproducible.math.call.problem.descriptor=<code> Math. #ref()</code> puede producir resultados no reproducibles #loc
non.reproducible.math.call.replace.quickfix=Reemplazar con llamada 'StrictMath'
non.serializable.@interface.with.serialversionuid.problem.descriptor=No serializable @interface <code>#ref</code> define un campo 'serialVersionUID' #loc
non.serializable.anonymous.with.serialversionuid.problem.descriptor=Clase anónima no serializable que extiende <code>#ref</code> define un campo 'serialVersionUID' #loc
non.serializable.class.with.readwriteobject.display.name=Clase no serializable con 'readObject()' o 'writeObject()'
non.serializable.class.with.readwriteobject.problem.descriptor.both=La clase no serializable <code>#ref</code> define 'readObject()' y 'writeObject()' #loc
non.serializable.class.with.readwriteobject.problem.descriptor.read=Clase no serializable <code>#ref</code> define 'readObject()' #loc
non.serializable.class.with.readwriteobject.problem.descriptor.write=Clase no serializable <code>#ref</code> define 'writeObject()' #loc
non.serializable.class.with.serialversionuid.problem.descriptor=La clase no serializable <code>#ref</code> define un campo 'serialVersionUID' #loc
non.serializable.component.in.serializable.record.problem.descriptor=Non-serializable component '\#ref' in Serializable record \#loc
non.serializable.field.in.serializable.class.display.name=Campo no serializable en una clase serializable
non.serializable.field.in.serializable.class.problem.descriptor=Campo no serializable '#ref' en una clase serializable #loc
non.serializable.interface.with.serialversionuid.problem.descriptor=Interfaz no serializable <code>#ref</code> define un campo 'serialVersionUID' #loc
non.serializable.object.bound.to.http.session.display.name=Objeto no serializable vinculado a HttpSession
non.serializable.object.bound.to.http.session.problem.descriptor=Objeto no serializable vinculado a HttpSession #loc
non.serializable.object.passed.to.object.stream.display.name=Objeto no serializable pasado a ObjectOutputStream
non.serializable.object.passed.to.object.stream.problem.descriptor=Objeto no serializable pasado a ObjectOutputStream #loc
non.serializable.with.serialversionuid.display.name=Clase no serializable con 'serialVersionUID'
non.short.circuit.boolean.expression.display.name=Expresión booleana sin cortocircuito
non.short.circuit.boolean.expression.problem.descriptor=Expresión booleana sin cortocircuito <code>#ref</code> #loc
non.short.circuit.boolean.expression.replace.quickfix=Reemplazar con expresión de cortocircuito
non.synchronized.method.overrides.synchronized.method.display.name=El método no sincronizado anula el método sincronizado
non.synchronized.method.overrides.synchronized.method.problem.descriptor=El método no sincronizado <code>#ref()</code> anula el método sincronizado #loc
non.thread.safe.lazy.initialization.display.name=Inicialización perezosa insegura del campo 'estático'
non.thread.safe.lazy.initialization.problem.descriptor=La inicialización diferida del campo 'estático' <code>#ref</code> no es seguro para subprocesos #loc
none=ninguno
noop.method.in.abstract.class.display.name=Método sin operación en clase abstracta
noop.method.in.abstract.class.problem.descriptor=El método sin operación <code>#ref()</code> debe hacerse abstracto #loc
normalize.declaration.quickfix=Dividir en declaraciones separadas
not.object.equals.can.be.equality.problem.descriptor=Puede reemplazar <code> \!\# Ref()</code> por '' \!\= ''.
notify.called.on.condition.display.name=notificar()' o 'notificar a todos()' llamado en el objeto 'java.util.concurrent.locks.Condition
notify.called.on.condition.problem.descriptor=Llamar a <code>#ref()</code> en el objeto Condición #loc
notify.without.corresponding.wait.display.name=notificar()' sin el correspondiente 'esperar()
notify.without.corresponding.wait.problem.descriptor=Llamar a <code>#ref</code> sin el <code> wait()</code> #loc correspondiente
null.argument.to.var.arg.method.display.name=Argumento confuso para el método varargs
null.argument.to.var.arg.method.problem.descriptor=Argumento confuso <code>#ref</code>, no está claro si se desea una llamada varargs o no varargs #loc
null.thrown.display.name=''null'' es lanzado
null.thrown.problem.descriptor=Se lanza <code>\#ref</code>.\#loc
number.comparison.display.name=Comparación de números usando '==', en lugar de 'equals()'
number.comparison.problem.descriptor=Los objetos numéricos se comparan usando <code>#ref</code>, no 'equals()' #loc
object.allocation.in.loop.display.name=Asignación de objetos en bucle
object.allocation.in.loop.new.descriptor=Asignación de objetos <code>new#ref()</code> en el bucle #loc
object.allocation.in.loop.problem.array.initializer.descriptor=Asignación de matriz en el bucle #loc
object.allocation.in.loop.problem.call.descriptor=Asignación de objetos a través de la llamada <code>#ref()</code> en el bucle #loc
object.allocation.in.loop.problem.lambda.descriptor=Asignación de objetos mediante la captura de lambda en el bucle #loc
object.allocation.in.loop.problem.methodref.descriptor=Asignación de objetos a través de la referencia del método vinculado a la instancia <code>#ref()</code> en el bucle #loc
object.allocation.in.loop.problem.string.concat=Asignación de objetos a través de la concatenación de cadenas en el bucle #loc
object.comparison.display.name=Comparación de objetos usando '==', en lugar de 'equals()'
object.comparison.enumerated.ignore.option=Ignorar '==' entre las variables de enumeración
object.comparison.klass.ignore.option=Ignorar '==' entre los tipos de clases finales sin la implementación de 'equals()'
object.comparison.problem.description=Los valores de los objetos se comparan usando <code>#ref</code>, no 'equals()' #loc
object.equality.ignore.between.objects.of.a.type.with.only.private.constructors.option=Ignore '==' entre objetos de un tipo con solo constructores 'privados'
object.equals.can.be.equality.display.name= equals()'' la llamada se puede reemplazar con ''\=\= 
object.equals.can.be.equality.problem.descriptor=Puede reemplazar <code>\#ref()</code> por ''\=\= ''.
object.instantiation.inside.equals.or.hashcode.display.name= equals()'' o instanciación de objeto dentro de '' hashCode()
object.instantiation.inside.equals.or.hashcode.problem.descriptor='' {0}()'' instanciación de objeto\#loc
object.instantiation.inside.equals.or.hashcode.problem.descriptor2=Creación de instancias de objeto dentro de '' {0}()'' ({1})\#loc
object.notify.display.name=Llamar a 'notificar()' en lugar de 'notificar a todos()'
object.notify.problem.descriptor=<code>#ref</code> probablemente debería reemplazarse con 'notifyAll()' #loc
objects.hash.fix.family.name=Wrap with 'Arrays.hashCode()'
objects.hash.problem.descriptor=Array passed to 'Objects.hash()' should be wrapped in 'Arrays.hashcode()'
octal.and.decimal.integers.in.same.array.display.name=Enteros octales y decimales en la misma matriz
octal.and.decimal.integers.in.same.array.problem.descriptor=Enteros octales y decimales en el mismo inicializador de matriz #loc
octal.literal.display.name=Entero octal
octal.literal.problem.descriptor=Entero octal <code>#ref</code> #loc
only.report.public.methods.option=Informar solo métodos '' públicos ''
only.report.qualified.static.usages.option=Informar solo acceso estático calificado desde un contexto estático
only.report.static.methods=&Solo reportar métodos 'static'
only.warn.on.protected.clone.methods=Advertir solo sobre métodos de clonación '' protegidos ''
only.warn.on.public.clone.methods=Advertir solo sobre métodos de clonación '' públicos ''
optional.contains.array.problem.descriptor='' Opcional '' contiene la matriz <code>\#ref</code>.
optional.contains.collection.display.name='' Opcional '' tiene una matriz o colección
optional.contains.collection.problem.descriptor='' Opcional '' tiene la colección <code>\#ref</code>.
optional.used.as.field.or.parameter.type.display.name='' Opcional '' no se usa como un campo o tipo de parámetro
optional.used.as.field.type.problem.descriptor=<code>\#ref</code> utilizado como tipo para el campo ''{0}''.
optional.used.as.parameter.type.problem.descriptor=<code>\#ref</code> se usa como tipo para el parámetro ''{0}''.
options.label.ignored.classes=Ignored classes:
options.title.ignored.classes=Clases ignoradas
overloaded.methods.with.same.number.parameters.display.name=Métodos sobrecargados con el mismo número de parámetros
overloaded.methods.with.same.number.parameters.option=<html>Ignore los métodos sobrecargados cuyos tipos de parámetros son definitivamente incompatibles</html>
overloaded.methods.with.same.number.parameters.problem.descriptor=Varios métodos llamados <code>#ref</code> con el mismo número de parámetros #loc
overloaded.vararg.constructor.problem.descriptor=Constructor de varargs sobrecargado <code>#ref()</code> #loc
overloaded.vararg.method.display.name=Método varargs sobrecargado
overloaded.vararg.method.problem.descriptor=Método varargs sobrecargado <code>#ref()</code> #loc
overloaded.vararg.method.problem.option=Ignore overloaded methods whose parameter types are definitely incompatible
overly.broad.throws.clause.display.name=Cláusula '' throw '' demasiado amplia
overly.broad.throws.clause.ignore.thrown.option=&Ignore las excepciones auto-lanzadas mientras oculta otras excepciones
overly.broad.throws.clause.problem.descriptor1=<code> throws\#ref</code> es demasiado ancho para enmascarar la excepción ''{0}''.\#loc
overly.broad.throws.clause.problem.descriptor2=<code> throws\#ref</code> es demasiado ancho para enmascarar las excepciones ''{0}'' y ''{1}''.\#loc
overly.broad.throws.clause.quickfix1=Agregar excepciones específicas.
overly.broad.throws.clause.quickfix2=Reemplazar con excepciones específicas.
overly.broad.throws.clause.threshold.option=Maximum number of hidden exceptions to report:
overly.complex.anonymous.inner.class.display.name=Clase anónima demasiado compleja
overly.complex.anonymous.inner.class.problem.descriptor=Clase anónima demasiado compleja (complejidad ciclomática={0}) #loc
overly.complex.arithmetic.expression.display.name=Expresión aritmética demasiado compleja
overly.complex.arithmetic.expression.max.number.option=Número máximo de términos:
overly.complex.arithmetic.expression.problem.descriptor=Expresión aritmética demasiado compleja #loc
overly.complex.boolean.expression.display.name=Expresión booleana demasiado compleja
overly.complex.boolean.expression.ignore.option=Ignorar conjunciones y disyunciones puras
overly.complex.boolean.expression.max.terms.option=Número máximo de términos:
overly.complex.boolean.expression.problem.descriptor=Expresión booleana demasiado compleja ({0} términos) #loc
overly.complex.class.display.name=Clase demasiado compleja
overly.complex.class.problem.descriptor=Clase demasiado compleja <code>#ref</code> (complejidad ciclomática={0}) #loc
overly.coupled.class.class.coupling.limit.option=Límite de acoplamiento de clase:
overly.coupled.class.display.name=Clase demasiado acoplada
overly.coupled.class.problem.descriptor=<code>#ref</code> está demasiado acoplado (dependencias={0}) #loc
overly.long.lambda.display.name=Expresión lambda demasiado larga
overly.long.lambda.problem.descriptor=Expresión Lambda demasiado larga (número de declaraciones fuente sin comentarios\= {0}).\#loc
overly.strong.type.cast.display.name=Reparto de tipo demasiado fuerte
overly.strong.type.cast.ignore.in.matching.instanceof.option=Ignorar las conversiones con una instancia de expresión coincidente
overly.strong.type.cast.problem.descriptor=La conversión a <code>#ref</code> se puede debilitar a ''{0}'' #loc
overly.strong.type.cast.weaken.quickfix=Debilitar elenco demasiado fuerte
overridable.method.call.in.constructor.display.name=Método reemplazable llamado durante la construcción del objeto
overridable.method.call.in.constructor.problem.descriptor=Llamada al método reemplazable <code>#ref()</code> durante la construcción del objeto #loc
overridden.method.call.in.constructor.display.name=Método anulado llamado durante la construcción del objeto
overridden.method.call.in.constructor.problem.descriptor=Llamada al método reemplazado <code>#ref()</code> durante la construcción del objeto #loc
package.dot.html.may.be.package.info.convert.quickfix=Convierta a '' package-info.java ''.
package.dot.html.may.be.package.info.delete.quickfix=Elimine '' package.html ''.
package.dot.html.may.be.package.info.display.name= package.html '' se puede convertir a '' package-info.java 
package.dot.html.may.be.package.info.exists.problem.descriptor=<code> package.html</code> se ignora porque existe  <code> package-info.java</code>.
package.dot.html.may.be.package.info.problem.descriptor=<code> package.html</code> se puede convertir a <code> package-info.java</code>.
package.in.multiple.modules.display.name=Paquete con clases en varios módulos
package.in.multiple.modules.problem.descriptor.many=Package ''{0}'' has classes in modules ''{1}'', ''{2}'' and ''{3}'' other modules
package.in.multiple.modules.problem.descriptor2=Package ''{0}'' has classes in modules ''{1}'' and ''{2}''
package.in.multiple.modules.problem.descriptor3=Package ''{0}'' has classes in modules ''{1}'', ''{2}'' and ''{3}''
package.info.java.without.package.display.name= paquete '' sin declaración '' package-info.java 
package.info.without.package.family.quickfix=Agregar sintaxis de paquete.
package.info.without.package.problem.descriptor=No hay declaración '' paquete '' en '' paquete-info.java ''.
package.info.without.package.quickfix=Agregue '' paquete {0}; ''.
package.local.field.not.accessible=paquete-campo privado ''{0}'' no es accesible aquí.
package.local.private=package-private \\& private
package.naming.convention.display.name=Convención de nomenclatura de paquetes
package.naming.convention.problem.descriptor.long=El nombre del paquete <code>{0}</code> es demasiado largo
package.naming.convention.problem.descriptor.regex.mismatch=El nombre del paquete <code>{0}</code> no coincide con la expresión regular ''{1}''
package.naming.convention.problem.descriptor.short=El nombre del paquete <code>{0}</code> es demasiado corto
package.visible.field.display.name=Campo visible del paquete
package.visible.field.problem.descriptor=Campo visible del paquete <code>#ref</code> #loc
package.visible.inner.class.display.name=Clase anidada visible al paquete
package.visible.inner.class.ignore.enum.option=Ignorar enumeraciones internas visibles del paquete
package.visible.inner.class.ignore.interface.option=Ignorar interfaces internas visibles para paquetes
package.visible.inner.class.problem.descriptor=Clase anidada visible al paquete <code>#ref</code> #loc
package.with.too.few.classes.display.name=Paquete con muy pocas clases
package.with.too.few.classes.min.option=Número mínimo de clases:
package.with.too.few.classes.problem.descriptor=El paquete ''{0}'' contiene muy pocas clases ({1} <{2})
package.with.too.many.classes.display.name=Paquete con demasiadas clases
package.with.too.many.classes.max.option=Número máximo de clases:
package.with.too.many.classes.problem.descriptor=El paquete ''{0}'' contiene demasiadas clases ({1}> {2})
parameter.hides.member.variable.display.name=El parámetro oculta el campo
parameter.hides.member.variable.ignore.abstract.methods.option=Ignorar para métodos abstractos
parameter.hides.member.variable.ignore.constructors.option=Ignorar para constructores
parameter.hides.member.variable.ignore.setters.option=Ignorar para los establecedores de propiedades
parameter.hides.member.variable.ignore.static.parameters.option=Ignorar los parámetros de métodos estáticos que ocultan campos de instancia
parameter.hides.member.variable.ignore.superclass.option=Ignorar los campos de superclase no visibles desde la subclase
parameter.hides.member.variable.problem.descriptor=El parámetro <code>#ref</code> oculta el campo en la clase ''{0}'' #loc
parameter.limit.option=Límite de parámetro:
parameter.name.differs.from.overridden.parameter.display.name=El nombre del parámetro difiere del parámetro en el método anulado
parameter.name.differs.from.overridden.parameter.ignore.character.option=Ignorar si el parámetro reemplazado contiene solo un carácter
parameter.name.differs.from.overridden.parameter.ignore.library.option=Ignorar si el parámetro reemplazado es de una biblioteca
parameter.name.differs.from.overridden.parameter.problem.descriptor=El nombre del parámetro <code>#ref</code> es diferente del parámetro ''{0}'' anulado #loc
parameter.naming.convention.display.name=Convención de nomenclatura de parámetros de método
parameter.naming.convention.element.description=Parámetro
parameter.type.prevents.overriding.display.name=No se puede anular debido al tipo de parámetro
parameter.type.prevents.overriding.family.quickfix=Cambiar tipo de parámetro ''.
parameter.type.prevents.overriding.problem.descriptor=El tipo de parámetro <code>\#ref</code> está en ''{0}'' pero el tipo de parámetro del método principal es ''{1}'' no se puede anulado.\#loc
parameter.type.prevents.overriding.quickfix=Cambiar el tipo de parámetro a ''{0}''.
parameters.per.constructor.display.name=Constructor con demasiados parámetros
parameters.per.constructor.problem.descriptor=<code>#ref()</code> tiene demasiados parámetros (num parameters={0}) #loc
parameters.per.method.display.name=Método con demasiados parámetros
parameters.per.method.problem.descriptor=<code>#ref()</code> tiene demasiados parámetros (num parameters={0}) #loc
pattern.variable.hides.field.display.name=Pattern variable hides field
pattern.variable.hides.field.problem.descriptor=Pattern variable <code>#ref</code> hides field in class ''{0}'' #loc
pointless.arithmetic.expression.display.name=Expresión aritmética sin sentido
pointless.bitwise.expression.display.name=Expresión bit a bit sin sentido
pointless.bitwise.expression.simplify.quickfix=Simplificar
pointless.boolean.expression.display.name=Expresión booleana sin sentido
pointless.boolean.expression.ignore.option=Ignore las constantes nombradas al determinar expresiones sin sentido
pointless.indexof.comparison.always.false.problem.descriptor=<code>#ref</code> es siempre falso #loc
pointless.indexof.comparison.always.true.problem.descriptor=<code>#ref</code> es siempre verdadero #loc
pointless.indexof.comparison.display.name=Comparación sin sentido 'indexOf()'
pointless.nullcheck.display.name=Verificación 'nula' innecesaria antes de la llamada al método
pointless.nullcheck.problem.descriptor.call=Verificación '' nula '' innecesaria antes de la llamada '' {0}() ''
possible.throw.from.finally.block.problem.descriptor=<code>{0}</code> podría ser lanzado dentro del bloque '' finalmente '' #loc
prefer.empty.array.options.mode.always=Siempre
prefer.empty.array.options.mode.always.never=Never (prefiere una matriz de un tamaño predefinido)
prefer.empty.array.options.mode.by.level=según el nivel de idioma
prefer.empty.array.options.title=Prefiero una matriz vacía\:
prefix.operation.quickfix.family.name=Replace with prefix operator
press.escape.to.remove.highlighting.message=Presione Escape para eliminar el resaltado
primitive.array.argument.to.var.arg.method.display.name=Argumento de matriz primitivo confuso con el método varargs
primitive.array.argument.to.var.arg.method.problem.descriptor=Argumento de matriz primitivo confuso para el método varargs #loc
primitive.fields.ignore.option=Ignorar campos primitivos
printstacktrace.call.display.name=Llamar a 'printStackTrace()'
printstacktrace.call.problem.descriptor=La llamada a <code>#ref()</code> probablemente debería reemplazarse con un registro más sólido #loc
private=private
private.field.not.accessible.problem.descriptor='' private '' Field ''{0}'' no es accesible aquí.
private.member.access.between.outer.and.inner.classes.display.name=Llamada de acceso sintético
private.member.access.between.outer.and.inner.classes.make.constructor.package.local.quickfix=Hacer privado el paquete del constructor ''{0}''
private.member.access.between.outer.and.inner.classes.make.local.quickfix=Hacer ''{0}'' paquete-privado
private.member.access.between.outer.and.inner.classes.problem.descriptor=El acceso al miembro 'privado' de la clase ''{0}'' requiere acceso sintético #loc
problematic.varargs.method.display.name=Los métodos que no son vararg anulan los métodos vararg
problematic.varargs.method.override.problem.descriptor=El método no vararg <code>\#ref()</code> anula el método vararg.\#loc
progress.text.analyzing.package.0=Analyzing package {0}
properties.object.as.hashtable.display.name=Uso del objeto Propiedades como Hashtable
properties.object.as.hashtable.problem.descriptor=Llamada a <code> Hashtable. #ref()</code> en el objeto de propiedades #loc
property.value.set.to.itself.display.name=Valor de propiedad establecido para usted
protected.field.display.name=Campo protegido
protected.field.not.accessible.problem.descriptor='' protected '' Field ''{0}'' no es accesible aquí.
protected.field.problem.descriptor=Campo protegido <code>#ref</code> #loc
protected.inner.class.display.name=Clase anidada protegida
protected.inner.class.ignore.enum.option=Ignorar enumeraciones internas 'protegidas'
protected.inner.class.ignore.interface.option=Ignorar interfaces internas 'protegidas'
protected.inner.class.problem.descriptor=Clase anidada protegida <code>#ref</code> #loc
protected.member.in.final.class.display.name=miembro 'protegido' en la clase 'final'
protected.member.in.final.class.problem.descriptor=Miembro de clase declarado <code>#ref</code> en la clase 'final' #loc
protected.package.local.private=protected, package-private \\& private
public.constructor.display.name=constructor '' público ''
public.constructor.in.non.public.class.display.name=constructor 'público' en una clase no pública
public.constructor.in.non.public.class.problem.descriptor=El constructor se declara <code>#ref</code> en la clase no pública ''{0}'' #loc
public.constructor.in.non.public.class.quickfix=Hacer constructor ''{0}''
public.constructor.problem.descriptor=constructor público <code>\#ref()</code>\#loc
public.constructor.quickfix=Reemplace el constructor con el método factory.
public.default.constructor.problem.descriptor=Class <code>\#ref</code> tiene un constructor predeterminado de '' public ''.
public.field.accessed.in.synchronized.context.display.name=Campo no privado al que se accede en contexto sincronizado
public.field.accessed.in.synchronized.context.problem.descriptor=Campo no privado <code>#ref</code> al que se accede en contexto sincronizado #loc
public.field.display.name=campo 'público'
public.field.ignore.enum.type.fields.option=Ignorar los campos 'final públicos' de un tipo de enumeración
public.field.problem.descriptor=campo 'público' <code>#ref</code> #loc
public.inner.class.display.name=clase anidada 'pública'
public.inner.class.ignore.enum.option=Ignorar enumeraciones internas 'públicas'
public.inner.class.ignore.interface.option=Ignorar interfaces internas 'públicas'
public.inner.class.problem.descriptor=clase anidada 'public' <code>#ref</code> #loc
public.method.not.in.interface.display.name=método 'público' no expuesto en la interfaz
public.method.not.in.interface.option=<html>Ignorar si la clase contenedora no implementa una interfaz que no sea de biblioteca</html>
public.method.not.in.interface.problem.descriptor=El método 'public' <code>#ref()</code> no se expone a través de una interfaz #loc
public.method.without.logging.display.name=método 'público' sin registro
public.method.without.logging.problem.descriptor=El método 'public' <code>#ref()</code> no tiene una llamada de registro #loc
public.static.array.field.display.name=campo de matriz 'público estático'
public.static.array.field.problem.descriptor=campo de matriz 'public static' <code>#ref</code>, comprometiendo la seguridad #loc
public.static.collection.field.display.name=campo de colección 'público estático'
public.static.collection.field.problem.descriptor=campo de colección 'public static' <code>#ref</code>, comprometiendo la seguridad #loc
qualify.call.fix.family.name=Calificación de referencia
query.label=Query names start with:
questionable.name.display.name=Nombre cuestionable
questionable.name.list.label=Reported names:
questionable.name.problem.descriptor=Nombre cuestionable <code>#ref</code> #loc
random.double.for.random.integer.display.name=Usando 'Random.nextDouble()' para obtener un entero aleatorio
random.double.for.random.integer.problem.descriptor=Usando <code> Random.#Ref</code> para crear un número entero aleatorio #loc
raw.use.of.parameterized.type.display.name=Uso sin procesar de la clase parametrizada
readobject.initialization.display.name=El campo de instancia no puede ser inicializado por 'readObject()'
readobject.initialization.problem.descriptor=Es posible que el campo de instancia <code>#ref</code> no se inicialice durante la llamada de 'readObject()' #loc
readresolve.writereplace.protected.display.name=readResolve()' o 'writeReplace()' no declarado 'protegido
readresolve.writereplace.protected.problem.descriptor=<code>#ref()</code> no declarado 'protegido' #loc
readwriteobject.private.display.name=readObject()' o 'writeObject()' no declarado como 'privado
readwriteobject.private.problem.descriptor=<code>#ref</code> no declarado 'privado' #loc
recordstore.opened.not.safely.closed.display.name=RecordStore abierto pero no cerrado de forma segura
redundant.as.list.for.iteration.fix.name=Desactivar las nuevas líneas
redundant.as.list.for.iteration.problem=Llamada innecesaria a '' Arrays.asList()''
redundant.call.problem.descriptor=Llamada redundante a <code>#ref()</code> #loc
redundant.else.display.name='else' redundante
redundant.else.problem.descriptor=<code>#ref</code> rama se puede desenvolver, ya que la rama 'if' nunca se completa normalmente #loc
redundant.else.unwrap.quickfix=Eliminar el 'else' redundante
redundant.escape.in.regex.replacement.display.name=Redundant escape in regex replacement string
redundant.escape.in.regex.replacement.problem.descriptor=Redundant escape of ''{0}''
redundant.escape.in.regex.replacement.quickfix=Remove redundant escape
redundant.explicit.var.type.display.name=El tipo de variable local se puede omitir
redundant.field.initialization.display.name=Inicialización de campo redundante
redundant.field.initialization.problem.descriptor=La inicialización del campo a <code>#ref</code> es redundante #loc
redundant.field.initialization.remove.quickfix=Eliminar inicializador
redundant.implements.display.name=Declaración de interfaz redundante
redundant.implements.problem.descriptor=Declaración de interfaz redundante <code>#ref</code> #loc
redundant.implements.remove.quickfix=Eliminar declaración de interfaz redundante
redundant.local.variable.annotation.option=Ignorar las variables que tienen una anotación
redundant.local.variable.display.name=Variable local redundante
redundant.local.variable.ignore.option=Ignorar variables devueltas o lanzadas inmediatamente
redundant.method.override.delegate.quickfix=Replace method with delegate to super
redundant.method.override.delegates.to.super.problem.descriptor=Method <code>#ref()</code> only delegates to its super method #loc
redundant.method.override.display.name=El método es idéntico a su súper método
redundant.method.override.option.check.library.methods=Check methods overriding library methods
redundant.method.override.option.ignore.delegates=Ignore delegates to super methods
redundant.method.override.problem.descriptor=El método <code> #ref()</code> es idéntico a su súper método #loc
redundant.method.override.quickfix=Eliminar método redundante
redundant.string.format.call.display.name=Llamada redundante a 'String.format()'
redundant.string.format.call.quickfix=Eliminar la llamada redundante a 'String.format()'
redundant.string.formatted.call.quickfix=Eliminar la llamada redundante a 'String.formatted()'
referencing.subclass.0.from.superclass.1.initializer.might.lead.to.class.loading.deadlock=La referencia a la subclase {0} en el inicializador de superclase {1} hace que se produzca un interbloqueo de carga de clases.
reflection.for.unavailable.annotation.display.name=Acceso reflectante a una anotación de solo fuente
reflection.for.unavailable.annotation.problem.descriptor=La anotación '#ref' no se retiene para el acceso reflectante #loc
refused.bequest.display.name=El método no llama al súper método
refused.bequest.fix.family.name=Insertar llamada al método principal
refused.bequest.ignore.default.super.methods.option=Ignorar los súper métodos 'predeterminados'
refused.bequest.ignore.empty.super.methods.option=Ignorar supermétodos vacíos
refused.bequest.problem.descriptor=El método <code> #ref()</code> no llama a 'super.#ref()' #loc
remove.annotation.parameter.0.fix.name=Remove annotation parameter ''{0}''
remove.call.fix.family.name=Eliminar llamada
remove.cloneable.quickfix=Eliminar 'Cloneable' de la cláusula de implementos
remove.finally.block.quickfix=Eliminar el bloque 'finalmente'
remove.leading.zero.to.make.decimal.quickfix=Elimina el cero inicial para hacer decimal
remove.leading.zeroes.to.make.decimals.quickfix=Elimina los ceros iniciales para hacer decimales
remove.loop.fix.family.name=Eliminar bucle
remove.modifier.fix.family.name=Eliminar modificador
remove.modifier.quickfix=Eliminar modificador ''{0}''
remove.redundant.polyadic.operand.fix.family.name=Eliminar condición innecesaria
remove.redundant.polyadic.operand.fix.name=Eliminar condición innecesaria ''{0}''
remove.redundant.string.fix.text= {0}()'' y elimina llamadas innecesarias '' {1}()
remove.redundant.substring.fix.family.name=Eliminar llamadas duplicadas '' substring()''
remove.try.finally.block.quickfix=Eliminar el bloque 'intentar finalmente'
remove.unnecessary.0.call.quickfix=Remove unnecessary ''{0}()'' call
rename.quickfix=Cambiar nombre
renameto.quickfix=Cambiar nombre a ''{0}''
replace.all.dot.display.name=Argumento de expresión regular sospechosa
replace.all.dot.problem.descriptor=Expresión regex sospechosa#refen la llamada a ''{0}()'' #loc
replace.all.dot.quickfix=Escape del metacarácter de expresión regular
replace.all.file.separator.problem.descriptor=File.separator is used as a regex; will not work on Windows
replace.anonymous.with.lambda.body.fix.family.name=Reemplazar la llamada con el cuerpo del método
replace.case.default.null.with.null.default=Replace 'case default, null' with 'case null, default'
replace.case.default.with.default=Replace 'case default' with 'default'
replace.cast.fix.family.name=Reemplazar tipo de conversión
replace.casted.literal.with.just.literal.fix.family.name={0} reemplazar con literal
replace.field.reference.fix.family.name=Reemplazar la referencia del campo
replace.field.reference.fix.text=Reemplazar la referencia del campo con {0}
replace.inheritance.with.delegation.quickfix=Reemplazar herencia con delegación
replace.instanceof.fix.family.name=instanceOf tipo de reemplazo
replace.method.call.fix.family.name=Reemplazar llamada al método
replace.method.call.fix.text=Reemplazar la llamada al método con {0}
replace.method.ref.with.qualifier.fix.family.name=reemplazar con calificador
replace.method.ref.with.qualifier.problem.lambda=Puede reemplazar lambda con un calificador de método
replace.method.ref.with.qualifier.problem.method=Puede reemplazar la referencia del método con un calificador
replace.with.cast.fix.family.name=Reemplazar con cast
replace.with.catch.clause.for.runtime.exception.quickfix=Reemplazar con la cláusula 'catch' para 'RuntimeException'
replace.with.comparator.fix.family.name=Simplifique los comparadores usando el método static Comparator
replace.with.lambda.body.fix.family.name=Reemplazar la llamada al método lambda con el cuerpo lambda
replace.with.method.ref.fix.family.name=Reemplazar lambda con la referencia del método
replace.with.method.ref.fix.name.may.change.semantics=Reemplaza lambda con la referencia del método (la semántica puede cambiar)
replace.with.method.reference.fix.family.name=Reemplazar la llamada al método en la referencia del método con la llamada al método adecuada
replace.with.var.fix.family.name=Reemplazar el tipo explícito con '' var ''
resource.opened.not.closed.problem.descriptor=''{0}'' debe abrirse frente a un bloque ''try'' y cerrarse en el bloque '' finalmente '' correspondiente #loc
result.of.method.call.ignored.class.column.title=Nombre de la clase
result.of.method.call.ignored.display.name=Resultado de la llamada al método ignorado
result.of.method.call.ignored.non.library.option=Informar todas las llamadas ignoradas que no pertenecen a la biblioteca
result.of.method.call.ignored.problem.descriptor=El resultado de <code>{0}. #ref()</code> se ignora #loc
result.of.object.allocation.fix.name=Ignorar la asignación de objetos de tipo ''{0}''
result.of.object.allocation.ignored.display.name=Resultado de la asignación del objeto ignorado
result.of.object.allocation.ignored.options.chooserTitle=Seleccione una clase que pueda ignorar la asignación de objetos
result.of.object.allocation.ignored.problem.descriptor=El resultado de <code>new #ref()</code> se ignora #loc
return.from.finally.block.display.name=regresar' dentro del bloque 'finalmente
return.from.finally.block.problem.descriptor=<code>#ref</code> dentro del bloque 'finalmente' #loc
return.of.anonymous.class.problem.descriptor=Devuelve una instancia de una clase anónima.\#loc
return.of.collection.field.fix.family.name=Crear colección de devolución como '' no modificable ''
return.of.field.with.mutable.type.problem.descriptor={0} return field <code> {1}</code>\#loc
return.of.inner.class.display.name=Devuelve una instancia de una clase anónima, local o interna
return.of.inner.class.ignore.non.public.option=Ignorar la devolución de métodos no públicos
return.of.inner.class.problem.descriptor=Devuelve una instancia de la clase interna no estática <code> {0}</code>.\#loc
return.of.local.class.problem.descriptor=Devuelve una instancia de la clase local <code> {0}</code>.\#loc
return.of.null.arrays.option=Métodos de informe que devuelven matrices
return.of.null.collections.option=Métodos de informe que devuelven objetos de colección
return.of.null.display.name=Devolución de 'nulo'
return.of.null.ignore.private.option=Ignorar métodos 'privados', clases anónimas \\& lambda
return.of.null.objects.option=Métodos de informe que devuelven objetos
return.of.null.problem.descriptor=Devolución de <code>#ref</code> #loc
return.point.limit.option=&Límite de punto de retorno:
return.this.display.name=Retorno de 'esto'
return.this.problem.descriptor=Devolución de <code>#ref</code> #loc
reuse.of.local.variable.display.name=Reutilización de variable local
reuse.of.local.variable.problem.descriptor=Reutilización de la variable local <code>#ref</code> #loc
reuse.of.local.variable.split.quickfix=Dividir variable local
runtime.exec.call.display.name=Llamar a 'Runtime.exec()'
runtime.exec.call.problem.descriptor=Llamada a <code> Runtime. #ref()</code> no es portátil #loc
runtime.exec.with.non.constant.string.display.name=Llamada a 'Runtime.exec()' con una cadena no constante
runtime.exec.with.non.constant.string.problem.descriptor=Llamada a <code>Runtime. #ref()</code> con argumento no constante #loc
safe.lock.display.name=Bloqueo adquirido pero no desbloqueado de forma segura
safe.lock.problem.descriptor=''{0}'' debe estar bloqueado frente a un bloque ''try'' y desbloqueado en el bloque '' finalmente '' correspondiente #loc
serial.annotation.used.on.wrong.member.display.name=Anotación '@Serial' utilizada en miembro incorrecto
serial.annotation.used.on.wrong.member.problem.descriptor=Los miembros anotados no están incluidos en el mecanismo de serialización.
serializable.anonymous.class.stores.non.serializable.problem.descriptor=serializable La clase anónima almacena implícitamente un objeto no serializable de tipo ''{0}''.
serializable.class.in.secure.context.display.name=Clase serializable en contexto seguro
serializable.class.in.secure.context.problem.descriptor=La clase <code>#ref</code> puede ser serializada, comprometiendo la seguridad #loc
serializable.deserializable.class.in.secure.context.problem.descriptor=La clase <code>#ref</code> puede ser serializada y deserializada, comprometiendo la seguridad #loc
serializable.has.serialization.methods.display.name=Clase serializable sin 'readObject()' y 'writeObject()'
serializable.has.serialization.methods.ignore.option=Ignorar clases que no definen campos de instancia
serializable.has.serialization.methods.problem.descriptor=La clase serializable <code>#ref</code> no define 'readObject()' o 'writeObject()' #loc
serializable.has.serialization.methods.problem.descriptor1=La clase serializable <code>#ref</code> no define 'writeObject()' #loc
serializable.has.serialization.methods.problem.descriptor2=La clase serializable <code>#ref</code> no define 'readObject()' #loc
serializable.inner.class.has.serial.version.uid.field.display.name=Clase interna serializable no 'estática' sin 'serialVersionUID'
serializable.inner.class.has.serial.version.uid.field.problem.descriptor=La clase interna <code>#ref</code> no define un campo 'serialVersionUID' #loc
serializable.inner.class.with.non.serializable.outer.class.display.name=Clase interna serializable no 'estática' con clase externa no serializable
serializable.inner.class.with.non.serializable.outer.class.problem.descriptor=La clase interna <code>#ref</code> es serializable mientras que su clase externa no es #loc
serializable.lambda.stores.non.serializable.problem.descriptor=lambda serializable almacena implícitamente un objeto no serializable de tipo ''{0}''
serializable.local.class.stores.non.serializable.problem.descriptor=clase local serializable ''{1}'' almacena implícitamente un objeto no serializable de tipo ''{0}''.
serializable.record.contains.ignored.field.problem.descriptor=<code>\#ref</code> se ignora durante la serialización de registros
serializable.record.contains.ignored.members.display.name='registro' contiene miembros ignorados
serializable.record.contains.ignored.method.problem.descriptor=<code>\#ref()</code> se ignora mientras la serialización de registros está en curso
serializable.stores.non.serializable.display.name=objeto serializable almacena implícitamente objetos no serializables
serializable.with.unconstructable.ancestor.display.name=Clase serializable con ancestro inconstructable
serializable.with.unconstructable.ancestor.problem.descriptor=<code>#ref</code> tiene un ancestro no serializable ''{0}'' sin constructor sin argumentos #loc
serialpersistentfields.with.wrong.signature.display.name=El campo 'serialPersistentFields' no se declaró 'Private static final ObjectStreamField[]'
serialpersistentfields.with.wrong.signature.problem.descriptor=El campo <code>#ref</code> de una clase serializable no se declara 'private static final ObjectStreamField []' #loc
serialversionuid.private.static.final.long.display.name=serialVersionUID' campo no declarado 'private static final long
serialversionuid.private.static.final.long.problem.descriptor=El campo <code>#ref</code> de una clase serializable no se declara 'private static final long' #loc
serialversionuid.private.static.final.long.quickfix=Hacer serialVersionUID 'privado estático final'
set.annotation.parameter.0.1.fix.name=Set annotation parameter {0} = "{1}"
set.replaceable.by.enum.set.display.name=Conjunto reemplazable con EnumSet
set.replaceable.by.enum.set.problem.descriptor=<code>#ref</code> reemplazable por 'EnumSet' #loc
shared.thread.local.random.display.name=La instancia '' ThreadLocalRandom '' se puede compartir
shared.thread.local.random.problem.descriptor=La instancia '' ThreadLocalRandom '' se puede compartir entre subprocesos.
shift.operation.by.inappropriate.constant.display.name=Operación de cambio por constante inapropiada
shift.operation.by.inappropriate.constant.problem.descriptor.negative=Operación de cambio <code>#ref</code> por valor constante negativo {0}#loc
shift.operation.by.inappropriate.constant.problem.descriptor.out.of.bounds=Operación de cambio <code>#ref</code> por valor fuera de límites {0}#loc
shift.operation.by.inappropriate.constant.problem.descriptor.too.large=Operación de cambio <code>#ref</code> por un valor constante demasiado grande {0}#loc
shift.out.of.range.fix.family.name=Modificar valor de turno
side.effects.method.ref.to.lambda.fix.family.name={0} (efectos secundarios)
signal.without.corresponding.await.display.name=signal()' sin el correspondiente 'await()
signal.without.corresponding.await.problem.descriptor=Llamar a <code>#ref</code> sin el <code> await()</code> #loc correspondiente
simplifiable.annotation.braces.problem.descriptor=Unnecessary braces around <code>{0}</code> in annotation #loc
simplifiable.annotation.display.name=Anotaciones simplificables
simplifiable.annotation.problem.descriptor=La anotación <code>\#ref</code> no es necesaria.\#loc
simplifiable.annotation.quickfix=Anotaciones simples.
simplifiable.annotation.whitespace.problem.descriptor=Los espacios en blanco de anotación no son necesarios.\#loc
simplifiable.boolean.expression.display.name=Expresión booleana simplificable
simplifiable.conditional.expression.display.name=Expresión condicional simplificable
simplifiable.conditional.expression.problem.descriptor=<code>#ref</code> se puede simplificar a ''{0}'' #loc
simplifiable.equals.expression.display.name=Verificación '' nula '' innecesaria antes de llamar a '' equals()''
simplifiable.equals.expression.option.non.constant=Informe igual con argumentos no constantes y no nulos
simplifiable.equals.expression.problem.descriptor='' {0}()'' Verificación '' nula '' innecesaria antes de llamar.\#loc
simplifiable.equals.expression.quickfix=''. {0}()'' invierte y elimina las comprobaciones '' nulas '' innecesarias.
simplifiable.junit.assertion.display.name=Aserción simplificable
simplifiable.junit.assertion.problem.descriptor=<code>#ref()</code> puede simplificarse a ''{0}'' #loc
simplify.junit.assertion.simplify.quickfix=Simplificar la afirmación
single.character.startswith.display.name=Carácter único 'startsWith()' o 'endsWith()'
single.character.startswith.problem.descriptor=Un solo carácter <code>#ref()</code> podría reemplazarse con la expresión 'charAt()' #loc
single.character.startswith.quickfix=Reemplazar con la expresión 'charAt()'
single.class.import.display.name=Importación de clase única
single.class.import.problem.descriptor=Importación de clase única <code>#ref</code> #loc
single.element.annotation.family.quickfix=Expandir anotaciones a forma genérica.
single.element.annotation.name=Anotación de un solo elemento
single.element.annotation.quickfix=Agregue '' value\= ''.
single.statement.in.block.descriptor=''{0}'' tiene una sola sintaxis.
single.statement.in.block.family.quickfix=Eliminar llaves en la sintaxis.
single.statement.in.block.name=Un bloque de código tiene una sola declaración
single.statement.in.block.quickfix=Elimine las llaves en la declaración ''{0}''.
singleton.display.name=Singleton
singleton.problem.descriptor=Class <code>#ref</code> es un singleton #loc
size.replaceable.by.isempty.display.name=size() == 0' reemplazable por 'isEmpty()
size.replaceable.by.isempty.fix.ignore.calls=Ignorando la llamada ''.{0}()'' al escribir ''{1}''
size.replaceable.by.isempty.negation.ignore.option=Ignorar expresiones que serían reemplazadas por '!isEmpty()'
sleep.while.holding.lock.display.name=Llamar a 'Thread.sleep()' mientras está sincronizado
sleep.while.holding.lock.problem.descriptor=Llamar a <code>Thread. #ref()</code> mientras está sincronizado #loc
smth.unnecessary.remove.quickfix=Eliminar innecesarios ''{0}''
socket.opened.not.closed.display.name=Enchufe abierto pero no cerrado de forma segura
standard.variable.names.display.name=Nombres de variables estándar
standard.variable.names.ignore.override.option=Ignorar los nombres de los parámetros idénticos a los parámetros del súper método
standard.variable.names.problem.descriptor=La variable denominada <code>#ref</code> no tiene el tipo ''{0}'' #loc
standard.variable.names.problem.descriptor2=La variable denominada <code>#ref</code> no tiene el tipo ''{0}'' o ''{1}'' #loc
statement.problem.descriptor=<code>#ref</code> declaración #loc
statement.with.empty.body.display.name=Declaración con cuerpo vacío
statement.with.empty.body.include.option=Incluir cuerpos de declaración que son bloques de código vacíos
statement.with.empty.body.problem.descriptor=<code>#ref</code> declaración tiene cuerpo vacío #loc
static.collection.display.name=Colección estática
static.collection.ignore.option=Ignorar colecciones o mapas estáticos débiles
static.collection.problem.descriptor=Colección estática <code>#ref</code> #loc
static.field.via.subclass.display.name=Campo estático referenciado mediante subclase
static.field.via.subclass.problem.descriptor=Campo estático <code>#ref</code> declarado en la clase ''{0}'' pero referenciado mediante la subclase ''{1}'' #loc
static.field.via.subclass.rationalize.quickfix=Racionalizar el acceso al campo estático
static.import.display.name=Importación estática
static.import.fix.ignore.class=Permitir declaración de importación estática de la clase ''{0}''
static.import.options.border.title=clases importables estáticamente
static.import.options.chooserTitle=Seleccionar clases importables estáticamente
static.import.problem.descriptor=Importación estática <code>#ref</code> #loc
static.import.replace.quickfix=Reemplazar con importación no estática
static.inheritance.display.name=Herencia estática
static.inheritance.fix.family.name=Reemplazar herencia con una referencia completamente calificada
static.inheritance.problem.descriptor=La interfaz <code>#ref</code> se implementa solo para sus constantes 'estáticas' #loc
static.inheritance.replace.quickfix=Reemplazar herencia con referencias calificadas en {0}
static.initializer.references.subclass.display.name=El inicializador estático hace referencia a una subclase
static.method.naming.convention.element.description=static
static.method.only.used.in.one.anonymous.class.problem.descriptor=Static {0, choice, 1#method | 2#field} <code>#ref{0, choice, 1 #() | 2 #}</code> solo se usa a partir de una clase anónima derivada de ''{1}'' #loc
static.method.only.used.in.one.class.display.name=Miembro estático que solo se usa de otra clase
static.method.only.used.in.one.class.ignore.anonymous.option=Ignorar cuando solo se usa desde una clase anónima
static.method.only.used.in.one.class.ignore.on.conflicts=Ignorar cuando el método no se puede mover sin conflictos
static.method.only.used.in.one.class.ignore.test.option=Ignorar cuando solo se usa desde una clase de prueba
static.method.only.used.in.one.class.ignore.utility.classes=Ignorar miembros ubicados en clases de servicios públicos
static.method.only.used.in.one.class.problem.descriptor=Static {0, choice, 1#method | 2#field} <code>#ref{0, choice, 1 #() | 2 #}</code> solo se usa desde la clase ''{1}'' #loc
static.method.only.used.in.one.class.quickfix=Mover{0} a la clase de uso
static.method.only.used.in.one.class.quickfix.preview=Moves the static member to the class where it is used.
static.method.via.subclass.display.name=Método estático referenciado a través de una subclase
static.method.via.subclass.problem.descriptor=Método estático <code>#ref()</code> declarado en la clase ''{0}'' pero referenciado mediante la subclase ''{1}'' #loc
static.method.via.subclass.rationalize.quickfix=Racionalizar la llamada al método estático
static.non.final.field.display.name=campo 'estático', no 'final'
static.non.final.field.option=Solo reportar campos 'públicos'
static.non.final.field.problem.descriptor=campo 'estático' no 'final' <code>#ref</code> #loc
static.variable.may.not.be.initialized.display.name=El campo estático no se puede inicializar
static.variable.may.not.be.initialized.problem.descriptor=El campo estático <code>#ref</code> no se puede inicializar durante la inicialización de la clase #loc
static.variable.naming.convention.element.description=campo 'estático'
static.variable.of.concrete.class.problem.descriptor=Campo estático ''{0}'' de clase concreta <code>#ref</code> #loc
static.variable.used.before.initialization.display.name=Campo estático usado antes de la inicialización
static.variable.used.before.initialization.problem.descriptor=Campo estático <code>#ref</code> usado antes de la inicialización #loc
string.buffer.must.have.initial.capacity.display.name=StringBuilder sin capacidad inicial
string.buffer.must.have.initial.capacity.problem.descriptor=<code>new#ref()</code> sin capacidad inicial #loc
string.buffer.replaceable.by.string.builder.display.name=StringBuffer' puede ser 'StringBuilder
string.buffer.replaceable.by.string.builder.problem.descriptor=<code>StringBuffer#ref</code> puede declararse como 'StringBuilder' #loc
string.buffer.replaceable.by.string.display.name=StringBuilder' puede ser reemplazado por 'String
string.buffer.replaceable.by.string.problem.descriptor=<code>{0}#ref</code> se puede reemplazar con '' String '' #loc
string.comparison.display.name=Comparación de cadenas usando '==', en lugar de 'equals()'
string.comparison.problem.descriptor=Los valores de cadena se comparan usando <code>#ref</code>, no 'equals()' #loc
string.concatenation.argument.to.log.call.display.name=Concatenar cadenas no constantes como argumentos para registrar llamadas
string.concatenation.argument.to.log.call.problem.descriptor=<code>\#ref()</code> Concatenar una cadena no constante como argumento para la llamada de registro\#loc
string.concatenation.argument.to.log.call.quickfix=Reemplazar la concatenación con mensajes de registro parametrizados.
string.concatenation.argument.to.log.message.format.call.quickfix=Replace 'Message.format()' with parameterized log message
string.concatenation.argument.to.log.string.format.call.quickfix=Replace 'String.format()' with parameterized log message
string.concatenation.display.name=Concatenación de cadenas
string.concatenation.in.format.call.display.name=concatenación de cadenas como argumento para llamar '' format()''
string.concatenation.in.format.call.fix.family.name=Reemplazar la concatenación con argumentos.
string.concatenation.in.format.call.problem.descriptor=La llamada a <code>\#ref()</code> tiene un argumento de concatenación de cadenas.\#loc
string.concatenation.in.format.call.quickfix=Reemplazar la concatenación con un argumento separado.
string.concatenation.in.loops.display.name=Concatenación de cadenas en bucle
string.concatenation.in.loops.problem.descriptor=Concatenación de cadenas <code>#ref</code> en el bucle #loc
string.concatenation.in.message.format.call.display.name=concatenación de cadenas como argumento para llamar a '' MessageFormat.format()''
string.concatenation.in.message.format.call.problem.descriptor=string concatenation\#loc como argumento para llamar '' MessageFormat.format()''
string.concatenation.inside.string.buffer.append.display.name=Concatenación de cadenas como argumento para la llamada 'StringBuilder.append()'
string.concatenation.inside.string.buffer.append.problem.descriptor=Concatenación de cadenas como argumento para <code> {0}. #ref()</code> llamada #loc
string.concatenation.inside.string.buffer.append.replace.quickfix=Reemplazar con llamadas encadenadas 'append()'
string.concatenation.introduce.fix=Inserte StringBuilder.
string.concatenation.introduce.fix.name=Actualizar la variable ''{0}'' insertando un nuevo {1}
string.concatenation.introduce.fix.name.null.safe=Actualizar la variable ''{0}'' insertando un nuevo {1} (nulo seguro)
string.concatenation.missing.whitespace.display.name=Falta un espacio en blanco en la concatenación literal de cadena
string.concatenation.missing.whitespace.option=Ignorar la concatenación con cadenas de variables
string.concatenation.missing.whitespace.problem.descriptor=Falta un espacio en blanco en la concatenación literal de cadena.\#loc
string.concatenation.problem.descriptor=Concatenación de cadenas <code>#ref</code> en un contexto internacionalizado #loc
string.concatenation.replace.fix=Reemplazar con StringBuilder.
string.concatenation.replace.fix.name=Convertir variable ''{0}'' de cadena a {1}
string.concatenation.replace.fix.name.null.safe=Convertir variable ''{0}'' de cadena a {1} (nulo seguro)
string.equals.char.sequence.display.name='' CharSequence '' Call '' String.equals()'' con argumento
string.equals.char.sequence.problem.descriptor=<code> String.\# ref()</code> se llama con el argumento ''{0}''.\#loc
string.equals.empty.string.display.name=String.equals ("")
string.equals.empty.string.fix.family.name=Simplificar la verificación de cadenas vacías
string.equals.empty.string.is.empty.problem.descriptor=<code>#ref("")</code> se puede reemplazar con 'isEmpty()' #loc
string.equals.empty.string.option.do.not.add.null.check=No informar cuando pueda ser necesaria una verificación nula
string.equals.empty.string.problem.descriptor=<code>#ref("")</code> se puede reemplazar con 'length() == 0' #loc
string.format.choose.class=Elija la clase Formatter
string.format.class.label=Additional formatter classes:
string.format.class.method.label=Additional formatter methods:
string.indexof.replaceable.by.contains.display.name=La expresión 'String.indexOf()' es reemplazable por 'contains()'
string.replace.quickfix=Reemplazar la concatenación con ''{0}''
string.replaceable.by.string.buffer.display.name=La cadena no constante debe ser StringBuilder
string.replaceable.by.string.buffer.in.loop.option=Solo advertir cuando se agrega en un bucle
string.replaceable.by.string.buffer.problem.descriptor=El <code>String#ref</code> no constante probablemente debería declararse como '' StringBuilder '' #loc
string.touppercase.tolowercase.without.locale.display.name=Llamada a 'String.toUpperCase()' o 'toLowerCase()' sin una configuración regional
string.touppercase.tolowercase.without.locale.problem.descriptor=<code> String. #ref()</code> llamado sin especificar un Locale usando cadenas internacionalizadas #loc
stringbuffer.field.display.name=campo StringBuilder
stringbuffer.field.problem.descriptor=''{0}'' campo <code>#ref</code> #loc
subtraction.in.compareto.display.name=Resta en 'compareTo()'
subtraction.in.compareto.problem.descriptor=La resta <code>#ref</code> en 'compareTo()' puede resultar en desbordamiento o pérdida de precisión #loc
super.class.logger.option=Ignorar clases con un registrador accesible declarado en una superclase
suppress.for.tests.scope.quickfix='' Pruebas '' Suprime el alcance.
suspicious.array.cast.display.name=Casting de matriz sospechoso
suspicious.array.cast.problem.descriptor=Una transmisión sospechosa a <code>\#ref</code>.\#loc
suspicious.comparator.compare.descriptor.min.value=Returning Integer.MIN_VALUE from a comparison function is discouraged
suspicious.comparator.compare.descriptor.non.negative=Comparator never returns negative values
suspicious.comparator.compare.descriptor.non.positive=Comparator never returns positive values
suspicious.comparator.compare.descriptor.non.reflexive=El comparador no devuelve 0 para elementos iguales
suspicious.comparator.compare.descriptor.parameter.not.used=El parámetro <code>#ref</code> 'compare()' no se usa #loc
suspicious.comparator.compare.display.name=Implementación sospechosa de 'Comparator.compare()'
suspicious.getter.problem.descriptor=Getter <code>\#ref()</code> devuelve el campo ''{0}''\#loc
suspicious.getter.setter.display.name=Captador/setter sospechoso
suspicious.indent.after.control.statement.display.name=Sangría sospechosa después de la declaración de control sin llaves
suspicious.indent.after.control.statement.problem.descriptor=<code>#ref</code> declaración tiene sangría sospechosa #loc
suspicious.integer.div.assignment.display.name=Asignación sospechosa de división de enteros
suspicious.integer.div.assignment.problem.descriptor=El resultado de la división se redondea a un número entero.
suspicious.integer.div.assignment.quickfix=Tipo de conversión a double.
suspicious.literal.underscore.display.name=Subrayado sospechoso en literal numérico
suspicious.literal.underscore.problem.descriptor=Los grupos en literales numéricos de subrayado no tienen una longitud de 3.\#loc
suspicious.package.private.access.display.name=Acceso privado al paquete sospechoso
suspicious.setter.problem.descriptor=setter <code>\#ref()</code> sustituye el campo ''{0}''.\#loc
suspicious.system.arraycopy.display.name=Llamada sospechosa 'System.arraycopy()'
suspicious.system.arraycopy.problem.descriptor.length.bigger.dest=La longitud siempre es mayor que '' dest.length - destPos '' {0}
suspicious.system.arraycopy.problem.descriptor.length.bigger.src=La longitud siempre es mayor que '' src.length - srcPos '' {0}
suspicious.system.arraycopy.problem.descriptor.ranges.intersect=Copiando a la misma matriz con rangos de intersección
suspicious.system.arraycopy.problem.descriptor4=<code>#ref</code> no es de un tipo de matriz #loc
suspicious.system.arraycopy.problem.descriptor5=<code>#ref</code> no es de un tipo de matriz #loc
suspicious.system.arraycopy.problem.descriptor6=El tipo de parámetro de origen ''{0}'' no se puede asignar al parámetro de destino <code>#ref</code> de tipo ''{1}'' #loc
suspicious.to.array.call.display.name=Llamada sospechosa 'Collection.toArray()'
suspicious.to.array.call.fix.family.name=Reemplazar con la matriz apropiada
suspicious.to.array.call.problem.descriptor=Se esperaba una matriz de tipo ''{0}[] '', se encontró #loc
swap.equals.fix.family.name=Invertir llamadas al método
switch.expression.with.single.default.message=La expresión 'switch' solo tiene el caso 'predeterminado'
switch.expression.with.too.few.branches.problem.descriptor=La expresión ''switch'' tiene muy pocas etiquetas de mayúsculas y minúsculas ({0}), y probablemente debería reemplazarse con una declaración ''if'' o un operador condicional#loc
switch.statement.density.display.name=declaración 'switch' con una densidad de rama demasiado baja
switch.statement.density.min.option=Densidad mínima de ramas:%
switch.statement.density.problem.descriptor=<code>#ref</code> tiene una densidad de rama demasiado baja ({0}%) #loc
switch.statement.display.name=declaración 'switch'
switch.statement.with.confusing.declaration.display.name=Variable local utilizada y declarada en diferentes ramas 'switch'
switch.statement.with.confusing.declaration.problem.descriptor=Variable local <code>#ref</code> declarada en una rama 'switch' y utilizada en otra #loc
switch.statement.with.single.default.message=la declaración 'switch' solo tiene el caso 'predeterminado'
switch.statement.with.too.few.branches.display.name=declaración 'switch' con muy pocas ramas
switch.statement.with.too.few.branches.ignore.pattern.option=Do not report pattern switch statements
switch.statement.with.too.few.branches.min.option=Número mínimo de ramas:
switch.statement.with.too.few.branches.problem.descriptor=La declaración ''switch'' tiene muy pocas etiquetas de caso ({0}), y probablemente debería reemplazarse con una declaración ''if'' #loc
switch.statement.with.too.many.branches.display.name=declaración 'switch' con demasiadas ramas
switch.statement.without.default.ignore.option=Ignorar si todos los casos de un tipo de enumeración están cubiertos
switch.statements.without.default.display.name=declaración 'switch' sin rama 'predeterminada'
switch.statements.without.default.problem.descriptor=<code>#ref</code> declaración sin rama 'predeterminada' #loc
synchronization.on.get.class.display.name='' getClass()'' Sincronización
synchronization.on.get.class.problem.descriptor=<code>\#ref()</code> Sincronización\#loc
synchronization.on.local.variable.or.method.parameter.display.name=Sincronización en variable local o parámetro de método
synchronization.on.local.variable.problem.descriptor=Sincronización en la variable local <code>#ref</code> #loc
synchronization.on.method.parameter.problem.descriptor=Sincronización en el parámetro del método <code>#ref</code> #loc
synchronization.on.static.field.display.name=Sincronización de campo '' estática ''
synchronization.on.static.field.problem.descriptor=campo '' estático '' <code>\#ref</code> sincronización\#loc
synchronize.on.class.problem.descriptor=Las operaciones de bloqueo en una clase pueden tener efectos secundarios imprevistos #loc
synchronize.on.lock.display.name=Sincronización en un objeto de bloqueo
synchronize.on.lock.problem.descriptor=Es poco probable que la sincronización en un objeto ''{0}'' sea intencional #loc
synchronize.on.non.final.field.display.name=Sincronización en un campo no final
synchronize.on.non.final.field.problem.descriptor=Sincronización en un campo no final <code>#ref</code> #loc
synchronize.on.this.display.name=Sincronización en 'esto'
synchronize.on.this.problem.descriptor=Las operaciones de bloqueo en 'esto' pueden tener efectos secundarios imprevistos #loc
synchronized.method.display.name=método 'synchronized'
synchronized.method.ignore.synchronized.super.option=Ignorar métodos que anulan un método sincronizado
synchronized.method.include.option=Incluir métodos nativos
synchronized.method.move.quickfix=Mover la sincronización al método
synchronized.method.problem.descriptor=Método '' {0}() '' declarado <code>#ref</code> #loc
synchronized.on.direct.literal.object.problem.descriptor=Sincronización en{0}literal <code>#ref</code> #loc
synchronized.on.literal.object.name=Sincronización en un objeto inicializado con un literal
synchronized.on.literal.object.problem.descriptor=Sincronización en{0}<code>#ref</code> que se inicializa con un #loc literal
synchronized.on.literal.object.warn.on.all.option=Advertir sobre todos los literales posibles
synchronized.on.possibly.literal.object.problem.descriptor=Sincronización en{0}<code>#ref</code> #loc
system.exit.call.display.name=Llamada a 'System.exit()' o métodos relacionados
system.exit.call.ignore.option=Ignorar en el método principal
system.exit.call.problem.descriptor=La llamada a <code> {0}. #ref()</code> no es portátil #loc
system.getenv.call.display.name=Llamar a 'System.getenv()'
system.getenv.call.problem.descriptor=La llamada a <code> System. #ref()</code> no es portátil #loc
system.properties.display.name=Acceso a las propiedades del sistema
system.properties.problem.descriptor=La llamada a <code> Integer. #ref()</code> puede plantear problemas de seguridad #loc
system.properties.problem.descriptor1=La llamada a <code> Boolean. #ref()</code> puede plantear problemas de seguridad #loc
system.run.finalizers.on.exit.display.name=Llamada a 'System.runFinalizersOnSalir()'
system.run.finalizers.on.exit.problem.descriptor=Llamar a <code>System. #ref()</code> #loc
system.set.problem.descriptor=La llamada a <code>System. #ref()</code> puede plantear problemas de seguridad #loc
system.set.security.manager.display.name=Llamar a 'System.setSecurityManager()'
system.set.security.manager.problem.descriptor=La llamada a <code> System. #ref()</code> puede plantear problemas de seguridad #loc
tail.recursion.display.name=Recursión de cola
tail.recursion.problem.descriptor=Tail recursive call <code>#ref()</code> #loc
tail.recursion.replace.quickfix=Reemplazar la recursividad de cola con iteración
text.label.in.switch.statement.display.name=Etiqueta de texto en la declaración 'switch'
text.label.in.switch.statement.problem.descriptor=Etiqueta de texto <code> #ref:</code> in ''switch'' {0, choice, 1#statement | 2#expression} #loc
the.whole.project=el proyecto completo
this.class=esta clase
this.reference.escaped.in.construction.display.name='this' referencia escapada en la construcción del objeto
this.reference.escaped.in.construction.problem.descriptor=Escape de <code>#ref</code> durante la construcción del objeto #loc
thread.death.rethrown.display.name='java.lang.ThreadDeath' no relanzado
thread.death.rethrown.problem.descriptor=ThreadDeath <code>#ref</code> no relanzado #loc
thread.local.not.static.final.display.name=El campo ThreadLocal no se declaró estático final
thread.local.not.static.final.problem.descriptor=ThreadLocal <code>#ref</code> no está declarado 'static final' #loc
thread.local.set.with.null.display.name='ThreadLocal.set()' with null as an argument
thread.local.set.with.null.problem.descriptor='ThreadLocal.set()' with null as an argument may cause memory leak
thread.local.set.with.null.quickfix=Replace with 'ThreadLocal.remove()' call
thread.priority.display.name=Llamada a 'Thread.setPriority()'
thread.priority.problem.descriptor=Llamada a <code>Thread. #ref()</code> #loc
thread.run.problem.descriptor=Las llamadas a <code>#ref()</code> probablemente deberían reemplazarse con 'start()' #loc
thread.start.in.construction.display.name=Llamada a 'Thread.start()' durante la construcción del objeto
thread.start.in.construction.problem.descriptor=Llamar a <code>#ref</code> durante la construcción del objeto #loc
thread.stop.suspend.resume.display.name=Llamada a 'Thread.stop()', 'suspend()' o 'resume()'
thread.stop.suspend.resume.problem.descriptor=Llamada a <code>Thread. #ref()</code> #loc
thread.with.default.run.method.display.name=Crear una instancia de un hilo con el método predeterminado 'run()'
thread.with.default.run.method.problem.descriptor=Creación de una instancia de un <code>#ref</code> con el método 'run()' predeterminado #loc
thread.yield.display.name=Llamada a 'Thread.yield()'
thread.yield.problem.descriptor=Llamada a <code>Thread. #ref()</code> #loc
three.negations.per.method.display.name=Método con más de tres negaciones
three.negations.per.method.ignore.assert.option=Ignorar negaciones en declaraciones 'assert'
three.negations.per.method.ignore.option=Ignorar negaciones en métodos 'equals()'
three.negations.per.method.problem.descriptor=<code>#ref</code> contiene{0}negaciones #loc
throw,from.finally.block.everywhere.option=Advertir en todos los lugares donde se pueden lanzar excepciones declaradas
throw.caught.locally.display.name=throw' atrapado conteniendo la declaración 'try
throw.caught.locally.ignore.option=Ignorar las excepciones repetidas
throw.caught.locally.problem.descriptor=<code>#ref</code> detectado al contener la declaración 'try' #loc
throw.from.finally.block.display.name=lanzar' dentro del bloque 'finalmente
throw.from.finally.block.problem.descriptor=<code>#ref</code> dentro del bloque 'finalmente' #loc
throwable.instance.never.thrown.checked.exception.problem.descriptor=La instancia de excepción marcada <code>#ref</code> no se lanza #loc
throwable.instance.never.thrown.error.problem.descriptor=La instancia de error <code>#ref</code> no se lanza #loc
throwable.instance.never.thrown.problem.descriptor=La instancia lanzada <code>#ref</code> no se lanza #loc
throwable.instance.never.thrown.runtime.exception.problem.descriptor=La instancia de excepción de tiempo de ejecución <code>#ref</code> no se lanza #loc
throwable.not.thrown.display.name=Lanzable no arrojado
throwable.printed.to.system.out.display.name= Throwable '' como '' System.out 
throwable.printed.to.system.out.problem.descriptor=El argumento <code>\#ref</code> '' Throwable '' llamado '' System. {0}. {1}()'' se genera como
throwable.printed.to.system.out.problem.fix.level.option=Log method for fix\:
throwable.result.of.method.call.ignored.problem.descriptor=Resultado de <code>#ref()</code> no arrojado #loc
throwable.supplier.only.throw.exception.name=Throwable supplier never returns a value
throwable.supplier.only.throw.exception.problem.descriptor=Throwable supplier doesn't return any exception
throwable.supplier.only.throw.exception.quickfix=Replace 'throw' with 'return' in lambda
thrown.exceptions.per.method.display.name=Método con demasiadas excepciones declaradas
thrown.exceptions.per.method.limit.option=Límite de excepciones lanzadas:
thrown.exceptions.per.method.problem.descriptor=<code>#ref</code> tiene demasiadas excepciones declaradas (num exceptions={0}) #loc
throws.runtime.exception.display.name=Excepción sin marcar declarada en la cláusula '' throws ''
throws.runtime.exception.fix.family.name=eliminado de la cláusula '' throws ''
throws.runtime.exception.move.quickfix=Mueva ''{0}'' a la etiqueta Javadoc '' @throws ''.
throws.runtime.exception.problem.descriptor=Se declaró una excepción sin marcar <code>\#ref</code> en la cláusula '' throws ''.\#loc
throws.runtime.exception.quickfix=Elimina ''{0}'' de la cláusula '' throws ''.
time.tostring.call.display.name=Llamar a 'Time.toString()'
time.tostring.call.problem.descriptor=<code> Time. #ref()</code> en un contexto internacionalizado #loc
to.array.call.style.display.name=Estilo de llamada 'Collection.toArray()'
to.array.call.style.problem.descriptor.presized=Llamada a <code>#ref()</code> con argumento de matriz de tamaño predeterminado ''{0}'' #loc
to.array.call.style.problem.descriptor.zero=Llamar a <code>#ref()</code> con un argumento de matriz vacío ''{0}'' #loc
to.array.call.style.quickfix.family.name=Corregir el tamaño de la matriz pasada a la llamada 'toArray'
to.array.call.style.quickfix.make.presized=Reemplazar argumento con una matriz de tamaño predeterminado
to.array.call.style.quickfix.make.zero=Reemplazar argumento con una matriz vacía
too.broad.catch.display.name=Bloque 'catch' demasiado amplio
too.broad.catch.option=&Solo advertir sobre RuntimeException, Exception, Error o Throwable
too.broad.catch.problem.descriptor=''catch'' de <code>#ref</code> es demasiado amplio, enmascarando la excepción ''{0}'' #loc
too.broad.catch.problem.descriptor1=''catch'' de <code>#ref</code> es demasiado amplio y enmascara las excepciones ''{0}'' y ''{1}'' #loc
too.broad.catch.quickfix=Agregar cláusula ''catch'' para ''{0}''
too.broad.scope.allow.option=<html>Informar variables con una nueva expresión como inicializador <br> (Potencialmente inseguro: la solución rápida puede modificar la semántica si el constructor tiene efectos secundarios no locales)</html>
too.broad.scope.display.name=El alcance de la variable es demasiado amplio
too.broad.scope.inspection.fix.family.name=Alcance estrecho
too.broad.scope.narrow.quickfix=Mueve la declaración de ''{0}'' más cerca de los usos
too.broad.scope.only.blocks.option=Solo reportar variables que se pueden mover a bloques internos
too.broad.scope.problem.descriptor=El alcance de la variable <code>#ref</code> es demasiado amplio #loc
too.many.constructors.count.limit.option=Límite de recuento de constructores:
too.many.constructors.display.name=Clase con demasiados constructores
too.many.constructors.ignore.deprecated.option=Ignorar constructores obsoletos
too.many.constructors.problem.descriptor=<code>#ref</code> tiene demasiados constructores (constructor count={0}) #loc
too.many.fields.count.limit.option=Límite de recuento de campos:
too.many.fields.display.name=Clase con demasiados campos
too.many.fields.problem.descriptor=<code>#ref</code> tiene demasiados campos (field count={0}) #loc
too.many.methods.display.name=Clase con demasiados métodos
too.many.methods.problem.descriptor=<code>#ref</code> tiene demasiados métodos (método count={0}) #loc
trace.level.option=Nivel de seguimiento
transient.field.in.non.serializable.class.display.name=Campo transitorio en clase no serializable
transient.field.in.non.serializable.class.problem.descriptor=El campo ''{0}'' está marcado como <code>#ref</code>, en la clase no serializable #loc
transient.field.not.initialized.display.name=El campo transitorio no se inicializa en la deserialización
transient.field.not.initialized.problem.descriptor=El campo transitorio <code>#ref</code> no se inicializó en la deserialización #loc
trivial.if.display.name=Declaración 'if' redundante
trivial.if.fix.family.name=Simplificar 'si más'
trivial.if.option.ignore.assert.statements=Ignore 'if' statements with trivial 'assert'
trivial.if.option.ignore.chained=Ignorar declaraciones 'if' encadenadas
trivial.if.problem.descriptor=<code>#ref</code> declaración se puede simplificar #loc
trivial.string.concatenation.display.name=Concatenación con cadena vacía
trivial.string.concatenation.option.only.necessary=Report only where empty strings can be removed without other changes
trivial.string.concatenation.problem.descriptor=Cadena vacía utilizada en la concatenación
try.finally.can.be.try.with.resources.display.name='' probar finalmente '' se puede reemplazar con '' probar '' con recursos
try.finally.can.be.try.with.resources.problem.descriptor=<code>\#ref</code> puede utilizar la gestión automática de recursos.\#loc
try.finally.can.be.try.with.resources.quickfix=Reemplazar con '' probar '' con recursos.
try.statement.with.multiple.resources.name=Puede dividir la declaración ''try'' con múltiples recursos
try.statement.with.multiple.resources.quickfix=Dividir una declaración ''try'' con varios recursos.
try.with.identical.catches.checkbox.different.comments=Do not report catch blocks with different comments
try.with.identical.catches.display.name=misma rama ''catch'' en la declaración ''try''
try.with.identical.catches.problem.descriptor=La rama ''catch'' es idéntica a la rama ''{0}''.\#loc
try.with.identical.catches.quickfix=Contraer bloque 'catch'
type.parameter.extends.enum.type.parameter.problem.descriptor=Tipo de parámetro <code>#ref</code> se extiende implícitamente enum final ''{0}'' #loc
type.parameter.extends.enum.wildcard.problem.descriptor=El argumento de tipo comodín <code>#ref</code> extiende implícitamente la enumeración final ''{0}'' #loc
type.parameter.extends.final.class.display.name=El parámetro de tipo extiende la clase final
type.parameter.extends.final.class.quickfix=Reemplazar el parámetro de tipo con la clase real
type.parameter.extends.final.class.type.parameter.problem.descriptor=Tipo de parámetro <code>#ref</code> extiende ''final'' clase ''{0}'' #loc
type.parameter.extends.final.class.wildcard.problem.descriptor=El argumento de tipo comodín <code>#ref</code> extiende ''final'' clase ''{0}'' #loc
type.parameter.extends.object.display.name=El parámetro de tipo extiende explícitamente 'java.lang.Object'
type.parameter.extends.object.ignore.annotated=Ignorar cuando se anota java.lang.Object
type.parameter.extends.object.problem.descriptor1=El parámetro de tipo <code>#ref</code> extiende explícitamente 'java.lang.Object' #loc
type.parameter.extends.object.problem.descriptor2=El argumento de tipo comodín <code>#ref</code> extiende explícitamente 'java.lang.Object' #loc
type.parameter.hides.type.parameter.problem.descriptor=El parámetro de tipo <code>#ref</code> oculta el parámetro de tipo ''{0}'' #loc
type.parameter.hides.visible.type.display.name=El parámetro de tipo oculta el tipo visible
type.parameter.hides.visible.type.problem.descriptor=El parámetro de tipo <code>#ref</code> oculta el tipo visible ''{0}'' #loc
type.parameter.naming.convention.element.description=Tipo de parámetro
unary.plus.display.name=Unario más
unary.plus.problem.descriptor=Operador <code>#ref</code> unario #loc
unary.plus.quickfix=Eliminar unario '' + ''.
unchecked.exception.class.display.name=Clase de excepción sin marcar
unchecked.exception.class.problem.descriptor=Clase de excepción sin marcar <code>#ref</code> #loc
unclear.binary.expression.display.name=expresión ambigua
unclear.binary.expression.problem.descriptor=Puede usar paréntesis delimitadores alrededor de las expresiones.\#loc
unclear.binary.expression.quickfix=Agregue paréntesis delimitadores claros.
unconditional.wait.display.name=Llamada incondicional 'wait()'
unconditional.wait.problem.descriptor=Llamada incondicional a <code>#ref()</code> #loc
unnecessarily.qualified.inner.class.access.display.name=Acceso de clase interno innecesario calificado
unnecessarily.qualified.inner.class.access.option=Ignore las referencias que requieran una declaración de importación
unnecessarily.qualified.inner.class.access.problem.descriptor=''{0}'' se calificó innecesariamente con <code>\#ref</code>.\#loc
unnecessarily.qualified.inner.class.access.quickfix=Eliminar calificador
unnecessarily.qualified.static.usage.display.name=Acceso estático innecesariamente calificado
unnecessarily.qualified.static.usage.ignore.field.option=Ignorar accesos de campo innecesariamente calificados
unnecessarily.qualified.static.usage.ignore.method.option=Ignorar llamadas a métodos innecesariamente calificados
unnecessarily.qualified.static.usage.problem.descriptor=Llamada a método estático innecesariamente calificado <code> {0}()</code> #loc
unnecessarily.qualified.static.usage.problem.descriptor1=Acceso estático innecesariamente calificado <code>{0}</code> #loc
unnecessarily.qualified.statically.imported.element.display.name=El elemento estático importado está innecesariamente calificado
unnecessarily.qualified.statically.imported.element.problem.descriptor=El elemento importado estáticamente ''{0}'' se calificó innecesariamente con <code>\#ref</code>.\#loc
unnecessarily.qualified.statically.imported.element.quickfix=Elimina los calificadores innecesarios.
unnecessary.block.statement.problem.descriptor=Las llaves alrededor de esta declaración son innecesarias #loc
unnecessary.boxing.display.name=Boxeo innecesario
unnecessary.boxing.inside.value.of.problem.descriptor=Boxing redundante dentro de <code>#ref</code> #loc
unnecessary.boxing.problem.descriptor=Boxeo innecesario <code>#ref</code> #loc
unnecessary.boxing.remove.quickfix=Eliminar el boxeo
unnecessary.boxing.superfluous.option=Solo reportar expresiones verdaderamente superfluas en cajas
unnecessary.break.display.name=Declaración innecesaria de '' interrupción ''
unnecessary.break.problem.descriptor=La declaración <code>\#ref</code> es innecesaria.\#loc
unnecessary.code.block.display.name=Bloque de código innecesario
unnecessary.code.block.unwrap.quickfix=Desenvolver bloque
unnecessary.constant.array.creation.expression.display.name=Expresión 'nueva' redundante en la creación constante de matrices
unnecessary.constant.array.creation.expression.family.quickfix=Reemplazar con la expresión del inicializador de matriz
unnecessary.constant.array.creation.expression.problem.descriptor=<code>#ref</code> se puede reemplazar con la expresión del inicializador de matriz #loc
unnecessary.constructor.annotation.option=Ignorar constructores con una anotación
unnecessary.constructor.display.name=Constructor redundante sin argumentos
unnecessary.constructor.problem.descriptor=El constructor sin argumentos <code>#ref()</code> es redundante #loc
unnecessary.constructor.remove.quickfix=Eliminar constructor redundante
unnecessary.continue.display.name=Declaración 'continuar' innecesaria
unnecessary.continue.problem.descriptor=<code>#ref</code> no es necesario como última declaración en un bucle #loc
unnecessary.conversion.to.string.display.name=Conversión innecesaria a cadena
unnecessary.default.display.name=predeterminado' innecesario para la declaración de enum 'switch
unnecessary.default.expressions.option=Solo reportar expresiones de cambio
unnecessary.default.problem.descriptor=<code>#ref</code> rama es innecesaria #loc
unnecessary.default.quickfix=Eliminar la rama 'predeterminada'
unnecessary.enum.constructor.modifier.problem.descriptor=Modifier <code>#ref</code> is redundant for enum constructors #loc
unnecessary.explicit.numeric.cast.display.name=Reparto numérico explícito innecesario
unnecessary.explicit.numeric.cast.problem.descriptor=''{0}'' se ha convertido innecesariamente en <code>\#ref</code>.\#loc
unnecessary.explicit.numeric.cast.quickfix=Eliminar elenco.
unnecessary.final.on.local.variable.or.parameter.display.name=Innecesario '' final '' de variable local o parámetro
unnecessary.final.on.local.variable.problem.descriptor=<code>\#ref</code> de la variable ''{0}'' no es necesario.\#loc
unnecessary.final.on.parameter.only.interface.option=Advertir solo para métodos abstractos o de interfaz
unnecessary.final.on.parameter.problem.descriptor=<code>\#ref</code> del parámetro ''{0}'' no es necesario.\#loc
unnecessary.final.report.local.variables.option=Informar variables locales
unnecessary.final.report.parameters.option=Parámetros del informe
unnecessary.final.report.pattern.variables.option=Report pattern variables
unnecessary.fully.qualified.name.display.name=Nombre completamente calificado innecesario
unnecessary.fully.qualified.name.fix.family.name=Renombrar completamente calificado
unnecessary.fully.qualified.name.problem.descriptor1=El calificador <code>#ref</code> no es necesario y puede reemplazarse con un #loc de importación
unnecessary.fully.qualified.name.problem.descriptor2=El calificador <code>#ref</code> es innecesario y se puede eliminar #loc
unnecessary.fully.qualified.name.remove.quickfix=Eliminar la calificación innecesaria
unnecessary.fully.qualified.name.replace.quickfix=Reemplazar nombre calificado con importación
unnecessary.inherit.doc.class.invalid.problem.descriptor=<code>#ref</code> no es válido en las clases #loc
unnecessary.inherit.doc.constructor.invalid.problem.descriptor=<code>#ref</code> no es válido en constructores #loc
unnecessary.inherit.doc.constructor.no.super.problem.descriptor=No se ha encontrado un súper método para heredar Javadoc de #loc
unnecessary.inherit.doc.display.name=Comentario de Javadoc {@inheritDoc} innecesario
unnecessary.inherit.doc.field.invalid.problem.descriptor=<code>#ref</code> no es válido en los campos #loc
unnecessary.inherit.doc.module.invalid.problem.descriptor=<code>#ref</code> no es válido en declaraciones de módulo #loc
unnecessary.inherit.doc.problem.descriptor=El comentario de Javadoc que contiene solo <code>#ref</code> es innecesario #loc
unnecessary.inherit.doc.quickfix=Eliminar {@inheritDoc} innecesario
unnecessary.initcause.display.name=Llamada innecesaria a '' throwable.initCause()''
unnecessary.initcause.problem.descriptor=Llamadas innecesarias a <code> Throwable.\# ref()</code>
unnecessary.initcause.quickfix=Elimine la llamada '' Throwable.initCause()''.
unnecessary.inner.enum.modifier.problem.descriptor=Modifier <code>#ref</code> is redundant for inner enums #loc
unnecessary.inner.interface.modifier.problem.descriptor=Modifier <code>#ref</code> is redundant for inner interfaces #loc
unnecessary.inner.record.modifier.problem.descriptor=Modifier <code>#ref</code> is redundant for inner records
unnecessary.interface.field.modifier.problem.descriptor=Modifier <code>#ref</code> is redundant for interface fields #loc
unnecessary.interface.inner.class.modifier.problem.descriptor=Modifier <code>#ref</code> is redundant for inner classes of interfaces #loc
unnecessary.interface.member.modifier.problem.descriptor=Modifier <code>#ref</code> is redundant for interface members #loc
unnecessary.interface.method.modifier.problem.descriptor=Modifier <code>#ref</code> is redundant for interface methods #loc
unnecessary.interface.modifier.problem.descriptor=El modificador <code>#ref</code> es redundante para interfaces #loc
unnecessary.java.doc.link.fix.family.name=Eliminar etiquetas duplicadas
unnecessary.javadoc.link.display.name=Enlace Javadoc innecesario
unnecessary.javadoc.link.option=Ignorar los enlaces en línea a los métodos principales
unnecessary.javadoc.link.quickfix=Elimina innecesarios ''{0}''
unnecessary.javadoc.link.super.method.problem.descriptor=<code>#ref</code> apuntar al súper método es innecesario #loc
unnecessary.javadoc.link.this.class.problem.descriptor=<code>#ref</code> apuntar a la clase contenedora es innecesario #loc
unnecessary.javadoc.link.this.method.problem.descriptor=<code>#ref</code> apuntar a este método es innecesario #loc
unnecessary.label.on.break.statement.display.name=Etiqueta innecesaria en la declaración 'break'
unnecessary.label.on.break.statement.problem.descriptor=Etiqueta innecesaria en la declaración <code>#ref</code> #loc
unnecessary.label.on.continue.statement.display.name=Etiqueta innecesaria en la declaración 'continuar'
unnecessary.label.on.continue.statement.problem.descriptor=Etiqueta innecesaria en la declaración <code>#ref</code> #loc
unnecessary.label.remove.quickfix=Eliminar etiqueta
unnecessary.local.variable.problem.descriptor=La variable local <code>#ref</code> es redundante #loc
unnecessary.modifier.display.name=Unnecessary modifier
unnecessary.parentheses.conditional.option=Ignore los paréntesis alrededor de la condición de las expresiones condicionales
unnecessary.parentheses.display.name=Paréntesis innecesarios
unnecessary.parentheses.option=Ignorar los paréntesis aclaratorios
unnecessary.parentheses.problem.descriptor=Los paréntesis alrededor de <code>#ref</code> son innecesarios #loc
unnecessary.parentheses.remove.quickfix=Elimina los paréntesis innecesarios
unnecessary.qualifier.for.super.problem.descriptor=El calificador <code>#ref</code> en 'super' no es necesario en este contexto #loc
unnecessary.qualifier.for.this.display.name=Calificador innecesario para 'esto' o 'super'
unnecessary.qualifier.for.this.problem.descriptor=El calificador <code>#ref</code> en 'esto' es innecesario en este contexto #loc
unnecessary.qualifier.for.this.remove.quickfix=Eliminar calificador innecesario
unnecessary.record.modifier.problem.descriptor=Modifier <code>#ref</code> is redundant for records
unnecessary.return.constructor.problem.descriptor=<code>#ref</code> no es necesario como última declaración en un constructor #loc
unnecessary.return.display.name=Declaración de 'retorno' innecesaria
unnecessary.return.option=ignorar en la rama de la declaración '' si '' con la rama '' más ''
unnecessary.return.problem.descriptor=<code>#ref</code> es innecesario como última declaración en un método 'void' #loc
unnecessary.semicolon.display.name=Punto y coma innecesario
unnecessary.semicolon.ignore.after.enum.constants.option=Ignorar puntos y comas innecesarios después de las constantes enum
unnecessary.semicolon.problem.descriptor=Punto y coma innecesario <code>#ref</code> #loc
unnecessary.semicolon.remove.quickfix=Eliminar el punto y coma innecesario
unnecessary.strictfp.modifier.problem.descriptor=Modifier <code>#ref</code> is redundant on Java 17 and later
unnecessary.string.escape.display.name=Caracteres innecesariamente escapados
unnecessary.string.escape.problem.descriptor=<code>\#ref</code> se escapa innecesariamente.
unnecessary.string.escape.quickfix=Reemplace los caracteres de escape innecesarios por otros sin escape.
unnecessary.super.constructor.display.name=Llamada innecesaria a 'super()'
unnecessary.super.constructor.problem.descriptor=<code>#ref</code> es innecesario #loc
unnecessary.super.constructor.remove.quickfix=Eliminar 'super()' innecesario
unnecessary.super.qualifier.display.name=Calificador 'super' innecesario
unnecessary.super.qualifier.problem.descriptor=El calificador <code>#ref</code> es innecesario en este contexto #loc
unnecessary.super.qualifier.quickfix=Elimina el calificador 'super' innecesario
unnecessary.temporary.object.fix.family.name=Cambiar conexión
unnecessary.temporary.on.conversion.from.string.display.name=Objeto temporal innecesario en la conversión de String
unnecessary.temporary.on.conversion.to.string.display.name=Objeto temporal innecesario en conversión a String
unnecessary.this.display.name=Calificador 'este' innecesario
unnecessary.this.ignore.assignments.option=Ignorar asignaciones de campo
unnecessary.this.problem.descriptor=<code>#ref</code> no es necesario en este contexto #loc
unnecessary.this.remove.quickfix=Elimina el calificador innecesario 'este'
unnecessary.tostring.call.display.name=Llamada innecesaria a 'toString()'
unnecessary.tostring.call.option.report.with.empty.string=Report calls that can be replaced with a concatenation with the empty string
unnecessary.tostring.call.problem.descriptor=<code>#ref()</code> innecesaria llamada #loc
unnecessary.tostring.call.problem.empty.string.descriptor=Can be replaced with concatenation with empty string
unnecessary.transient.modifier.problem.descriptor=Modifier <code>#ref</code> is redundant for a 'static' field
unnecessary.unary.minus.display.name=Menos unario innecesario
unnecessary.unary.minus.problem.descriptor=Unario innecesario menos #loc
unnecessary.unary.minus.quickfix=Eliminar el signo menos unario e invertir el signo de operación principal
unnecessary.unary.minus.remove.quickfix=Remove double unary minus
unnecessary.unboxing.display.name=Unboxing innecesario
unnecessary.unboxing.problem.descriptor=Desembalaje innecesario <code>#ref</code> #loc
unnecessary.unboxing.remove.quickfix=Eliminar unboxing
unnecessary.unboxing.superfluous.option=Solo reportar expresiones verdaderamente superfluas sin caja
unnecessary.unicode.escape.display.name=Secuencias de escape Unicode innecesarias
unnecessary.unicode.escape.fix.family.name=Reemplazar con caracteres.
unnecessary.unicode.escape.fix.text=Reemplazar con caracteres de salto de línea
unnecessary.unicode.escape.problem.descriptor=La secuencia de escape Unicode <code>\#ref</code> se puede reemplazar con ''{0}''.\#loc
unnecessary.unicode.escape.problem.newline.descriptor=Puede reemplazar las secuencias de escape Unicode <code>\#ref</code> con caracteres de salto de línea.\#loc
unpredictable.big.decimal.constructor.call.display.name=Llamada al constructor BigDecimal impredecible
unpredictable.big.decimal.constructor.call.ignore.complex.literals.option=Ignorar las llamadas al constructor con varios literales (por ejemplo, 0,1 + 0,2)
unpredictable.big.decimal.constructor.call.ignore.references.option=Ignorar las llamadas al constructor con argumentos de llamada de variable o método
unpredictable.big.decimal.constructor.call.problem.descriptor=Impredecible <code> new#ref()</code> llamada #loc
unqualified,static.usage.only.report.static.usages.option=Solo informa el acceso estático desde un contexto no estático
unqualified.field.access.display.name=El acceso al campo de la instancia no está calificado con 'esto'
unqualified.field.access.problem.descriptor=El acceso al campo de instancia <code>#ref</code> no está calificado con 'this' #loc
unqualified.inner.class.access.display.name=Acceso de clase interna no calificado
unqualified.inner.class.access.option=Ignorar referencias a clases internas locales
unqualified.inner.class.access.problem.descriptor=<code>\#ref</code> no está calificado como una clase externa.\#loc
unqualified.inner.class.access.quickfix=Canonicalizar a la clase externa.
unqualified.method.access.display.name=Llamada al método de instancia no calificada con 'this'
unqualified.method.access.problem.descriptor=La llamada al método de instancia <code>#ref</code> no está calificada con 'this' #loc
unqualified.static.access.fix.family.name=acceso estático calificado
unqualified.static.usage.display.name=Acceso estático no calificado
unqualified.static.usage.ignore.field.option=Ignorar accesos de campo no calificados
unqualified.static.usage.ignore.method.option=Ignorar llamadas a métodos no calificados
unqualified.static.usage.problem.descriptor=Llamada de método estático no calificado <code>#ref()</code> #loc
unqualified.static.usage.problem.descriptor1=Acceso a campo estático no calificado <code>#ref</code> #loc
unqualified.static.usage.qualify.field.quickfix=Calificar el acceso al campo estático
unqualified.static.usage.qualify.method.quickfix=Calificar llamada de método estático
unrunnable.main.method.problem.descriptor=Method <code>#ref()</code> can't be run because the containing class does not have a fully qualified name
unsecure.random.number.generation.display.name=Generación insegura de números aleatorios
unsecure.random.number.generation.problem.descriptor1=Por motivos de seguridad, utilice 'java.security.SecureRandom' en lugar de <code> java.lang.Math. #ref()</code> #loc
unsecure.random.number.generation.problem.descriptor2=Por motivos de seguridad, utilice 'java.security.SecureRandom' en lugar de <code> java.util.#ref</code> #loc
unsecure.random.number.generation.problem.descriptor3=Por motivos de seguridad, utilice 'java.security.SecureRandom' en lugar de <code>#ref</code> #loc
unused.import.problem.descriptor=Importación no utilizada <code>#ref</code> #loc
unused.label.display.name=Etiqueta no utilizada
unused.label.problem.descriptor=Etiqueta no utilizada <code>#ref</code> #loc
unused.label.remove.quickfix=Eliminar etiqueta no utilizada
update.label=Update names start with:
upper.case.field.name.not.constant.display.name=Campo no constante con nombre en mayúsculas
upper.case.field.name.not.constant.problem.descriptor=Campo no constante <code>#ref</code> con nombre de estilo constante #loc
use.0index.in.jdbc.prepared.statement.problem.descriptor=Uso del índice '0' en JDBC PreparedStatement #loc
use.0index.in.jdbc.resultset.display.name=Uso del índice 0 en JDBC ResultSet
use.0index.in.jdbc.resultset.problem.descriptor=Uso del índice '0' en JDBC ResultSet #loc
use.contentequals=Use 'contentEquals()' for comparison with 'AbstractStringBuilder'
use.equalsignorecase.for.case.insensitive.comparison=Use equalsIgnoreCase() para una comparación que no distinga entre mayúsculas y minúsculas
use.isblank.to.check.if.string.is.whitespace.or.empty=Use 'isBlank()' to check if a string is empty or only contains whitespace
use.obsolete.collection.type.display.name=Uso de tipo de colección obsoleto
use.obsolete.collection.type.ignore.library.arguments.option=Ignore los tipos de colección obsoletos cuando sean necesarios
use.obsolete.collection.type.problem.descriptor=Tipo de colección obsoleto <code>#ref</code> usado #loc
use.of.awt.peer.class.display.name=Uso de la clase de pares AWT
use.of.awt.peer.class.problem.descriptor=El uso de la clase de pares AWT <code>#ref</code> no es portátil #loc
use.of.clone.call.method.problem.descriptor=implementando <code>\#ref()</code>
use.of.clone.call.problem.descriptor=Llamar a <code>\#ref()</code>
use.of.clone.display.name= clone()'' o '' Clonable 
use.of.clone.reference.problem.descriptor=Use <code>\#ref</code>
use.of.concrete.class.option.ignore.abstract=Ignore abstract class type
use.of.concrete.class.option.ignore.records=Ignore Java records
use.of.concrete.class.option.report.cast=Report type used in cast expression
use.of.concrete.class.option.report.instance.fields=Report instance field type
use.of.concrete.class.option.report.instanceof=Report type used in instanceof, patterns, or getClass() comparison
use.of.concrete.class.option.report.local.variable=Report local variable type
use.of.concrete.class.option.report.method.returns=Report method return type
use.of.concrete.class.option.report.parameter=Report method parameter type
use.of.concrete.class.option.report.static.fields=Report static field type
use.of.concrete.jdbc.driver.class.display.name=Uso de una clase de controlador JDBC concreta
use.of.concrete.jdbc.driver.class.problem.descriptor=El uso de la clase de controlador JDBC concreto <code>#ref</code> no es portátil #loc
use.of.obsolete.date.time.api.display.name=Usar la API de fecha y hora obsoleta
use.of.obsolete.date.time.api.problem.descriptor=Se ha utilizado el tipo de fecha y hora obsoleto <code>\#ref</code>.\#loc
use.of.properties.as.hashtable.fix.family.name=Modificar el acceso a la propiedad
use.processbuilder.class.display.name=Uso de la clase 'java.lang.ProcessBuilder'
use.processbuilder.class.problem.descriptor=El uso de <code>#ref</code> no es portátil #loc
use.stringtokenizer.display.name=Uso de StringTokenizer
use.stringtokenizer.problem.descriptor=<code>#ref</code> en un contexto internacionalizado #loc
use.sun.classes.display.name=Uso de clases sun. *
use.sun.classes.problem.descriptor=El uso de la clase <code>#ref</code> proporcionada por Sun no es portátil #loc
use.system.out.err.display.name=Uso de System.out o System.err
use.system.out.err.problem.descriptor=Los usos de <code>#ref</code> probablemente deberían reemplazarse con un registro más sólido #loc
use.system.out.err.problem.fix.err.option=Log method for 'System.err'\:
use.system.out.err.problem.fix.out.option=Log method for 'System.out'\:
utility.class.can.be.enum.display.name=La clase de utilidad puede ser '' enum ''
utility.class.code.can.be.enum.problem.descriptor=La clase de utilidad <code>\#ref</code> puede ser '' enum ''.\#loc
utility.class.code.can.be.enum.quickfix=Convierta a '' enum ''.
utility.class.display.name=Clase de utilidad
utility.class.problem.descriptor=La clase <code>#ref</code> solo tiene miembros 'estáticos', lo que indica la construcción de procedimientos #loc
utility.class.with.public.constructor.display.name=Clase de utilidad con constructor 'público'
utility.class.with.public.constructor.fix.family.name=Hacer que el constructor sea privado
utility.class.with.public.constructor.make.private.quickfix=Make {0, choice, 1#constructor|2#constructors} ''private''
utility.class.with.public.constructor.make.protected.quickfix=Make {0, choice, 1#constructor|2#constructors} ''protected''
utility.class.with.public.constructor.problem.descriptor=La clase <code>#ref</code> solo tiene miembros 'estáticos' y un constructor 'público' #loc
utility.class.without.private.constructor.cant.generate.constructor.message=La clase de utilidad incluye instanciación y no se crea ningún constructor privado.
utility.class.without.private.constructor.create.quickfix=Generar constructor 'privado' vacío
utility.class.without.private.constructor.display.name=Clase de utilidad sin constructor 'privado'
utility.class.without.private.constructor.make.quickfix=Hacer que el constructor sea 'privado'
utility.class.without.private.constructor.option=Ignorar clases con solo un método principal
utility.class.without.private.constructor.problem.descriptor=La clase <code>#ref</code> solo tiene miembros 'estáticos' y carece de un constructor 'privado' #loc
value.of.post.decrement.problem.descriptor=Se usa el valor de la expresión de post-decremento <code>#ref</code> #loc
value.of.post.increment.problem.descriptor=Se usa el valor de la expresión posterior al incremento <code>#ref</code> #loc
value.of.pre.decrement.problem.descriptor=Se usa el valor de la expresión de pre-decremento <code>#ref</code> #loc
value.of.pre.increment.problem.descriptor=Se usa el valor de la expresión de preincremento <code>#ref</code> #loc
variable.argument.method.display.name=Método Varargs
variable.argument.method.problem.descriptor=Método de Varargs <code>#ref()</code> #loc
variable.argument.method.quickfix=Convertir el parámetro varargs en una matriz
variable.not.used.inside.conditional.problem.descriptor=<code>#ref</code> verificado para 'nulo' no se usa dentro del #loc condicional
variable.not.used.inside.if.display.name=La referencia marcada para 'nulo' no se usa dentro de 'if'
variable.not.used.inside.if.problem.descriptor=<code>#ref</code> marcado para 'nulo' no se usa dentro de 'if' #loc
variable.type.can.be.explicit.display.name=El tipo de variable puede ser explícito
volatile.array.field.display.name=Campo de matriz volátil
volatile.field.problem.descriptor=Campo volátil <code>#ref</code> de tipo ''{0}'' #loc
wait.called.on.condition.display.name=wait()' llamado en el objeto 'java.util.concurrent.locks.Condition
wait.called.on.condition.problem.descriptor=Llamar a <code>#ref()</code> en el objeto Condición #loc
wait.not.in.loop.display.name='wait()' not in loop
wait.not.in.loop.problem.descriptor=La llamada a <code>#ref()</code> no se realiza en un bucle #loc
wait.notify.not.in.synchronized.context.display.name='' wait()'' or '' notify()'' while unsynchronized
wait.notify.while.not.synchronized.on.problem.descriptor=Llamado mientras <code>\#ref</code> no está sincronizado en ''{0}''.\#loc
wait.or.await.without.timeout.display.name='wait()' o 'await()' sin tiempo de espera
wait.or.await.without.timeout.problem.descriptor=<code>#ref</code> sin tiempo de espera #loc
wait.while.holding.two.locks.display.name='wait()' mientras mantiene dos candados
wait.while.holding.two.locks.problem.descriptor=La llamada a <code>#ref()</code> se realiza mientras se mantienen dos bloqueos #loc
wait.without.corresponding.notify.display.name=wait()' sin el correspondiente 'notificar()
wait.without.corresponding.notify.problem.descriptor=Llamar a <code>#ref</code> sin el correspondiente <code> notify()</code> o <code> notifyAll()</code> #loc
warn.level.and.lower.option=Por debajo del nivel de advertencia
warn.on.label=Advertir sobre\:
weaken.visibility.quickfix=Weaken visibility
while.can.be.foreach.display.name=while' bucle reemplazable con bucle mejorado 'for
while.can.be.foreach.problem.descriptor=<code>#ref</code> bucle reemplazable con mejorado 'for' #loc
while.loop.spins.on.field.display.name='while' loop gira en el campo
while.loop.spins.on.field.fix.family.name=Corregir bucle de giro
while.loop.spins.on.field.fix.spinwait=Agregar hilo.onSpinWait()
while.loop.spins.on.field.fix.volatile=Hacer ''{0}'' volátil
while.loop.spins.on.field.fix.volatile.spinwait=Hacer ''{0}'' volátil y agregar Thread.onSpinWait()
while.loop.spins.on.field.ignore.non.empty.loops.option=Advertir solo si el bucle está vacío
while.loop.spins.on.field.problem.descriptor=<code>#ref</code> bucle gira en el campo #loc
wrap.with.arrays.hash.code.quickfix=Wrap with ''{0}''
write.only.object.display.name=Write-only object
write.only.object.option.ignore.impure.constructors=Ignore impure constructors
