0.2.choice.0.is.in.progress.1.on.the.fly.analysis.is.turned.1={0}{2, choice, 0\# 진행 중|1\# 즉석 분석 {1}}
0.abi={0} ABI
0.for.1=''{1}''의 ''{0}''
0.lines.covered={0}%개 줄 포함
0.naming.convention={0} 이름 지정 규칙
0.of.1.files={0}/{1}개 파일
0.of.1.files.covered={0}/{1}개 파일 포함
0.to.execute=실행할 <{0}>
1.lines.covered=<1%개 줄 포함
abbreviated.month.name.always.3.letters.jul=(Jul) 월의 축약 표기. 항상 3글자.
abbreviated.weekday.name.always.3.letters.sun=(Sun) 요일의 축약 표기. 항상 3글자.
action.Cargo.AttachCargoProject.text=Cargo 프로젝트 연결
action.Cargo.DetachCargoProject.text=Cargo 프로젝트 연결 해제
action.Cargo.RefreshCargoProject.description=Cargo 프로젝트 정보를 업데이트하고 새로운 종속성을 다운로드합니다
action.Cargo.RefreshCargoProject.text=Cargo 프로젝트 새로고침
action.Cargo.RunCargoCommand.text=Cargo 명령어 실행
action.Cargo.RunExternalLinter.text=외부 Linter 실행
action.Cargo.RustfmtCargoProject.description=Reformat Cargo project with Rustfmt
action.Cargo.RustfmtCargoProject.text=Rustfmt로 Cargo 프로젝트의 서식을 다시 지정
action.Cargo.RustfmtFile.default.text=Rustfmt로 파일의 서식을 다시 지정
action.Cargo.RustfmtFile.description=Rustfmt로 현재 파일의 서식을 다시 지정
action.Cargo.RustfmtFile.file.text=Rustfmt로 {0}의 서식을 다시 지정
action.Cargo.RustfmtFile.progress.default.text=Rustfmt로 파일의 서식을 다시 지정하는 중...
action.Cargo.RustfmtFile.progress.file.text=Rustfmt로 {0}의 서식을 다시 지정하는 중...
action.Cargo.RustfmtFile.text=Reformat File with Rustfmt
action.Cargo.ShowSettings.description=현재 프로젝트의 Cargo 설정 편집
action.Cargo.ShowSettings.text=Cargo 설정
action.Cargo.ToggleExternalLinterOnTheFlyAction.text=외부 Linter(Cargo Check / Clippy)를 즉석 실행
action.Rust.Build.description=프로젝트 빌드
action.Rust.Build.text=빌드
action.Rust.ConsoleREPL.text=Rust REPL
action.Rust.CreateNewIssue.description=https\://youtrack.jetbrains.com/issues/RUST에서 새 이슈를 생성합니다
action.Rust.CreateNewIssue.text=Rust 팀에 이슈 보고
action.Rust.GenerateConstructor.text=생성자
action.Rust.GenerateDictionaries.text=Rust 철자 검사기 사전 생성
action.Rust.GenerateGetter.text=Getter
action.Rust.GenerateSetter.text=Setter
action.Rust.NewCargoCrate.description=새 Cargo 크레이트를 생성합니다
action.Rust.NewCargoCrate.text=크레이트 생성
action.Rust.NewRustFile.description=새 Rust 파일을 생성합니다
action.Rust.NewRustFile.text=Rust 파일
action.Rust.RebuildAllDefMaps.text=모든 크레이트의 DefMap 다시 빌드
action.Rust.RebuildCurrentDefMap.text=현재 파일의 DefMap 다시 빌드
action.Rust.ReexpandMacrosAction.text=모든 Rust 매크로 재확장
action.Rust.RsConvertToNamedFields.description=튜플 구조체를 명명된 필드로 변환합니다
action.Rust.RsConvertToNamedFields.text=명명된 필드로 변환
action.Rust.RsConvertToTuple.description=구조체를 튜플로 변환합니다
action.Rust.RsConvertToTuple.text=튜플로 변환
action.Rust.RsDowngradeModuleToFile.description=이 모듈을 별도의 파일로 이동합니다
action.Rust.RsDowngradeModuleToFile.text=모듈을 파일로 다운그레이드
action.Rust.RsExtractEnumVariant.description=열거형 배리언트를 별도의 구조체로 추출합니다
action.Rust.RsExtractEnumVariant.text=열거형 배리언트 추출
action.Rust.RsExtractStructFields.choose.fields.title=추출할 필드 선택
action.Rust.RsExtractStructFields.choose.name.dialog.invalid.name=잘못된 구조체 이름
action.Rust.RsExtractStructFields.choose.name.dialog.title=새로운 구조체의 이름 지정
action.Rust.RsExtractStructFields.command.name=구조체 필드 추출 중
action.Rust.RsExtractStructFields.description=선택된 구조체 필드를 별도의 구조체로 추출합니다
action.Rust.RsExtractStructFields.intention.text=구조체 필드 추출
action.Rust.RsExtractStructFields.text=구조체 필드 추출...
action.Rust.RsExtractTrait.description=선택된 'impl'에서 특성을 추출합니다
action.Rust.RsExtractTrait.dialog.title=특성 추출
action.Rust.RsExtractTrait.text=특성 추출...
action.Rust.RsPromoteModuleToDirectoryAction.description=모듈을 전용 디렉터리로 이동합니다
action.Rust.RsPromoteModuleToDirectoryAction.text=모듈을 디렉터리로 승격
action.Rust.ShareInPlayground.confirmation={0}을(를) Rust Playground에 업로드하고 public으로 만드시겠어요?
action.Rust.ShareInPlayground.confirmation.selected.text=선택된 텍스트를 Rust Playground에 업로드하고 public으로 만드시겠어요?
action.Rust.ShareInPlayground.description=Rust Playground(https\://play.rust-lang.org/)에서 코드를 공유합니다
action.Rust.ShareInPlayground.notification.copy.url.text=URL을 클립보드로 복사
action.Rust.ShareInPlayground.notification.error=Go Playground에 코드를 공유할 수 없습니다
action.Rust.ShareInPlayground.notification.text=Rust Playground에 공유된 파일\: <a href\="{0}">{0}</a>
action.Rust.ShareInPlayground.notification.title=Rust Playground에 공유
action.Rust.ShareInPlayground.progress.title=코드를 Rust Playground에 게시 중...
action.Rust.ShareInPlayground.text=Playground에 공유
action.Rust.ShowRecursiveMacroExpansionAction.text=재귀 매크로 확장 표시
action.Rust.ShowSingleStepMacroExpansionAction.text=매크로 확장 표시
action.all.features.description=모든 기능을 {0}합니다
action.all.features.text=모든 기능 {0}
action.enable.text=사용
action.enter.type.name.text=타입 이름 입력...
action.install.text=설치
action.rerun.text=''{0}'' 다시 실행
action.run.on.fly.text={0} 즉시 실행
action.run.rustup.update.text=''rustup update {0}'' 실행
action.rust.coverage.text=Rust 커버리지
action.show.rust.feedback.dialog.text=Rust 피드백 대화상자 표시
action.show.variables.text=변수 표시
action.shows.active.console.variables.description=활성화된 콘솔 변수 표시
action.stop.console.text=Rust REPL 중지
action.stop.rust.console.description=Stop Rust REPL
action.while.expr.text=while expr
action.while.text=while { }
adt.const.params=adt const params
advanced.setting.org.rust.cargo.test.tool.window=테스트 결과를 테스트 도구 창에 표시
advanced.setting.org.rust.cargo.test.tool.window.description=구조화된 테스트 결과를 표시합니다. 결과가 일관적이지 않을 수 있으므로 Rust 1.70.0+ 이상의 안정화된 툴체인을 사용할 때는 권장되지 않습니다.
advanced.setting.org.rust.convert.json.to.struct=붙여 넣을 때 JSON을 Rust로 변환
advanced.setting.org.rust.external.doc.url=외부 문서의 베이스 URL
advanced.setting.org.rust.macros.maximum.recursion.limit=매크로 확장의 최대 재귀 제한
advanced.setting.org.rust.macros.maximum.recursion.limit.description=성능 문제가 발생할 경우 수를 줄입니다
advanced.setting.org.rust.show.attach.projects.dialog=Show Attach Cargo Projects dialog each time a new project is opened
advanced.setting.org.rust.show.attach.projects.dialog.on.file.opened=Show Attach Cargo Projects dialog each time an unattached file is opened
advanced.setting.rust.group=Rust
am.or.pm.in.12.hour.clocks=12시간제의 오전 혹은 오후.
am.or.pm.in.12.hour.clocks2=12시간제의 오전 혹은 오후.
and.impls=\ 및 impl
apply.compiler.fix.command.name=컴파일러 수정 적용
apply.compiler.fix.tooltip=수정 사항 적용
associated.type.defaults=연관 타입 디폴트 값
attach.file=모듈에 파일 연결
attach.projects.dialog.dont.show.again.button=Don't Show Again
attach.projects.dialog.explanation=<html>The following Cargo.toml files are not attached to the project model.<br/>Select the files to attach\:</html>
attach.projects.dialog.ok.button=Attach Selected
attach.projects.dialog.title=Attach Cargo Projects
attribute.0=속성{0}
backtrace=백트레이스(&T)\:
border.title.inline={0} 인라인화
border.title.inline.type.alias=타입 별칭 인라인화
border.title.project.template=프로젝트 템플릿
box.expression.syntax='box' 식 구문
box.pattern.syntax=box 패턴 구문
build=빌드
build.event.message.={0} {1}
build.event.message.cargo.project.update.failed.no.rust.toolchain=Cargo 프로젝트를 업데이트할 수 없습니다.\nRust 툴체인이 없습니다
build.event.message.compiling=컴파일링 중
build.event.message.compiling.0={0} 컴파일링 중
build.event.message.fetching.cargo.config.failed=Cargo 구성을 가져올 수 없습니다\n\n{0}
build.event.message.fetching.target.specific.cfg.options.failed.fallback.to.host.options=대상에 특정적인 ''cfg'' 옵션을 가져올 수 없습니다. 호스트 옵션으로 폴백하는 것을 고려해 보세요.\n\n{0}
build.event.message.fresh=Fresh
build.event.message.internal.compiler.error=내부 컴파일러 오류\:
build.event.message.project.directory.does.not.exist.consider.detaching.project.from.cargo.tool.window=프로젝트 디렉터리 ''{0}''이(가) 없습니다.\n프로젝트 ''{1}''을(를) Cargo 도구 창에서 연결 해제하는 것을 고려해 보세요.
build.event.message.running={0} 실행 중...
build.event.title.build.scripts.evaluation=빌드 스크립트 평가
build.event.title.build.scripts.evaluation.failed=빌드 스크립트 평가 실패
build.event.title.cargo=Cargo
build.event.title.failed.to.fetch.rustc.version=rustc 버전을 페치할 수 없음
build.event.title.failed.to.fetch.stdlib.package.info=stdlib 패키지 정보를 페치할 수 없음
build.event.title.failed.to.load.stdlib.dependencies=stdlib 종속성을 로드할 수 없음
build.event.title.fetching.cargo.config=Cargo 구성 파일 페치 중
build.event.title.fetching.target.specific.cfg.options=타깃별 'cfg' 옵션 페치 중
build.event.title.run.cargo.command=Cargo 명령어 실행
build.event.title.sync.project={0} 프로젝트 동기화
c.str.literals='c".."' 리터럴
c.variadic.functions=C 가변 함수
cargo=Cargo
cargo.command.run.configuration=Cargo 실행 구성
cargo.commandline.description=지정된 폴더에 Cargo 프로젝트를 구성합니다
cargo.commands=Cargo 명령어
cargo.test=Cargo 테스트
cargo.toml=Cargo.toml
cargo.toml.schema=Cargo.toml 스키마
checkbox.async=Async
checkbox.build.on.remote.target=원격 타깃에서 빌드
checkbox.convert.all.usages=모든 사용 위치를 변환
checkbox.emulate.terminal.in.output.console=출력 콘솔에서 터미널 에뮬레이션
checkbox.enable.inspection.only.if.procedural.macros.are.enabled=절차적 매크로가 활성화된 경우에만 검사 실행
checkbox.i.want.to.receive.rustrover.product.news=RustRover 제품 소식 받기
checkbox.ignore.unresolved.references.with.possibly.high.false.positive.rate=거짓 양성일 가능성이 높은 미해결 참조 무시
checkbox.ignore.unused.imports.in.doctests=doctest에서 미사용된 import 문 무시
checkbox.implicitly.add.required.features.if.possible=가능한 경우 필요한 기능을 자동으로 추가
checkbox.run.with.administrator.privileges=관리자 권한으로 실행
checkbox.run.with.root.privileges=루트 권한으로 실행
checkbox.unsafe=안전하지 않음
checkbox.use.all.features.in.tests=테스트 및 벤치마크에서 모든 기능 활성화
code.vision.disable.hints.message=\n            함수에 관한 힌트를 비활성화하려면 적절한 패턴을 사용하세요.<br />\n            <b>std\:\:*</b> ? 표준 라이브러리 함수<br />\n            <b>std\:\:fs\:\:*(*, *)</b> ? 두 개의 매개변수를 취하는 <i>std\:\:fs</i> 모듈의 함수<br />\n            <b>(*_)</b> ? 매개변수 이름이 <i>_</i>로 끝나는 단일 매개변수 함수<br />\n            <b>(key, value)</b> ? <i>key</i> 및 <i>value</i> 매개변수가 있는 함수<br />\n            <b>*.put(key, value)</b> ? <i>key</i> 및 <i>value</i> 매개변수가 있는 <i>put</i> 함수\n
coerced.type=강제된 타입
column.name.apply.to=적용 대상
column.name.covered=포함, %
column.name.file=파일
column.name.item.or.module=항목 혹은 모듈
column.name.mutable=가변형
column.name.pattern=패턴\:
column.name.scope=범위
command=명령어(&C)\:
command.name.choose.constant.name=상수 이름 선택
command.name.choose.field.name=필드 이름 선택
command.name.choose.parameter=매개변수 선택
command.name.choose.struct.name=구조체 이름 선택
command.name.choose.variable=변수 선택
command.name.converting.to.named.fields=''{0}''을(를) 명명된 필드로 변환 중
command.name.converting.to.tuple=''{0}''을(를) 튜플로 변환하는 중
command.name.extract.trait=특성 추출
command.name.extracting.variant=배리언트 {0} 추출 중
command.name.inline={0} {1} 인라인화
command.name.inline.function=함수 ''{0}'' 인라인화
command.name.inline.type.alias=타입 별칭 ''{0}'' 인라인화
command.name.introduce.local.variable=지역 변수 삽입
command.name.move.items=항목 이동
command.name.postfix.let.template='let' 접미사 템플릿
command2=명령어\:
completion.unavailable.during.index.loading=Cargo 레지스트리 색인 로드 중에는 완성이 제한됩니다
configurable.name.rust.external.linter=Rust 외부 Linter
configurable.name.rust.resolve.context=Rust 해결 컨텍스트
console.is.not.enabled=Rust REPL이 비활성화되었습니다
const.closures=const 클로저
const.fn.trait.bound=const fn 특성 바운드
const.generics.defaults=상수 제네릭 디폴트 값
const.trait.impls=상수 특성 impl
constants.equal.to.1=1과 동일한 상수
copy.paste.convert.json.to.struct.dialog.text=삽입된 텍스트가 JSON 객체인 것으로 보입니다. 이 객체로 Rust 구조체를 생성하시겠어요?
copy.paste.convert.json.to.struct.dialog.title=JSON에서 Rust 구조체 생성
copy.paste.import.dialog.explanation=<html>붙여넣은 코드 조각이 새로운 임포트를 가져왔습니다.<br/>아래에서 삭제하고 싶은 임포트를 선택하세요.</html>
copy.paste.import.dialog.title=제거할 임포트 선택
copy.paste.reference.notification=<html>{0}개의 {0, choice, 1\#임포트 |2\#임포트}가 추가되었습니다.<p><span><a href\=''show''>검토하기...</a></span></html>
corrupted.standard.library.0=손상된 표준 라이브러리\: {0}
crate.in.paths=경로 내의 'crate'
dangling.else=불완전한 'else'
day.month.year.format.same.as.e.b.y=(8-Jul-2001) 일-월-년 형식. %e-%b-%Y와 동일합니다.
day.number.01.31.zero.padded.to.2.digits=(08) 날짜 표기(01?31). 0을 추가하여 2자리로 맞춥니다.
day.of.the.year.001.366.zero.padded.to.3.digits=(189) 연중 일수 표기(001?366). 0을 추가하여 3자리로 맞춥니다.
dbg.usage='\#[dbg]' 사용 위치
default.parameter.value=디폴트 매개변수 값
deprecated.item=지원 중단된 항목
details=세부 정보\:
dialog.create.project.custom.add.template.action.add=추가
dialog.create.project.custom.add.template.name=이름\:
dialog.create.project.custom.add.template.title=사용자 지정 템플릿 추가
dialog.create.project.custom.add.template.url=템플릿 URL\:
dialog.create.project.custom.add.template.url.description=<a href\="https\://cargo-generate.github.io/cargo-generate/index.html">cargo-generate</a>로 템플릿이 생성됩니다. GitHub 프로젝트의 링크를 제공할 수 있습니다.
dialog.message.can.not.generate.coverage.report=커버리지 보고서 생성에 실패했습니다. {0}
dialog.message.can.t.create.new.rust.file.or.attach.it.to.module.tree=Rust 파일을 생성하거나 모듈 트리에 연결할 수 없습니다
dialog.message.can.t.detect.target.process.id=타깃 프로세스 ID를 해결할 수 없습니다
dialog.message.can.t.find.binary=바이너리를 찾을 수 없습니다
dialog.message.can.t.get.output.perf.data.file=출력 perf.data 파일을 찾을 수 없습니다
dialog.message.cannot.change.signature.function.in.foreign.crate=외부 크레이트에 있는 함수의 시그니처를 변경할 수 없습니다
dialog.message.cannot.inline.constant.without.expression=표현식 없는 상수를 인라인화할 수 없습니다
dialog.message.cannot.inline.empty.function=빈 함수를 인라인화할 수 없습니다
dialog.message.cannot.inline.function.with.more.than.one.exit.points=여러 개의 종료점이 있는 함수를 인라인화할 수 없습니다
dialog.message.cannot.inline.function.with.recursive.calls=재귀 호출이 있는 함수를 인라인화할 수 없습니다
dialog.message.cannot.inline.multiline.function.into.while.loop.condition=여러 줄로 구성된 함수를 'while' 루프의 조건으로 인라인화할 수 없습니다
dialog.message.cannot.inline.variable.without.expression=표현식 없는 변수를 인라인화할 수 없습니다
dialog.message.cannot.inline.variable.without.identifier=식별자 없는 변수를 인라인화할 수 없습니다
dialog.message.caret.should.be.positioned.at.function.or.method=캐럿을 함수나 메서드에 두어야 합니다
dialog.message.cargo.generate.needed.to.create.project.from.custom.template=사용자 지정 템플릿에서 프로젝트를 생성하려면 cargo-generate가 설치되었는지 확인하세요
dialog.message.channel.cannot.be.set.explicitly.because.rustup.not.available=rustup을 사용할 수 없어 채널을 명시적으로 설정할 수 없습니다
dialog.message.channel.set.explicitly.with.no.rustup.available=채널 ''{0}''은(는) 사용 가능한 rustup 없이 명시적으로 설정되었습니다
dialog.message.debug.toolchain.not.configured=디버그 툴체인이 구성되지 않았습니다
dialog.message.default.value.entered.for.parameter.invalid=매개변수 {0}의 디폴트 값이 올바르지 않습니다
dialog.message.directory.already.exists=디렉터리 {0}이(가) 이미 있습니다
dialog.message.do.you.want.to.find.usages.base.declaration=기본 선언의 사용 위치도 검색하시겠어요?
dialog.message.enter.custom.type.name.type.parameters.are.not.supported=사용자 지정 타입 이름을 입력하세요. 타입 매개변수는 지원되지 않습니다.
dialog.message.error.during.creating.new.rust.file=새 Rust 파일 생성 중 오류 발생\: {0}
dialog.message.failed.to.prepare.remote.environment=원격 환경을 준비하지 못했습니다. {0}
dialog.message.file.not.found=파일을 찾을 수 없습니다. {0}
dialog.message.file.will.not.be.included.in.module.tree.after.move.continue=파일을 이동하면 모듈 트리에 포함되지 않게 됩니다. 계속하시겠어요?
dialog.message.function.name.must.be.valid.rust.identifier=함수 이름은 올바른 Rust 식별자여야 합니다
dialog.message.function.return.type.must.be.valid.rust.type=함수의 반환 타입은 유효한 Rust 타입이어야 합니다
dialog.message.function.visibility.must.be.valid.visibility.specifier=함수 가시성은 올바른 가시성 지정자여야 합니다
dialog.message.gnu.debugger.cannot.be.used.with.msvc.rust.toolchain=GNU 디버거는 MSVC Rust 툴체인과 함께 사용할 수 없습니다
dialog.message.gnu.toolchain.not.supported.please.use.msvc.toolchain=GNU 툴체인은 지원되지 않습니다. MSVC 툴체인을 대신 사용하세요.
dialog.message.html.body.br.b.b.body.html=<html><body>{0}{1}<br/><b>{2}</b> {3}</body></html>\n
dialog.message.html.coverage.report.has.been.successfully.saved.as.file.br.use.instruction.in.href.to.generate.html.output.html=<html>커버리지 보고서가 ''{0}''(으)로 저장되었습니다.<br>HTML로 출력하려면 <a href\="{1}">{2}</a>의 지침을 따르세요.</html>
dialog.message.html.local.debugger.cannot.be.used.with.wsl.br.use.href.https.www.jetbrains.com.help.clion.how.to.use.wsl.development.environment.in.product.html.instructions.to.configure.wsl.toolchain.html=<html>로컬 디버거는 WSL과 함께 사용할 수 없습니다.<br><a href\="https\://www.jetbrains.com/help/clion/how-to-use-wsl-development-environment-in-product.html">CLion 문서의 지침</a>을 따라 WSL을 구성하세요.</html>
dialog.message.illegal.path=잘못된 경로\: {0}
dialog.message.input.file.doesn.t.exist=입력 파일이 없습니다
dialog.message.input.file.not.valid=입력 파일이 잘못되었습니다
dialog.message.internal.error.can.t.find.process.starter=내부 오류\: 프로세스 스타터를 찾을 수 없습니다
dialog.message.invalid.identifier=잘못된 식별자
dialog.message.invalid.toolchain=잘못된 툴체인\: {0}
dialog.message.more.than.one.binary.was.produced.please.specify.bin.lib.test.or.example.flag.explicitly=2개 이상의 바이너리가 생성되었습니다. '--bin', '--lib', '--test' 혹은 '--example' 플래그를 지정하세요.
dialog.message.msvc.debugger.cannot.be.used.with.gnu.rust.toolchain=MSVC 디버거는 GNU Rust 툴체인과 함께 사용할 수 없습니다
dialog.message.msvc.toolchain.not.supported.please.use.gnu.toolchain=MSVC 툴체인은 지원되지 않습니다. GNU 툴체인을 대신 사용하세요.
dialog.message.name.cannot.be.used.as.crate.name=''{0}''은(는) 크레이트 이름으로 사용할 수 없습니다
dialog.message.name.cannot.be.used.as.crate.name2=''{0}''은(는) 크레이트 이름으로 사용할 수 없습니다
dialog.message.name.reserved.windows.filename=파일 이름 ''{0}''은(는) Windows에 의해 예약되었습니다
dialog.message.no.command.specified=지정된 명령어가 없습니다
dialog.message.no.rust.toolchain.specified=지정된 Rust 툴체인이 없습니다
dialog.message.no.suitable.function.to.extract.parameter.found=둘러싸는 함수가 없습니다
dialog.message.no.working.directory.specified=잘못된 작업 디렉터리
dialog.message.package.name.can.t.be.empty=패키지 이름이 공백일 수 없습니다
dialog.message.package.names.should.contain.only.letters.digits=패키지 이름은 문자, 숫자, 하이픈('-') 및 밑줄('_')만 포함할 수 있습니다
dialog.message.package.names.starting.with.digit.cannot.be.used.as.crate.name=패키지 이름은 숫자로 시작할 수 없습니다
dialog.message.parameter.has.invalid.pattern=매개변수 {0}의 패턴이 잘못되었습니다
dialog.message.perf.profiler.not.available.for.selected.toolchain=Perf 프로파일러와 선택된 툴체인을 함께 사용할 수 없습니다
dialog.message.perf.profiler.not.available.for.selected.wsl.distribution.try.updating.wsl.to.newer.one=Perf 프로파일러를 선택된 WSL 배포판과 사용할 수 없습니다.\nWSL을 업데이트해 보세요.
dialog.message.please.choose.target.directory.different.from.current=타깃 디렉터리는 현재 디렉터리와 동일할 수 없습니다
dialog.message.please.enter.type.for.parameter=매개변수 {0}의 타입 지정
dialog.message.profiler.connection.error.can.t.detect.target.process.id=프로파일러와 연결하는 중 오류가 발생했습니다. 타깃 프로세스 ID를 해결할 수 없습니다
dialog.message.run.targets.cannot.be.used.alongside.with.wsl.toolchain='타깃 실행' 기능은 WSL 툴체인과 호환되지 않습니다
dialog.message.rust.toolchain.is.not.set=Rust 툴체인이 구성되지 않았습니다
dialog.message.target.file.must.be.rust.file=대상 파일은 Rust 파일이어야 합니다
dialog.message.this.cargo.package.already.part.attached.workspace=이 Cargo 패키지는 이미 연결된 작업 공간의 일부입니다
dialog.message.type.entered.for.parameter.invalid=매개변수 {0}에 입력된 타입이 올바르지 않습니다
dialog.message.wsl.debugger.cannot.be.used.with.non.wsl.rust.toolchain=WSL 디버거를 비 WSL Rust 툴체인과 사용할 수 없습니다
dialog.message.wsl.toolchain.not.supported=WSL 툴체인은 지원되지 않습니다
dialog.title.choose.destination.file=대상 파일 선택
dialog.title.convert.to.named.fields.settings=명명된 필드로 변환
dialog.title.convert.to.tuple=튜플로 변환
dialog.title.coverage.report.generation=커버리지 보고서 생성
dialog.title.download.debugger=디버거 다운로드
dialog.title.enter.type.name=타입 이름 입력
dialog.title.extract.function=함수 추출
dialog.title.find.usages=사용 위치 찾기
dialog.title.implement.members=멤버 구현
dialog.title.installing.cargo.generate=Cargo-generate 설치 중
dialog.title.move=이동
dialog.title.move.module.items=모듈 항목 이동
dialog.title.move.rust=이동(Rust)
dialog.title.new.cargo.crate=새 Cargo 크레이트
dialog.title.select.cargo.toml=Cargo.toml 연결
dialog.title.select.module=모듈 선택
dialog.title.unable.to.attach.cargo.project=Cargo 프로젝트를 연결할 수 없음
dialog.title.unable.to.build=빌드 실패
dialog.title.unable.to.run.debugger=디버거를 실행할 수 없음
dialog.title.unable.to.run.profiler=프로파일러를 실행할 수 없음
dialog.title.unable.to.run.valgrind=Valgrind를 실행할 수 없음
disable=비활성화
disabling.the.test.tool.window=테스트 도구 창을 비활성화하는 중
discriminant.on.a.non.unit.variant=유닛이 아닌 배리언트에 대한 판별자
documentation.raw.byte.string.literals.def=<h3>원시 바이트 문자열 리터럴</h3>
documentation.raw.byte.string.literals.p1=<p>원시 바이트 문자열 리터럴은 이스케이프를 처리하지 않습니다. <code class\="hljs">U+0062</code>(<code class\="hljs">b</code>)로 시작하고 <code class\="hljs">U+0072</code> ( <code class\="hljs">r</code>) 뒤에 256자 미만의 문자 <code class\="hljs">U+0023</code> (<code class\="hljs">\#</ code>) 및 <code class\="hljs">U+0022</code> (쌍따옴표) 문자가 따릅니다. <em>원시 문자열 본문</em>은 임의의 연속 ASCII 문자를 포함할 수 있으며, <code class\="hljs">U+0022</code>(쌍따옴표) 문자로 시작하는 동일한 수의 <code class\="hljs">U+0023</code> (<code class\="hljs">\#</code>) 문자가 뒤에 오는 또 다른 <code class\="hljs">U+0022</code>(쌍따옴표) 문자로만 종료됩니다. 원시 바이트 문자열 리터럴은 비 ASCII 바이트를 포함할 수 없습니다. </p>
documentation.raw.byte.string.literals.p2=<p>원시 문자열 본문에 포함된 모든 문자는 ASCII 인코딩을 의미합니다. 문자 <code class\="hljs">U+0022</code>(쌍따옴표)(원시 문자열 리터럴을 시작한 것과 최소 같은 개수의 <code class\="hljs">U+0023</code>(<code class\="hljs">\#</code>) 문자가 사용된 경우는 제외) 혹은 <code class\="hljs">U+005C</code>(<code class\="hljs"></code>)는 특별한 의미가 없습니다.</p>
documentation.raw.byte.string.literals.p3=<p>바이트 문자열 리터럴 예시\:</p>
documentation.raw.string.literals.def=<h3>원시 문자열 리터럴</h3>
documentation.raw.string.literals.p1=<p>원시 문자열 리터럴은 이스케이프를 처리하지 않습니다. <code>U+0072</code>(<code>r</code>)로 시작하고 256자 미만의 <code>U+0023</code>(<code>\#</code>) 및 < code>U+0022</code>(쌍따옴표) 문자가 뒤에 옵니다. <em>원시 문자열 본문</em>은 임의의 연속 유니코드 문자를 포함할 수 있으며, <code>U+0022</code>(쌍따옴표) 문자로 시작하는 동일한 수의 <code>U+0023< /code>(<code>\#</code>) 문자는 뒤에 오는 다음 다른 <code>U+0022</code>(쌍따옴표) 문자로만 종료됩니다.</p>
documentation.raw.string.literals.p2=<p>원시 문자열 본문에 포함된 모든 유니코드 문자는 그 자체를 의미합니다. 문자 <code>U+0022</code>(쌍따옴표)(원시 문자열 리터럴을 시작한 것과 최소 같은 개수의 <code>U+0023</code>(<code>\#</code>) 문자가 사용된 경우는 제외) 혹은 <code>U+005C</code>(<code></code>)는 특별한 의미가 없습니다.</p>
documentation.raw.string.literals.p3=<p>문자열 리터럴 예시\:</p>
don.t.show.again=다시 표시 안 함
double.negation=이중 부정
download.failed.0=다운로드 실패\: {0}
drop.reference=참조 삭제
duplicated.trait.method.parameter.binding=중복되는 특성 메서드 매개변수 바인딩
dyn.keyword=`dyn` 키워드
empty.0=빈 ''{0}''
enum=enum
error.message.struct.inheritance.is.not.supported=구조체 상속은 Rust에서 지원되지 않습니다
exclusive.range.patterns=배제 범위 패턴
expected.0.found.1=''{0}''이(가) 필요하나 ''{1}''이(가) 발견되었습니다
explain.move.highlights.code.elements.that.resulted.in.this.error=Highlights code elements that resulted in this error.
explain.move.value.moved.here=Value{0, choice, 0\#|1\# partially} moved{1, choice, 0\#|1\# into closure} here{2, choice, 0\#|1\# by the macro call} {3, choice, 0\#|1\#, in the previous iteration of loop}
explain.move.was.moved={0} was moved
extern.crate.self=extern crate self
extern.types=extern 타입
external.linter=외부 Linter
failed.to.get.project.sysroot=프로젝트 sysroot를 가져올 수 없습니다
failed.to.run.cargo=Cargo 실행 실패
feature.0=기능{0}
feedback.notification.thanks.feedback.content=RustRover를 개선하는 데 큰 도움이 되었습니다\!
feedback.user.dialog.cancel.label=아니요
feedback.user.dialog.description=꽤 오랜 시간 동안 RustRover를 사용하셨습니다. 사용자님의 경험이 어땠는지 알려주세요\!
feedback.user.dialog.like_most.label=RustRover에서 가장 마음에 드는 점은 무엇인가요?
feedback.user.dialog.ok.label=피드백 보내기
feedback.user.dialog.problems.label=문제점이나 빠진 기능이 있다면 알려주세요
feedback.user.dialog.satisfaction.label=RustRover가 전체적으로 만족스러우신가요?
feedback.user.dialog.title=RustRover에 관한 피드백 공유
feedback.user.dialog.top.title=피드백
fetching.actual.stdlib.info.failed.hardcoded.stdlib.structure.will.be.used=최신 stdlib 정보를 가져올 수 없습니다. 하드코딩된 stdlib 구조가 대신 사용됩니다.
file=파일
fn.0=fn {0}
from=원본 위치\:
full.month.name.july=(July) 전체 월 이름.
full.weekday.name.sunday=(Sunday) 전체 요일 이름.
function=함수
gen.syntax=`gen` 구문
generic.associated.types=제네릭 연결 타입
go.to.class.kind.text=타입
go.to.class.kind.text.pluralized=타입
group.Rust.MacroExpansionActions.text=매크로 확장 표시
group.Rust.Tools.text=Rust
gutter.rust.generated.typescript.declarations.name=생성된 TypeScript 선언
gutter.rust.generated.typescript.declarations.popup.title=생성된 선언
gutter.rust.generated.typescript.declarations.tooltip=생성된 선언으로 이동
gutter.rust.implemented.item.name=Implemented item
gutter.rust.implemented.item.tooltip=구현이 있습니다
gutter.rust.implementing.item=항목 구현 중
gutter.rust.open.documentation.for=''{0}''에 대한 문서 열기
gutter.rust.open.documentation.name=문서 열기
gutter.rust.open.documentation.toml.name=문서 열기(TOML)
gutter.rust.overriding.item=항목을 재정의하는 중
gutter.rust.recursive.call.name=재귀 호출
half.open.range.patterns=반개 범위 패턴
has.0.occurrences={0}개의 찾은 항목이 있습니다
has.1.occurrence=1개의 찾은 항목이 있습니다
highlighter.action.text.go.to.implementations=구현으로 이동
highlighter.name.implementations=구현
hint.text.crates.local.index.not.ready.yet=크레이트 로컬 색인이 아직 준비되지 않았습니다
hint.text.no.members.to.implement.have.been.found=구현할 멤버가 없습니다
hint.text.please.convert.innermost.impl.trait.first=가장 내부에 있는 'impl Trait'를 먼저 변환하세요
hint.text.select.expression=표현식 선택
hint.text.some.elements.that.action.going.to.change.exist.only.in.macro.expansion.so.cannot.be.changed.by.action=변경될 일부 요소가 매크로 확장에만 존재하며 이 액션으로는 변경되지 않습니다
hour.minute.format.same.as.h.m=(00\:34) 시-분 형식. %H\:%M과 동일합니다.
hour.minute.second.format.in.12.hour.clocks.same.as.i.m.s.p=(12\:34\:60 AM) 12시간제 시-분-초 형식. %I\:%M\:%S %p와 동일합니다.
hour.minute.second.format.same.as.h.m.s=(00\:34\:60) 시-분-초 형식. %H\:%M\:%S와 동일합니다.
hour.number.00.23.zero.padded.to.2.digits=(00) 시간 표기(00?23). 0을 추가하여 2자리로 맞춥니다.
hour.number.in.12.hour.clocks.01.12.zero.padded.to.2.digits=(12) 12시간제 시간 표기(01?12). 0을 추가하여 2자리로 맞춥니다.
html.head.0.style.body.background.1.text.align.center.style.head.body.2.body.html=\n        <html>\n        <head>\n            {0}\n            <style>body '{'background\: \#{1}; text-align\: center; '}'</style>\n        </head>\n        <body>\n            {2}\n        </body>\n        </html>\n
if.let.guard='if let' guard
impl.keyword=`impl` 키워드
inherent.associated.types=본질적으로 연관된 타입
inline.const=inline const
inline.const.pat=inline const pat
inspection.DoubleMustUse.FixRemoveMustUseAttr.name='\#[must_use]'를 함수에서 제거
inspection.DoubleMustUse.description=이 함수에는 '\#[must_use]' 속성이 있지만 이미 '\#[must_use]'로 표시된 타입을 반환합니다
inspection.PathStatementsInspection.description.drops.value=경로 구문이 값을 버립니다
inspection.PathStatementsInspection.description.no.effect=효과가 없는 경로 구문
inspection.RedundantSemicolons.description.multiple=불필요한 후행 세미콜론
inspection.RedundantSemicolons.description.single=불필요한 후행 세미콜론
inspection.RedundantSemicolons.fix.name=불필요한 후행 세미콜론 제거
inspection.UnusedLabels.description=사용되지 않는 라벨
inspection.UnusedMustUse.AddAwaitFix.name='.await' 추가
inspection.UnusedMustUse.FixAddExpect.family.name='.expect("")' 추가
inspection.UnusedMustUse.FixAddLetUnderscore.name='let _ \=' 추가
inspection.UnusedMustUse.FixAddUnwrap.name='.unwrap()' 추가
inspection.UnusedMustUse.description.function.attribute=사용되어야 하는 반환 값 ''{0}''이(가) 사용되지 않음
inspection.UnusedMustUse.description.type.attribute=사용되지 않은 {0}이(가) 사용되어야 합니다
inspection.can.be.replaced.with.local.stable.method=`with` 호출은 스레드 로컬의 안정된 메서드로 대체할 수 있습니다
inspection.cargo.toml.cyclic.feature.display.name=순환 기능 종속성
inspection.crate.not.found.display.name=크레이트를 찾을 수 없습니다
inspection.crate.version.invalid.display.name=잘못된 크레이트 버전
inspection.duplicated.key.display.name=중복 키
inspection.message.={0}\: {1}
inspection.message.0.1.2.and.other.fields=`{0}`, `{1}`, `{2}` 및 기타 {3}개의 {4, choice, 0\#필드|1\#필드}
inspection.message.0.1.and.2=`{0}`, `{1}`, 및 `{2}`
inspection.message.0.and.1=`{0}` 및 `{1}`
inspection.message.a.field.type.must.be.specified=Field type is required
inspection.message.access.field.on.primitive.type=`{0}` cannot have fields as it is a primitive type
inspection.message.access.nonexistent.field=타입 ''{1}''에 필드 ''{0}''이(가) 없습니다
inspection.message.access.to.union.field.unsafe.requires.unsafe.function.or.block=공용체 필드 액세스는 'unsafe' 블록이나 함수 내에서만 허용됩니다
inspection.message.align.argument.must.be.power.two='align' 인수는 2승이어야 합니다
inspection.message.align.argument.must.be.unsuffixed.integer='align'에 전달되는 인수는 접미사가 없는 정수이어야 합니다
inspection.message.align.argument.must.not.be.larger.than='align'에 전달되는 인수는 2^29를 초과할 수 없습니다
inspection.message.align.needs.argument='align' 제어자에는 인수가 필요합니다
inspection.message.align.takes.exactly.one.argument.in.parentheses='align' 제어자는 괄호로 둘러쌓인 하나의 인수가 필요합니다
inspection.message.all.versions.matching.for.crate.are.yanked=크레이트 ''{1}''의 {0}와(과) 일치하는 모든 버전이 삭제됩니다
inspection.message.anonymous.functions.parameters.are.deprecated.rfc=익명 함수 매개변수는 더 이상 지원되지 않습니다(RFC 1685)
inspection.message.approximate.value.found.consider.using.it.directly=''{0}''의 근사값이 발견되었습니다
inspection.message.are.not.allowed.inside={2} 내에서 ''{0}''은(는) 허용되지 않습니다
inspection.message.argument.never.used=인수가 한 번도 사용되지 않습니다
inspection.message.array.index.out.of.bounds=범위를 벗어난 색인\: 배열 길이는 {0}이지만 색인은 {1}입니다
inspection.message.array.size.cannot.refer.to.static=static ''{0}''은(는) 배열 크기로 사용할 수 없습니다
inspection.message.assert.b.can.be.b=''assert\!(a {0} b)''는 ''{1}\!(a, b)''로 바꿀 수 있습니다
inspection.message.associated.type.not.found.for=''{1}''와(과) 연관된 타입 ''{0}''이(가) 발견되지 않았습니다
inspection.message.async.non.move.closures.with.parameters.are.currently.not.supported=매개변수가 있고 'move'가 아닌 'async' 클로저는 현재 지원되지 않습니다
inspection.message.at.least.one.trait.required.for.object.type=객체 타입에는 최소 하나의 특성이 필요합니다
inspection.message.attribute.should.be.applied.to.enum=''{0}'' 속성은 열거형에만 적용할 수 있습니다
inspection.message.attribute.should.be.applied.to.function.or.closure=속성은 함수나 클로저에만 적용할 수 있습니다
inspection.message.attribute.should.be.applied.to.struct.enum.or.union=''{0}'' 속성은 구조체, 열거형 혹은 공용체에만 적용할 수 있습니다
inspection.message.attribute.should.be.applied.to.struct.or.union=''{0}'' 속성은 구조체 혹은 공용체에만 적용할 수 있습니다
inspection.message.attributes.on.function.parameters.experimental='함수 매개변수의 속성'은 실험적인 기능입니다
inspection.message.await.only.allowed.inside.async.functions.blocks='await'은 'async' 함수 및 블록 내에서만 허용됩니다
inspection.message.binary.assignment.operation.cannot.be.applied.to.type=2진 대입 연산 ''{0}''은(는) 타입 ''{1}''에 적용할 수 없습니다
inspection.message.binary.operation.cannot.be.applied.to.type=2진 연산 ''{0}''은(는) 타입 ''{1}''에 적용할 수 없습니다
inspection.message.binding.never.used=바인딩 ''{0}''이(가) 한 번도 사용되지 않습니다
inspection.message.boolean.expression.can.be.simplified=bool 표현식을 단순화할 수 있음
inspection.message.bounds.on.have.no.effect={0}의 바운드는 효과가 없습니다
inspection.message.break.with.value.from.loop=`break` with a value is not allowed in `{0}` loops
inspection.message.c.variadic.function.must.have.compatible.calling.convention.like.c.or.cdecl=C 가변 함수는 'C' 혹은 'cdecl'과 같이 호환되는 호출 규칙을 사용해야 합니다
inspection.message.call.to.std.mem.drop.with.reference.argument.dropping.reference.does.nothing=참조 인수를 사용하여 std\:\:mem\:\:drop을 호출하면 효과가 없습니다
inspection.message.call.to.unsafe.function=안전하지 않은 함수의 호출
inspection.message.call.to.unsafe.function.requires.unsafe.function.or.block=안전하지 않은 함수의 호출은 'unsafe' 블록이나 함수 내에서만 허용됩니다
inspection.message.calls.in.constants.are.limited.to.constant.functions.tuple.structs.tuple.variants=상수 표현식은 상수 함수, 튜플 구조체 혹은 튜플 배리언트만 포함할 수 있습니다
inspection.message.can.be.replaced.with=''{0}''(으)로 바꿀 수 있습니다
inspection.message.can.be.replaced.with.literal.suffix=리터럴 접미사로 바꿀 수 있습니다
inspection.message.can.be.replaced.with.random=''random{0}()''(으)로 바꿀 수 있습니다
inspection.message.can.impl.only.struct.s.enum.s.union.s.trait.objects=고유한 'impl' 블록은 구조체, 열거형, 공용체 및 특성 객체에만 추가할 수 있습니다
inspection.message.can.t.capture.dynamic.environment.in.fn.item='fn' 항목 내 동적인 환경을 캡처할 수 없습니다
inspection.message.can.t.find.crate.for=크레이트 ''{0}''을(를) 찾을 수 없습니다
inspection.message.cannot.add.to=''{0}''을(를) ''{1}''(으)로 추가할 수 없습니다
inspection.message.cannot.apply.unary.operator.to.type=단항 연산자 `{0}`을(를) 타입 `{1}`에 적용할 수 없습니다
inspection.message.cannot.assign.to=''{0}''에 새로운 값을 대입할 수 없습니다
inspection.message.cannot.assign.twice.to.immutable.variable=불변 변수에 여러 번 새로운 값을 대입할 수 없습니다
inspection.message.cannot.be.declared.unsafe=''{0}''은(는) 불안전한 것으로 선언될 수 없습니다
inspection.message.cannot.be.used.in.closures.only.inside.loop.while.blocks=''{0}''은(는) 클로저 내에서 사용할 수 없습니다. ''loop'' 및 ''while'' 블록 내에서만 사용할 수 있습니다
inspection.message.cannot.be.variadic=''{0}''은(는) 가변형일 수 없습니다
inspection.message.cannot.borrow.immutable.local.variable.as.mutable=불변 지역 변수 ''{0}''을(를) 가변형으로 사용할 수 없습니다
inspection.message.cannot.cast.as.bool=`bool`로 형 변환할 수 없습니다
inspection.message.cannot.cast.from.pointer.unknown.kind=포인터를 알 수 없는 종류로 형 변환할 수 없습니다
inspection.message.cannot.cast.thin.pointer.to.fat.pointer=뚱뚱한 포인터 `{0}`을(를) 날씬한 포인터 `{1}`(으)로 형 변환할 수 없습니다
inspection.message.cannot.cast.to.pointer.that.may.be.wide=`{0}`을(를) 넓을 수도 있는 포인터로 형 변환할 수 없습니다
inspection.message.cannot.cast.to.pointer.that.wide=`{0}`을(를) 넓은 포인터로 형 변환할 수 없습니다
inspection.message.cannot.cast.to.pointer.unknown.kind=포인터를 알 수 없는 종류로 형 변환할 수 없습니다
inspection.message.cannot.declare.non.inline.module.inside.block.unless.it.has.path.attribute=인라인화되지 않은 모듈에 경로 속성이 없으면 블록 내에서 선언할 수 없습니다
inspection.message.cannot.define.inherent.impl.for.dyn.auto.trait=고유한 'impl'을 동적 자동 특성으로 선언할 수 없습니다
inspection.message.cannot.define.inherent.impl.for.type.outside.crate.where.type.defined=고유한 'impl'은 그 안에 포함된 크레이트의 외부에 있는 타입에 대해 정의할 수 없습니다
inspection.message.cannot.divide.by=''{0}''을(를) ''{1}''(으)로 나눌 수 없습니다
inspection.message.cannot.have.anonymous.parameters=''{0}''은(는) 익명 매개변수를 가질 수 없습니다
inspection.message.cannot.have.body=''{0}''은(는) 본문을 가질 수 없습니다
inspection.message.cannot.have.const.qualifier=''{0}''은(는) ''const'' 한정자를 가질 수 없습니다
inspection.message.cannot.have.default.qualifier=''{0}''은(는) ''default'' 한정자를 가질 수 없습니다
inspection.message.cannot.have.extern.abi=''{0}''은(는) extern ABI를 가질 수 없습니다
inspection.message.cannot.have.generic.parameters=''{0}은(는) 제네릭 매개변수를 가질 수 없습니다
inspection.message.cannot.have.pub.qualifier=''{0}''은(는) ''pub'' 한정자를 가질 수 없습니다
inspection.message.cannot.have.self.parameter=''{0}은(는) ''self'' 매개변수를 가질 수 없습니다
inspection.message.cannot.have.unsafe.qualifier=''{0}''은(는) ''unsafe'' 한정자를 가질 수 없습니다
inspection.message.cannot.have.where.clause=''{0}''은(는) ''where'' 절을 가질 수 없습니다
inspection.message.cannot.have.where.clause.after.type=''{0}''은(는) 타입 뒤에 ''where'' 절을 가질 수 없습니다
inspection.message.cannot.have.where.clause.before.type=''{0}''은(는) 타입 앞에 ''where'' 절을 가질 수 없습니다
inspection.message.cannot.implement.both.copy.drop=Both `Copy` and `Drop` cannot be implemented simultaneously
inspection.message.cannot.mod.by=''{0}''을(를) ''{1}''(으)로 모듈화할 수 없습니다
inspection.message.cannot.move=이동할 수 없습니다
inspection.message.cannot.multiply.by=''{0}''을(를) ''{1}''(으)로 곱할 수 없습니다
inspection.message.cannot.subtract.from=''{1}''에서 ''{0}''을(를) 뺄 수 없습니다
inspection.message.cast.to.unsized.type.as=unsized 타입으로의 형 변환\: `{0}`을(를) `{1}`(으)로
inspection.message.casting.as.invalid=`{0}`을(를) `{1}`(으)로 형 변환할 수 없습니다
inspection.message.cfg.predicate.cannot.be.a.literal=술부 키는 리터럴일 수 없습니다
inspection.message.cfg.predicate.is.not.specified=술부 누락
inspection.message.cfg.predicate.must.be.identifier=술부 키는 식별자여야 합니다
inspection.message.chained.comparison.operator.require.parentheses=연속 비교 연산자에는 소괄호가 필요합니다
inspection.message.condition.always=조건이 항상 {0}입니다
inspection.message.const=상수
inspection.message.const.cannot.refer.to.static=상수 ''{0}''은(는) static ''{1}''을(를) 참조할 수 없습니다
inspection.message.const.generic.argument.cannot.refer.to.static=상수 제네릭 인수는 static ''{0}''을(를) 참조할 수 없습니다
inspection.message.const2=상수
inspection.message.constant=상수 ''{0}''
inspection.message.constant.function.cannot.refer.to.static=상수 함수 ''{0}''은(는) static ''{1}''을(를) 참조할 수 없습니다
inspection.message.consts={0}\:\:{1}\:\:consts\:\:{2}
inspection.message.continue.pointing.to.labeled.block='continute'가 라벨이 지정된 블록을 가리킵니다
inspection.message.crate.in.paths.can.only.be.used.in.start.position=경로 내의 'crate'는 시작 위치에서만 사용할 수 있습니다
inspection.message.crate.name.can.only.contain.unicode.alphanumeric.or.underscore.empty.found=크레이트 이름은 유니코드 영숫자 또는 '_' 문자만 포함할 수 있습니다
inspection.message.crate.name.cannot.be.empty.found=크레이트 이름이 공백일 수 없습니다
inspection.message.crate.not.found=크레이트 ''{0}''을(를) 찾을 수 없습니다
inspection.message.cyclic.feature.dependency.feature.depends.on.itself=순환 기능 종속성\: 기능 ''{0}''이(가) 자신에게 종속되어 있습니다
inspection.message.default.cannot.have.pub.qualifier=디폴트 ''{0}''은(는) ''pub'' 한정자를 가질 수 없습니다
inspection.message.default.parameter.values.are.not.supported.in.rust=디폴트 매개변수 값은 Rust에서 지원되지 않습니다
inspection.message.defaults.for.const.parameters.are.only.allowed.in.struct.enum.type.or.trait.definitions=상수 매개변수의 디폴트 값은 구조체, 열거형, 타입 및 특성 정의에서만 허용됩니다
inspection.message.defaults.for.type.parameters.are.only.allowed.in.struct.enum.type.or.trait.definitions=타입 매개변수의 디폴트 값은 구조체, 열거형, 타입 및 특성 정의에서만 허용됩니다
inspection.message.denote.infinite.loops.with.loop=무한 루프는 ''loop { ... }''로 표시
inspection.message.dereference.raw.pointer.requires.unsafe.function.or.block=원시 포인터의 역참조는 'unsafe' 블록 혹은 함수에서만 허용됩니다
inspection.message.derive.may.only.be.applied.to.structs.enums.unions='derive'는 구조체, 열거형 및 공용체에만 적용할 수 있습니다
inspection.message.different.impl.member.order.from.trait='impl' 멤버의 순서가 특성과 다릅니다
inspection.message.direct.implementation.of.to.string=`ToString`은 직접 구현되면 안됩니다
inspection.message.discriminant.value.already.exists=판별자 값 ''{0}''이(가) 이미 있습니다
inspection.message.doesn.t.derive.both.partialeq.eq=''{0}''은(는) ''PartialEq'' 및 ''Eq'' 모두를 파생할 수 없습니다
inspection.message.doesn.t.implement.required.by=''{0}''은(는) ''{1}''을(를) 구현하지 않습니다(''{2}''에 필요)
inspection.message.drop.can.be.only.implemented.by.structs.enums=`Drop` can only be implemented for structs and enums
inspection.message.duplicate.definitions.with.name=중복 정의 ''{0}''
inspection.message.duplicate.field=필드 중복
inspection.message.duplicate.key=중복 해시 키
inspection.message.duplicate.macro.pattern=중복 매크로 패턴
inspection.message.duplicated.parameter.name.consider.renaming.it=매개변수 이름 ''{0}'' 중복
inspection.message.enum.variant=열거형 배리언트
inspection.message.enum.variant.expected=열거형 배리언트가 필요합니다
inspection.message.enum.variant.s.discriminant.value.cannot.refer.to.static=''{0}'' 열거형 variant의 판별자 값은 static ''{1}''을(를) 참조할 수 없습니다
inspection.message.enum.with.no.variants.can.t.have.repr.attribute=배리언트가 없는 열거형은 'repr' 속성을 가질 수 없습니다
inspection.message.expected.cfg.pattern=하나의 cfg 패턴이 필요합니다
inspection.message.expected.function.found=함수가 필요하지만 ''{0}''이(가) 발견되었습니다
inspection.message.expected.path.to.trait.found.literal=Expected path to a trait but found literal
inspection.message.expected.trait.bound.found.impl.trait.type=특성 바운드가 필요하지만 'impl Trait' 타입이 발견되었습니다
inspection.message.expected.trait.found=특성이 필요하지만 {0} ''{1}''이(가) 발견되었습니다
inspection.message.experimental.can.be.added=`{0}` 기능은 안정적이지 않으며 현재 활성화되어 있지 않습니다
inspection.message.experimental.not.available=`{0}` 기능은 현재 Rust 툴체인에서 사용할 수 없습니다
inspection.message.explicit.calls.to.drop.are.forbidden.use.std.mem.drop.instead='drop'의 명시적 호출은 금지됩니다. 'std\:\:mem\:\:drop'을 대신 사용하세요.
inspection.message.explicit.impls.for.sized.trait.are.not.permitted='Sized' 특성의 명시적 impl은 허용되지 않습니다
inspection.message.explicit.impls.for.unsize.trait.are.not.permitted='Unsize' 특성의 명시적 impl은 허용되지 않습니다
inspection.message.explicit.lifetimes.given.in.parameter.types.where.they.could.be.elided=매개변수 타입이 생략될 수 있는 명시적인 유효기간을 포함하고 있습니다
inspection.message.expression.can.be.simplified=표현식을 단순화할 수 있습니다
inspection.message.expressions.must.be.enclosed.in.braces.to.be.used.as.const.generic.arguments=표현식을 const 제네릭 인수로 사용하려면 중괄호로 둘러싸세요
inspection.message.extern=extern
inspection.message.extern.crate.self.requires.as.name='extern crate self'는 'as name'이 필요합니다
inspection.message.extra.field.found.in.pattern={0} `{1}`에 필드 `{2}`이(가) 없습니다
inspection.message.extra.fields.found.in.tuple.struct.pattern.expected.found=튜플 구조체 패턴에서 추가 필드가 발견되었습니다. {0}이(가) 필요하나 {1}이(가) 발견되었습니다
inspection.message.failed.to.resolve.could.not.find=`{1}`에서 `{0}`을(를) 찾을 수 없습니다
inspection.message.failed.to.resolve.use.undeclared.crate.or.module=선언되지 않은 크레이트 혹은 모듈 `{0}`의 사용
inspection.message.failed.to.resolve.use.undeclared.type=선언되지 않은 타입 `{0}`의 사용
inspection.message.feature.has.been.removed=기능 ''{0}''은(는) 제거되었습니다
inspection.message.feature.may.not.be.used.on.release.channel=''\#\![feature]''은 {0} 릴리스 채널에서 사용할 수 없습니다
inspection.message.field.already.declared=필드 ''{0}''은(는) 이미 선언되었습니다
inspection.message.field.bound.multiple.times.in.pattern=필드 ''{0}''이(가) 패턴 내에서 여러 번 바운드됩니다
inspection.message.field.struct.private=구조체 ''{1}''의 필드 ''{0}''이(가) private입니다
inspection.message.file.not.found.for.module=모듈 ''{0}''의 파일을 찾을 수 없습니다
inspection.message.file.not.included.in.module.tree.analysis.not.available=모듈 선언이 누락되었습니다. 스마트 편집 및 자동 완성 기능에 영향을 줄 수 있습니다.
inspection.message.for.loop.expression.has.unnecessary.parentheses='for' 루프 식에 불필요한 소괄호가 있습니다
inspection.message.foreign.items.may.not.have.parameters=외부 항목은 {0} 매개변수를 가질 수 없습니다
inspection.message.format.call.without.format.parameters=서식 매개변수가 없는 `format\!` 호출
inspection.message.formatting.is.supported.only.for.tuples.up.to.12.elements=최대 12개의 요소를 가진 튜플의 서식을 지정할 수 있습니다.
inspection.message.from.trait=''{0}''(''{1}'' 특성로부터)
inspection.message.function.returns.instead=함수가 ''{0}'' 대신 ''()''를 반환합니다
inspection.message.functions.with.start.attribute.must.have=`\#[start]` 속성으로 표시된 함수에는 {0}이(가) 있어야 합니다
inspection.message.functions.with.start.attribute.must.return.isize=`\#[start]` 속성으로 표시된 함수는`isize`를 반환해야 합니다
inspection.message.generic.arguments.must.come.before.first.constraint=제네릭 인수는 첫 번째 제약 앞에 지정되어야 합니다
inspection.message.generic.default.param.cannot.use.forward.declared.identifiers=Generic parameters with a default value cannot use forward-declared identifiers
inspection.message.generic.parameter.expected=제네릭 매개변수가 필요합니다
inspection.message.has.been.removed=''{0}''이(가) 제거되었습니다
inspection.message.has.been.removed2={0} has been removed
inspection.message.has.but.its.trait.declaration.has={0} ''{1}''에는 {2} {3}이(가) 있지만 특성 선언에는 {4} {5}이(가) 있습니다
inspection.message.identifier.bound.more.than.once.in.same.pattern=식별자 ''{0}''이(가) 동일한 패턴에서 한 번 이상 바운드됩니다
inspection.message.identifier.bound.more.than.once.in.this.parameter.list=식별자 ''{0}''이(가) 이 매개변수 목록에서 한 번 이상 바운드됩니다
inspection.message.impl.trait.not.allowed.in.path.parameters='impl Trait'은(는) 경로 매개변수에서 허용되지 않습니다
inspection.message.impl.trait.not.allowed.outside.function.inherent.method.return.types='impl Trait'은(는) 함수 또는 고유한 메서드 반환 타입의 외부에서는 허용되지 않습니다
inspection.message.implementing.trait.not.unsafe=특성 ''{0}''을(를) 구현하는 것은 안전합니다
inspection.message.in.expressions.can.only.be.used.on.left.hand.side.assignment=표현식에서 '_'은 대입의 왼쪽에만 사용할 수 있습니다
inspection.message.in.this.pattern.redundant=이 패턴에서 ''{0}\:''은(는) 불필요합니다
inspection.message.inclusive.ranges.must.be.bounded.at.end.b.or.b=포괄적인 범위에는 반드시 끝나는 바운드가 지정되어야 합니다('..\=b' or 'a..\=b')
inspection.message.incorrect.meta.item=Invalid meta item
inspection.message.incorrect.repr.align.attribute.format=잘못된 '\#[repr(align())]' 속성 서식
inspection.message.incorrect.visibility.restriction=잘못된 가시성 제한
inspection.message.inherent.impls.cannot.be.unsafe=고유한 impl은 반드시 안전해야 합니다
inspection.message.invalid.abi.found=잘못된 ABI\: {0}
inspection.message.invalid.crate.type.value=잘못된 'crate_type' 값
inspection.message.invalid.dyn.keyword=잘못된 'dyn' 키워드
inspection.message.invalid.format.string=잘못된 서식 문자열
inspection.message.invalid.format.string.expected.if.you.intended.to.print.symbol.you.can.escape.it.using=잘못된 서식 문자열\: '}'가 필요합니다.\n'{' 기호를 출력하려는 경우 이스케이프 시퀀스('{{')를 사용하세요.
inspection.message.invalid.format.string.unmatched=잘못된 서식 문자열\: 짝이 없는 '}'
inspection.message.invalid.json.schema.format=Value format should be `{0}`
inspection.message.invalid.label.name=잘못된 라벨 이름 ''{0}''
inspection.message.invalid.path.self.super.are.allowed.only.at.beginning=잘못된 경로\: 'self'와 'super'는 경로의 시작 부분에만 허용됩니다
inspection.message.invalid.predicate=잘못된 술부 ''{0}''
inspection.message.invalid.reference.to.positional.argument=위치 인수 {0}에 대한 잘못된 참조({1})
inspection.message.invalid.suffix.for.suffix.must.be.one=''{1}''의 접미사 ''{0}''이(가) 잘못되었습니다. 접미사는 다음 중 하나이어야 합니다. {2}
inspection.message.invalid.version.requirement=잘못된 버전 요구사항 ''{0}''
inspection.message.invoking.drop.with.copy.type=`Copy`를 구현하는 값이 있는 `std\:\:mem\:\:drop`을 호출하면 아무 일도 일어나지 않습니다
inspection.message.it.not.allowed.to.cast.to.bool=부울로 형 변환할 수 없습니다
inspection.message.item.associated.which.doesn.t.match.its.trait=''{0}''은(는) 연관된 {1}으로, 특성 ''{2}''의 정의와 상충됩니다
inspection.message.item.expected=항목이 필요합니다
inspection.message.let.expressions.are.not.supported.here='let' 식은 여기서 사용할 수 없습니다
inspection.message.let.expressions.in.this.position.are.unstable=이 위치의 'let' 식은 안정적이지 않습니다
inspection.message.lifetime.name.declared.twice.in.same.scope=유효기간 이름 ''{0}''이(가) 동일한 범위에서 두 번 선언됩니다
inspection.message.lifetime.without.specified.name=이름이 없는 유효기간이 지정되었습니다
inspection.message.lifetimes.cannot.use.keyword.names=유효기간은 키워드 이름을 사용할 수 없습니다
inspection.message.literal.out.of.range=리터럴 ''{0}''은(는) 타입 ''{1}''에 맞지 않습니다
inspection.message.macro.reference.unexpected=타입이 `{1}`인 예기치 않은 요소 `{0}`
inspection.message.main.function.not.allowed.to.have.generic.parameters='main' 함수는 제네릭 매개변수를 가질 수 없습니다
inspection.message.main.function.not.found.in.crate=크레이트 ''{0}''에 ''main'' 함수가 없습니다
inspection.message.main.is.async=''{0}'' 함수는 ''async''일 수 없습니다
inspection.message.malformed.attribute.input=잘못된 ''{0}'' 속성 입력
inspection.message.malformed.attribute.input.missing.parentheses=잘못된 ''{0}'' 속성 입력\: 소괄호가 누락되었습니다
inspection.message.manual.implementations.are.experimental=''{0}''의 수동 구현은 실험적 기능입니다
inspection.message.match.expr.can.be.replaced.with.method.call=match 식을 메서드 호출로 바꿀 수 있음
inspection.message.match.expression.has.unnecessary.parentheses='match' 식에 불필요한 소괄호가 있습니다
inspection.message.match.must.be.exhaustive='match' 식이 모든 가능한 경우를 포함하지 않습니다
inspection.message.may.only.be.used.inside.loop.while.blocks=''{0}''은(는) ''loop'' 혹은 ''while'' 블록 내에서만 사용할 수 있습니다
inspection.message.method=메서드
inspection.message.method.has.but.declaration.in.trait.has=메서드 ''{0}''에는 {1} {2}이(가) 있지만 특성 ''{3}''의 선언에는 {4}이(가) 있습니다
inspection.message.method.has.declaration.in.impl.but.not.in.trait=메서드 ''{0}''은(는) 특성이 아닌 ''impl''에 ''{1}'' 선언이 있습니다
inspection.message.method.has.declaration.in.trait.but.not.in.impl=메서드 ''{0}''은(는) ''impl''이 아닌 특성에 ''{1}'' 선언이 있습니다
inspection.message.methods.called.usually.take.consider.choosing.less.ambiguous.name=''{0}*{1}''(으)로 명명된 메서드는 주로 {2}을(를) 취합니다. 더 명확한 이름을 고려해 보세요.
inspection.message.mismatched.types=타입 불일치
inspection.message.missing.features=누락된 기능\: {0}
inspection.message.missing.fields.in.initializer.of=`{2}` 이니셜라이저에서 누락된 {0, choice, 0\#필드|1\#필드}\: {1}
inspection.message.missing.lifetime.specifier=누락된 유효기간 지정자
inspection.message.missing.type.for.item=''{0}''의 타입이 누락되었습니다
inspection.message.multiple.attributes=다수의 ''{0}'' 속성
inspection.message.multiple.bounds.can.be.applied.with.plus=다수의 바운드에 '+'를 적용할 수 있습니다
inspection.message.multiple.cfg.predicates.are.specified=여러 개의 술부는 허용되지 않습니다
inspection.message.multiple.default.variants=Multiple defaults declared
inspection.message.multiple.items=다수의 ''{0}'' 항목
inspection.message.multiple.patterns.in.if.let.while.let.are.unstable='if let' 및 'while let' 내에 있는 다수의 패턴이 불안정합니다
inspection.message.must.be.declared.prior.to=''{0} {1}''은(는) ''{2} {3}'' 이전에 선언되어야 합니다
inspection.message.must.be.last.in.argument.list.for.variadic.function='...'은(는) 가변 함수의 마지막 인수여야 합니다
inspection.message.must.have.body=''{0}''에는 본문이 있어야 합니다
inspection.message.must.have.value=''{0}''에는 값이 있어야 합니다
inspection.message.mutable=가변형
inspection.message.name.already.used.for.generic.parameter.in.this.item.s.generic.parameters=이름 ''{0}''은(는) 이 항목에서 제네릭 매개변수로 사용되고 있습니다
inspection.message.name.defined.multiple.times=''{0}''이(가) 여러 번 정의됩니다
inspection.message.named.argument.never.used=명명된 인수가 한 번도 사용되지 않습니다
inspection.message.named.field.expected=기명 필드가 필요합니다
inspection.message.negative.implementations.are.not.unsafe=음의 구현은 안전하지 않습니다
inspection.message.nested.impl.trait.not.allowed=중첩된 'impl Trait'는 허용되지 않습니다
inspection.message.nested.quantification.lifetimes=유효기간의 중첩된 수량화
inspection.message.newer.version.available.for.crate=크레이트 ''{0}''의 새 버전이 있습니다. {1}
inspection.message.no.arguments.were.given=제공된 인수가 없습니다
inspection.message.no.default.declared=No default declared
inspection.message.no.implementation.for=''{0}''의 구현이 없습니다
inspection.message.no.such.field=해당 필드가 없습니다
inspection.message.no.version.matching.found.for.crate=크레이트 ''{1}''에 대해 {0}와(과) 일치하는 버전이 없습니다
inspection.message.non.constant.value.was.used.in.constant.expression=상수 표현식에서 상수가 아닌 값이 사용되었습니다
inspection.message.non.primitive.cast.as=기본이 아닌 형 변환\: `{0}`을(를) `{1}`(으)로
inspection.message.non.string.abi.literal=ABI 리터럴은 문자열이어야 합니다
inspection.message.not.all.trait.items.implemented.missing=일부 특성 항목이 구현되지 않았습니다. 누락\: {0}
inspection.message.not.member.trait={0} ''{1}''은(는) 특성 ''{2}''의 멤버가 아닙니다
inspection.message.only.auto.traits.can.be.used.as.additional.traits.in.trait.object=특성 객체 내에서는 자동 특성만 추가 특성으로 추가될 수 있습니다
inspection.message.only.single.explicit.lifetime.bound.permitted=하나의 명시적 유효기간 바운드만 허용됩니다
inspection.message.only.static.constants.are.allowed.in.extern.blocks='extern' 블록에서는 static 상수만 허용됩니다
inspection.message.only.traits.defined.in.current.crate.can.be.implemented.for.arbitrary.types=현재 크레이트에서 정의된 특성만 임의의 타입에 대해 구현될 수 있습니다
inspection.message.only.u8.can.be.cast.as.char.not=`{0}`은(는) `char`로 형 변환될 수 없습니다(`u8`만 가능)
inspection.message.parameter.expected=매개변수 필요
inspection.message.parameter.never.used=매개변수 ''{0}''이(가) 한 번도 사용되지 않습니다
inspection.message.parenthesized.lifetime.bounds.are.not.supported=소괄호 내의 유효기간 바운드는 지원되지 않습니다
inspection.message.parenthetical.notation.only.stable.when.used.with.fn.family.traits=소괄호 표기는 'fn' 계열의 특성과 사용할 때만 안정적입니다
inspection.message.pattern.does.not.correspond.to.its.declaration.expected.found=''{0}'' 패턴이 해당 선언과 일치하지 않습니다. {1} {2}이(가) 필요하나 {3}이(가) 발견되었습니다
inspection.message.pattern.does.not.mention=''{0}'' 패턴이 {1} {2}을(를) 언급하지 않습니다
inspection.message.patterns.aren.t.allowed.in.foreign.function.declarations=패턴은 외부 함수 선언 내에서 허용되지 않습니다
inspection.message.patterns.aren.t.allowed.in.function.pointer.types=패턴은 함수 포인터 타입 내에서 허용되지 않습니다
inspection.message.patterns.aren.t.allowed.in.functions.without.bodies=패턴은 본문이 없는 함수 내에서 허용되지 않습니다
inspection.message.positional.arguments.cannot.follow.named.arguments=위치 인수는 명명된 인수 앞에 와야 합니다
inspection.message.precise.format.fn.family.traits.type.parameters.subject.to.change='fn' 계열 특성 내에서 타입 매개변수의 정확한 서식은 변경될 수 있습니다
inspection.message.predicate.expression.has.unnecessary.parentheses=술부 표현식에 불필요한 괄호가 있습니다
inspection.message.println.macro.invocation.can.be.simplified='printIn\!' 매크로 호출을 간소화할 수 있습니다
inspection.message.private={0} ''{1}''은(는) private입니다
inspection.message.private.cannot.be.re.exported=''{0}''은(는) private이며 다시 내보낼 수 없습니다
inspection.message.proc.macro.crates.can.export.only.functions='proc-macro' 크레이트는 '\#[proc_macro]', '\#[proc_macro_derive]', 혹은 '\#[proc_macro_attribute]' 속성이 있는 함수만 내보낼 수 있습니다
inspection.message.provided.when.constant.was.expected=상수가 필요한 곳에 {0}이(가) 제공되었습니다
inspection.message.provided.when.lifetime.was.expected=유효기간이 필요한 곳에 {0}이(가) 제공되었습니다
inspection.message.provided.when.type.was.expected=타입이 필요한 곳에 {0}이(가) 제공되었습니다
inspection.message.range.to.patterns.with.are.not.allowed='...'가 있는 range-to 패턴은 허용되지 않습니다
inspection.message.recursion.in.async.fn.requires.boxing=Recursion in an `async` function requires boxing
inspection.message.redundant=불필요한 '\:\:'
inspection.message.redundant.else=불필요한 'else'
inspection.message.repr.inttype.must.be.specified='\#[repr(inttype)]'을 지정해야 합니다
inspection.message.requires.unsafe.impl.declaration.due.to.attribute=''\#[{0}]'' 속성은 ''unsafe impl'' 선언이 필요합니다
inspection.message.reserved.keyword=''{0}''은(는) 예약된 키워드입니다
inspection.message.reserved.keyword.in.edition=''{0}''은(는) Rust {1} 에디션에서 예약된 키워드입니다
inspection.message.reserved.lifetime.name=''{0}''은(는) 예약된 유효기간 이름입니다
inspection.message.rest.expr.without.base.expr=`..` 뒤에는 기본 표현식이 필요합니다
inspection.message.return.can.be.lifted.out=''{0}''에서 ''return'' 키워드를 삭제할 수 있습니다
inspection.message.return.expression.has.unnecessary.parentheses='return' 식에 불필요한 소괄호가 있습니다
inspection.message.return.in.function.whose.return.type.not=반환 타입이 '()'이 아닌 함수에서 'return;'이 사용되고 있습니다
inspection.message.rust.has.no.incdec.operator=Rust에는 ''{0}'' 연산자가 없습니다
inspection.message.self.import.appears.more.than.once.in.list='self' import 문이 목록에 여러 번 표시됩니다
inspection.message.self.import.can.only.appear.in.import.list.with.non.empty.prefix=import 문 목록에서 'self' import 문은 반드시 비어 있지 않은 접두사를 가져야 합니다
inspection.message.self.imports.are.only.allowed.within.list='self' import 문은 '{}' 목록에서만 허용됩니다
inspection.message.self.keyword.was.used.in.static.method='self' 키워드가 static 메서드에서 사용됩니다
inspection.message.self.value.not.available.in.this.context='self' 값은 이 목록에서 사용할 수 없습니다
inspection.message.should.have.body=''{0}''에 본문이 있어야 합니다
inspection.message.should.have.body2=`{0}` must have a body
inspection.message.should.have.case.name.such.as={0} ''{1}''에는 ''{3}'' 동일한 {2} 케이스 이름이 있어야 합니다
inspection.message.specifier.must.be.type.usize=''{0}'' 지정자의 타입은 ''usize''이어야 합니다
inspection.message.start.attribute.can.be.placed.only.on.functions=`\#[start]` 속성은 함수에 표시할 때만 사용할 수 있습니다
inspection.message.statement.expected=구문 필요
inspection.message.static.constant=static 상수 ''{0}''
inspection.message.static.constants.are.not.allowed.in.impl.blocks=static 상수는 'impl' 블록에서 허용되지 않습니다
inspection.message.static.constants.are.not.allowed.in.traits=static 상수는 특성에서 허용되지 않습니다
inspection.message.static.constants.in.extern.blocks.cannot.have.values='extern' 블록이 있는 static 상수에는 값이 없어야 합니다
inspection.message.struct=구조체
inspection.message.suffixed.literals.are.not.allowed.in.attributes=접미사가 있는 리터럴은 속성에서 허용되지 않습니다
inspection.message.suspicious.assignment.did.you.mean.or=의심스러운 대입입니다. ''{0}'' 또는 ''{1}''을(를) 의도하셨나요?
inspection.message.suspicious.else.if.formatting=의심스러운 'else if' 서식
inspection.message.suspicious.if.did.you.mean.else.if=의심스러운 'if'입니다. 'else if'를 의도하셨나요?
inspection.message.syntax.deprecated.use.for.exclusive.range.or.for.inclusive.range='...' 구문은 더 이상 사용되지 않습니다. 배타적인 범위에는 '..'를, 포괄적인 범위에는 '..\='를 사용하세요
inspection.message.there.are.arguments=인수가 {0}개 있습니다
inspection.message.there.argument=인수가 1개 있습니다
inspection.message.there.no.argument.named=이름이 ''{0}''인 인수가 없습니다
inspection.message.this.feature.only.available.in.edition=이 기능은 Rust {0} 에디션에서만 사용할 수 있습니다
inspection.message.this.function.takes.choice.at.least.but.choice.was.were.supplied=이 함수는 {0, choice, 0\# 최소|1\#} {1}개의 {2}을(를) 취하지만 {3}개의 {4} {5, choice, 0\#이(가)|1\#이(가)} 입력되었습니다
inspection.message.trait.bound.not.satisfied=''{0}\: {1}'' 특성 바운드가 충족되지 않았습니다
inspection.message.trait.copy.may.not.be.implemented.for.this.type=Trait `Copy` cannot be implemented for this type
inspection.message.trait.functions.cannot.be.declared.const=const 선언은 특성 함수에서 허용되지 않습니다
inspection.message.trait.not.implemented=특성 ''{0}''이(가) ''{1}''에 대해 구현되지 않았습니다
inspection.message.trait.objects.must.include.dyn.keyword=특성 객체는 'dyn' 키워드를 포함해야 합니다
inspection.message.trait.objects.without.explicit.dyn.are.deprecated='dyn' 키워드가 없는 특성 객체는 더 이상 사용되지 않습니다
inspection.message.trait.requires.unsafe.impl.declaration=특성 ''{0}''에는 ''unsafe impl'' 선언이 필요합니다
inspection.message.try.macro.can.be.replaced.with.operator='try\!' 매크로는 '?' 연산자로 바꿀 수 있습니다
inspection.message.tuple.field.expected=튜플 필드가 필요합니다
inspection.message.tuple.struct=튜플 구조체
inspection.message.type=타입
inspection.message.type.0=타입 ''{0}''
inspection.message.type.cannot.be.dereferenced=타입 ''{0}''은(는) 역참조될 수 없습니다
inspection.message.type.cant.be.indexed.by=타입 ''{0}''은(는) ''{1}''(으)로 색인화할 수 없습니다
inspection.message.type.mismatch=타입 불일치 해결 중 `{0}`
inspection.message.type.parameter.has.more.than.one.relaxed.default.bound.only.one.supported=타입 매개변수에 완화된 디폴트 바운드가 여러 개 있습니다. 하나의 바운드만 지원됩니다
inspection.message.type.parameters.with.default.must.be.trailing=디폴트 타입의 매개변수는 끝에 위치해야 합니다
inspection.message.type.placeholder.not.allowed.within.types.on.item.signatures=타입 자리표시자 `_`는 아이템의 시그니처에 사용할 수 없습니다
inspection.message.type2=타입
inspection.message.unclosed=닫히지 않은 {0}
inspection.message.unexpected=예기치 않은 '...'
inspection.message.unexpected2=예기치 않은 '..\='
inspection.message.unexpected3=예기치 않은 '..'
inspection.message.union.cannot.be.tuple.like=공용체는 튜플과 비슷할 수 없습니다
inspection.message.union.expressions.should.have.exactly.one.field=공용체 표현식은 정확히 하나의 필드만 가질 수 있습니다
inspection.message.union.patterns.requires.field=공용체 패턴에는 필드가 필요합니다
inspection.message.union.patterns.should.have.exactly.one.field=공용체 패턴은 정확히 하나의 필드만 가질 수 있습니다
inspection.message.unknown.format.trait=알 수 없는 서식의 특성 ''{0}''
inspection.message.unknown.meta.item=알 수 없는 메타 항목 ''{0}''
inspection.message.unlabeled.inside.labeled.block=라벨 지정된 블록 내 라벨 지정되지 않은 ''{0}''
inspection.message.unnecessary.cast=불필요한 형 변환
inspection.message.unnecessary.qualification=경로 접두사는 불필요합니다
inspection.message.unnecessary.visibility.qualifier=불필요한 가시성 한정자
inspection.message.unreachable.code=도달할 수 없는 코드
inspection.message.unreachable.pattern=도달할 수 없는 패턴
inspection.message.unrecognized.representation=인식되지 않는 표현형 ''{0}''
inspection.message.unresolved.associated.item.for.struct=구조체 `{1}`의 현재 범위에서 연결된 항목 `{0}`을(를) 찾을 수 없습니다
inspection.message.unresolved.function.name=이 범위에서 함수 `{0}`을(를) 찾을 수 없습니다
inspection.message.unresolved.function.or.associated.item=구조체 `{1}`의 현재 범위에서 함수 혹은 연결된 항목 `{0}`을(를) 찾을 수 없습니다
inspection.message.unresolved.import=해결되지 않은 임포트\: `{0}`
inspection.message.unresolved.method=구조체 `{1}`의 현재 범위에서 메서드 `{0}`을(를) 찾을 수 없습니다
inspection.message.unresolved.reference=해결되지 않은 참조\: ''{0}''
inspection.message.unresolved.reference2=해결되지 않은 참조
inspection.message.unresolved.struct.variant.or.union=이 범위에서 구조체, 변형 혹은 공용체 타입 `{0}`을(를) 찾을 수 없습니다
inspection.message.unresolved.trait=이 범위에서 특성 `{0}`을(를) 찾을 수 없습니다
inspection.message.unresolved.type=이 범위에서 타입 `{0}`을(를) 찾을 수 없습니다
inspection.message.unresolved.value.name=이 범위에서 값 `{0}`을(를) 찾을 수 없습니다
inspection.message.unresolved.variant.or.associated.item=열거형 `{1}`의 현재 범위에서 변형 혹은 연결된 항목 `{0}`을(를) 찾을 수 없습니다
inspection.message.unsafe.dereference.raw.pointer=원시 포인터를 역참조하는 것은 안전하지 않습니다
inspection.message.unstable=''{0}''은(는) 불안정합니다{1}
inspection.message.unused.attribute=사용되지 않는 속성
inspection.message.unused.import=사용되지 않는 import 문\: ''{0}''
inspection.message.unused.mut=사용되지 않는 'mut'
inspection.message.use.moved.value=값이 이동된 후에 사용되었습니다
inspection.message.use.possibly.uninitialized.variable=변수가 초기화되지 않았을 수 있습니다
inspection.message.use.static.unsafe.requires.unsafe.function.or.block=static {0}은(는) ''unsafe'' 블록 혹은 함수 내에서만 사용할 수 있습니다
inspection.message.use.undeclared.label=선언되지 않은 라벨 ''{0}''
inspection.message.use.undeclared.lifetime.name=선언되지 않은 유효기간 이름 ''{0}''
inspection.message.use.unreachable.label=도달할 수 없는 라벨 ''{0}''
inspection.message.use.unsafe.requires.unsafe.function.or.block=''{0}\!''은(는) ''unsafe'' 블록 혹은 함수 내에서만 사용할 수 있습니다
inspection.message.use.unsafe.static=안전하지 않은 {0} static 항목이 사용되었습니다
inspection.message.value.associated.must.be.specified=연관된 {0} {1}의 값이 제공되어야 합니다
inspection.message.value.was.moved.out.while.it.was.still.borrowed=값이 아직 사용 중일 때 이동되었습니다
inspection.message.variable.never.used=변수 ''{0}''은(는) 전혀 사용되지 않습니다
inspection.message.visibilities.can.only.be.restricted.to.ancestor.modules=가시성 제한은 상위 모듈로 한정됩니다
inspection.message.with.no.label.in.condition.while.loop=''while'' 루프 조건에 라벨이 없는 ''{0}''이(가) 있습니다
inspection.message.with.suffix.invalid=접미사가 있는 ''{0}''은(는) 잘못되었습니다
inspection.message.wrong.meta.list.delimiters=잘못된 메타 리스트 구분자
inspection.message.wrong.number.arguments.expected.found={0} 인수의 개수가 잘못되었습니다. 필요\: {1}, 발견\: {2}
inspection.message.wrong.number.lifetime.arguments.expected.found=유효기간 인수의 개수가 잘못되었습니다. 필요\: {0}, 수신\: {1}
inspection.message.x.could.be.misinterpreted.as.pre.decrement.but.effectively.no.op='--x'는 선행 감소 표현식으로 잘못 해석될 수도 있으나 실질적으로는 연산이 일어나지 않습니다
inspection.missing.features.display.name=누락된 기능
inspection.new.crate.version.available.display.name=새 크레이트 버전 사용 가능
inspection.rs.approx.constant.display.name=근사 상수
inspection.rs.argument.naming.display.name=인수 이름 지정 규칙
inspection.rs.array.out.of.bounds.display.name=범위를 벗어난 배열
inspection.rs.assert.equal.display.name=상등 어설션 단순화 가능
inspection.rs.assign.to.immutable.display.name=불변형이 재대입됨
inspection.rs.assoc.type.naming.display.name=연관 타입 이름 지정 규칙
inspection.rs.async.main.function.display.name=진입점이 async임
inspection.rs.attempt.to.call.not.function.display.name=함수가 아닌 것을 호출하려고 함
inspection.rs.attr.without.parentheses.display.name=소괄호가 없는 속성
inspection.rs.attribute.error=속성 오류
inspection.rs.bare.trait.objects.display.name=특성 객체에 'dyn' 누락
inspection.rs.borrow.checker.display.name=빌림 검사기
inspection.rs.c.string.pointer.display.name=안전하지 않은 CString 포인터
inspection.rs.cannot.impl.for.dyn.auto.trait=Inherent `impl` for dyn auto trait
inspection.rs.cast.to.bool.display.name=부울로 형 변환
inspection.rs.compile.error.macro.display.name='compile_error\!' 매크로
inspection.rs.compiler.feature.is.unavailable=컴파일러 기능을 사용할 수 없습니다
inspection.rs.const.naming.display.name=상수 이름 지정 규칙
inspection.rs.const.refer.static.display.name=상수는 static을 참조할 수 없음
inspection.rs.constant.condition.if.display.name='if' 조건이 상수임
inspection.rs.control.flow.expr.in.while.condition.without.loop=`break` or `continue` with no label in the condition of a `while` loop
inspection.rs.copy.and.drop.impl=Both `Copy` and `Drop` implemented
inspection.rs.crate.name.display.name=잘못된 크레이트 이름
inspection.rs.dangling.else.display.name=불완전한 'else'
inspection.rs.deprecation.display.name=지원 중단된 요소
inspection.rs.derive.on.unsupported.item='derive'는 구조체, 열거형 및 공용체에만 적용할 수 있습니다
inspection.rs.detached.file.display.name=연결 해제된 파일
inspection.rs.double.must.use.display.name=불필요한 '\#[must_use]'
inspection.rs.double.neg.display.name=이중 부정
inspection.rs.drop.copy.type.display.name=`Copy` 타입이 삭제됨
inspection.rs.drop.ref.display.name=참조가 삭제됨
inspection.rs.duplicate.defnition=중복 정의
inspection.rs.duplicated.macro.pattern.name=중복 매크로 패턴
inspection.rs.duplicated.trait.method.binding.display.name=중복되는 특성 메서드 매개변수 이름
inspection.rs.enum.naming.display.name=열거형 이름 지정 규칙
inspection.rs.enum.repr.int.is.required=`\#[repr(inttype)]` must be specified for enum
inspection.rs.enum.variant.naming.display.name=열거형 배리언트 이름 지정 규칙
inspection.rs.equality.trait.members.display.name=Derived trait not implemented
inspection.rs.experimental.checks.display.name=실험적 검사
inspection.rs.experimental.trait.obligations.display.name=타입이 특성을 구현하지 않습니다(실험적)
inspection.rs.experimental.type.check.display.name=타입 체커(실험적)
inspection.rs.external.linter.display.name=외부 Linter
inspection.rs.field.init.shorthand.display.name=축약형이 아닌 필드 초기화
inspection.rs.field.naming.display.name=필드 이름 지정 규칙
inspection.rs.field.without.type=Missing struct field type
inspection.rs.format.macro.errors=Format macro error
inspection.rs.function.naming.display.name=함수 이름 지정 규칙
inspection.rs.function.parameters.are.sized=Parameter type with unknown size
inspection.rs.generic.default.param.cannot.use.forward=Forward-declared identifier for parameter with default value
inspection.rs.impl.copy.for.wrong.type=Invalid `Copy` implementation
inspection.rs.impl.drop.for.non.adt=Invalid `Drop` implementation
inspection.rs.impl.for.non.adt.error=내재적인 `impl` 블록은 항목에 허용되지 않습니다
inspection.rs.incorrect.function.argument.count=Wrong number of arguments
inspection.rs.incorrect.type.of.index.expression.display.name=색인 표현식에 잘못된 타입이 있음
inspection.rs.incorrectly.placed.inline.attr=`\#[inline]` Attribute can only be applied to a function or closure
inspection.rs.inherent.impl.different.crate=내재적인 `impl`이 타입을 포함하는 크레이트 외부에 정의되었습니다
inspection.rs.invalid.brea.continue.usage=Invalid 'break' or 'continue'
inspection.rs.invalid.label.name=잘못된 라벨 이름
inspection.rs.invalid.lifetime.name=Invalid lifetime name
inspection.rs.invalid.macro.call.display.name=잘못된 매크로 호출
inspection.rs.invalid.macro.variable.type.display.name=유효하지 않은 매크로 변수 타입
inspection.rs.invalid.start.attribute=잘못된 `\#[start]` 속성
inspection.rs.invalid.struct.fields=구조체 내의 잘못된 필드
inspection.rs.lifetime.naming.display.name=유효기간 이름 지정 규칙
inspection.rs.lift.display.name='return' 제거 가능
inspection.rs.literal.out.of.range.display.name=리터럴 범위 초과
inspection.rs.liveness.display.name=활동성 분석
inspection.rs.loop.only.keyword.outside.of.loop=`break` and `continue` can only be used inside `loop` and `while` blocks
inspection.rs.macro.naming.display.name=매크로 이름 지정 규칙
inspection.rs.main.function.not.found.display.name=메인 함수를 찾을 수 없음
inspection.rs.method.naming.display.name=메서드 이름 지정 규칙
inspection.rs.missing.else.display.name='else' 누락
inspection.rs.module.naming.display.name=모듈 이름 지정 규칙
inspection.rs.needless.lifetimes.display.name=불필요한 유효기간 어노테이션
inspection.rs.non.exhaustive.match.display.name=완전하지 않은 일치
inspection.rs.non.shorthand.field.patterns.display.name=비축약 필드 패턴
inspection.rs.nonexistent.field.access=Non-existent field access
inspection.rs.path.statements.display.name=잘못된 경로 구문
inspection.rs.public.items.in.proc.macro.crate.inspection.display.name=proc macro crate 내의 public 항목
inspection.rs.reassign.immutable.display.name=불변 변수가 재대입됨
inspection.rs.recursion.in.async.function=No boxing for async recursion
inspection.rs.redundant.else.display.name=불필요한 'else'
inspection.rs.redundant.semicolons.display.name=불필요한 세미콜론
inspection.rs.reference.is.not.public=Invalid private field/method access
inspection.rs.replace.cast.with.suffix.display.name=형 변환은 리터럴 접미사로 바꿀 수 있습니다
inspection.rs.return.must.have.value=`return` must have a value
inspection.rs.self.convention.display.name=Self 규칙
inspection.rs.simplify.boolean.expression.display.name=bool 표현식을 단순화할 수 있음
inspection.rs.simplify.print.display.name='printIn\!' 매크로를 단순화할 수 있음
inspection.rs.sleep.in.async.context=블로킹 'sleep' 함수는 'async' 컨텍스트에서 사용할 수 없습니다
inspection.rs.sort.impl.trait.members.display.name='impl' 멤버 순서가 특성과 다릅니다
inspection.rs.static.const.naming.display.name=static 상수 이름 지정 규칙
inspection.rs.struct.naming.display.name=구조체 이름 지정 규칙
inspection.rs.struct.rest.without.base.expression.name=`..` 뒤에는 기본 기본 표현식이 필요
inspection.rs.super.trait.is.not.implemented=Supertrait is not implemented
inspection.rs.suspicious.assignment.display.name=의심스러운 대입
inspection.rs.test.failed.line.display.name=테스트에서 실패한 줄
inspection.rs.thread.rng.gen.can.be.replaced.with.random='thread_rng().gen()'은 'random()'으로 바꿀 수 있습니다
inspection.rs.trait.implementation.display.name=특성 구현 문제
inspection.rs.trait.naming.display.name=특성 이름 지정 규칙
inspection.rs.trait.obligations.display.name=타입이 특성을 구현하지 않습니다
inspection.rs.traits.defined.in.current.crate=외부 특성 구현
inspection.rs.try.macro.display.name='try\!' 매크로 사용
inspection.rs.type.alias.naming.display.name=타입 별칭 이름 지정 규칙
inspection.rs.type.check.display.name=타입 검사기
inspection.rs.type.mismatch.display.name=타입이 특성의 연결된 타입과 불일치합니다.
inspection.rs.type.parameter.naming.display.name=타입 매개변수 이름 지정 규칙
inspection.rs.type.placeholder.is.forbidden=타입 자리표시자가 아이템 시그니처에 사용되었습니다
inspection.rs.union.expression.fields.count.display.name=공용체 식 필드 카운트
inspection.rs.unknown.crate.types.display.name=알 수 없는 크레이트 타입
inspection.rs.unlabeled.control.flow.expr=Unlabeled `continue` or `break` inside of a labeled block
inspection.rs.unnecessary.cast.display.name=불필요한 형 변환
inspection.rs.unnecessary.parentheses.inspection.display.name=불필요한 소괄호
inspection.rs.unnecessary.qualifications.display.name=불필요한 경로 접미사
inspection.rs.unreachable.code.display.name=도달할 수 없는 코드
inspection.rs.unreachable.patterns.display.name=도달할 수 없는 패턴
inspection.rs.unresolved.method.display.name=해결되지 않은 메서드
inspection.rs.unresolved.method.experimental.display.name=해결되지 않은 메서드(실험적)
inspection.rs.unresolved.path.display.name=해결되지 않은 경로
inspection.rs.unresolved.path.experimental.display.name=해결되지 않은 경로(실험적)
inspection.rs.unresolved.reference.display.name=해결되지 않은 참조
inspection.rs.unsupported.binary.operator.display.name=지원되지 않는 이항 연산자
inspection.rs.unused.import.display.name=사용되지 않는 import
inspection.rs.unused.labels.display.name=사용되지 않는 라벨
inspection.rs.unused.must.use.display.name=사용되지 않는 '\#[must_use]'
inspection.rs.unused.mut.display.name=사용되지 않는 'mut' 제어자
inspection.rs.variable.naming.display.name=변수 이름 지정 규칙
inspection.rs.while.true.loop.display.name='while true'는 'loop'로 바꿀 수 있음
inspection.rs.wrong.assoc.type.arguments.display.name=잘못 연관된 타입 인수
inspection.rs.wrong.generic.arguments.number.display.name=잘못된 제네릭 인수 개수
inspection.rs.wrong.generic.arguments.order.display.name=잘못 정렬된 제네릭 인수
inspection.rs.wrong.generic.parameters.number.display.name=타입 혹은 const 매개변수의 잘못된 개수
inspection.rs.wrong.lifetime.parameters.number.display.name=유효기간 매개변수의 잘못된 개수
inspection.toml.duplicate.table.header=중복 테이블 헤더
inspection.toml.edition.must.be.in.list=에디션은 {0} 중 하나여야 합니다
inspection.toml.invalid.category=잘못된 패키지 카테고리
inspection.toml.invalid.package.name=잘못된 패키지 이름
inspection.toml.json.schema=Doesn't conform to schema
inspection.toml.string.literal.expected=문자열 리터럴이 필요합니다
inspection.toml.too.many.categories=crates.io는 최대 5개의 카테고리를 허용합니다
inspection.toml.unclosed.string=닫히지 않은 문자열 리터럴
intention.Rust.ToggleFeatureIntention.disable=기능 ''{0}'' 비활성화
intention.Rust.ToggleFeatureIntention.enable=기능 ''{0}'' 활성화
intention.Rust.ToggleFeatureIntention.family.name=기능 상태 전환
intention.family.name.add.default.meta.item=Add \#[default] to first variant
intention.family.name.add.feature.attribute='\#\![feature]' 속성 추가
intention.family.name.add.fn.main='fn main()' 추가
intention.family.name.add.import=import 문 추가
intention.family.name.add.import.for.path.in.pattern=패턴 내 경로에 대한 import 문 추가
intention.family.name.add.label=라벨 추가
intention.family.name.add.method.call=표현식에 대한 메서드 호출
intention.family.name.add.missing.generic.arguments=누락된 제네릭 인수 추가
intention.family.name.add.parentheses=소괄호 추가
intention.family.name.add.safe.cast=안전한 형 변환 추가
intention.family.name.add.self.to={0}에 ''self'' 추가
intention.family.name.add.to.dependencies=종속성에 크레이트 추가
intention.family.name.add.type=타입 추가
intention.family.name.apply.suggested.replacement.made.by.external.linter=외부 Linter가 제안한 대로 바꾸기
intention.family.name.change.function.signature=함수 시그니처 변경
intention.family.name.change.item.visibility=항목 가시성 변경
intention.family.name.change.name.element=요소 이름 변경
intention.family.name.change.repr.attribute='repr' 속성 변경
intention.family.name.change.return.type=반환 타입 변경
intention.family.name.compare.with.zero=0과 비교
intention.family.name.convert.not.b.cfg.pattern.to.all.not.not.b='not(a, b)' cfg 패턴을 'all(not(a), not(b))'로 변환
intention.family.name.convert.to.loop=루프로 변환
intention.family.name.convert.to.sized.type=크기가 지정된 타입으로 변환
intention.family.name.convert.to.type=타입으로 변환
intention.family.name.convert.to.unsuffixed.integer=접미사가 없는 정수로 변환
intention.family.name.convert.type=선언의 타입 변환
intention.family.name.convert.type.local.variable=지역 변수 타입 변환
intention.family.name.create.enum.variant=열거형 배리언트 생성
intention.family.name.create.function=함수 생성
intention.family.name.create.lifetime.parameter=유효기간 매개변수 생성
intention.family.name.create.module.file=모듈 파일 생성
intention.family.name.create.struct=구조체 생성
intention.family.name.create.tuple.struct=튜플 구조체 생성
intention.family.name.demorgan.s.law=드 모르간의 법칙
intention.family.name.derive.trait=특성 파생
intention.family.name.do.not.show.again=다시 표시 안 함
intention.family.name.enable.features=기능 활성화
intention.family.name.extract.inline.module.structure=인라인 모듈 구조 추출
intention.family.name.import=Import 문
intention.family.name.import.item.from.crate=외부 크레이트에서 항목 가져오기
intention.family.name.lift.return='return' 제거
intention.family.name.make.async=async로 만들기
intention.family.name.make.mutable=가변으로 만들기
intention.family.name.make.private=private으로 만들기
intention.family.name.make.public=public으로 만들기
intention.family.name.qualify.path=전체 경로 지정
intention.family.name.reload.project=프로젝트 다시 로드
intention.family.name.remove=제거
intention.family.name.remove.bound=바운드 제거
intention.family.name.remove.macro.branch=매크로 브랜치 제거
intention.family.name.remove.parameter=매개변수 제거
intention.family.name.remove.pat.field=패턴 필드 제거
intention.family.name.remove.reference=참조 제거
intention.family.name.remove.return.type=반환 타입 제거
intention.family.name.remove.self.from=''self''를 {0}에서 제거
intention.family.name.remove.struct.literal.field=구조체 리터럴 필드 제거
intention.family.name.remove.unnecessary.cast=불필요한 형 변환 제거
intention.family.name.remove.variable=변수 제거
intention.family.name.rename.element=요소 이름 변경
intention.family.name.rename.label=라벨 이름 변경
intention.family.name.replace.box.with.box.new='box'를 'Box\:\:new'로 바꾸기
intention.family.name.replace.cast.with.literal.suffix=형 변환을 리터럴 접미사로 바꾸기
intention.family.name.replace.fragment.specifier=`{0}`의 조각 지정자를 `{1}`(으)로 변경
intention.family.name.replace.str.index.with.chars.index=&str 색인을 char 색인으로 바꾸기(&S)
intention.family.name.replace.successive.with=연속되는 '_'를 '..'로 바꾸기
intention.family.name.replace.with.block.comment=블록 주석으로 바꾸기
intention.family.name.replace.with.end.line.comment=줄 주석으로 바꾸기
intention.family.name.replace.with.inclusive.range=포괄적인 범위로 바꾸기
intention.family.name.replace.with.predefined.constant=사전 정의된 상수로 바꾸기
intention.family.name.replace.with.thread.local.stable.method.call=스레드 로컬의 안전한 메서드 호출로 대체
intention.family.name.simplify.boolean.expression=bool 표현식 단순화
intention.family.name.specify.return.type=반환 값 지정
intention.family.name.split.if='if' 분할
intention.family.name.substitute.one.text.to.another=텍스트를 다른 텍스트로 바꾸기
intention.family.name.suppress.warnings=경고 억제
intention.family.name.unwrap.enum.or.tuple.struct.constructor.from.expression=표현식에서 열거형 혹은 튜플 구조체 생성자의 래핑 해제
intention.family.name.update.dependency.version=종속성 버전 업데이트
intention.family.name.use.loop='loop' 사용
intention.family.name.use.shorthand.field.pattern=축약 필드 패턴 사용
intention.name.={0}{1}
intention.name.add='..' 추가
intention.name.add.as.parameter.to=''{0}''을(를) ''{1}'' 매개변수로서 {2} ''{3}''에 추가
intention.name.add.async.recursion.attribute='\#[async_recursion]' 속성 추가
intention.name.add.braces.to.lambda.expression=람다 식에 중괄호 추가
intention.name.add.curly.braces=중괄호 추가
intention.name.add.definition.to.trait=멤버 정의를 특성에 추가
intention.name.add.derive.clause='\#[derive]' 속성 추가
intention.name.add.derive.to=''{1}''에 ''\#[derive({0})]'' 추가
intention.name.add.dummy.parameter.name=더미 매개변수 이름 추가
intention.name.add.dyn.keyword.to.trait.object=특성 객체에 'dyn' 키워드 추가
intention.name.add.else.branch.to.this.if.statement='else' 브랜치 추가
intention.name.add.feature=''{0}'' 기능 추가
intention.name.add.field.name=필드 이름 추가
intention.name.add.field.to.struct=타입 ''{1}''에 필드 ''{0}'' 추가
intention.name.add.format.argument=서식 인수 ''{0}'' 추가
intention.name.add.format.string=서식 문자열 추가
intention.name.add.format.string.argument=서식 문자열 인수 추가
intention.name.add.impl.before.trait=`impl` 키워드 추가
intention.name.add.impl.block='impl' 블록 추가
intention.name.add.import.for=''{0}''의 import 문 추가
intention.name.add.method.call=''{1}''에 대한 ''{0}'' 호출
intention.name.add.missing=누락된 {0} 추가
intention.name.add.missing.associated.types=누락된 연관 타입 추가
intention.name.add.missing.fields=누락된 필드 추가
intention.name.add.parentheses.to=''{0}''에 소괄호 추가
intention.name.add.pattern='_' 패턴 추가
intention.name.add.remaining.patterns=남은 패턴 추가
intention.name.add.required.features=`{0}`의 필수 필드 추가
intention.name.add.required.features.family.name=필수 기능 추가
intention.name.add.safe.cast.to={0}에 안전한 형 변환 추가
intention.name.add.self=Add `Self\:\:`
intention.name.add.self.to.function=함수 정의에 'self' 추가
intention.name.add.to.dependencies=종속성에 ''{0}'' 추가
intention.name.add.to.owned=`.to_owned()` 추가
intention.name.add.tokio.main='\#[tokio\:\:main]' 추가
intention.name.add.turbofish.operator=터보피시 구문 추가
intention.name.add.type=타입 ''{0}'' 추가
intention.name.add.unsafe.to={0}에 ''unsafe'' 추가
intention.name.append.semicolon=세미콜론 추가
intention.name.apply.same.member.order=특성에서와 동일한 멤버 순서 적용
intention.name.attach.file.to={0}에 파일 연결
intention.name.b.b=<b>{0}</b>
intention.name.b.b2=<b>{0}</b>
intention.name.block=블록
intention.name.change.equals.op.to.eq=`\=\=`를 `.eq(...)`로 변경
intention.name.change.field.lookup.to.method.call=필드 액세스 표현식을 메서드 호출로 바꾸기
intention.name.change.format.parameter.to=서식 매개변수를 '{\:?}'로 변경
intention.name.change.iter.to.iter.mut=for 루프 내에서 `.iter()`를 `.iter_mut()`로 변경
intention.name.change.match.expr.to.method.call=match 식을 메서드 호출로 변환
intention.name.change.reference.to.mutable=참조를 가변으로 변경
intention.name.change.representation.enum.to.repr=열거형 ''{0}''의 표현을 ''\#[repr({1})]''(으)로 변경
intention.name.change.return.type.to=반환 타입 {0} {1}을(를) ''{2}''(으)로 변경
intention.name.change.to=''{0}''(으)로 변경
intention.name.change.to.else.if='else if'로 변경
intention.name.change.to1=''{0}''(으)로 변경
intention.name.change.to3=''{0}''(으)로 변경
intention.name.change.toml.literal.to.array=리터럴을 배열로 변환
intention.name.change.try.to='try\!'를 '?'로 변경
intention.name.change.type.to={1} {2} 내에 있는 {0}의 타입을 ''{3}''(으)로 변경
intention.name.change.type.to2={0}의 타입을 ''{1}''(으)로 변경
intention.name.convert.closure.to.function=클로저를 함수로 변환
intention.name.convert.function.to.closure=함수를 클로저로 변환
intention.name.convert.if.let.statement.to.match='if let' 문을 'match'로 변환
intention.name.convert.impl.trait.to.type.parameter='impl Trait'를 타입 매개변수로 변환
intention.name.convert.match.statement.to.if.let='match' 문을 'if let'으로 변환
intention.name.convert.to=''{0}''(으)로 변환
intention.name.convert.to.box='Box'로 변환
intention.name.convert.to.by.removing.refs=참조를 제거하고 `{0}`(으)로 변환
intention.name.convert.to.display.implementation=`Display` 구현으로 변환
intention.name.convert.to.macro=''{0}\!''(으)로 변환
intention.name.convert.to.method.call=메서드 호출로 변환
intention.name.convert.to.reference=참조로 변환
intention.name.convert.to.struct=구조체로 변환
intention.name.convert.to.tuple=튜플로 변환
intention.name.convert.to.ufcs=UFCS로 변환
intention.name.convert.to.using={1}을(를) 사용하여 {0}(으)로 변환
intention.name.create.associated.function=연관 함수 ''{0}\:\:{1}'' 생성
intention.name.create.associated.function.self=연관 함수 ''Self\:\:{0}'' 생성
intention.name.create.enum.variant=열거형 배리언트 ''{0}'' 생성
intention.name.create.field=필드 생성
intention.name.create.function=함수 ''{0}'' 생성
intention.name.create.method=메서드 ''{0}'' 생성
intention.name.create.module.file=모듈 파일 ''{0}'' 생성
intention.name.create.struct=구조체 ''{0}'' 생성
intention.name.create.tuple.struct=튜플 구조체 ''{0}'' 생성
intention.name.demorgan.s.law.replace.with='||'를 '&&'로 바꾸기(드 모르간의 법칙)
intention.name.demorgan.s.law.replace.with2='||'를 '&&'로 바꾸기(드 모르간의 법칙)
intention.name.derive.copy.trait=Copy 특성 파생
intention.name.derive.debug.and.replace.display.to.debug=`{0}`의 `Debug`를 파생하고 `'{}'`를 `'{\:?}'`로 바꾸기
intention.name.elide.lifetimes=유효기간 생략
intention.name.enclose.expression.in.braces=표현식을 중괄호로 감싸기
intention.name.escape.keyword=키워드 이스케이프
intention.name.escape.reserved.keyword=예약어 이스케이프
intention.name.expand.dependency.specification=종속성 사양 확장
intention.name.explain.move.error=Explain
intention.name.external.linter=외부 Linter\: {0}
intention.name.extract.enum.variant=열거형 배리언트 추출
intention.name.extract.inline.module=인라인 모듈 추출
intention.name.fill.missing.arguments=누락된 인수 채우기
intention.name.fix.visibility.restriction=가시성 제한 수정
intention.name.flatten.use.statements='use' 문 평면화
intention.name.flip=''{0}'' 반전
intention.name.flip.binary.expression=이항식 반전
intention.name.flip.changes.semantics=''{0}'' 반전(의미가 변경됩니다)
intention.name.flip.to=''{0}''을(를) ''{1}''(으)로 반전
intention.name.function=함수
intention.name.generate.documentation.stub=문서 스텁 생성
intention.name.html.change.signature.to.html=<html>시그너처를 ''{0}({1})''(으)로 변경</html>
intention.name.impl=impl
intention.name.implement.display.trait.for=''{0}''의 ''Display'' 특성 구현
intention.name.implement.members=멤버 구현
intention.name.implement.members.hint.text=<html><body><a href\="action">{0}의 누락된 멤버 구현</a>? \\&nbsp;\\&nbsp;<span style\="color\:\#{2}">{1}</span></body></html>
intention.name.implement.missing.supertrait.s=누락된 상위 특성 구현
intention.name.implement.operator.trait=연산자 특성 구현
intention.name.implement.trait=특성 구현
intention.name.implement.trait2=''{0}'' 특성 구현
intention.name.import=import 문
intention.name.import.item.from.crate=크레이트 `{1}`에서 `{0}` 가져오기
intention.name.initialize.with.default.value=디폴트 값으로 초기화
intention.name.install.tokio.and.add.main=종속성에 'tokio'를 추가하고 메인 함수에 '\#[tokio\:\:main]' 어노테이션 추가
intention.name.introduce.local.variable=지역 변수 삽입
intention.name.invert.if.condition='if' 조건 반전
intention.name.join.else.if='else if' 결합
intention.name.lambda=람다
intention.name.lift.return.out=''{0}''에서 ''return'' 제거
intention.name.make={0}을(를) {1}(으)로 만들기
intention.name.make.async={0}을(를) async로 만들기
intention.name.make.mutable=''{0}''을(를) 가변으로 만들기
intention.name.make.private=''{0}''을(를) private로 설정
intention.name.make.public=''{0}''을(를) public으로 만들기
intention.name.merge.with.nested.if.expression=중첩 'if' 식과 병합
intention.name.method=메서드
intention.name.method.not.a.field=메서드 {0}을(를) 타입 `{1}`의 필드로서 액세스하려고 시도
intention.name.move.guard.inside.match.arm=guard를 match arm 내부로 이동
intention.name.move.to.type.reference='\\&'을(를) 타입 참조로 이동
intention.name.move.type.constraint.to.parameter.list=타입 제약을 매개변수 목록으로 이동
intention.name.move.type.constraint.to.where.clause=타입 제약을 'where' 절로 이동
intention.name.nest.use.statements='use' 문 중첩
intention.name.put.arguments.on.one.line=인수를 한 줄에 정렬
intention.name.put.arguments.on.separate.lines=인수를 여러 줄에 정렬
intention.name.put.fields.on.one.line=필드를 한 줄에 정렬
intention.name.put.fields.on.separate.lines=필드를 여러 줄에 정렬
intention.name.put.parameters.on.one.line=매개변수를 한 줄에 정렬
intention.name.put.parameters.on.separate.lines=매개변수를 여러 줄에 정렬
intention.name.put.variants.on.one.line=배리언트를 한 줄에 정렬
intention.name.put.variants.on.separate.lines=배리언트를 여러 줄에 정렬
intention.name.qualify.path.to=''{0}''의 전체 경로 지정
intention.name.recursively.add.missing.fields=누락된 필드를 재귀적으로 추가
intention.name.recursively.replace.with.actual.fields='..'를 실제 필드로 재귀적으로 바꾸기
intention.name.remove=''{0}'' 제거
intention.name.remove.as=''as {0}'' 제거
intention.name.remove.bound=''{0}'' 바운드 제거
intention.name.remove.braces.from.single.expression=식에서 중괄호 제거
intention.name.remove.braces.from.single.expression.statement=식 구문의 중괄호 제거
intention.name.remove.curly.braces=중괄호를 제거합니다.
intention.name.remove.dbg='dbg\!' 제거
intention.name.remove.drop.and.keep.expression=`drop`을 제거하고 표현식 유지
intention.name.remove.element.semicolon=세미콜론
intention.name.remove.else='else' 제거
intention.name.remove.field=필드 `{0}` 제거
intention.name.remove.format.parameter=서식 인수 제거
intention.name.remove.from={1} ''{2}''에서 ''{0}'' 제거
intention.name.remove.if.expression='if' 표현 제거
intention.name.remove.parameter=매개변수 ''{0}'' 제거
intention.name.remove.parentheses.from.expression=소괄호를 표현식에서 제거
intention.name.remove.quotes=따옴표 제거
intention.name.remove.redundant.arguments=중복 인수 제거
intention.name.remove.redundant.associated.type=불필요한 연관 타입 제거
intention.name.remove.redundant.generic.arguments=불필요한 제네릭 인수 제거
intention.name.remove.suffix=접미사 제거
intention.name.remove.unary.operator.add.rev=단항 연산자 `-`를 제거하고 `.rev()` 추가
intention.name.remove.unnecessary.argument=불필요한 인수 제거
intention.name.remove.unnecessary.path.prefix=불필요한 경로 접두사 제거
intention.name.remove.unreachable.code=도달할 수 없는 코드 제거
intention.name.remove.unreachable.match.arm=도달할 수 없는 match arm 제거
intention.name.remove.unreachable.pattern=도달할 수 없는 패턴 제거
intention.name.remove.unused.argument=사용되지 않는 인수 제거
intention.name.remove.unused.import=사용되지 않는 Import 제거
intention.name.remove.variable=변수 ''{0}'' 제거
intention.name.remove2={0} 제거
intention.name.rename.to=''{0}''(으)로 이름 변경
intention.name.replace.brackets=대괄호 바꾸기
intention.name.replace.comma.with.plus.sign=쉼표를 더하기 기호로 바꾸기
intention.name.replace.deprecated.element.with.suggestion=지원 중단된 요소를 제안된 요소로 바꾸기
intention.name.replace.inc.dec.operator=''{0}''(으)로 바꾸기
intention.name.replace.unwrap.with.match='.unwrap()'을 'match'로 바꾸기
intention.name.replace.unwrap.with.try='.unwrap()'을 'try'로 바꾸기
intention.name.replace.with=`{0}`을(를) `{1}`(으)로 바꾸기
intention.name.replace.with.0.1=''{0}{1}''(으)로 바꾸기
intention.name.replace.with.1=''{0}''(으)로 바꾸기
intention.name.replace.with.actual.fields='..'를 실제 필드로 바꾸기
intention.name.replace.with.and.import=''{0}''(으)로 바꾸고 ''{1}''에서 임포트
intention.name.replace.with.parse.call=`.parse` 호출로 바꾸기
intention.name.replace.with.std.mem.drop='std\:\:mem\:\:drop'으로 바꾸기
intention.name.replace.with.to.string=`{0}.to_string()`으로 바꾸기
intention.name.replace.with2=''{0}''(으)로 바꾸기
intention.name.set.reference.immutable=참조를 불변으로 만들기
intention.name.set.reference.mutable=참조를 가변으로 만들기
intention.name.show.recursive.macro.expansion=재귀 매크로 확장 표시
intention.name.show.result.macro.expansion.cargo.expand=확장된 매크로 표시(cargo expand)
intention.name.show.single.step.macro.expansion=한 단계 매크로 확장 표시
intention.name.simplify.boolean.expression=bool 표현식 단순화
intention.name.simplify.dependency.specification=종속성 사양 단순화
intention.name.specify.type=타입 지정
intention.name.specify.type.explicitly=타입을 명시적으로 지정
intention.name.split.into.if.s=2개의 if로 분할
intention.name.substitute=대체
intention.name.substitute.type.alias=타입 별칭 대체
intention.name.suppress.all.inspections.for.item=항목에 대한 모든 검사 억제
intention.name.suppress.for={1}에 대한 ''{0}'' 억제
intention.name.suppress.for.item.with.comment=주석이 있는 항목에 대해 억제
intention.name.surround.with.unsafe.block=안전하지 않은 블록으로 둘러싸기
intention.name.toggle.ignore.for.tests=테스트에 대한 ignore 전환
intention.name.un.elide.lifetimes=유효기간 생략 해제
intention.name.unwrap.from.expression=표현식에서 ''{0}'' 래핑 해제
intention.name.unwrap.if.expression='if' 표현 래핑 해제
intention.name.update.version.to=버전을 {0}(으)로 업데이트
intention.name.use.destructuring.declaration=구조 분해 선언 사용
intention.name.use.drop.to.clarify.intent.drop=''drop''으로 의도를 명확히 표시\: ''drop({0});''
intention.name.use.initialization.shorthand=축약된 이니셜라이저 사용
intention.name.use.shorthand.field.pattern=축약형 필드 패턴 사용\: ''{0}''
intention.name.wrap.in.ok=`Ok()`로 래핑
introduce.parameter.to.method=메서드에 매개변수 삽입
invalid.rust.toolchain.0=잘못된 Rust 툴체인\: {0}
invalid.rust.toolchain.02=잘못된 Rust 툴체인\: {0}
invalid.standard.library.0=잘못된 표준 라이브러리\: {0}
irrefutable.let.pattern=반박할 수 없는 let 패턴
iso.8601.rfc.3339.date.time.format.2001.07.08t00.34.60.026490.09.30=(2001-07-08T00\:34\:60.026490+09\:30) ISO 8601 / RFC 3339 날짜 및 시간 형식.
item.and.impls=항목 및 impl
kind.of.development.hobby=개인, 사이드 오픈 소스 프로젝트
kind.of.development.professional=전문 소프트웨어 개발
label.attribute=속성
label.channel=채널(&C)\:
label.everything=전체
label.expression=표현식
label.for.what.kind.development.do.you.primarily.use.rustrover=RustRover를 어떤 상황에서 주로 사용하시나요?
label.install.cargo.generate.using.cargo=Cargo로 cargo-generate 설치
label.item=항목
label.methods.only=메서드만
label.module=모듈
label.on.block=블록의 라벨
label.rust=Rust
label.rust.files=Rust 파일
label.statement=구문
label.struct=구조체 {0}'{'
label.structure=구조
label.trait.name=특성 이름\:
label.type.alias=타입 별칭 {0}
let.else=`let-else`
library.file.restore.content.notification.hyperlink=Restore initial content
library.file.restore.content.notification.text=External source files should not be modified
lints=Lints
list.item.attach.to.module=모듈에 연결
list.item.binary.application=바이너리(애플리케이션)
list.item.don.t.attach.to.module=모듈에 연결하지 않기
list.item.empty.file=빈 파일
list.item.function.to.inline=인라인화할 함수
list.item.library=라이브러리
list.item.procedural.macro=절차적 매크로
list.item.to.inline=인라인화할 {0}
list.item.type.alias.to.inline=인라인화할 타입 별칭
list.item.webassembly.lib=WebAssembly Lib
literal.newline.n=리터럴 새 줄(\\n)
literal.percent.sign=리터럴 퍼센트 기호
literal.tab.t=리터럴 탭(\\t)
local.time.zone.name.skips.all.non.whitespace.characters.during.parsing.acst=(ACST) 지역 시간대 이름. 분석 시 공백이 아닌 모든 문자를 건너뜁니다.
locale.s.date.and.time.thu.mar.3.23.05.25.2005=(Thu Mar 3 23\:05\:25 2005) 지역 날짜 및 시간.
locale.s.date.representation.12.31.99=(12/31/99) 지역 날짜 표시 방식.
locale.s.time.representation.23.13.48=(23\:13\:48) 지역 시간 표시 방식.
macro='매크로'
macro.expansion.error.BuiltinMacroExpansionError.message=기본 매크로를 확장할 수 없습니다
macro.expansion.error.CfgDisabled.message=매크로 호출이 '\#[cfg()]' 속성으로 인해 조건부로 비활성화됩니다
macro.expansion.error.ConcatArgumentsMustBeLiteral.message=리터럴(예\: `"foo"`, `-42` 및 `3.14`)만 `concat\!()`에 전달될 수 있습니다
macro.expansion.error.ConcatArgumentsNotFound.message=`concat\!()` 매크로에 인수가 없습니다
macro.expansion.error.DeclMacroExpansionError.DefSyntax.message=매크로 정의에 구문 오류가 있습니다
macro.expansion.error.DeclMacroExpansionError.Matching.message=매크로 호출 본문이 매크로 정의 패턴과 일치하지 않습니다
macro.expansion.error.DeclMacroExpansionError.TooLargeExpansion.message=매크로 확장이 너무 큽니다
macro.expansion.error.ExpansionFileNotFound.message=매크로가 아직 확장되지 않았습니다
macro.expansion.error.ExpansionNameNotFound.message=확장 이름을 찾을 수 없습니다(내부 오류)
macro.expansion.error.FileIncludedIntoMultiplePlaces.message=동일한 파일을 여러 곳에 포함하는 것은 지원되지 않습니다
macro.expansion.error.IncludingFileNotFound.message=포함된 파일을 찾을 수 없습니다
macro.expansion.error.InconsistentExpansionCacheAndVfs.message=확장 파일은 찾을 수 없지만 캐시에 유효한 확장이 포함되어 있습니다(내부 오류)
macro.expansion.error.InconsistentExpansionExpandedFrom.message='macro.expansion.expandedFrom \!\= macro'(내부 오류). 매크로 호출이 다른 모듈의 이름과 충돌하는 모듈 내에 있을 수 있습니다.
macro.expansion.error.MacroCallSyntax.message=매크로 호출 구문에 오류가 있습니다
macro.expansion.error.MacroDefSyntax.message=매크로 정의 구문에 오류가 있습니다
macro.expansion.error.MacroExpansionEngineIsNotReady.message=매크로 확장 엔진이 아직 준비되지 않았습니다
macro.expansion.error.MacroExpansionIsDisabled.message=매크로 확장이 프로젝트 설정에서 비활성화되었습니다
macro.expansion.error.MacroMatchingError.EndOfInput.message=매크로 호출 인수가 정의와 일치하지 않습니다. 토큰이 누락되었습니다
macro.expansion.error.MacroMatchingError.ExtraInput.message=매크로 호출 인수가 정의와 일치하지 않습니다. 이 토큰에는 규칙이 필요하지 않습니다
macro.expansion.error.MacroMatchingError.FragmentIsNotParsed.message=매크로 호출 인수가 정의와 일치하지 않습니다. 메타 변수 ''{0}''와(과) 일치하지 않습니다
macro.expansion.error.MacroMatchingError.UnmatchedToken.message=매크로 호출 인수가 정의와 일치하지 않습니다. 토큰이 어느 규칙과도 일치하지 않습니다. ''{1}''이(가) 아닌 ''{0}''이(가) 필요합니다
macro.expansion.error.MemExpAttrMacro.message=기존의 매크로 확장 엔진은 특성을 확장하거나 매크로를 파생할 수 없습니다
macro.expansion.error.MemExpParsingError.message=''{0}''을(를) ''{1}''(으)로서 분석할 수 없습니다
macro.expansion.error.ModDataNotFound.message=매크로 호출을 포함하는 'mod'의 ModData를 찾을 수 없습니다(내부 오류)
macro.expansion.error.NoMacroIndex.message=매크로 호출의 매크로 색인을 찾을 수 없습니다(내부 오류)
macro.expansion.error.NoProcMacroArtifact.message=절차적 매크로가 컴파일링되었으나 오류가 발생했습니다
macro.expansion.error.OldEngineStd.message=기존 매크로 확장 엔진은 Rust 표준 라이브러리로부터 매크로를 확장할 수 없습니다
macro.expansion.error.ProcMacroExpansionError.CantRunExpander.message=`{0}` 프로세스를 생성하는 중에 오류가 발생했습니다. 자세한 정보는 로그를 참조하세요.
macro.expansion.error.ProcMacroExpansionError.ExecutableNotFound.message=''{0}'' 실행 파일을 찾을 수 없습니다
macro.expansion.error.ProcMacroExpansionError.IOExceptionThrown.message=절차적 매크로 확장 서버와 통신하는 중 예외가 발생했습니다. 자세한 정보는 로그를 참조하세요.
macro.expansion.error.ProcMacroExpansionError.ProcMacroExpansionIsDisabled.message=절차적 매크로 확장이 비활성화되었습니다
macro.expansion.error.ProcMacroExpansionError.ProcessAborted.message=절차적 매크로 확장자 프로세스가 코드 {0}와(과) 함께 예기치 않게 종료되었습니다
macro.expansion.error.ProcMacroExpansionError.ServerSideError.message=절차적 매크로 오류가 발생했습니다\n{0}
macro.expansion.error.ProcMacroExpansionError.Timeout.message=절차적 매크로 확장이 시간 초과되었습니다({0}밀리초)
macro.expansion.error.ProcMacroExpansionError.UnsupportedExpanderVersion.message=현재 Rust 툴체인 버전({0})으로 절차적 매크로를 확장할 수 없습니다. IDE를 업데이트하거나 툴체인을 이전 버전으로 다운그레이드해 보세요.
macro.expansion.error.Skipped.message=이 절차적 매크로의 확장을 건너뛰었습니다
macro.expansion.error.SkippedInsideMacroRulesInjection.message=매크로를 매크로 선언 내에서 확장할 수 없습니다
macro.expansion.error.TooDeepExpansion.message=재귀 제한에 도달했습니다
macro.expansion.error.TooLargeExpansion.message=매크로 확장이 너무 큽니다
macro.expansion.error.UnmatchedProcMacroKind.message=절차적 매크로 ''{0}''을(를) ''{1}(으)로서 호출할 수 없습니다
macro.expansion.error.Unresolved.message=매크로 정의를 찾을 수 없습니다
macro.expansion.error.VirtualFileFoundButPsiIsNull.message=PSI 파일을 찾을 수 없습니다(내부 오류)
macro.expansion.error.VirtualFileFoundButPsiIsUnknown.message=알 수 없는 PSI 파일(내부 오류)
macro.expansion.error.start=매크로를 확장할 수 없습니다. {0}
min.const.generics=min const generics
minute.number.00.59.zero.padded.to.2.digits=(34) 분 표기(00?59). 0을 추가하여 2자리로 맞춥니다.
missing.else='else' 누락
mod.0=mod {0}
mod.statements.in.non.mod.rs.files=mod.rs가 아닌 파일 내의 모듈 선언
monday.1.tuesday.2.sunday.7.iso.8601=(7) 월요일 \= 1, 화요일 \= 2, ?, 일요일 \= 7. (ISO 8601)
month.day.year.format.same.as.m.d.y=(07/08/01) 월-일-년 형식. %m/%d/%y와 동일합니다.
month.number.01.12.zero.padded.to.2.digits.07=(07) 월 표기(01?12). 0을 추가하여 2자리로 맞춥니다.
name=이름
name2=이름\:
naming.conventions=이름 지정 규칙
no.explicit.stdlib.or.rustup.found=stdlib와 rustup 모두를 찾을 수 없습니다
no.lines.covered=포함된 줄 없음
no.mutable.required='mutable'은 불필요합니다
non.exhaustive.match=완전하지 않은 일치
notification.0.action.is.not.available.for.1.command={0} 액션은 ''{1}'' 명령어와 함께 사용할 수 없습니다
notification.action.attach.manually.text=수동으로 연결
notification.action.attach.text=Cargo.toml 연결
notification.action.do.not.show.again.text=다시 표시 안 함
notification.action.set.up.toolchain.text=툴체인 설정
notification.can.not.attach.stdlib.sources=rustup 없이 stdlib 소스를 자동으로 연결할 수 없습니다
notification.content.bad.answer.from.crates.io=crates.io의 응답이 유효하지 않습니다
notification.content.cannot.load.rustc.renderers=rustc 렌더러를 로드할 수 없습니다
notification.content.cannot.load.rustc.sources=rustc 소스를 로드할 수 없습니다
notification.content.cargo.expand=cargo-expand
notification.content.could.not.create.mod=''mod {0}'' 생성 실패
notification.content.could.not.reach.crates.io=crates.io에 도달할 수 없습니다
notification.content.debugger.downloading.failed=디버거를 다운로드하지 못했습니다
notification.content.debugger.successfully.downloaded=디버거 다운로드 성공
notification.content.failed.to.find.stdlib.in.sysroot=sysroot에서 stdlib을 찾을 수 없습니다
notification.content.failed.to.install.cargo.generate=cargo-generate 설치 실패
notification.content.grcov=grcov
notification.content.incompatible.toml.plugin.version.code.completion.for.cargo.toml.not.available=호환되지 않는 TOML 플러그인 버전입니다. Cargo.toml의 코드 완성을 사용할 수 없습니다.
notification.content.low.performance.due.to.rust.external.linter=외부 Rust Linter{0}{1}\\&nbsp;\\&nbsp;\\&nbsp;\\&nbsp;{2}(으)로 인한 성능 저하
notification.content.need.at.least={0} {1} 이상이 필요합니다
notification.content.new.rust.version.available.for.download=새로운 버전의 Rust {0}을(를) 다운로드할 수 있습니다
notification.content.new.rust.version.was.installed=Rust {0}이(가) 설치되었습니다
notification.content.no.rustup={0} 사용 불가\: rustup을 찾을 수 없음
notification.content.not.installed={0}이(가) 설치되지 않았습니다
notification.content.please.answer.few.questions.it.will.take.about.minutes=몇 가지 질문에 답변해 주세요. 2분 정도 소요됩니다.
notification.content.project.not.found=프로젝트를 찾을 수 없습니다
notification.content.rebuilt.defmap.for.all.crates.in.ms=모든 크레이트의 DefMap 재빌드가 {0}밀리초 후에 완료됩니다
notification.content.respond=응답하기
notification.content.rust.toolchain.no.longer.supported=Rust <b>{0}</b>은(는) 지원되지 않으며, 해당 버전을 사용하면 오류가 발생할 수 있습니다. 툴체인을 <b>{1}</b> 이상으로 업그레이드하세요.
notification.content.rustup.failed=rustup 실패\: {0}
notification.content.target.no.rustup=대상 {0} 사용 불가\: rustup을 찾을 수 없음
notification.content.target.not.installed=대상 {0}이(가) 설치되어 있지 않습니다
notification.content.using.path.to.cargo=활성 Cargo 경로\: {0}
notification.content.wasm.pack=wasm-pack
notification.failed.to.load.cargo.changes=빌드 실패
notification.failed.to.load.cargo.changes.with.settings=빌드가 실패했습니다\nCargo 변경 사항은 Cargo.toml을 입력하면 자동으로 다시 로드됩니다. <a href\="disable.auto.reload">자동 재로드 비활성화</a>
notification.file.not.belong.to.cargo.project=파일이 알려진 Cargo 프로젝트에 속해 있지 않습니다
notification.group.rust=Rust
notification.group.rust.updates=Rust 업데이트
notification.group.rustfmt=Rustfmt
notification.group.toml=TOML
notification.invalid.stdlib.source.path=잘못된 Rust 표준 라이브러리 소스 경로\: ''{0}''
notification.load.cargo.change.with.settings=Cargo 변경 사항은 Cargo.toml을 입력하면 자동으로 다시 로드됩니다. <a href\="disable.auto.reload">자동 재로드 비활성화</a>
notification.navigation.to.implementations=인덱스 업데이트 중에는 구현으로 이동할 수 없습니다
notification.no.cargo.projects.found=프로젝트가 Cargo.toml 파일과 연결되지 않았습니다
notification.no.toolchain.configured=구성된 Rust 툴체인이 없습니다
notification.run.tests.as.root.unix=루트 권한으로 테스트를 실행하는 것은 지원되지 않습니다
notification.run.tests.as.root.windows=관리자 권한으로 테스트를 실행하는 것은 지원되지 않습니다
notification.rustfmt.show.details.in.console=콘솔 내에 상세 정보 표시
notification.successful.cargo.sync.with.settings=빌드에 성공했습니다\nCargo 변경 사항은 Cargo.toml을 입력하면 자동으로 다시 로드됩니다. <a href\="disable.auto.reload">자동 재로드 비활성화</a>
notification.title.code.code.not.installed=크레이트 ''{0}''이(가) 설치되지 않음
notification.title.debugger=디버거
notification.title.potentially.inconsistent.build.test.results=빌드/테스트 결과가 일관되지 않을 수 있음
notification.title.rustfmt=Rustfmt
notification.title.rustfmt.error=Rustfmt 오류
notification.title.share.feedback.about.rustrover=RustRover에 관한 피드백 공유
off=끄기
offset.from.the.local.time.to.utc.with.seconds.09.30.00=(+09\:30\:00) 초 단위 까지 표시된 로컬 시간과 UTC 간의 오프셋.
offset.from.the.local.time.to.utc.with.utc.being.0000=(+0930) UTC와 지역 시간 간의 오프셋.
offset.from.the.local.time.to.utc.without.minutes.09=(+09) 분 단위를 제외한 UTC와 로컬 시간 간의 오프셋.
on=켜기
optimize.imports.fix=import 문 최적화
or.patterns.syntax=or 패턴 구문
parameters=매개변수\:
parsing.error.expected=''{0}'' 필요
parsing.error.expected.got='';''이 필요하나 ''{0}''이(가) 수신되었습니다
parsing.error.macro.argument.expected.got=<매크로 인수>가 필요하나 ''{0}''이(가) 수신되었습니다
parsing.only.same.as.z.but.allows.minutes.to.be.missing.or.present=(+09) 분석만\: %z와 동일하지만 분 단위가 선택적으로 표시됩니다.
popular.crates.import.paste.dialog.always.add=항상 추가
popular.crates.import.paste.dialog.cancel=아니오
popular.crates.import.paste.dialog.explanation=<html>붙여넣은 코드에는 다음에 있는 크레이트의 임포트가 포함되어 있습니다.<br/>Cargo.toml에 추가할까요?</html>
popular.crates.import.paste.dialog.never.add=추가하지 않음
popular.crates.import.paste.dialog.title=크레이트 추가
popup.title.choose.module.declaration=모듈 선언 선택
popup.title.choose.scope.to.introduce.constant=''{0}''을(를) 대체하는 신규 상수의 범위 선택
popup.title.first.level.expansion=''{0}''의 첫 단계 확장
popup.title.item.to.import=가져올 항목
popup.title.macro=''{0}\!'' 매크로
popup.title.recursive.expansion=''{0}''의 재귀적 확장
popup.title.rename.label=라벨
popup.title.value.used.after.being.moved=Value Used After Being Moved
previous.command.is.still.running.please.wait.or.press.ctrl.c.in.console.to.interrupt=이전 명령어가 아직 실행 중입니다. 기다리거나 콘솔에서 Ctrl+C를 눌러 중지하세요.
println.usage='println\!' 매크로 사용 위치
private=비공개
profiler.attach.default.group.title=네이티브
progress.text.building=빌드 중...
progress.text.building1=빌드 중...
progress.text.connecting.to.console=Rust REPL에 연결 중...
progress.text.getting.rust.stdlib=Rust stdlib 가져오는 중
progress.text.getting.toolchain.version=툴체인 버전 가져오는 중
progress.text.info=정보\:
progress.text.installing.using.cargo=Cargo를 통해 설치 중...
progress.text.preparing.resolve.data=이름 해결을 위한 데이터 준비 중
progress.text.save.macro.expansions=매크로 확장 저장 중...
progress.text.updating.workspace.info=작업 공간 정보 업데이트 중
progress.text.waiting.for.current.build.to.finish=현재 빌드 완료 대기 중...
progress.title.analyzing.project.with={0}(으)로 프로젝트 분석 중
progress.title.build=빌드
progress.title.building=빌드 중
progress.title.building.cargo.project=Cargo 프로젝트 빌드 중
progress.title.checking.if.installed={0} 설치 여부 확인 중
progress.title.checking.if.toolchain.supported=툴체인이 지원되는지 확인 중
progress.title.choice.recursive.single.step.expansion.progress={0, choice, 0\#재귀적|1\#한 단계} 확장 진행 중
progress.title.cleaning.outdated.macros=오래된 매크로 제거 중
progress.title.connecting.to.console=REPL 콘솔에 연결 중
progress.title.expanding.rust.macros=Rust 매크로 확장 중
progress.title.generating.cargo.project=Cargo 프로젝트 생성 중
progress.title.getting.environment.variables=환경 변수 가져오는 중
progress.title.getting.installed.distributions=설치된 배포판 가져오는 중
progress.title.installing={0} 설치 중
progress.title.installing2={0} 설치 중
progress.title.loading.cargo.registry.index=Cargo 레지스트리 색인 로드 중
progress.title.loading.coverage.data=커버리지 데이터 로드 중
progress.title.preparing.remote.environment=원격 환경 준비 중
progress.title.reformatting.cargo.project.with.rustfmt=Rustfmt로 Cargo 프로젝트의 서식 다시 지정 중
progress.title.reloading.cargo.projects=Cargo 프로젝트 다시 로드 중
progress.title.restarting.console=REPL 콘솔 다시 시작 중
public=공개
quick.doc.macro.expansion=매크로 확장
radio.inline.all.keep.method=전체 인라인화하고 메서드 유지
radio.inline.all.references.keep=모든 참조를 인라인화하고 ''{0}'' 유지
radio.inline.all.remove.type.alias=전체 인라인화하고 타입 별칭 제거
radio.inline.this.only.keep=이 항목만 인라인화하고 ''{0}'' 유지
radio.inline.this.only.keep.type.alias=이 항목만 인라인화하고 타입 별칭 유지
raw.address.of.syntax=raw-address-of 구문
redundant.else=불필요한 'else'
refactoring.change.signature.error.cfg.disabled.parameters=시그니처를 변경할 수 없습니다. 함수에 cfg가 비활성화된 매개변수가 있습니다
refactoring.change.signature.name=시그니처 변경
refactoring.change.signature.name.conflict=이름 ''{0}''이(가) ''{1}''에 있는 기존 항목과 충돌합니다
refactoring.change.signature.refactor.super.function=메서드 ''{0}''이(가) 특성 ''{1}''의 기본 메서드를 구현합니다.\n기본 메서드를 리팩터링하시겠어요?
refactoring.change.signature.visibility.conflict=리팩터링되면 함수가 ''{0}''에서 보이지 않게 됩니다
resolve.context.promoter.header=대상 아키텍쳐 위젯
resolve.context.promoter.message=이 위젯을 사용하여 현재 대상 아키텍처를 번경하세요
resolve.contexts.linemarker.tooltip=구성 대상 아키텍처
resolve.contexts.popup.footer=선택된 아키텍처에 대해서만 코드가 해결되었습니다
resolve.contexts.popup.header=사용 가능한 대상 아키텍처
resolve.contexts.popup.tooltip=''{0}'' 아키텍처를 대상으로 하는 소스 코드만 해결 중입니다.
resolve.contexts.widget.undefined=<아키텍처 선택>
resolve.contexts.widget.undefined.tooltip=타깃 아키텍처를 선택하면 IDE가 이에 맞춰서 프로젝트 소스 코드를 해결할 수 있습니다.
resolve.pasted.references.command.name=붙여넣은 참조 해결
resolve.pasted.references.indicator.text=붙여넣은 참조 해결 중
revert=되돌리기
revert.applied.imports.command.name=추가된 임포트 제거
run.rustfmt=rustfmt 실행
run.target.build.arguments.comment=<b>원격 타깃에서 빌드</b> 옵션 비활성화 시 'cargo build' 명령어의 추가 인수
run.target.build.arguments.label=추가 빌드 인수\:
run.target.cargo.executable.path.label=Cargo 실행 파일\:
run.target.cargo.executable.version.label=Cargo 버전\:
run.target.rustc.executable.path.label=Rustc 실행 파일\:
run.target.rustc.executable.version.label=Rustc 버전\:
runs.cargo.command=Cargo 명령어를 실행합니다
runs.wasm.pack.command=wasm-pack 명령어를 실행합니다
rust=Rust
rust.1.70.0.stable=Rust 1.70.0 안정판
rust.cargo.toml=Rust/Cargo.toml
rust.checkin.factory.fmt.commit.anyway.question=그래도 커밋하시겠어요?
rust.checkin.factory.fmt.failed.message=Rusfmt 실행 실패
rust.checkin.factory.fmt.header.message=Rustfmt가 ''{0}''의 서식을 지정하지 못했습니다
rust.checkin.factory.fmt.rustfmt.not.installed.message=Rustfmt가 설치되지 않았습니다
rust.code.vision.implementation.hint={0,choice, 1\#1개 구현|2\#{0,number}개 구현}
rust.code.vision.overrides.hint={0,choice, 1\#1개 재정의|2\#{0,number}개 재정의}
rust.code.vision.usage.hint={0,choice, 0\#0개 사용 위치|1\#1개 사용 위치|2\#{0,number}개 사용 위치}
rust.compiler=Rust 컴파일러
rust.consoles=Rust 콘솔
rust.debugger.renderers.bundled.item=번들에 포함된 렌더러
rust.debugger.renderers.compiler.item=Rust 컴파일러의 렌더러
rust.debugger.renderers.none.item=렌더러 없음
rust.external.linter=Rust 외부 Linter
rust.external.linter.cargo.check.item=Cargo Check
rust.external.linter.clippy.item=Clippy
rust.file=Rust 파일
rust.module=Rust 모듈
rust.repl=Rust REPL
rustc.bootstrap.warning={0}을(를) 지원하기 위해 IDE가 {2} 환경 변수로 {1}을(를) 실행하며, 간헐적으로 빌드/테스트 결과가 일관적이지 않을 수 있습니다. {3} {4}(으)로 잠재적인 일관성 문제를 피할 수 있습니다.
rustfmt.console.toolwindow.display.name=Rustfmt 로그
rustfmt.promoter.enable.message=기본값으로 활성화
rustfmt.promoter.message=<html>{0}은(는) Rustfmt으로 전체 파일에 대한 서식 지정을 지원합니다<br/>{1}</html>
rustup.could.not.amend.shell.profile=<html>rcfile에 기록할 수 없습니다.<br><code>{0}</code><br><br>다음을 rcfile에 수동으로 추가하세요.<br><code>. "$HOME/.cargo/env"</code></html>
rustup.could.not.amend.shell.profile.title=셸 프로파일을 수정할 수 없습니다
rustup.failed.to.install.exit.code=종료 코드 {0}
rustup.failed.to.install.timed.out=설치가 타임아웃되었습니다
rustup.failed.to.install.title=Rustup 설치 실패
rustup.failed.to.start.installation=Rustup 설치를 시작할 수 없습니다
rustup.installation.has.been.cancelled.title=Rustup 설치가 취소되었습니다
rustup.installer.downloading={0} 다운로드 중
rustup.installer.running={0} 실행 중
rustup.installer.vs.question=Rust에는 링커와 Windows API 라이브러리가 필요합니다.\n\nVisual Studio 커뮤니티 인스톨러를 통해 이러한 구성 요소를 설치할 수 있습니다(개인 및 학술 용도로 무료이며 오픈 소스).
rustup.installer.vs.question.title=Rust Visual C++ 전제 조건
rustup.some.installed.components.might.get.inconsistent.after.cancellation=취소 전에 설치된 Rustup 구성 요소는 일관적으로 작동하지 않을 수 있습니다.
rustup.try.to.install.manually=https\://rustup.rs에서 Rustup을 수동으로 설치해 보세요.
same.as.d.but.space.padded.8=( 8) %d와 동일하지만 공백이 추가됩니다.
same.as.h.but.space.padded.same.as.h=( 0) %H와 동일하지만 공백이 추가됩니다. %_H와 동일합니다.
same.as.i.but.space.padded.same.as.i=(12) %I와 동일하지만 공백이 추가됩니다. %_I와 동일합니다.
same.as.u.but.uses.the.week.number.in.iso.8601.week.date.01.53=(27) %U와 동일하지만 ISO 8601 주 및 날짜(01?53)의 주 표기를 사용합니다.
same.as.u.but.week.1.starts.with.the.first.monday.in.that.year.instead=(27) %U와 동일하지만 1주차가 해당 년도의 첫 번째 월요일에 시작합니다.
same.as.y.but.uses.the.year.number.in.iso.8601.week.date=(01) %y와 동일하지만 ISO 8601 주 및 날짜의 년도 표기를 사용합니다.
same.as.y.but.uses.the.year.number.in.iso.8601.week.date.2001=(2001) %Y와 동일하지만 ISO 8601 주 및 날짜의 년도 표기를 사용합니다.
same.as.z.but.with.a.colon=(+09\:30) %z와 동일하지만 콜론이 있습니다.
second.number.00.60.zero.padded.to.2.digits=(60) 초 표기(00?60). 0을 추가하여 2자리로 맞춥니다.
separator.items.to.move=이동할 항목
separator.members.to.form.trait=특성을 구성할 멤버
settings.rust.add.crates.dependencies.on.paste=붙여넣기 시 크레이트 종속 요소 추가\:
settings.rust.auto.import.exclude.comment=<code>use</code> 선언에서처럼 각 경로를 지정하세요. 특정 접두사가 경로에 포함된 모든 항목에 대해 자동 가져오기를 끄려면 경로에 <code>\:\:*</code>를 추가하세요. 특성을 제외할 때에는 자동 가져오기를 특성 메서드 대해서만 비활성화할지 혹은 특성 이름에 대해서도 비활성화할지를 지정하세요. 단, 이러한 설정은 <code>use</code> 선언으로 재정의됩니다.
settings.rust.auto.import.exclude.label=자동 가져오기 및 코드 완성에서 제외\:
settings.rust.auto.import.on.completion=코드 완성 시 범위 밖의 항목 가져오기
settings.rust.auto.import.on.paste=붙여 넣을 때 import 문 삽입
settings.rust.auto.import.show.popup=import 문 팝업 표시
settings.rust.auto.import.title=Rust
settings.rust.cargo.auto.update.project.label=Cargo.toml이 변경될 때마다 프로젝트를 자동으로 업데이트
settings.rust.cargo.compile.all.targets.comment=<b>--target-all</b> 옵션을 <b>cargo 빌드</b>/<b>검사</b>에 전달
settings.rust.cargo.compile.all.targets.label=가능한 경우 모든 프로젝트 타깃을 컴파일링
settings.rust.cargo.moved.label=Cargo 설정이 '빌드, 실행, 배포 | 빌드 도구 | Cargo'로 이동되었습니다
settings.rust.cargo.name=Cargo
settings.rust.cargo.offline.mode.comment=네트워크 요청을 피하기 위해 Cargo 명령어에 <b>--offline</b> 옵션을 전달
settings.rust.cargo.offline.mode.label=오프라인 모드
settings.rust.cargo.show.first.error.label=빌드가 실패할 때 자동으로 첫 번째 오류를 에디터에 표시
settings.rust.code.style.align.return.type=반환 타입을 함수 매개변수에 정렬
settings.rust.code.style.align.where.clause='where' 절을 함수 매개변수에 정렬
settings.rust.code.style.align.where.clause.bounds='where' 절 바운드 정렬
settings.rust.code.style.around.associated.type.bindings=연관 타입 바인딩 주변
settings.rust.code.style.between.declarations=선언 사이\:
settings.rust.code.style.end.of.line.comments.on.the.same.line=Preserve end of line comments on the same line
settings.rust.code.style.indent.where.clause='where' 절 들여쓰기
settings.rust.code.style.match.expressions.in.one.line=표현식을 한 줄로 일치
settings.rust.code.style.name=Rust
settings.rust.code.style.punctuation=문장 부호
settings.rust.color.associated.function.call=함수//연관된 함수 호출
settings.rust.color.associated.function.declaration=함수//연관된 함수 선언
settings.rust.color.attribute=속성
settings.rust.color.char=리터럴//문자
settings.rust.color.conditionally.disabled.code=조건부로 비활성화되는 코드
settings.rust.color.const.parameter=매개변수//상수 매개변수
settings.rust.color.constant=변수//상수
settings.rust.color.crate=타입//크레이트
settings.rust.color.enum=타입//열거형
settings.rust.color.enum.variant=타입//열거형 variant
settings.rust.color.field=변수//필드
settings.rust.color.format.parameter=리터럴//문자열//서식 매개변수
settings.rust.color.format.specifier=리터럴//문자열//서식 매개변수 내 서식 지정자
settings.rust.color.function.call=함수//함수 호출
settings.rust.color.function.declaration=함수//함수 선언
settings.rust.color.generated.items=매크로가 생성한 항목
settings.rust.color.invalid.escape.sequence=리터럴//문자열//이스케이프 시퀀스//유효하지 않음
settings.rust.color.keyword=키워드//키워드
settings.rust.color.keyword.unsafe=키워드//안전하지 않음
settings.rust.color.lifetime=매개변수//유효기간
settings.rust.color.macro=함수//매크로
settings.rust.color.method.call=함수//메서드 호출
settings.rust.color.method.declaration=함수//메서드 선언
settings.rust.color.module=타입//모듈
settings.rust.color.mutable.binding=변수//가변 바인딩
settings.rust.color.mutable.parameter=매개변수//가변 매개변수
settings.rust.color.number=리터럴//숫자
settings.rust.color.operation.sign=괄호 및 연산자//연산 기호
settings.rust.color.parameter=매개변수//매개변수
settings.rust.color.primitive=타입//기본형
settings.rust.color.question.mark=괄호 및 연산자//? 연산자
settings.rust.color.rustdoc.bold=Rustdoc//굵은 텍스트
settings.rust.color.rustdoc.code=Rustdoc//코드
settings.rust.color.rustdoc.comment=Rustdoc//주석
settings.rust.color.rustdoc.heading=Rustdoc//헤딩
settings.rust.color.rustdoc.italic=Rustdoc//기울임꼴 텍스트
settings.rust.color.rustdoc.link=Rustdoc//링크
settings.rust.color.scheme.title=Rust
settings.rust.color.self.parameter=매개변수//Self 매개변수
settings.rust.color.static=변수//static
settings.rust.color.static.mutable=변수//가변 static
settings.rust.color.string=리터럴//문자열//문자열
settings.rust.color.struct=타입//구조체
settings.rust.color.trait=타입//특성
settings.rust.color.type.alias=타입//타입 별칭
settings.rust.color.type.parameter=매개변수//타입 매개변수
settings.rust.color.union=타입//공용체
settings.rust.color.unsafe.code=안전하지 않은 코드
settings.rust.color.valid.escape.sequence=리터럴//문자열//이스케이프 시퀀스//유효함
settings.rust.color.variables.default=변수//디폴트 값
settings.rust.completion.suggest.out.of.scope.items=범위 밖 항목 제안
settings.rust.completion.title=Rust
settings.rust.external.linters.additional.arguments.comment=<b>cargo check</b> / <b>cargo clippy</b>용 추가 인수
settings.rust.external.linters.additional.arguments.label=추가 인수\:
settings.rust.external.linters.channel.label=채널\:
settings.rust.external.linters.name=외부 Linter
settings.rust.external.linters.on.the.fly.comment=외부 Linter 결과에 따라 코드 강조 표시를 추가합니다. IDE 성능에 영향을 줄 수 있습니다.
settings.rust.external.linters.on.the.fly.label=외부 Linter 즉석 실행
settings.rust.external.linters.tool.comment=추가 코드 분석을 실행합니다
settings.rust.external.linters.tool.label=외부 도구\:
settings.rust.folding.one.line.methods.checkbox=<html>한 줄 메서드<html>
settings.rust.folding.title=Rust
settings.rust.inlay.hints.for=다음에 대한 힌트 표시\:
settings.rust.inlay.hints.for.closures=클로저
settings.rust.inlay.hints.for.exclusive.range.expressions=배타적인 범위 표현식
settings.rust.inlay.hints.for.exclusive.range.patterns=배제 범위 패턴
settings.rust.inlay.hints.for.iterators=반복자를 'impl Iterator<...>'로
settings.rust.inlay.hints.for.loop.variables=루프 변수
settings.rust.inlay.hints.for.obvious.types=명백한 타입
settings.rust.inlay.hints.for.same.consecutive.types=동일한 순차 타입
settings.rust.inlay.hints.for.type.placeholders=타입 자리표시자
settings.rust.inlay.hints.for.variables=변수
settings.rust.inlay.hints.title.method.chains=메서드 체인
settings.rust.inlay.hints.title.types=타입
settings.rust.inlay.hints.title.values=값
settings.rust.inlay.parameter.hints.only.smart=스마트 힌트만
settings.rust.rustfmt.actions.on.save=저장 시 액션 구성...
settings.rust.rustfmt.additional.arguments.comment=<b>rustfmt</b> / <b>cargo fmt</b>용 추가 인수
settings.rust.rustfmt.additional.arguments.label=추가 인수\:
settings.rust.rustfmt.builtin.formatter.label=내장 서식 지정 도구 대신 Rustfmt 사용
settings.rust.rustfmt.builtin.formatter.label.comment=Rustfmt은 전체 파일의 서식을 지정할 때만 사용됩니다. 코드 조각의 경우 IDE가 내장 서식 지정 도구로 전환합니다.
settings.rust.rustfmt.channel.label=채널\:
settings.rust.rustfmt.name=Rustfmt
settings.rust.rustup.install.rustup.dialog.title=Rustup 설치 중
settings.rust.rustup.install.rustup.link=Rustup 설치
settings.rust.toolchain.download.stdlib.dialog.title=Rust 표준 라이브러리 다운로드 중
settings.rust.toolchain.download.stdlib.link=Rustup을 통해 다운로드
settings.rust.toolchain.download.stdlib.progress.text=Rustup을 통해 설치 중...
settings.rust.toolchain.expand.macros.checkbox=매크로 확장
settings.rust.toolchain.expand.macros.comment=매크로 호출의 처리를 활성화합니다. 활성화 시 매크로의 적절한 이름 해결 및 타입 추론이 가능해집니다.
settings.rust.toolchain.inject.rust.in.doc.comments.checkbox=Rust 언어를 문서 주석에 삽입
settings.rust.toolchain.invalid.toolchain.error.1=잘못된 툴체인 위치\: {0}에서 Cargo를 찾을 수 없습니다
settings.rust.toolchain.invalid.toolchain.error.2=툴체인 위치가 지정되지 않았습니다
settings.rust.toolchain.location.label=툴체인 위치\:
settings.rust.toolchain.name=Rust
settings.rust.toolchain.not.applicable.version.text=해당 사항 없음
settings.rust.toolchain.select.standard.library.dialog.title=Rust 표준 라이브러리 소스의 위치 지정
settings.rust.toolchain.standard.library.label=표준 라이브러리\:
settings.rust.toolchain.version.label=툴체인 버전\:
signature=시그니처\:
similar.to.3f.but.without.the.leading.dot.026=(026) %.3f와 유사하지만 선행하는 마침표가 없습니다.
similar.to.6f.but.without.the.leading.dot.026490=(026490) %.6f와 유사하지만 선행하는 마침표가 없습니다.
similar.to.9f.but.without.the.leading.dot.026490000=(026490000) %.9f와 유사하지만 선행하는 마침표가 없습니다.
similar.to.f.but.left.aligned.but.fixed.to.a.length.of.3.026=(.026) .%f와 유사하지만 왼쪽 정렬되며 길이가 3으로 고정됩니다.
similar.to.f.but.left.aligned.but.fixed.to.a.length.of.6.026490=(.026490) .%f와 유사하지만 왼쪽 정렬되며 길이가 6으로 고정됩니다.
similar.to.f.but.left.aligned.but.fixed.to.a.length.of.9.026490000=(.026490000) .%f와 유사하지만 왼쪽 정렬되며 길이가 9로 고정됩니다.
similar.to.f.but.left.aligned.these.all.consume.the.leading.dot.026490=(.026490) .%f와 유사하지만 왼쪽 정렬됩니다. 이 형식에는 모두 선행하는 마침표가 있습니다.
ssr.unsupported.replace.template=바꾸기는 아직 지원되지 않습니다
ssr.unsupported.search.template=검색 템플릿에 지원되지 않는 요소가 있습니다
start.function='\#[start]' 함수
status.bar.text.rebuilt.defmap.for.in.ms=''{0}''의 DefMap 재빌드가 {1}밀리초 후에 완료됨
struct=struct
structs.deriving.default=Default를 파생하는 구조체
structs.with.a.u8.field='u8' 필드가 있는 구조체
structure.view.show.macro.expanded=매크로 확장의 항목 표시
structure.view.sort.visibility=가시성별 정렬
subslice.patterns=subslice 패턴
suffixes.on.tuple.index.are.invalid=튜플 색인에는 접미사가 허용되지 않습니다
sunday.0.monday.1.saturday.6=(0) 일요일 \= 0, 월요일 \= 1, ?, 토요일 \= 6.
super.structs=super 구조체
suspicious.assignment=의심스러운 대입
system.notification.text.={0}개 {1} 및 {2}개 {3}
system.notification.title.canceled={0} 취소됨
system.notification.title.failed={0} 실패
system.notification.title.finished={0} 완료
tab.title.error.running.console=Rust REPL을 실행하는 중 오류 발생
test=테스트
text.conditionally.disabled.code=조건부로 비활성화되는 코드
text.use.my.e.mail.location.for.this.purpose=이 목적을 위해 내 이메일 및 위치 사용
the.0.tool.window.was.disabled.1.2={0} 도구 창이 비활성화되었습니다. {1}{2}
the.fractional.seconds.in.nanoseconds.since.last.whole.second.026490000=(026490000) 초 단위 미만의 소수 자리 초(나노초 단위).
the.full.proleptic.gregorian.year.zero.padded.to.4.digits.2021=(2001) 완전한 역산 그레고리력. 0을 추가하여 4자리에 맞춥니다.
the.proleptic.gregorian.year.divided.by.100.zero.padded.to.2.digits.20=(20) 100으로 나눈 역산 그레고리력. 0을 추가하여 2자리로 맞춥니다.
the.proleptic.gregorian.year.modulo.100.zero.padded.to.2.digits.01=(01) 역산 그레고리력을 100으로 나눈 나머지. 0을 추가하여 2자리로 맞춥니다.
to=대상\:
too.many.characters.in.0=''{0}''에 문자가 너무 많습니다
toolchain.version.is.unknown.hardcoded.stdlib.structure.will.be.used=툴 체인 버전을 판별할 수 없습니다. 하드코드된 stdlib 구조가 대신 사용됩니다.
tooltip.cannot.cast.enum.with.non.exhaustive.variant.when.it.s.defined.in.another.crate=완전하지 않은 변형이 있는 열거형은 다른 크레이트에서 정의되므로 형 변환할 수 없습니다
tooltip.delimiters.should.be='(' 및 ')'를 구분자로 사용
tooltip.does.not.have.constant.size.known.at.compile.time=''{0}''은(는) 컴파일링 타임 시 알려진 상수 크기를 갖지 않습니다
tooltip.following.are.possible.correct.uses=잠재적으로 올바른 사용 위치
tooltip.implements=구현
tooltip.in=''{2}'' 내의 {0} {1}
tooltip.instead.using.suffixed.literal.1u8.0f32.etc.use.unsuffixed.version.etc=접미사가 있는 리터럴(예\: '1u8', '1.0f32')을 접미사가 없는 버전(예\: '1', '\n1.0')으로 바꾸기
tooltip.must.be.defined.only.once.in.namespace.this=`{0}` can only be defined once in the `{1}` namespace of this {2}
tooltip.must.be.form=양식이어야 합니다
tooltip.overrides=재정의
tooltip.project.directory.does.not.exist=프로젝트 디렉터리가 없습니다
tooltip.project.needs.update=프로젝트를 업데이트해야 합니다
tooltip.project.up.to.date=프로젝트가 최신 상태입니다
tooltip.target={0} 타깃 ''{1}''
tooltip.this.accepted.in.current.edition.rust.but.hard.error.in.rust=이 구문은 Rust 2018에서는 허용되지만 Rust 2021에서는 컴파일링되지 않습니다
tooltip.this.was.previously.accepted.by.compiler.but.being.phased.out.it.will.become.hard.error.in.future.release=이 구문은 이전 컴파일러 버전에서는 허용되지만 추후 버전에서는 컴파일링되지 않습니다.
tooltip.trait.not.implemented.for=특성 ''{0}''이(가) ''{1}''에 대해 구현되지 않았습니다
tooltip.valid.abis=올바른 ABI\: {0}
tooltip.visibility.restriction.with.module.path.should.start.with.in.keyword=모듈 경로에 가시성 제한을 설정할 때 'in'을 사용합니다
toolwindow.stripe.RustCargo=Cargo
trait=특성
try.macro.usage='try\!' 매크로 사용
type=타입
type.0=타입\: {0}
type2=타입
unable.to.run.debugger=디버거를 실행할 수 없습니다
unix.timestamp.the.number.of.seconds.since.1970.01.01.00.00.utc.994518299=(994518299) UNIX 타임스탬프. 1970-01-01 00\:00 UTC 이후 경과한 초.
unreachable.patterns=도달할 수 없는 패턴
unsafe.cstring.pointer=안전하지 않은 CString 포인터
untrusted.project.notification.execution.error=작업을 실행할 수 없습니다. 신뢰할 수 없는 Cargo 프로젝트
update.status.failed.hardcoded.stdlib=stdlib 구조를 판별할 수 없습니다. 하드코드된 stdlib 구조가 대신 사용됩니다.
visibility=가시성\:
visibility.qualifier=가시성 한정자
vs.exit.code.-1073720687=연결 실패
vs.exit.code.-1073741510=Microsoft Visual Studio 인스톨러가 종료되었습니다
vs.exit.code.1001=Visual Studio 인스톨러 프로세스가 실행 중입니다
vs.exit.code.1003=Visual Studio가 사용 중입니다
vs.exit.code.1602=작업이 취소되었습니다
vs.exit.code.1618=다른 설치가 실행 중입니다
vs.exit.code.1641=작업이 성공적으로 완료되었으며 재부팅이 필요합니다
vs.exit.code.3010=작업이 성공적으로 완료되었으나 설치된 소프트웨어를 사용하기 전에 재부팅이 필요합니다
vs.exit.code.5003=부트스트래퍼가 인스톨러를 다운로드할 수 없습니다
vs.exit.code.5004=작업이 취소되었습니다
vs.exit.code.5005=부트스트래퍼 명령줄 분석 오류
vs.exit.code.5007=작업이 차단되었습니다. 컴퓨터가 요구사항을 만족하지 않습니다
vs.exit.code.740=승격 필요
vs.exit.code.8001=Arm 머신 확인 실패
vs.exit.code.8002=백그라운드 다운로드 사전 검사 실패
vs.exit.code.8003=지원의 선택 가능한 실패
vs.exit.code.8004=대상 디렉터리 실패
vs.exit.code.8005=소스 페이로드 실패 검증 중
vs.exit.code.8006=Visual Studio 프로세스가 실행 중입니다
vs.exit.code.else=종료 코드 {0}
vs.failed.to.install.timed.out=시간 초과
vs.failed.to.install.title=Visual Studio 설치 실패
vs.failed.to.start.installation=Visual Studio 설치를 시작할 수 없습니다
vs.installation.has.been.cancelled.title=Visual Studio 설치가 취소되었습니다
vs.installer.downloading=Visual Studio 설치 프로그램 다운로드 중
vs.installer.running=Visual Studio 설치 프로그램 실행 중
vs.installer.title=Visual Studio 설치 프로그램
vs.installer.waiting=Rustup은 Visual Studio 설치가 완료되면 재개됩니다
vs.some.installed.components.might.get.inconsistent.after.cancellation=설치된 일부 Visual Studio 구성 요소가 취소 후 일관적이지 않을 수 있습니다.
vs.try.to.install.manually=https\://visualstudio.microsoft.com에서 Visual Studio를 수동으로 설치해 보세요.
wasm.pack=wasm-pack
wasm.pack.command.run.configuration=wasm-pack 실행 구성
wasm.pack.commands=wasm-pack 명령어
week.number.starting.with.sunday.00.53.zero.padded.to.2.digits=(28) 일요일부터 시작하는 주 표기(00?53). 0을 추가하여 2자리로 맞춥니다.
where.clauses.on.associated.types=연관된 타입의 'where' 절
while.true.loop='while true' 루프
year.month.day.format.iso.8601.same.as.y.m.d=(2001-07-08) 년-월-일 형식(ISO 8601). %Y-%m-%d와 동일합니다.
yield.syntax='yield' 구문
