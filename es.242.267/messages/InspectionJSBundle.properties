add.require.amd.module.fix=Agregar dependencia del módulo {0}
add.require.amd.module.group.name=Node.js
add.return.statement.fix.name=Agregar declaración de devolución
anonymous.function.contains.multiple.loops.error.string=#ref contiene {0} bucles #loc
anonymous.function.contains.multiple.return.points.error.string=#ref tiene {0} puntos de retorno #loc
anonymous.function.contains.too.many.negation.error.string=#ref contiene {0} negaciones #loc
anonymous.function.display.name=Función anónima
anonymous.function.error.string=Anónimo #ref #loc
anonymous.function.has.inconsistent.return.points.error.string=#ref tiene puntos de retorno inconsistentes #loc
anonymous.function.has.too.many.parameters.error.string=#ref tiene demasiados parámetros (parámetro count={0}) #loc
anonymous.function.is.overly.complex.cyclomatic.complexity.error.string=#ref es demasiado complejo (complejidad ciclomática={0}) #loc
anonymous.function.is.overly.long.statement.error.string=#ref is too long (statement count={0}) #loc
anonymous.function.is.overly.nested.error.string=#ref está demasiado anidado (la profundidad de anidamiento es {0}, pero el máximo permitido es {1}) #loc
assignment.replaceable.with.operator.assignment.display.name=Asignación reemplazable por asignación de operador
assignment.replaceable.with.operator.assignment.error.string=#ref podría simplificarse a {0} #loc
assignment.to.for.loop.parameter.display.name=Asignación al parámetro de bucle 'for'
assignment.to.for.loop.parameter.error.string=Asignación al parámetro de bucle for #ref #loc
assignment.to.function.parameter.display.name=Asignación al parámetro de función
assignment.to.function.parameter.error.string=Asignación al parámetro de función '#ref' #loc
break.statement.display.name=declaración 'break'
break.statement.error.string='#ref' instrucción #loc
break.statement.with.label.display.name=declaración 'break' con etiqueta
break.statement.with.label.error.string=Declaración '#ref' con etiqueta #loc
call.to.document.write.display.name=Llamar a 'document.write()'
caller.display.name=Uso de la propiedad 'caller'
caller.error.string=Uso de la propiedad '#ref' #loc
chained.equality.display.name=Igualdad encadenada
chained.equality.error.string=Comparación de igualdad encadenada <code>#ref</code>#loc
chained.function.call.display.name=Llamada a función encadenada
chained.function.call.problem.descriptor=Llamada encadenada a la función '#ref' #loc
class.name.doesnt.match.regex.error.string=El nombre de la clase ''{0}'' no coincide con la expresión regular ''{1}'' #loc
class.name.is.too.long.error.string=El nombre de la clase ''{0}'' es demasiado largo #loc
class.name.is.too.short.error.string=El nombre de la clase ''{0}'' es demasiado corto #loc
class.naming.convention.display.name=Convención de nomenclatura de clases
collapse.conditional.expression.fix=Contraer expresión condicional
collapse.if.statement.fix=Contraer declaración 'if'
comma.expression.display.name=Expresión de coma
comma.expression.error.string=Expresión de coma #loc
conditional.expression.display.name=Expresión condicional
conditional.expression.error.string=Expresión condicional #loc
conditional.expression.with.identical.branches.display.name=Expresión condicional con ramas idénticas
conditional.expression.with.identical.branches.error.string=Expresión condicional #ref con ramas idénticas #loc
confusing.floating.point.literal.change.quickfix=Cambiar a forma canónica
confusing.floating.point.literal.display.name=Confuso literal de punto flotante
confusing.floating.point.literal.problem.descriptor=Confuso literal de coma flotante <code>#ref</code>#loc
confusing.pluses.or.minuses.display.name=Secuencia confusa de '+' o '-'
confusing.pluses.or.minuses.error.string=La secuencia de '+' o '-' puede cambiar de significado si se eliminan los espacios en blanco #loc
constant.conditional.expression.display.name=Expresión condicional constante
constant.conditional.expression.error.string=#ref se puede simplificar #loc
constant.on.left.side.of.comparison.display.name=Constante en el lado izquierdo de la comparación
constant.on.left.side.of.comparison.error.string=#ref: constante en el lado izquierdo de la comparación #loc
constant.on.right.side.of.comparison.display.name=Constante en el lado derecho de la comparación
constant.on.right.side.of.comparison.error.string=#ref: constante en el lado derecho de la comparación #loc
constructor.name.doesnt.match.regex.error.string=El nombre del constructor ''{0}'' no coincide con la expresión regular ''{1}'' #loc
constructor.name.is.too.long.error.string=El nombre del constructor ''{0}'' es demasiado largo #loc
constructor.name.is.too.short.error.string=El nombre del constructor ''{0}'' es demasiado corto #loc
continue.or.break.inside.finally.block.display.name=continuar' o 'romper' dentro del bloque 'finalmente
continue.or.break.inside.finally.block.error.string='#ref' inside 'finalmente' bloque #loc
continue.statement.display.name=declaración 'continue'
continue.statement.error.string='#ref' instrucción #loc
continue.statement.with.label.display.name=declaración 'continue' con etiqueta
continue.statement.with.label.error.string=Declaración '#ref' con etiqueta #loc
debugger.statement.display.name=declaración 'depurador'
debugger.statement.error.string='#ref' instrucción #loc
default.branch.not.last.case.in.switch.error.string=<code>#ref</code> rama no es el último caso en 'switch' #loc
default.not.last.case.in.switch.display.name=default' no es el último caso en 'switch
divide.by.zero.display.name=División por cero
division.by.zero.error.string=División por cero #loc
document.write.error.string=Llamar a '#ref()' #loc
duplicate.case.label.display.name=Etiqueta de caso duplicada
duplicate.case.label.error.string=Etiqueta de caso duplicada #ref #loc
duplicate.condition.error.string=Condición duplicada #ref #loc
duplicate.condition.in.if.statement.display.name=Condición duplicada en la declaración 'if'
dynamically.generated.code.display.name=Ejecución de JavaScript generado dinámicamente
dynamically.generated.code.error.string=Función '#ref' indicativa de código generado dinámicamente #loc
empty.catch.block.display.name=Bloque 'catch' vacío
empty.catch.block.error.string=Bloque '#ref' vacío #loc
empty.finally.block.display.name=Bloque 'finalmente' vacío
empty.finally.block.error.string=Bloque 'finalmente' vacío #loc
empty.try.block.display.name=Bloque vacío 'try'
empty.try.block.error.string=Bloque vacío '#ref' #loc
exception.caught.locally.error.string='#ref' de excepción capturada localmente #loc
exception.used.for.local.control.flow.display.name=Excepción utilizada para el flujo de control local
expression.statement.is.not.assignment.or.call.error.string=La declaración de expresión no es una asignación o llamada #loc
expression.statement.which.is.not.assignment.or.call.display.name=Declaración de expresión que no es asignación ni llamada
fall.through.in.switch.statement.display.name=Fallthrough en la declaración 'switch'
fall.through.in.switch.statement.error.string=Fallthrough en la declaración 'switch' #loc. Falta "descanso" o "retorno"
flip.comparison.fix=Comparación de volteo
for.loop.not.use.loop.variable.display.name='for' bucle donde la actualización o condición no usa la variable de bucle
for.loop.not.use.loop.variable.problem.descriptor.both.condition.and.update=<code>#ref</code> declaración tiene condición y actualización que no utiliza la variable de bucle for #loc
for.loop.not.use.loop.variable.problem.descriptor.condition=<code>#ref</code> La declaración tiene una condición que no utiliza la variable de bucle for #loc
for.loop.not.use.loop.variable.problem.descriptor.update=<code>#ref</code> La declaración tiene una actualización que no usa la variable de bucle for #loc
for.loop.replaceable.by.while.display.name='for' loop puede ser reemplazado por 'while' loop
for.loop.replaceable.by.while.ignore.option=Ignorar 'infinito' para bucles sin condiciones
for.loop.replaceable.by.while.problem.descriptor=<code>#ref</code> El bucle puede ser reemplazado por el bucle 'while' #loc
for.loop.replaceable.by.while.replace.quickfix=Reemplazar con 'while'
function.complexity.limit.parameter=Límite de complejidad de la función:
function.contains.multiple.loops.error.string=function ''#ref'' contiene {0} bucles #loc
function.contains.multiple.return.points.error.string=function ''#ref'' tiene {0} puntos de retorno #loc
function.contains.too.many.negation.error.string=function ''#ref'' contiene {0} negaciones #loc
function.has.inconsistent.return.points.error.string=function '#ref' tiene puntos de retorno inconsistentes #loc
function.has.too.many.parameters.error.string=function ''#ref'' tiene demasiados parámetros (parámetro count={0}) #loc
function.is.overly.long.statement.error.string=function ''#ref'' is too long (statement count={0}) #loc
function.is.overly.nested.error.string=function ''#ref'' está demasiado anidada (la profundidad de anidación es {0}, pero el máximo permitido es {1}) #loc
function.name.doesnt.match.regex.error.string=El nombre de la función ''{0}'' no coincide con la expresión regular ''{1}'' #loc
function.name.is.too.long.error.string=El nombre de la función ''{0}'' es demasiado largo #loc
function.name.is.too.short.error.string=El nombre de la función ''{0}'' es demasiado corto #loc
function.naming.convention.display.name=Convención de nomenclatura de funciones
function.parameter.limit=Límite de parámetro de función:
function.parameter.naming.convention.display.name=Convención de nomenclatura de parámetros de función
function.ref.is.overly.complex.cyclomatic.complexity.error.string=function ''#ref'' es demasiado compleja (complejidad ciclomática={0}) #loc
function.with.inconsistent.returns.display.name=Función con retornos inconsistentes
function.with.more.than.three.negations.display.name=Función con más de tres negaciones
function.with.multiple.loops.display.name=Función con múltiples bucles
function.with.multiple.return.points.display.name=Función con múltiples puntos de retorno
function.with.too.many.parameters.display.name=Función con demasiados parámetros
group.path.javascript=JavaScript
if.statement.with.identical.branches.display.name=declaración 'if' con ramas idénticas
if.statement.with.too.many.branches.display.name=declaración 'if' con demasiadas ramas
if.statement.with.too.many.branches.error.string=''#ref'' tiene demasiadas ramas ({0}) #loc
include.anonymous.functions.parameter=Incluir funciones anónimas
include.statement.bodies.that.are.empty.code.blocks.parameter=Incluir cuerpos de declaración que son bloques de código vacíos
incompatible.mask.operation.display.name=Operación de máscara bit a bit incompatible
incompatible.mask.operation.problem.descriptor.always.false=<code>#ref</code> es siempre falso #loc
incompatible.mask.operation.problem.descriptor.always.true=<code>#ref</code> es siempre verdadero #loc
infinite.loop.error.string=<code>#ref</code> declaración no puede completarse sin lanzar una excepción #loc
infinite.loop.statement.display.name=Declaración de bucle infinito
infinite.recursion.display.name=Recursión infinita
infinite.recursion.problem.descriptor=La función <code>#ref</code> se repite infinitamente, y solo puede terminar lanzando una excepción #loc
inner.html.error.string=uso de la propiedad '#ref' #loc
invert.condition.fix=Condición de inversión
invert.if.condition.fix=Invertir condición 'if'
javascript.dom.issues.group.name=Problemas de DOM
js.inspection.group.path=JavaScript and TypeScript
js.inspection.switch.group.name=Problemas con la declaración de cambio
labeled.statement.display.name=Declaración etiquetada
local.variable.naming.convention.display.name=Convención de nomenclatura de variables locales
loop.statement.that.doesn.t.loop.display.name=Declaración de bucle que no se repite
loop.statement.that.doesnt.loop.error.string=<code>#ref</code> declaración no se repite #loc
magic.number.display.name=Número mágico
magic.number.problem.descriptor=Número mágico '#ref' #loc
maximum.number.of.branches.parameter=Número máximo de ramas:
maximum.number.of.terms.parameter=Número máximo de términos:
maximum.statements.per.function=Máximo de declaraciones por función:
missing.return.statement.error.string=Falta la declaración de devolución #loc
negated.conditional.expression.display.name=Expresión condicional negada
negated.conditional.expression.error.string=Expresión condicional negada #loc
negated.if.statement.display.name=Declaración 'if' negada
negated.ref.statement.error.string=Declaración '#ref' negada #loc
nested.anonymous.function.error.string=Anidado #ref #loc
nested.assignment.display.name=Asignación anidada
nested.assignment.error.string=Asignación anidada <code>#ref</code>#loc
nested.conditional.expression.display.name=Expresión condicional anidada
nested.conditional.expression.error.string=Expresión condicional anidada #loc
nested.function.call.display.name=Llamada a función anidada
nested.function.call.problem.descriptor=Llamada anidada a la función '#ref' #loc
nested.function.display.name=Función anidada
nested.function.error.string=Función anidada '#ref' #loc
nested.switch.statement.display.name=Declaración 'switch' anidada
nested.switch.statement.error.string=Declaración '#ref' anidada #loc
nesting.depth.limit=Límite de profundidad de anidación:
non.block.body.error.string=<code>#ref</code> declaración tiene cuerpo sin bloque #loc
non.block.branch.error.string=<code>#ref</code> declaración tiene una rama no bloqueada #loc
non.block.statement.body.display.name=Cuerpo de la declaración no bloqueada
octal.integer.display.name=Entero octal
overly.complex.arithmetic.expression.display.name=Expresión aritmética demasiado compleja
overly.complex.arithmetic.expression.error.string=Expresión aritmética demasiado compleja #loc
overly.complex.boolean.expression.display.name=Expresión booleana demasiado compleja
overly.complex.boolean.expression.error.string=Expresión booleana demasiado compleja #loc
overly.complex.function.display.name=Función demasiado compleja
overly.long.function.display.name=Función demasiado larga
overly.nested.function.display.name=Función demasiado anidada
parameter.name.doesnt.match.regex.error.string=El nombre del parámetro ''#ref'' no coincide con la expresión regular ''{0}'' #loc
parameter.name.is.too.long.error.string=El nombre del parámetro '#ref' es demasiado largo #loc
parameter.name.is.too.short.error.string=El nombre del parámetro '#ref' es demasiado corto #loc
platform.detection.display.name=Detección de plataforma
platform.detection.error.string='#ref' probablemente se use para la detección de plataforma #loc
pointless.arithmetic.error.message=#ref se puede reemplazar con {0} #loc
pointless.arithmetic.expression.display.name=Expresión aritmética sin sentido
pointless.bitwise.expression.display.name=Expresión bit a bit sin sentido
pointless.bitwise.expression.ignore.option=Ignorar la constante nombrada al determinar expresiones sin sentido
pointless.bitwise.expression.problem.descriptor=''{1}'' se puede reemplazar con ''{0}'' #loc
pointless.bitwise.expression.simplify.quickfix=Simplificar
pointless.boolean.error.string=Puede simplificarse a {0} #loc
pointless.boolean.expression.display.name=Declaración sin sentido o expresión booleana
pointless.statement.error.string={0} declaración se puede simplificar #loc
redundant.conditional.expression.display.name=Expresión condicional redundante
redundant.if.statement.display.name=Declaración redundante 'if'
redundant.local.variable.display.name=Variable local redundante
redundant.local.variable.ignore.option=Ignorar variables devueltas o lanzadas inmediatamente
redundant.local.variable.quickfix=Variable en línea
ref.statement.with.identical.branches.error.string=<code>#ref</code> declaración con ramas idénticas #loc
remove.label.fix=Eliminar etiqueta
remove.unnecessary.continue.fix=Eliminar innecesario continuar
remove.unnecessary.return.fix=Eliminar return innecesaria
rename.fix=Cambiar nombre
replace.redundant.await.family.name=Reemplazar redundante await
replace.with.operator.assign.fix=Reemplazar=con {0} =
reserved.word.used.as.name.display.name=Palabra reservada utilizada como nombre
reserved.word.used.as.name.error.string=Palabra reservada '#ref' utilizada como nombre
result.of.assignment.expression.used.error.string=Resultado de la expresión de asignación usada #loc
result.of.assignment.used.displayName=Resultado de la asignación utilizada
result.of.increment.or.decrement.expression.used.error.string=Resultado de la expresión de incremento o decremento utilizada #loc
result.of.increment.or.decrement.used.display.name=Resultado del incremento o decremento utilizado
result.of.object.allocation.ignored.display.name=Resultado de la asignación del objeto ignorado
result.of.object.allocation.ignored.error.string=El resultado de <code>new #ref()</code> se ignora #loc
return.inside.finally.block.display.name=return' dentro del bloque 'finalmente
return.inside.finally.block.error.string='#ref' dentro del bloque 'finalmente' #loc
reuse.of.local.variable.display.name=Reutilización de variable local
reuse.of.local.variable.problem.descriptor=Reutilización de la variable local <code>#ref</code>#loc
set.return.type.to.void.fix.name=Establecer el tipo de retorno en void
shift.operation.by.inappropriate.constant.display.name=Operación de cambio por constante inapropiada
shift.operation.by.inappropriate.constant.problem.descriptor.negative=Operación de cambio <code>#ref</code> por valor constante negativo #loc
shift.operation.by.inappropriate.constant.problem.descriptor.too.large=Operación de cambio <code>#ref</code> por un valor constante demasiado grande #loc
shift.out.of.range.family.name=Modificar el valor de turno
silly.assignment.display.name=La variable se asigna a sí misma
silly.assignment.error.string=Variable asignada a sí misma #loc
simplify.fix=Simplificar
statement.has.empty.body.error.string=<code>#ref</code> declaración tiene cuerpo vacío #loc
statement.has.empty.branch.error.string=<code>#ref</code> La declaración tiene una rama vacía #loc
statement.label.error.string=Etiqueta de declaración '#ref' #loc
statement.simplify.quickfix=Simplificar declaración
statement.with.empty.body.display.name=Declaración con cuerpo vacío
string.literal.breaks.html.display.name=Literal de cadena que rompe el análisis de HTML
string.literal.breaks.html.error.string=El literal de cadena #ref puede romper los analizadores HTML #loc
tail.recursion.display.name=Recursión de cola
tail.recursion.problem.descriptor=Recursión de cola #loc
terminate.statement.fix=Terminar sentencia
text.label.in.switch.statement.display.name=Etiqueta de texto en la declaración 'switch'
text.label.in.switch.statement.error.string=Etiqueta de texto <code>#ref:</code> en la declaración 'switch' #loc
this.expression.references.global.object.error.string=Expresión '#ref' de nivel superior #loc
this.expression.which.references.the.global.object.display.name='this' expresión que hace referencia al objeto global
throw.inside.finally.block.display.name=lanzar' dentro del bloque 'finalmente
throw.inside.finally.block.error.string='#ref' dentro del bloque 'finalmente' #loc
trivial.conditional.error.string=''{0}'' se puede simplificar a ''{1}'' #loc
trivial.if.error.string=La sentencia #ref se puede simplificar #loc
typeof.using.incorrect.case.display.name=Tipo de comparación con valor no estándar
typeof.using.incorrect.case.error=tipo de comparación con valor no estándar
typeof.using.incorrect.convert=Convertir a {0}
typeof.using.incorrect.family.name=Convertir a valor estándar
unnecessary.block.statement.display.name=Declaración de 'bloque' innecesaria
unnecessary.block.statement.error.string=Declaración de bloque innecesaria #loc
unnecessary.continue.error.string=#ref es innecesario como la última declaración en un bucle #loc
unnecessary.continue.statement.display.name=Declaración innecesaria 'continuar'
unnecessary.label.display.name=Etiqueta innecesaria
unnecessary.label.error.string=Etiqueta innecesaria #ref #loc
unnecessary.label.on.break.error.string=declaración '#ref' con etiqueta innecesaria #loc
unnecessary.label.on.break.statement.display.name=Etiqueta innecesaria en la declaración 'break'
unnecessary.label.on.continue.error.string=declaración '#ref' con etiqueta innecesaria #loc
unnecessary.label.on.continue.statement.display.name=Etiqueta innecesaria en la declaración 'continuar'
unnecessary.local.variable.problem.descriptor=La variable local ''{0}'' es redundante
unnecessary.return.error.string=#ref es innecesario como la última declaración en una función sin valor de retorno #loc
unnecessary.return.statement.display.name=Declaración de 'retorno' innecesaria
unreachable.code.display.name=Código inalcanzable
unreachable.code.error.string=Código inalcanzable #loc
unterminated.statement.display.name=Declaración no terminada
unterminated.statement.error.string=Sentencia no terminada #loc
unterminated.statement.ignore.atend.of.block=Permitir la ausencia de punto y coma al final del bloque
unterminated.statement.possibly.unterminated.statement.error=Declaración posiblemente no terminada #loc
unused.catch.parameter.display.name=Parámetro 'catch' no utilizado
unused.catch.parameter.ignore.catch.option=Ignorar los bloques de captura que contienen comentarios
unused.catch.parameter.problem.descriptor=Parámetro de captura no utilizado <code>#ref</code>#loc
use.of.innerhtml.property.display.name=Uso de la propiedad 'innerHTML'
variable.name.doesnt.match.regex.error.string=El nombre de la variable ''#ref'' no coincide con la expresión regular ''{0}'' #loc
variable.name.is.too.long.error.string=El nombre de la variable '#ref' es demasiado largo #loc
variable.name.is.too.short.error.string=El nombre de la variable '#ref' es demasiado corto #loc
void.expression.display.name=expresión 'void'
void.expression.error.string='#ref' expresión #loc
with.expression.error.string='#ref' instrucción #loc
with.statement.display.name=declaración 'with'
wrap.statement.body.fix=Ajustar el cuerpo de la declaración
xhtml.incompatabilities.error.string='#ref' puede producir resultados inconsistentes para documentos XHTML #loc
xhtml.incompatibilities.display.name=Incompatibilidades XHTML
