cast.to.concrete.class.problem.descriptor=Transmitir a clase concreta <code>{0}</code> #loc
class.references.subclass.display.name=La clase hace referencia a una de sus subclases
class.references.subclass.problem.descriptor=Class ''{0}'' hace referencia a la subclase <code>#ref</code> #loc
class.references.subclass.problem.descriptor.anonymous=Referencias de clase anónimas subclase <code>#ref</code> #loc
collection.declared.by.class.display.name=Colección declarada por clase, no por interfaz
collection.declared.by.class.problem.descriptor=La declaración de <code>#ref</code> probablemente debería debilitarse a ''{0}'' #loc
collection.declared.by.class.ignore.locals.option=Ignorar variables locales
collection.declared.by.class.ignore.private.members.option=Ignorar campos y métodos 'privados'
feature.envy.display.name=Característica envidia
feature.envy.problem.descriptor=Clase ''{0}'' a la que se accede repetidamente en el método <code>#ref()</code> #loc
bounded.wildcard.display.name=Puede usar comodines acotados
bounded.wildcard.contravariant.descriptor=¿Se puede generalizar a <code>? super#ref</code> #loc
bounded.wildcard.covariant.descriptor=¿Se puede generalizar a <code>? extiende#ref</code> #loc
bounded.wildcard.report.invariant.option=Informar clases invariantes
bounded.wildcard.report.private.option=Informar métodos privados
bounded.wildcard.report.instance.option=Métodos de instancia de informe
instance.variable.of.concrete.class.problem.descriptor=El tipo de campo ''{0}'' es clase concreta <code>#ref</code> #loc
chain.of.instanceof.checks.display.name=Cadena de comprobaciones 'instanceof'
chain.of.instanceof.checks.problem.descriptor=La cadena de comprobaciones 'instanceof' indica falla de abstracción #loc
chain.of.class.equality.checks.problem.descriptor=La cadena de comprobaciones de igualdad de clases indica un fallo de abstracción #loc
instanceof.concrete.class.problem.descriptor='instancia de' clase concreta <code>#ref</code> #loc
instanceof.concrete.class.equality.problem.descriptor=Comparación de clases contra clases concretas <code>#ref</code> #loc
instanceof.check.for.this.display.name=Instancia de' verificar 'esto
instanceof.check.for.this.problem.descriptor='instancia de' verificar <code>#ref</code> #loc
instanceof.check.for.this.equality.problem.descriptor=Comparación de clases para 'esto' #loc
local.variable.of.concrete.class.problem.descriptor=Variable local ''{0}'' de clase concreta <code>#ref</code> #loc
magic.number.display.name=Número mágico
magic.number.problem.descriptor=Número mágico <code>#ref</code> #loc
concrete.class.use.display.name=Uso de clase concreta.
method.return.concrete.class.problem.descriptor=El método devuelve una clase concreta <code>#ref</code> #loc
overly.strong.type.cast.display.name=Reparto de tipo demasiado fuerte
overly.strong.type.cast.weaken.quickfix=Debilitar elenco demasiado fuerte
concrete.class.method.parameter.problem.descriptor=Parámetro ''{0}'' de la clase concreta <code>#ref</code> #loc
public.method.not.in.interface.display.name=Método 'público' no expuesto en la interfaz
public.method.not.in.interface.problem.descriptor=El método 'public' <code>#ref()</code> no se expone a través de una interfaz #loc
public.method.not.in.interface.option=<html>Ignorar si la clase contenedora no implementa una interfaz que no sea de biblioteca</html>
static.variable.of.concrete.class.problem.descriptor=Campo estático ''{0}'' de clase concreta <code>#ref</code> #loc
incompatible.mask.operation.display.name=Operación de máscara bit a bit incompatible
incompatible.mask.operation.problem.descriptor.always.false=<code>#ref</code> es siempre falso #loc
incompatible.mask.operation.problem.descriptor.always.true=<code>#ref</code> es siempre verdadero #loc
pointless.bitwise.expression.display.name=Expresión bit a bit sin sentido
pointless.bitwise.expression.simplify.quickfix=Simplificar
shift.operation.by.inappropriate.constant.display.name=Operación de cambio por constante inapropiada
shift.operation.by.inappropriate.constant.problem.descriptor.too.large=Operación de cambio <code>#ref</code> por un valor constante demasiado grande {0}#loc
shift.operation.by.inappropriate.constant.problem.descriptor.negative=Operación de cambio <code>#ref</code> por valor constante negativo {0}#loc
shift.operation.by.inappropriate.constant.problem.descriptor.out.of.bounds=Operación de cambio <code>#ref</code> por valor fuera de límites {0}#loc
equals.called.on.array.display.name='equals()' llamado en la matriz
equals.called.on.array.problem.descriptor=<code>#ref()</code> entre matrices probablemente debería ser 'Arrays.equals()' #loc
assignment.to.null.display.name=Asignación 'nula'
assignment.to.null.problem.descriptor='nulo' asignado a la variable <code>#ref</code> #loc
assignment.to.null.option=Ignorar asignaciones a campos
assignment.to.static.field.from.instance.method.display.name=Asignación a un campo estático desde el contexto de la instancia
assignment.to.static.field.from.instance.method.problem.descriptor=Asignación al campo estático <code>#ref</code> desde el contexto de la instancia #loc
assignment.used.as.condition.display.name=Asignación utilizada como condición
assignment.used.as.condition.problem.descriptor=Asignación <code>#ref</code> usada como condición #loc
cast.conflicts.with.instanceof.display.name=Cast entra en conflicto con 'instanceof'
cast.conflicts.with.instanceof.problem.descriptor=Cast <code>#ref</code> entra en conflicto con la comprobación 'instanceof' #loc circundante
casting.to.incompatible.interface.display.name=Transmitiendo a una interfaz incompatible
casting.to.incompatible.interface.problem.descriptor=Pase interfaz incompatible <code>#ref</code> #loc
collection.added.to.self.display.name=Colección agregada a uno mismo
collection.added.to.self.problem.descriptor=''{0}()'' llamado en la colección <code>#ref</code> con él mismo como argumento #loc
non.final.field.compareto.display.name=Campo no final referenciado en 'compareTo()'
non.final.field.compareto.problem.descriptor=Campo no final <code>#ref</code> al que se accede en 'compareTo()' #loc
covariant.equals.display.name=Covariante 'igual()'
covariant.equals.problem.descriptor=<code>#ref()</code> debe tomar 'Objeto' como argumento #loc
empty.class.initializer.display.name=Inicializador de clase vacía
empty.class.initializer.problem.descriptor=Inicializador de clase vacía #loc
empty.class.initializer.delete.quickfix=Eliminar inicializador de clase vacío
statement.with.empty.body.display.name=Declaración con cuerpo vacío
statement.with.empty.body.problem.descriptor=<code>#ref</code> declaración tiene cuerpo vacío #loc
statement.with.empty.body.include.option=Incluir cuerpos de declaración que son bloques de código vacíos
equals.between.inconvertible.types.display.name='equals()' entre objetos de tipos inconvertibles
equals.between.inconvertible.types.problem.descriptor=<code>#ref</code> entre objetos de tipos inconvertibles ''{0}'' y ''{1}'' #loc
equals.between.inconvertible.types.no.mutual.subclass.problem.descriptor=No se encontró ninguna clase que sea un subtipo de ''{0}'' y ''{1}'' #loc
equals.between.inconvertible.types.mutual.subclass.option=Advertir si no se encuentra ninguna subclase mutua
equals.called.on.suspicious.object.display.name='equals()' llamado en StringBuilder
equals.called.on.suspicious.object.problem.descriptor=Llamada sospechosa '' es igual a '' en el objeto ''{0}''
non.final.field.in.equals.display.name=Campo no final referenciado en 'equals()'
non.final.field.in.equals.problem.descriptor=Campo no final <code>#ref</code> al que se accede en 'equals()' #loc
equals.doesnt.check.class.parameter.display.name=Método 'equals()' que no verifica la clase de parámetro
equals.doesnt.check.class.parameter.problem.descriptor=<code>#ref()</code> debe verificar la clase de su parámetro #loc
non.final.field.in.hashcode.display.name=Campo no final referenciado en 'hashCode()'
non.final.field.in.hashcode.problem.descriptor=Campo no final <code>#ref</code> al que se accede en 'hashCode()' #loc
result.of.method.call.ignored.display.name=Resultado de la llamada al método ignorado
write.only.object.display.name=Objeto de solo escritura
write.only.object.option.ignore.impure.constructors=Ignorar constructores impuros
result.of.method.call.ignored.problem.descriptor=El resultado de <code>{0}. #ref()</code> se ignora #loc
result.of.method.call.ignored.class.column.title=Nombre de la clase
result.of.method.call.ignored.method.column.title=Nombre del método regex
result.of.method.call.ignored.non.library.option=Informar todas las llamadas ignoradas que no pertenecen a la biblioteca
infinite.recursion.display.name=Recursión infinita
infinite.recursion.problem.descriptor=El método <code>#ref()</code> se repite infinitamente y solo puede terminar lanzando una excepción #loc
instanceof.with.incompatible.interface.display.name='instanceof' con interfaz incompatible
instanceof.with.incompatible.interface.problem.descriptor='instancia de' interfaz incompatible <code>#ref</code> #loc
instantiation.utility.class.display.name=Creación de instancias de la clase de utilidad
instantiation.utility.class.problem.descriptor=Instanciación de la clase de utilidad <code>#ref</code> #loc
iterator.hasnext.which.calls.next.display.name=Iterator.hasNext()' que llama a 'next()
iterator.hasnext.which.calls.next.problem.descriptor=<code>Iterator. {0}()</code> contiene la llamada a ''#ref()'' #loc
iterator.next.does.not.throw.nosuchelementexception.display.name=Iterator.next()' que no puede lanzar 'NoSuchElementException
malformed.format.string.display.name=Cadena de formato incorrecto
malformed.format.string.problem.descriptor.malformed=La cadena de formato <code>#ref</code> está mal formada #loc
malformed.format.string.problem.descriptor.illegal=Especificador de cadena de formato ilegal:{0}#loc
malformed.format.string.problem.descriptor.too.many.arguments=Demasiados argumentos para la cadena de formato (encontrado: {0}, esperado: {1}) #loc
malformed.format.string.problem.descriptor.too.few.arguments=Muy pocos argumentos para la cadena de formato (encontrado: {0}, esperado: {1}) #loc
malformed.format.string.problem.descriptor.arguments.do.not.match.type=El tipo de argumento ''{0}'' no coincide con el tipo del especificador de formato ''{1}'' #loc
format.string.error.flags.not.allowed={2, choice, 1#flag | 1 <flags} ''{0}'' no permitido en ''{1}''
format.string.error.unexpected.flag=Carácter inesperado ''{0}'' en ''{1}''
format.string.error.duplicate.flag=Bandera duplicada ''{0}'' en ''{1}''
format.string.error.width.not.allowed=Width (''{0}'') no permitido en ''{1}''
format.string.error.precision.not.allowed=Precisión (''{0}'') no permitido en ''{1}''
format.string.error.unnecessary.position.specifier=Especificador de posición de argumento innecesario ''{0}'' en ''{1}''
format.string.error.illegal.position.specifier=Especificador de posición ilegal ''{0}'' en ''{1}''
format.string.error.previous.element.not.found=Bandera anterior '' <'' utilizada pero no se encontró un especificador de formato anterior para ''{0}''
format.string.error.unknown.conversion=Conversión desconocida en ''{0}''
format.string.error.invalid.precision=Precisión no válida especificada en ''{0}''
format.string.error.illegal.flag.combination=Combinación de bandera ilegal ''{0}'' y ''{1}'' en ''{2}''
format.string.error.left.justify.no.width=Indicador de justificación a la izquierda '' - '' usado pero ancho no especificado en ''{0}''
format.string.error.zero.padding.no.width=Marca de relleno cero ''0'' usada pero ancho no especificado en ''{0}''
mismatched.read.write.array.display.name=Lectura y escritura de matriz no coincidentes
mismatched.read.write.array.problem.descriptor.write.not.read=El contenido de la matriz <code>#ref</code> se escribe, pero nunca se lee #loc
mismatched.read.write.array.problem.descriptor.read.not.write=El contenido de la matriz <code>#ref</code> se lee, pero nunca se escribe en #loc
mismatched.update.collection.display.name=Consulta y actualización de colección no coincidentes
mismatched.update.collection.problem.descriptor.updated.not.queried=El contenido de la colección <code>#ref</code> se actualizó, pero nunca se consultó #loc
mismatched.update.collection.problem.description.queried.not.updated=Se consulta el contenido de la colección <code>#ref</code>, pero nunca se actualiza #loc
rename.quickfix=Cambiar nombre
renameto.quickfix=Cambiar nombre a ''{0}''
misspelled.equals.display.name=Equal()' en lugar de 'equals()
misspelled.equals.problem.descriptor=<code>#ref()</code> método probablemente debería ser 'equals()' #loc
non.short.circuit.boolean.expression.display.name=Expresión booleana sin cortocircuito
non.short.circuit.boolean.expression.problem.descriptor=Expresión booleana sin cortocircuito <code>#ref</code> #loc
non.short.circuit.boolean.expression.replace.quickfix=Reemplazar con expresión de cortocircuito
null.argument.to.var.arg.method.display.name=Argumento confuso para el método varargs
null.argument.to.var.arg.method.problem.descriptor=Argumento confuso <code>#ref</code>, no está claro si se desea una llamada varargs o no varargs #loc
primitive.array.argument.to.var.arg.method.display.name=Argumento de matriz primitivo confuso con el método varargs
primitive.array.argument.to.var.arg.method.problem.descriptor=Argumento de matriz primitivo confuso para el método varargs #loc
object.comparison.display.name=Comparación de objetos usando '==', en lugar de 'equals()'
object.comparison.enumerated.ignore.option=Ignorar '==' entre las variables de enumeración
object.comparison.klass.ignore.option=Ignorar '==' entre los tipos de clases finales sin la implementación de 'equals()'
object.comparison.problem.description=Los valores de los objetos se comparan usando <code>#ref</code>, no 'equals()' #loc
equality.to.safe.equals.quickfix=Reemplazar '==' con nulo seguro 'equals()'
inequality.to.safe.not.equals.quickfix=Reemplazar '! =' con null-safe '! equals()'
default.tostring.call.display.name=Llamar al valor predeterminado 'toString()'
default.tostring.call.problem.descriptor=Llamar al 'toString()' predeterminado en <code>#ref</code> #loc
octal.and.decimal.integers.in.same.array.display.name=Enteros octales y decimales en la misma matriz
octal.and.decimal.integers.in.same.array.problem.descriptor=Enteros octales y decimales en el mismo inicializador de matriz #loc
result.of.object.allocation.ignored.display.name=Resultado de la asignación del objeto ignorado
result.of.object.allocation.ignored.problem.descriptor=El resultado de <code>new #ref()</code> se ignora #loc
result.of.object.allocation.ignored.options.chooserTitle=Seleccione una clase que pueda ignorar la asignación de objetos
result.of.object.allocation.fix.name=Ignorar la asignación de objetos de tipo ''{0}''
use.0index.in.jdbc.resultset.display.name=Uso del índice 0 en JDBC ResultSet
use.0index.in.jdbc.resultset.problem.descriptor=Uso del índice '0' en JDBC ResultSet #loc
use.0index.in.jdbc.prepared.statement.problem.descriptor=Uso del índice '0' en JDBC PreparedStatement #loc
return.of.null.display.name=Devolución de 'nulo'
return.of.null.problem.descriptor=Devolución de <code>#ref</code> #loc
return.of.null.arrays.option=Métodos de informe que devuelven matrices
return.of.null.objects.option=Métodos de informe que devuelven objetos
return.of.null.collections.option=Métodos de informe que devuelven objetos de colección
return.of.null.ignore.private.option=Ignorar métodos 'privados', clases anónimas \\& lambda
static.method.via.subclass.display.name=Método estático referenciado a través de una subclase
static.method.via.subclass.problem.descriptor=Método estático <code>#ref()</code> declarado en la clase ''{0}'' pero referenciado mediante la subclase ''{1}'' #loc
static.method.via.subclass.rationalize.quickfix=Racionalizar la llamada al método estático
static.field.via.subclass.display.name=Campo estático referenciado mediante subclase
static.field.via.subclass.problem.descriptor=Campo estático <code>#ref</code> declarado en la clase ''{0}'' pero referenciado mediante la subclase ''{1}'' #loc
static.field.via.subclass.rationalize.quickfix=Racionalizar el acceso al campo estático
string.comparison.display.name=Comparación de cadenas usando '==', en lugar de 'equals()'
number.comparison.display.name=Comparación de números usando '==', en lugar de 'equals()'
string.comparison.problem.descriptor=Los valores de cadena se comparan usando <code>#ref</code>, no 'equals()' #loc
number.comparison.problem.descriptor=Los objetos numéricos se comparan usando <code>#ref</code>, no 'equals()' #loc
subtraction.in.compareto.display.name=Resta en 'compareTo()'
subtraction.in.compareto.problem.descriptor=La resta <code>#ref</code> en 'compareTo()' puede resultar en desbordamiento o pérdida de precisión #loc
text.label.in.switch.statement.display.name=Etiqueta de texto en la declaración 'switch'
text.label.in.switch.statement.problem.descriptor=Etiqueta de texto <code> #ref:</code> en ''cambiar'' {0,choice, 1#declaración | 2#expresión} #loc
properties.object.as.hashtable.display.name=Uso del objeto Propiedades como Hashtable
properties.object.as.hashtable.problem.descriptor=Llamada a <code> Hashtable. #ref()</code> en el objeto de propiedades #loc
assignment.replaceable.with.operator.assignment.display.name=Asignación reemplazable por asignación de operador
unnecessary.code.block.display.name=Bloque de código innecesario
unnecessary.code.block.unwrap.quickfix=Desenvolver bloque
redundant.local.variable.display.name=Variable local redundante
redundant.local.variable.ignore.option=Ignorar variables devueltas o lanzadas inmediatamente
redundant.local.variable.annotation.option=Ignorar las variables que tienen una anotación
static.collection.display.name=Colección estática
static.collection.problem.descriptor=Colección estática <code>#ref</code> #loc
static.collection.ignore.option=Ignorar colecciones o mapas estáticos débiles
stringbuffer.field.display.name=Campo StringBuilder
stringbuffer.field.problem.descriptor=''{0}'' campo <code>#ref</code> #loc
gc.call.display.name=Llamadas a 'System.gc()' o 'Runtime.gc()'
gc.call.problem.descriptor=<code>#ref</code> no se debe llamar en el código de producción #loc
array.allocation.zero.length.display.name=Asignación de matriz de longitud cero
array.allocation.zero.length.problem.descriptor=Asignación de matriz de longitud cero #loc
constant.for.zero.length.array.display.name=Uso innecesario de matriz de longitud cero
constant.for.zero.length.array.problem.descriptor=La matriz de longitud cero se puede cambiar a constante #loc
constant.for.zero.length.array.quickfix.family=Reemplazar con constante
multiple.loggers.display.name=Clase con varios registradores
logger.name.option=Registrador y nombre de clase:
multiple.loggers.problem.descriptor=Class <code>#ref</code> declara múltiples registradores #loc
no.logger.display.name=Clase sin registrador
no.logger.problem.descriptor=Class <code>#ref</code> no declara un registrador #loc
non.constant.logger.display.name=Registrador no constante
non.constant.logger.problem.descriptor=Campo de registrador no constante <code>#ref</code> #loc
public.method.without.logging.display.name=Método 'público' sin registro
public.method.without.logging.problem.descriptor=El método 'public' <code>#ref()</code> no tiene una llamada de registro #loc
ignore.trivial.finalizers.option=Ignorar las implementaciones triviales de 'finalize()'
finalize.declaration.display.name=Declaración 'finalize()'
finalize.declaration.problem.descriptor=<code>#ref()</code> declarado #loc
finalize.not.declared.protected.display.name=Finalize()' no declarado 'protegido
finalize.not.declared.protected.problem.descriptor=<code>#ref()</code> no declarado 'protegido' #loc
finalize.called.explicitly.display.name='finalize()' llamado explícitamente
finalize.called.explicitly.problem.descriptor=<code>#ref()</code> llamado explícitamente #loc
java.lang.import.display.name=Importación 'java.lang'
java.lang.import.problem.descriptor=Importación innecesaria del paquete 'java.lang' #loc
import.display.name=Importar '*'
import.problem.descriptor=Importación de paquete <code>#ref</code> #loc
import.from.same.package.display.name=Importar desde el mismo paquete
import.from.same.package.problem.descriptor=Importación innecesaria desde el mismo paquete <code>#ref</code> #loc
single.class.import.display.name=Importación de clase única
single.class.import.problem.descriptor=Importación de clase única <code>#ref</code> #loc
static.import.display.name=Importación estática
static.import.problem.descriptor=Importación estática <code>#ref</code> #loc
static.import.replace.quickfix=Reemplazar con importación no estática
static.import.fix.ignore.class=Permitir declaración de importación estática de la clase ''{0}''
static.import.options.border.title=Clases importables estáticamente
static.import.options.chooserTitle=Seleccionar clases importables estáticamente
unused.import.problem.descriptor=Importación no utilizada <code>#ref</code> #loc
clone.instantiates.objects.with.constructor.display.name='clone()' crea una instancia de los objetos con el constructor
clone.instantiates.objects.with.constructor.problem.descriptor='clone()' crea nuevas instancias de <code>#ref</code> #loc
clone.instantiates.new.array.problem.descriptor=''clone()'' crea una nueva matriz {0}#loc
clone.doesnt.declare.clonenotsupportedexception.display.name=Clone()' no declara 'CloneNotSupportedException
clone.doesnt.declare.clonenotsupportedexception.problem.descriptor=<code>#ref()</code> #loc no declara 'CloneNotSupportedException'
clone.doesnt.declare.clonenotsupportedexception.declare.quickfix=Agregue 'CloneNotSupportedException' a la cláusula de lanzamientos
clone.method.in.non.cloneable.class.display.name=Método 'clone()' en una clase no clonable
clone.method.in.non.cloneable.class.problem.descriptor=<code>#ref()</code> definido en la clase no clonable ''{0}'' #loc
clone.method.in.non.cloneable.anonymous.class.problem.descriptor=<code>#ref()</code> definido en una clase anónima no clonable derivada de ''{0}'' #loc
clone.method.in.non.cloneable.interface.problem.descriptor=<code>#ref()</code> definido en la interfaz no clonable ''{0}'' #loc
cloneable.class.without.clone.display.name=Clase clonable sin método 'clone()'
cloneable.class.without.clone.problem.descriptor=<code>#ref</code> no define 'clone()' #loc
cloneable.class.without.clone.ignore.option=Ignorar clases clonables debido a herencia
cloneable.class.without.clone.quickfix=Generar método 'clone()'
use.obsolete.collection.type.display.name=Uso de tipo de colección obsoleto
use.obsolete.collection.type.problem.descriptor=Tipo de colección obsoleto <code>#ref</code> usado #loc
use.obsolete.collection.type.ignore.library.arguments.option=Ignore los tipos de colección obsoletos cuando sean necesarios
inspection.suppression.annotation.display.name=Anotación de supresión de inspección
inspection.suppression.annotation.problem.descriptor=Anotación de supresión de inspección <code>#ref</code> #loc
use.system.out.err.display.name=Uso de System.out o System.err
use.system.out.err.problem.descriptor=Los usos de <code>#ref</code> probablemente deberían reemplazarse con un registro más sólido #loc
dumpstack.call.display.name=Llamada a 'Thread.dumpStack()'
dumpstack.call.problem.descriptor=Llamada a <code> Thread. #ref()</code> probablemente debería reemplazarse con un registro más robusto #loc
printstacktrace.call.display.name=Llamar a 'printStackTrace()'
printstacktrace.call.problem.descriptor=La llamada a <code>#ref()</code> probablemente debería reemplazarse con un registro más sólido #loc
abstract.method.call.in.constructor.display.name=Método abstracto llamado durante la construcción del objeto
abstract.method.call.in.constructor.problem.descriptor=Llamada al método 'abstracto' <code>#ref()</code> durante la construcción del objeto #loc
instance.variable.may.not.be.initialized.display.name=El campo de instancia no se puede inicializar
instance.variable.may.not.be.initialized.problem.descriptor=El campo de instancia <code>#ref</code> puede no inicializarse durante la construcción del objeto #loc
instance.Variable.may.not.be.initialized.problem.descriptor.junit=El campo de instancia <code>#ref</code> no se puede inicializar durante la construcción del objeto o la llamada 'setUp()' #loc
primitive.fields.ignore.option=Ignorar campos primitivos
instance.variable.used.before.initialized.display.name=Campo de instancia usado antes de la inicialización
instance.variable.used.before.initialized.problem.descriptor=Campo de instancia <code>#ref</code> usado antes de inicializado #loc
non.final.static.variable.initialization.display.name=El campo estático no final se usa durante la inicialización de la clase
non.final.static.variable.initialization.problem.descriptor=Campo estático no final <code>#ref</code> utilizado durante la inicialización de la clase #loc
overridable.method.call.in.constructor.display.name=Método reemplazable llamado durante la construcción del objeto
overridable.method.call.in.constructor.problem.descriptor=Llamada al método reemplazable <code>#ref()</code> durante la construcción del objeto #loc
overridden.method.call.in.constructor.display.name=Método anulado llamado durante la construcción del objeto
overridden.method.call.in.constructor.problem.descriptor=Llamada al método reemplazado <code>#ref()</code> durante la construcción del objeto #loc
static.variable.may.not.be.initialized.display.name=El campo estático no se puede inicializar
static.variable.may.not.be.initialized.problem.descriptor=El campo estático <code>#ref</code> no se puede inicializar durante la inicialización de la clase #loc
static.variable.used.before.initialization.display.name=Campo estático usado antes de la inicialización
static.variable.used.before.initialization.problem.descriptor=Campo estático <code>#ref</code> usado antes de la inicialización #loc
this.reference.escaped.in.construction.display.name='this' referencia escapada en la construcción del objeto
this.reference.escaped.in.construction.problem.descriptor=Escape de <code>#ref</code> durante la construcción del objeto #loc
assignment.to.catch.block.parameter.display.name=Asignación al parámetro del bloque de captura
extract.parameter.as.local.variable.quickfix=Extraer parámetro como variable local
assignment.to.for.loop.parameter.display.name=Asignación al parámetro de bucle 'for'
assignment.to.for.loop.parameter.check.foreach.option=Verifique los parámetros mejorados de bucle 'for'
assignment.to.for.loop.parameter.problem.descriptor=Asignación al parámetro de bucle for <code>#ref</code> #loc
assignment.to.method.parameter.display.name=Asignación al parámetro del método
chained.equality.comparisons.display.name=Comparaciones encadenadas de igualdad
confusing.octal.escape.sequence.display.name=Secuencia de escape octal confusa
increment.decrement.display.name=Valor de ++ o - usado
nested.assignment.display.name=Resultado de la asignación utilizada
nested.assignment.problem.descriptor=Resultado de la expresión de asignación utilizada #loc
overloaded.methods.with.same.number.parameters.display.name=Métodos sobrecargados con el mismo número de parámetros
overloaded.vararg.method.display.name=Método varargs sobrecargado
refused.bequest.display.name=El método no llama al súper método
reuse.of.local.variable.display.name=Reutilización de variable local
reuse.of.local.variable.split.quickfix=Dividir variable local
character.comparison.display.name=Comparación de personajes
character.comparison.problem.descriptor=Comparación de caracteres <code>#ref</code> en un contexto internacionalizado #loc
package.visible.field.display.name=Campo visible del paquete
package.visible.field.problem.descriptor=Campo visible del paquete <code>#ref</code> #loc
package.visible.inner.class.display.name=Clase anidada visible al paquete
package.visible.inner.class.problem.descriptor=Clase anidada visible al paquete <code>#ref</code> #loc
package.visible.inner.class.ignore.enum.option=Ignorar enumeraciones internas visibles del paquete
package.visible.inner.class.ignore.interface.option=Ignorar interfaces internas visibles para paquetes
protected.field.display.name=Campo protegido
protected.field.problem.descriptor=Campo protegido <code>#ref</code> #loc
protected.inner.class.display.name=Clase anidada protegida
protected.inner.class.problem.descriptor=Clase anidada protegida <code>#ref</code> #loc
protected.inner.class.ignore.enum.option=Ignorar enumeraciones internas 'protegidas'
protected.inner.class.ignore.interface.option=Ignorar interfaces internas 'protegidas'
public.field.display.name=Campo 'público'
public.field.problem.descriptor=Campo 'público' <code>#ref</code> #loc
public.field.ignore.enum.type.fields.option=Ignorar los campos 'final públicos' de un tipo de enumeración
public.inner.class.display.name=Clase anidada 'pública'
public.inner.class.problem.descriptor=Clase anidada 'public' <code>#ref</code> #loc
public.inner.class.ignore.enum.option=Ignorar enumeraciones internas 'públicas'
public.inner.class.ignore.interface.option=Ignorar interfaces internas 'públicas'
accessing.non.public.field.of.another.object.display.name=Accediendo a un campo no público de otro objeto
accessing.non.public.field.of.another.object.problem.descriptor=Acceso directo del campo no público <code>#ref</code> en otro objeto #loc
call.to.date.tostring.display.name=Llamar a 'Date.toString()'
call.to.date.tostring.problem.descriptor=<code> Date. #ref()</code> usado en un contexto internacionalizado #loc
magic.character.display.name=Personaje mágico
magic.character.problem.descriptor=Carácter mágico <code>#ref</code> en un contexto internacionalizado #loc
call.to.numeric.tostring.display.name=Llamar a numérico 'toString()'
call.to.numeric.tostring.problem.descriptor=<code>#ref()</code> numérico llamado en un contexto internacionalizado #loc
instantiating.simpledateformat.without.locale.display.name=Creación de una instancia de SimpleDateFormat sin una configuración regional
instantiating.simpledateformat.without.locale.problem.descriptor=Crear una instancia de un <code>#ref</code> sin especificar un Locale en un contexto internacionalizado #loc
string.concatenation.display.name=Concatenación de cadenas
string.concatenation.problem.descriptor=Concatenación de cadenas <code>#ref</code> en un contexto internacionalizado #loc
inspection.option.ignore.system.out=Ignorar los argumentos de 'System.out.print'
inspection.option.ignore.system.err=Ignorar los argumentos 'System.err.print'
inspection.option.ignore.assert=Ignorar los argumentos de descripción de la declaración de afirmación
inspection.option.ignore.exceptions=Ignorar los argumentos del constructor de las subclases Throwable
inspection.option.ignore.nonnls=Ignorar cuando se anota a través de @NonNls
inspection.option.ignore.constant.initializers=Ignorar para inicializadores de campos constantes
inspection.option.ignore.in.annotations=Ignorar en anotaciones
inspection.option.ignore.in.tostring=Ignorar dentro de los métodos toString()
inspection.option.ignore.as.initial.capacity=Ignorar la capacidad inicial para StringBuilders y Colecciones
inspection.option.ignore.in.hashcode=Ignorar constantes en métodos 'hashCode()'
string.touppercase.tolowercase.without.locale.display.name=Llamada a 'String.toUpperCase()' o 'toLowerCase()' sin una configuración regional
string.touppercase.tolowercase.without.locale.problem.descriptor=<code> String. #ref()</code> llamado sin especificar un Locale usando cadenas internacionalizadas #loc
use.stringtokenizer.display.name=Usando StringTokenizer
use.stringtokenizer.problem.descriptor=<code>#ref</code> en un contexto internacionalizado #loc
time.tostring.call.display.name=Llamar a 'Time.toString()'
time.tostring.call.problem.descriptor=<code> Time. #ref()</code> en un contexto internacionalizado #loc
class.escapes.defined.scope.display.name=La clase no accesible está expuesta
class.escapes.defined.scope.display.module.option=La API del módulo expone clases no exportadas (Java 9+)
class.escapes.defined.scope.display.public.option=La API pública expone clases no accesibles
class.escapes.defined.scope.display.package.option=La API local del paquete expone clases privadas
class.escapes.defined.scope.problem.descriptor=La clase <code>#ref</code> está expuesta fuera de su alcance definido #loc
class.escapes.defined.scope.java9.modules.descriptor=La clase <code>#ref</code> no se exporta desde el módulo ''{0}''
field.name.hides.in.superclass.display.name=El nombre del campo oculta el campo en la superclase
field.name.hides.in.superclass.problem.descriptor=Field <code>#ref</code> oculta el campo en la superclase #loc
field.name.hides.in.superclass.ignore.option=Ignorar campos no accesibles
field.name.hides.in.superclass.ignore.static.field.option=Ignorar campos estáticos que ocultan campos estáticos
inner.class.field.hides.outer.display.name=El campo de clase interior oculta el campo de clase exterior
inner.class.field.hides.outer.ignore.option=Ignorar los campos externos no visibles desde la clase interna
inner.class.field.hides.outer.problem.descriptor=El campo de clase interior <code>#ref</code> oculta el campo de clase exterior #loc
local.variable.hides.member.variable.display.name=La variable local oculta el campo
local.variable.hides.member.variable.problem.descriptor=La variable local <code>#ref</code> oculta el campo en la clase ''{0}'' #loc
local.variable.hides.member.variable.ignore.option=Ignorar variables locales en un contexto estático ocultando campos no estáticos
method.overloads.display.name=El método sobrecarga el método de la superclase
method.overloads.problem.descriptor=El método <code>#ref()</code> sobrecarga un método compatible de una superclase, cuando podría haber sido la anulación #loc
method.overloads.report.incompatible.option=Informe incluso si los tipos de parámetros no son compatibles
method.overrides.private.display.name.problem.descriptor=El método <code>#ref()</code> anula un método 'privado' de una superclase #loc
method.overrides.static.display.name=El método intenta anular el método estático de la superclase
method.overrides.static.problem.descriptor=El método <code>#ref()</code> intenta anular un método estático de una superclase #loc
parameter.hides.member.variable.display.name=El parámetro oculta el campo
parameter.hides.member.variable.problem.descriptor=El parámetro <code>#ref</code> oculta el campo en la clase ''{0}'' #loc
parameter.hides.member.variable.ignore.setters.option=Ignorar para los establecedores de propiedades
parameter.hides.member.variable.ignore.superclass.option=Ignorar los campos de superclase no visibles desde la subclase
parameter.hides.member.variable.ignore.constructors.option=Ignorar para constructores
parameter.hides.member.variable.ignore.abstract.methods.option=Ignorar para métodos abstractos
parameter.hides.member.variable.ignore.static.parameters.option=Ignorar los parámetros de métodos estáticos que ocultan campos de instancia
type.parameter.hides.visible.type.display.name=El parámetro de tipo oculta el tipo visible
type.parameter.hides.visible.type.problem.descriptor=El parámetro de tipo <code>#ref</code> oculta el tipo visible ''{0}'' #loc
type.parameter.hides.type.parameter.problem.descriptor=El parámetro de tipo <code>#ref</code> oculta el parámetro de tipo ''{0}'' #loc
anonymous.class.variable.hides.containing.method.variable.display.name=La variable de clase anónima oculta la variable en el método contenedor
anonymous.class.parameter.hides.containing.method.variable.problem.descriptor=El parámetro de clase anónimo <code>#ref</code> oculta la variable en el método contenedor #loc
anonymous.class.field.hides.containing.method.variable.problem.descriptor=El campo de clase anónimo <code>#ref</code> oculta la variable en el método contenedor #loc
anonymous.class.variable.hides.containing.method.variable.problem.descriptor=La variable local de clase anónima <code>#ref</code> oculta la variable en el método contenedor #loc
channel.opened.not.closed.display.name=Canal abierto pero no cerrado de forma segura
drivermanager.call.display.name=Uso de DriverManager para obtener la conexión JDBC
drivermanager.call.problem.descriptor=Llamar a <código> DriverManager. #ref()</código> #loc
hibernate.resource.opened.not.closed.display.name=Recurso de hibernación abierto pero no cerrado de forma segura
i.o.resource.opened.not.closed.display.name=Recurso de E/S abierto pero no cerrado de forma segura
resource.opened.not.closed.problem.descriptor=''{0}'' debe abrirse frente a un bloque ''try'' y cerrarse en el bloque '' finalmente '' correspondiente #loc
jdbc.resource.opened.not.closed.display.name=Recurso JDBC abierto pero no cerrado de forma segura
jndi.resource.opened.not.closed.display.name=Recurso JNDI abierto pero no cerrado de forma segura
socket.opened.not.closed.display.name=Enchufe abierto pero no cerrado de forma segura
annotation.class.display.name=Clase de anotación
annotation.class.problem.descriptor=Clase de anotación <code>#ref</code> #loc
annotation.display.name=Anotación
annotation.problem.descriptor=Anotación <code>#ref</code> #loc
assert.statement.display.name=Declaración 'assert'
statement.problem.descriptor=<code>#ref</code> declaración #loc
auto.boxing.display.name=Boxeo automático
auto.boxing.problem.descriptor=Boxeo automático <code>#ref</code> #loc
auto.boxing.make.boxing.explicit.quickfix=Hacer explícito el boxeo
auto.boxing.ignore.added.to.collection.option=Ignorar expresiones agregadas a una colección
auto.unboxing.display.name=Auto-desempaquetado
auto.unboxing.problem.descriptor=Desempaquetado automático <code>#ref</code> #loc
auto.unboxing.make.unboxing.explicit.quickfix=Hacer explícito el unboxing
enumerated.class.display.name=Clase enumerada
enumerated.class.problem.descriptor=Clase enumerada <code>#ref</code> #loc
extended.for.statement.display.name=Extendido 'para' declaración
extended.for.statement.replace.quickfix=Reemplazar con la antigua declaración 'for'
variable.argument.method.display.name=Método Varargs
variable.argument.method.problem.descriptor=Método de Varargs <code>#ref()</code> #loc
variable.argument.method.quickfix=Convertir el parámetro varargs en una matriz
hardcoded.file.separator.display.name=Separador de archivos codificado
hardcoded.file.separator.problem.descriptor=Separador de archivos codificado <code>#ref</code> #loc
hardcoded.file.separator.include.option=Incluir "ejemplo/*" en tipos de medios MIME reconocidos
hardcoded.line.separator.display.name=Separador de línea codificado
hardcoded.line.separator.problem.descriptor=Separador de línea codificado <code>#ref</code> #loc
native.method.display.name=Método nativo
native.method.problem.descriptor=Los métodos declarados <code>#ref</code> no son portátiles #loc
runtime.exec.call.display.name=Llamar a 'Runtime.exec()'
runtime.exec.call.problem.descriptor=Llamada a <code> Runtime. #ref()</code> no es portátil #loc
system.exit.call.display.name=Llamada a 'System.exit()' o métodos relacionados
system.exit.call.problem.descriptor=La llamada a <code> {0}. #ref()</code> no es portátil #loc
system.exit.call.ignore.option=Ignorar en el método principal
system.getenv.call.display.name=Llamar a 'System.getenv()'
system.getenv.call.problem.descriptor=La llamada a <code> System. #ref()</code> no es portátil #loc
use.of.awt.peer.class.display.name=Uso de la clase de pares AWT
use.of.awt.peer.class.problem.descriptor=El uso de la clase de pares AWT <code>#ref</code> no es portátil #loc
use.of.concrete.jdbc.driver.class.display.name=Uso de una clase de controlador JDBC concreta
use.of.concrete.jdbc.driver.class.problem.descriptor=El uso de la clase de controlador JDBC concreto <code>#ref</code> no es portátil #loc
use.processbuilder.class.display.name=Uso de la clase 'java.lang.ProcessBuilder'
use.processbuilder.class.problem.descriptor=El uso de <code>#ref</code> no es portátil #loc
use.sun.classes.display.name=Uso de clases sun. *
use.sun.classes.problem.descriptor=El uso de la clase <code>#ref</code> proporcionada por Sun no es portátil #loc
abstract.class.with.only.one.direct.inheritor.display.name=Clase abstracta que tiene un solo heredero directo
anonymous.inner.may.be.named.static.inner.class.display.name=La clase anónima puede ser una clase interna 'estática' con nombre
anonymous.inner.may.be.named.static.inner.class.problem.descriptor=La clase anónima <code>#ref</code> puede ser una clase interna 'estática' nombrada #loc
array.length.in.loop.condition.display.name=Array.length en condición de bucle
array.length.in.loop.condition.problem.descriptor=Verificación de la matriz <code>#ref</code> en condición de bucle #loc
large.array.allocation.no.outofmemoryerror.display.name=Asignación de matriz grande sin verificación de OutOfMemoryError
large.array.allocation.no.outofmemoryerror.problem.descriptor=Asignación de matriz grande que no se comprueba para la condición de falta de memoria #loc
large.array.allocation.no.outofmemoryerror.maximum.number.of.elements.option=Número máximo de elementos:
connection.opened.not.safely.closed.display.name=Conexión abierta pero no cerrada de forma segura
interface.one.inheritor.display.name=Interfaz que tiene un solo heredero directo
interface.one.inheritor.problem.descriptor=La interfaz <code>#ref</code> tiene solo un heredero directo #loc
method.call.in.loop.condition.display.name=Llamada al método en condición de bucle
method.call.in.loop.condition.problem.descriptor=Llamada al método <code>#ref()</code> en condición de bucle #loc
large.initializer.primitive.type.array.display.name=Inicializador demasiado grande para una matriz de tipo primitivo
large.initializer.primitive.type.array.problem.descriptor=Inicializador de matriz primitivo con demasiados elementos ({0}) #loc
large.initializer.primitive.type.array.maximum.number.of.elements.option=Número máximo de elementos:
private.member.access.between.outer.and.inner.classes.display.name=Llamada de acceso sintético
private.member.access.between.outer.and.inner.classes.problem.descriptor=El acceso al miembro 'privado' de la clase ''{0}'' requiere acceso sintético #loc
private.member.access.between.outer.and.inner.classes.make.local.quickfix=Hacer ''{0}'' paquete-privado
private.member.access.between.outer.and.inner.classes.make.constructor.package.local.quickfix=Hacer privado el paquete del constructor ''{0}''
recordstore.opened.not.safely.closed.display.name=RecordStore abierto pero no cerrado de forma segura
overly.complex.anonymous.inner.class.display.name=Clase anónima demasiado compleja
cyclomatic.complexity.limit.option=Límite de complejidad ciclomática:
overly.complex.anonymous.inner.class.problem.descriptor=Clase anónima demasiado compleja (complejidad ciclomática={0}) #loc
anonymous.inner.class.with.too.many.methods.display.name=Clase interna anónima con demasiados métodos
method.count.limit.option=Límite de recuento de métodos:
anonymous.inner.class.with.too.many.methods.problem.descriptor=Clase interna anónima con demasiados métodos (cuenta de métodos={0}) #loc
overly.complex.class.display.name=Clase demasiado compleja
overly.complex.class.problem.descriptor=Clase demasiado compleja <code>#ref</code> (complejidad ciclomática={0}) #loc
overly.coupled.class.display.name=Clase demasiado acoplada
overly.coupled.class.class.coupling.limit.option=Límite de acoplamiento de clase:
include.java.system.classes.option=Incluir acoplamientos a las clases del sistema java
include.library.classes.option=Incluir acoplamientos a las clases de la biblioteca
overly.coupled.class.problem.descriptor=<code>#ref</code> está demasiado acoplado (dependencias={0}) #loc
class.too.deep.display.name=Clase demasiado profunda en el árbol de herencia
class.too.deep.inheritance.depth.limit.option=Límite de profundidad de herencia:
class.too.deep.problem.descriptor=<code>#ref</code> está demasiado profundo en el árbol de herencia (profundidad de herencia={0}) #loc
inner.class.too.deeply.nested.display.name=Clase interna demasiado anidada
inner.class.too.deeply.nested.nesting.limit.option=Límite de anidamiento:
inner.class.too.deeply.nested.problem.descriptor=<code>#ref</code> está demasiado anidado (nivel de anidamiento={0}) #loc
too.many.constructors.display.name=Clase con demasiados constructores
too.many.constructors.count.limit.option=Límite de recuento de constructores:
too.many.constructors.ignore.deprecated.option=Ignorar constructores obsoletos
too.many.constructors.problem.descriptor=<code>#ref</code> tiene demasiados constructores (constructor count={0}) #loc
too.many.fields.display.name=Clase con demasiados campos
too.many.fields.count.limit.option=Límite de recuento de campos:
too.many.fields.problem.descriptor=<code>#ref</code> tiene demasiados campos (field count={0}) #loc
too.many.methods.display.name=Clase con demasiados métodos
too.many.methods.problem.descriptor=<code>#ref</code> tiene demasiados métodos (método count={0}) #loc
externalizable.with.serialization.methods.display.name=Clase externalizable con 'readObject()' o 'writeObject()'
externalizable.with.serialization.methods.problem.descriptor.both=La clase externalizable <code>#ref</code> define 'readObject()' y 'writeObject()' #loc
externalizable.with.serialization.methods.problem.descriptor.write=La clase externalizable <code>#ref</code> define 'writeObject()' #loc
externalizable.with.serialization.methods.problem.descriptor.read=La clase externalizable <code>#ref</code> define 'readObject()' #loc
non.serializable.with.serialversionuid.display.name=Clase no serializable con 'serialVersionUID'
non.serializable.class.with.serialversionuid.problem.descriptor=La clase no serializable <code>#ref</code> define un campo 'serialVersionUID' #loc
non.serializable.interface.with.serialversionuid.problem.descriptor=Interfaz no serializable <code>#ref</code> define un campo 'serialVersionUID' #loc
non.serializable.@interface.with.serialversionuid.problem.descriptor=No serializable @interface <code>#ref</code> define un campo 'serialVersionUID' #loc
non.serializable.anonymous.with.serialversionuid.problem.descriptor=Clase anónima no serializable que extiende <code>#ref</code> define un campo 'serialVersionUID' #loc
non.serializable.class.with.readwriteobject.display.name=Clase no serializable con 'readObject()' o 'writeObject()'
non.serializable.class.with.readwriteobject.problem.descriptor.both=La clase no serializable <code>#ref</code> define 'readObject()' y 'writeObject()' #loc
non.serializable.class.with.readwriteobject.problem.descriptor.write=Clase no serializable <code>#ref</code> define 'writeObject()' #loc
non.serializable.class.with.readwriteobject.problem.descriptor.read=Clase no serializable <code>#ref</code> define 'readObject()' #loc
readwriteobject.private.display.name=ReadObject()' o 'writeObject()' no declarado como 'privado
readwriteobject.private.problem.descriptor=<code>#ref</code> no declarado 'privado' #loc
readobject.initialization.display.name=El campo de instancia no puede ser inicializado por 'readObject()'
readobject.initialization.problem.descriptor=Es posible que el campo de instancia <code>#ref</code> no se inicialice durante la llamada de 'readObject()' #loc
readresolve.writereplace.protected.display.name=ReadResolve()' o 'writeReplace()' no declarado 'protegido
readresolve.writereplace.protected.problem.descriptor=<code>#ref()</code> no declarado 'protegido' #loc
missing.serial.annotation.display.name=Se puede utilizar la anotación @Serial
missing.serial.annotation.on.field.problem.descriptor=Puede agregar la anotación @Serial a <code>\#ref</code>
missing.serial.annotation.on.method.problem.descriptor=Puede agregar la anotación @Serial a <code>\#ref()</code>
serial.annotation.used.on.wrong.member.display.name=@Serial anotación utilizada en miembro incorrecto
serial.annotation.used.on.wrong.member.problem.descriptor=El miembro anotado no forma parte del mecanismo de serialización.
serializable.record.contains.ignored.members.display.name=El registro serializable tiene un miembro ignorado
serializable.record.contains.ignored.field.problem.descriptor=<code>\#ref</code> se ignora durante la serialización de registros
serializable.record.contains.ignored.method.problem.descriptor=<code>\#ref()</code> se ignora mientras la serialización de registros está en curso
serialpersistentfields.with.wrong.signature.display.name=El campo 'serialPersistentFields' no se declaró 'Private static final ObjectStreamField[]'
serialpersistentfields.with.wrong.signature.problem.descriptor=El campo <code>#ref</code> de una clase serializable no se declara 'private static final ObjectStreamField []' #loc
serialversionuid.private.static.final.long.display.name=SerialVersionUID' campo no declarado 'private static final long
serialversionuid.private.static.final.long.problem.descriptor=El campo <code>#ref</code> de una clase serializable no se declara 'private static final long' #loc
serialversionuid.private.static.final.long.quickfix=Hacer serialVersionUID 'privado estático final'
non.protected.constructor.in.abstract.class.display.name=Constructor 'público' en clase 'abstracta'
unnecessary.qualifier.for.this.display.name=Calificador innecesario para 'esto' o 'super'
multiple.declaration.display.name=Varias variables en una declaración
thread.priority.display.name=Llamada a 'Thread.setPriority()'
too.broad.scope.display.name=El alcance de la variable es demasiado amplio
infinite.loop.statement.display.name=Declaración de bucle infinito
asserts.without.messages.display.name=Falta el mensaje en la afirmación
constant.naming.convention.element.description=Constante
constant.with.mutable.field.naming.convention.element.description=Constante con tipo de campo mutable
random.double.for.random.integer.display.name=Usando 'Random.nextDouble()' para obtener un entero aleatorio
string.buffer.replaceable.by.string.builder.display.name=StringBuffer' puede ser 'StringBuilder'
comparison.of.short.and.char.display.name=Comparación de valores 'short' y 'char'
unnecessary.fully.qualified.name.display.name=Nombre completamente calificado innecesario
ignore.in.module.statements.option=Ignorar en las declaraciones del módulo Java 9
unnecessary.label.on.break.statement.display.name=Etiqueta innecesaria en la declaración 'break'
exception.name.doesnt.end.with.exception.display.name=El nombre de la clase de excepción no termina con 'Exception'
bad.exception.declared.display.name=Excepción prohibida declarada
pointless.boolean.expression.display.name=Expresión booleana sin sentido
class.without.constructor.display.name=Clase sin constructor
break.statement.display.name=Declaración 'break'
unconditional.wait.display.name=Llamada incondicional 'wait()'
cyclomatic.complexity.display.name=Método demasiado complejo
final.class.display.name=Clase 'final'
labeled.statement.display.name=Declaración etiquetada
notify.called.on.condition.display.name=Notificar()' o 'notificar a todos()' llamado en el objeto 'java.util.concurrent.locks.Condition
loop.statements.that.dont.loop.display.name=Declaración de bucle que no se repite
ignore.enhanced.for.loop.statements=Ignorar bucles mejorados para
non.synchronized.method.overrides.synchronized.method.display.name=El método no sincronizado anula el método sincronizado
synchronize.on.this.display.name=Sincronización en 'esto'
switch.statement.with.too.many.branches.display.name=Declaración 'switch' con demasiadas ramas
utility.class.without.private.constructor.display.name=Clase de utilidad sin constructor 'privado'
throw.caught.locally.display.name=Throw' atrapado conteniendo la declaración 'try
exception.from.catch.which.doesnt.wrap.display.name='lanzar' dentro del bloque 'captura' que ignora la excepción detectada
type.parameter.naming.convention.element.description=Tipo de parámetro
multiply.or.divide.by.power.of.two.display.name=Multiplicar o dividir por potencia de dos
multiply.or.divide.by.power.of.two.divide.option=Verifica las divisiones por una potencia de dos también
serializable.with.unconstructable.ancestor.display.name=Clase serializable con ancestro inconstructable
missorted.modifiers.display.name=Modificadores mal clasificados
sleep.while.holding.lock.display.name=Llamar a 'Thread.sleep()' mientras está sincronizado
singleton.display.name=Único
thread.death.rethrown.display.name='java.lang.ThreadDeath' no relanzado
if.statement.with.too.many.branches.display.name=Declaración 'if' con demasiadas ramas
redundant.implements.display.name=Declaración de interfaz redundante
nesting.depth.display.name=Método demasiado anidado
return.this.display.name=Retorno de 'esto'
busy.wait.display.name=Espera ocupada
utility.class.display.name=Clase de utilidad
instantiating.object.to.get.class.object.display.name=Creación de instancias de objeto para obtener un objeto de clase
abstract.class.extends.concrete.class.display.name=La clase abstracta extiende la clase concreta
parameter.naming.convention.display.name=Convención de nomenclatura de parámetros de método
parameter.naming.convention.element.description=Parámetro
integer.division.in.floating.point.context.display.name=División entera en contexto de punto flotante
interface.naming.convention.element.description=Interfaz
length.one.strings.in.concatenation.display.name=Concatenación de cadena de un solo carácter
length.one.string.in.indexof.display.name=Argumento de cadena de un solo carácter en la llamada 'String.indexOf()'
thread.yield.display.name=Llamada a 'Thread.yield()'
confusing.floating.point.literal.display.name=Confuso literal de punto flotante
wait.not.in.loop.display.name='esperar()' no está en bucle
string.concatenation.inside.string.buffer.append.display.name=Concatenación de cadenas como argumento para la llamada 'StringBuilder.append()'
class.initializer.display.name=Inicializador no 'estático'
enumerated.class.naming.convention.element.description=Enumeración
non.thread.safe.lazy.initialization.display.name=Inicialización perezosa insegura del campo 'estático'
call.to.simple.setter.in.class.display.name=Llamada a establecedor simple desde dentro de la clase
comparison.to.nan.display.name=Comparación con Double.NaN o Float.NaN
new.method.naming.convention.display.name=Convención de nomenclatura de métodos
instance.method.naming.convention.element.description=Instancia
unnecessary.semicolon.display.name=Punto y coma innecesario
fallthru.in.switch.statement.display.name=Fallthrough en la declaración 'switch'
call.to.native.method.while.locked.display.name=Llamar a un método nativo mientras está bloqueado
switch.statement.display.name=Declaración 'switch'
custom.classloader.display.name=Cargador de clases personalizado
nested.conditional.expression.display.name=Expresión condicional anidada
duplicate.condition.display.name=Condición duplicada
method.with.multiple.loops.display.name=Método con múltiples bucles
non.comment.source.statements.display.name=Método demasiado largo
local.variable.naming.convention.display.name=Convención de nomenclatura de variables locales
local.variable.naming.convention.element.description=Variable local
negated.if.else.display.name=Declaración 'if' con condición negada
class.naming.convention.display.name=Convención de nomenclatura de clases
class.naming.convention.element.description=Clase
abstract.class.naming.convention.element.description=Clase abstracta
serializable.inner.class.with.non.serializable.outer.class.display.name=Clase interna serializable no 'estática' con clase externa no serializable
pointless.arithmetic.expression.display.name=Expresión aritmética sin sentido
method.name.same.as.class.name.display.name=El nombre del método es el mismo que el de la clase
unnecessary.temporary.on.conversion.to.string.display.name=Objeto temporal innecesario en conversión a String
unnecessary.continue.display.name=Declaración 'continuar' innecesaria
inner.class.on.interface.display.name=Clase interna de interfaz
unused.label.display.name=Etiqueta no utilizada
overly.complex.boolean.expression.display.name=Expresión booleana demasiado compleja
continue.statement.with.label.display.name=Declaración 'continue' con etiqueta
class.loader.instantiation.display.name=Instanciación de ClassLoader
return.from.finally.block.display.name=Regresar' dentro del bloque 'finalmente
unnecessary.boxing.display.name=Boxeo innecesario
annotation.naming.convention.element.description=Anotación
checked.exception.class.display.name=Clase de excepción marcada
switch.statement.with.confusing.declaration.display.name=Variable local utilizada y declarada en diferentes ramas 'switch'
cast.that.loses.precision.display.name=Reparto numérico que pierde precisión
manual.array.copy.display.name=Copia manual de matriz
manual.array.to.collection.copy.display.name=Copia manual de matriz a colección
long.literals.ending.with.lowercase.l.display.name=Long' literal que termina con 'l' en lugar de 'L
overly.complex.arithmetic.expression.display.name=Expresión aritmética demasiado compleja
junit.abstract.test.class.naming.convention.element.description=Prueba abstracta
unnecessary.parentheses.display.name=Paréntesis innecesarios
serializable.class.in.secure.context.display.name=Clase serializable en contexto seguro
static.variable.naming.convention.element.description=Campo 'estático'
nested.method.call.display.name=Llamada al método anidado
throw.from.finally.block.display.name=Lanzar' dentro del bloque 'finalmente
field.accessed.synchronized.and.unsynchronized.display.name=Campo al que se accede tanto en contextos sincronizados como no sincronizados
abstract.method.overrides.abstract.method.display.name=El método abstracto anula el método abstracto
static.non.final.field.display.name=Campo 'estático', no 'final'
static.non.final.field.option=Solo reportar campos 'públicos'
class.without.no.arg.constructor.display.name=Clase sin constructor sin argumentos
unnecessary.return.display.name=Declaración de 'retorno' innecesaria
final.static.method.display.name=Método 'estático' declarado 'final'
constant.declared.in.abstract.class.display.name=Constante declarada en clase abstracta
too.broad.catch.display.name=Bloque 'catch' demasiado amplio
floating.point.equality.display.name=Comparación de igualdad de punto flotante
thrown.exceptions.per.method.display.name=Método con demasiadas excepciones declaradas
public.static.array.field.display.name=Campo de matriz 'público estático'
await.not.in.loop.display.name='await()' no está en el bucle
method.names.differ.only.by.case.display.name=Los nombres de los métodos difieren solo por caso
unsecure.random.number.generation.display.name=Generación insegura de números aleatorios
parameters.per.method.display.name=Método con demasiados parámetros
parameters.per.constructor.display.name=Constructor con demasiados parámetros
unnecessary.unboxing.display.name=Unboxing innecesario
extends.thread.display.name=La clase extiende directamente 'java.lang.Thread'
parameter.name.differs.from.overridden.parameter.display.name=El nombre del parámetro difiere del parámetro en el método anulado
final.private.method.display.name=Método 'privado' declarado 'final'
enum.switch.statement.which.misses.cases.display.name=Enum 'switch' statement que no usa mayúsculas y minúsculas
enum.switch.statement.which.misses.cases.option=Ignorar declaraciones de cambio con una rama predeterminada
string.buffer.must.have.initial.capacity.display.name=StringBuilder sin capacidad inicial
method.may.be.static.display.name=El método puede ser 'estático'
class.initializer.may.be.static.display.name=El inicializador de clase puede ser 'estático'
class.initializer.option=Solo advertir cuando la clase tiene uno o más constructores
class.initializer.move.code.to.constructor.quickfix=Mover el código inicializador al constructor
nested.switch.statement.display.name='interruptor' anidado
c.style.array.declaration.display.name=Declaración de matriz de estilo C
final.method.in.final.class.display.name=Método 'final' en la clase 'final'
extends.annotation.display.name=La clase extiende la interfaz de anotación
naked.notify.display.name='notificar()' o 'notificar a todos()' sin el cambio de estado correspondiente
switch.statement.density.display.name=Declaración 'switch' con una densidad de rama demasiado baja
switch.statement.with.too.few.branches.display.name=Declaración 'switch' con muy pocas ramas
upper.case.field.name.not.constant.display.name=Campo no constante con nombre en mayúsculas
unnecessary.label.on.continue.statement.display.name=Etiqueta innecesaria en la declaración 'continuar'
jdbc.prepare.statement.with.non.constant.string.display.name=Llamada a 'Connection.prepare *()' con una cadena no constante
synchronize.on.non.final.field.display.name=Sincronización en un campo no final
noop.method.in.abstract.class.display.name=Método sin operación en clase abstracta
non.final.field.of.exception.display.name=Campo no final de la clase de excepción
nested.try.statement.display.name=Declaración 'try' anidada
condition.signal.display.name=Llamada a 'signal()' en lugar de 'signalAll()'
jdbc.execute.with.non.constant.string.display.name=Llamada a 'Statement.execute()' con una cadena no constante
system.set.security.manager.display.name=Llamar a 'System.setSecurityManager()'
system.set.security.manager.problem.descriptor=La llamada a <code> System. #ref()</code> puede plantear problemas de seguridad #loc
control.flow.statement.without.braces.display.name=Declaración de flujo de control sin llaves
trivial.if.display.name=Declaración 'if' redundante
trivial.if.fix.family.name=Simplificar 'si más'
trivial.if.option.ignore.chained=Ignorar declaraciones 'if' encadenadas
thread.with.default.run.method.display.name=Crear una instancia de un hilo con el método predeterminado 'run()'
while.loop.spins.on.field.display.name='while' loop gira en el campo
while.loop.spins.on.field.fix.family.name=Corregir bucle de giro
while.loop.spins.on.field.fix.volatile=Hacer ''{0}'' volátil
while.loop.spins.on.field.fix.spinwait=Agregar hilo.onSpinWait()
while.loop.spins.on.field.fix.volatile.spinwait=Hacer ''{0}'' volátil y agregar Thread.onSpinWait()
if.statement.with.identical.branches.display.name=Declaración 'if' con partes comunes
inspection.common.if.parts.message.variables.only=Extraer variables de ''if'' {0}
inspection.common.if.parts.message.with.variables.extract=Extraer parte común con variables de ''if'' {0}
inspection.common.if.parts.message.without.variables.extract=Extraer parte común de ''if'' {0}
inspection.common.if.parts.message.whole.branch=Extraer parte común quitando rama {0}
inspection.common.if.parts.message.complete.duplicate=Contraer la instrucción ''if'' {0}
inspection.common.if.parts.message.complete.duplicate.side.effect=Contraer la declaración "si" y extraer el efecto secundario
inspection.common.if.parts.description.variables.only=Las variables se pueden extraer de ''if'' {0}
inspection.common.if.parts.description.with.variables.extract=Las partes comunes con variables se pueden extraer de ''if'' {0}
inspection.common.if.parts.description.without.variables.extract=La parte común se puede extraer de ''if'' {0}
inspection.common.if.parts.description.whole.branch=La parte común se puede extraer quitando la rama {0}
inspection.common.if.parts.description.complete.duplicate=La declaración ''if'' se puede contraer {0}
inspection.common.if.parts.description.complete.duplicate.side.effect=La declaración 'if' se puede contraer con la extracción de efectos secundarios
inspection.note.may.change.semantics=Puede cambiar la semántica
multiple.return.points.per.method.display.name=Método con múltiples puntos de retorno
break.statement.with.label.display.name=Declaración 'break' con etiqueta
public.constructor.in.non.public.class.display.name=Constructor 'público' en una clase no pública
questionable.name.display.name=Nombre cuestionable
empty.finally.block.display.name=Bloque 'finalmente' vacío
abstract.method.overrides.concrete.method.display.name=El método abstracto anula el método concreto
thread.stop.suspend.resume.display.name=Llamada a 'Thread.stop()', 'suspend()' o 'resume()'
constant.math.call.display.name=Llamada constante a 'java.lang.Math'
volatile.array.field.display.name=Campo de matriz volátil
literal.as.arg.to.string.equals.display.name=Expresión.equals ("literal")' en lugar de '"literal" .equals (expresión)
inner.class.may.be.static.display.name=La clase interna puede ser 'estática'
redundant.field.initialization.display.name=Inicialización de campo redundante
string.buffer.to.string.in.concatenation.display.name='StringBuilder.toString()' en concatenación
utility.class.with.public.constructor.display.name=Clase de utilidad con constructor 'público'
for.loop.replaceable.by.while.display.name=El bucle 'for' se puede reemplazar con el bucle 'while'
missing.deprecated.annotation.display.name=Falta anotación @Deprecated
cloneable.class.in.secure.context.display.name=Clase clonable en contexto seguro
static.inheritance.display.name=Herencia estática
class.name.prefixed.with.package.name.display.name=Nombre de clase con el prefijo del nombre del paquete
call.to.simple.getter.in.class.display.name=Llamar a un captador simple desde dentro de la clase
class.name.differs.from.file.name.display.name=El nombre de la clase difiere del nombre del archivo
protected.member.in.final.class.display.name=Miembro 'protegido' en la clase 'final'
load.library.with.non.constant.string.display.name=Llamada a 'System.loadLibrary()' con una cadena no constante
instanceof.catch.parameter.display.name=Instanceof' en el parámetro 'catch
implicit.numeric.conversion.display.name=Conversión numérica implícita
confusing.main.method.display.name=Método 'main()' confuso
octal.literal.display.name=Entero octal
misordered.assert.equals.arguments.display.name=Argumentos 'assertEquals()' mal ordenados
unnecessary.constructor.display.name=Constructor redundante sin argumentos
method.name.same.as.parent.name.display.name=El nombre del método es el mismo que el de la clase principal
while.can.be.foreach.display.name=While' bucle reemplazable con bucle mejorado 'for
big.decimal.equals.display.name=Equals()' llamado en 'java.math.BigDecimal
implicit.call.to.super.display.name=Llamada implícita a 'super()'
unqualified.static.usage.display.name=Acceso estático no calificado
simplifiable.junit.assertion.display.name=Aserción simplificable
object.notify.display.name=Llamar a 'notificar()' en lugar de 'notificar a todos()'
thread.start.in.construction.display.name=Llamada a 'Thread.start()' durante la construcción del objeto
non.final.clone.display.name='clone()' no final en contexto seguro
unnecessary.temporary.on.conversion.from.string.display.name=Objeto temporal innecesario en la conversión de String
unnecessary.this.display.name=Calificador 'este' innecesario
unnecessary.this.ignore.assignments.option=Ignorar asignaciones de campo
runtime.exec.with.non.constant.string.display.name=Llamada a 'Runtime.exec()' con una cadena no constante
system.properties.display.name=Acceso a las propiedades del sistema
chained.method.call.display.name=Llamadas a métodos encadenados
safe.lock.display.name=Bloqueo adquirido pero no desbloqueado de forma segura
system.run.finalizers.on.exit.display.name=Llamada a 'System.runFinalizersOnSalir()'
for.can.be.foreach.display.name=Bucle 'for' reemplazable con bucle 'for' mejorado
type.parameter.extends.object.display.name=El parámetro de tipo extiende explícitamente 'java.lang.Object'
type.parameter.extends.object.ignore.annotated=Ignorar cuando se anota java.lang.Object
marker.interface.display.name=Interfaz de marcador
limited.scope.inner.class.display.name=Clase interna de alcance limitado
switch.statements.without.default.display.name=Declaración 'switch' sin rama 'predeterminada'
unchecked.exception.class.display.name=Clase de excepción sin marcar
for.loop.with.missing.component.display.name=Bucle 'for' con componentes faltantes
for.loop.with.missing.component.collection.loop.option=Ignorar iteraciones de colección
double.checked.locking.display.name=Bloqueo con doble verificación
double.checked.locking.problem.descriptor=Bloqueo con doble verificación #loc
string.buffer.replaceable.by.string.display.name=StringBuilder' puede ser reemplazado por 'String
boolean.method.name.must.start.with.question.display.name=El nombre del método booleano debe comenzar con la palabra pregunta
class.name.same.as.ancestor.name.display.name=Nombre de clase igual al nombre del ancestro
error.rethrown.display.name='java.lang.Error' no relanzado
serializable.has.serialization.methods.display.name=Clase serializable sin 'readObject()' y 'writeObject()'
serializable.has.serialization.methods.ignore.option=Ignorar clases que no definen campos de instancia
missing.override.annotation.display.name=Falta la anotación @Override
wait.while.holding.two.locks.display.name='wait()' mientras mantiene dos candados
empty.class.display.name=Clase vacía redundante
trivial.string.concatenation.display.name=Concatenación con cadena vacía
empty.synchronized.statement.display.name=Declaración vacía 'sincronizada'
unnecessary.default.display.name=Predeterminado' innecesario para la declaración de enum 'switch
simplifiable.conditional.expression.display.name=Expresión condicional simplificable
unnecessary.super.constructor.display.name=Llamada innecesaria a 'super()'
unnecessarily.qualified.static.usage.display.name=Acceso estático innecesariamente calificado
bad.exception.caught.display.name=Excepción prohibida capturada
custom.security.manager.display.name=Administrador de seguridad personalizado
string.concatenation.in.loops.display.name=Concatenación de cadenas en bucle
boolean.constructor.display.name=Llamada al constructor booleano
continue.statement.display.name=Declaración 'continue'
extends.object.display.name=La clase extiende explícitamente 'java.lang.Object'
serializable.inner.class.has.serial.version.uid.field.display.name=Clase interna serializable no 'estática' sin 'serialVersionUID'
static.method.naming.convention.element.description=Estático
empty.try.block.display.name=Bloque vacío 'try'
field.has.setter.but.no.getter.display.name=El campo tiene un setter pero no un getter
three.negations.per.method.display.name=Método con más de tres negaciones
conditional.expression.display.name=Expresión condicional (? :)
string.equals.empty.string.display.name=Cadena.equals ("")
synchronize.on.lock.display.name=Sincronización en un objeto de bloqueo
synchronized.on.literal.object.name=Sincronización en un objeto inicializado con un literal
field.may.be.static.display.name=El campo puede ser 'estático'
class.may.be.interface.display.name=La clase abstracta puede ser interfaz
abstract.class.without.abstract.methods.display.name=Clase abstracta sin métodos abstractos
divide.by.zero.display.name=Dividir por cero
default.not.last.case.in.switch.display.name=Default' no es el último caso en la declaración 'switch
nested.synchronized.statement.display.name=Declaración 'sincronizada' anidada
constant.conditional.expression.display.name=Expresión condicional constante
redundant.else.display.name='else' redundante
public.field.accessed.in.synchronized.context.display.name=Campo no privado al que se accede en contexto sincronizado
string.replaceable.by.string.buffer.display.name=La cadena no constante debe ser StringBuilder
junit.test.class.naming.convention.element.description=Prueba
junit.test.suite.naming.convention.element.description=Conjunto de pruebas
method.coupling.display.name=Método demasiado acoplado
collections.must.have.initial.capacity.display.name=Colección sin capacidad inicial
anonymous.inner.class.display.name=Clase interna anónima
negated.conditional.display.name=Expresión condicional con condición negada
non.reproducible.math.call.display.name=Llamada no reproducible a 'java.lang.Math'
multiple.top.level.classes.in.file.display.name=Varias clases de nivel superior en un solo archivo
set.replaceable.by.enum.set.display.name=Conjunto reemplazable con EnumSet
tail.recursion.display.name=Recursión de cola
finally.block.cannot.complete.normally.display.name='finalmente' bloque que no se puede completar normalmente
non.atomic.operation.on.volatile.field.display.name=Operación no atómica en campo volátil
public.static.collection.field.display.name=Campo de colección 'público estático'
non.exception.name.ends.with.exception.display.name=El nombre de la clase que no es una excepción termina con 'Exception'
synchronized.method.display.name=Método 'synchronized'
enumerated.constant.naming.convention.element.description=Constante enumerada
final.method.display.name=Método 'final'
transient.field.in.non.serializable.class.display.name=Campo transitorio en clase no serializable
bad.exception.thrown.display.name=Se ha lanzado una excepción prohibida
conditional.expression.with.identical.branches.display.name=Expresión condicional con ramas idénticas
conditional.can.be.pushed.inside.expression.display.name=El condicional se puede insertar dentro de la expresión de la rama
conditional.can.be.pushed.inside.expression.option=Ignorar cuando condicional será el único argumento de una llamada de método
conditional.can.be.pushed.inside.expression.quickfix=Insertar expresión condicional dentro de la rama
raw.use.of.parameterized.type.display.name=Uso sin procesar de la clase parametrizada
standard.variable.names.display.name=Nombres de variables estándar
field.naming.convention.display.name=Convención de nomenclatura de campos
instance.variable.naming.convention.element.description=Campo de instancia
dollar.sign.in.name.display.name=Uso de '$' en el identificador
map.replaceable.by.enum.map.display.name=Mapa reemplazable con EnumMap
extends.concrete.collection.display.name=La clase extiende explícitamente una clase de Colección
continue.or.break.from.finally.block.display.name=Continuar' o 'romper' dentro del bloque 'finalmente
abstract.method.with.missing.implementations.display.name=Método abstracto con implementaciones faltantes
object.allocation.in.loop.display.name=Asignación de objetos en bucle
wait.called.on.condition.display.name=Wait()' llamado en el objeto 'java.util.concurrent.locks.Condition
test.case.with.no.test.methods.display.name=Clase de prueba sin pruebas
abstract.class.never.implemented.display.name=Clase abstracta que no tiene subclase concreta
interface.never.implemented.display.name=Interfaz que no tiene una subclase concreta
constant.declared.in.interface.display.name=Constante declarada en la interfaz
exception.name.doesnt.end.with.exception.problem.descriptor=El nombre de la clase de excepción <code>#ref</code> no termina con 'Exception' #loc
non.exception.name.ends.with.exception.problem.descriptor=El nombre de clase sin excepción <code>#ref</code> termina con 'Exception' #loc
class.name.prefixed.with.package.name.problem.descriptor=El nombre de la clase <code>#ref</code> comienza con su nombre de paquete #loc
class.name.same.as.ancestor.name.problem.descriptor=El nombre de la clase <code>#ref</code> es el mismo que uno de los nombres de su superclase #loc
method.name.same.as.class.name.problem.descriptor=El nombre del método <code>#ref</code> es el mismo que su nombre de clase #loc
method.name.same.as.parent.name.problem.descriptor=El nombre del método <code>#ref</code> es el mismo que el nombre de la clase principal #loc
boolean.method.name.must.start.with.question.problem.descriptor=El nombre del método booleano <code>#ref</code> no comienza con la palabra de pregunta #loc
questionable.name.problem.descriptor=Nombre cuestionable <code>#ref</code> #loc
confusing.main.method.problem.descriptor=Método llamado <code>#ref</code> sin firma 'public static void main (String [])' #loc
upper.case.field.name.not.constant.problem.descriptor=Campo no constante <code>#ref</code> con nombre de estilo constante #loc
dollar.sign.in.name.problem.descriptor=El identificador <code>#ref</code> contiene '$' #loc
integer.division.in.floating.point.context.problem.descriptor=<code>#ref</code>: división de enteros en contexto de punto flotante #loc
comparison.of.short.and.char.problem.descriptor=Comparación de igualdad <code>#ref</code> de valores cortos y char #loc
big.decimal.equals.problem.descriptor=<code>#ref()</code> entre los valores BigDecimal probablemente debería ser 'compareTo()' #loc
divide.by.zero.problem.descriptor=División por cero #loc
non.reproducible.math.call.problem.descriptor=<code> Math. #ref()</code> puede producir resultados no reproducibles #loc
constant.math.call.problem.descriptor=La llamada constante a <code>#ref()</code> se puede simplificar #loc
floating.point.equality.problem.descriptor=<code>#ref</code>: valores de punto flotante comparados para la igualdad exacta #loc
fallthru.in.switch.statement.problem.descriptor=Fallo en la declaración de 'cambio' #loc
switch.statements.without.default.problem.descriptor=<code>#ref</code> declaración sin rama 'predeterminada' #loc
default.not.last.case.in.switch.problem.descriptor=<code>#ref</code> rama no es el último caso en 'switch'{0}#loc
loop.statements.that.dont.loop.problem.descriptor=La declaración <code>#ref</code> no se repite #loc
conditional.expression.with.identical.branches.problem.descriptor=Expresión condicional <code>#ref</code> con ramas idénticas #loc
conditional.can.be.pushed.inside.expression.problem.descriptor=La expresión condicional se puede insertar dentro de la rama #loc
duplicate.condition.problem.descriptor=Condición duplicada <code>#ref</code> #loc
duplicate.condition.ignore.method.calls.option=Ignorar condiciones con efectos secundarios
iterator.next.does.not.throw.nosuchelementexception.problem.descriptor=<code>Iterator. #ref()</code> que no puede lanzar 'NoSuchElementException' #loc
infinite.loop.statement.problem.descriptor=<code>#ref</code> declaración no se puede completar sin lanzar una excepción #loc
confusing.floating.point.literal.problem.descriptor=Confuso literal de coma flotante <code>#ref</code> #loc
overly.complex.arithmetic.expression.problem.descriptor=Expresión aritmética demasiado compleja #loc
overly.complex.boolean.expression.problem.descriptor=Expresión booleana demasiado compleja ({0} términos) #loc
labeled.statement.problem.descriptor=Instrucción etiquetada <code> #ref:</code> #loc
break.statement.with.label.problem.descriptor=<code>#ref</code> declaración con etiqueta #loc
continue.statement.with.label.problem.descriptor=<code>#ref</code> declaración con etiqueta #loc
conditional.expression.problem.descriptor=Expresión condicional <code>#ref</code> #loc
conditional.expression.option=Ignorar para asignaciones simples y devoluciones
conditional.expression.expression.context.option=Ignorar lugares donde una declaración if no es posible
conditional.expression.quickfix=Reemplazar con la declaración 'if'
nested.conditional.expression.problem.descriptor=Expresión condicional anidada <code>#ref</code> #loc
long.literals.ending.with.lowercase.l.problem.descriptor='long' literal <code>#ref</code> termina en minúscula 'l' #loc
nested.switch.statement.problem.descriptor=<code>#ref</code> anidado{0}#loc
chained.method.call.problem.descriptor=Llamada al método encadenado <code>#ref()</code> #loc
nested.method.call.problem.descriptor=Llamada al método anidado <code>#ref()</code> #loc
octal.literal.problem.descriptor=Entero octal <code>#ref</code> #loc
implicit.call.to.super.problem.descriptor=Llamada implícita a 'super()' #loc
negated.if.else.problem.descriptor=<code>#ref</code> declaración con condición negada #loc
negated.conditional.problem.descriptor=Expresión condicional con condición negada #loc
redundant.else.problem.descriptor=<code>#ref</code> rama se puede desenvolver, ya que la rama 'if' nunca se completa normalmente #loc
switch.statement.with.confusing.declaration.problem.descriptor=Variable local <code>#ref</code> declarada en una rama 'switch' y utilizada en otra #loc
final.class.problem.descriptor=Clase declarada <code>#ref</code> #loc
empty.class.problem.descriptor=La clase <code>#ref</code> está vacía #loc
empty.enum.problem.descriptor=Enum <code>#ref</code> está vacío #loc
empty.class.file.without.class.problem.descriptor=El archivo Java no declara ninguna clase #loc
empty.anonymous.class.problem.descriptor=La clase anónima está vacía #loc
anonymous.inner.class.problem.descriptor=Clase interna anónima <code>#ref</code> #loc
limited.scope.inner.class.problem.descriptor=Clase interna de alcance limitado <code>#ref</code> #loc
final.method.problem.descriptor=Método declarado <code>#ref</code> #loc
class.initializer.problem.descriptor=Inicializador no 'estático' #loc
class.may.be.interface.problem.descriptor=La clase abstracta <code>#ref</code> puede ser la interfaz #loc
non.protected.constructor.in.abstract.class.problem.descriptor=El constructor <code>#ref()</code> no está declarado 'protegido' en la clase 'abstracta' #loc
class.without.constructor.problem.descriptor=Class <code>#ref</code> no tiene constructor #loc
abstract.class.without.abstract.methods.problem.descriptor=La clase <code>#ref</code> se declara 'abstracta' y no tiene métodos 'abstractos' #loc
final.method.in.final.class.problem.descriptor=Método declarado <code>#ref</code> en la clase 'final' #loc
protected.member.in.final.class.problem.descriptor=Miembro de clase declarado <code>#ref</code> en la clase 'final' #loc
utility.class.with.public.constructor.problem.descriptor=La clase <code>#ref</code> solo tiene miembros 'estáticos' y un constructor 'público' #loc
utility.class.without.private.constructor.problem.descriptor=La clase <code>#ref</code> solo tiene miembros 'estáticos' y carece de un constructor 'privado' #loc
abstract.method.overrides.concrete.method.problem.descriptor=El método abstracto <code>#ref()</code> anula el método concreto #loc
abstract.method.with.missing.implementations.problem.descriptor=El método abstracto <code>#ref()</code> no está implementado en todas las subclases #loc
abstract.method.overrides.abstract.method.problem.descriptor=El método abstracto <code>#ref()</code> anula el método abstracto #loc
abstract.method.overrides.abstract.method.ignore.different.javadoc.option=Ignorar métodos con un Javadoc diferente al de sus súper métodos
abstract.class.extends.concrete.class.problem.descriptor=La clase <code>#ref</code> se declara 'abstracta' y extiende una clase concreta #loc
static.non.final.field.problem.descriptor=Campo 'estático' no 'final' <code>#ref</code> #loc
constant.declared.in.abstract.class.problem.descriptor=Constante <code>#ref</code> declarada en la clase abstracta #loc
constant.declared.in.interface.problem.descriptor=Constante <code>#ref</code> declarada en la interfaz #loc
static.inheritance.problem.descriptor=La interfaz <code>#ref</code> se implementa solo para sus constantes 'estáticas' #loc
utility.class.problem.descriptor=La clase <code>#ref</code> solo tiene miembros 'estáticos', lo que indica la construcción de procedimientos #loc
singleton.problem.descriptor=Class <code>#ref</code> es un singleton #loc
enum.singleton.problem.descriptor=Enum <code>#ref</code> es un singleton #loc
final.private.method.problem.descriptor=Método 'privado' declarado <code>#ref</code> #loc
noop.method.in.abstract.class.problem.descriptor=El método sin operación <code>#ref()</code> debe hacerse abstracto #loc
final.static.method.problem.descriptor=Método 'estático' declarado <code>#ref</code> #loc
class.without.no.arg.constructor.problem.descriptor=<code>#ref</code> no tiene constructor sin argumentos #loc
multiple.top.level.classes.in.file.problem.descriptor=Varias clases de nivel superior en el archivo
class.name.differs.from.file.name.problem.descriptor=El nombre de la clase <code>#ref</code> difiere del nombre de archivo #loc
marker.interface.problem.descriptor=Interfaz de marcador <code>#ref</code> #loc
field.has.setter.but.no.getter.problem.descriptor=El campo <code>#ref</code> tiene setter pero no getter #loc
abstract.class.never.implemented.problem.descriptor=La clase abstracta <code>#ref</code> no tiene una subclase concreta #loc
interface.never.implemented.problem.descriptor=Interface <code>#ref</code> no tiene una subclase concreta #loc
missing.deprecated.annotation.problem.descriptor=Falta la anotación '@Deprecated' #loc
missing.deprecated.tag.problem.descriptor=Falta la explicación de la etiqueta Javadoc '@deprecated' #loc
missing.deprecated.tag.option=Advertir sobre la explicación de la etiqueta Javadoc @deprecated que falta
missing.override.annotation.problem.descriptor=Falta la anotación '@Override' en <code>#ref()</code> #loc
missing.override.annotation.in.overriding.problem.descriptor=Los métodos anulados no se anotan con '@Override'
non.thread.safe.lazy.initialization.problem.descriptor=La inicialización diferida del campo 'estático' <code>#ref</code> no es seguro para subprocesos #loc
empty.finally.block.problem.descriptor=Bloque <code>#ref</code> vacío #loc
finally.block.cannot.complete.normally.problem.descriptor=<code>#ref</code> el bloque no se puede completar normalmente #loc
empty.try.block.problem.descriptor=Bloque <code>#ref</code> vacío #loc
throw.from.finally.block.problem.descriptor=<code>#ref</code> dentro del bloque 'finalmente' #loc
possible.throw.from.finally.block.problem.descriptor=<code>{0}</code> podría ser lanzado dentro del bloque '' finalmente '' #loc
throw,from.finally.block.everywhere.option=Advertir en todos los lugares donde se pueden lanzar excepciones declaradas
throw.caught.locally.problem.descriptor=<code>#ref</code> detectado al contener la declaración 'try' #loc
throw.caught.locally.ignore.option=Ignorar las excepciones repetidas
return.from.finally.block.problem.descriptor=<code>#ref</code> dentro del bloque 'finalmente' #loc
continue.or.break.from.finally.block.problem.descriptor=<code>#ref</code> dentro del bloque 'finalmente' #loc
bad.exception.declared.problem.descriptor=Excepción prohibida <code>#ref</code> declarada #loc
bad.exception.caught.problem.descriptor=Excepción prohibida <code>#ref</code> capturada #loc
checked.exception.class.problem.descriptor=Clase de excepción marcada <code>#ref</code> #loc
unchecked.exception.class.problem.descriptor=Clase de excepción sin marcar <code>#ref</code> #loc
thread.death.rethrown.problem.descriptor=ThreadDeath <code>#ref</code> no relanzado #loc
error.rethrown.problem.descriptor=Error <code>#ref</code> no reiniciado #loc
nested.try.statement.problem.descriptor=Instrucción <code>#ref</code> anidada #loc
exception.from.catch.which.doesnt.wrap.problem.descriptor=<code>#ref</code> dentro del bloque 'catch' ignora la excepción detectada #loc
instanceof.catch.parameter.problem.descriptor='instanceof' en el parámetro 'catch' <code>#ref</code> #loc
non.final.field.of.exception.problem.descriptor=Campo no final <code>#ref</code> de la clase de excepción #loc
unnecessary.label.on.break.statement.problem.descriptor=Etiqueta innecesaria en la declaración <code>#ref</code> #loc
unnecessary.label.on.continue.statement.problem.descriptor=Etiqueta innecesaria en la declaración <code>#ref</code> #loc
trivial.if.problem.descriptor=<code>#ref</code> declaración se puede simplificar #loc
unnecessary.parentheses.problem.descriptor=Los paréntesis alrededor de <code>#ref</code> son innecesarios #loc
unnecessary.local.variable.problem.descriptor=La variable local <code>#ref</code> es redundante #loc
unnecessary.this.problem.descriptor=<code>#ref</code> no es necesario en este contexto #loc
unnecessary.block.statement.problem.descriptor=Las llaves alrededor de esta declaración son innecesarias #loc
unnecessary.continue.problem.descriptor=<code>#ref</code> no es necesario como última declaración en un bucle #loc
unnecessary.semicolon.problem.descriptor=Punto y coma innecesario <code>#ref</code> #loc
unnecessary.semicolon.ignore.after.enum.constants.option=Ignorar puntos y comas innecesarios después de las constantes enum
unnecessary.fully.qualified.name.problem.descriptor1=El calificador <code>#ref</code> no es necesario y puede reemplazarse con un #loc de importación
unnecessary.fully.qualified.name.problem.descriptor2=El calificador <code>#ref</code> es innecesario y se puede eliminar #loc
unnecessary.qualifier.for.this.problem.descriptor=El calificador <code>#ref</code> en 'esto' es innecesario en este contexto #loc
unnecessary.qualifier.for.super.problem.descriptor=El calificador <code>#ref</code> en 'super' no es necesario en este contexto #loc
unused.label.problem.descriptor=Etiqueta no utilizada <code>#ref</code> #loc
redundant.field.initialization.problem.descriptor=La inicialización del campo a <code>#ref</code> es redundante #loc
redundant.implements.problem.descriptor=Declaración de interfaz redundante <code>#ref</code> #loc
extends.object.problem.descriptor=Class <code>#ref</code> extiende explícitamente 'java.lang.Object' #loc
type.parameter.extends.object.problem.descriptor1=El parámetro de tipo <code>#ref</code> extiende explícitamente 'java.lang.Object' #loc
type.parameter.extends.object.problem.descriptor2=El argumento de tipo comodín <code>#ref</code> extiende explícitamente 'java.lang.Object' #loc
unnecessary.super.constructor.problem.descriptor=<code>#ref</code> es innecesario #loc
unnecessary.constructor.problem.descriptor=El constructor sin argumentos <code>#ref()</code> es redundante #loc
unnecessary.constructor.annotation.option=Ignorar constructores con una anotación
for.loop.replaceable.by.while.problem.descriptor=<code>#ref</code> La declaración de bucle se puede reemplazar por el bucle 'while' #loc
unnecessary.default.problem.descriptor=<code>#ref</code> rama es innecesaria #loc
unnecessary.default.expressions.option=Solo reportar expresiones de cambio
unnecessary.default.quickfix=Eliminar la rama 'predeterminada'
unnecessary.boxing.problem.descriptor=Boxeo innecesario <code>#ref</code> #loc
unnecessary.boxing.inside.value.of.problem.descriptor=Boxing redundante dentro de <code>#ref</code> #loc
unnecessary.unboxing.problem.descriptor=Desembalaje innecesario <code>#ref</code> #loc
unnecessary.boxing.superfluous.option=Solo reportar expresiones verdaderamente superfluas en cajas
unnecessary.unboxing.superfluous.option=Solo reportar expresiones verdaderamente superfluas sin caja
for.can.be.foreach.problem.descriptor=<code>#ref</code> bucle reemplazable con mejorado 'for' #loc
while.can.be.foreach.problem.descriptor=<code>#ref</code> bucle reemplazable con mejorado 'for' #loc
too.broad.scope.problem.descriptor=El alcance de la variable <code>#ref</code> es demasiado amplio #loc
return.this.problem.descriptor=Devolución de <code>#ref</code> #loc
constant.on.side.of.comparison.display.name=Constante en el lado equivocado de la comparación
constant.on.lhs.of.comparison.problem.descriptor=Constante <code>#ref</code> en el lado izquierdo de la comparación #loc
constant.on.rhs.of.comparison.problem.descriptor=Constante <code>#ref</code> en el lado derecho de la comparación #loc
control.flow.statement.without.braces.problem.descriptor=<code>{0}</code> sin llaves #loc
missorted.modifiers.problem.descriptor=Modificadores mal clasificados <code>{0}</code> #loc
cstyle.array.variable.declaration.problem.descriptor=Declaración de matriz de estilo C de {0, choice, 1#campo | 2#parámetro | 3#componente de registro | 4#variable local} <code>#ref</code> #loc
cstyle.array.method.declaration.problem.descriptor=Declaración de matriz de estilo C del tipo de retorno del método <code>#ref()</code> #loc
multiple.declaration.problem.descriptor=Varias variables en una declaración #loc
multiple.typed.declaration.problem.descriptor=Variables con diferente dimensión de matriz en una declaración #loc
serializable.inner.class.has.serial.version.uid.field.problem.descriptor=La clase interna <code>#ref</code> no define un campo 'serialVersionUID' #loc
serializable.inner.class.with.non.serializable.outer.class.problem.descriptor=La clase interna <code>#ref</code> es serializable mientras que su clase externa no es #loc
busy.wait.problem.descriptor=Llamada a <code>Thread. #ref()</code> en un bucle, probablemente ocupado esperando #loc
sleep.while.holding.lock.problem.descriptor=Llamar a <code>Thread. #ref()</code> mientras está sincronizado #loc
non.atomic.operation.on.volatile.field.problem.descriptor=Operación no atómica en campo volátil <code>#ref</code> #loc
call.to.native.method.while.locked.problem.descriptor=Llamada al método nativo <code>#ref()</code> en un contexto sincronizado #loc
object.notify.problem.descriptor=<code>#ref</code> probablemente debería reemplazarse con 'notifyAll()' #loc
condition.signal.problem.descriptor=<code>#ref</code> probablemente debería reemplazarse con 'signalAll()' #loc
thread.with.default.run.method.problem.descriptor=Creación de una instancia de un <code>#ref</code> con el método 'run()' predeterminado #loc
extends.thread.problem.descriptor=Class <code>#ref</code> extiende directamente 'java.lang.Thread' #loc
anonymous.extends.thread.problem.descriptor=La clase anónima extiende directamente 'java.lang.Thread' #loc
naked.notify.problem.descriptor=Llamar a <code>#ref()</code> sin el cambio de estado correspondiente #loc
unconditional.wait.problem.descriptor=Llamada incondicional a <code>#ref()</code> #loc
system.run.finalizers.on.exit.problem.descriptor=Llamar a <code>System. #ref()</code> #loc
thread.priority.problem.descriptor=Llamada a <code>Thread. #ref()</code> #loc
thread.yield.problem.descriptor=Llamada a <code>Thread. #ref()</code> #loc
thread.stop.suspend.resume.problem.descriptor=Llamada a <code>Thread. #ref()</code> #loc
while.loop.spins.on.field.problem.descriptor=<code>#ref</code> bucle gira en el campo #loc
wait.not.in.loop.problem.descriptor=La llamada a <code>#ref()</code> no se realiza en un bucle #loc
await.not.in.loop.problem.descriptor=La llamada a <code>#ref()</code> no se realiza en un bucle #loc
wait.called.on.condition.problem.descriptor=Llamar a <code>#ref()</code> en el objeto Condición #loc
notify.called.on.condition.problem.descriptor=Llamar a <code>#ref()</code> en el objeto Condición #loc
wait.while.holding.two.locks.problem.descriptor=La llamada a <code>#ref()</code> se realiza mientras se mantienen dos bloqueos #loc
thread.run.problem.descriptor=Las llamadas a <code>#ref()</code> probablemente deberían reemplazarse con 'start()' #loc
thread.start.in.construction.problem.descriptor=Llamar a <code>#ref</code> durante la construcción del objeto #loc
synchronize.on.lock.problem.descriptor=Es poco probable que la sincronización en un objeto ''{0}'' sea intencional #loc
synchronized.on.literal.object.problem.descriptor=Sincronización en{0}<code>#ref</code> que se inicializa con un #loc literal
synchronized.on.direct.literal.object.problem.descriptor=Sincronización en{0}literal <code>#ref</code> #loc
synchronized.on.possibly.literal.object.problem.descriptor=Sincronización en{0}<code>#ref</code> #loc
synchronize.on.non.final.field.problem.descriptor=Sincronización en un campo no final <code>#ref</code> #loc
synchronized.on.literal.object.warn.on.all.option=Advertir sobre todos los literales posibles
synchronize.on.this.problem.descriptor=Las operaciones de bloqueo en 'esto' pueden tener efectos secundarios imprevistos #loc
synchronize.on.class.problem.descriptor=Las operaciones de bloqueo en una clase pueden tener efectos secundarios imprevistos #loc
nested.synchronized.statement.problem.descriptor=Instrucción <code>#ref</code> anidada #loc
empty.synchronized.statement.problem.descriptor=Vacío <code>#ref</code> declaración #loc
non.synchronized.method.overrides.synchronized.method.problem.descriptor=El método no sincronizado <code>#ref()</code> anula el método sincronizado #loc
public.field.accessed.in.synchronized.context.problem.descriptor=Campo no privado <code>#ref</code> al que se accede en contexto sincronizado #loc
field.accessed.synchronized.and.unsynchronized.problem.descriptor=Se accede al campo <code>#ref</code> en contextos sincronizados y no sincronizados #loc
extended.for.statement.problem.descriptor=Extendida <code>#ref</code> declaración #loc
object.allocation.in.loop.new.descriptor=Asignación de objetos <code>new#ref()</code> en el bucle #loc
object.allocation.in.loop.problem.array.initializer.descriptor=Asignación de matriz en el bucle #loc
object.allocation.in.loop.problem.call.descriptor=Asignación de objetos a través de la llamada <code>#ref()</code> en el bucle #loc
object.allocation.in.loop.problem.methodref.descriptor=Asignación de objetos a través de la referencia del método vinculado a la instancia <code>#ref()</code> en el bucle #loc
object.allocation.in.loop.problem.lambda.descriptor=Asignación de objetos mediante la captura de lambda en el bucle #loc
object.allocation.in.loop.problem.string.concat=Asignación de objetos a través de la concatenación de cadenas en el bucle #loc
instantiating.object.to.get.class.object.problem.descriptor=Creación de instancias del objeto para obtener el objeto Class #loc
field.may.be.static.problem.descriptor=El campo <code>#ref</code> puede ser #loc 'estático'
method.may.be.static.problem.descriptor=El método <code>#ref()</code> puede ser 'estático' #loc
class.initializer.may.be.static.problem.descriptor=El inicializador de clase puede ser 'estático' #loc
map.replaceable.by.enum.map.problem.descriptor=<code>#ref</code> reemplazable por 'EnumMap' #loc
set.replaceable.by.enum.set.problem.descriptor=<code>#ref</code> reemplazable por 'EnumSet' #loc
inner.class.may.be.static.problem.descriptor=La clase interna <code>#ref</code> puede ser 'estática' #loc
string.buffer.must.have.initial.capacity.problem.descriptor=<code>new#ref()</code> sin capacidad inicial #loc
string.buffer.replaceable.by.string.builder.problem.descriptor=<code>StringBuffer#ref</code> puede declararse como 'StringBuilder' #loc
string.buffer.replaceable.by.string.problem.descriptor=<code>{0}#ref</code> se puede reemplazar con '' String '' #loc
new.string.buffer.replaceable.by.string.problem.descriptor=<code>#ref</code> se puede reemplazar con 'String' #loc
string.replaceable.by.string.buffer.problem.descriptor=El <code>String#ref</code> no constante probablemente debería declararse como '' StringBuilder '' #loc
collections.must.have.initial.capacity.problem.descriptor=<code>new#ref()</code> sin capacidad inicial #loc
string.concatenation.in.loops.problem.descriptor=Concatenación de cadenas <code>#ref</code> en el bucle #loc
string.concatenation.inside.string.buffer.append.problem.descriptor=Concatenación de cadenas como argumento para <code> {0}. #ref()</code> llamada #loc
boolean.constructor.problem.descriptor=Llamada al constructor booleano #loc
string.buffer.to.string.in.concatenation.problem.descriptor=Llamada a <code> {0}. #ref()</code> en concatenación #loc
tail.recursion.problem.descriptor=Llamada recursiva de cola <code>#ref()</code> #loc
string.equals.empty.string.problem.descriptor=<code>#ref("")</code> se puede reemplazar con 'length() == 0' #loc
string.equals.empty.string.is.empty.problem.descriptor=<code>#ref("")</code> se puede reemplazar con 'isEmpty()' #loc
random.double.for.random.integer.problem.descriptor=Usando <code> Random.#Ref</code> para crear un número entero aleatorio #loc
manual.array.copy.problem.descriptor=Copia manual de matriz #loc
manual.array.to.collection.copy.problem.descriptor=Matriz manual a copia de colección #loc
call.to.simple.getter.in.class.problem.descriptor=Llamada al getter simple <code>#ref()</code> desde dentro de la clase #loc
call.to.simple.setter.in.class.problem.descriptor=Llamada a simple setter <code>#ref()</code> desde dentro de la clase #loc
assert.without.message.problem.descriptor=<code>#ref()</code> sin mensaje #loc
assert.without.message.quick.fix.family.name=Agregar mensaje de error
misordered.assert.equals.arguments.problem.descriptor=Argumentos para <code>#ref()</code> en orden incorrecto #loc
simplifiable.junit.assertion.problem.descriptor=<code>#ref()</code> puede simplificarse a ''{0}'' #loc
test.case.with.no.test.methods.problem.descriptor=La clase de prueba <code>#ref</code> no tiene pruebas #loc
deserializable.class.in.secure.context.problem.descriptor=La clase <code>#ref</code> puede ser deserializada, comprometiendo la seguridad #loc
serializable.class.in.secure.context.problem.descriptor=La clase <code>#ref</code> puede ser serializada, comprometiendo la seguridad #loc
serializable.deserializable.class.in.secure.context.problem.descriptor=La clase <code>#ref</code> puede ser serializada y deserializada, comprometiendo la seguridad #loc
cloneable.class.in.secure.context.problem.descriptor=La clase <code>#ref</code> puede ser clonada, comprometiendo la seguridad #loc
cloneable.class.in.secure.context.quickfix=Genera el método 'clone()' que siempre arroja una excepción
remove.cloneable.quickfix=Eliminar 'Cloneable' de la cláusula de implementos
non.final.clone.problem.descriptor=Método <code>#ref()</code> no final, comprometiendo la seguridad #loc
runtime.exec.with.non.constant.string.problem.descriptor=Llamada a <code>Runtime. #ref()</code> con argumento no constante #loc
load.library.with.non.constant.string.problem.descriptor=Llamada a <code>{0}. #ref()</code> con argumento no constante #loc
jdbc.execute.with.non.constant.string.problem.descriptor=Llamada a <code>Statement. #ref()</code> con argumento no constante #loc
jdbc.prepare.statement.with.non.constant.string.problem.descriptor=Llamada a <code>Connection. #ref()</code> con argumento no constante #loc
custom.classloader.problem.descriptor=Clase ClassLoader personalizada <code>#ref</code> #loc
custom.security.manager.problem.descriptor=Clase de SecurityManager personalizada <code>#ref</code> #loc
system.set.problem.descriptor=La llamada a <code>System. #ref()</code> puede plantear problemas de seguridad #loc
class.loader.instantiation.problem.descriptor=La creación de instancias de <code>#ref</code> puede plantear problemas de seguridad #loc
public.static.array.field.problem.descriptor=Campo de matriz 'public static' <code>#ref</code>, comprometiendo la seguridad #loc
public.static.collection.field.problem.descriptor=Campo de colección 'public static' <code>#ref</code>, comprometiendo la seguridad #loc
abstract.class.with.only.one.direct.inheritor.problem.descriptor=La clase abstracta <code>#ref</code> tiene solo un heredero directo #loc
abstract.method.overrides.abstract.method.remove.quickfix=Eliminar la declaración de método abstracto redundante
class.may.be.interface.convert.quickfix=Convertir clase en interfaz
class.without.constructor.create.quickfix=Generar constructor vacío
class.without.no.arg.constructor.ignore.option=Ignorar si la clase tiene un constructor predeterminado
extends.annotation.problem.descriptor=Class ''{0}'' implementa la interfaz de anotación <code>#ref</code> #loc
extends.annotation.interface.problem.descriptor=Interfaz ''{0}'' extiende la interfaz de anotaciones <code>#ref</code> #loc
extends.concrete.collection.problem.descriptor=Class <code>#ref</code> extiende explícitamente ''{0}'' #loc
anonymous.extends.concrete.collection.problem.descriptor=La clase anónima extiende explícitamente ''{0}'' #loc
inner.class.on.interface.ignore.option=Ignorar interfaces internas de interfaces
inner.class.on.interface.problem.descriptor=La interfaz ''{0}'' tiene una clase interna <code>#ref</code> #loc
missing.deprecated.annotation.add.quickfix=Agregar anotación @Deprecated
missing.add.deprecated.javadoc.tag.quickfix=Agregar etiqueta Javadoc '@deprecated'
non.protected.constructor.in.abstract.class.ignore.option=Ignorar para clases no públicas
public.constructor.in.non.public.class.problem.descriptor=El constructor se declara <code>#ref</code> en la clase no pública ''{0}'' #loc
static.inheritance.replace.quickfix=Reemplazar herencia con referencias calificadas en {0}
utility.class.with.public.constructor.make.quickfix=Haz {0,choice, 1#constructor | 2#constructores} 'privado'
utility.class.without.private.constructor.create.quickfix=Generar constructor 'privado' vacío
utility.class.without.private.constructor.make.quickfix=Hacer que el constructor sea 'privado'
naming.convention.problem.descriptor.short={0} nombre <code>#ref</code> es demasiado corto ({1} <{2}) #loc
naming.convention.problem.descriptor.long={0} nombre <code>#ref</code> es demasiado largo ({1}> {2}) #loc
naming.convention.problem.descriptor.regex.mismatch={0} name <code>#ref</code> no coincide con regex ''{1}'' #loc
local.variable.naming.convention.ignore.option=Ignorar parámetros de bucle for
local.variable.naming.convention.ignore.catch.option=Ignorar los parámetros del bloque 'catch'
method.names.differ.only.by.case.problem.descriptor=El nombre del método <code>#ref</code> y el nombre del método ''{0}'' difieren solo en el caso #loc
parameter.name.differs.from.overridden.parameter.ignore.character.option=Ignorar si el parámetro reemplazado contiene solo un carácter
parameter.name.differs.from.overridden.parameter.ignore.library.option=Ignorar si el parámetro reemplazado es de una biblioteca
parameter.name.differs.from.overridden.parameter.problem.descriptor=El nombre del parámetro <code>#ref</code> es diferente del parámetro ''{0}'' anulado #loc
questionable.name.column.title=Nombre
questionable.name.list.label=Nombres reportados:
standard.variable.names.problem.descriptor=La variable denominada <code>#ref</code> no tiene el tipo ''{0}'' #loc
standard.variable.names.problem.descriptor2=La variable denominada <code>#ref</code> no tiene el tipo ''{0}'' o ''{1}'' #loc
standard.variable.names.ignore.override.option=Ignorar los nombres de los parámetros idénticos a los parámetros del súper método
boolean.method.name.must.start.with.question.table.label=Prefijos de nombres de métodos booleanos:
conditional.expression.with.identical.branches.collapse.quickfix=Contraer expresión condicional
redundant.else.unwrap.quickfix=Eliminar el 'else' redundante
constant.conditional.expression.problem.descriptor=<code>#ref</code> se puede simplificar a ''{0}'' #loc
constant.conditional.expression.simplify.quickfix=Simplificar
constant.conditional.expression.simplify.quickfix.sideEffect=Extrae efectos secundarios y simplifica
enum.switch.statement.which.misses.cases.problem.descriptor.single=<code>#ref</code> declaración sobre el tipo de enumeración ''{0}'' falta caso ''{1}'' #loc
enum.switch.statement.which.misses.cases.problem.descriptor=<code>#ref</code> declaración en el tipo de enumeración ''{0}'' casos de error: {1} #loc
for.loop.replaceable.by.while.ignore.option=Ignorar 'infinito' para bucles sin condiciones
for.loop.with.missing.component.problem.descriptor1=La declaración <code>#ref</code> carece de inicializador #loc
for.loop.with.missing.component.problem.descriptor2=La declaración <code>#ref</code> carece de la condición #loc
for.loop.with.missing.component.problem.descriptor3=La declaración <code>#ref</code> carece de actualización #loc
for.loop.with.missing.component.problem.descriptor4=La declaración <code>#ref</code> carece de inicializador y condición #loc
for.loop.with.missing.component.problem.descriptor5=La declaración <code>#ref</code> carece de inicializador y actualización #loc
for.loop.with.missing.component.problem.descriptor6=La declaración <code>#ref</code> carece de condición y actualiza #loc
for.loop.with.missing.component.problem.descriptor7=La declaración <code>#ref</code> carece de inicializador, condición y actualización #loc
foreach.replace.quickfix=Reemplazar con mejorado 'for'
unnecessary.boxing.remove.quickfix=Eliminar el boxeo
unnecessary.unboxing.remove.quickfix=Eliminar unboxing
misordered.assert.equals.arguments.flip.quickfix=Cambiar argumentos comparados
simplify.junit.assertion.simplify.quickfix=Simplificar la afirmación
system.properties.problem.descriptor=La llamada a <code> Integer. #ref()</code> puede plantear problemas de seguridad #loc
system.properties.problem.descriptor1=La llamada a <code> Boolean. #ref()</code> puede plantear problemas de seguridad #loc
unsecure.random.number.generation.problem.descriptor1=Por motivos de seguridad, utilice 'java.security.SecureRandom' en lugar de <code> java.lang.Math. #ref()</code> #loc
unsecure.random.number.generation.problem.descriptor2=Por motivos de seguridad, utilice 'java.security.SecureRandom' en lugar de <code> java.util.#ref</code> #loc
unsecure.random.number.generation.problem.descriptor3=Por motivos de seguridad, utilice 'java.security.SecureRandom' en lugar de <code>#ref</code> #loc
serializable.has.serialization.methods.problem.descriptor=La clase serializable <code>#ref</code> no define 'readObject()' o 'writeObject()' #loc
serializable.has.serialization.methods.problem.descriptor1=La clase serializable <code>#ref</code> no define 'writeObject()' #loc
serializable.has.serialization.methods.problem.descriptor2=La clase serializable <code>#ref</code> no define 'readObject()' #loc
serializable.with.unconstructable.ancestor.problem.descriptor=<code>#ref</code> tiene un ancestro no serializable ''{0}'' sin constructor sin argumentos #loc
transient.field.in.non.serializable.class.problem.descriptor=El campo ''{0}'' está marcado como <code>#ref</code>, en la clase no serializable #loc
safe.lock.problem.descriptor=''{0}'' debe estar bloqueado frente a un bloque ''try'' y desbloqueado en el bloque '' finalmente '' correspondiente #loc
synchronized.method.problem.descriptor=Método '' {0}() '' declarado <code>#ref</code> #loc
synchronized.method.include.option=Incluir métodos nativos
synchronized.method.ignore.synchronized.super.option=Ignorar métodos que anulan un método sincronizado
synchronized.method.move.quickfix=Mover la sincronización al método
volatile.field.problem.descriptor=Campo volátil <code>#ref</code> de tipo ''{0}'' #loc
string.format.choose.class=Elija la clase Formatter
string.format.class.column.name=Clases de formateador adicionales
string.format.class.label=Clases de formateador adicionales:
string.format.class.method.name=Métodos de formateador adicionales
string.format.class.method.label=Métodos de formateo adicionales:
bad.exception.thrown.problem.descriptor=Excepción prohibida ''{0}'' lanzada #loc
too.broad.catch.problem.descriptor=''catch'' de <code>#ref</code> es demasiado amplio, enmascarando la excepción ''{0}'' #loc
too.broad.catch.problem.descriptor1=''catch'' de <code>#ref</code> es demasiado amplio y enmascara las excepciones ''{0}'' y ''{1}'' #loc
add.serialversionuidfield.quickfix=Agregar campo 'serialVersionUID'
delete.import.quickfix=Eliminar importación innecesaria
encapsulate.variable.quickfix=Encapsular campo ''{0}''
extract.method.quickfix=Método de extracción
inline.call.quickfix=Llamada en línea
inline.variable.quickfix=Variable en línea
pointless.nullcheck.display.name=Verificación 'nula' innecesaria antes de la llamada al método
pointless.nullcheck.problem.descriptor.call=Verificación '' nula '' innecesaria antes de la llamada '' {0}() ''
remove.redundant.polyadic.operand.fix.name=Eliminar condición innecesaria ''{0}''
remove.redundant.polyadic.operand.fix.family.name=Eliminar condición innecesaria
introduce.constant.quickfix=Introduce constante
make.initialization.explicit.quickfix=Hacer explícita la inicialización
move.anonymous.to.inner.quickfix=Convertir a clase interna con nombre
anonymous.inner.may.be.named.static.inner.class.quickfix=Convertir a clase interna 'estática' nombrada
move.class.quickfix=Mover clase
normalize.declaration.quickfix=Dividir en declaraciones separadas
remove.modifier.quickfix=Eliminar modificador ''{0}''
replace.inheritance.with.delegation.quickfix=Reemplazar herencia con delegación
cast.that.loses.precision.problem.descriptor=La conversión de ''{0}'' a <code>#ref</code> puede provocar una pérdida de precisión #loc
cast.that.loses.precision.negative.problem.descriptor=La conversión de ''{0}'' a <code>#ref</code> puede resultar en la pérdida de precisión para el argumento negativo #loc
comparison.to.nan.problem.descriptor1=La comparación con <code>#ref</code> es siempre falsa #loc
comparison.to.nan.problem.descriptor2=La comparación con <code>#ref</code> es siempre verdadera #loc
confusing.floating.point.literal.change.quickfix=Cambiar a forma canónica
implicit.numeric.conversion.ignore.widening.conversion.option=Ignorar conversiones de ampliación
implicit.numeric.conversion.ignore.char.conversion.option=Ignorar conversiones desde y hacia char
implicit.numeric.conversion.ignore.constant.conversion.option=Ignorar conversiones de constantes y literales
implicit.numeric.conversion.problem.descriptor=Conversión numérica implícita de <code>#ref</code> de ''{0}'' a ''{1}'' #loc
implicit.numeric.conversion.assignment.problem.descriptor=Conversión numérica implícita del valor del resultado de ''{0}'' a ''{1}'' #loc
implicit.numeric.conversion.make.explicit.quickfix=Hacer explícita la conversión
non.reproducible.math.call.replace.quickfix=Reemplazar con llamada 'StrictMath'
overly.complex.arithmetic.expression.max.number.option=Número máximo de términos:
expression.can.be.replaced.problem.descriptor=<code>#ref</code> se puede reemplazar con ''{0}'' #loc
method.complexity.limit.option=Límite de complejidad del método:
expression.can.be.replaced.no.quotes.problem.descriptor={0} se puede reemplazar con {1}
cyclomatic.complexity.problem.descriptor=Método demasiado complejo <code>#ref()</code> (complejidad ciclomática={0}) #loc
method.coupling.limit.option=Límite de acoplamiento del método:
method.coupling.problem.descriptor=<code>#ref</code> está demasiado acoplado (# clases referenciadas={0}) #loc
method.with.multiple.loops.problem.descriptor=<code>#ref</code> contiene{0}bucles #loc
return.point.limit.option=&Límite de punto de retorno:
multiple.return.points.per.method.problem.descriptor=<code>#ref</code> tiene{0}puntos de retorno #loc
nesting.depth.limit.option=Límite de profundidad de anidación:
nesting.depth.problem.descriptor=<code>#ref</code> está demasiado anidado (profundidad máxima de anidamiento={0}) #loc
non.comment.source.statements.limit.option=Límite de declaraciones de fuentes sin comentarios:
non.comment.source.statements.problem.descriptor=<code>#ref</code> es demasiado largo (# declaraciones de origen sin comentarios={0}) #loc
parameters.per.method.problem.descriptor=<code>#ref()</code> tiene demasiados parámetros (num parameters={0}) #loc
parameters.per.constructor.problem.descriptor=<code>#ref()</code> tiene demasiados parámetros (num parameters={0}) #loc
parameter.limit.option=Límite de parámetro:
constructor.visibility.option=Ignorar constructores con visibilidad:
three.negations.per.method.ignore.option=Ignorar negaciones en métodos 'equals()'
three.negations.per.method.ignore.assert.option=Ignorar negaciones en declaraciones 'assert'
three.negations.per.method.problem.descriptor=<code>#ref</code> contiene{0}negaciones #loc
thrown.exceptions.per.method.problem.descriptor=<code>#ref</code> tiene demasiadas excepciones declaradas (num exceptions={0}) #loc
thrown.exceptions.per.method.limit.option=Límite de excepciones lanzadas:
call.to.simple.getter.in.class.ignore.option=Ignorar las llamadas de getter en otros objetos
call.to.private.simple.getter.in.class.option=Solo informar cuando getter es 'privado'
call.to.simple.getter.in.class.inline.quickfix=Llamada en línea al getter
call.to.simple.setter.in.class.ignore.option=Ignorar las llamadas del setter en otros objetos
call.to.private.setter.in.class.option=Solo informar cuando el setter es 'privado'
call.to.simple.setter.in.class.inline.quickfix=Llamada en línea a setter
make.static.quickfix=Hacer 'estático'
length.one.strings.in.concatenation.replace.quickfix=Reemplazar con carácter
multiply.or.divide.by.power.of.two.replace.quickfix=Reemplazar con turno
boolean.expression.can.be.simplified.problem.descriptor=<code>#ref</code> puede simplificarse a ''{0}'' #loc
boolean.expression.does.not.modify.problem.descriptor=<code>#ref</code> no modifica el valor de ''{0}'' #loc
boolean.expression.remove.compound.assignment.quickfix=Eliminar asignación compuesta sin sentido
trivial.string.concatenation.problem.descriptor=Cadena vacía utilizada en la concatenación
string.replace.quickfix=Reemplazar la concatenación con ''{0}''
instantiating.object.to.get.class.object.replace.quickfix=Reemplazar con acceso directo al objeto de clase
method.may.be.static.only.option=Solo verifique los métodos 'privados' o 'finales'
method.may.be.static.empty.option=Ignorar métodos vacíos
string.concatenation.inside.string.buffer.append.replace.quickfix=Reemplazar con llamadas encadenadas 'append()'
string.equals.empty.string.option.do.not.add.null.check=No informar cuando pueda ser necesaria una verificación nula
tail.recursion.replace.quickfix=Reemplazar la recursividad de cola con iteración
if.statement.with.too.many.branches.max.option=Número máximo de ramas:
if.statement.with.too.many.branches.problem.descriptor=<code>#ref</code> tiene demasiadas ramas ({0}) #loc
negated.conditional.invert.quickfix=Condición de inversión
negated.if.else.ignore.negated.null.option=Ignorar comparaciones '!=null'
negated.if.else.ignore.negated.zero.option=Ignore '!=0' comparaciones
negated.if.else.invert.quickfix=Invertir la condición 'if'
overly.complex.boolean.expression.max.terms.option=Número máximo de términos:
pointless.boolean.expression.ignore.option=Ignore las constantes nombradas al determinar expresiones sin sentido
simplifiable.conditional.expression.problem.descriptor=<code>#ref</code> se puede simplificar a ''{0}'' #loc
switch.statement.density.min.option=Densidad mínima de ramas:%
switch.statement.density.problem.descriptor=<code>#ref</code> tiene una densidad de rama demasiado baja ({0}%) #loc
switch.statement.with.too.few.branches.min.option=Número mínimo de ramas:
switch.statement.with.too.few.branches.problem.descriptor=La declaración ''switch'' tiene muy pocas etiquetas de caso ({0}), y probablemente debería reemplazarse con una declaración ''if'' #loc
switch.statement.with.single.default.message=La declaración 'switch' solo tiene el caso 'predeterminado'
switch.expression.with.too.few.branches.problem.descriptor=La expresión ''switch'' tiene muy pocas etiquetas de mayúsculas y minúsculas ({0}), y probablemente debería reemplazarse con una declaración ''if'' o un operador condicional#loc
switch.expression.with.single.default.message=La expresión 'switch' solo tiene el caso 'predeterminado'
switch.statement.without.default.ignore.option=Ignorar si todos los casos de un tipo de enumeración están cubiertos
unnecessary.label.remove.quickfix=Eliminar etiqueta
unnecessary.return.problem.descriptor=<code>#ref</code> es innecesario como última declaración en un método 'void' #loc
unnecessary.return.constructor.problem.descriptor=<code>#ref</code> no es necesario como última declaración en un constructor #loc
unused.label.remove.quickfix=Eliminar etiqueta no utilizada
unnecessarily.qualified.static.usage.problem.descriptor=Llamada a método estático innecesariamente calificado <code> {0}()</code> #loc
unnecessarily.qualified.static.usage.problem.descriptor1=Acceso estático innecesariamente calificado <code>{0}</code> #loc
unnecessarily.qualified.static.usage.ignore.field.option=Ignorar accesos de campo innecesariamente calificados
unnecessarily.qualified.static.usage.ignore.method.option=Ignorar llamadas a métodos innecesariamente calificados
unnecessary.interface.modifier.problem.descriptor=El modificador <code>#ref</code> es redundante para interfaces #loc
smth.unnecessary.remove.quickfix=Eliminar innecesarios ''{0}''
unqualified.static.usage.problem.descriptor=Llamada de método estático no calificado <code>#ref()</code> #loc
unqualified.static.usage.problem.descriptor1=Acceso a campo estático no calificado <code>#ref</code> #loc
unqualified.static.usage.ignore.field.option=Ignorar accesos de campo no calificados
unqualified.static.usage.ignore.method.option=Ignorar llamadas a métodos no calificados
unqualified.static.usage.qualify.field.quickfix=Calificar el acceso al campo estático
unqualified.static.usage.qualify.method.quickfix=Calificar llamada de método estático
too.broad.scope.allow.option=<html>Informar variables con una nueva expresión como inicializador <br> (Potencialmente inseguro: la solución rápida puede modificar la semántica si el constructor tiene efectos secundarios no locales)</html>
too.broad.scope.only.blocks.option=Solo reportar variables que se pueden mover a bloques internos
too.broad.scope.narrow.quickfix=Mueve la declaración de ''{0}'' más cerca de los usos
press.escape.to.remove.highlighting.message=Presione Escape para eliminar el resaltado
literal.as.arg.to.string.equals.problem.descriptor=El <code>#ref</code> literal es el argumento de '' {0}() '', en lugar de su calificador #loc
literal.as.arg.to.string.equals.flip.quickfix=Voltear '' {0}() ''
c.style.array.declaration.replace.quickfix=Reemplazar con declaración de matriz de estilo Java
chained.method.call.ignore.option=Ignorar llamadas a métodos encadenados en inicializadores de campo
chained.method.call.ignore.self.types.option=Ignorar las llamadas a los métodos que devuelven el mismo tipo que su clase adjunta
introduce.variable.quickfix=Introducir variable
introduce.variable.may.change.semantics.quickfix=Introducir variable (puede cambiar la semántica)
flip.comparison.quickfix=Comparación de volteo
control.flow.statement.without.braces.add.quickfix=Agregar llaves a la declaración
control.flow.statement.without.braces.message=Agregar llaves a la declaración ''{0}''
extends.object.remove.quickfix=Eliminar el 'objeto extendido' redundante
implicit.call.to.super.ignore.option=Ignorar las subclases directas de 'java.lang.Object'
implicit.call.to.super.make.explicit.quickfix=Hacer una llamada a 'super()' explícita
missorted.modifiers.require.option=Verificar el orden de las anotaciones
missorted.modifiers.typeuse.before.type.option=Las anotaciones de TYPE_USE de destino siempre van antes del tipo
missorted.modifiers.sort.quickfix=Modificadores de clasificación
nested.method.call.ignore.option=Ignorar las llamadas a métodos anidados en los inicializadores de campo
ignore.calls.to.static.methods=Ignorar llamadas a métodos estáticos
ignore.calls.to.property.getters=Ignorar llamadas a captadores de propiedades
redundant.field.initialization.remove.quickfix=Eliminar inicializador
redundant.implements.remove.quickfix=Eliminar declaración de interfaz redundante
unnecessary.constructor.remove.quickfix=Eliminar constructor redundante
unnecessary.fully.qualified.name.replace.quickfix=Reemplazar nombre calificado con importación
unnecessary.fully.qualified.name.remove.quickfix=Eliminar la calificación innecesaria
unnecessary.fully.qualified.name.status.bar.escape.highlighting.message={0} totalmente calificado {0, choice, 1#name | 2#names} reemplazado con import (presione Escape para eliminar el resaltado)
unnecessary.parentheses.remove.quickfix=Elimina los paréntesis innecesarios
unnecessary.qualifier.for.this.remove.quickfix=Eliminar calificador innecesario
unnecessary.semicolon.remove.quickfix=Eliminar el punto y coma innecesario
unnecessary.super.constructor.remove.quickfix=Eliminar 'super()' innecesario
unnecessary.this.remove.quickfix=Elimina el calificador innecesario 'este'
overly.strong.type.cast.problem.descriptor=La conversión a <code>#ref</code> se puede debilitar a ''{0}'' #loc
field.count.inspection.include.constant.fields.in.count.checkbox=Incluir campos constantes en el recuento
field.count.inspection.static.final.fields.count.as.constant.checkbox=Los campos 'static final' cuentan como constantes
field.count.inspection.include.enum.constants.in.count=Incluir constantes de enumeración en el recuento
make.method.final.fix.name=Crear método ''{0}()'' ''final''
make.class.final.fix.name=Hacer clase ''{0}'' ''final''
non.boolean.method.name.must.not.start.with.question.display.name=El nombre del método no booleano no debe comenzar con una palabra de pregunta
non.boolean.method.name.must.not.start.with.question.problem.descriptor=El nombre del método no booleano <code>#ref</code> comienza con una palabra de pregunta #loc
boolean.constructor.simplify.quickfix=Simplificar
only.report.qualified.static.usages.option=Informar solo acceso estático calificado desde un contexto estático
unqualified,static.usage.only.report.static.usages.option=Solo informa el acceso estático desde un contexto no estático
assignment.to.catch.block.parameter.problem.descriptor=Asignación al parámetro de bloque 'catch' <code>#ref</code> #loc
assignment.to.method.parameter.problem.descriptor=Asignación al parámetro del método <code>#ref</code> #loc
value.of.post.increment.problem.descriptor=Se usa el valor de la expresión posterior al incremento <code>#ref</code> #loc
value.of.post.decrement.problem.descriptor=Se usa el valor de la expresión de post-decremento <code>#ref</code> #loc
value.of.pre.increment.problem.descriptor=Se usa el valor de la expresión de preincremento <code>#ref</code> #loc
value.of.pre.decrement.problem.descriptor=Se usa el valor de la expresión de pre-decremento <code>#ref</code> #loc
assignment.replaceable.with.operator.assignment.problem.descriptor=<code>#ref</code> podría simplificarse a ''{0}'' #loc
assignment.replaceable.with.operator.assignment.ignore.conditional.operators.option=Ignorar operadores condicionales
assignment.replaceable.with.operator.assignment.ignore.obscure.operators.option=Ignorar los operadores oscuros ^ y%
object.equality.ignore.between.objects.of.a.type.with.only.private.constructors.option=Ignore '==' entre objetos de un tipo con solo constructores 'privados'
redundant.method.override.display.name=El método es idéntico a su súper método
redundant.method.override.delegates.to.super.problem.descriptor=El método <code>#ref()</code> solo delega en su súper método #loc
redundant.method.override.problem.descriptor=El método <code> #ref()</code> es idéntico a su súper método #loc
redundant.method.override.quickfix=Eliminar método redundante
redundant.method.override.option.check.library.methods=Verificar métodos que anulan los métodos de la biblioteca
refused.bequest.problem.descriptor=El método <code> #ref()</code> no llama a 'super.#ref()' #loc
refused.bequest.ignore.empty.super.methods.option=Ignorar supermétodos vacíos
refused.bequest.ignore.default.super.methods.option=Ignorar los súper métodos 'predeterminados'
overly.complex.boolean.expression.ignore.option=Ignorar conjunciones y disyunciones puras
pointless.indexof.comparison.display.name=Comparación sin sentido 'indexOf()'
pointless.indexof.comparison.always.true.problem.descriptor=<code>#ref</code> es siempre verdadero #loc
pointless.indexof.comparison.always.false.problem.descriptor=<code>#ref</code> es siempre falso #loc
reuse.of.local.variable.problem.descriptor=Reutilización de la variable local <code>#ref</code> #loc
single.character.startswith.display.name=Carácter único 'startsWith()' o 'endsWith()'
single.character.startswith.problem.descriptor=Un solo carácter <code>#ref()</code> podría reemplazarse con la expresión 'charAt()' #loc
list.indexof.replaceable.by.contains.display.name=La expresión 'List.indexOf()' es reemplazable por 'contains()'
string.indexof.replaceable.by.contains.display.name=La expresión 'String.indexOf()' es reemplazable por 'contains()'
overloaded.methods.with.same.number.parameters.problem.descriptor=Varios métodos llamados <code>#ref</code> con el mismo número de parámetros #loc
overloaded.vararg.method.problem.descriptor=Método varargs sobrecargado <code>#ref()</code> #loc
overloaded.vararg.constructor.problem.descriptor=Constructor de varargs sobrecargado <code>#ref()</code> #loc
cached.number.constructor.call.display.name=Llamada al constructor de números con argumento primitivo
cached.number.constructor.call.problem.descriptor=Llamada al constructor de números con argumento primitivo #loc
cached.number.constructor.call.ignore.string.arguments.option=Ignorar nuevas expresiones numéricas con un argumento de cadena
cached.number.constructor.call.report.only.deprecated=Informar solo cuando el constructor es @Deprecated
chained.equality.comparisons.problem.descriptor=Comparación de igualdad encadenada <code>#ref</code> #loc
confusing.octal.escape.sequence.problem.descriptor=Secuencia de escape octal <code>#ref</code> seguida inmediatamente por el dígito #loc
field.accessed.synchronized.and.unsynchronized.option=Los getters y setters simples también se consideran accesos de campo
method.overrides.inaccessible.method.display.name=El método anula el método inaccesible de la superclase
method.overrides.package.local.method.problem.descriptor=El método <code>#ref()</code> anula un método privado de paquete de una superclase ubicada en otro paquete #loc
suspicious.to.array.call.display.name=Llamada sospechosa 'Collection.toArray()'
suspicious.to.array.call.problem.descriptor=Se esperaba una matriz de tipo ''{0}[] '', se encontró #loc
suspicious.system.arraycopy.display.name=Llamada sospechosa 'System.arraycopy()'
suspicious.system.arraycopy.problem.descriptor4=<code>#ref</code> no es de un tipo de matriz #loc
suspicious.system.arraycopy.problem.descriptor5=<code>#ref</code> no es de un tipo de matriz #loc
suspicious.system.arraycopy.problem.descriptor6=El tipo de parámetro de origen ''{0}'' no se puede asignar al parámetro de destino <code>#ref</code> de tipo ''{1}'' #loc
suspicious.system.arraycopy.problem.descriptor.length.bigger.src=La longitud siempre es mayor que '' src.length - srcPos '' {0}
suspicious.system.arraycopy.problem.descriptor.length.bigger.dest=La longitud siempre es mayor que '' dest.length - destPos '' {0}
suspicious.system.arraycopy.problem.descriptor.ranges.intersect=Copiando a la misma matriz con rangos de intersección
method.only.used.from.inner.class.display.name=Método privado solo usado desde la clase interna
method.only.used.from.inner.class.problem.descriptor=El método <code>#ref()</code> #loc solo se usa desde la clase interna ''{0}'' #loc
method.only.used.from.inner.class.ignore.option=Ignorar los métodos a los que se accede desde una clase &anónima
only.report.static.methods=&Solo reportar métodos 'static'
single.character.startswith.quickfix=Reemplazar con la expresión 'charAt()'
interface.never.implemented.option=Ignorar interfaces que solo declaran constantes
size.replaceable.by.isempty.display.name=Tamaño() == 0' reemplazable por 'isEmpty()
size.replaceable.by.isempty.negation.ignore.option=Ignorar expresiones que serían reemplazadas por '!isEmpty()'
size.replaceable.by.isempty.fix.ignore.calls=Ignorando la llamada ''.{0}()'' al escribir ''{1}''
choose.class.type.to.ignore=Elija el tipo de clase para ignorar
loop.condition.not.updated.inside.loop.display.name=Variable de bucle no actualizada dentro del bucle
loop.variable.not.updated.inside.loop.problem.descriptor=La variable '#ref' no se actualiza dentro del bucle #loc
loop.condition.not.updated.inside.loop.problem.descriptor=La condición '#ref' no se actualiza dentro del bucle #loc
loop.variable.not.updated.inside.loop.option.nonlocal=Ignorar posibles cambios no locales
utility.class.without.private.constructor.option=Ignorar clases con solo un método principal
super.class.logger.option=Ignorar clases con un registrador accesible declarado en una superclase
static.method.only.used.in.one.class.display.name=Miembro estático que solo se usa de otra clase
static.method.only.used.in.one.class.problem.descriptor=Static {0, choice, 1#method | 2#field} <code>#ref{0, choice, 1 #() | 2 #}</code> solo se usa desde la clase ''{1}'' #loc
static.method.only.used.in.one.anonymous.class.problem.descriptor=Static {0, choice, 1#method | 2#field} <code>#ref{0, choice, 1 #() | 2 #}</code> solo se usa a partir de una clase anónima derivada de ''{1}'' #loc
static.method.only.used.in.one.class.quickfix=Mover{0} a la clase de uso
static.method.only.used.in.one.class.ignore.test.option=Ignorar cuando solo se usa desde una clase de prueba
static.method.only.used.in.one.class.ignore.anonymous.option=Ignorar cuando solo se usa desde una clase anónima
static.method.only.used.in.one.class.ignore.on.conflicts=Ignorar cuando el método no se puede mover sin conflictos
static.method.only.used.in.one.class.ignore.utility.classes=Ignorar miembros ubicados en clases de servicios públicos
unary.plus.display.name=Unario más
unary.plus.problem.descriptor=Operador <code>#ref</code> unario #loc
await.without.corresponding.signal.display.name=Await()' sin la correspondiente 'señal()
await.without.corresponding.signal.problem.descriptor=Llamar a <code>#ref</code> sin el <code> signal()</code> o <code> signalAll()</code> correspondiente #loc
signal.without.corresponding.await.display.name=Signal()' sin el correspondiente 'await()
signal.without.corresponding.await.problem.descriptor=Llamar a <code>#ref</code> sin el <code> await()</code> #loc correspondiente
wait.without.corresponding.notify.display.name=Wait()' sin el correspondiente 'notificar()
wait.without.corresponding.notify.problem.descriptor=Llamar a <code>#ref</code> sin el correspondiente <code> notify()</code> o <code> notifyAll()</code> #loc
notify.without.corresponding.wait.display.name=Notificar()' sin el correspondiente 'esperar()
notify.without.corresponding.wait.problem.descriptor=Llamar a <code>#ref</code> sin el <code> wait()</code> #loc correspondiente
integer.multiplication.implicit.cast.to.long.display.name=Multiplicación de enteros o cambio de conversión implícita a largo
integer.multiplication.implicit.cast.to.long.problem.descriptor=# ref: multiplicación de enteros convertida implícitamente en long #loc
integer.multiplication.implicit.cast.to.long.quickfix=Lanzar demasiado
integer.shift.implicit.cast.to.long.problem.descriptor=# ref: integer shift implícitamente convertido a long #loc
integer.multiplication.implicit.cast.to.long.option=<html>Ignore las expresiones en las que se haya comprobado estáticamente que el desbordamiento es imposible</html>
wait.or.await.without.timeout.display.name='wait()' o 'await()' sin tiempo de espera
wait.or.await.without.timeout.problem.descriptor=<code>#ref</code> sin tiempo de espera #loc
method.return.always.constant.display.name=El método devuelve constante por clase
method.return.always.constant.problem.descriptor=El método <code>#ref()</code> y todas sus derivables siempre devuelven constantes
class.with.too.many.dependencies.display.name=Clase con demasiadas dependencias
class.with.too.many.dependencies.problem.descriptor=La clase ''{0}'' tiene demasiadas dependencias ({1}> {2})
class.with.too.many.transitive.dependencies.display.name=Clase con demasiadas dependencias transitivas
class.with.too.many.transitive.dependencies.problem.descriptor=Class ''{0}'' tiene demasiadas dependencias transitivas ({1}> {2})
class.with.too.many.dependents.display.name=Clase con demasiados dependientes
class.with.too.many.dependents.problem.descriptor=La clase ''{0}'' tiene demasiados dependientes ({1}> {2})
class.with.too.many.transitive.dependents.display.name=Clase con demasiados dependientes transitivos
class.with.too.many.transitive.dependents.problem.descriptor=La clase ''{0}'' tiene demasiadas dependencias transitivas ({1}> {2})
class.with.too.many.dependencies.max.option=Número máximo de dependencias
class.with.too.many.dependents.max.option=Número máximo de dependientes
class.with.too.many.transitive.dependencies.max.option=Número máximo de dependencias transitivas
class.with.too.many.transitive.dependents.max.option=Número máximo de dependientes transitivos
cyclic.class.dependency.display.name=Dependencia de clase cíclica
cyclic.class.dependency.problem.descriptor=La clase ''{0}'' depende cíclicamente de {1} otras clases
cyclic.class.dependency.1.problem.descriptor=La clase ''{0}'' depende cíclicamente de la clase ''{1}''
cyclic.class.dependency.2.problem.descriptor=La clase ''{0}'' depende cíclicamente de las clases ''{1}'' y ''{2}''
cyclic.package.dependency.display.name=Dependencia cíclica del paquete
cyclic.package.dependency.problem.descriptor=El paquete ''{0}'' depende cíclicamente de {1} otros paquetes
cyclic.package.dependency.1.problem.descriptor=El paquete ''{0}'' depende cíclicamente del paquete ''{1}''
cyclic.package.dependency.2.problem.descriptor=El paquete ''{0}'' depende cíclicamente de los paquetes ''{1}'' y ''{2}''
class.unconnected.to.package.display.name=Clase independiente de su paquete
class.unconnected.to.package.problem.descriptor=Class <code>#ref</code> no tiene dependencias ni dependientes en su paquete
exception.package.display.name=Paquete de excepción
exception.package.problem.descriptor=El paquete ''{0}'' contiene solo clases de excepción
package.with.too.many.classes.display.name=Paquete con demasiadas clases
package.with.too.many.classes.problem.descriptor=El paquete ''{0}'' contiene demasiadas clases ({1}> {2})
package.with.too.many.classes.max.option=Número máximo de clases:
package.with.too.few.classes.display.name=Paquete con muy pocas clases
package.with.too.few.classes.problem.descriptor=El paquete ''{0}'' contiene muy pocas clases ({1} <{2})
package.with.too.few.classes.min.option=Número mínimo de clases:
suspicious.package.private.access.display.name=Acceso privado al paquete sospechoso
groups.of.modules.loaded.together.label=Grupos de módulos que se cargan juntos:
groups.of.modules.loaded.together.description=Cada línea especifica una lista separada por comas de los nombres de los módulos que se sabe que son cargados por el mismo cargador de clases y, por lo tanto, no se debe informar el acceso a los miembros privados del paquete entre dichos módulos.
module.with.too.many.classes.display.name=Módulo con demasiadas clases
module.with.too.many.classes.problem.descriptor=El módulo ''{0}'' contiene demasiadas clases ({1}> {2})
module.with.too.many.classes.max.option=Número máximo de clases:
module.with.too.few.classes.display.name=Módulo con muy pocas clases
module.with.too.few.classes.problem.descriptor=El módulo ''{0}'' contiene muy pocas clases ({1} <{2})
module.with.too.few.classes.min.option=Número mínimo de clases:
package.in.multiple.modules.display.name=Paquete con clases en varios módulos
disjoint.package.display.name=Paquete con gráfico de dependencia disjunto
disjoint.package.problem.descriptor=El paquete{0}se puede descomponer en {1} paquetes independientes
package.naming.convention.display.name=Convención de nomenclatura de paquetes
package.naming.convention.problem.descriptor.short=El nombre del paquete <code>{0}</code> es demasiado corto
package.naming.convention.problem.descriptor.long=El nombre del paquete <code>{0}</code> es demasiado largo
package.naming.convention.problem.descriptor.regex.mismatch=El nombre del paquete <code>{0}</code> no coincide con la expresión regular ''{1}''
design.for.extension.display.name=Diseño para extensión
design.for.extension.problem.descriptor=El método <code>#ref()</code> puede ser anulado y su funcionalidad ignorada #loc
bad.oddness.display.name=Prueba sospechosa de rareza
bad.oddness.problem.descriptor=La prueba de rareza <code>#ref</code> fallará en valores negativos #loc
comparator.not.serializable.display.name=Clase de comparador no declarada serializable
comparator.not.serializable.problem.descriptor=La clase de comparador <code>#ref</code> no se declara como serializable #loc
non.serializable.field.in.serializable.class.display.name=Campo no serializable en una clase serializable
non.serializable.field.in.serializable.class.problem.descriptor=Campo no serializable '#ref' en una clase serializable #loc
non.serializable.object.passed.to.object.stream.display.name=Objeto no serializable pasado a ObjectOutputStream
non.serializable.object.passed.to.object.stream.problem.descriptor=Objeto no serializable pasado a ObjectOutputStream #loc
non.serializable.object.bound.to.http.session.display.name=Objeto no serializable vinculado a HttpSession
non.serializable.object.bound.to.http.session.problem.descriptor=Objeto no serializable vinculado a HttpSession #loc
reflection.for.unavailable.annotation.display.name=Acceso reflectante a una anotación de solo fuente
reflection.for.unavailable.annotation.problem.descriptor=La anotación '#ref' no se retiene para el acceso reflectante #loc
access.to.static.field.locked.on.instance.display.name=Acceso al campo estático bloqueado en datos de instancia
access.to.static.field.locked.on.instance.problem.descriptor=Acceso al campo estático <code>#ref</code> bloqueado en datos de instancia #loc
access.to.static.field.locked.on.instance.fix.name=Ignorar campos estáticos de tipo ''{0}''
make.method.ctr.quickfix=Crear constructor de método
replace.all.dot.display.name=Argumento de expresión regular sospechosa
replace.all.dot.problem.descriptor=Expresión regex sospechosa#refen la llamada a ''{0}()'' #loc
replace.all.dot.quickfix=Escape del metacarácter de expresión regular
class.extends.utility.class.display.name=La clase extiende la clase de utilidad
class.extends.utility.class.problem.descriptor=Class <code>#ref</code> extiende la clase de utilidad ''{0}'' #loc
class.extends.utility.class.ignore.utility.class.option=Ignorar si la clase de reemplazo es una clase de utilidad
public.constructor.in.non.public.class.quickfix=Hacer constructor ''{0}''
assignment.to.method.parameter.ignore.transformation.option=<html>Ignorar si la asignación es una transformación del parámetro original</html>
type.parameter.extends.final.class.display.name=El parámetro de tipo extiende la clase final
type.parameter.extends.final.class.type.parameter.problem.descriptor=Tipo de parámetro <code>#ref</code> extiende ''final'' clase ''{0}'' #loc
type.parameter.extends.enum.type.parameter.problem.descriptor=Tipo de parámetro <code>#ref</code> se extiende implícitamente enum final ''{0}'' #loc
type.parameter.extends.final.class.wildcard.problem.descriptor=El argumento de tipo comodín <code>#ref</code> extiende ''final'' clase ''{0}'' #loc
type.parameter.extends.enum.wildcard.problem.descriptor=El argumento de tipo comodín <code>#ref</code> extiende implícitamente la enumeración final ''{0}'' #loc
type.parameter.extends.final.class.quickfix=Reemplazar el parámetro de tipo con la clase real
double.negation.display.name=Doble negación
double.negation.problem.descriptor=Doble negación en <code>#ref</code> #loc
double.negation.quickfix=Eliminar la doble negación
exception.from.catch.which.doesntwrap.ignore.option=Ignorar si se usa el resultado de la llamada al método de excepción
exception.from.catch.which.doesntwrap.ignore.cant.wrap.option=Ignorar si la excepción lanzada no puede envolver una excepción
comparable.implemented.but.equals.not.overridden.display.name=Comparable implementado pero 'equals()' no anulado
comparable.implemented.but.equals.not.overridden.problem.descriptor=Class <code>#ref</code> implementa 'java.lang.Comparable' pero no anula 'equals()' #loc
comparable.implemented.but.equals.not.overridden.fix.add.note.name=Se agregó la nota de JavaDoc ''Ordenado inconsistente con signos iguales''
comparable.implemented.but.equals.not.overridden.fix.generate.equals.name=Crear el método ''equals()''
unqualified.field.access.display.name=El acceso al campo de la instancia no está calificado con 'esto'
unqualified.field.access.problem.descriptor=El acceso al campo de instancia <code>#ref</code> no está calificado con 'this' #loc
unqualified.method.access.display.name=Llamada al método de instancia no calificada con 'this'
unqualified.method.access.problem.descriptor=La llamada al método de instancia <code>#ref</code> no está calificada con 'this' #loc
add.this.qualifier.quickfix=Agregar 'este' calificador
while.loop.spins.on.field.ignore.non.empty.loops.option=Advertir solo si el bucle está vacío
method.may.be.synchronized.problem.descriptor=El método <code>#ref()</code> con bloque sincronizado podría sincronizarse método #loc
method.may.be.synchronized.display.name=El método con bloque sincronizado podría ser un método sincronizado
method.may.be.synchronized.quickfix=Hacer que el método esté sincronizado y eliminar el bloque sincronizado
fallthru.in.switch.statement.quickfix=Agregar 'descanso'
law.of.demeter.display.name=La llamada al método viola la ley de Demeter
law.of.demeter.problem.descriptor=<code>#ref()</code> la llamada viola la ley de Demeter #loc
law.of.demeter.ignore.library.calls.option=Ignorar las llamadas a los métodos de la biblioteca
masked.assertion.display.name=La afirmación fue enmascarada mediante "catch"
masked.assertion.problem.description={0}'' no puede fallar porque está enmascarado por ''catch
enumeration.can.be.iteration.display.name=La enumeración puede ser iteración
enumeration.can.be.iteration.problem.descriptor=<code>#ref()</code> se puede reemplazar con ''{0}'' construct #loc
enumeration.can.be.iteration.quickfix=Reemplazar con la construcción 'Iterator'
equals.hashcode.called.on.url.display.name=Equals()' o 'hashCode()' llamado en el objeto 'java.net.URL
equals.hashcode.called.on.url.problem.descriptor=Llamar a <code>#ref()</code> en el objeto URL #loc
collection.contains.url.problem.decriptor={0} <code>#ref</code> puede contener objetos URL #loc
collection.contains.url.display.name=El mapa o el conjunto pueden contener objetos 'java.net.URL'
implicit.array.to.string.problem.descriptor=Llamada implícita a 'toString()' en la matriz <code>#ref</code> #loc
explicit.array.to.string.problem.descriptor=Llamada a '#ref()' en la matriz #loc
implicit.array.to.string.method.call.problem.descriptor=Llamada implícita a 'toString()' en la matriz devuelta por la llamada a <code>#ref</code> #loc
implicit.array.to.string.display.name=Llamar a 'toString()' en la matriz
implicit.array.to.string.quickfix=Ajustar con expresión ''{0}''
suspicious.indent.after.control.statement.problem.descriptor=<code>#ref</code> declaración tiene sangría sospechosa #loc
suspicious.indent.after.control.statement.display.name=Sangría sospechosa después de la declaración de control sin llaves
unpredictable.big.decimal.constructor.call.display.name=Llamada al constructor BigDecimal impredecible
unpredictable.big.decimal.constructor.call.problem.descriptor=Impredecible <code> new#ref()</code> llamada #loc
unpredictable.big.decimal.constructor.call.ignore.references.option=Ignorar las llamadas al constructor con argumentos de llamada de variable o método
unpredictable.big.decimal.constructor.call.ignore.complex.literals.option=Ignorar las llamadas al constructor con varios literales (por ejemplo, 0,1 + 0,2)
unnecessary.unary.minus.display.name=Menos unario innecesario
unnecessary.unary.minus.problem.descriptor=Unario innecesario menos #loc
unnecessary.unary.minus.quickfix=Eliminar el signo menos unario e invertir el signo de operación principal
unnecessary.unary.minus.remove.quickfix=Remove double unary minus
make.field.final.quickfix=Hacer ''{0}'' ''final''
increment.decrement.used.as.expression.quickfix=Extraer ''{0}'' a una declaración separada
ignore.classes.in.hierarchy.column.name=Ignorar subclases de
overly.strong.type.cast.ignore.in.matching.instanceof.option=Ignorar las conversiones con una instancia de expresión coincidente
access.to.non.thread.safe.static.field.from.instance.display.name=Acceso a campo estático no seguro para subprocesos
access.to.non.thread.safe.static.field.from.instance.field.problem.descriptor=Acceso al campo estático no seguro para subprocesos <code>#ref</code> de tipo ''{0}' '#loc
access.to.non.thread.safe.static.field.from.instance.option.title=Clases no seguras para subprocesos
access.to.non.thread.safe.static.field.from.instance.class.chooser.title=Elija una clase no segura para subprocesos
transient.field.not.initialized.display.name=El campo transitorio no se inicializa en la deserialización
transient.field.not.initialized.problem.descriptor=El campo transitorio <code>#ref</code> no se inicializó en la deserialización #loc
call.to.string.concat.can.be.replaced.by.operator.display.name=La llamada a 'String.concat()' se puede reemplazar con '+'
call.to.string.concat.can.be.replaced.by.operator.problem.descriptor=La llamada a <code>#ref()</code> se puede reemplazar con la expresión '+' #loc
call.to.string.concat.can.be.replaced.by.operator.quickfix=Reemplazar la llamada 'concat()' con '+'
new.string.buffer.with.char.argument.display.name=Llamada al constructor StringBuilder con argumento 'char'
new.string.buffer.with.char.argument.problem.descriptor=<code> new#ref()</code> con argumento de tipo 'char' #loc
new.string.buffer.with.char.argument.quickfix=Reemplazar el argumento char con el literal String
suspicious.comparator.compare.display.name=Implementación sospechosa de 'Comparator.compare()'
suspicious.comparator.compare.descriptor.parameter.not.used=El parámetro <code>#ref</code> 'compare()' no se usa #loc
suspicious.comparator.compare.descriptor.non.reflexive=El comparador no devuelve 0 para elementos iguales
to.array.call.style.display.name=Estilo de llamada 'Collection.toArray()'
to.array.call.style.problem.descriptor.zero=Llamar a <code>#ref()</code> con un argumento de matriz vacío ''{0}'' #loc
to.array.call.style.problem.descriptor.presized=Llamada a <code>#ref()</code> con argumento de matriz de tamaño predeterminado ''{0}'' #loc
to.array.call.style.quickfix.family.name=Corregir el tamaño de la matriz pasada a la llamada 'toArray'
to.array.call.style.quickfix.make.presized=Reemplazar argumento con una matriz de tamaño predeterminado
to.array.call.style.quickfix.make.zero=Reemplazar argumento con una matriz vacía
throwable.instance.never.thrown.runtime.exception.problem.descriptor=La instancia de excepción de tiempo de ejecución <code>#ref</code> no se lanza #loc
throwable.instance.never.thrown.checked.exception.problem.descriptor=La instancia de excepción marcada <code>#ref</code> no se lanza #loc
throwable.instance.never.thrown.error.problem.descriptor=La instancia de error <code>#ref</code> no se lanza #loc
throwable.instance.never.thrown.problem.descriptor=La instancia lanzada <code>#ref</code> no se lanza #loc
ignore.guard.clauses.option=Ignorar y proteger cláusulas
ignore.for.equals.methods.option=Ignorar los métodos '&equals()'
caught.exception.immediately.rethrown.display.name=La excepción capturada se vuelve a lanzar inmediatamente
caught.exception.immediately.rethrown.problem.descriptor=La excepción capturada <code>#ref</code> se vuelve a lanzar inmediatamente #loc
delete.catch.section.quickfix=Eliminar la sección 'captura'
loop.with.implicit.termination.condition.display.name=Bucle con condición de terminación implícita
loop.with.implicit.termination.condition.dowhile.problem.descriptor=<code>#ref-while</code> loop con condición de terminación implícita #loc
loop.with.implicit.termination.condition.problem.descriptor=<code>#ref</code> bucle con condición de terminación implícita #loc
loop.with.implicit.termination.condition.quickfix=Hacer explícita la condición
rename.catch.parameter.to.ignored=Cambiar el nombre del parámetro ''catch'' a ''{0}''
inspection.empty.catch.block.generate.body=Generar cuerpo 'captura' a partir de plantilla
unnecessary.super.qualifier.display.name=Calificador 'super' innecesario
unnecessary.super.qualifier.problem.descriptor=El calificador <code>#ref</code> es innecesario en este contexto #loc
unnecessary.super.qualifier.quickfix=Elimina el calificador 'super' innecesario
collections.field.access.replaceable.by.method.call.display.name=Collections.EMPTY_ * acceso al campo reemplazable con la llamada al método 'Collections.empty *()'
collections.field.access.replaceable.by.method.call.problem.descriptor=<code>#ref</code> reemplazable por '' Colecciones.{0}'' #loc
synchronization.on.local.variable.or.method.parameter.display.name=Sincronización en variable local o parámetro de método
synchronization.on.local.variable.problem.descriptor=Sincronización en la variable local <code>#ref</code> #loc
synchronization.on.method.parameter.problem.descriptor=Sincronización en el parámetro del método <code>#ref</code> #loc
too.broad.catch.quickfix=Agregar cláusula ''catch'' para ''{0}''
replace.with.catch.clause.for.runtime.exception.quickfix=Reemplazar con la cláusula 'catch' para 'RuntimeException'
too.broad.catch.option=&Solo anunciar sobre RuntimeException, Exception, Error o Throwable
unnecessary.conversion.to.string.display.name=Conversión innecesaria a cadena
unnecessary.tostring.call.display.name=Llamada innecesaria a 'toString()'
unnecessary.tostring.call.problem.descriptor=<code>#ref()</code> innecesaria llamada #loc
throwable.not.thrown.display.name=Lanzable no arrojado
throwable.result.of.method.call.ignored.problem.descriptor=Resultado de <code>#ref()</code> no arrojado #loc
char.used.in.arithmetic.context.display.name='char' expresión utilizada en contexto aritmético
char.used.in.arithmetic.context.problem.descriptor='char' <code>#ref</code> usado en contexto aritmético #loc
char.used.in.arithmetic.context.quickfix=Convertir a literal de cadena
char.used.in.arithmetic.context.cast.quickfix=Insertar conversión en {0}
unnecessary.constant.array.creation.expression.display.name=Expresión 'nueva' redundante en la creación constante de matrices
unnecessary.constant.array.creation.expression.problem.descriptor=<code>#ref</code> se puede reemplazar con la expresión del inicializador de matriz #loc
unnecessary.constant.array.creation.expression.family.quickfix=Reemplazar con la expresión del inicializador de matriz
ambiguous.method.call.display.name=La llamada al método heredado parece una llamada al método local
ambiguous.method.call.problem.descriptor=Llamada al método <code>#ref()</code> desde la superclase ''{0}'' parece una llamada al método desde la clase ''{1}'' #loc
ambiguous.method.call.quickfix=Agregar calificador 'super' a la llamada al método
change.modifier.quickfix=Hacer ''{0}''
the.whole.project=El proyecto completo
this.class=Esta clase
logger.initialized.with.foreign.class.problem.descriptor=Registrador inicializado con clase extranjera <code>#ref</code> #loc
logger.initialized.with.foreign.class.display.name=Logger inicializado con clase extranjera
logger.factory.method.name=Nombre del método de fábrica del registrador
logger.factory.class.name=Nombre de clase de la fábrica de registradores
make.static.final.quickfix=Hacer ''{0}'' estático final
logging.condition.disagrees.with.log.statement.display.name=La condición de registro no coincide con la llamada de registro
logging.condition.disagrees.with.log.statement.problem.descriptor=La condición de registro <code>#ref()</code> no coincide con la llamada de registro '' {0}() '' #loc
log.statement.guarded.by.log.condition.display.name=Llamada de registro no protegida por la condición de registro
log.statement.guarded.by.log.condition.problem.descriptor=<code>#ref()</code> registro de llamadas no protegido por la condición de registro #loc
log.statement.guarded.by.log.condition.quickfix=Rodear con condición de registro
log.statement.guarded.by.log.condition.flag.all.unguarded.option=Marcar todas las llamadas de registro no vigiladas
key.set.iteration.may.use.entry.set.display.name=La iteración sobre 'keySet()' puede optimizarse
key.set.iteration.may.use.entry.set.problem.descriptor=La iteración sobre <code>#ref</code> se puede reemplazar con ''{0}'' iteración #loc
key.set.iteration.may.use.entry.set.quickfix=Optimizar iteración del mapa
string.replaceable.by.string.buffer.in.loop.option=Solo advertir cuando se agrega en un bucle
declare.collection.as.interface.quickfix=Debilitado a ''{0}''
non.exception.name.ends.with.exception.quickfix=Hacer ''{0}'' extender '' java.lang.Exception ''
constant.value.variable.use.display.name=Uso de variable cuyo valor se sabe que es constante
constant.value.variable.use.problem.descriptor=Se sabe que el valor de <code>#ref</code> es constante #loc
unnecessary.parentheses.option=Ignorar los paréntesis aclaratorios
unnecessary.parentheses.conditional.option=Ignore los paréntesis alrededor de la condición de las expresiones condicionales
field.may.be.final.display.name=El campo puede ser 'final'
field.may.be.final.problem.descriptor=El campo <code>#ref</code> puede ser #loc 'final'
cast.that.loses.precision.option=Ignorar conversiones de int a char
ignore.overflowing.byte.casts.option=Ignorar conversiones de int 128-255 a byte
variable.not.used.inside.if.display.name=La referencia marcada para 'nulo' no se usa dentro de 'if'
variable.not.used.inside.if.problem.descriptor=<code>#ref</code> marcado para 'nulo' no se usa dentro de 'if' #loc
variable.not.used.inside.conditional.problem.descriptor=<code>#ref</code> verificado para 'nulo' no se usa dentro del #loc condicional
boolean.expression.may.be.conditional.display.name=La expresión booleana podría reemplazarse con una expresión condicional
if.may.be.conditional.problem.descriptor=<code>#ref</code> podría reemplazarse con la expresión condicional #loc
if.may.be.conditional.quickfix=Reemplazar con expresión condicional
redundant.string.format.call.display.name=Llamada redundante a 'String.format()'
redundant.call.problem.descriptor=Llamada redundante a <code>#ref()</code> #loc
redundant.string.format.call.quickfix=Eliminar la llamada redundante a 'String.format()'
redundant.string.formatted.call.quickfix=Eliminar la llamada redundante a 'String.formatted()'
junit4.test.method.in.class.extending.junit3.testcase.display.name=Método de prueba JUnit 4 en la clase que extiende JUnit 3 TestCase
junit4.test.method.in.class.extending.junit3.testcase.problem.descriptor=Método <code>#ref()</code> anotado con '@Test' dentro de la clase que extiende JUnit 3 TestCase #loc
ignore.test.method.in.class.extending.junit3.testcase.problem.descriptor=El método de prueba JUnit 3 <code>#ref()</code> anotado con '@Ignore' no será ignorado #loc
ignore.test.method.in.class.extending.junit3.testcase.quickfix=Eliminar '' @Ignore '' y cambiar el nombre del método a ''{0}''
convert.junit3.test.class.quickfix=Convertir la clase JUnit 3 ''{0}'' a JUnit 4
remove.junit4.test.annotation.quickfix=Eliminar la anotación '@Test'
remove.junit4.test.annotation.and.rename.quickfix=Eliminar la anotación '' @Test '' y cambiar el nombre a ''{0}''
equals.called.on.enum.constant.display.name='equals()' llamado en el valor Enum
equals.called.on.enum.constant.problem.descriptor=<code>#ref()</code> llamado en el valor Enum #loc
int.literal.may.be.long.literal.display.name=Int' literal convertido a 'long' podría ser literal 'long
int.literal.may.be.long.literal.problem.descriptor=<code>#ref</code> podría reemplazarse con ''{0}'' #loc
constant.assert.condition.display.name=La condición de la declaración 'assert' es constante
constant.assert.condition.problem.descriptor=Afirmar la condición <code>#ref</code> es constante #loc
assert.with.side.effects.display.name=Declaración 'assert' con efectos secundarios
assert.with.side.effects.problem.descriptor=<code>#ref</code> tiene efectos secundarios:{0}#loc
method.count.ignore.getters.setters.option=&Ignorar métodos simples getter y setter
class.new.instance.display.name=Llamada no segura a 'Class.newInstance()'
class.new.instance.problem.descriptor=La llamada a <code>#ref()</code> puede generar excepciones marcadas no declaradas #loc
dynamic.regex.replaceable.by.compiled.pattern.display.name=La expresión regular dinámica podría ser reemplazada por un patrón compilado
dynamic.regex.replaceable.by.compiled.pattern.problem.descriptor=<code>#ref()</code> podría reemplazarse con la construcción compilada 'java.util.regex.Pattern' #loc
dynamic.regex.replaceable.by.compiled.pattern.quickfix=Reemplazar con una llamada al método de la constante compilada 'Patrón'
ignore.serializable.option=Ignorar 'java.io.Serializable'
ignore.cloneable.option=Ignorar 'java.lang.Cloneable'
listener.may.use.adapter.display.name=La clase puede extender el adaptador en lugar de implementar el oyente
listener.may.use.adapter.problem.descriptor=Class ''{0}'' puede extender ''{1}'' en lugar de implementar <code>#ref</code> #loc
listener.may.use.adapter.emtpy.methods.option=&Advertir solo cuando se encuentran métodos de implementación vacíos
unnecessary.inherit.doc.display.name=Comentario de Javadoc {@inheritDoc} innecesario
unnecessary.inherit.doc.problem.descriptor=El comentario de Javadoc que contiene solo <code>#ref</code> es innecesario #loc
unnecessary.inherit.doc.field.invalid.problem.descriptor=<code>#ref</code> no es válido en los campos #loc
unnecessary.inherit.doc.constructor.invalid.problem.descriptor=<code>#ref</code> no es válido en constructores #loc
unnecessary.inherit.doc.class.invalid.problem.descriptor=<code>#ref</code> no es válido en las clases #loc
unnecessary.inherit.doc.module.invalid.problem.descriptor=<code>#ref</code> no es válido en declaraciones de módulo #loc
unnecessary.inherit.doc.constructor.no.super.problem.descriptor=No se ha encontrado un súper método para heredar Javadoc de #loc
unnecessary.inherit.doc.quickfix=Eliminar {@inheritDoc} innecesario
multiple.exceptions.declared.on.test.method.display.name=Varias excepciones declaradas en el método de prueba
multiple.exceptions.declared.on.test.method.problem.descriptor=<code>#ref</code> podría reemplazarse con 'throws Exception' #loc
unnecessary.javadoc.link.display.name=Enlace Javadoc innecesario
unnecessary.javadoc.link.super.method.problem.descriptor=<code>#ref</code> apuntar al súper método es innecesario #loc
unnecessary.javadoc.link.this.method.problem.descriptor=<code>#ref</code> apuntar a este método es innecesario #loc
unnecessary.javadoc.link.this.class.problem.descriptor=<code>#ref</code> apuntar a la clase contenedora es innecesario #loc
unnecessary.javadoc.link.quickfix=Elimina innecesarios ''{0}''
thread.local.not.static.final.display.name=El campo ThreadLocal no se declaró estático final
thread.local.not.static.final.problem.descriptor=ThreadLocal <code>#ref</code> no está declarado 'static final' #loc
remove.try.finally.block.quickfix=Eliminar el bloque 'intentar finalmente'
remove.finally.block.quickfix=Eliminar el bloque 'finalmente'
remove.leading.zero.to.make.decimal.quickfix=Elimina el cero inicial para hacer decimal
remove.leading.zeroes.to.make.decimals.quickfix=Elimina los ceros iniciales para hacer decimales
convert.octal.literal.to.decimal.literal.quickfix=Convertir literal octal en literal decimal
convert.octal.literals.to.decimal.literals.quickfix=Convertir literales octales en literales decimales
ignore.single.field.static.imports.option=Ignorar importaciones estáticas individuales y de campo
ignore.single.method.static.imports.option=Ignorar importaciones estáticas de un solo &método
ignore.methods.with.boolean.return.type.option=Ignorar métodos con el tipo de retorno 'java.lang. &Boolean'
ignore.boolean.methods.in.an.interface.option=Ignorar métodos booleanos en una interfaz @&
ignore.methods.overriding.super.method=Ignorar el mét&odo para anular/implementar un súper método
ignored.io.resource.types=Tipos de recursos de E/S ignorados
ignored.io.resource.types.label=Tipos de recursos de E/S ignorados:
choose.io.resource.type.to.ignore=Elija el tipo de recurso de E/S para ignorar
ignore.accesses.from.the.same.class=Ignorar accesos de la misma clase
ignore.accesses.from.equals.method=Ignorar accesos desde el método 'equals()'
ignore.branches.of.switch.statements=Ignorar ramas de declaraciones 'switch'
ignore.equals.hashcode.and.tostring=Ignorar los métodos 'equals()', 'hashCode()' y 'toString()'
ignore.methods.in.anonymous.classes=Ignorar métodos en clases anónimas
class.name=Nombre de la clase
method.name.regex=Nombre del método regex
column.assertion.class.name=Nombre de clase de aserción
choose.class=Elige clase
query.column.name=Los nombres de las consultas comienzan con
query.label=Los nombres de las consultas comienzan con:
update.column.name=Los nombres de actualización comienzan con
update.label=Los nombres de las actualizaciones comienzan con:
assert.keyword.is.considered.an.assertion=La palabra clave 'assert' se considera una aserción
expected.exception.never.thrown.display.name=Excepción esperada nunca lanzada en el cuerpo del método de prueba
expected.exception.never.thrown.problem.descriptor=Se esperaba <code>#ref</code> nunca incluido en el cuerpo de '' {0}() '' #loc
choose.logger.class=Elija la clase de registrador
logger.class.name=Nombre de la clase del registrador
ignore.exceptions.declared.on.library.override.option=Ignore las excepciones declaradas en los métodos que anulan un método &library
allow.resource.to.be.opened.inside.a.try.block=Permitir que el recurso se abra dentro de un bloque 'try'
any.method.may.close.resource.argument=Cualquier método puede cerrar el argumento del recurso
ignore.constructor.method.references=Ignorando las referencias al método del constructor que crean AutoCloseable
ignore.getters.returning.resource=Ignorar captadores que devuelven recursos
log.method.name=Nombre del método de registro
log.condition.text=Texto de condición de registro
ignore.if.annotated.by=Ignorar si está anotado con
ignore.classes.annotated.by=Ignorar las siguientes clases anotadas
ignored.class.hierarchies.border.title=Ignore las siguientes subclases
choose.class.hierarchy.to.ignore.title=Elija la jerarquía de clases para ignorar
unqualified.inner.class.access.display.name=Acceso de clase interna no calificado
unqualified.inner.class.access.problem.descriptor=<code>\#ref</code> no está calificado como una clase externa.\#loc
unqualified.inner.class.access.quickfix=Canonicalizar a la clase externa.
unnecessarily.qualified.inner.class.access.problem.descriptor=''{0}'' se calificó innecesariamente con <code>\#ref</code>.\#loc
unnecessarily.qualified.inner.class.access.display.name=Acceso de clase interno innecesario calificado
unnecessarily.qualified.inner.class.access.quickfix=Eliminar calificador
synchronization.on.static.field.display.name=Sincronización de campo '' estática ''
synchronization.on.static.field.problem.descriptor=Campo '' estático '' <code>\#ref</code> sincronización\#loc
overly.broad.throws.clause.display.name=Cláusula '' throw '' demasiado amplia
overly.broad.throws.clause.problem.descriptor1=<code> throws\#ref</code> es demasiado ancho para enmascarar la excepción ''{0}''.\#loc
overly.broad.throws.clause.problem.descriptor2=<code> throws\#ref</code> es demasiado ancho para enmascarar las excepciones ''{0}'' y ''{1}''.\#loc
overly.broad.throws.clause.quickfix1=Agregar excepciones específicas.
overly.broad.throws.clause.quickfix2=Reemplazar con excepciones específicas.
overly.broad.throws.clause.ignore.thrown.option=&Ignore las excepciones auto-lanzadas mientras oculta otras excepciones
unnecessarily.qualified.statically.imported.element.display.name=El elemento estático importado está innecesariamente calificado
unnecessarily.qualified.statically.imported.element.problem.descriptor=El elemento importado estáticamente ''{0}'' se calificó innecesariamente con <code>\#ref</code>.\#loc
unnecessarily.qualified.statically.imported.element.quickfix=Elimina los calificadores innecesarios.
ignore.instanceof.on.library.classes=Ignorar instancia de clases de biblioteca
for.can.be.foreach.option=Informe indexado bucle '' java.util.List ''
for.can.be.foreach.option2=No reportar iteraciones de colección sin tipo
cast.conflicts.with.instanceof.quickfix1=En cast, reemplace ''{0}'' por ''{1}''.
cast.conflicts.with.instanceof.quickfix2=Instanceof reemplazar ''{0}'' con ''{1}''.
double.checked.locking.quickfix=Hacer ''{0}'' volátil.
double.literal.may.be.float.literal.display.name='' double '' conversión literal a '' float '' puede convertirse en '' float '' literal
multiple.declaration.ignore.for.option=Ignorar la declaración de bucle '' for ''
multiple.declaration.array.only.option=Advertir solo sobre diferentes tamaños de matriz en una sola declaración
simplifiable.annotation.display.name=Anotaciones simplificables
simplifiable.annotation.problem.descriptor=La anotación <code>\#ref</code> no es necesaria.\#loc
simplifiable.annotation.whitespace.problem.descriptor=Los espacios en blanco de anotación no son necesarios.\#loc
simplifiable.annotation.quickfix=Anotaciones simples.
overloaded.methods.with.same.number.parameters.option=<html>Ignore los métodos sobrecargados cuyos tipos de parámetros son definitivamente incompatibles</html>
string.concatenation.in.format.call.display.name=Concatenación de cadenas como argumento para llamar '' format()''
string.concatenation.in.format.call.problem.descriptor=La llamada a <code>\#ref()</code> tiene un argumento de concatenación de cadenas.\#loc
string.concatenation.in.format.call.quickfix=Reemplazar la concatenación con un argumento separado.
string.concatenation.in.message.format.call.display.name=Concatenación de cadenas como argumento para llamar a '' MessageFormat.format()''
string.concatenation.in.message.format.call.problem.descriptor=String concatenation\#loc como argumento para llamar '' MessageFormat.format()''
boxing.boxed.value.display.name=Caja un valor ya en caja
boxing.boxed.value.problem.descriptor=Caja ya en caja <code>\#ref</code>.\#loc
boxing.boxed.value.quickfix=Elimina el boxeo innecesario.
unnecessary.javadoc.link.option=Ignorar los enlaces en línea a los métodos principales
constant.junit.assert.argument.display.name=Argumento de aserción constante
constant.junit.assert.argument.problem.descriptor=El argumento <code>\#ref</code> es una constante.\#loc
test.case.with.no.test.methods.option=Ignorar TestCase con la clase principal usando métodos de prueba
package.dot.html.may.be.package.info.display.name=Package.html '' se puede convertir a '' package-info.java
package.dot.html.may.be.package.info.exists.problem.descriptor=<code> package.html</code> se ignora porque existe  <code> package-info.java</code>.
package.dot.html.may.be.package.info.problem.descriptor=<code> package.html</code> se puede convertir a <code> package-info.java</code>.
package.dot.html.may.be.package.info.delete.quickfix=Elimina ''paquete.html''.
package.dot.html.may.be.package.info.convert.quickfix=Convierta a '' package-info.java ''.
ignore.anonymous.inner.classes=Ignorar clases internas anónimas
try.with.identical.catches.display.name=Misma rama ''catch'' en la declaración ''try''
try.with.identical.catches.problem.descriptor=La rama ''catch'' es idéntica a la rama ''{0}''.\#loc
if.can.be.switch.display.name=If '' puede ser reemplazado por ''switch
if.can.be.switch.problem.descriptor=Puede reemplazar la instrucción <code>\#ref</code> por una instrucción ''switch''.\#loc
if.can.be.switch.minimum.branch.option=Número mínimo de ramas condicionales '' if ''\:
if.can.be.switch.int.option=Sugerir un cambio de números
if.can.be.switch.enum.option=Sugerir cambio en enumeración
if.can.be.switch.null.safe.option=Null sugerido solo en expresiones seguras
unnecessarily.qualified.inner.class.access.option=Ignore las referencias que requieran una declaración de importación
unqualified.inner.class.access.option=Ignorar referencias a clases internas locales
try.with.identical.catches.quickfix=Contraer bloque 'catch'
confusing.else.option=Informar que falta la sintaxis después de la declaración '' if ''
html.tag.can.be.javadoc.tag.display.name=Puede reemplazar <code>...</code> con {@code...}
html.tag.can.be.javadoc.tag.problem.descriptor=<code>\#ref... \\& lt;/code \\& gt;</code> a '' {@code...} ' 'se puede reemplazar con\#loc
try.finally.can.be.try.with.resources.display.name='' probar finalmente '' se puede reemplazar con '' probar '' con recursos
try.finally.can.be.try.with.resources.problem.descriptor=<code>\#ref</code> puede utilizar la gestión automática de recursos.\#loc
try.finally.can.be.try.with.resources.quickfix=Reemplazar con '' probar '' con recursos.
array.comparison.display.name=Compare matrices usando ''\=\= '' en lugar de '' Arrays.equals()''
array.comparison.problem.descriptor=Comparar objetos de matriz usando <code>\#ref</code>, no '' Arrays.equals()''.\#loc
array.hash.code.display.name=Llamar '' hashCode()'' en una matriz
array.hash.code.problem.descriptor=<code>\#ref()</code> llamado en una matriz debe ser '' Arrays.hashCode()''.\#loc
objects.hash.problem.descriptor=La matriz pasada a 'Objects.hash()' debe estar envuelta en 'Arrays.hashcode()'
wrap.with.arrays.hash.code.quickfix=Envolver con ''{0}''
method.can.be.variable.arity.method.display.name=El método puede ser un método vararg
method.can.be.variable.arity.method.problem.descriptor=Puede convertir <code>\#ref()</code> en un método vararg.\#loc
method.can.be.variable.arity.method.ignore.byte.short.option=Ignorar parámetros con tipo byte [] o short []
method.can.be.variable.arity.method.ignore.all.primitive.arrays.option=Ignorar todos los tipos de matrices primitivas
method.can.be.variable.arity.method.ignore.multiple.arrays.option=Ignorar métodos con múltiples parámetros de matriz
method.can.be.variable.arity.method.ignore.multidimensional.arrays.option=Ignorar parámetros de matriz de varios tamaños
convert.to.variable.arity.method.quickfix=Convierta al método vararg.
mismatched.string.builder.query.update.display.name=La consulta y la actualización no coinciden en StringBuilder
mismatched.string.builder.updated.problem.descriptor={0} El contenido de <code>\#ref</code> se actualiza pero no se consulta.\#loc
mismatched.string.builder.queried.problem.descriptor={0} El contenido de <code>\#ref</code> se consulta pero no se actualiza.\#loc
math.random.cast.to.int.display.name=Emita ''Math.random()'' a ''int''
math.random.cast.to.int.problem.descriptor=<code>\#ref</code> se convierte en ''{0}'' siempre se descarta como '' 0 ''.\#loc
math.random.cast.to.int.quickfix=Agrega paréntesis para hacer la multiplicación antes de lanzar.
boolean.variable.always.inverted.display.name=Las variables booleanas siempre están invertidas
boolean.field.always.inverted.problem.descriptor=El campo booleano <code>\#ref</code> siempre está invertido.\#loc
boolean.variable.always.inverted.problem.descriptor=La variable booleana <code>\#ref</code> siempre está invertida.\#loc
unnecessary.explicit.numeric.cast.display.name=Reparto numérico explícito innecesario
unnecessary.explicit.numeric.cast.problem.descriptor=''{0}'' se ha convertido innecesariamente en <code>\#ref</code>.\#loc
unnecessary.explicit.numeric.cast.quickfix=Eliminar elenco.
null.thrown.display.name=''null'' es lanzado
null.thrown.problem.descriptor=Se lanza <code>\#ref</code>.\#loc
unnecessary.final.on.local.variable.or.parameter.display.name=Innecesario '' final '' de variable local o parámetro
unnecessary.final.on.local.variable.problem.descriptor=<code>\#ref</code> de la variable ''{0}'' no es necesario.\#loc
unnecessary.final.on.parameter.problem.descriptor=<code>\#ref</code> del parámetro ''{0}'' no es necesario.\#loc
unnecessary.final.report.local.variables.option=Informar variables locales
unnecessary.final.report.parameters.option=Parámetros del informe
unnecessary.final.on.parameter.only.interface.option=Advertir solo para métodos abstractos o de interfaz
choose.exception.class=Elija la clase de excepción
choose.exception.label=Excepciones prohibidas:
class.independent.of.module.display.name=Clase que no depende de este módulo
class.independent.of.module.problem.descriptor=El módulo de la clase <code>\#ref</code> no tiene dependencias ni dependencias.\#loc
class.only.used.in.one.module.display.name=Clase utilizada solo por otros módulos
class.only.used.in.one.module.problem.descriptor=El módulo ''{0}'' de la clase <code>\#ref</code> solo tiene dependencias y/o dependencias.\#loc
simplifiable.equals.expression.option.non.constant=Informe igual con argumentos no constantes y no nulos
simplifiable.equals.expression.display.name=Verificación '' nula '' innecesaria antes de llamar a '' equals()''
simplifiable.equals.expression.problem.descriptor='' {0}()'' Verificación '' nula '' innecesaria antes de llamar.\#loc
simplifiable.equals.expression.quickfix=''. {0}()'' invierte y elimina las comprobaciones '' nulas '' innecesarias.
use.of.concrete.class.option.ignore.abstract=Ignorar el tipo de clase abstracta
use.of.concrete.class.option.report.method.returns=Tipo de retorno del método de informe
use.of.concrete.class.option.report.local.variable=Informar tipo de variable local
use.of.concrete.class.option.report.parameter=Tipo de parámetro del método de informe
use.of.concrete.class.option.report.static.fields=Informar tipo de campo estático
use.of.concrete.class.option.report.instance.fields=Tipo de campo de instancia de informe
use.of.concrete.class.option.report.instanceof=Tipo de informe utilizado en la comparación de instancia o getClass()
use.of.concrete.class.option.report.cast=Tipo de informe utilizado en la expresión de conversión
class.only.used.in.one.package.display.name=Clase solo utilizada por otro paquete
class.only.used.in.one.package.problem.descriptor=El paquete ''{0}'' de la clase <code>\#ref</code> solo tiene dependencias y/o dependencias.\#loc
unnecessary.return.option=Ignorar en la rama de la declaración '' si '' con la rama '' más ''
usage.of.obsolete.assert.display.name=Use el método obsoleto '' junit.framework.Assert ''
use.of.obsolete.assert.problem.descriptor=Debe reemplazar las llamadas a <code>\#ref()</code> en ''{0}'' con llamadas a métodos en '' org.junit.Assert ''.\#loc
use.of.obsolete.assert.quickfix=Reemplácelo con la llamada al método '' org.junit.Assert ''.
unclear.binary.expression.display.name=Expresión ambigua
unclear.binary.expression.problem.descriptor=Puede usar paréntesis delimitadores alrededor de las expresiones.\#loc
unclear.binary.expression.quickfix=Agregue paréntesis delimitadores claros.
new.exception.without.arguments.display.name=Llamar al constructor de excepciones sin argumentos
new.exception.without.arguments.problem.descriptor=<code> new\#ref()</code>\#loc sin argumentos
absolute.alignment.in.user.interface.display.name=Usar alineación absoluta en el código AWT/Swing
absolute.alignment.in.user.interface.problem.descriptor=Constante de alineación absoluta <code> {0}.\# ref</code> utilizada.\#loc
throws.runtime.exception.display.name=Excepción sin marcar declarada en la cláusula '' throws ''
throws.runtime.exception.problem.descriptor=Se declaró una excepción sin marcar <code>\#ref</code> en la cláusula '' throws ''.\#loc
throws.runtime.exception.quickfix=Elimina ''{0}'' de la cláusula '' throws ''.
throws.runtime.exception.move.quickfix=Mueva ''{0}'' a la etiqueta Javadoc '' @throws ''.
empty.class.ignore.parameterization.option=Ignorar clase si parametrización de supertipo
ambiguous.field.access.display.name=Los accesos de campos heredados parecen accesos de elementos en el código circundante
ambiguous.field.access.hides.local.variable.problem.descriptor=El acceso al campo <code>\#ref</code> en la clase principal ''{0}'' parece un acceso a la variable local.\#loc
ambiguous.field.access.hides.parameter.problem.descriptor=El acceso al campo <code>\#ref</code> en la clase principal ''{0}'' parece el acceso al parámetro.\#loc
ambiguous.field.access.hides.field.problem.descriptor=El acceso al campo <code>\#ref</code> en la clase principal ''{0}'' parece el acceso a los campos de la clase circundante.\#loc
ambiguous.field.access.quickfix=Agregar modificador '' super '' al acceso al campo.
add.0.to.ignore.if.annotated.by.list.quickfix={0}'' a la lista '' ignorar si se anota con
non.final.field.in.enum.display.name=Campo de enumeración no '' final ''
non.final.field.in.enum.problem.descriptor=Enum ''{0}'' tiene un campo <code>\#ref</code> que no es '' final ''.\#loc
externalizable.without.public.no.arg.constructor.display.name='' public '' clase externalizable sin constructor sin argumentos
externalizable.without.public.no.arg.constructor.problem.descriptor=La clase externalizable <code>\#ref</code> no tiene un constructor "público" sin argumentos.\#loc
make.constructor.public=Establecer constructor en '' público ''
string.concatenation.missing.whitespace.display.name=Falta un espacio en blanco en la concatenación literal de cadena
string.concatenation.missing.whitespace.problem.descriptor=Falta un espacio en blanco en la concatenación literal de cadena.\#loc
string.concatenation.missing.whitespace.option=Ignorar la concatenación con cadenas de variables
negated.equality.expression.display.name=Expresión de igualdad negada
negated.equality.expression.problem.descriptor=''{0}'' está negado\#loc
negated.equality.expression.quickfix=Eliminar negación
negated.conditional.expression.display.name=Expresión condicional negativa
negated.conditional.expression.problem.descriptor=La expresión condicional no es válida.\#loc
negated.conditional.expression.quickfix=Eliminar negación
suspicious.array.cast.display.name=Casting de matriz sospechoso
suspicious.array.cast.problem.descriptor=Una transmisión sospechosa a <code>\#ref</code>.\#loc
public.constructor.display.name=Constructor '' público ''
public.default.constructor.problem.descriptor=Class <code>\#ref</code> tiene un constructor predeterminado de '' public ''.
public.constructor.problem.descriptor=Constructor público <code>\#ref()</code>\#loc
public.constructor.quickfix=Reemplace el constructor con el método factory.
junit3.style.test.method.in.junit4.class.display.name=Método de prueba JUnit de estilo antiguo en la clase JUnit 4
junit3.style.test.method.in.junit4.class.problem.descriptor=La clase JUnit 4 tiene un método de prueba JUnit de estilo antiguo <code>\#ref()</code>.\#loc
none=Ninguno
private=Privado
package.local.private=Paquete privado \\& privado
protected.package.local.private=Protegido, paquete privado \\& privado
non.final.utility.class.display.name=Clase de utilidad no '' final ''
non.final.utility.class.problem.descriptor=La clase de utilidad <code>\#ref</code> no es '' final ''.\#loc
0.will.no.longer.be.overridable.by.1={0} ya no puede ser anulado por {1}.
arrays.as.list.with.zero.or.one.argument.display.name=Llamar a '' Arrays.asList()'' con muy pocos argumentos
arrays.as.list.with.one.argument.problem.descriptor=<code>\#ref()</code> llamado con un solo argumento\#loc
arrays.as.list.with.zero.arguments.problem.descriptor=<code>\#ref()</code> fue llamado para crear una lista vacía\#loc
string.concatenation.argument.to.log.call.display.name=Concatenar cadenas no constantes como argumentos para registrar llamadas
string.concatenation.argument.to.log.call.problem.descriptor=<code>\#ref()</code> Concatenar una cadena no constante como argumento para la llamada de registro\#loc
string.concatenation.argument.to.log.call.quickfix=Reemplazar la concatenación con mensajes de registro parametrizados.
placeholder.count.matches.argument.count.display.name=El número de marcadores de posición no coincide con el número de argumentos en la llamada de registro
placeholder.count.matches.argument.count.more.problem.descriptor=Hay más argumentos ({0}) que el número especificado de marcadores de posición ({1}).\#loc
placeholder.count.matches.argument.count.fewer.problem.descriptor=Hay menos argumentos ({0}) que el número de marcadores de posición ({1}) especificado.\#loc
assignment.to.superclass.field.display.name=El constructor asigna un valor al campo definido en la clase principal
assignment.to.superclass.field.problem.descriptor=Asignar al campo ''{0}'' definido en la superclase ''{1}''.\#loc
inner.class.referenced.via.subclass.display.name=Clase interna referenciada a través de subclase
inner.class.referenced.via.subclass.problem.descriptor=Clase interna <code>\#ref</code> declarada en la clase ''{0}'' pero subclase ''{1}'' Referenciada a través de\#loc
inner.class.referenced.via.subclass.quickfix=Optimice el acceso a las clases internas.
boolean.parameter.display.name='' método booleano '' público '' con parámetro
boolean.parameter.problem.descriptor=Método '' público '' con parámetro '' booleano '' <code>\#ref()</code>\#loc
boolean.parameters.problem.descriptor=Método '' público '' con parámetro '' booleano '' <code>\#ref()</code>\#loc
boolean.parameter.constructor.problem.descriptor=Constructor '' público '' con parámetro '' booleano '' <code>\#ref()</code>\#loc
boolean.parameters.constructor.problem.descriptor=Constructor '' público '' con parámetro '' booleano '' <code>\#ref()</code>\#loc
boolean.parameter.only.report.multiple.option=Informar solo métodos con múltiples parámetros booleanos
unnecessary.unicode.escape.display.name=Secuencias de escape Unicode innecesarias
unnecessary.unicode.escape.problem.descriptor=La secuencia de escape Unicode <code>\#ref</code> se puede reemplazar con ''{0}''.\#loc
unnecessary.unicode.escape.problem.tab.descriptor=Las secuencias de escape Unicode <code>\#ref</code> se pueden reemplazar con caracteres de tabulación.\#loc
unnecessary.unicode.escape.problem.newline.descriptor=Puede reemplazar las secuencias de escape Unicode <code>\#ref</code> con caracteres de salto de línea.\#loc
missing.package.info.display.name=Falta el '' paquete-info.java ''
missing.package.info.problem.descriptor=Falta el archivo <code> package-info.java</code> en el paquete ''{0}''.
missing.package.html.problem.descriptor=Falta el archivo <code> package.html</code> del paquete ''{0}''.
package.info.java.without.package.display.name=Paquete '' sin declaración '' package-info.java
package.info.without.package.problem.descriptor=No hay declaración '' paquete '' en '' paquete-info.java ''.
package.info.without.package.quickfix=Agregue '' paquete {0}; ''.
package.info.without.package.family.quickfix=Agregar sintaxis de paquete.
auto.closeable.resource.display.name=Usar AutoCloseable sin '' intentar '' - con-recursos
auto.closeable.resource.problem.descriptor=''{0}'' se usó sin '' intentar '' - con-recursos.\#loc
auto.closeable.resource.quickfix=Ignorar '' AutoCloseable '' devuelto por este método.
auto.closeable.resource.returned.option=Ignorar instancias AutoCloseable devueltas de todas las llamadas a métodos
problematic.varargs.method.display.name=Los métodos que no son vararg anulan los métodos vararg
problematic.varargs.method.override.problem.descriptor=El método no vararg <code>\#ref()</code> anula el método vararg.\#loc
negatively.named.boolean.variable.problem.descriptor=La variable booleana <code>\#ref</code> fue nombrada negativamente.\#loc
negatively.named.boolean.variable.display.name=Variable booleana con nombre negativo
invert.quickfix.family.name=Invertir booleano
invert.method.quickfix=Método de inversión.
invert.quickfix=Invertir ''{0}''.
throwable.printed.to.system.out.display.name=Lanzable '' como '' System.out
throwable.printed.to.system.out.problem.descriptor=El argumento <code>\#ref</code> '' Throwable '' llamado '' System. {0}. {1}()'' se genera como
suppress.for.tests.scope.quickfix='' Pruebas '' Suprime el alcance.
implicit.default.charset.usage.display.name=Uso implícito del juego de caracteres predeterminado de la plataforma
implicit.default.charset.usage.problem.descriptor=Las llamadas <code>\#ref()</code> utilizan el juego de caracteres predeterminado de la plataforma.
implicit.default.charset.usage.constructor.problem.descriptor=Las llamadas <code> new\#ref()</code> utilizan el juego de caracteres predeterminado de la plataforma.
interface.may.be.annotated.functional.display.name=La interfaz se puede anotar con @FunctionalInterface
interface.may.be.annotated.functional.problem.descriptor=La interfaz <code>\#ref</code> se puede anotar con @FunctionalInterface
only.report.public.methods.option=Informar solo métodos '' públicos ''
lambda.parameter.hides.member.variable.display.name=El parámetro Lambda oculta el campo
static.initializer.references.subclass.display.name=El inicializador estático hace referencia a una subclase
lambda.parameter.hides.member.variable.problem.descriptor=El parámetro Lambda <code>\#ref</code> oculta el campo de la clase ''{0}''.\#loc
lambda.parameter.hides.member.variable.ignore.invisible.option=Ignorar campos no visibles en lambda
shared.thread.local.random.display.name=La instancia '' ThreadLocalRandom '' se puede compartir
shared.thread.local.random.problem.descriptor=La instancia '' ThreadLocalRandom '' se puede compartir entre subprocesos.
native.method.naming.convention.element.description=Nativo
use.of.obsolete.date.time.api.display.name=Usar la API de fecha y hora obsoleta
use.of.obsolete.date.time.api.problem.descriptor=Se ha utilizado el tipo de fecha y hora obsoleto <code>\#ref</code>.\#loc
warn.on.label=Advertir sobre\:
all.levels.option=Todos los niveles de registro
warn.level.and.lower.option=Por debajo del nivel de advertencia
info.level.and.lower.option=Nivel inferior al de información
debug.level.and.lower.option=Por debajo del nivel de depuración
trace.level.option=Nivel de seguimiento
ignored.autocloseable.types.column.label=Tipos de recursos autocerrables ignorados
ignored.autocloseable.types.label=Tipos de recursos de cierre automático ignorados:
choose.autocloseable.type.to.ignore.title=Elija los tipos de recursos que se pueden cerrar automáticamente para ignorar
big.decimal.method.without.rounding.called.display.name=Llamar al método '' BigDecimal '' sin el argumento del modo de redondeo
big.decimal.method.without.rounding.called.problem.descriptor='' BigDecimal.\# ref()'' se llama sin argumento de modo de redondeo.
bigdecimal.legacy.method.display.name='' BigDecimal '' Llamar a un método existente
bigdecimal.legacy.method.problem.descriptor=Las llamadas '' BigDecimal.\# ref()'' pueden usar la constante de enumeración '' RoundingMode ''.
bigdecimal.legacy.method.quickfix=Utilice la constante de enumeración '' RoundingMode ''.
serializable.stores.non.serializable.display.name=Objeto serializable almacena implícitamente objetos no serializables
serializable.lambda.stores.non.serializable.problem.descriptor=Lambda serializable almacena implícitamente un objeto no serializable de tipo ''{0}''
serializable.local.class.stores.non.serializable.problem.descriptor=Clase local serializable ''{1}'' almacena implícitamente un objeto no serializable de tipo ''{0}''.
serializable.anonymous.class.stores.non.serializable.problem.descriptor=Serializable La clase anónima almacena implícitamente un objeto no serializable de tipo ''{0}''.
assignment.to.lambda.parameter.display.name=Asignación al parámetro lambda
assignment.to.lambda.parameter.problem.descriptor=Asignado al parámetro lambda <code>\#ref</code>.\#loc
class.with.only.private.constructors.display.name=Private '' Las clases con solo constructores deben declararse como '' finales
class.with.only.private.constructors.problem.descriptor='' private '' La clase con solo constructor <code>\#ref</code> debe declararse como '' final ''.
property.value.set.to.itself.display.name=Valor de propiedad establecido para usted
equals.with.itself.display.name=Llama a '' equals()'' en ti mismo
equals.with.itself.problem.descriptor=Llame a <code>\#ref()</code> en usted mismo
junit4.method.naming.convention.element.description=JUnit 4+ pruebas
junit3.method.naming.convention.element.description=JUnit 3 pruebas
introduce.holder.class.quickfix=Clase titular
double.brace.initialization.display.name=Inicializar llaves dobles
double.brace.initialization.quickfix=Reemplazar con inicialización normal.
return.of.inner.class.display.name=Devuelve una instancia de una clase anónima, local o interna
return.of.anonymous.class.problem.descriptor=Devuelve una instancia de una clase anónima.\#loc
return.of.local.class.problem.descriptor=Devuelve una instancia de la clase local <code> {0}</code>.\#loc
return.of.inner.class.problem.descriptor=Devuelve una instancia de la clase interna no estática <code> {0}</code>.\#loc
return.of.inner.class.ignore.non.public.option=Ignorar la devolución de métodos no públicos
parameter.type.prevents.overriding.display.name=No se puede anular debido al tipo de parámetro
parameter.type.prevents.overriding.problem.descriptor=El tipo de parámetro <code>\#ref</code> está en ''{0}'' pero el tipo de parámetro del método principal es ''{1}'' no se puede anulado.\#loc
parameter.type.prevents.overriding.quickfix=Cambiar el tipo de parámetro a ''{0}''.
parameter.type.prevents.overriding.family.quickfix=Cambiar tipo de parámetro ''.
suspicious.getter.setter.display.name=Captador/setter sospechoso
suspicious.setter.problem.descriptor=Setter <code>\#ref()</code> sustituye el campo ''{0}''.\#loc
suspicious.getter.problem.descriptor=Getter <code>\#ref()</code> devuelve el campo ''{0}''\#loc
unnecessary.break.display.name=Declaración innecesaria de '' interrupción ''
unnecessary.break.problem.descriptor=La declaración <code>\#ref</code> es innecesaria.\#loc
utility.class.can.be.enum.display.name=La clase de utilidad puede ser '' enum ''
utility.class.code.can.be.enum.problem.descriptor=La clase de utilidad <code>\#ref</code> puede ser '' enum ''.\#loc
utility.class.code.can.be.enum.quickfix=Convierta a '' enum ''.
non.public.clone.display.name=El método '' clone()'' no es '' público ''
non.public.clone.problem.descriptor=El método <code>\#ref()</code> no es "público".\#loc
only.warn.on.public.clone.methods=Advertir solo sobre métodos de clonación '' públicos ''
only.warn.on.protected.clone.methods=Advertir solo sobre métodos de clonación '' protegidos ''
clone.returns.class.type.display.name='' clone()'' debe tener el mismo tipo de retorno que la clase contenedora
clone.returns.class.type.problem.descriptor='' Clone()'' debe tener el tipo de retorno ''{0}''.\#loc
clone.returns.class.type.quickfix=Cambiar el tipo de retorno a ''{0}''.
clone.returns.class.type.family.quickfix=Cambiar el tipo de retorno a tipo de clase.
use.of.clone.display.name=Clone()'' o '' Clonable
use.of.clone.call.problem.descriptor=Llamar a <code>\#ref()</code>
use.of.clone.call.method.problem.descriptor=Implementando <code>\#ref()</code>
use.of.clone.reference.problem.descriptor=Use <code>\#ref</code>
dangling.javadoc.display.name=Comentarios Javadoc colgado
dangling.javadoc.problem.descriptor=Comentarios ilegales de Javadoc\#loc
dangling.javadoc.convert.quickfix=Reemplazar con comentarios de bloque.
dangling.javadoc.delete.quickfix=Eliminar comentarios colgantes.
equals.replaceable.by.objects.call.display.name=Equals()'' puede ser reemplazado por '' Objects.equals()
equals.replaceable.by.objects.call.problem.descriptor=Puede reemplazar <code>\#ref</code> con la expresión '' Objects.equals()''.\#loc
equals.replaceable.by.objects.check.not.null.option='' a \!\= null \\&\\& a.equals (b) '' para resaltar una expresión
array.objects.equals.display.name=Llamar '' Objects.equals()'' en una matriz
array.equals.problem.descriptor=La comparación de matrices probablemente debería realizarse usando ''{0}''
array.hashcode.problem.descriptor=El cálculo del código hash de matriz probablemente debería realizarse usando ''{0}''
extends.throwable.display.name=La clase extiende directamente '' java.lang.Throwable ''
anonymous.extends.throwable.problem.descriptor=La clase anónima extiende directamente '' java.lang.Throwable ''.\#loc
extends.throwable.problem.descriptor=La clase <code>\#ref</code> extiende directamente '' java.lang.Throwable ''.\#loc
lambda.parameter.naming.convention.display.name=Convención de nomenclatura de parámetros Lambda
lambda.parameter.naming.convention.element.description=Parámetros Lambda
assert.message.not.string.display.name=El mensaje '' assert '' no es una cadena
assert.message.of.type.boolean.problem.descriptor=Mensaje '' assert '' de tipo ''{0}''\#loc
assert.message.not.string.only.warn.boolean.option=Advertir solo si el mensaje '' assert '' es '' booleano '' o '' java.lang.Boolean ''
suspicious.literal.underscore.display.name=Subrayado sospechoso en literal numérico
suspicious.literal.underscore.problem.descriptor=Los grupos en literales numéricos de subrayado no tienen una longitud de 3.\#loc
unary.plus.quickfix=Eliminar unario '' + ''.
convert.double.unary.quickfix=Reemplazar con ''{0}{1}''
prefix.operation.quickfix.family.name=Reemplazar con operación de prefijo
confusing.floating.point.literal.option=Ignorar literales de punto flotante en notación científica
class.may.be.interface.java8.option=Clases de informes con métodos no abstractos cuando se usa Java 8
simplifiable.boolean.expression.display.name=Expresión booleana simplificable
unnecessary.initcause.display.name=Llamada innecesaria a '' throwable.initCause()''
unnecessary.initcause.problem.descriptor=Llamadas innecesarias a <code> Throwable.\# ref()</code>
unnecessary.initcause.quickfix=Elimine la llamada '' Throwable.initCause()''.
consider.static.final.fields.constant.option=Los campos '' static final '' se consideran constantes
atomic.field.updater.not.static.final.display.name=El campo AtomicFieldUpdater no se declaró '' static final ''
atomic.field.updater.not.static.final.problem.descriptor=El campo {0} field <code>\#ref</code> no está declarado '' static final ''.\#loc
atomic.field.updater.issues.display.name=Problema de AtomicFieldUpdater
field.not.found.in.class.problem.descriptor=El campo con el nombre ''{0}'' no se pudo encontrar en la clase ''{1}''.
field.incorrect.type.problem.descriptor=El campo ''{0}'' no tiene el tipo ''{1}''.
field.missing.volatile.modifier.problem.descriptor=El campo ''{0}'' no tiene el modificador '' volatile ''.
field.has.static.modifier.problem.descriptor=El campo ''{0}'' tiene el modificador '' estático ''
private.field.not.accessible.problem.descriptor='' private '' Field ''{0}'' no es accesible aquí.
package.local.field.not.accessible=Paquete-campo privado ''{0}'' no es accesible aquí.
protected.field.not.accessible.problem.descriptor='' protected '' Field ''{0}'' no es accesible aquí.
interface.clashes.with.object.class.display.name=El método de la interfaz entra en conflicto con el método en '' java.lang.Object ''
interface.clashes.with.object.class.problem.descriptor=<code>\#ref()</code> entra en conflicto con un método en '' java.lang.Object ''.
optional.used.as.field.or.parameter.type.display.name='' Opcional '' no se usa como un campo o tipo de parámetro
optional.used.as.field.type.problem.descriptor=<code>\#ref</code> utilizado como tipo para el campo ''{0}''.
optional.used.as.parameter.type.problem.descriptor=<code>\#ref</code> se usa como tipo para el parámetro ''{0}''.
lambda.unfriendly.method.overload.display.name=Sobrecarga de método no compatible con lambda
lambda.unfriendly.method.overload.problem.descriptor=La sobrecarga del método <code>\#ref()</code> no es compatible con lambda.
lambda.unfriendly.constructor.overload.problem.descriptor=La sobrecarga en el constructor <code>\#ref()</code> no es compatible con lambda.
optional.contains.collection.display.name='' Opcional '' tiene una matriz o colección
optional.contains.collection.problem.descriptor='' Opcional '' tiene la colección <code>\#ref</code>.
optional.contains.array.problem.descriptor='' Opcional '' contiene la matriz <code>\#ref</code>.
synchronization.on.get.class.display.name='' getClass()'' Sincronización
synchronization.on.get.class.problem.descriptor=<code>\#ref()</code> Sincronización\#loc
object.instantiation.inside.equals.or.hashcode.display.name=Equals()'' o instanciación de objeto dentro de '' hashCode()
object.instantiation.inside.equals.or.hashcode.problem.descriptor='' {0}()'' instanciación de objeto\#loc
object.instantiation.inside.equals.or.hashcode.problem.descriptor2=Creación de instancias de objeto dentro de '' {0}()'' ({1})\#loc
lambda.body.can.be.code.block.name=El cuerpo de Lambda puede ser un bloque de código
lambda.body.can.be.code.block.quickfix=Expanda el cuerpo lambda a {...}.
lambda.parameter.type.can.be.specified.name=Puede especificar un tipo de parámetro lambda
lambda.parameter.type.can.be.specified.descriptor=Los tipos de parámetros Lambda se pueden expandir a {0}
lambda.parameter.type.can.be.specified.quickfix=Expandir el tipo de parámetro a {0}.
lambda.parameter.type.can.be.specified.family.quickfix=Especifica el tipo de parámetro lambda.
diamond.can.be.replaced.with.explicit.type.arguments.name=Puede reemplazar diamantes con argumentos de tipo explícito
diamond.can.be.replaced.with.explicit.type.arguments.quickfix=Reemplace '' <> '' con argumentos de tipo explícito.
lambda.can.be.replaced.with.anonymous.name=Puede reemplazar lambda con una clase anónima
lambda.can.be.replaced.with.anonymous.quickfix=Reemplazar lambda con una clase anónima.
method.ref.can.be.replaced.with.lambda.name=Puede reemplazar la referencia del método con lambda
method.ref.can.be.replaced.with.lambda.quickfix=Reemplazar la referencia del método con lambda.
try.statement.with.multiple.resources.name=Puede dividir la declaración ''try'' con múltiples recursos
try.statement.with.multiple.resources.quickfix=Dividir una declaración ''try'' con varios recursos.
multi.catch.can.be.split.name=Puede dividir múltiples capturas en bloques de capturas individuales
multi.catch.can.be.split.quickfix=Dividir múltiples capturas en bloques de '' captura '' individuales.
assertion.can.be.if.name=Puede reemplazar la aserción con la declaración if
assert.can.be.if.quickfix=Reemplace '' assert '' con una declaración '' if ''.
if.can.be.assertion.name=Puede reemplazar la sintaxis con '' assert '' o '' Objects.requireNonNull ''
if.can.be.assertion.replace.with.assertion.quickfix=Reemplace la sintaxis con la declaración '' assert ''.
if.can.be.assertion.replace.with.objects.requirenonnull.quickfix=Reemplace la sintaxis por '' Objects.requireNonNull()''.
single.statement.in.block.name=Un bloque de código tiene una sola declaración
single.statement.in.block.descriptor=''{0}'' tiene una sola sintaxis.
single.statement.in.block.quickfix=Elimine las llaves en la declaración ''{0}''.
single.statement.in.block.family.quickfix=Eliminar llaves en la sintaxis.
single.element.annotation.name=Anotación de un solo elemento
single.element.annotation.quickfix=Agregue '' value\= ''.
single.element.annotation.family.quickfix=Expandir anotaciones a forma genérica.
array.creation.without.new.keyword.name='' new '' Crea una matriz sin expresión
array.creation.without.new.keyword.quickfix=Agregue '' new {0} ''.
array.creation.without.new.keyword.family.quickfix=Agregue la expresión '' new ''.
overly.long.lambda.display.name=Expresión lambda demasiado larga
overly.long.lambda.problem.descriptor=Expresión Lambda demasiado larga (número de declaraciones fuente sin comentarios\= {0}).\#loc
wait.notify.not.in.synchronized.context.display.name=''esperar()'' o ''notificar()'' mientras no está sincronizado
wait.notify.while.not.synchronized.on.problem.descriptor=Llamado mientras <code>\#ref</code> no está sincronizado en ''{0}''.\#loc
call.to.suspicious.string.method.display.name=Llamar al método de cadena sospechoso
call.to.suspicious.string.method.problem.descriptor=<code> String.\# ref()</code> se llama en un contexto internacionalizado.\#loc
unnecessary.string.escape.display.name=Caracteres innecesariamente escapados
unnecessary.string.escape.problem.descriptor=<code>\#ref</code> se escapa innecesariamente.
unnecessary.string.escape.quickfix=Reemplace los caracteres de escape innecesarios por otros sin escape.
array.can.be.replaced.with.enum.values=Puede reemplazar matrices con valores de enumeración.
array.can.be.replaced.with.enum.values.quickfix=Reemplazar matriz con {0} .values ().
array.can.be.replaced.with.enum.values.family.quickfix=Reemplace la matriz con EnumType.value ().
string.concatenation.replace.fix=Reemplazar con StringBuilder.
string.concatenation.replace.fix.name=Convertir variable ''{0}'' de cadena a {1}
string.concatenation.replace.fix.name.null.safe=Convertir variable ''{0}'' de cadena a {1} (nulo seguro)
string.concatenation.introduce.fix=Inserte StringBuilder.
string.concatenation.introduce.fix.name=Actualizar la variable ''{0}'' insertando un nuevo {1}
string.concatenation.introduce.fix.name.null.safe=Actualizar la variable ''{0}'' insertando un nuevo {1} (nulo seguro)
ignored.class.names=Ignorar clases (incluidas subclases)
ignored.class.label=Clases ignoradas (incluidas las subclases):
meta.annotation.without.runtime.retention=Anotaciones que no son de tiempo de ejecución para usar en la reflexión
string.equals.char.sequence.display.name='' CharSequence '' Call '' String.equals()'' con argumento
string.equals.char.sequence.problem.descriptor=<code> String.\# ref()</code> se llama con el argumento ''{0}''.\#loc
object.equals.can.be.equality.display.name=Equals()'' la llamada se puede reemplazar con ''\=\=
object.equals.can.be.equality.problem.descriptor=Puede reemplazar <code>\#ref()</code> por ''\=\= ''.
not.object.equals.can.be.equality.problem.descriptor=Puede reemplazar <code> \!\# Ref()</code> por '' \!\= ''.
redundant.explicit.var.type.display.name=El tipo de variable local se puede omitir
variable.type.can.be.explicit.display.name=El tipo de variable puede ser explícito
assignment.or.return.of.field.with.mutable.type.display.name=Asignar o devolver un campo con un tipo mutable
assignment.of.field.with.mutable.type.problem.descriptor=Asignado al {0} campo ''{1}'' en el parámetro <code>\#ref</code>.\#loc
return.of.field.with.mutable.type.problem.descriptor={0} campo de retorno <code> {1}</code>\#loc
ignore.private.methods.option=Ignorar la asignación y devolución de métodos privados
inspection.redundant.string.operation.display.name=Operación String redundante
inspection.redundant.string.remove.fix.name=Eliminar llamada duplicada '' {0}()''
inspection.redundant.string.fix.family.name=Eliminar llamadas duplicadas
inspection.redundant.string.call.message=Duplicar <code>\#ref()</code> llamada\#loc
inspection.redundant.empty.string.argument.message=Argumento de cadena vacía innecesario.
inspection.redundant.string.length.argument.message=Argumento de longitud de cadena innecesario
inspection.redundant.zero.argument.message=Argumento cero innecesario
inspection.redundant.string.remove.argument.fix.name=Eliminar argumento
inspection.redundant.string.intern.on.constant.message=Llamar a <code>\#ref()</code> de constantes de tiempo de compilación es innecesario\#loc
inspection.redundant.string.constructor.message=Duplicar <code>\#ref</code>.\#loc
inspection.redundant.string.replace.with.arg.fix.name=Reemplazar con argumentos
inspection.redundant.string.replace.with.empty.fix.name=Reemplazar con una cadena vacía
inspection.redundant.string.option.do.not.report.string.constructors=No reportar constructores de cadenas
inspection.x.call.can.be.replaced.with.y=La llamada ''{0}'' se puede reemplazar con ''{1}''
inspection.type.may.be.weakened.display.name=El tipo puede estar debilitado
inspection.type.may.be.weakened.problem.descriptor=El tipo de variable <code>\#ref</code> puede debilitarse a {0}.\#loc
inspection.type.may.be.weakened.method.problem.descriptor=El tipo de retorno del método <code>\#ref()</code> puede debilitarse a {0}.\#loc
inspection.type.may.be.weakened.parameter.problem.descriptor=El tipo de parámetro <code>\#ref</code> puede debilitarse a {0}.\#loc
inspection.type.may.be.weakened.field.problem.descriptor=El tipo de campo <code>\#ref</code> puede debilitarse a {0}.\#loc
inspection.type.may.be.weakened.quickfix=Tipo debilitado a ''{0}''.
inspection.type.may.be.weakened.ignore.option=&Utilice el tipo correcto como el tipo más débil en la asignación
inspection.type.may.be.weakened.collection.method.option=&Use el tipo de colección parametrizado para el argumento de llamada al método
inspection.type.may.be.weakened.do.not.weaken.to.object.option=&no debilitado a '' java.lang.object ''
inspection.type.may.be.weakened.add.stopper=Agregar como clase de parada para debilitar
inspection.type.may.be.weakened.add.stopper.single=Agregar {0} como clase de parada para debilitar
inspection.type.may.be.weakened.only.weaken.to.an.interface=Debilitado solo con interfaz
inspection.type.may.be.weakened.do.not.weaken.return.type=No debe debilitar el tipo de retorno.
inspection.type.may.be.weakened.add.stop.class.family=Detener agregar clase
inspection.type.may.be.weakened.weaken.type.family=Tipo debilitado
inspection.type.may.be.weakened.add.stop.class.selection.table=Clase de parada
inspection.type.may.be.weakened.add.stop.class.selection.table.label=Detener clases:
inspection.type.may.be.weakened.add.stop.class.selection.popup=Detener la selección de clase
inspection.type.may.be.weakened.do.not.weaken.inferred.variable.type=No sugiera que las variables debilitadas se declaren como '' var ''
inspection.commented.out.code.display.name=Código comentado
inspection.commented.out.code.problem.descriptor=Código comentado ({0} {0, choice, 1\#line | 1 <line})
commented.out.code.delete.quickfix=Eliminar comentario
commented.out.code.uncomment.quickfix=Código de descomentar
inspection.commented.out.code.min.lines.options=Líneas mínimas de código
inspection.catch.ignores.exception.display.name=El bloque de captura puede ignorar las excepciones
inspection.catch.ignores.exception.option.comments=No advertir si el bloque ''catch'' contiene comentarios
inspection.catch.ignores.exception.option.nonempty=No advertir si el bloque ''catch'' tiene un comentario vacío
inspection.catch.ignores.exception.option.ignored.used=No advertir si la excepción '' ignore (d) '' no se ignora realmente
inspection.catch.ignores.exception.used.message=Se utilizó el parámetro ''catch'' con el nombre <code>\#ref</code>.\#loc
inspection.catch.ignores.exception.empty.message=Bloque <code>\#ref</code> vacío\#loc
inspection.catch.ignores.exception.unused.message=Parámetro '' captura '' obsoleto <code>\#ref</code>\#loc
inspection.catch.ignores.exception.vm.ignored.message=Algunas excepciones importantes pueden ignorarse en el bloque <code>\#ref</code>.\#loc
inspection.redundant.collection.operation.display.name=Operaciones de cobranza duplicadas
inspection.redundant.collection.operation.fix.family.name=Simplificar la operación de recolección
inspection.redundant.collection.operation.problem.arraycopy=Se creó una colección innecesaria para copiar la matriz.
inspection.redundant.collection.removal.by.index.problem=Eliminar por índice se puede reemplazar con Eliminar por objeto.
inspection.redundant.collection.removal.by.index.fix=Habilitar la eliminación por objeto.
inspection.redundant.collection.unnecessary.contains.problem=Inspección '' {0}()'' innecesaria
inspection.redundant.collection.unnecessary.contains.fix='' {0}()'' Eliminar inspección
comments.as.content.option=Contar comentarios como contenido
copy.constructor.misses.field.display.name=Falta un campo en el constructor de copias
copy.constructor.misses.field.problem.descriptor.1=El constructor de copia no copia el campo ''{0}''.
copy.constructor.misses.field.problem.descriptor.2=El constructor de copia no copia los campos ''{0}'', ''{1}''.
copy.constructor.misses.field.problem.descriptor.3=El constructor de copia no copia los campos ''{0}'', ''{1}'', ''{2}''.
copy.constructor.misses.field.problem.descriptor.many=El constructor de copia no copia los campos {0}.
fix.add.argument.family.name=Agregar argumento
fix.add.argument.name=''{0}'' Agregar argumento
inspection.constant.expression.display.name=La expresión constante se puede evaluar
inspection.constant.expression.message=La expresión constante se puede evaluar como ''{0}''.
inspection.constant.expression.fix.name=Calculando el valor constante de la ''{0}''
inspection.constant.expression.fix.name.with.value={0}'' reemplazar valor constante ''{1}
inspection.constant.expression.fix.family.name=Calcular valor constante
inspection.redundant.compare.call.display.name=Duplicar llamada al método '' compare()''
inspection.redundant.compare.call.fix.name='' compare()'' llamada en línea
inspection.simplifiable.if.statement.display.name=Si las sentencias se pueden reemplazar con expresiones?\:, \\& \\&, ||,\=\= o \!\=
inspection.simplifiable.if.statement.message=Si la declaración se puede reemplazar con ''{0}''.
inspection.simplifiable.if.statement.option.dont.warn.on.ternary=''?\: '' operador obsoleto
inspection.simplifiable.if.statement.fix.name=Reemplazar '' si más '' por ''{0}''
inspection.simplifiable.if.statement.fix.family.name=Reemplace '' si más '' con expresión condicional
inspection.list.remove.in.loop.display.name=Llamar '' List.remove()'' en bucle
inspection.list.remove.in.loop.message=Lista.subLista (). claro()
implicit.default.charset.usage.fix.family.name=Especificación del juego de caracteres UTF-8
inspection.redundant.class.call.display.name=Duplicar llamadas '' isInstance()'' o '' cast()''
inspection.new.object.equality.display.name=Comparar el nuevo objeto usando ''\=\= ''
inspection.new.object.equality.message=Objeto nuevo comparado mediante ''{0}''
inspection.excessive.range.check.message=Se puede reemplazar con ''{0}''.
inspection.excessive.range.check.fix.family.name=Simplifique la verificación de rango excesivo
suspicious.integer.div.assignment.problem.descriptor=El resultado de la división se redondea a un número entero.
suspicious.integer.div.assignment.display.name=Asignación sospechosa de división de enteros
suspicious.integer.div.assignment.quickfix=Tipo de conversión a double.
inspection.if.statement.missing.break.in.loop.name=Puede salir del ciclo después de que se cumpla la condición.
inspection.if.statement.missing.break.in.loop.description=El bucle se puede terminar después de que se cumpla la condición
inspection.if.statement.missing.break.in.loop.quickfix=Agregue '' break ''.
inspection.case.mismatch.display.name=Discrepancia de casos en la operación de cadena
inspection.case.mismatch.message.arg.is.lower=El método '' {0}()'' siempre devuelve {1}. Los argumentos tienen símbolos en minúsculas, pero solo calificadores en mayúsculas
inspection.case.mismatch.message.arg.is.upper=El método '' {0}()'' siempre devuelve {1}. Los argumentos tienen símbolos en mayúsculas, pero los calificadores son solo en minúsculas
inspection.suspicious.date.format.display.name=Patrón de formato de fecha sospechoso
inspection.suspicious.date.format.message.upper=Se usa el patrón ''{0}''({1}) en mayúsculas. ''{2}'' ({3}) puede ser intencional.
inspection.suspicious.date.format.message.lower=Se utiliza el patrón en minúsculas ''{0}''({1}). ''{2}'' ({3}) puede ser intencional.
fix.replace.map.with.flat.map.description=Puede reemplazar ''map()'' por ''flatMap()''.
fix.eliminate.folded.if.present.name=Eliminar llamada '' ifPresent()'' colapsada
fix.eliminate.folded.if.present.description=Puede eliminar la llamada '' ifPresent()'' doblada
inspection.pattern.variable.can.be.used.display.name=Variable de patrón disponible
inspection.pattern.variable.can.be.used.message=La variable ''{0}'' se puede reemplazar con una variable de patrón.
inspection.pattern.variable.can.be.used.fix.family.name=Reemplazar con variable de patrón
inspection.pattern.variable.can.be.used.fix.name=Reemplazar ''{0}'' con la variable de patrón
inspection.pattern.variable.can.be.used.existing.message=Se puede utilizar la variable de patrón existente ''{0}'' en lugar de ''{1}''
inspection.pattern.variable.can.be.used.existing.fix.family.name=Reemplazar con variable de patrón existente
inspection.pattern.variable.can.be.used.existing.fix.name=Reemplace ''{0}'' con la variable de patrón existente ''{1}''
array.hash.code.fix.family.name=Reemplazar con '' hashCode '' implícito
objects.hash.fix.family.name=Envolver con 'Arrays.hashCode()'
unqualified.static.access.fix.family.name=Acceso estático calificado
replace.field.reference.fix.family.name=Reemplazar la referencia del campo
replace.field.reference.fix.text=Reemplazar la referencia del campo con {0}
replace.method.call.fix.family.name=Reemplazar llamada al método
replace.method.call.fix.text=Reemplazar la llamada al método con {0}
delete.unnecessary.statement.fix.family.name=Eliminar declaraciones duplicadas
increment.decrement.used.as.expression.fix.family.name=Extraer con sintaxis separada
use.of.properties.as.hashtable.fix.family.name=Modificar el acceso a la propiedad
unnecessary.java.doc.link.fix.family.name=Eliminar etiquetas duplicadas
swap.equals.fix.family.name=Invertir llamadas al método
remove.modifier.fix.family.name=Eliminar modificador
shift.out.of.range.fix.family.name=Modificar valor de turno
unnecessary.unicode.escape.fix.family.name=Reemplazar con caracteres.
unnecessary.unicode.escape.fix.text=Reemplazar con caracteres de salto de línea
absolute.alignment.in.user.interface.fix.family.name=Reemplazar con constante
static.inheritance.fix.family.name=Reemplazar herencia con una referencia completamente calificada
suspicious.to.array.call.fix.family.name=Reemplazar con la matriz apropiada
incorrect.date.format.fix.family.name=Corregir formato de fecha incorrecto
referencing.subclass.0.from.superclass.1.initializer.might.lead.to.class.loading.deadlock=La referencia a la subclase {0} en el inicializador de superclase {1} hace que se produzca un interbloqueo de carga de clases.
collections.field.access.replaceable.by.method.call.fix.family.name=Reemplazar Collections.EMPTY_ * con una llamada
delete.catch.section.fix.family.name=Eliminar declaración de captura
make.field.static.final.fix.family.name=Final estática
string.concatenation.in.format.call.fix.family.name=Reemplazar la concatenación con argumentos.
implicit.array.to.string.fix.family.name=Escribir implícitamente Array.toString ()
listener.may.use.adapter.fix.family.name=Reemplazar con adaptador
unnecessary.temporary.object.fix.family.name=Cambiar conexión
utility.class.with.public.constructor.fix.family.name=Hacer que el constructor sea privado
change.modifier.fix.family.name=Cambiar modificador
make.field.final.fix.family.name=Hágalo final.
generate.to.string.quick.fix.family.name=Encadenar ()
replace.instanceof.fix.family.name=InstanceOf tipo de reemplazo
replace.cast.fix.family.name=Reemplazar tipo de conversión
make.package.private.fix.family.name=Paquete cree-privado
make.method.final.fix.family.name=Establecer método en '' final ''
replace.casted.literal.with.just.literal.fix.family.name={0} reemplazar con literal
char.used.in.arithmetic.content.cast.fix.family.name=Insertar elenco
ignore.parentheses.around.single.no.formal.type.lambda.parameter=Ignore los paréntesis que rodean los parámetros lambda de tipo único sin escribir
double.checked.locking.fix.family.name=Establecer campo como volátil
declare.collection.as.interface.fix.family.name=Tipo débil
string.equals.empty.string.fix.family.name=Simplificar la verificación de cadenas vacías
class.without.logger.annotations.tab=Anotaciones
class.without.logger.loggers.tab=Registradores
options.title.ignored.classes=Clases ignoradas
options.label.ignored.classes=Clases ignoradas:
add.catch.section.fix.family.name=Agregar cláusula ''catch''
inspection.autocloseable.resource.ignored.methods.title=Ignorar instancias AutoCloseable devueltas por este método
logger.initialized.with.foreign.class.fix.family.name=Reemplazar clase extranjera
extend.exception.fix.family.name=Escribir extensión de clase como '' excepción ''
inspection.use.of.private.field.inner.classes.option=Ignorar el acceso de las clases internas
refused.bequest.fix.family.name=Insertar llamada al método principal
mark.modules.as.loaded.together.fix.family.name=Marcar módulos para cargar juntos
mark.modules.as.loaded.together.fix.text=''{0}'' y ''{1}'' marcan los módulos para que se carguen juntos
inspection.suspicious.package.private.access.description={0} es {1} pero se declara en otro módulo ''{2}''.
ignore.class.fix.family.name=Ignorar este tipo
create.default.branch.fix.family.name='' predeterminado '' insertar rama
unnecessary.fully.qualified.name.fix.family.name=Renombrar completamente calificado
return.of.collection.field.fix.family.name=Crear colección de devolución como '' no modificable ''
remove.redundant.substring.fix.family.name=Eliminar llamadas duplicadas '' substring()''
remove.redundant.string.fix.text={0}()'' y elimina llamadas innecesarias '' {1}()
use.equalsignorecase.for.case.insensitive.comparison=Use equalsIgnoreCase() para una comparación que no distinga entre mayúsculas y minúsculas
make.class.final.fix.family.name=Hacer que la clase sea final
side.effects.method.ref.to.lambda.fix.family.name={0} (efectos secundarios)
encapsulate.variable.fix.family.name=Encapsular campos
method.may.be.static.replaces.qualifiers.with.class.references.option=El arreglo rápido reemplaza los calificadores de instancia con referencias de clase.
method.may.be.static.ignore.default.methods.option=Ignorar método '' predeterminado ''
convert.empty.anonymous.to.new.fix.family.name=Eliminar '{}'
replace.method.ref.with.qualifier.fix.family.name=Reemplazar con calificador
replace.method.ref.with.qualifier.problem.method=Puede reemplazar la referencia del método con un calificador
replace.method.ref.with.qualifier.problem.lambda=Puede reemplazar lambda con un calificador de método
add.throws.clause.fix.family.name=Modificar cláusula ''lanzamientos''
prefer.empty.array.options.title=Prefiero una matriz vacía\:
prefer.empty.array.options.mode.always=Siempre
prefer.empty.array.options.mode.by.level=Según el nivel de idioma
prefer.empty.array.options.mode.always.never=Never (prefiere una matriz de un tamaño predefinido)
too.broad.scope.inspection.fix.family.name=Alcance estrecho
replace.with.cast.fix.family.name=Reemplazar con cast
replace.anonymous.with.lambda.body.fix.family.name=Reemplazar la llamada con el cuerpo del método
replace.with.method.reference.fix.family.name=Reemplazar la llamada al método en la referencia del método con la llamada al método adecuada
replace.with.lambda.body.fix.family.name=Reemplazar la llamada al método lambda con el cuerpo lambda
inspection.trivial.functional.expression.usage.description=Puede simplificar las llamadas a métodos
replace.with.var.fix.family.name=Reemplazar el tipo explícito con '' var ''
inspection.redundant.explicit.variable.type.description=Se puede omitir el tipo explícito de variable local
add.read.write.object.methods.fix.family.name=Agregar métodos '' readObject()'' y '' writeObject()'' que siempre arrojan una excepción
add.read.write.object.methods.fix.text=Agregar método '' writeObject()'' que siempre arroja una excepción
add.read.write.object.methods.fix.text2=Agregar método '' readObject()'' que siempre arroja una excepción
replace.with.method.ref.fix.family.name=Reemplazar lambda con la referencia del método
replace.with.method.ref.fix.name.may.change.semantics=Reemplaza lambda con la referencia del método (la semántica puede cambiar)
qualify.call.fix.family.name=Calificación de referencia
replace.with.comparator.fix.family.name=Simplifique los comparadores usando el método static Comparator
inspection.comparator.combinators.description=Puede ser reemplazado por una cadena Comparator
inspection.comparator.combinators.description2=Puede ser reemplazado por {0}
inspection.unnecessary.string.escape.report.char.literals.option=Informe de cadena de caracteres
inspection.method.call.in.loop.ignore.known.methods.option=Ignore métodos conocidos con efectos secundarios
fix.data.provider.signature.family.name=Modificar la firma del proveedor de datos
allow.suppressions.fix.family.name=Permitir supresiones
allow.suppressions.fix.text=Permitir esta supresión
remove.suppress.comment.fix.family.name=// Eliminar {0}
convert.to.j.unit.4.fix.family.name=Convertir la clase JUnit 3 a JUnit 4
throws.runtime.exception.fix.family.name=Eliminado de la cláusula '' throws ''
move.exception.to.javadoc.fix.family.name=Javadoc Mover a la etiqueta '' @throws ''
create.package.info.java.family.name=Paquete-info.java
remove.loop.fix.family.name=Eliminar bucle
remove.call.fix.family.name=Eliminar llamada
inspection.meta.annotation.without.runtime.description={0} debe contener @Retention (RetentionPolicy.RUNTIME).
inspection.refused.bequest.super.annotated.option=Informar solo si el método principal está anotado con\:
inspection.empty.class.ignore.subclasses.option=Ignorar {0} subclases
inspection.test.method.without.assertions.exceptions.option=Ignore los métodos de prueba que declaran excepciones
inspection.collection.must.have.initial.capacity.initializers.option=No reportar inicializadores de campo
utility.class.without.private.constructor.cant.generate.constructor.title=No se puede crear el constructor
utility.class.without.private.constructor.cant.generate.constructor.message=La clase de utilidad incluye instanciación y no se crea ningún constructor privado.
inspection.suspicious.package.private.access.problem={0} anula el método de paquete privado en {1} declarado en otro módulo ''{2}''.
inspection.condition.covered.by.further.condition.descr=Condición '' {0} realizada por {1, choice, 1\#condition '' ''{2}'' '' | 2\#condition} 'subsiguiente '
inspection.parameterized.parameters.static.collection.display.name=@RunWith (Parameterized.class) sin proveedor de datos
create.missing.switch.branch=Crear rama de interruptor faltante ''{0}''
create.missing.switch.branches=Crear ramas faltantes\: {0}
redundant.as.list.for.iteration.problem=Llamada innecesaria a '' Arrays.asList()''
redundant.as.list.for.iteration.fix.name=Desactivar las nuevas líneas
assert.with.side.effects.call.mutates.expression=La llamada {0}()'' muta ''{1}
assert.with.side.effects.call.mutates.field={0}()'' campo de mutaciones de llamada ''{1}
inspection.comparator.combinators.fix.chain=Cadena comparadora
logger.initialized.with.foreign.options.title=Seleccione la clase de fábrica del registrador
test.without.assertion.options.choose.class=Elija la clase de aserción
constant.on.lhs.of.comparison.options.item.left=Izquierda
constant.on.lhs.of.comparison.options.item.right=Derecha
convert.junit3.test.fix.conflict.semantics=La llamada al método {0} puede cambiar la semántica cuando {1} se convierte a JUnit 4
convert.junit3.test.fix.conflict.compile=La llamada al método {0} no se compila cuando {1} se convierte a JUnit 4
convert.junit3.test.fix.conflict.compile.2=La referencia {0} no se compila cuando {1} se convierte a JUnit 4
inspection.byte.array.output.stream.to.string.message=Conversión ineficiente de ByteArrayOutputStream
fix.data.provider.signature.fix.name=Cambiar la firma del método a ''{0}''
fix.data.provider.create.method.fix.name=Crear método de proveedor de datos '@Parameters público estático Iterable<Objeto> parámetros()'
fix.data.provider.signature.missing.method.problem=La clase de prueba parametrizada <code>#ref</code> carece del método de proveedor de datos anotado con '@Parameters'
fix.data.provider.signature.incorrect.problem=El método del proveedor de datos <code>#ref()</code> tiene una firma incorrecta
fix.data.provider.multiple.methods.problem=Múltiples métodos de proveedor de datos @Parameters presentes en la clase <code>#ref</code>
cloneable.class.without.clone.todo.message=TODO: copie el estado mutable aquí, para que el clon no pueda cambiar las partes internas del original
cloneable.class.without.clone.ignore.when.clone.called.option=Ignorar cuando Cloneable es necesario para llamar al método clone() de la superclase
trivial.if.option.ignore.assert.statements=Ignorar declaraciones de 'afirmación'
if.may.be.factorized.problem.descriptor=Puedes factorizar <code>#ref</code> #loc
if.may.be.factorized.quickfix=Convertir a expresión factorizada
weaken.visibility.quickfix=Visibilidad reducida
non.final.field.in.enum.quickfix.option=Ignorar campos cuando las soluciones rápidas no estén disponibles
checkbox.ignore.null.on.wrong.side=<html>Ignorar <code>null</code> en el lado equivocado</html>
cyclic.class.dependency.ignore.in.same.file=Ignorar ciclos entre clases en el mismo archivo
ambiguous.field.access.navigate.quickfix=Mover al acceso obvio {0,choice, 1#variable local|2#parámetro|3#campo}
logger.initialized.with.foreign.class.ignore.super.class.option=Ignorar los registradores inicializados por la clase principal
logger.initialized.with.foreign.class.ignore.non.public.classes.option=Ignorar registradores para clases no públicas
dangling.javadoc.ignore.copyright.option=Ignorar los comentarios del encabezado del archivo en formato JavaDoc
package.in.multiple.modules.problem.descriptor2=El paquete ''{0}'' tiene clases en los módulos ''{1}'' y ''{2}''
package.in.multiple.modules.problem.descriptor3=El paquete ''{0}'' tiene clases en los módulos ''{1}'', ''{2}'' y ''{3}''
package.in.multiple.modules.problem.descriptor.many=El paquete ''{0}'' tiene clases en los módulos ''{1}'', ''{2}'' y ''{3}'' otros módulos
use.isblank.to.check.if.string.is.whitespace.or.empty=Utilice 'isBlank()' para comprobar si una cadena está vacía o contiene solo espacios en blanco
expression.may.be.factorized.display.name=Puedes factorizar expresiones.
create.missing.enum.switch.branches.fix.family.name=Crear rama de cambio de enumeración faltante
create.missing.sealed.class.switch.branches.fix.family.name=Crear rama de cambio de clase sellada que falta
inspection.case.mismatch.message.label.is.lower=La rama de cambio es inaccesible: la etiqueta contiene símbolos en minúsculas, pero el selector solo está en mayúsculas
inspection.case.mismatch.message.label.is.upper=La rama de cambio es inaccesible: la etiqueta contiene símbolos en mayúsculas, pero el selector solo está en minúsculas
for.can.be.foreach.fix.no.indexed=No informar el bucle indexado 'java.util.List'
use.of.concrete.class.option.ignore.records=Ignorar registros de Java
create.null.branch.fix.family.name=Insertar rama 'nula'
instanceof.concrete.class.pattern.problem.descriptor=Prueba de patrón para clase concreta <code>#ref</code> #loc
remove.annotation.parameter.0.fix.name=Eliminar el parámetro de anotación ''{0}''
set.annotation.parameter.0.1.fix.name=Establecer parámetro de anotación {0} = "{1}"
progress.text.analyzing.package.0=Analizando el paquete ''{0}''
test.case.in.product.code.display.name=JUnit TestCase en la fuente del producto
unnecessary.inner.interface.modifier.problem.descriptor=El controlador <code>#ref</code> duplica la interfaz interna #loc
unnecessary.interface.method.modifier.problem.descriptor=El controlador <code>#ref</code> está duplicado con el método de interfaz #loc
unnecessary.interface.inner.class.modifier.problem.descriptor=El controlador <code>#ref</code> está duplicado con una clase interna de interfaz #loc
unnecessary.interface.field.modifier.problem.descriptor=El controlador <code>#ref</code> está duplicado con el campo de interfaz #loc
unnecessary.modifier.display.name=Controlador innecesario
unnecessary.enum.constructor.modifier.problem.descriptor=El controlador <code>#ref</code> es redundante con el constructor de enumeración #loc
unnecessary.inner.enum.modifier.problem.descriptor=El controlador <code>#ref</code> es un duplicado de la enumeración interna #loc
unnecessary.record.modifier.problem.descriptor=El controlador <code>#ref</code> no es necesario para el registro
unnecessary.inner.record.modifier.problem.descriptor=El controlador <code>#ref</code> no es necesario para registros internos
unnecessary.transient.modifier.problem.descriptor=El controlador <code>#ref</code> duplica el campo 'estático' #loc
unnecessary.strictfp.modifier.problem.descriptor=El controlador <code>#ref</code> es redundante en Java 17 y posteriores #loc
inspection.replace.on.literal.display.name=La acción alternativa no funciona
missing.override.warn.on.super.option=Resalte un método si todos los métodos que anula no tienen la anotación '@Override'
unnecessary.interface.member.modifier.problem.descriptor=El controlador <code>#ref</code> está duplicado con el miembro de la interfaz #loc
try.with.identical.catches.checkbox.different.comments=No informar bloques de captura con otras anotaciones
unresolved.class.reference.repair.display.name=Referencias de clase no resueltas
unresolved.class.reference.repair.problem.descriptor=No se pudo resolver la referencia ''{0}''
switch.statement.with.too.few.branches.ignore.pattern.option=No informa declaraciones de cambio de patrón
pattern.variable.hides.field.display.name=La variable de patrón oculta el campo
pattern.variable.hides.field.problem.descriptor=La variable de patrón <code>#ref</code> oculta el campo de la clase ''{0}'' #loc
law.of.demeter.field.problem.descriptor=El acceso <code>#ref</code> viola las leyes de Demeter #loc
instantiating.datetimeformatter.without.locale.problem.descriptor=Llame a <code>DateTimeFormatter.#ref</code> sin especificar la configuración regional en un contexto internacionalizado #loc
change.modifier.package.private.quickfix=Crear paquete privado
inspection.non.strict.comparison.equality.message=Se puede sustituir por uno equivalente.
inspection.non.strict.comparison.equality.display.name=La falta de coincidencia no estricta '>=' o '<=' se puede reemplazar por '=='
test.method.is.public.void.no.arg.problem.descriptor1=El método de prueba <code>#ref()</code> probablemente no debería tener parámetros #loc
test.method.is.public.void.no.arg.problem.descriptor2=El método de prueba <code>#ref()</code> no se declara 'public void' #loc
test.method.is.public.void.no.arg.problem.descriptor3=El método de prueba <code>#ref()</code> no debe ser 'estático' #loc
inspection.use.of.slash.s.fix.family=Reemplazar secuencias '\\s' con espacios
inspection.use.of.slash.s.message=No se recomienda utilizar la secuencia de escape '\\s' en medio de una línea.
inspection.use.of.slash.s.display.name=Uso no terminal de la secuencia de escape '\\s'
negative.int.constant.in.long.context.display.name=Las constantes hexadecimales que son números enteros negativos se utilizan en contexto largo.
negative.int.constant.in.long.context.fix.add.suffix=Se agregó el sufijo 'L' (significado cambiado)
negative.int.constant.in.long.context.fix.convert=Convertir a constante larga (conservar el significado)
allow.suppressions.preview.text=En la configuración, la identificación de inspección se agrega a la lista de supresión permitida.
inspection.only.one.element.used.display.name=Sólo se utiliza un elemento
inspection.only.one.element.used.array=Sólo se utiliza una matriz
inspection.only.one.element.used.string=Sólo se utiliza un carácter de cadena
inspection.only.one.element.used.list=Solo se utiliza un elemento de lista
inspection.only.one.element.used.fix.family=Reemplazar con el elemento accedido
inspection.incorrect.date.format.display.name=Patrón 'DateTimeFormat' no válido
inspection.incorrect.date.format.message.unsupported=Carácter de patrón no válido ''{0}
inspection.incorrect.date.format.message.unpaired=Cerrar <code>#ref</code> sin abrir previamente ''{0}''
inspection.incorrect.date.format.message.padding=Modificador de relleno ''{0}'' sin caracteres de patrón consecutivos
static.method.only.used.in.one.class.quickfix.preview=Mueva un miembro estático a la clase en la que se está utilizando.
inspection.type.may.be.weakened.add.stopper.preview=Esta verificación agrega la clase de parada correspondiente a la lista de clases de parada.
inspection.simplifiable.compare.java.time.display.name=Las expresiones 'java.time' con llamadas 'compareTo()' se pueden simplificar
inspection.simplifiable.compare.java.time.family.name=Java.time' Simplifica la expresión con la llamada 'compareTo()
inspection.simplifiable.compare.java.time.problem.descriptor=Las expresiones con llamadas 'java.time' <code>#ref()</code> se pueden simplificar
inspection.redundant.string.new.array.message=<code>#ref</code> está duplicado #loc
inspection.incorrect.date.format.message.reserved.character=Uso del carácter reservado ''{0}''
inspection.incorrect.date.format.too.many.letters=Hay demasiados caracteres de patrón consecutivos ''{0}''. Máximo: {1}, Especificado: {2}
inspection.incorrect.date.format.too.few.letters=Hay muy pocos caracteres de patrón consecutivos ''{0}''. Mínimo: {1}, Especificado: {2}
inspection.incorrect.date.format.wrong.number.of.letters=El número de caracteres de patrón consecutivos ''{0}'' es incorrecto. Posible: {1}, Especificado: {2}
inspection.incorrect.date.format.message.literal=Comillas abiertas sin comillas de cierre finales ({0})
redundant.escape.in.regex.replacement.display.name=Escape innecesario en cadenas de reemplazo de expresiones regulares
redundant.escape.in.regex.replacement.problem.descriptor=Escape innecesario de ''{0}''
inspection.common.subexpression.in.switch.display.name=Se pueden extraer subexpresiones comunes de 'switch'
inspection.common.subexpression.in.switch.fix.family.name=Bajar la expresión 'cambiar'
inspection.cast.can.be.replaced.with.variable.display.name=Puede cambiar la conversión de tipo a variable
inspection.cast.can.be.replaced.with.variable.message=Se puede utilizar la variable ''{0}'' en lugar de ''{1}''
inspection.cast.can.be.replaced.with.variable.family.name=Convertir tipo de conversión a variable
suspicious.comparator.compare.descriptor.non.positive=El comparador no devuelve un valor positivo
suspicious.comparator.compare.descriptor.non.negative=El comparador no devuelve valores negativos
inspection.redundant.length.check.display.name=Verifique la longitud innecesaria de la matriz
suspicious.comparator.compare.descriptor.min.value=No se recomienda devolver Integer.MIN_VALUE de los métodos de comparación
replace.all.file.separator.problem.descriptor=File.separator se utiliza como expresión regular y no funciona en Windows
