0.already.contains.field.1={0}에 필드 {1}이(가) 이미 포함되어 있습니다.
0.already.contains.inner.class.named.1=이름이 {1}인 내부 클래스가 {0}에 이미 포함되어 있습니다.
0.already.has.parameter.named.1.use.this.name.anyway=이름이 ''{1}''인 매개변수가 {0}에 이미 있습니다.\n\
그래도 이 이름을 사용하시겠어요?
0.contains.call.with.null.argument.for.parameter.1={0}에는 매개변수 {1}의 null 인수가 있는 호출이 포함되어 있습니다.
0.implements.1={0} 은(는) {1}을(를) 구현합니다.
0.is.1.and.will.not.be.accessible.from.2.in.the.target.class={0} 은(는) {1}이며 {2}에서 액세스할 수 없습니다.
0.is.a.part.of.method.hierarchy.do.you.want.to.delete.multiple.parameters={0} 은(는) 메소드 계층 구조의 일부입니다. 여러 매개변수를 삭제하시겠어요?
0.is.a.part.of.method.hierarchy.do.you.want.to.delete.multiple.type.parameters={0} 은(는) 메소드 계층 구조의 일부입니다. 여러 유형 매개변수를 삭제하시겠어요?
0.is.an.interface.method.implementation.will.be.added.to.all.directly.implementing.classes={0} 은(는) 인터페이스입니다. \n\
메소드 구현은 모든 구현 클래스에 바로 추가됩니다.\n\
 진행하시겠어요?
0.is.an.interface.that.has.no.implementing.classes={0} 은(는) 구현 클래스가 없는 인터페이스입니다.
0.is.not.a.legal.java.identifier=''{0}''은(는) 정규 Java 식별자가 아닙니다.
0.is.not.accessible.from.1.value.for.introduced.parameter.in.that.method.call.will.be.incorrect={1}에서 {0}에 액세스할 수 없습니다. 해당 메소드 호출에 삽입된 매개변수의 값이 올바르지 않습니다.
0.is.not.initialized.in.declaration.such.fields.are.not.allowed.in.interfaces={0}이(가) 선언에서 초기화되지 않습니다. 이러한 필드는 인터페이스에서 허용되지 않습니다.
0.is.not.static.it.cannot.be.moved.to.the.interface={0}이(가) 정적이지 않습니다. 인터페이스로 이동시킬 수 없습니다.
0.is.used.for.writing.in.1={0} 은(는) {1}에서 쓰기에 사용됩니다.
0.or.all.directories.in.project={0} 또는 프로젝트의 모든 디렉토리?
0.refactoring.is.supported.only.for.final.fields={0} 리팩토링은 final 필드에만 지원됩니다.
0.upcasts.an.instance.of.1.to.2={0} 은(는) {1}의 인스턴스를 {2}(으)로 업캐스트합니다.
0.uses.1.of.an.instance.of.a.2={0} 은(는) {2}의 인스턴스의 {1}을(를) 사용합니다.
0.uses.1.which.needs.class.instance={0} uses {1},which needs class instance
0.uses.a.package.local.1={0} 은(는) 패키지 프라이빗 {1}을(를) 사용합니다.
0.uses.non.static.1.which.is.not.passed.as.a.parameter={0} uses non-static {1},which is not passed as a parameter
0.will.be.inaccessible.from.1={1}에서 {0}에 액세스할 수 없게 됩니다.
0.will.become.inaccessible.from.1={1}에서 {0}에 액세스할 수 없게 됩니다.
0.will.hide.renamed.1={0} 은(는) 이름 변경된 {1}을(를) 숨깁니다.
0.will.no.longer.override.1={0}이(가) {1}을(를) 더 이상 재정의하지 않습니다.
0.will.not.be.accessible.from.1.after.inlining=인라인화하면 {1}에서 {0}에 액세스할 수 없게 됩니다.
0.will.override.renamed.1={0} 은(는) 이름 변경된 {1}을(를) 재정의합니다.
a.package.local.class.0.will.no.longer.be.accessible.from.1={1}에서 패키지 로컬 클래스 {0}에 더 이상 액세스할 수 없습니다.
accept.signature.change=시그니처 변경 수락
add.object.as.a.parameter.to.constructors.with.name=객체를 다음 이름의 생성자에 추가(&O)\:
add.parameters.for.fields=필드 매개변수 추가(&F)\:
add.parameters.for.fields.to.constructors=필드 매개변수를 생성자에 추가(&F)\:
all.candidate.variables.have.types.not.in.project=모든 후보 변수는 프로젝트에 없는 유형을 포함합니다.
all.candidate.variables.have.unknown.types=모든 후보 변수는 알 수 없는 유형을 포함합니다.
all.invocations.keep.the.method=전체 인라인화 및 메소드 유지(&E)
all.references.and.remove.super.class=전체 참조 인라인화 및 클래스 제거(&A)
all.references.and.remove.the.class=전체 참조 인라인화 및 클래스 제거(&A)
all.references.and.remove.the.field=전체 인라인화 및 필드 제거(&A)
all.references.keep.field=전체 인라인화 및 필드 유지(&E)
all.these.directories.will.be.moved.and.all.references.to.0.will.be.changed=All these directories will be moved,and all references to {0} \n\
will be changed.
analyze.and.replace.usages=사용 위치 분석 및 교체
analyze.module.conflicts=모듈 충돌 분석...
annotate.field.as.nonnls.checkbox=@NonNls로 필드에 어노테이션 추가(&F)
anonymous.class.text=익명 클래스
anonymous.to.inner.enum.constant.cannot.refactor.message=열거형 상수는 내부 클래스로 변환될 수 없습니다.
anonymousToInner.class.name.label.text=클래스 이름\:
anonymousToInner.make.class.static.checkbox.text=클래스를 정적으로 설정(&S)
anonymousToInner.no.inner.class.name=클래스 이름을 지정해야 합니다.
anonymousToInner.parameters.panel.border.title=생성자 매개변수
anonymousToInner.refactoring.name=익명을 내부로 변환
auto.rename.module.dialog.description=다음 이름을 가진 Java 모듈의 이름 변경\:
auto.rename.module.dialog.title=Java 모듈 이름 변경
auto.rename.module.entity=Java 모듈
boolean.method.result=부울 메소드 결과
can.t.restore.context.for.method.extraction=메소드 추출 컨텍스트를 복원할 수 없습니다.
cannot.find.or.create.destination.directory=대상 디렉토리를 찾거나 생성할 수 없습니다.
cannot.introduce.field.in.interface=인스턴스 필드가 인터페이스에서 허용되지 않습니다.
cannot.introduce.field.in.record=인스턴스 필드가 기록에서 허용되지 않습니다.
cannot.move=이동할 수 없음
cannot.move.inner.class.0.into.itself=내부 클래스 {0}을(를) 자체 내로 이동할 수 없습니다.
cannot.move.package.into.itself=패키지를 자체로 이동할 수 없습니다.
cannot.replace.temp.with.query.in.interface=인터페이스에서 임시를 쿼리로 교체할 수 없습니다.
caret.position.warning.message=캐럿은 리팩토링할 필드, 변수, 메소드 또는 메소드 매개변수의 유형에 있어야 합니다.
change.method.signature.action.name=메소드 시그니처 변경
change.signature.default.value.missing.warning.message=디폴트 값이 없습니다. 메소드 호출에 새로운 매개변수 값 대신 공백이 포함됩니다.
change.signature.use.any.checkbox=임의의 변수 사용(&U)
changeClassSignature.bad.value=잘못된 {0} 값\: 매개변수 ''{2}''의 ''{1}''
changeClassSignature.class.label.text={0}의 시그니처 변경
changeClassSignature.no.type.parameters=클래스는 유형 매개변수를 가질 수 없습니다.
changeClassSignature.parameters.panel.border.title=매개 변수
changeClassSignature.refactoring.name=클래스 시그니처 변경
changeSignature.bound.value.column=바운드 값\:
changeSignature.cannot.resolve.return.type=반환 유형 ''{0}''을(를) 해결할 수 없습니다.\n\
계속하시겠어요?
changeSignature.default.value.column=디폴트 값\:
changeSignature.exception.caller.chooser=새 예외를 전달할 메소드 선택
changeSignature.exceptions.panel.border.title=예외
changeSignature.exceptions.wont.propagate=예외 변경 내용의 재귀적 전달이 수행되지 않습니다.
changeSignature.no.return.type=반환 유형이 지정되지 않았습니다.
changeSignature.no.type.for.exception=예외 유형 지정
changeSignature.no.type.for.parameter=매개변수 ''{1}''의 유형을 {0}(으)로 지정
changeSignature.not.throwable.type=Wrong type ''{0}'' for exception,should extend java.lang.Throwable
changeSignature.propagate.exceptions.title=예외 전달(&X)...
changeSignature.vararg.not.last=Vararg 매개변수는 메소드 시그니처의 마지막 매개변수여야 합니다
changeSignature.wrong.return.type=잘못된 반환 유형\: ''{0}''
changeSignature.wrong.type.for.exception=잘못된 유형\: 예외의 ''{0}''
changeSignature.wrong.type.for.parameter=잘못된 유형\: 매개변수 ''{1}''의 ''{0}''
checking.conflicts=충돌 확인 중...
choose.the.ones.you.want.to.be.deleted=삭제할 항목을 선택하십시오.
class.0.already.exists=클래스 {0}이(가) 이미 있습니다.
class.0.is.not.accessible.from.target.1=대상 {1}에서 클래스 {0}에 액세스할 수 없습니다.
class.0.not.found=클래스 {0}을(를) 찾을 수 없습니다.
class.description=클래스 {0}
class.does.not.exist.in.the.project=프로젝트에 클래스가 없습니다. 생성하시겠습니까?
class.does.not.have.base.classes.or.interfaces=클래스 {0}에 기본 클래스 또는 인터페이스가 없습니다.
class.does.not.have.implicit.default.constructor=클래스 {0}에 암묵적 디폴트 생성자가 없습니다.
class.has.been.successfully.created=클래스 {0}이(가) 성공적으로 생성되었습니다.
class.is.abstract={0} 은(는) 추상입니다.
class.is.final.warning.message={0} 클래스는 final 클래스입니다.
class.is.interface={0} 은(는) 인터페이스입니다.
class.is.never.used=클래스가 사용되지 않습니다.
class.name.prompt=클래스 이름(&N)\:
collect.overloads=오버로드 수집...
comments.elements.header=Occurrences found in comments,strings and non-code files {0}
constructor.being.refactored.is.used.in.initializer.of.0=리팩토링되는 생성자는 {0}의 이니셜라이저에서 사용됩니다. 내부 클래스 {1}의 비정적 factory는 이 컨텍스트에서 사용할 수 없습니다. 결과 코드는 컴파일되지 않습니다.
constructor.description=생성자 {0}
constructor.with.builder.new.setter.prefix.dialog.message=새로운 setter 접두사\:
constructor.with.builder.parameters.to.pass.to.the.builder.title=빌더에 전달할 매개변수
constructor.with.builder.rename.setters.prefix.action.name=setter 접두사 이름 변경
convert.anonymous.to.inner.action.name=익명을 내부로 변환...
convert.local.to.field.title=로컬을 필드로 변환
convert.to.instance.method.title=인스턴스 메소드로 변환
convertToInstanceMethod.all.reference.type.parameters.are.not.in.project=인스턴스 메소드에 대한 대상 클래스를 찾을 수 없습니다. 참조된 모든 유형이 프로젝트에 없습니다.
convertToInstanceMethod.all.reference.type.parametres.have.unknown.types=인스턴스 메소드에 대한 대상 클래스를 찾을 수 없습니다. 참조된 모든 유형을 알 수 없습니다.
convertToInstanceMethod.method.is.not.static=리팩토링을 수행할 수 없습니다.\n\
메소드 {0}이(가) 정적이지 않습니다.
convertToInstanceMethod.no.parameters.with.reference.type=참조 유형이 있는 매개변수가 없습니다.
copy.class.clone.0.1={0} {1} 복제
copy.class.copy.0.1={0} {1} 복사
copy.handler.clone.class=클래스 복제
copy.handler.copy.class=클래스 복사
copy.handler.copy.class.with.dialog=클래스 복사...
copy.handler.copy.classes.with.dialog=클래스 복사...
copy.handler.is.not.available.during.indexing=색인 생성 중 클래스 복사를 사용할 수 없습니다.
current.class=현재 클래스
dataflow.to.here.expand.progress=모든 노드 확장...{0}
dataflow.to.here.group.by.leaf.action.description=null이 해당 식으로 유입될 수 있는지 판단
dataflow.to.here.group.by.leaf.action.text=리프 식 Nullness{0, choice, 1\#|2\#  (Analysis in Progress)}에 따라 그룹 지정
dataflow.to.here.variable.dereferenced.tooltip=역참조된 변수
declaration.s.to.be.generified=일반화될 선언 {0}
declare.final=final 선언(&F)
declare.generated.annotations=어노테이션 생성(&G)
declare.static.checkbox=static 선언(&S)
declare.static.pass.fields.checkbox=static 선언(필드를 매개변수로 전달)(&S)
declare.var.type=var 유형 선언(&V)
declare.varargs.checkbox=vararg 선언(&A)
default.visibility.border.title=디폴트 가시성
delegate.members=멤버 위임(&B)
delegating.field=위임 필드
delete.variable.declaration=변수 선언 삭제(&D)
destination.directory.does.not.correspond.to.any.package=대상 디렉토리가 패키지와 일치하지 않습니다.
destination.package=대상 패키지(&P)\:
directory.0.already.contains.1.named.2=이름이 ''{2}''인 {1}이(가) \n\
디렉토리 {0}에 이미 포함되어 있습니다.
directory.0.already.contains.a.file.named.1=이름이 ''{1}''인 파일이 \n\
디렉토리 {0}에 이미 포함되어 있습니다.
do.not.replace=교체 안 함(&N)
do.not.show.this.message.in.the.future=이 메시지를 다시 표시 안 함(&D)
do.you.want.to.process.overriding.methods.with.covariant.return.type=공변성 반환 유형이 있는\n\
재정의 메소드를 처리하시겠습니까?
dont.move.to.another.source.folder.option=다른 소스 폴더로 이동하지 않음(&D)
edit.migration.entry.title=클래스/패키지 마이그레이션 설명 편집
edit.migration.map.title=마이그레이션 맵 편집
element.will.no.longer.be.accessible={1}에서 {0}에 더 이상 액세스할 수 없습니다.
encapsulate.fields..encapsulated.fields.visibility.border.title=캡슐화된 필드의 가시성
encapsulate.fields..package.local.radio=로컬 패키지(&C)
encapsulate.fields.accessors.visibility.border.title=접근자 가시성
encapsulate.fields.command.name={0}의 필드 캡슐화
encapsulate.fields.encapsulate.border.title=캡슐화
encapsulate.fields.field.column.name=필드
encapsulate.fields.fields.to.be.encapsulated=캡슐화할 필드
encapsulate.fields.fields.to.encapsulate.border.title=캡슐화할 필드
encapsulate.fields.get.access.checkbox=액세스 권한 획득(&G)
encapsulate.fields.getter.column.name=Getter
encapsulate.fields.getter.exists=getter {1} 와(과) 반환 유형만 다른 메소드 {0} 이(가) 이미 있습니다
encapsulate.fields.nothing.todo.warning.message=클래스에 캡슐화할 필드가 없습니다.
encapsulate.fields.private.radio=Private(&I)
encapsulate.fields.protected.radio=보호됨(&T)
encapsulate.fields.refactoring.cannot.be.applied.to.interface=필드 캡슐화 리팩토링을 인터페이스에 적용할 수 없습니다.
encapsulate.fields.set.access.checkbox=액세스 설정(&S)
encapsulate.fields.setter.column.name=Setter
encapsulate.fields.setter.exists=setter {1} 와(과) 반환 유형만 다른 메소드 {0} 이(가) 이미 있습니다
encapsulate.fields.title=필드 캡슐화
encapsulate.fields.use.accessors.even.when.field.is.accessible.checkbox=필드에 액세스할 수 있는 경우에도 접근자 사용(&U)
entity.name.constructor.parameter=매개변수
entity.name.inheritor=상속자
entity.name.test=테스트
entity.name.variable=변수
entity.name.accessor=접근자
enum.description=열거형 {0}
error.cannot.resolve={0}을(를) 해결할 수 없습니다.
error.incorrect.data=잘못된 데이터
error.not.supported.for.jsp={0} 리팩토링은 JSP에서 지원되지 않습니다.
error.not.supported.for.local={0} 리팩토링은 로컬 클래스에서 지원되지 않습니다.
error.not.supported.for.package.info={0} 리팩토링은 package-info.java에서 지원되지 않습니다.
error.wrong.caret.position.anonymous=캐럿은 리팩토링할 익명 클래스 내부에 있어야 합니다.
error.wrong.caret.position.constructor=캐럿은 리팩토링할 생성자 내부에 있어야 합니다.
error.wrong.caret.position.local.name=캐럿이 리팩토링할 지역 변수 이름에 있어야 합니다.
error.wrong.caret.position.local.or.expression.name=캐럿이 리팩토링할 지역 변수 또는 표현식 이름에 있어야 합니다.
error.wrong.caret.position.method=캐럿이 리팩토링할 메소드 내부에 있어야 합니다.
error.wrong.name.input=잘못된 이름\: {0}
expand.method.reference.warning=메소드는 메소드 참조에 사용됩니다. 진행하면 람다 식으로 변환됩니다.
expression.result=표현식 결과
extract.chained.constructor.checkbox=체인 생성자 추출(&C)
extract.delegate.as.enum.checkbox=열거형으로 추출
extract.delegate.create.nested.checkbox=중첩 클래스 생성
extract.delegate.generate.accessors.checkbox=접근자 생성
extract.delegate.unable.create.warning.message=지정된 이름으로 클래스를 생성할 수 없습니다.
extract.method.control.flow.analysis.failed=코드에 구문 오류가 포함되어 있습니다. 필요한 분석을 수행할 수 없습니다.
extract.method.error.prefix=메소드를 추출하지 못했습니다.
extract.method.error.class.outside.used=지역 클래스가 선택된 블록 외부에서 사용되고 있습니다.
extract.method.error.class.outside.defined=지역 클래스가 선택된 블록 외부에 정의되어 있습니다.
extract.method.error.many.outputs=반환할 변수가 여러 개 있습니다.
extract.method.error.many.exits=종료점이 여러 개 있습니다.
extract.method.error.many.finals=final 필드에 대입할 항목이 1개 있습니다.
extract.method.error.variable.in.expression=선택된 표현식 내에서 반환할 변수가 1개 있습니다.
extract.method.error.class.not.found=선택된 블록은 Java 클래스의 일부여야 합니다.
extract.method.object.anonymous.make.varargs.option=가변인수 생성(&V)
extract.method.object.class.name=클래스 이름(&C)\:
extract.method.object.create.anonymous.class=익명 클래스 생성(&A)
extract.method.object.create.inner.class=내부 클래스 생성(&I)
extract.method.object.inner.class.visibility=가시성\:
extract.method.object.inner.make.static.option=정적으로 설정(&S)
extract.method.object.inner.make.varargs.option=가변인수 생성(&V)
extract.method.object.inner.visibility.package.local=로컬 패키지(&K)
extract.method.object.inner.visibility.private=비공개(&V)
extract.method.object.inner.visibility.protected=protected(&O)
extract.method.object.inner.visibility.public=공개(&B)
extract.method.object.method.name=메소드 이름(&M)\:
extract.method.object.parameters=매개 변수
extract.method.object.signature.preview=시그니처 미리보기
extract.method.object.suggestion=메소드 객체 추출을 원하십니까?
extract.parameters.to.replace.duplicates=매개변수를 추출하여 중복 교체
extract.subclass.command=하위 클래스 추출
extractSuper.rename.original.class.to=원본 클래스의 이름을 다음으로 변경(&R)\:
extractSuperInterface.javadoc=JavaDoc
factory.method.name.label=factory 메소드 이름\:
failed.to.re.run.refactoring=리팩토링을 다시 실행하지 못했습니다.
field.0.is.already.defined.in.the.1=필드 {0} 은(는) {1}에 이미 정의되어 있습니다.
field.0.is.never.used=필드 {0} 은(는) 전혀 사용되지 않습니다.
field.0.is.not.accessible={1}에서 필드 {0}에 액세스할 수 없습니다.
field.0.will.hide.field.1.of.the.base.class=필드 {0} 은(는) 기본 {2}의 \n\
필드 {1}을 숨깁니다.
field.declaration.radio=필드 선언(&D)
field.description=필드 {0}
field.name=필드 이름(&F)\:
fields.to.be.refactored.should.belong.to.the.same.class=리팩토링할 필드는 동일한 클래스에 속해야 합니다.
functional.interface.broken=함수식은 정확한 한 가지 메소드를 가지려면 함수 인터페이스가 있어야 합니다.
generate.getter.for.delegated.component=위임된 구성 요소의 getter 생성(&G)
generate.module.descriptors.analysing.message=종속 요소 분석 중
generate.module.descriptors.build.required.message=프로젝트가 아직 빌드되지 않았기 때문에 모듈 설명자를 생성할 수 없습니다.
generate.module.descriptors.collecting.message=종속 요소 수집 중
generate.module.descriptors.command.title=모듈 정보 설명자 생성
generate.module.descriptors.no.suitable.modules.message=module-info를 포함할 수 있는 모듈을 찾지 못했습니다.
generate.module.descriptors.preparing.message=코드 준비 중
generate.module.descriptors.rebuild.message=종속 요소 계산의 정확도를 높이기 위해 프로젝트를 빌드해야 합니다. \n\
module-info 설명자를 생성하기 전 빌드를 시작하시겠습니까?
generate.module.descriptors.scanning.message=컴파일러 출력 검사 중
generate.module.descriptors.title=모듈 설명자 생성
generify.title=일반화
getter.and.setter.methods.found.for.the.field.0=필드 {0} 의 getter 및 setter 메소드가 발견되었습니다. \n\
이 메소드도 {1} 하시겠어요?
getter.method.found.for.the.field.0=필드 {0} 의 getter 메소드가 발견되었습니다. \n\
이 getter도 {1} 하시겠어요?
idea.has.not.found.any.code.that.can.be.replaced.with.method.call={0}이(가) 중복을 찾지 못했습니다.
ignore.button=무시
information.title=정보
initializer.for.variable.cannot.be.a.constant.initializer=변수 {0}의 이니셜라이저는 상수 이니셜라이저가 될 수 없습니다.
inline.action.name=인라인
inline.anonymous.conflict.progress=클래스 "{0}" 상속자 검색 중 ...
inline.class.elements.header=인라인화할 클래스
inline.conflicts.progress=인라인화가 가능한지 확인...
inline.constant.field.not.supported.for.enum.constants={0} 은(는) 열거형 상수에서 지원되지 않습니다.
inline.field.command=필드 {0} 인라인화
inline.field.elements.header=인라인화할 필드
inline.field.field.name.label=필드 {0} {1}
inline.field.title=필드 인라인화
inline.local.unable.try.catch.warning.message=Try/catch 문 외부에서 인라인화할 수 없음
inline.local.used.as.resource.cannot.refactor.message=변수가 리소스 참조로 사용됩니다.
inline.local.variable.declared.outside.cannot.refactor.message=변수가 코드 블록 외부에서 선언됩니다.
inline.method.checking.tail.calls.progress=테일 호출 사용 위치 확인 중
inline.method.elements.header=인라인할 메소드
inline.method.object.action.name=객체 인라인화
inline.method.object.suggestion.message=개체와 후속 호출을 인라인화하시겠습니까?
inline.parameter.cannot.find.initializer.warning.message=매개변수에 대한 상수 이니셜라이저를 찾을 수 없습니다.
inline.parameter.confirmation=매개변수 ''{0}''을(를) 이니셜라이저 ''{1}''(으)로 인라인화하시겠어요?
inline.parameter.error.hierarchy=메소드가 상속 계층 구조의 일부인 경우 Inline 매개변수가 지원되지 않습니다.
inline.parameter.error.varargs=varargs 매개변수에 대한 인라인화는 지원되지 않습니다.
inline.parameter.method.usages.progress=메소드 사용 위치 검색 중
inline.parameter.no.usages.warning.message=메소드에 사용 위치가 없습니다.
inline.parameter.not.accessible.warning.message=메소드 본문에서 상수 이니셜라이저에 액세스할 수 없습니다.
inline.parameter.refactoring=Inline 매개변수
inline.parameter.replace.with.local.checkbox=지역 변수로 교체(&E)
inline.parameter.write.usages.warning.message=쓰기에 사용되는 Inline 매개변수는 지원되지 않습니다.
inline.pattern.variable.title=패턴 변수 인라인화
inline.super.non.project.class.warning.message=비 프로젝트 클래스를 인라인화할 수 없습니다.
inline.to.anonymous.border.title=인라인
inline.to.anonymous.command.name=클래스 {0} 인라인화
inline.to.anonymous.name.label=클래스 {0}
inline.to.anonymous.no.abstract=추상 클래스는 인라인화할 수 없습니다.
inline.to.anonymous.no.multiple.interfaces=여러 인터페이스를 구현하는 클래스는 인라인화할 수 없습니다.
inline.to.anonymous.no.superclass.and.interface=상위 클래스가 있고 인터페이스를 구현하는 클래스는 인라인화할 수 없습니다.
inline.to.anonymous.refactoring=익명 클래스로 인라인화
inline.vars.elements.header=인라인화할 변수
inlined.method.implements.method.from.0=인라인화된 메소드는 {0}의 메소드를 구현합니다.
inlined.method.overrides.method.from.0=인라인화된 메소드는 {0}의 메소드를 재정의합니다.
inlined.method.will.be.transformed.to.single.return.form=인라인화된 메소드는 단일 반환 형식으로 변환됩니다.
inner.class.0.is.already.defined.in.class.1=내부 클래스 {0} 은(는) 클래스 {1}에 이미 정의되어 있습니다.\n\
그래도 계속하시겠어요?
inner.class.0.is.not.static=내부 클래스 {0} 은(는) 정적이지 않습니다.\n\
{1} 리팩토링은 정적 멤버에만 지원됩니다.
inner.class.exists=''{0}''(이)라는 이름의 내부 클래스가 클래스 ''{1}''에\n\
이미 정의되어 있습니다.
inner.class.name=내부 클래스 이름(&I)\:
instance.initializer.description=클래스 {0}의 인스턴스 이니셜라이저
instances.casted.to.java.lang.object=java.lang.Object로 형 변환된 인스턴스
instances.of.0.upcasted.to.1.were.found=Instances of {0} upcasted to {1} were found. If you continue,they will be shown in a separate Find tab.
instances.upcasted.to.java.lang.object.found=java.lang.Object로 업캐스트된 인스턴스 발견
instances.upcasted.to.object=객체로 업캐스트된 인스턴스 발견
interface.0.does.not.have.inheritors=인터페이스 {0}에 상속자가 없습니다.
interface.description=인터페이스 {0}
interface.does.not.have.base.interfaces=인터페이스 {0}에 기본 인터페이스가 없습니다.
interface.has.been.successfully.created=인터페이스 {0}이(가) 성공적으로 생성되었습니다.
introduce.constant.enum.cb=열거형 상수로서 추출(&E)
introduce.constant.field.of.type=유형의 상수(static final 필드)(&T)\:
introduce.constant.introduce.to.class=클래스(정규화된 이름)로 추출(&C)\:
introduce.constant.move.to.another.class.checkbox=다른 클래스로 이동
introduce.constant.used.for.write.cannot.refactor.message=선택한 표현식은 쓰기에 사용됩니다.
introduce.field.field.of.type=유형의 필드(&T)\:
introduce.field.static.field.of.type=유형의 정적 필드(&T)\:
introduce.functional.variable.pass.fields.checkbox=필드를 매개변수로 전달(&F)
introduce.local.variable.to.reassign.title=재할당할 변수 선택
introduce.parameter.command=매개변수를 {0}(으)로 추출
introduce.parameter.convert.lambda=함수형 표현식으로 변환(&C)
introduce.parameter.duplicates.progress=메소드 중복 검색 중...
introduce.parameter.elements.header=메소드에 매개변수 추가
introduce.parameter.object.create.inner.class=내부 클래스 생성(&I)
introduce.parameter.object.create.new.class=새 클래스 생성(&C)
introduce.parameter.object.escalate.visibility.option=가시성 에스컬레이션(&E)
introduce.parameter.object.existing.class.name=이름(&N)
introduce.parameter.object.generate.accessors.option=접근자 생성(&G)
introduce.parameter.object.inner.class.name=이름(&N)
introduce.parameter.object.new.class.name=이름(&N)
introduce.parameter.object.new.class.package.name=패키지 이름(&P)
introduce.parameter.object.use.existing.class=기존 클래스 사용(&U)
introduce.parameter.super.method.checkbox=상위 메소드 리팩토링
introduce.parameter.to.method=매개변수를 메소드로 추출\:
introduced.variable.will.conflict.with.0=삽입된 변수가 {0}와(과) 충돌합니다.
introducing.variable.may.break.code.logic=변수를 도입하면 코드 논리가 깨질 수 있습니다.
invalid.expression.context=잘못된 표현식 컨텍스트.
invalid.target.package.name.specified=대상 패키지의 이름이 잘못 지정되었습니다.
invert.boolean.foreach=Foreach 매개변수 이니셜라이저를 반전할 수 없습니다.
invert.boolean.wrong.type=리팩토링할 메소드 또는 변수의 반환 유형은 부울이어야 합니다.
invocations.to.be.inlined=인라인화할 호출 {0}
is.modified.in.loop.body={0}이(가) 루프 본문에서 수정됩니다.
javadoc.for.abstracts=추상에 대한 JavaDoc
keep.original.signature=원본 시그니처 유지
lambda.to.reference.side.effect.warning.message=메소드 참조 한정자에 가능한 부작용이 있습니다.\n\
지역 변수를 도입하시겠습니까?
local.variable.description=지역 변수 {0}
local.will.be.hidden.renamed=이름 변경된 필드는 {0}을(를) 숨깁니다.
locate.caret.inside.a.method=멤버 내부의 캐럿 검색
locate.duplicates.action.name=중복 검색
make.0.static={0}을(를) 정적으로 설정
make.method.static.title=메소드를 정적으로 설정
make.static.command={0}을(를) 정적으로 설정
make.static.description.label={0} {1}을(를) 정적으로 설정
make.static.elements.header={0}을(를) 정적으로 설정
make.static.method.references.progress=메소드 참조 검색
make.static.methods.to.propagate.dialog.title=Static 문을 전달할 메소드 선택
method.0.is.overridden.by.1=메소드 {0}이(가) {1}(으)로 재정의됩니다.
method.0.will.hide.method.of.the.base.class=메소드 {0} 은(는) 기본 클래스 {1}의 \n\
메소드를 숨깁니다.
method.0.will.implement.method.of.the.base.class=메소드 {0} 은(는) 기본 클래스 {1}의 \n\
메소드를 구현합니다.
method.0.will.override.a.method.of.the.base.class=메소드 {0} 은(는) 기본 클래스 {1}의 \n\
메소드를 재정의합니다.
method.call.would.be.linked.to.0.after.rename=메소드 호출은 이름 변경 후 "{0}"에 연결됩니다.
method.column=메소드
method.description=메소드 {0}
method.does.not.have.a.body=메소드 {0}에 본문이 없습니다.
method.duplicates.found.message={0, choice, 1\#1개의 코드 조각|2\#{0,number} 개의 코드 조각} 발견
method.has.an.empty.body=메소드 {0}에 본문이 비어 있습니다.
method.is.not.a.constructor=메소드가 생성자가 아닙니다.
migration.class=클래스
migration.dialog.ok.button.text=실행
migration.dialog.title=패키지 및 클래스 마이그레이션
migration.edit.button=편집...
migration.entry.class=클래스
migration.entry.new.name=새 이름\:
migration.entry.old.name=이전 이름\:
migration.entry.package=패키지
migration.map.description.label=맵 설명\:
migration.map.name.prompt=맵 이름\:
migration.new.name.column.header=새 이름
migration.no.usages.found.in.the.project=프로젝트에서 사용 위치를 찾을 수 없습니다.
migration.old.name.column.header=이전 이름
migration.package=패키지
migration.package.with.subpackages=하위 패키지가 있는 패키지
migration.remove.button=제거
migration.title=마이그레이션
migration.type.column.header=유형
move.class=클래스 이동...
move.class.refactoring.cannot.be.applied.to.anonymous.classes=클래스 이동 리팩토링을 익명 클래스에 적용할 수 없습니다.
move.class.to.inner.command.name={1}(으)로 {0} 이동
move.class.to.inner.move.to.self.error=클래스를 자체로 이동할 수 없습니다.
move.class.to.inner.nonstatic.error=클래스를 비 'static' 내부 클래스로 이동할 수 없습니다.
move.classes=클래스 이동...
move.classes.and.packages=클래스 및 패키지 이동...
move.classes.command=패키지 {1}(으)로 {0} 이동
move.classes.destination.make.inner=다음의 내부 클래스 생성(&M)
move.classes.destination.package.prompt=패키지로\:
move.classes.destination.to.package=대상 패키지(&G)
move.classes.invalid.package.name.warning.message=잘못된 패키지 이름
move.classes.or.packages.title=이동
move.current.directory=현재 디렉토리 이동(&C)
move.directories=모두 이동(&A)
move.directories.to.another.source.root={0} 디렉토리를 다른 소스 루트로 이동(&A)
move.directory.to.another.source.root=디렉토리 {0}을(를) 다른 소스 루트로 이동(&A)
move.enum.constant.cb=가능한 경우 열거형 상수로서 이동(&E)
move.everything.from.directories.to.another.directory={0} 디렉토리에서 다른 디렉토리로 전체 이동
move.everything.to.another.directory={0}에서 다른 디렉토리로 전체 이동
move.files.regrouping.command.name=다시 그룹 지정 중...
move.files.to.new.directory.prompt=대상 디렉토리\:
move.inner.class.action.name=내부 클래스 이동...
move.inner.class.command=내부 클래스 {0} 이동
move.inner.class.to.another.class=내부 클래스 {0}을(를) 다른 클래스로 이동(&M)
move.inner.class.to.be.moved=이동할 클래스
move.inner.class.to.upper.level=내부 클래스 {0}을(를) 상위 수준으로 이동(&I)
move.inner.class.to.upper.level.action.name=내부 클래스를 상위 수준으로 이동...
move.instance.method.delegate.title=인스턴스 메소드 이동...
move.instance.method.elements.header=인스턴스 메소드 이동
move.instance.method.handler.make.method.static=''{0}'' 메소드를 static 메소드로 만들고 이동하시겠습니까?
move.members.action.name=멤버 이동...
move.method.enter.a.valid.name.for.parameter=올바른 매개변수 이름을 입력하십시오.
move.method.is.not.supported.for.0=인스턴스 이동 메소드는 {0}에서 지원되지 않습니다.
move.method.is.not.supported.for.constructors=생성자에 대한 메소드 이동이 지원되지 않습니다.
move.method.is.not.supported.for.generic.classes=제네릭 클래스에 대한 메소드 이동이 지원되지 않습니다.
move.method.is.not.supported.for.non.project.methods=비 프로젝트 메소드에 대한 메소드 이동이 지원되지 않습니다.
move.method.this.parameter.label=''{0}.this'' 매개변수의 이름 선택
move.methods.used.in.extracted.block.only=추출된 블록에만 사용되는 메소드 이동
move.nonstatic.class.from.jsp.not.supported=JSP 페이지의 비 'static' 클래스 이동이 지원되지 않습니다.
move.package.or.directory=패키지 또는 디렉토리 이동...
move.package.refactoring.cannot.be.applied.to.default.package=패키지 이동 리팩토링을 디폴트 패키지에 적용할 수 없습니다.
move.package.to.another.package=패키지 ''{0}''을(를) 다른 패키지로 이동(&P)
move.packages.or.directories=패키지 또는 디렉토리 이동...
move.packages.to.another.package={0} 패키지를 다른 패키지로 이동(&P)
move.single.class.or.package.name.label={0} {1} 이동
move.specified.classes=지정된 클래스 이동
move.specified.classes.to=지정된 클래스를 다음으로 이동\:
move.specified.packages=지정된 패키지 이동
move.to.inner.duplicate.inner.class=이름이 {1}인 내부 클래스가 클래스 {0}에 이미 포함되어 있습니다.
moving.local.classes.is.not.supported=로컬 클래스 이동은 지원되지 않습니다.
no.class.name.specified=클래스 이름이 지정되지 않았습니다.
no.exact.method.duplicates.were.found=<html><b>정확한 메소드 중복을 찾을 수 없습니다.</b>아래에 표시된 것처럼 변경된 메소드는 {0} {0,choice, 1\#중복|2\#중복}을 포함합니다.</html>
no.initializer.present.for.the.field=해당 필드에 대한 이니셜라이저가 존재하지 않습니다.
no.parameter.name.specified=매개변수 이름이 지정되지 않았습니다.
no.usages.can.be.replaced={0}의 사용 위치가 없습니다. \n\
{1}의 사용 위치로 대체할 수 있습니다.
occurrences.to.be.migrated=마이그레이션할 사용 위치 {0}
ok.button=확인
only.fields.variables.of.methods.of.valid.type.can.be.considered=Only fields,variables,method parameters or methods of valid type can be considered.
package.description=패키지 {0}
package.does.not.exist=패키지 {0}이(가) 없습니다.\n\
생성하시겠어요?
package.name.prompt=패키지 이름(&G)\:
parameter.description=매개변수 {0}
parameter.initializer.contains.0.but.not.all.calls.to.method.are.in.its.class=Parameter initializer contains {0},but not all calls to method are in its class
parameter.name.prompt=매개변수 이름(&M)\:
parameter.of.type=유형의 매개변수(&T)\:
parameter.type.table.column.title=유형
pass.outer.class.instance.as.parameter=외부 클래스의 인스턴스를 매개변수로 전달(&O)
please.enter.a.valid.target.package.name=유효한 대상 패키지 이름을 입력하십시오.
press.the.do.migrate.button=Press the "Do Migrate" button at the bottom of the search results panel\n\
to migrate using the migration map "{0}"
preview.usages.to.be.changed=변경할 사용 위치 미리 보기(&P)
process.duplicates.change.signature.promt=모든 사용 위치를 교체하기 위해 메소드 시그니처가 변경됩니다. 진행하시겠습니까?
process.duplicates.title=프로세스 중복
process.methods.duplicates.title=메소드 {2} 중복 처리({1} 중 {0})
processing.progress.text={0} 처리 중
project.files.have.been.changed=프로젝트 파일이 변경되었습니다.\n\
리팩토링을 다시 실행하시겠습니까?
push.down.delete.warning.text={0}멤버를 아래로 이동하면 해당 멤버가 삭제됩니다. 진행하시겠습니까?
push.down.enum.no.constants.warning.text=열거형 {0}에는 인라인화할 상수가 없습니다.
push.down.no.inheritors.class.warning.text=클래스 {0}에 상속자가 없습니다.
push.down.no.inheritors.final.class.warning.text=final 클래스 {0}에 상속자가 없습니다.
re.run.refactoring=리팩토링 다시 실행
refactoring.cannot.be.applied.no.sources.attached=연결된 소스가 없어 {0} 리팩토링을 적용할 수 없습니다.
refactoring.cannot.be.applied.to.abstract.methods={0} 리팩토링은 추상 메소드에 적용할 수 없습니다.
refactoring.cannot.be.applied.to.inline.non.chaining.constructors={0} 리팩토링은 체인이 아닌 생성자에 적용할 수 없습니다.
refactoring.cannot.be.applied.to.native.methods={0} 리팩토링은 기본 메소드에 적용할 수 없습니다.
refactoring.cannot.be.applied.to.vararg.constructors={0} 리팩토링은 vararg 생성자에 적용할 수 없습니다.
refactoring.extract.method.dialog.duplicates.count={0,choice, 1\#하나의|2\#{0,number}개의} 중복 코드 {0,choice, 1\#조각|2\#조각}은 추출된 메소드 호출을 사용하여 교체할 수 있습니다
refactoring.extract.method.dialog.duplicates.pending=중복 검색 중...
refactoring.extract.method.dialog.duplicates.progress=중복 검색
refactoring.extract.method.preview.button.refactor=리팩토링 수행(&D)
refactoring.extract.method.preview.button.rerun=리팩토링 다시 실행(&E)
refactoring.extract.method.preview.failed=메소드 추출 실패
refactoring.extract.method.preview.group.duplicates=코드 조각 복제
refactoring.extract.method.preview.group.method=추출할 메소드
refactoring.extract.method.preview.group.original=원본 코드 조각
refactoring.extract.method.preview.preparing=Diff 준비 중
refactoring.extract.method.preview.updating=Diff 업데이트 중
refactoring.introduce.variable.enum.in.label.message=switch 라벨의 열거형 상수를 추출할 수 없습니다.
refactoring.is.not.supported.for.jsp.classes=\ 리팩토링은 JSP 클래스에서 지원되지 않습니다
refactoring.is.not.supported.for.language={0} 은(는) {1}에서 지원되지 않습니다.
refactoring.is.not.supported.for.local.and.jsp.classes=리팩토링은 로컬 및 JSP 클래스에서 지원되지 않습니다.
refactoring.is.not.supported.in.the.current.context={0} 리팩토링은 현재 컨텍스트에서 지원되지 않습니다.
references.in.code.to.elements.from.migration.map=마이그레이션 맵 "{0}" {1}의 요소에 대한 코드 내 참조
references.to.0.to.be.replaced.with.references.to.1=''{0}''에 대한 참조를 ''{1}''에 대한 참조로 교체
remove.parameter.0.no.longer.used=더 이상 사용되지 않는 매개변수 ''{0}'' 제거
rename.constructor.parameters.title=생성자 매개변수 이름 변경
rename.constructor.parameters.with.the.following.names.to=다음 이름을 가진 매개변수의 이름 변경\:
rename.inheritors.with.the.following.names.to=다음 이름을 가진 상속자의 이름 변경\:
rename.module.already.exists=프로젝트에 모듈 ''{0}''이(가) 이미 있습니다.
rename.module.directory.command=모듈 및 디렉토리 이름을 ''{0}''(으)로 변경합니다.
rename.module.directory.title=모듈 및 디렉토리 이름 변경(&A)
rename.overloads=오버로드 이름 변경(&O)
rename.overloads.dialog.title=오버로드 이름 변경
rename.overloads.to.dialog.description=오버로드 이름을 다음으로 변경\:
rename.parameter.in.hierarchy.to.dialog.description=계층 구조에서 매개변수 이름을 다음으로 변경\:
rename.parameters.dialog.title=매개변수 이름 변경
rename.tests=테스트 이름 변경(&E)
rename.tests.title=테스트 이름 변경
rename.tests.with.the.following.names.to=다음 이름을 가진 테스트의 이름 변경\:
rename.variables=변수 이름 변경(&V)
rename.variables.title=변수 이름 변경
rename.variables.with.the.following.names.to=다음 이름을 가진 변수의 이름 변경\:
rename.accessors=접근자 이름 변경(&A)
rename.accessors.title=Getter/Setter 이름 변경 
rename.accessors.with.the.following.names.to=다음 이름을 가진 접근자의 이름 변경\:
renamed.class.will.hide.0.in.1=이름 변경된 클래스는 {1}에서 {0}을(를) 숨깁니다.
renaming.method.will.override.final.0=메소드 이름 변경은 final "{0}"을(를) 재정의합니다.
replace.all.fields=모든 필드 교체(&R)
replace.all.occurrences.of.expression.0.occurrences=모든 사용 위치 교체({0})(&A)
replace.constructor.0.with.a.factory.method=factory 메소드로 생성자 {0} 교체
replace.constructor.builder.create.new=새로 만들기(&C)
replace.constructor.builder.use.existing=기존 사용(&U)
replace.constructor.existing.builder.fqn=빌더 클래스 이름(정규화된)(&B)
replace.constructor.new.builder.class.name=빌더 클래스 이름(&N)
replace.constructor.new.builder.package=새 빌더를 위한 패키지(&P)
replace.constructor.with.factory.method=factory 메소드로 생성자 교체
replace.constructor.with.factory.method.title=Factory 메소드로 생성자 교체
replace.constructor.with.factory.target.fq.name=대상 위치(정규화된 이름)\:
replace.default.constructor.of.0.with.a.factory.method=factory 메소드로 {0}의 디폴트 생성자 교체
replace.default.constructor.with.factory.method=factory 메소드로 의 디폴트 생성자 교체
replace.fields.inaccessible.in.usage.context=사용 컨텍스트에서 접근할 수 없는 필드 교체(&I)
replace.fields.used.in.expressions.with.their.getters=표현식에 사용된 필드를 getter로 교체
replace.inheritance.from=다음에서 위임 상속으로 교체(&R)\:
replace.inheritance.with.delegation.command={0}에 있는 위임으로 상속 교체
replace.inheritance.with.delegation.elements.header=상속을 위임으로 교체합니다.
replace.inheritance.with.delegation.title=상속을 위임으로 교체
replace.instance.qualifiers.with.class.references=인스턴스 한정자를 클래스 참조로 교체
replace.method.code.duplicates.title=코드 중복 교체
replace.method.duplicates.scope.chooser.message=범위 분석
replace.method.duplicates.scope.chooser.title={0} 범위 지정
replace.temp.with.query.title=임시를 쿼리로 교체
replace.this.code.fragment.and.change.signature=Method signature will be changed to \n\
{0}
replace.this.code.fragment.and.make.method.static=(메소드는 정적으로 설정됩니다)
replace.this.code.fragment.and.make.method.static.visible=(메소드는 정적 및 {0}(으)로 생성)
replace.this.code.fragment.and.make.method.visible=(메소드는 {0}(으)로 생성)
replace.with.method.call.does.not.work.for.constructors='메소드 호출로 교체'는 생성자에서 작동하지 않습니다.
replace.write.access.occurrences=쓰기 액세스 사용 위치 교체(&L)
replacing.inheritance.with.delegation=상속을 위임으로 교체
safe.delete.search.for.caller.method.usages.progress=호출 메소드 사용 위치 검색 중...
safe.delete.select.members.to.propagate.dialog.title=안전한 삭제를 전달할 멤버 선택
safe.delete.select.methods.to.propagate.delete.parameters.dialog.title=매개변수 삭제를 전달할 메소드 선택
select.migration.map=마이그레이션 맵 선택\:
select.source.root.chooser.title=소스 루트 선택
selected.block.contains.invocation.of.another.class.constructor=선택한 블록에 다른 클래스 생성자의 호출이 포함되어 있습니다.
selected.block.contains.statement.outside.of.class=선택한 블록에는 클래스 외부 구문이 포함되어 있습니다.
selected.block.should.represent.an.expression=선택한 블록이 표현식을 나타내야 합니다.
selected.expression.cannot.be.a.constant.initializer=선택한 표현식은 상수 이니셜라이저가 될 수 없습니다.
selected.expression.has.void.type=선택한 표현식에 void 유형이 있습니다.
selected.expression.introduces.pattern.variable=선택한 표현식은 패턴 변수 ''{0}''(을)를 삽입합니다.
setter.method.found.for.the.field.0=필드 {0} 의 setter 메소드가 발견되었습니다. \n\
이 setter도 {1} 하시겠어요?
side.effects.detected.title=부작용 탐지됨
source.folder.0.has.package.prefix.1=소스 폴더 {0}에 패키지 접두사 ''{1}''이(가) 있습니다.\n\
패키지 ''{2}''을(를) 거기에 생성할 수 없습니다.
static.initializer.description=클래스 {0}의 정적 이니셜라이저
superclass.cannot.be.extracted.from.an.enum=상위 클래스는 열거형에서 추출할 수 없습니다.
synthetic.jsp.class.is.referenced.in.the.method=통합 jsp 클래스는 메소드에서 참조됩니다.
target.0.is.not.accessible.from.1={1}에서 대상 {0}에 액세스할 수 없습니다.
the.field.should.be.declared.in.a.class=해당 필드는 클래스에서 선언되어야 합니다.
there.are.going.to.be.multiple.destination.files.with.the.same.name=같은 이름의 여러 대상 파일이 존재할 것입니다.
there.are.multiple.exit.points.in.the.selected.code.fragment=선택한 코드 조각에 여러 종료점이 있습니다.
there.are.multiple.output.values.for.the.selected.code.fragment=선택한 코드 조각에 여러 출력 값이 있습니다.
there.are.no.variables.that.have.reference.type=참조 유형이 있는 변수가 없습니다.
there.are.unused.methods.that.override.methods.you.delete=삭제한 메소드를 재정의하는 사용되지 않는 메소드가 있습니다.
there.is.already.a.0.in.1={1}에 {0}이(가) 이미 있습니다.
there.is.already.a.0.it.will.conflict.with.an.introduced.parameter={0}이(가) 이미 있습니다. 삽입된 매개변수와 충돌하게 됩니다
there.is.already.a.0.it.will.conflict.with.the.renamed.1={0}이(가) 이미 있습니다. 이름 변경된 {1}와(과) 충돌하게 됩니다.
there.is.already.type.parameter.in.0.with.name.1={0}에 이미 이름이 {1} 유형 매개변수가 있습니다.
this.method=이 메소드
this.reference.only.and.keep.super.class=이 참조만 인라인화하고 상위 클래스 유지(&K)
this.reference.only.and.keep.the.class=이 참조만 인라인화하고 클래스 유지(&K)
this.reference.only.and.keep.the.field=이 항목만 인라인화하고 필드 유지(&K)
to.delete.with.usage.search=삭제(사용 위치 검색 사용)
turn.refs.to.super.command={0}의 사용 위치를 {1}(으)로 교체
turnRefsToSuper.change.usages.to={0}의 사용 위치를 다음으로 변경(&C)\:
turnRefsToSuper.use.superclass.in.instanceof=인스턴스에서 인터페이스/상위 클래스 사용(&U)
type.cook.command=일반화
type.cook.drop.obsolete.casts=사용되지 않는 형 변환 드롭(&D)
type.cook.elements.header=일반화할 범위
type.cook.generify.objects=객체 일반화(&O)
type.cook.leave.object.parameterized.types.raw=객체 매개변수화된 유형을 원시 상태로 두기(&L)
type.cook.perform.exhaustive.search=정밀 검색 수행(&E)
type.cook.preserve.raw.arrays=원시 및 배열 보존(&A)
type.cook.produce.wildcard.types=와일드카드 유형 생성(&W)
type.cook.ratio.generified={0,choice,-1\#계산되지 않음|0\#{0,number}/{1}}
type.cook.report=Items generified\: {0},casts removed\: {1}
type.migration.action.name=유형 마이그레이션
type.migration.choose.scope.title=시그니처 변경이 발생할 수 있는 범위 선택
type.migration.conflicts.found=발견된 마이그레이션 충돌
type.migration.exclude.action.text=제외(&E)
type.migration.include.action.text=포함(&I)
type.migration.label=다음으로 {0} "{1}" 마이그레이션
type.migration.migrate.button.text=마이그레이션(&M)
type.migration.no.conflicts.found=마이그레이션 충돌이 없습니다.
type.migration.no.scope.warning.message=범위가 선택되지 않았습니다.
type.migration.preview.warning.text=마이그레이션할 10개 이상의 루트를 찾았습니다. 미리 보시겠습니까?
type.migration.reasons.to.migrate=마이그레이션할 이유 발견
type.migration.rerun.button.text=유형 마이그레이션 다시 실행(&R)
type.migration.select.suggestion=마이그레이션할 이유를 발견하려면 루트를 선택합니다.
type.of.the.selected.expression.cannot.be.determined=선택한 표현식의 유형을 지정할 수 없습니다.
unable.to.start.type.migration=유형 마이그레이션을 시작할 수 없음
unknown.expression.type=알 수 없는 표현식 유형
unused.overriding.methods.title=사용되지 않는 재정의 메소드
usages.detected.title=사용 위치 탐지됨
use.interface.superclass.in.instanceof=인스턴스에서 인터페이스/상위 클래스 사용
use.interface.where.possible.title=가능하면 인터페이스 사용
use.super.references.prompt=이 단계에서 {0} 은(는) {1}의 사용 위치를 분석하여 \n\
가능한 곳에서 {2}의 사용 위치와 교체할 수 있습니다.\n\
계속하시겠어요?
use.variable.initializer.to.initialize.parameter=변수 및 이니셜라이저를 사용하여 매개변수 초기화(&I)
variable.0.is.changed.before.last.access=변수 ''{0}''이(가) ''{1}''에 마지막으로 액세스하기 전에 변경됩니다.
variable.does.not.have.an.initializer=변수 {0}에 이니셜라이저가 없습니다.
variable.is.accessed.for.writing=변수 ''{0}''은(는) 쓰기용으로 액세스됩니다.
variable.is.never.used.before.modification=변수 {0} 은(는) 수정 전에 전혀 사용되지 않습니다.
variable.of.type=유형의 변수(&T)\:
would.you.like.to.replace.default.constructor.of.0.with.factory.method={0}의 디폴트 생성자를 factory 메소드로 교체하시겠어요?
wrap.return.value.create.inner.class=내부 클래스 생성(&I)
wrap.return.value.create.new.class=새 클래스 생성(&C)
wrap.return.value.existing.class.name=이름
wrap.return.value.inner.class.name=이름(&M)
wrap.return.value.new.class.name=이름(&N)
wrap.return.value.new.class.package.name=패키지 이름(&P)
wrap.return.value.use.existing.class=기존 클래스 사용(&U)
wrap.return.value.wrapper.field=래퍼 필드(&F)

replace.inside.current.lambda=현재 람다 내부에 변수 생성
replace.as.separate.operation=''{0}'' 연산으로 추출
replace.all.read.and.write=읽기 및 쓰기 사용 위치 대체[(의미가 변경됩니다\!)
replace.all.and.extract={0}의 모든 사용 위치를 대체하고 ''{1}'' 연산으로 추출
replace.lambda.chain.detected=람다 체인 탐지됨
replace.occurrences.inside.statement={2, choice, 1\#|2\# 외부} ''{1}'' 블록의 {0} 사용 위치 대체
