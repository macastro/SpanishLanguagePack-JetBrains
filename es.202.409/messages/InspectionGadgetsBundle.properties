cast.to.concrete.class.display.name=구체 클래스로 형 변환
cast.to.concrete.class.problem.descriptor=구체 클래스 <code>{0}</code>(으)로 형 변환합니다. \#loc
class.references.subclass.display.name=클래스가 하위 클래스 중 하나를 참조
class.references.subclass.problem.descriptor=클래스 ''{0}''이(가) 하위 클래스 <code>\#ref</code>을(를) 참조합니다. \#loc
class.references.subclass.problem.descriptor.anonymous=익명 클래스가 하위 클래스 <code>\#ref</code>을(를) 참조합니다. \#loc
collection.declared.by.class.display.name=인터페이스가 아닌 클래스로 선언된 컬렉션
collection.declared.by.class.problem.descriptor=<code>\#ref</code>의 선언이 ''{0}''(으)로 약화될 것입니다. \#loc
collection.declared.by.class.ignore.locals.option=지역 변수 무시
collection.declared.by.class.ignore.private.members.option='private' 필드 및 메소드 무시
feature.envy.display.name=기능에 대한 욕심(Feature envy)
feature.envy.problem.descriptor=클래스 ''{0}''이(가) 메소드 <code>\#ref()</code>에서 반복적으로 액세스됩니다. \#loc
bounded.wildcard.display.name=바운드된 와일드카드 사용 가능
bounded.wildcard.contravariant.descriptor=<code>? super \#ref</code>(으)로 일반화할 수 있습니다. \#loc
bounded.wildcard.covariant.descriptor=<code>? extends \#ref</code>(으)로 일반화할 수 있습니다. \#loc
bounded.wildcard.report.invariant.option=불변 클래스 보고
bounded.wildcard.report.private.option=private 메소드 보고
bounded.wildcard.report.instance.option=인스턴스 메소드 보고
instance.variable.of.concrete.class.display.name=인스턴스 필드의 유형이 구체 클래스
instance.variable.of.concrete.class.problem.descriptor=필드 ''{0}''의 유형이 구체 클래스 <code>\#ref</code>입니다. \#loc
chain.of.instanceof.checks.display.name='instanceof' 검사 체인
chain.of.instanceof.checks.problem.descriptor='instanceof' 검사 체인은 추상화 실패를 표시합니다. \#loc
chain.of.class.equality.checks.problem.descriptor=클래스 상등 검사 체인은 추상화 실패를 표시합니다. \#loc
instanceof.concrete.class.display.name=구체 클래스에 대한 'instanceof'
instanceof.concrete.class.problem.descriptor=구체 클래스 <code>\#ref</code>에 대한 'instanceof' \#loc
instanceof.concrete.class.equality.problem.descriptor=구체 클래스 <code>\#ref</code>와(과) 클래스를 비교합니다. \#loc
instanceof.check.for.this.display.name='this'에 대한 'instanceof' 검사
instanceof.check.for.this.problem.descriptor=<code>\#ref</code>에 대한 'instanceof' 검사 \#loc
instanceof.check.for.this.equality.problem.descriptor='this'에 대한 클래스 비교 \#loc
local.variable.of.concrete.class.display.name=구체 클래스의 지역 변수
local.variable.of.concrete.class.problem.descriptor=구체 클래스 <code>\#ref</code>의 지역 변수 ''{0}'' \#loc
magic.number.display.name=매직 숫자
magic.number.problem.descriptor=매직 숫자 <code>\#ref</code> \#loc
method.return.concrete.class.display.name=구체 클래스의 메소드 반환
method.return.concrete.class.problem.descriptor=메소드가 구체 클래스 <code>\#ref</code>을(를) 반환합니다. \#loc
overly.strong.type.cast.display.name=지나치게 강한 유형 형 변환
overly.strong.type.cast.weaken.quickfix=지나치게 강한 형 변환을 약화합니다.
concrete.class.method.parameter.display.name=구체 클래스의 메소드 매개변수
concrete.class.method.parameter.problem.descriptor=구체 클래스 <code>\#ref</code>의 매개변수 ''{0}'' \#loc
public.method.not.in.interface.display.name=인터페이스에 노출되지 않는 'public' 메소드
public.method.not.in.interface.problem.descriptor='public' 메소드 <code>\#ref()</code>이(가) 인터페이스를 통해 노출되지 않습니다. \#loc
public.method.not.in.interface.option=<html>포함된 클래스가 비 라이브러리 인터페이스를 구현하지 않는 경우 무시</html>
static.variable.of.concrete.class.display.name=구체 클래스의 static 필드
static.variable.of.concrete.class.problem.descriptor=구체 클래스 <code>\#ref</code>의 static 필드 ''{0}'' \#loc
incompatible.mask.operation.display.name=호환되지 않는 비트 마스크 연산
incompatible.mask.operation.problem.descriptor.always.false=<code>\#ref</code>이(가) 항상 false입니다. \#loc
incompatible.mask.operation.problem.descriptor.always.true=<code>\#ref</code>이(가) 항상 true입니다. \#loc
pointless.bitwise.expression.display.name=무의미한 비트 표현식
pointless.bitwise.expression.simplify.quickfix=단순화
shift.operation.by.inappropriate.constant.display.name=부적절한 상수에 의한 시프트 연산
shift.operation.by.inappropriate.constant.problem.descriptor.too.large=지나치게 큰 상수값에 의한 시프트 연산 <code>\#ref</code> {0} \#loc
shift.operation.by.inappropriate.constant.problem.descriptor.negative=음수값에 의한 시프트 연산 <code>\#ref</code> {0} \#loc
shift.operation.by.inappropriate.constant.problem.descriptor.out.of.bounds=아웃바운드 값에 의한 시프트 연산 <code>\#ref</code> {0} \#loc
equals.called.on.array.display.name=배열에서 'equals()' 호출
equals.called.on.array.problem.descriptor=배열 사이의 <code>\#ref()</code>은(는) 'Arrays.equals()'여야 할 것입니다. \#loc
assignment.to.null.display.name='null' 대입
assignment.to.null.problem.descriptor='null'이 변수 <code>\#ref</code>에 대입되었습니다. \#loc
assignment.to.null.option=필드에 대한 대입 무시
assignment.to.static.field.from.instance.method.display.name=인스턴스 컨텍스트의 static 필드에 대입
assignment.to.static.field.from.instance.method.problem.descriptor=인스턴스 컨텍스트의 static 필드 <code>\#ref</code>에 대입합니다. \#loc
assignment.used.as.condition.display.name=조건으로 사용된 대입
assignment.used.as.condition.problem.descriptor=<code>\#ref</code> 대입이 조건으로 사용되었습니다. \#loc 사용
cast.conflicts.with.instanceof.display.name='instanceof'와의 충돌 형 변환
cast.conflicts.with.instanceof.problem.descriptor=형 변환 <code>\#ref</code>이(가) 주변 'instanceof' 검사와 충돌합니다. \#loc
casting.to.incompatible.interface.display.name=호환되지 않는 인터페이스로 형 변환
casting.to.incompatible.interface.problem.descriptor=호환되지 않는 인터페이스 <code>\#ref</code>(으)로 형 변환합니다. \#loc
collection.added.to.self.display.name=컬렉션이 컬렉션 자신에게 추가됨
collection.added.to.self.problem.descriptor=''{0}()''이(가) 자신을 인수로 가진 컬렉션 <code>\#ref</code>에서 호출됩니다. \#loc
non.final.field.compareto.display.name=최종이 아닌 필드가 'compareTo()'에서 참조됨
non.final.field.compareto.problem.descriptor=비 final 필드 <code>\#ref</code>이(가) 'compareTo()'에서 액세스되었습니다. \#loc
covariant.equals.display.name=공분산 'equals()'
covariant.equals.problem.descriptor=<code>\#ref()</code>이(가) 'Object'를 인수로 취해야 합니다. \#loc
empty.class.initializer.display.name=빈 클래스 이니셜라이저
empty.class.initializer.problem.descriptor=빈 클래스 이니셜라이저 \#loc
empty.class.initializer.delete.quickfix=빈 클래스 이니셜라이저 삭제
statement.with.empty.body.display.name=본문이 비어 있는 구문
statement.with.empty.body.problem.descriptor=<code>\#ref</code> 문에 본문이 비어 있습니다. \#loc
statement.with.empty.body.include.option=빈 코드 블록인 구문 본문 포함
equals.between.inconvertible.types.display.name=변환할 수 없는 유형의 객체 간의 'equals()'
equals.between.inconvertible.types.problem.descriptor=<code>\#ref</code>이(가) 변환할 수 없는 유형인 ''{0}'' 및 ''{1}''의 객체 사이에 있습니다. \#loc
equals.between.inconvertible.types.no.mutual.subclass.problem.descriptor=''{0}'' 및 ''{1}''의 공통 하위 유형인 클래스를 찾을 수 없습니다. \#loc
equals.between.inconvertible.types.mutual.subclass.option=상호 하위 클래스가 발견되지 않으면 경고
equals.called.on.suspicious.object.display.name=StringBuilder에서 'equals()' 호출
equals.called.on.suspicious.object.problem.descriptor=''{0}'' 객체에서의 의심스러운 호출 ''equals''
non.final.field.in.equals.display.name=최종이 아닌 필드가 'equals()'에서 참조됨
non.final.field.in.equals.problem.descriptor=비 final 필드 <code>\#ref</code>이(가) 'equals()'에서 액세스되었습니다. \#loc
equals.doesnt.check.class.parameter.display.name=매개변수의 클래스를 검사하지 않는 'equals()' 메소드
equals.doesnt.check.class.parameter.problem.descriptor=<code>\#ref()</code>은(는) 자체 매개변수를 검사해야 합니다. \#loc
non.final.field.in.hashcode.display.name=최종이 아닌 필드가 'hashCode()'에서 참조됨
non.final.field.in.hashcode.problem.descriptor=비 final 필드 <code>\#ref</code>이(가) 'hashCode()'에서 액세스되었습니다. \#loc
result.of.method.call.ignored.display.name=메소드 호출의 결과가 무시됨
result.of.method.call.ignored.problem.descriptor=<code>{0}.\#ref()</code>의 결과가 무시되었습니다. \#loc
result.of.method.call.ignored.class.column.title=클래스 이름
result.of.method.call.ignored.method.column.title=메소드 이름 정규식
result.of.method.call.ignored.non.library.option=무시된 모든 비 라이브러리 호출 보고
infinite.recursion.display.name=무한 재귀
infinite.recursion.problem.descriptor=메소드 <code>\#ref()</code>이(가) 무한 반복되며 예외를 던져야 종료됩니다. \#loc
instanceof.with.incompatible.interface.display.name=호환되지 않는 인터페이스가 있는 'instanceof'
instanceof.with.incompatible.interface.problem.descriptor=호환되지 않는 인터페이스 <code>\#ref</code>에 대한 'instanceof' \#loc
instantiation.utility.class.display.name=유틸리티 클래스의 인스턴스화
instantiation.utility.class.problem.descriptor=유틸리티 클래스 <code>\#ref</code>의 인스턴스화 \#loc
iterator.hasnext.which.calls.next.display.name='next()'를 호출하는 'Iterator.hasNext()'
iterator.hasnext.which.calls.next.problem.descriptor=<code>Iterator.{0}()</code>에 ''\#ref()'' 호출이 포함되어 있습니다. \#loc
iterator.next.does.not.throw.nosuchelementexception.display.name='NosuchElementException'을 던질 수 없는 'Iterator.next()'
malformed.format.string.display.name=형식이 잘못된 서식 문자열
malformed.format.string.problem.descriptor.malformed=서식 문자열 <code>\#ref</code>의 서식이 올바르지 않습니다. \#loc
malformed.format.string.problem.descriptor.illegal=잘못된 서식 문자열 지정자\: {0} \#loc
malformed.format.string.problem.descriptor.too.many.arguments=서식 문자열에 대한 인수가 너무 많습니다(발견된 개수\: {0}개, 기대된 개수\: {1}개) \#loc
malformed.format.string.problem.descriptor.too.few.arguments=서식 문자열에 대한 인수가 너무 적습니다(발견된 개수\: {0}개, 기대된 개수\: {1}개) \#loc
malformed.format.string.problem.descriptor.arguments.do.not.match.type=인수 유형 ''{0}'' 서식 지정자 ''{1}''의 유형과 일치하지 않습니다. \#loc
format.string.error.flags.not.allowed=''{1}''에서 {2, choice, 1\#플래그|1<플래그} ''{0}'' 이(가) 허용되지 않습니다
format.string.error.unexpected.flag=\ ''{1}''의 예기치 않은 문자 ''{0}''
format.string.error.duplicate.flag=\ ''{1}''의 중복 플래그 ''{0}''
format.string.error.width.not.allowed=''{1}''에서 너비(''{0}'')가 허용되지 않음
format.string.error.precision.not.allowed=''{1}''에서 정밀도(''{0}'')가 허용되지 않음
format.string.error.unnecessary.position.specifier=''{1}''의 불필요한 인수 위치 지정자 ''{0}''
format.string.error.illegal.position.specifier=''{1}''의 잘못된 위치 지정자 ''{0}''
format.string.error.previous.element.not.found=기존 플래그 ''<''가 사용되지만 ''{0}''에 대한 기존 형식 지정자는 찾을 수 없음
format.string.error.unknown.conversion=''{0}''의 알 수 없는 변환
format.string.error.invalid.precision=''{0}''에 지정된 유효하지 않은 정밀도
format.string.error.illegal.flag.combination=''{2}''에서 ''{0}'' 및 ''{1}''으로 잘못된 플래그 조합
format.string.error.left.justify.no.width=좌측 정렬 플래그 ''-''가 사용되지만 너비가 ''{0}''에서 지정되지 않음
format.string.error.zero.padding.no.width=제로 패딩 플래그 ''0''이 사용되지만 너비가 ''{0}''에서 지정되지 않음
mismatched.read.write.array.display.name=배열의 일치하지 않는 읽기 및 쓰기
mismatched.read.write.array.problem.descriptor.write.not.read=배열 <code>\#ref</code>의 내용은 쓰기는 되지만 읽기는 되지 않습니다. \#loc
mismatched.read.write.array.problem.descriptor.read.not.write=배열 <code>\#ref</code>의 내용은 읽기는 되지만 쓰기는 되지 않습니다. \#loc
mismatched.update.collection.display.name=컬렉션의 쿼리 및 업데이트 불일치
mismatched.update.collection.problem.descriptor.updated.not.queried=컬렉션 <code>\#ref</code>의 내용은 업데이트되지만 쿼리되지 않습니다. \#loc
mismatched.update.collection.problem.description.queried.not.updated=컬렉션 <code>\#ref</code>의 내용은 쿼리되지만 업데이트되지 않습니다. \#loc
rename.quickfix=이름 바꾸기
renameto.quickfix=''{0}''로 이름 바꾸기
misspelled.equals.display.name='equals()' 대신 'equal()'
misspelled.equals.problem.descriptor=<code>\#ref()</code> 메소드는 'equals()'여야 할 것입니다. \#loc
non.short.circuit.boolean.expression.display.name=비단락 회로 부울 표현식
non.short.circuit.boolean.expression.problem.descriptor=비단락 회로 부울 표현식 <code>\#ref</code> \#loc
non.short.circuit.boolean.expression.replace.quickfix=단락 표현식으로 대체합니다.
null.argument.to.var.arg.method.display.name=vararg 메소드에 대한 인수 혼동
null.argument.to.var.arg.method.problem.descriptor=인수 <code>\#ref</code>이(가) 혼동됩니다. vararg 호출이 기대되는지, 비 vararg 호출이 기대되는지 명확하지 않습니다. \#loc
primitive.array.argument.to.var.arg.method.display.name=vararg 메소드에 대한 기본 배열 인수가 혼동됩니다.
primitive.array.argument.to.var.arg.method.problem.descriptor=vararg 메소드에 대한 기본 배열 인수가 혼동됩니다.
object.comparison.display.name='equals()' 대신 '\=\='를 사용하여 객체 비교
object.comparison.enumerated.ignore.option=열거형 변수 간 '\=\=' 무시
object.comparison.klass.ignore.option='equals()' 구현이 없는 final 클래스 유형 간 '\=\=' 무시
object.comparison.problem.description=객체 값을 'equals()'가 아닌 <code>\#ref</code>을(를) 사용하여 비교합니다. \#loc
equality.to.safe.equals.quickfix='\=\='를 null 안전 'equals()'로 대체합니다.
inequality.to.safe.not.equals.quickfix='\!\='를 null 안전 '\!equals()'로 대체합니다.
default.tostring.call.display.name=디폴트 값 'toString()' 호출
default.tostring.call.problem.descriptor=<code>\#ref</code>의 디폴트 값 'toString()' 호출 \#loc
octal.and.decimal.integers.in.same.array.display.name=동일한 배열의 8진 및 10진 정수
octal.and.decimal.integers.in.same.array.problem.descriptor=동일한 배열 이니셜라이저의 8진 및 10진 정수 \#loc
result.of.object.allocation.ignored.display.name=객체 대입의 결과가 무시됨
result.of.object.allocation.ignored.problem.descriptor=<code>new \#ref()</code>의 결과가 무시되었습니다. \#loc
use.0index.in.jdbc.resultset.display.name=JDBC ResultSet의 색인 0 사용
use.0index.in.jdbc.resultset.problem.descriptor=JDBC ResultSet의 색인 '0' 사용 \#loc
use.0index.in.jdbc.prepared.statement.problem.descriptor=JDBC PreparedStatement의 색인 '0' 사용 \#loc
return.of.null.display.name='null' 반환
return.of.null.problem.descriptor=<code>\#ref</code> 반환 \#loc
return.of.null.arrays.option=배열을 반환하는 메소드 보고
return.of.null.quickfix=@Nullable로 메소드에 어노테이션을 추가합니다.
return.of.null.objects.option=객체를 반환하는 메소드 보고
return.of.null.collections.option=컬렉션 객체를 반환하는 메소드 보고
return.of.null.ignore.private.option='private' 메소드, 익명 클래스, 람다 무시
static.method.via.subclass.display.name=static 메소드가 하위 클래스를 통해 참조됨
static.method.via.subclass.problem.descriptor=static 메소드 <code>\#ref()</code>이(가) 클래스 ''{0}''에서 선언되었지만 하위 클래스 ''{1}''을(를) 통해 참조되었습니다 \#loc
static.method.via.subclass.rationalize.quickfix=static 메소드 호출 합리화
static.field.via.subclass.display.name=static 필드가 하위 클래스를 통해 참조됨
static.field.via.subclass.problem.descriptor=static 필드 <code>\#ref</code>이(가) 클래스 ''{0}''에서 선언되었지만 하위 클래스 ''{1}''을(를) 통해 참조되었습니다 \#loc
static.field.via.subclass.rationalize.quickfix=static 필드 액세스를 합리화합니다.
string.comparison.display.name='equals()' 대신 '\=\='를 사용하여 문자열 비교
number.comparison.display.name='equals()' 대신 '\=\='를 사용하여 숫자 비교
string.comparison.problem.descriptor=문자열 값을 'equals()'가 아닌 <code>\#ref</code>을(를) 사용하여 비교합니다. \#loc
number.comparison.problem.descriptor=숫자 객체를 'equals()'가 아닌 <code>\#ref</code>을(를) 사용하여 비교합니다. \#loc
subtraction.in.compareto.display.name='compareTo()'의 뺄셈
subtraction.in.compareto.problem.descriptor='compareTo()'의 뺄셈 <code>\#ref</code>이(가) 오버플로 또는 정확성 손실을 낳을 수 있습니다. \#loc
text.label.in.switch.statement.display.name='switch' 문의 텍스트 라벨
text.label.in.switch.statement.problem.descriptor='switch' {0, choice, 1\#문|2\#식}의 텍스트 라벨 <code>\#ref\:</code> \#loc
properties.object.as.hashtable.display.name=프로퍼티 객체를 해시테이블로 사용
properties.object.as.hashtable.problem.descriptor=프로퍼티 객체에서 <code>Hashtable.\#ref()</code>이(가) 호출됩니다. \#loc
assignment.replaceable.with.operator.assignment.display.name=연산자 대입으로 대체 가능한 대입
unnecessary.code.block.display.name=불필요한 코드 블록
unnecessary.code.block.unwrap.quickfix=블록 줄 바꿈을 해제합니다.
redundant.local.variable.display.name=중복 지역 변수
redundant.local.variable.ignore.option=즉시 반환되거나 던져진 변수 무시
redundant.local.variable.annotation.option=어노테이션이 있는 변수 무시
static.collection.display.name=static 컬렉션
static.collection.problem.descriptor=static 컬렉션 <code>\#ref</code> \#loc
static.collection.ignore.option=약한 static 컬렉션 또는 맵 무시
stringbuffer.field.display.name=StringBuilder 필드
stringbuffer.field.problem.descriptor=''{0}'' 필드 <code>\#ref</code> \#loc
gc.call.display.name='System.gc()' 또는 'Runtime.gc()' 호출
gc.call.problem.descriptor=<code>\#ref</code>을(를) 프로덕션 코드에서 호출하면 안 됩니다. \#loc
array.allocation.zero.length.display.name=제로 길이 배열 대입
array.allocation.zero.length.problem.descriptor=제로 길이 배열 대입 \#loc
constant.for.zero.length.array.display.name=불필요한 제로 길이 배열 사용
constant.for.zero.length.array.problem.descriptor=제로 길이 배열은 상수로 변경할 수 있습니다. \#loc
constant.for.zero.length.array.quickfix.family=상수로 대체
multiple.loggers.display.name=여러 로거가 있는 클래스
logger.name.option=로거 클래스 이름(&C)\:
multiple.loggers.problem.descriptor=클래스 <code>\#ref</code>이(가) 여러 로거를 선언합니다. \#loc
no.logger.display.name=로거가 없는 클래스
no.logger.problem.descriptor=클래스 <code>\#ref</code>이(가) 로거를 선언하지 않습니다. \#loc
non.constant.logger.display.name=비상수 로거
non.constant.logger.problem.descriptor=비상수 로거 필드 <code>\#ref</code> \#loc
public.method.without.logging.display.name=로깅 없는 'public' 메소드
public.method.without.logging.problem.descriptor='public' 메소드 <code>\#ref()</code>에 로깅 호출이 없습니다. \#loc
ignore.trivial.finalizers.option=자명한 'finalize()' 구현 무시
finalize.declaration.display.name='finalize()' 선언
finalize.declaration.problem.descriptor=<code>\#ref()</code>이(가) 선언되었습니다. \#loc
finalize.not.declared.protected.display.name='finalize()'가 'protected'로 선언되지 않음
finalize.not.declared.protected.problem.descriptor=<code>\#ref()</code>이(가) 'protected'로 선언되지 않았습니다. \#loc
finalize.called.explicitly.display.name=명시적으로 'finalize()' 호출
finalize.called.explicitly.problem.descriptor=<code>\#ref()</code>이(가) 명시적으로 호출됩니다. \#loc
java.lang.import.display.name='java.lang' import 문
java.lang.import.problem.descriptor=패키지 'java.lang'의 불필요한 import 문 \#loc
import.display.name='*' 가져오기
import.problem.descriptor=패키지 import 문 <code>\#ref</code> \#loc
redundant.import.display.name=중복 import 문
redundant.import.problem.descriptor=중복 import 문 <code>\#ref</code> \#loc
import.from.same.package.display.name=동일한 패키지의 import 문
import.from.same.package.problem.descriptor=동일한 패키지 <code>\#ref</code>의 불필요한 import 문 \#loc
single.class.import.display.name=단일 클래스 import 문
single.class.import.problem.descriptor=단일 클래스 import 문 <code>\#ref</code> \#loc
static.import.display.name=static import 문
static.import.problem.descriptor=static import 문 <code>\#ref</code> \#loc
static.import.replace.quickfix=비 static import 문으로 대체합니다.
unused.import.problem.descriptor=사용되지 않는 import 문 <code>\#ref</code> \#loc
clone.instantiates.objects.with.constructor.display.name='clone()'이 생성자로 객체 인스턴스화
clone.instantiates.objects.with.constructor.problem.descriptor='clone()'이 새 <code>\#ref</code> 인스턴스를 생성합니다. \#loc
clone.instantiates.new.array.problem.descriptor=''clone()''이 새 {0} 배열을 생성합니다. \#loc
clone.doesnt.declare.clonenotsupportedexception.display.name='clone()'이 'CloneNotSupportedException'을 선언하지 않음
clone.doesnt.declare.clonenotsupportedexception.problem.descriptor=<code>\#ref()</code>에서 'CloneNotSupportedException'을 선언하지 않습니다. \#loc
clone.doesnt.declare.clonenotsupportedexception.declare.quickfix=throw 절에 'CloneNotSupportedException'을 추가합니다.
clone.method.in.non.cloneable.class.display.name=복제할 수 없는 클래스의 'clone()' 메소드
clone.method.in.non.cloneable.class.problem.descriptor=<code>\#ref()</code>이(가) 비 cloneable 클래스 ''{0}''에 정의되었습니다. \#loc
clone.method.in.non.cloneable.anonymous.class.problem.descriptor=<code>\#ref()</code>이(가) ''{0}''에서 파생된 비 cloneable 익명 클래스에 정의되었습니다. \#loc
clone.method.in.non.cloneable.interface.problem.descriptor=<code>\#ref()</code>이(가) 비 cloneable 인터페이스 ''{0}''에 정의되었습니다. \#loc
cloneable.class.without.clone.display.name='clone()' 메소드가 없는 cloneable 클래스
cloneable.class.without.clone.problem.descriptor=<code>\#ref</code>이(가) 'clone()'을 정의하지 않습니다. \#loc
cloneable.class.without.clone.ignore.option=상속으로 인해 cloneable 클래스 무시
cloneable.class.without.clone.quickfix='clone()' 메소드를 생성합니다.
class.without.tostring.display.name='toString()'이 없는 클래스()
class.without.tostring.problem.descriptor=클래스 <code>\#ref</code>이(가) 디버그 목적으로 'toString()'을 구현해야 할 것입니다. \#loc
use.obsolete.collection.type.display.name=더 이상 사용되지 않는 컬렉션 유형 사용
use.obsolete.collection.type.problem.descriptor=더 이상 사용되지 않는 컬렉션 유형 <code>\#ref</code>이(가) 사용되었습니다. \#loc
use.obsolete.collection.type.ignore.library.arguments.option=필요한 경우 더 이상 사용되지 않는 컬렉션 유형 무시
inspection.suppression.annotation.display.name=검사 숨기기 어노테이션
inspection.suppression.annotation.problem.descriptor=검사 억제 어노테이션 <code>\#ref</code> \#loc
use.system.out.err.display.name=System.out 또는 System.err 사용
use.system.out.err.problem.descriptor=<code>\#ref</code>의 사용을 더 강력한 로깅으로 대체해야 할 것입니다. \#loc
dumpstack.call.display.name='Thread.dumpStack()' 호출
dumpstack.call.problem.descriptor=<code>Thread.\#ref()</code>의 호출을 더 강력한 로깅으로 대체해야 할 것입니다. \#loc
printstacktrace.call.display.name='printStackTrace()' 호출
printstacktrace.call.problem.descriptor=<code>\#ref()</code>의 호출을 더 강력한 로깅으로 대체해야 할 것입니다. \#loc
abstract.method.call.in.constructor.display.name=객체 생성 중에 추상 메소드 호출
abstract.method.call.in.constructor.problem.descriptor='abstract' 메소드 <code>\#ref()</code>을(를) 객체 생성 중에 호출합니다. \#loc
instance.variable.may.not.be.initialized.display.name=인스턴스 필드가 초기화되지 않을 수 있음
instance.variable.may.not.be.initialized.problem.descriptor=인스턴스 필드 <code>\#ref</code>은(는) 객체 생성 중에 초기화할 수 없습니다. \#loc
instance.Variable.may.not.be.initialized.problem.descriptor.junit=인스턴스 필드 <code>\#ref</code>은(는) 객체 생성이나 'setUp()' 호출 중에 초기화할 수 없습니다. \#loc
primitive.fields.ignore.option=기본 필드 무시
instance.variable.used.before.initialized.display.name=초기화 전에 사용된 인스턴스 필드
instance.variable.used.before.initialized.problem.descriptor=인스턴스 필드 <code>\#ref</code>이(가) 초기화 전에 사용되었습니다. \#loc
non.final.static.variable.initialization.display.name=클래스 초기화 중에 비 final static 필드가 사용됨
non.final.static.variable.initialization.problem.descriptor=비 final static 필드 <code>\#ref</code>이(가) 클래스 초기화 중에 사용되었습니다. \#loc
overridable.method.call.in.constructor.display.name=객체 생성 중에 재정의 가능한 메소드 호출
overridable.method.call.in.constructor.problem.descriptor=재정의 가능한 메소드 <code>\#ref()</code>을(를) 객체 생성 중에 호출합니다. \#loc
overridden.method.call.in.constructor.display.name=객체 생성 중에 재정의된 메소드 호출
overridden.method.call.in.constructor.problem.descriptor=재정의된 메소드 <code>\#ref()</code>을(를) 객체 생성 중에 호출합니다. \#loc
static.variable.may.not.be.initialized.display.name=static 필드가 초기화되지 않을 수 있음
static.variable.may.not.be.initialized.problem.descriptor=static 필드 <code>\#ref</code>은(는) 클래스 초기화 중에 초기화할 수 없습니다. \#loc
static.variable.used.before.initialization.display.name=초기화 전에 사용된 static 필드
static.variable.used.before.initialization.problem.descriptor=static 필드 <code>\#ref</code>이(가) 초기화 전에 사용되었습니다. \#loc
this.reference.escaped.in.construction.display.name=객체 생성에서 'this' 참조 이스케이프
this.reference.escaped.in.construction.problem.descriptor=<code>\#ref</code>이(가) 객체 생성 중에 이스케이프되었습니다. \#loc
assignment.to.catch.block.parameter.display.name=catch 블록 매개변수에 대입
extract.parameter.as.local.variable.quickfix=매개변수를 지역 변수로 추출합니다.
assignment.to.for.loop.parameter.display.name='for' 루프 매개변수에 대입
assignment.to.for.loop.parameter.check.foreach.option=향상된 'for' 루프 매개변수 검사
assignment.to.for.loop.parameter.problem.descriptor=for 루프 매개변수 <code>\#ref</code>에 대입되었습니다. \#loc
assignment.to.method.parameter.display.name=메소드 매개변수에 대입
chained.equality.comparisons.display.name=체인 상등 비교
confusing.octal.escape.sequence.display.name=혼동되는 8진 이스케이프 시퀀스
increment.decrement.display.name=++ 또는 -- 값 사용
nested.assignment.display.name=대입 결과 사용
nested.assignment.problem.descriptor=대입 표현식의 결과가 사용되었습니다. \#loc
overloaded.methods.with.same.number.parameters.display.name=매개변수 수가 동일한 오버로드된 메소드
overloaded.vararg.method.display.name=오버로드된 vararg 메소드
refused.bequest.display.name=메소드가 상위 메소드를 호출하지 않음
reuse.of.local.variable.display.name=지역 변수 재사용
reuse.of.local.variable.split.quickfix=지역 변수를 분할합니다.
character.comparison.display.name=문자 비교
character.comparison.problem.descriptor=국제화된 컨텍스트의 문자 비교 <code>\#ref</code> \#loc
package.visible.field.display.name=패키지 표시 필드
package.visible.field.problem.descriptor=패키지 표시 필드 <code>\#ref</code> \#loc
package.visible.inner.class.display.name=패키지 표시 중첩 클래스
package.visible.inner.class.problem.descriptor=패키지 표시 중첩 클래스 <code>\#ref</code> \#loc
package.visible.inner.class.ignore.enum.option=패키지 표시 내부 열거형 무시
package.visible.inner.class.ignore.interface.option=패키지 표시 내부 인터페이스 무시
protected.field.display.name=protected 필드
protected.field.problem.descriptor=protected 필드 <code>\#ref</code> \#loc
protected.inner.class.display.name=protected 중첩 필드
protected.inner.class.problem.descriptor=protected 중첩 필드 <code>\#ref</code> \#loc
protected.inner.class.ignore.enum.option='protected' 내부 열거형 무시
protected.inner.class.ignore.interface.option='protected' 내부 인터페이스 무시
public.field.display.name='public' 필드
public.field.problem.descriptor='public' 필드 <code>\#ref</code> \#loc
public.field.ignore.enum.type.fields.option=열거형의 'public final' 필드 무시
public.inner.class.display.name='public' 중첩 클래스
public.inner.class.problem.descriptor='public' 중첩 클래스 <code>\#ref</code> \#loc
public.inner.class.ignore.enum.option='public' 내부 열거형 무시
public.inner.class.ignore.interface.option='public' 내부 인터페이스 무시
accessing.non.public.field.of.another.object.display.name=다른 객체의 비 public 필드에 액세스
accessing.non.public.field.of.another.object.problem.descriptor=다른 객체에 있는 비 public 필드 <code>\#ref</code>에 바로 액세스 \#loc
call.to.date.tostring.display.name='Date.toString()' 호출
call.to.date.tostring.problem.descriptor=<code>Date.\#ref()</code>이(가) 국제화된 컨텍스트에서 사용되었습니다. \#loc
magic.character.display.name=매직 문자
magic.character.problem.descriptor=국제화된 컨텍스트의 매직 문자 <code>\#ref</code> \#loc
call.to.numeric.tostring.display.name=숫자 'toString()' 호출
call.to.numeric.tostring.problem.descriptor=숫자 <code>\#ref()</code>이(가) 국제화된 컨텍스트에서 호출됩니다. \#loc
instantiating.simpledateformat.without.locale.display.name=로케일 없이 SimpleDateFormat 인스턴스화
instantiating.simpledateformat.without.locale.problem.descriptor=국제화된 컨텍스트에서 로케일을 지정하지 않은 상태로 <code>\#ref</code>을(를) 초기화합니다. \#loc
string.concatenation.display.name=문자열 연결
string.concatenation.problem.descriptor=국제화된 컨텍스트의 문자열 연결 <code>\#ref</code> \#loc
inspection.option.ignore.system.out='System.out.print' 인수 무시
inspection.option.ignore.system.err='System.err.print' 인수 무시
inspection.option.ignore.assert=어설션 문 설명 인수 무시
inspection.option.ignore.exceptions=Throwable 하위 클래스의 생성자 인수 무시
inspection.option.ignore.nonnls=@NonNls로 어노테이션이 추가된 경우 무시
inspection.option.ignore.constant.initializers=상수 필드의 이니셜라이저 무시
inspection.option.ignore.in.annotations=어노테이션에서 무시
inspection.option.ignore.in.tostring=toString() 메소두 내부 무시
inspection.option.ignore.as.initial.capacity=StringBuilders 및 Collections의 초기 용량 무시
inspection.option.ignore.in.hashcode='hashCode()' 메소드에서 상수 무시
string.touppercase.tolowercase.without.locale.display.name=로케일 없이 'String.toUpperCase()' 또는 'toLowerCase()' 호출
string.touppercase.tolowercase.without.locale.problem.descriptor=국제화된 문자열을 사용하는 로케일을 지정하지 않은 상태에서 <code>String.\#ref()</code>이(가) 호출됩니다. \#loc
use.stringtokenizer.display.name=StringTokenizer 사용
use.stringtokenizer.problem.descriptor=국제화된 컨텍스트의 <code>\#ref</code> \#loc
time.tostring.call.display.name='Time.toString()' 호출
time.tostring.call.problem.descriptor=국제화된 컨텍스트의 <code>Time.\#ref()</code> \#loc
class.escapes.defined.scope.display.name=액세스할 수 없는 클래스가 노출됨
class.escapes.defined.scope.display.module.option=모듈의 API가 내보내지 않은 클래스를 노출(Java 9+)
class.escapes.defined.scope.display.public.option=공용 API가 액세스할 수 없는 클래스를 노출
class.escapes.defined.scope.display.package.option=패키지 로컬 API가 private 클래스를 노출
class.escapes.defined.scope.problem.descriptor=클래스 <code>\#ref</code>이(가) 정의된 범위 외부에 노출됩니다. \#loc
class.escapes.defined.scope.java9.modules.descriptor=클래스 <code>\#ref</code>이(가) 모듈 ''{0}''에서 노출되지 않습니다. \#loc
field.name.hides.in.superclass.display.name=필드 이름이 상위 클래스의 필드를 숨깁니다.
field.name.hides.in.superclass.problem.descriptor=필드 <code>\#ref</code>이(가) 상위 클래스를 숨깁니다. \#loc
field.name.hides.in.superclass.ignore.option=액세스할 수 없는 필드 무시
field.name.hides.in.superclass.ignore.static.field.option=static 필드를 숨기는 static 필드 무시
inner.class.field.hides.outer.display.name=내부 클래스 필드가 외부 클래스 필드를 숨김
inner.class.field.hides.outer.ignore.option=내부 클래스에서 표시되지 않는 외부 필드 무시
inner.class.field.hides.outer.problem.descriptor=내부 클래스 필드 <code>\#ref</code>이(가) 외부 클래스 필드를 숨깁니다. \#loc
local.variable.hides.member.variable.display.name=지역 변수가 필드를 숨김
local.variable.hides.member.variable.problem.descriptor=지역 변수 <code>\#ref</code>이(가) 클래스 ''{0}''의 필드를 숨깁니다. \#loc
local.variable.hides.member.variable.ignore.option=비 static 필드를 숨기는 static 컨텍스트의 지역 변수 무시
method.overloads.display.name=메소드가 상위 클래스의 메소드를 오버로드
method.overloads.problem.descriptor=재정의가 의도된 경우 메소드 <code>\#ref()</code>이(가) 상위 클래스의 호환되는 메소드를 오버로드합니다. \#loc
method.overloads.report.incompatible.option=매개변수 유형이 호환되지 않는 경우에도 보고
method.overrides.private.display.name.problem.descriptor=메소드 <code>\#ref()</code>이(가) 상위 클래스의 'private' 메소드를 재정의합니다. \#loc
method.overrides.static.display.name=메소드가 상위 클래스의 static 메소드를 재정의하려고 함
method.overrides.static.problem.descriptor=메소드 <code>\#ref()</code>이(가) 상위 클래스의 static 메소드를 재정의하려고 합니다. \#loc
parameter.hides.member.variable.display.name=매개변수가 필드를 숨김
parameter.hides.member.variable.problem.descriptor=매개변수 <code>\#ref</code>이(가) 클래스 ''{0}''의 필드를 숨깁니다. \#loc
parameter.hides.member.variable.ignore.setters.option=프로퍼티 setter 무시
parameter.hides.member.variable.ignore.superclass.option=하위 클래스에서 표시되지 않는 상위 클래스 필드 무시
parameter.hides.member.variable.ignore.constructors.option=생성자 무시
parameter.hides.member.variable.ignore.abstract.methods.option=추상 메소드 무시
parameter.hides.member.variable.ignore.static.parameters.option=인스턴스 필드를 숨기는 static 메소드 매개변수 무시
type.parameter.hides.visible.type.display.name=유형 매개변수가 표시되는 유형을 숨김
type.parameter.hides.visible.type.problem.descriptor=유형 매개변수 <code>\#ref</code>이(가) 표시되는 유형 ''{0}''을(를) 숨깁니다. \#loc
type.parameter.hides.type.parameter.problem.descriptor=유형 매개변수 <code>\#ref</code>이(가) 유형 매개변수 ''{0}''을(를) 숨깁니다. \#loc
anonymous.class.variable.hides.containing.method.variable.display.name=익명의 클래스 변수가 메소드 포함 시 변수를 숨김
anonymous.class.parameter.hides.containing.method.variable.problem.descriptor=익명의 클래스 매개변수 <code>\#ref</code>이(가) 메소드 포함 시 변수를 숨깁니다. \#loc
anonymous.class.field.hides.containing.method.variable.problem.descriptor=익명의 클래스 필드 <code>\#ref</code>이(가) 메소드 포함 시 변수를 숨깁니다. \#loc
anonymous.class.variable.hides.containing.method.variable.problem.descriptor=익명의 클래스 지역 변수 <code>\#ref</code>이(가) 메소드 포함 시 변수를 숨깁니다. \#loc
channel.opened.not.closed.display.name=채널이 열렸으나 안전하게 닫히지 않음
drivermanager.call.display.name=JDBC 연결을 얻기 위해 DriverManager 사용
drivermanager.call.problem.descriptor=<code>DriverManager.\#ref()</code> 호출 \#loc
hibernate.resource.opened.not.closed.display.name=Hibernate 리소스가 열렸으나 안전하게 닫히지 않음
i.o.resource.opened.not.closed.display.name=I/O 리소스가 열렸으나 안전하게 닫히지 않음
resource.opened.not.closed.problem.descriptor=''{0}''은(는) ''try'' 블록 앞에서 열고 해당하는 ''finally'' 블록에서 닫아야 합니다. \#loc
jdbc.resource.opened.not.closed.display.name=JDBC 리소스가 열렸으나 안전하게 닫히지 않음
jndi.resource.opened.not.closed.display.name=JNDI 리소스가 열렸으나 안전하게 닫히지 않음
socket.opened.not.closed.display.name=소켓이 열렸으나 안전하게 닫히지 않음
annotation.class.display.name=어노테이션 클래스
annotation.class.problem.descriptor=어노테이션 클래스 <code>\#ref</code> \#loc
annotation.display.name=어노테이션
annotation.problem.descriptor=어노테이션 <code>\#ref</code> \#loc
use.assert.as.identifier.display.name='assert'를 식별자로 사용
use.assert.as.identifier.problem.descriptor=<code>\#ref</code>을(를) 식별자로 사용 \#loc
assert.statement.display.name='assert' 문
statement.problem.descriptor=<code>\#ref</code> 문 \#loc
auto.boxing.display.name=자동 박싱
auto.boxing.problem.descriptor=자동 박싱 <code>\#ref</code> \#loc
auto.boxing.make.boxing.explicit.quickfix=박싱을 명시적으로 만듭니다.
auto.boxing.ignore.added.to.collection.option=컬렉션에 추가된 표현식 무시
auto.unboxing.display.name=자동 언박싱
auto.unboxing.problem.descriptor=자동 언박싱 <code>\#ref</code> \#loc
auto.unboxing.make.unboxing.explicit.quickfix=언박싱을 명시적으로 만듭니다.
use.enum.as.identifier.display.name='enum'을 식별자로 사용
use.enum.as.identifier.problem.descriptor=<code>\#ref</code>을(를) 식별자로 사용 \#loc
enumerated.class.display.name=열거형 클래스
enumerated.class.problem.descriptor=열거형 클래스 <code>\#ref</code> \#loc
extended.for.statement.display.name=확장된 'for' 문
extended.for.statement.replace.quickfix=이전 스타일의 'for' 문으로 대체합니다.
variable.argument.method.display.name=vararg 메소드
variable.argument.method.problem.descriptor=vararg 메소드 <code>\#ref()</code> \#loc
variable.argument.method.quickfix=vararg 매개변수를 배열로 변환합니다
hardcoded.file.separator.display.name=하드코딩된 파일 구분 기호
hardcoded.file.separator.problem.descriptor=하드코딩된 파일 구분 기호 <code>\#ref</code> \#loc
hardcoded.file.separator.include.option=인지된 MIME 미디어 유형에 "example/*" 포함
hardcoded.line.separator.display.name=하드코딩된 줄 구분 기호
hardcoded.line.separator.problem.descriptor=하드코딩된 줄 구분 기호 <code>\#ref</code> \#loc
native.method.display.name=네이티브 메소드
native.method.problem.descriptor=<code>\#ref</code>(으)로 선언된 메소드는 이식 불가능합니다. \#loc
runtime.exec.call.display.name='Runtime.exec()' 호출
runtime.exec.call.problem.descriptor=<code>Runtime.\#ref()</code> 호출은 이식 불가능합니다. \#loc
system.exit.call.display.name='System.exit()' 또는 관련 메소드 호출
system.exit.call.problem.descriptor=<code>{0}.\#ref()</code> 호출은 이식 불가능합니다. \#loc
system.exit.call.ignore.option=메인 메소드에서 무시
system.getenv.call.display.name='System.getenv()' 호출
system.getenv.call.problem.descriptor=<code>System.\#ref()</code> 호출은 이식 불가능합니다. \#loc
use.of.awt.peer.class.display.name=AWT 피어 클래스 사용
use.of.awt.peer.class.problem.descriptor=AWT 피어 클래스 <code>\#ref</code>의 사용은 이식 불가능합니다. \#loc
use.of.concrete.jdbc.driver.class.display.name=구체 JDBC 드라이버 클래스 사용
use.of.concrete.jdbc.driver.class.problem.descriptor=구체 JDBC 드라이버 클래스 <code>\#ref</code>의 사용은 이식 불가능합니다. \#loc
use.processbuilder.class.display.name='java.lang.ProcessBuilder' 클래스 사용
use.processbuilder.class.problem.descriptor=<code>\#ref</code>의 사용은 이식 불가능합니다. \#loc
use.sun.classes.display.name=sun.* 클래스 사용
use.sun.classes.problem.descriptor=Sun 제공 클래스 <code>\#ref</code>의 사용은 이식 불가능합니다. \#loc
abstract.class.with.only.one.direct.inheritor.display.name=직접 상속자가 하나만 있는 추상 클래스
anonymous.inner.may.be.named.static.inner.class.display.name=익명 클래스가 이름 지정된 'static' 내부 클래스가 될 수 있음
anonymous.inner.may.be.named.static.inner.class.problem.descriptor=익명 클래스 <code>\#ref</code>이(가) 이름 지정된 'static' 내부 클래스가 될 수 있습니다. \#loc
array.length.in.loop.condition.display.name=루프 조건의 Array.length
array.length.in.loop.condition.problem.descriptor=루프 조건의 배열 <code>\#ref</code>을(를) 검사합니다. \#loc
large.array.allocation.no.outofmemoryerror.display.name=OutOfMemoryError 검사 없이 대규모 배열 대입
large.array.allocation.no.outofmemoryerror.problem.descriptor=메모리 부족 조건에 대해 검사되지 않은 대규모 배열 대입 \#loc
large.array.allocation.no.outofmemoryerror.maximum.number.of.elements.option=최대 요소 수\:
connection.opened.not.safely.closed.display.name=연결이 열렸으나 안전하게 닫히지 않음
interface.one.inheritor.display.name=직접 상속자가 하나만 있는 인터페이스
interface.one.inheritor.problem.descriptor=인터페이스 <code>\#ref</code>에 직접 상속자가 하나만 있습니다. \#loc
method.call.in.loop.condition.display.name=루프 조건의 메소드 호출
method.call.in.loop.condition.problem.descriptor=루프 조건의 메소드 <code>\#ref</code>을(를) 호출합니다. \#loc
large.initializer.primitive.type.array.display.name=기본 유형 배열에 지나치게 큰 이니셜라이저
large.initializer.primitive.type.array.problem.descriptor=요소가 너무 많은({0}) 기본 배열 이니셜라이저 \#loc
large.initializer.primitive.type.array.maximum.number.of.elements.option=최대 요소 수\:
private.member.access.between.outer.and.inner.classes.display.name=통합 접근자 호출
private.member.access.between.outer.and.inner.classes.problem.descriptor=클래스 ''{0}''의 ''private'' 멤버에 액세스하려면 통합 접근자가 필요합니다. \#loc
private.member.access.between.outer.and.inner.classes.make.local.quickfix=''{0}''을(를) package-private으로 만듭니다.
private.member.access.between.outer.and.inner.classes.make.constructor.package.local.quickfix=''{0}'' 생성자를 package-private으로 만듭니다.
recordstore.opened.not.safely.closed.display.name=RecordStore가 열렸으나 안전하게 닫히지 않음
overly.complex.anonymous.inner.class.display.name=지나치게 복잡한 익명 클래스
cyclomatic.complexity.limit.option=순환 복잡성 제한\:
overly.complex.anonymous.inner.class.problem.descriptor=지나치게 복잡한 익명 클래스(순환 복잡도 \= {0}) \#loc
anonymous.inner.class.with.too.many.methods.display.name=메소드가 너무 많은 익명의 내부 클래스
method.count.limit.option=메소드 수 제한\:
anonymous.inner.class.with.too.many.methods.problem.descriptor=메소드가 너무 많은 익명의 내부 클래스(메소드 수 \= {0}) \#loc
overly.complex.class.display.name=지나치게 복잡한 클래스
overly.complex.class.problem.descriptor=지나치게 복잡한 클래스 <code>\#ref</code>(순환 복잡도 \= {0}) \#loc
overly.coupled.class.display.name=지나치게 결합된 클래스
overly.coupled.class.class.coupling.limit.option=클래스 결합 제한\:
include.java.system.classes.option=Java 시스템 클래스에 결합 포함
include.library.classes.option=라이브러리 클래스에 결합 포함
overly.coupled.class.problem.descriptor=<code>\#ref</code>이(가) 지나치게 결합되었습니다(종속 요소 \= {0}). \#loc
class.too.deep.display.name=상속 트리에서 너무 깊이 있는 클래스
class.too.deep.inheritance.depth.limit.option=상속 깊이 제한\:
class.too.deep.problem.descriptor=<code>\#ref</code>의 상속 트리가 너무 깊습니다(상속 깊이 \= {0}). \#loc
inner.class.too.deeply.nested.display.name=내부 클래스가 너무 깊게 중첩
inner.class.too.deeply.nested.nesting.limit.option=중첩 제한\:
inner.class.too.deeply.nested.problem.descriptor=<code>\#ref</code>이(가) 지나치게 중첩되었습니다(중첩 수준 \= {0}). \#loc
too.many.constructors.display.name=생성자가 너무 많은 클래스
too.many.constructors.count.limit.option=생성자 수 제한\:
too.many.constructors.ignore.deprecated.option=더 이상 사용되지 않는 생성자 무시
too.many.constructors.problem.descriptor=<code>\#ref</code>에 생성자가 너무 많습니다(생성자 수 \= {0}). \#loc
too.many.fields.display.name=필드가 너무 많은 클래스
too.many.fields.count.limit.option=필드 수 제한\:
too.many.fields.problem.descriptor=<code>\#ref</code>에 생성자가 너무 많습니다(생성자 수 \= {0}). \#loc
too.many.methods.display.name=메소드가 너무 많은 클래스
too.many.methods.problem.descriptor=<code>\#ref</code>에 생성자가 너무 많습니다(생성자 수 \= {0}). \#loc
externalizable.with.serialization.methods.display.name='readObject()' 또는 'writeObject()'가 있는 externalizable 클래스
externalizable.with.serialization.methods.problem.descriptor.both=externalizable 클래스 <code>\#ref</code>이(가) 'readObject()'와 'writeObject()'를 정의합니다. \#loc
externalizable.with.serialization.methods.problem.descriptor.write=externalizable 클래스 <code>\#ref</code>이(가) 'writeObject()'를 정의합니다. \#loc
externalizable.with.serialization.methods.problem.descriptor.read=externalizable 클래스 <code>\#ref</code>이(가) 'readObject()'를 정의합니다. \#loc
non.serializable.with.serialversionuid.display.name='serialVersionUID'가 있는 비 serializable 클래스
non.serializable.class.with.serialversionuid.problem.descriptor=직렬화되지 않는 클래스 <code>\#ref</code>이(가) 'serialVersionUID' 필드를 정의합니다. \#loc
non.serializable.interface.with.serialversionuid.problem.descriptor=직렬화되지 않는 인터페이스 <code>\#ref</code>이(가) 'serialVersionUID' 필드를 정의합니다. \#loc
non.serializable.@interface.with.serialversionuid.problem.descriptor=직렬화되지 않는 @interface <code>\#ref</code>이(가) 'serialVersionUID' 필드를 정의합니다. \#loc
non.serializable.anonymous.with.serialversionuid.problem.descriptor=직렬화되지 않는 익명의 클래스를 확장하는 <code>\#ref</code>이(가) 'serialVersionUID' 필드를 정의합니다. \#loc
non.serializable.class.with.readwriteobject.display.name='readObject()' 또는 'writeObject()'가 있는 비 serializable 클래스
non.serializable.class.with.readwriteobject.problem.descriptor.both=직렬화되지 않는 클래스 <code>\#ref</code>이(가) 'readObject()'와 'writeObject()'를 정의합니다. \#loc
non.serializable.class.with.readwriteobject.problem.descriptor.write=직렬화되지 않는 클래스 <code>\#ref</code>이(가) 'writeObject()'를 정의합니다. \#loc
non.serializable.class.with.readwriteobject.problem.descriptor.read=직렬화되지 않는 클래스 <code>\#ref</code>이(가) 'readObject()'를 정의합니다. \#loc
non.serializable.anonymous.with.readwriteobject.problem.descriptor.both=직렬화되지 않는 익명의 클래스를 확장하는 <code>\#ref</code>이(가) 'readObject()'와 'writeObject()'를 정의합니다. \#loc
non.serializable.anonymous.with.readwriteobject.problem.descriptor.write=직렬화되지 않는 익명의 클래스를 확장하는 <code>\#ref</code>이(가) 'writeObject()'를 정의합니다. \#loc
non.serializable.anonymous.with.readwriteobject.problem.descriptor.read=직렬화되지 않는 익명의 클래스를 확장하는 <code>\#ref</code>이(가) 'readObject()'를 정의합니다. \#loc
readwriteobject.private.display.name='readObject()' 또는 'writeObject()'가 'private'으로 선언되지 않음
readwriteobject.private.problem.descriptor=<code>\#ref()</code>이(가) 'private'으로 선언되지 않았습니다. \#loc
readobject.initialization.display.name='readObject()'로 인스턴스 필드가 초기화되지 않을 수 있음
readobject.initialization.problem.descriptor=인스턴스 필드 <code>\#ref</code>은(는) 'readObject()' 호출 중에 초기화할 수 없습니다. \#loc
readresolve.writereplace.protected.display.name='readResolve()' 또는 'writeReplace()'가 'protected'로 선언되지 않음
readresolve.writereplace.protected.problem.descriptor=<code>\#ref()</code>이(가) 'protected'로 선언되지 않았습니다. \#loc
serialpersistentfields.with.wrong.signature.display.name='serialPersistentFields' 필드가 'private static final ObjectStreamField[]'로 선언되지 않음
serialpersistentfields.with.wrong.signature.problem.descriptor=serializable 클래스의 <code>\#ref</code> 필드가 'private static final ObjectStreamField[]'로 선언되지 않았습니다. \#loc
serialversionuid.private.static.final.long.display.name='serialVersionUID' 필드가 'private static final long'으로 선언되지 않음
serialversionuid.private.static.final.long.problem.descriptor=serializable 클래스의 <code>\#ref</code> 필드가 'private static final long'으로 선언되지 않았습니다. \#loc
serialversionuid.private.static.final.long.quickfix=serialVersionUID를 'private static final'로 만듭니다.
serializable.class.without.serialversionuid.display.name='serialVersionUID'가 없는 serializable 클래스
serializable.class.without.serialversionuid.problem.descriptor=<code>\#ref</code>이(가) 'serialVersionUID' 필드를 정의하지 않습니다. \#loc

#dynamic
non.protected.constructor.in.abstract.class.display.name='abstract' 클래스의 'public' 생성자
unnecessary.qualifier.for.this.display.name='this' 또는 'super'에 불필요한 한정자
multiple.declaration.display.name=하나의 선언 내 여러 변수
thread.priority.display.name='Thread.setPriority()' 호출
too.broad.scope.display.name=변수의 범위가 너무 넓음
infinite.loop.statement.display.name=무한 루프 문
asserts.without.messages.display.name=어설션에서 메시지 누락
constant.naming.convention.display.name=상수 이름 지정 규칙
constant.naming.convention.element.description=상수
constant.with.mutable.field.naming.convention.element.description=가변 필드 유형이 있는 상수
random.double.for.random.integer.display.name='Random.nextDouble()'을 사용하여 임의의 정수 얻기
test.method.without.assertion.display.name=어설션 없는 JUnit 테스트 메소드
string.buffer.replaceable.by.string.builder.display.name='StringBuffer'가 'StringBuilder'가 될 수 있음
comparison.of.short.and.char.display.name='short' 및 'char' 값 비교
unnecessary.fully.qualified.name.display.name=불필요한 정규화된 이름
ignore.in.module.statements.option=Java 9 모듈 구문에서 무시
unnecessary.label.on.break.statement.display.name='break' 문의 불필요한 라벨
exception.name.doesnt.end.with.exception.display.name=예외 클래스 이름이 'Exception'으로 끝나지 않음
bad.exception.declared.display.name=금지된 예외 선언
pointless.boolean.expression.display.name=무의미한 부울 표현식
class.without.constructor.display.name=생성자가 없는 클래스
break.statement.display.name='break' 문
unconditional.wait.display.name=조건 없는 'wait()' 호출
cyclomatic.complexity.display.name=지나치게 복잡한 메소드
final.class.display.name='final' 클래스
labeled.statement.display.name=라벨 지정된 구문
notify.called.on.condition.display.name='java.util.concurrent.locks.locks.Condition' 객체에서 'notify()' 또는 'notifyAll()' 호출
loop.statements.that.dont.loop.display.name=루프를 실행하지 않는 루프 문
ignore.enhanced.for.loop.statements=향상된 for 루프 무시
thread.run.display.name='Thread.run()' 호출
non.synchronized.method.overrides.synchronized.method.display.name=비동기화된 메소드가 동기화된 메소드를 재정의합니다.
synchronize.on.this.display.name='this' 동기화
switch.statement.with.too.many.branches.display.name=브랜치가 너무 많은 'switch' 문
utility.class.without.private.constructor.display.name='private' 생성자가 없는 유틸리티 클래스
throw.caught.locally.display.name='try' 문을 포함하여 'throw' 포착
exception.from.catch.which.doesnt.wrap.display.name=포착한 예외를 무시하는 'catch' 블록 내 'throw'
type.parameter.naming.convention.display.name=유형 매개변수 이름 지정 규칙
type.parameter.naming.convention.element.description=유형 매개변수
multiply.or.divide.by.power.of.two.display.name=2의 거듭제곱으로 곱하기 또는 나누기
multiply.or.divide.by.power.of.two.divide.option=2의 거듭제곱으로 나누기 검사
serializable.with.unconstructable.ancestor.display.name=생성할 수 없는 조상을 가진 serializable 클래스
missorted.modifiers.display.name=잘못 정렬된 제어자
sleep.while.holding.lock.display.name='Thread.sleep()'을 동기화 중에 호출 \#loc
singleton.display.name=싱글턴
thread.death.rethrown.display.name='java.lang.ThreadDeath'가 다시 던져지지 않음
if.statement.with.too.many.branches.display.name=브랜치가 너무 많은 'if' 문
redundant.implements.display.name=중복 인터페이스 선언
nesting.depth.display.name=지나치게 중첩된 메소드
return.this.display.name='this' 반환
busy.wait.display.name=바쁜 대기
utility.class.display.name=유틸리티 클래스
instantiating.object.to.get.class.object.display.name=클래스 객체를 얻기 위해 객체를 인스턴스화
abstract.class.extends.concrete.class.display.name=추상 클래스가 구체 클래스를 확장
parameter.naming.convention.display.name=메소드 매개변수 이름 지정 규칙
parameter.naming.convention.element.description=매개변수
integer.division.in.floating.point.context.display.name=부동소수점 컨텍스트의 정수 나누기
interface.naming.convention.display.name=인터페이스 이름 지정 규칙
interface.naming.convention.element.description=인터페이스
length.one.strings.in.concatenation.display.name=단일 문자 문자열 연결
length.one.string.in.indexof.display.name= 'String.indexOf()' 호출의 단일 문자열 인수
thread.yield.display.name='Thread.yield()' 호출
confusing.floating.point.literal.display.name=혼동되는 부동소수점 리터럴
wait.not.in.loop.display.name='wait()'가 루프에 없음
string.concatenation.inside.string.buffer.append.display.name='StringBuilder.append()' 호출에 대한 인수로서의 문자열 연결
class.initializer.display.name=비 'static' 이니셜라이저
enumerated.class.naming.convention.element.description=열거형
non.thread.safe.lazy.initialization.display.name='static' 필드의 안전하지 않은 지연 초기화
call.to.simple.setter.in.class.display.name=클래스 내에서 간단한 setter 호출
comparison.to.nan.display.name=Double.NaN 또는 Float.NaN과 비교
instance.method.naming.convention.display.name=인스턴스 메소드 이름 지정 규칙
new.method.naming.convention.display.name=메소드 이름 지정 규칙
instance.method.naming.convention.element.description=인스턴스
unnecessary.semicolon.display.name=불필요한 세미콜론
fallthru.in.switch.statement.display.name='switch' 문의 폴스루(Fallthrough)
call.to.native.method.while.locked.display.name=네이티브 메소드가 잠긴 상태에서 해당 메소드 호출
switch.statement.display.name='switch' 문
custom.classloader.display.name=사용자 지정 ClassLoader
nested.conditional.expression.display.name=중첩된 조건식
duplicate.condition.display.name=중복 조건
method.with.multiple.loops.display.name=여러 루프가 있는 메소드
non.comment.source.statements.display.name=지나치게 긴 메소드
local.variable.naming.convention.display.name=지역 변수 이름 지정 규칙
local.variable.naming.convention.element.description=지역 변수
negated.if.else.display.name=부정된 조건이 있는 'if' 문
class.naming.convention.display.name=클래스 이름 지정 규칙
class.naming.convention.element.description=클래스
abstract.class.naming.convention.display.name=추상 클래스 이름 지정 규칙
abstract.class.naming.convention.element.description=추상 클래스
serializable.inner.class.with.non.serializable.outer.class.display.name=비 serializable 외부 클래스가 있는 serializable 비 'static' 내부 클래스
pointless.arithmetic.expression.display.name=무의미한 산술 표현식
method.name.same.as.class.name.display.name=클래스 이름과 동일한 메소드 이름
unnecessary.temporary.on.conversion.to.string.display.name=문자열로 변환할 때 불필요한 임시 객체
unnecessary.continue.display.name=불필요한 'continue' 문
inner.class.on.interface.display.name=인터페이스의 내부 클래스
unused.label.display.name=사용되지 않는 라벨
overly.complex.boolean.expression.display.name=지나치게 복잡한 부울 표현식
continue.statement.with.label.display.name=라벨이 있는 'continue' 문
class.loader.instantiation.display.name=ClassLoader 인스턴스화
return.from.finally.block.display.name='finally' 블록 내 'return'
unnecessary.boxing.display.name=불필요한 박싱
annotation.naming.convention.element.description=어노테이션
checked.exception.class.display.name=검사된 예외 클래스
switch.statement.with.confusing.declaration.display.name=지역 변수가 다른 'switch' 브랜치에서 사용 및 선언됨
cast.that.loses.precision.display.name=정확성이 손실된 숫자 형 변환
manual.array.copy.display.name=수동 배열 복사
manual.array.to.collection.copy.display.name=컬렉션 복사로 수동 배열
long.literals.ending.with.lowercase.l.display.name='L' 대신 'l'로 끝나는 'long' 리터럴
overly.complex.arithmetic.expression.display.name=지나치게 복잡한 산술 표현식
junit.abstract.test.class.naming.convention.element.description=추상 테스트
unnecessary.parentheses.display.name=불필요한 소괄호
test.case.in.product.code.display.name=제품 소스의 JUnit TestCase
test.method.in.product.code.display.name=제품 소스의 JUnit 테스트 메소드
serializable.class.in.secure.context.display.name=안전한 컨텍스트의 serializable 클래스
static.variable.naming.convention.display.name='static' 필드 이름 지정 규칙
static.variable.naming.convention.element.description='static' 필드
nested.method.call.display.name=중첩된 메소드 호출
throw.from.finally.block.display.name='finally' 블록 내 'throw'
field.accessed.synchronized.and.unsynchronized.display.name=동기화/비동기화된 컨텍스트 모두에서 액세스되는 필드
abstract.method.overrides.abstract.method.display.name=추상 메소드가 추상 메소드를 재정의
static.non.final.field.display.name='static' 및 비 'final' 필드
static.non.final.field.option='public' 필드만 보고
class.without.no.arg.constructor.display.name=비인수 생성자가 없는 클래스
unnecessary.return.display.name=불필요한 'return' 문
final.static.method.display.name='static' 메소드를 'final'로 선언
constant.declared.in.abstract.class.display.name=상수를 추상 클래스로 선언
too.broad.catch.display.name=지나치게 넓은 'catch' 블록
floating.point.equality.display.name=부동소수점 상등 비교
thrown.exceptions.per.method.display.name=예외가 너무 많은 메소드 선언
public.static.array.field.display.name='public static' 배열 필드
await.not.in.loop.display.name='await()'가 루프에 없음
method.names.differ.only.by.case.display.name=대/소문자만 다른 메소드 이름
unsecure.random.number.generation.display.name=안전하지 않은 난수 생성
parameters.per.method.display.name=매개변수가 너무 많은 메소드
parameters.per.constructor.display.name=매개변수가 너무 많은 생성자
unnecessary.unboxing.display.name=불필요한 언박싱
extends.thread.display.name=클래스가 'java.lang.Thread'를 바로 확장
test.case.with.constructor.display.name=자명하지 않은 생성자가 있는 JUnit TestCase
parameter.name.differs.from.overridden.parameter.display.name=매개변수 이름이 재정의된 메소드의 매개변수와 다름
final.private.method.display.name='private' 메소드를 'final'로 선언
enum.switch.statement.which.misses.cases.display.name=case가 누락된 열거형 'switch' 문
enum.switch.statement.which.misses.cases.option=디폴트 브랜치가 있는 switch 문 무시
unconstructable.test.case.display.name=생성할 수 없는 JUnit TestCase
string.buffer.must.have.initial.capacity.display.name=초기 용량이 없는 StringBuilder
method.may.be.static.display.name=메소드가 'static'이 될 수 있음
class.initializer.may.be.static.display.name=클래스 이니셜라이저가 'static'이 될 수 있음
class.initializer.option=클래스에 하나 이상의 생성자가 있는 경우에만 경고
class.initializer.move.code.to.constructor.quickfix=이니셜라이저 코드를 생성자로 이동합니다.
nested.switch.statement.display.name=중첩된 'switch'
c.style.array.declaration.display.name=C 스타일 배열 선언
final.method.in.final.class.display.name='final' 클래스의 'final' 메소드
extends.annotation.display.name=클래스가 어노테이션 인터페이스를 확장
naked.notify.display.name=해당하는 상태 변경 없는 'notify()' 또는 'notifyAll()'
switch.statement.density.display.name=브랜치 밀도가 너무 낮은 'switch' 문
switch.statement.with.too.few.branches.display.name=브랜치가 너무 적은 'switch' 문
upper.case.field.name.not.constant.display.name=대문자 이름이 있는 상수 필드가 아님
unnecessary.label.on.continue.statement.display.name='continue' 문의 불필요한 라벨
jdbc.prepare.statement.with.non.constant.string.display.name=비상수 문자열이 있는 'Connection.prepare*()' 호출
synchronize.on.non.final.field.display.name=비 final 필드 동기화
noop.method.in.abstract.class.display.name=추상 클래스에 op 메소드가 없음
non.final.field.of.exception.display.name=예외 클래스의 비 final 필드
nested.try.statement.display.name=중첩된 'try' 문
condition.signal.display.name='signalAll()' 대신 'signal()' 호출
jdbc.execute.with.non.constant.string.display.name=비상수 문자열이 있는 'Statement.execute()' 호출
system.set.security.manager.display.name='System.setSecurityManager()' 호출
system.set.security.manager.problem.descriptor=<code>System.\#ref()</code> 호출로 보안 문제가 발생할 수 있습니다. \#loc
control.flow.statement.without.braces.display.name=중괄호가 없는 flow 문 제어
trivial.if.display.name=중복 'if' 문
trivial.if.fix.family.name='if else' 단순화
trivial.if.option.ignore.chained=체인 'if' 문 무시
thread.with.default.run.method.display.name=디폴트 'run()' 메소드로 스레드 초기화
while.loop.spins.on.field.display.name=필드에서 'while' 루프 스핀
while.loop.spins.on.field.fix.family.name=스핀 루프 수정
while.loop.spins.on.field.fix.volatile=''{0}''을(를) 휘발성으로 만듭니다.
while.loop.spins.on.field.fix.spinwait=Thread.onSpinWait() 추가
while.loop.spins.on.field.fix.volatile.spinwait=''{0}''을(를) 휘발성으로 만들고 Thread.onSpinWait()를 추가합니다.
test.method.is.public.void.no.arg.display.name=형식이 잘못된 테스트 메소드
if.statement.with.identical.branches.display.name=공통 부분이 있는 'if' 문
inspection.common.if.parts.message.variables.only=''if''에서 변수를 추출합니다{0}
inspection.common.if.parts.message.with.variables.extract=''if''에서 변수를 가진 공통 부분 추출{0}
inspection.common.if.parts.message.without.variables.extract=''if''에서 공통 부분 추출{0}
inspection.common.if.parts.message.whole.branch=브랜치를 제거하는 공통 부분 추출{0}
inspection.common.if.parts.message.complete.duplicate=''if'' 구문{0} 접기
inspection.common.if.parts.message.complete.duplicate.side.effect='if' 문을 접고 부작용을 추출합니다
inspection.common.if.parts.description.variables.only=''if''에서 변수 추출 가능{0}
inspection.common.if.parts.description.with.variables.extract=''if''에서 변수가 포함된 공통 부분 추출 가능{0}
inspection.common.if.parts.description.without.variables.extract=''if''에서 공통 부분 추출 가능{0}
inspection.common.if.parts.description.whole.branch=브랜치를 제거하여 공통 부분을 추출 할 수 있습니다{0}
inspection.common.if.parts.description.complete.duplicate=''if'' 문을 접을 수 있습니다{0}
inspection.common.if.parts.description.complete.duplicate.side.effect=부작용 추출을 활용해 'if' 문을 접을 수 있습니다
inspection.note.may.change.semantics=의미가 변경될 수 있습니다
multiple.return.points.per.method.display.name=여러 반환점이 있는 메소드
break.statement.with.label.display.name=라벨이 있는 'break' 문
public.constructor.in.non.public.class.display.name=비 public 클래스의 'public' 생성자
questionable.name.display.name=의심스러운 이름
empty.finally.block.display.name=빈 'finally' 블록
abstract.method.overrides.concrete.method.display.name=추상 메소드가 구체 메소드를 재정의
thread.stop.suspend.resume.display.name='Thread.stop()', 'suspend()' 또는 'resume()' 호출
constant.math.call.display.name=지속적 'java.lang.Math' 호출
volatile.array.field.display.name=휘발성 배열 필드
literal.as.arg.to.string.equals.display.name='"literal".equals(expression)'이 아닌 'expression.equals("literal")'
inner.class.may.be.static.display.name=내부 클래스가 'static'이 될 수 있음
static.suite.display.name='suite()' 메소드가 'static'으로 선언되지 않음
redundant.field.initialization.display.name=중복 필드 초기화
string.buffer.to.string.in.concatenation.display.name=연결된 'StringBuilder.toString()'
utility.class.with.public.constructor.display.name='public' 생성자가 있는 유틸리티 클래스
for.loop.replaceable.by.while.display.name='for' 루프를 'while' 루프로 대체할 수 있음
missing.deprecated.annotation.display.name=@Deprecated 어노테이션 누락
cloneable.class.in.secure.context.display.name=안전한 컨텍스트의 cloneable 클래스
static.inheritance.display.name=정적 상속
class.name.prefixed.with.package.name.display.name=패키지 이름 앞에 붙어 있는 클래스 이름
call.to.simple.getter.in.class.display.name=클래스 내에서 간단한 getter 호출
class.name.differs.from.file.name.display.name=클래스 이름이 파일 이름과 다름
protected.member.in.final.class.display.name='final' 클래스의 'protected' 멤버
load.library.with.non.constant.string.display.name=비상수 문자열이 있는 'Statement.loadLibrary()' 호출
instanceof.catch.parameter.display.name='catch' 매개변수에 대한 'instanceof'
implicit.numeric.conversion.display.name=묵시적 숫자 변환
unnecessary.interface.modifier.display.name=불필요한 인터페이스 제어자
confusing.main.method.display.name=혼동되는 'main()' 메소드
octal.literal.display.name=8진 정수
misordered.assert.equals.arguments.display.name=잘못 정렬된 'assertequals()' 인수
unnecessary.constructor.display.name=중복 비인수 생성자
method.name.same.as.parent.name.display.name=상위 클래스 이름과 동일한 메소드 이름
while.can.be.foreach.display.name='while' 루프를 향상된 'for' 루프로 대체할 수 있음
big.decimal.equals.display.name='java.math.BigDecimal'에서 'equals()' 호출
implicit.call.to.super.display.name='super()'를 묵시적으로 호출
empty.catch.block.display.name=빈 'catch' 블록
unqualified.static.usage.display.name=정규화되지 않은 정적 액세스
simplifiable.junit.assertion.display.name=단순화 가능한 어설션
object.notify.display.name='notifyAll()' 대신 'notify()' 호출
thread.start.in.construction.display.name=객체 생성 중에 'Thread.start()' 호출
non.final.clone.display.name=안전한 컨텍스트의 비 final 'clone()'
unnecessary.temporary.on.conversion.from.string.display.name=문자열에서 변환할 때 불필요한 임시 객체
unnecessary.this.display.name=불필요한 'this' 한정자
unnecessary.this.ignore.assignments.option=필드 대입 무시
runtime.exec.with.non.constant.string.display.name=비상수 문자열이 있는 'Runtime.exec()' 호출
system.properties.display.name=시스템 프로퍼티의 액세스
chained.method.call.display.name=체인 메소드 호출
safe.lock.display.name=잠금되었으나 안전하게 잠금 해제되지 않음
system.run.finalizers.on.exit.display.name='System.runFinalizersOnExit()' 호출
for.can.be.foreach.display.name='for' 루프를 향상된 'for' 루프로 대체할 수 있음
type.parameter.extends.object.display.name=유형 매개변수가 명시적으로 'java.lang.Object'를 확장
type.parameter.extends.object.ignore.annotated=java.lang.Object에 어노테이션이 지정된 경우 무시
marker.interface.display.name=마커 인터페이스
limited.scope.inner.class.display.name=제한된 범위의 내부 클래스
switch.statements.without.default.display.name='default' 브랜치가 없는 'switch' 문
unchecked.exception.class.display.name=검사되지 않은 예외 클래스
for.loop.with.missing.component.display.name=구성 요소가 누락된 'for' 루프
for.loop.with.missing.component.collection.loop.option=컬렉션 반복 무시
double.checked.locking.display.name=이중 검사된 잠금
double.checked.locking.problem.descriptor=이중 검사된 잠금 \#loc
double.checked.locking.ignore.on.volatiles.option=휘발성 필드에서 이중 검사된 잠금 무시
string.buffer.replaceable.by.string.display.name='StringBuilder'를 'String'로 대체 가능
boolean.method.name.must.start.with.question.display.name=부울 메소드 이름은 질문 단어로 시작해야 함
class.name.same.as.ancestor.name.display.name=조상의 이름과 동일한 클래스 이름
error.rethrown.display.name='java.lang.Error'가 다시 던져지지 않음
serializable.has.serialization.methods.display.name='readObject()' 또는 'writeObject()'가 없는 serializable 클래스
serializable.has.serialization.methods.ignore.option=인스턴스 필드를 정의하지 않는 클래스 무시
missing.override.annotation.display.name=@Override 어노테이션 누락
wait.while.holding.two.locks.display.name=두 개의 잠금을 유지하면서 'wait()'
empty.class.display.name=빈 클래스
trivial.string.concatenation.display.name=빈 문자열과 연결
empty.synchronized.statement.display.name=빈 'synchronized' 문
unnecessary.default.display.name=열거형 'switch' 문의 불필요한 'default'
simplifiable.conditional.expression.display.name=단순화 가능한 조건식
unnecessary.super.constructor.display.name=불필요한 'super()' 호출
unnecessarily.qualified.static.usage.display.name=정적 액세스가 불필요하게 정규화되었습니다.
bad.exception.caught.display.name=금지된 예외 포착
custom.security.manager.display.name=사용자 지정 SecurityManager
string.concatenation.in.loops.display.name=루프 내 문자열 연결
boolean.constructor.display.name=부울 생성자 호출
continue.statement.display.name='continue' 문
extends.object.display.name=클래스가 'java.lang.Object'를 명시적으로 확장
serializable.inner.class.has.serial.version.uid.field.display.name='serialVersionUID'가 없는 serializable 비 'static' 클래스
static.method.naming.convention.display.name='static' 메소드 이름 지정 규칙
static.method.naming.convention.element.description='static'
empty.try.block.display.name=빈 'try' 블록
field.has.setter.but.no.getter.display.name=필드에 setter는 있지만 getter가 없음
three.negations.per.method.display.name=4개 이상의 부정이 있는 메소드
conditional.expression.display.name=조건식 (?\:)
unnecessary.enum.modifier.display.name=불필요한 열거형 제어자
string.equals.empty.string.display.name='String.equals("")'
synchronize.on.lock.display.name=lock 객체 동기화
synchronized.on.literal.object.name=리터럴로 초기화된 객체 동기화
field.may.be.static.display.name=필드가 'static'이 될 수 있음
class.may.be.interface.display.name=추상 클래스가 인터페이스가 될 수 있음
abstract.class.without.abstract.methods.display.name=추상 메소드가 없는 추상 클래스
divide.by.zero.display.name=0으로 나누기
default.not.last.case.in.switch.display.name='default'가 'switch' 문의 마지막 case가 아님
nested.synchronized.statement.display.name=중첩된 'synchronized' 문
constant.conditional.expression.display.name=상수 조건식
redundant.else.display.name=중복 'else'
public.field.accessed.in.synchronized.context.display.name=동기화된 컨텍스트에서 비 private 필드 액세스
string.replaceable.by.string.buffer.display.name=비상수는 문자열이 StringBuilder여야 함
junit.test.class.naming.convention.display.name=JUnit 테스트 클래스 이름 지정 규칙
junit.test.class.naming.convention.element.description=테스트
junit.test.suite.naming.convention.element.description=테스트 도구
method.coupling.display.name=지나치게 결합된 메소드
collections.must.have.initial.capacity.display.name=초기 용량이 없는 컬렉션
anonymous.inner.class.display.name=익명의 내부 클래스
negated.conditional.display.name=부정된 조건이 있는 조건식
non.reproducible.math.call.display.name=재현 불가능한 'java.lang.math' 호출
multiple.top.level.classes.in.file.display.name=단일 파일 내 여러 최상위 클래스
set.replaceable.by.enum.set.display.name=EnumSet으로 대체 가능하도록 설정
non.static.inner.class.in.secure.context.display.name=안전한 컨텍스트의 비 'static' 내부 클래스
tail.recursion.display.name=꼬리 재귀
finally.block.cannot.complete.normally.display.name=정상적으로 완료되지 않는 'finally' 블록
non.atomic.operation.on.volatile.field.display.name=휘발성 필드의 비원자 연자
public.static.collection.field.display.name='public static' 컬렉션 필드
non.exception.name.ends.with.exception.display.name=비예외 클래스 이름이 'Exception'으로 끝남
synchronized.method.display.name='synchronized' 메소드
enumerated.constant.naming.convention.element.description=열거형 상수
final.method.display.name='finally' 메소드
transient.field.in.non.serializable.class.display.name=비 serializable 클래스의 transient 필드
bad.exception.thrown.display.name=금지된 예외가 던져짐
conditional.expression.with.identical.branches.display.name=동일한 브랜치가 있는 조건식
conditional.can.be.pushed.inside.expression.display.name=조건을 브랜치 표현식 내부로 푸시할 수 있음
conditional.can.be.pushed.inside.expression.option=조건이 메소드 호출의 인수일 뿐인 경우 무시
conditional.can.be.pushed.inside.expression.quickfix=브랜치 내부로 조건식을 푸시합니다.
raw.use.of.parameterized.type.display.name=매개변수화된 클래스의 원시 사용
standard.variable.names.display.name=표준 변수 이름
field.naming.convention.display.name=필드 이름 지정 규칙
instance.variable.naming.convention.element.description=인스턴스 필드
dollar.sign.in.name.display.name=식별자에서 '$' 사용
map.replaceable.by.enum.map.display.name=맵을 'EnumMap'으로 대체 가능
extends.concrete.collection.display.name=클래스가 컬렉션 클래스를 명시적으로 확장
continue.or.break.from.finally.block.display.name='finally' 블록 내 'continue' 또는 'break'
abstract.method.with.missing.implementations.display.name=구현이 누락된 추상 메소드
object.allocation.in.loop.display.name=루프 내 객체 대입
wait.called.on.condition.display.name='java.util.concurrent.locks.locks.Condition' 객체에서 'wait()' 호출
test.case.with.no.test.methods.display.name=테스트가 없는 테스트 클래스
abstract.class.never.implemented.display.name=구체 하위 클래스가 없는 추상 클래스
interface.never.implemented.display.name=구체 하위 클래스가 없는 인터페이스
constant.declared.in.interface.display.name=인터페이스에서 상수 선언


#problem descriptors
exception.name.doesnt.end.with.exception.problem.descriptor=예외 클래스 이름 <code>\#ref</code>이(가) 'Exception'으로 끝나지 않습니다. \#loc
non.exception.name.ends.with.exception.problem.descriptor=비예외 클래스 이름 <code>\#ref</code>이(가) 'Exception'으로 끝납니다. \#loc
class.name.prefixed.with.package.name.problem.descriptor=클래스 이름 <code>\#ref</code>이(가) 패키지 이름으로 시작합니다. \#loc
class.name.same.as.ancestor.name.problem.descriptor=클래스 이름 <code>\#ref</code>이(가) 해당 상위 클래스의 이름 중 하나와 동일합니다. \#loc
method.name.same.as.class.name.problem.descriptor=메소드 이름 <code>\#ref</code>이(가) 해당 상위 클래스의 이름 중 하나와 동일합니다. \#loc
method.name.same.as.parent.name.problem.descriptor=메소드 이름 <code>\#ref</code>이(가) 해당 상위 클래스의 이름 중 하나와 동일합니다. \#loc
boolean.method.name.must.start.with.question.problem.descriptor=부울 메소드 이름 <code>\#ref</code>이(가) 질문 단어로 시작하지 않습니다. \#loc
questionable.name.problem.descriptor=의심스러운 이름 <code>\#ref</code> \#loc
confusing.main.method.problem.descriptor='public static void main(String[])'이라는 시그니처 없이 <code>\#ref</code>(으)로 이름 지정된 메소드 \#loc
upper.case.field.name.not.constant.problem.descriptor=상수 스타일 이름을 가진 비상수 필드 <code>\#ref</code> \#loc
dollar.sign.in.name.problem.descriptor=식별자 <code>\#ref</code>에 '$'가 포함되어 있습니다. \#loc
integer.division.in.floating.point.context.problem.descriptor=<code>\#ref</code>\: 부동소수점 컨텍스트의 정수 나누기 \#loc
comparison.of.short.and.char.problem.descriptor=short 및 char 값의 상등 비교 <code>\#ref</code> \#loc
big.decimal.equals.problem.descriptor=BigDecimal 값 사이의 <code>\#ref()</code>은(는) 'compareTo()'여야 할 것입니다. \#loc
divide.by.zero.problem.descriptor=0으로 나누기 \#loc
non.reproducible.math.call.problem.descriptor=<code>Math.\#ref()</code>이(가) 재현 불가능한 결과를 생성할 수 있습니다. \#loc
constant.math.call.problem.descriptor=지속적인 <code>\#ref()</code> 호출을 단순화할 수 있습니다. \#loc
floating.point.equality.problem.descriptor=<code>\#ref</code>\: 부동소수점 값의 정확한 상등 비교 \#loc
fallthru.in.switch.statement.problem.descriptor='switch' 문의 폴스루(Fallthrough) \#loc
switch.statements.without.default.problem.descriptor='default' 브랜치가 없는 <code>\#ref</code> 문 \#loc
default.not.last.case.in.switch.problem.descriptor=<code>\#ref</code> 브랜치가 ''switch'' {0}의 마지막 case가 아닙니다. \#loc
loop.statements.that.dont.loop.problem.descriptor=<code>\#ref</code> 문에 루프가 없습니다. \#loc
conditional.expression.with.identical.branches.problem.descriptor=동일한 브랜치가 있는 조건식 <code>\#ref</code> \#loc
conditional.can.be.pushed.inside.expression.problem.descriptor=조건식은 브랜치 내부로 푸시할 수 있습니다. \#loc
duplicate.condition.problem.descriptor=중복 조건 <code>\#ref</code> \#loc
duplicate.condition.ignore.method.calls.option=부작용이 있는 조건 무시
duplicate.boolean.branch.problem.descriptor=중복 브랜치 <code>\#ref</code> \#loc
iterator.next.does.not.throw.nosuchelementexception.problem.descriptor='NoSuchElementException'을 던질 수 없는 <code>Iterator.\#ref()</code> \#loc
infinite.loop.statement.problem.descriptor=<code>\#ref</code> 문은 예외를 던지지 않으면 완료되지 않습니다. \#loc
confusing.floating.point.literal.problem.descriptor=부동소수점 리터럴 <code>\#ref</code>이(가) 혼동됩니다. \#loc
overly.complex.arithmetic.expression.problem.descriptor=지나치게 복잡한 산술 표현식 \#loc
overly.complex.boolean.expression.problem.descriptor=지나치게 복잡한 부울 표현식({0}개 항) \#loc
labeled.statement.problem.descriptor=라벨 지정된 구문 <code>\#ref\:</code> \#loc
break.statement.with.label.problem.descriptor=라벨 지정된 <code>\#ref</code> 문 \#loc
continue.statement.with.label.problem.descriptor=라벨 지정된 <code>\#ref</code> 문 \#loc
conditional.expression.problem.descriptor=조건식 <code>\#ref</code> \#loc
conditional.expression.option=간단한 대입 및 반환 무시
conditional.expression.expression.context.option=if 문이 불가능한 위치 무시
conditional.expression.quickfix='if' 문으로 대체합니다.
nested.conditional.expression.problem.descriptor=중첩된 조건식 <code>\#ref</code> \#loc
long.literals.ending.with.lowercase.l.problem.descriptor='long' 리터럴 <code>\#ref</code>이(가) 소문자 'l'로 끝납니다. \#loc
nested.switch.statement.problem.descriptor=중첩된 <code>\#ref</code> {0} \#loc
chained.method.call.problem.descriptor=체인 메소드 호출 <code>\#ref()</code> \#loc
nested.method.call.problem.descriptor=중첩된 메소드 호출 <code>\#ref()</code> \#loc
octal.literal.problem.descriptor=8진 정수 <code>\#ref</code> \#loc
implicit.call.to.super.problem.descriptor='super()'를 묵시적으로 호출합니다. \#loc
negated.if.else.problem.descriptor=부정된 조건이 있는 <code>\#ref</code> 문 \#loc
negated.conditional.problem.descriptor=부정된 조건이 있는 조건식 \#loc
redundant.else.problem.descriptor='if' 브랜치가 보통 절대 완료되지 않기 때문에 <code>\#ref</code> 브랜치가 줄 바꿈 해제될 수 있습니다. \#loc
switch.statement.with.confusing.declaration.problem.descriptor=지역 변수 <code>\#ref</code>이(가) 한 'switch' 브랜치에서 선언되고 다른 브랜치에서 사용됩니다. \#loc
raw.use.of.parameterized.type.problem.descriptor=매개변수화된 클래스 <code>\#ref</code>의 원시 사용 \#loc
final.class.problem.descriptor=<code>\#ref</code>(으)로 선언된 클래스 \#loc
empty.class.problem.descriptor=클래스 <code>\#ref</code>이(가) 비어 있습니다. \#loc
empty.enum.problem.descriptor=열거형 <code>\#ref</code>이(가) 비어 있습니다. \#loc
empty.class.file.without.class.problem.descriptor=Java 파일이 어떤 클래스도 선언하지 않습니다. \#loc
empty.anonymous.class.problem.descriptor=익명 클래스가 비어 있습니다. \#loc
anonymous.inner.class.problem.descriptor=익명의 내부 클래스 <code>\#ref</code> \#loc
limited.scope.inner.class.problem.descriptor=제한된 범위의 내부 클래스 <code>\#ref</code> \#loc
final.method.problem.descriptor=메소드가 <code>\#ref</code>(으)로 선언되었습니다. \#loc
class.initializer.problem.descriptor=비 'static' 이니셜라이저 \#loc
class.may.be.interface.problem.descriptor=추상 클래스 <code>\#ref</code>이(가) 인터페이스가 될 수 있습니다. \#loc
non.protected.constructor.in.abstract.class.problem.descriptor=생성자 <code>\#ref()</code>이(가) 'abstract' 클래스에서 'protected'로 선언되지 않았습니다. \#loc
class.without.constructor.problem.descriptor=클래스 <code>\#ref</code>에 생성자가 없습니다. \#loc
abstract.class.without.abstract.methods.problem.descriptor=클래스 <code>\#ref</code>이(가) 'abstract'로 선언되었으나 'abstract' 메소드가 없습니다. \#loc
final.method.in.final.class.problem.descriptor=메소드가 'final' 클래스에서 <code>\#ref</code>(으)로 선언되었습니다. \#loc
protected.member.in.final.class.problem.descriptor='final' 클래스에서 <code>\#ref</code>(으)로 선언된 클래스 멤버 \#loc
utility.class.with.public.constructor.problem.descriptor=클래스 <code>\#ref</code>에 'static' 멤버만 있고 'public' 생성자가 1개 있습니다. \#loc
utility.class.without.private.constructor.problem.descriptor=클래스 <code>\#ref</code>에 'static' 멤버만 있고 'private' 생성자가 없습니다. \#loc
abstract.method.overrides.concrete.method.problem.descriptor=추상 메소드 <code>\#ref()</code>이(가) 구체 메소드를 재정의합니다. \#loc
abstract.method.with.missing.implementations.problem.descriptor=추상 메소드 <code>\#ref()</code>이(가) 모든 하위 클래스에서 구현되어 있지 않습니다. \#loc
abstract.method.overrides.abstract.method.problem.descriptor=추상 메소드 <code>\#ref()</code>이(가) 추상 메소드를 재정의합니다. \#loc
abstract.method.overrides.abstract.method.ignore.different.javadoc.option=해당하는 상위 메소드가 아닌 다른 Javadoc이 있는 메소드 무시
abstract.class.extends.concrete.class.problem.descriptor=클래스 <code>\#ref</code>이(가) 'abstract'로 선언되고 구체 클래스를 확장합니다. \#loc
static.non.final.field.problem.descriptor='static' 및 비 'final' 필드 <code>\#ref</code> \#loc
constant.declared.in.abstract.class.problem.descriptor=상수 <code>\#ref</code>이(가) 추상 클래스로 선언되었습니다. \#loc
constant.declared.in.interface.problem.descriptor=상수 <code>\#ref</code>이(가) 인터페이스로 선언되었습니다. \#loc
static.inheritance.problem.descriptor=인터페이스 <code>\#ref</code>이(가) 'static' 상수에 대해서만 구현됩니다. \#loc
utility.class.problem.descriptor=클래스 <code>\#ref</code>에 'static' 멤버만 있고 절차적 생성을 표시합니다. \#loc
singleton.problem.descriptor=클래스 <code>\#ref</code>는 싱글턴입니다. \#loc
enum.singleton.problem.descriptor=열거형 <code>\#ref</code>는 싱글턴입니다. \#loc
final.private.method.problem.descriptor='private' 메소드가 <code>\#ref</code>(으)로 선언되었습니다. \#loc
noop.method.in.abstract.class.problem.descriptor=비 op 메소드 <code>\#ref()</code>은(는) 추상으로 만들어야 합니다. \#loc
final.static.method.problem.descriptor='static' 메소드가 <code>\#ref</code>(으)로 선언되었습니다. \#loc
class.without.no.arg.constructor.problem.descriptor=<code>\#ref</code>에 비인수 생성자가 없습니다. \#loc
multiple.top.level.classes.in.file.problem.descriptor=파일 내 여러 최상위 클래스
class.name.differs.from.file.name.problem.descriptor=클래스 이름 <code>\#ref</code>이(가) 파일 이름과 다릅니다. \#loc
marker.interface.problem.descriptor=마커 인터페이스 <code>\#ref</code> \#loc
field.has.setter.but.no.getter.problem.descriptor=필드 <code>\#ref</code>에 setter는 있지만 getter가 없습니다. \#loc
abstract.class.never.implemented.problem.descriptor=추상 클래스 <code>\#ref</code>에 구체 하위 클래스가 없습니다. \#loc
interface.never.implemented.problem.descriptor=인터페이스 <code>\#ref</code>에 구체 하위 클래스가 없습니다. \#loc
missing.deprecated.annotation.problem.descriptor='@Deprecated' 어노테이션 누락 \#loc
missing.deprecated.tag.problem.descriptor='@deprecated' Javadoc 태그 설명 누락 \#loc
missing.deprecated.tag.option=@deprecated Javadoc 태그 설명 누락 시 경고
missing.override.annotation.problem.descriptor=<code>\#ref()</code>에 관한 '@Override' 어노테이션 누락 \#loc
missing.override.annotation.in.overriding.problem.descriptor=재정의된 메소드가 '@Override'로 어노테이션이 추가되지 않았습니다
non.thread.safe.lazy.initialization.problem.descriptor='static' 필드 <code>\#ref</code>의 지연 초기화가 스레드 안전이 아닙니다. \#loc
empty.finally.block.problem.descriptor=빈 <code>\#ref</code> 블록 \#loc
finally.block.cannot.complete.normally.problem.descriptor=<code>\#ref</code> 블록이 정상적으로 완료되지 않습니다. \#loc
empty.try.block.problem.descriptor=빈 <code>\#ref</code> 블록 \#loc
throw.from.finally.block.problem.descriptor='finally' 블록 내 <code>\#ref</code> \#loc
possible.throw.from.finally.block.problem.descriptor=<code>{0}</code>이(가) ''finally'' 블록 내에서 던져질 수 있습니다. \#loc
throw,from.finally.block.everywhere.option=선언된 예외가 던져질 수 있는 모든 곳에 대해 경고
throw.caught.locally.problem.descriptor='try' 문을 포함하여 <code>\#ref</code>이(가) 포착되었습니다. \#loc
throw.caught.locally.ignore.option=다시 던져진 예외 무시
return.from.finally.block.problem.descriptor='finally' 블록 내 <code>\#ref</code> \#loc
continue.or.break.from.finally.block.problem.descriptor='finally' 블록 내 <code>\#ref</code> \#loc
bad.exception.declared.problem.descriptor=금지된 예외 <code>\#ref</code>이(가) 선언되었습니다. \#loc
bad.exception.caught.problem.descriptor=금지된 예외 <code>\#ref</code>이(가) 포착되었습니다. \#loc
checked.exception.class.problem.descriptor=검사된 예외 클래스 <code>\#ref</code> \#loc
unchecked.exception.class.problem.descriptor=검사되지 않은 예외 클래스 <code>\#ref</code> \#loc
thread.death.rethrown.problem.descriptor=ThreadDeath <code>\#ref</code>이(가) 다시 던져지지 않습니다. \#loc
error.rethrown.problem.descriptor=오류 <code>\#ref</code>이(가) 다시 던져지지 않습니다. \#loc
nested.try.statement.problem.descriptor=중첩된 <code>\#ref</code> 문 \#loc
exception.from.catch.which.doesnt.wrap.problem.descriptor='catch' 블록 내부의 <code>\#ref</code>이(가) 포착된 예외를 무시합니다. \#loc
instanceof.catch.parameter.problem.descriptor='catch' 매개변수 <code>\#ref</code>에 대한 'instanceof' \#loc
non.final.field.of.exception.problem.descriptor=예외 클래스의 비 final 필드 <code>\#ref</code> \#loc
unnecessary.label.on.break.statement.problem.descriptor=<code>\#ref</code> 문의 불필요한 라벨 \#loc
unnecessary.label.on.continue.statement.problem.descriptor=<code>\#ref</code> 문의 불필요한 라벨 \#loc
trivial.if.problem.descriptor=<code>\#ref</code> 문을 단순화할 수 있습니다. \#loc
unnecessary.parentheses.problem.descriptor=<code>\#ref</code> 주변의 소괄호가 불필요합니다. \#loc
unnecessary.local.variable.problem.descriptor=지역 변수 <code>\#ref</code>이(가) 중복됩니다. \#loc
unnecessary.this.problem.descriptor=<code>\#ref</code>은(는) 이 컨텍스트에서 불필요합니다. \#loc
unnecessary.block.statement.problem.descriptor=이 구문 주위에는 중괄호가 불필요합니다. \#loc
unnecessary.continue.problem.descriptor=루프의 마지막 구문으로서 <code>\#ref</code>은(는) 불필요합니다. \#loc
unnecessary.semicolon.problem.descriptor=불필요한 세미콜론 <code>\#ref</code> \#loc
unnecessary.semicolon.ignore.after.enum.constants.option=열거형 상수 뒤의 불필요한 세미콜론 무시
unnecessary.fully.qualified.name.problem.descriptor1=한정자 <code>\#ref</code>는 불필요하며 import 문으로 대체할 수 있습니다. \#loc
unnecessary.fully.qualified.name.problem.descriptor2=한정자 <code>\#ref</code>는 불필요하며 제거할 수 있습니다. \#loc
unnecessary.qualifier.for.this.problem.descriptor='this'에 있는 한정자 <code>\#ref</code>은(는) 이 컨텍스트에서 불필요합니다. \#loc
unnecessary.qualifier.for.super.problem.descriptor='super'에 있는 한정자 <code>\#ref</code>은(는) 이 컨텍스트에서 불필요합니다. \#loc
unused.label.problem.descriptor=사용되지 않는 라벨 <code>\#ref</code> \#loc
redundant.field.initialization.problem.descriptor=<code>\#ref</code>의 필드 초기화가 중복됩니다. \#loc
redundant.implements.problem.descriptor=중복 인터페이스 선언 <code>\#ref</code> \#loc
extends.object.problem.descriptor=클래스 <code>\#ref</code>이(가) 명시적으로 'java.lang.Object'를 확장합니다. \#loc
type.parameter.extends.object.problem.descriptor1=유형 매개변수 <code>\#ref</code>이(가) 명시적으로 'java.lang.Object'를 확장합니다. \#loc
type.parameter.extends.object.problem.descriptor2=와일드카드 유형 인수 <code>\#ref</code>이(가) 명시적으로 'java.lang.Object'를 확장합니다. \#loc
unnecessary.super.constructor.problem.descriptor=<code>\#ref</code>은(는) 불필요합니다. \#loc
unnecessary.constructor.problem.descriptor=비인수 생성자 <code>\#ref()</code>이(가) 중복됩니다. \#loc
unnecessary.constructor.annotation.option=어노테이션이 있는 생성자 무시
for.loop.replaceable.by.while.problem.descriptor=<code>\#ref</code> 루프 문은 'while' 루프로 대체할 수 있습니다. \#loc
unnecessary.default.problem.descriptor=<code>\#ref</code> 브랜치는 불필요합니다. \#loc
unnecessary.default.expressions.option=switch 식만 보고
unnecessary.default.quickfix='default' 브랜치를 제거합니다.
unnecessary.boxing.problem.descriptor=불필요한 박싱 <code>\#ref</code> \#loc
unnecessary.boxing.inside.value.of.problem.descriptor=<code>\#ref</code> 내 중복 박싱 \#loc
unnecessary.unboxing.problem.descriptor=불필요한 언박싱 <code>\#ref</code> \#loc
unnecessary.boxing.superfluous.option=진정으로 불필요한 박싱된 표현식만 보고
unnecessary.unboxing.superfluous.option=진정으로 불필요한 언박싱된 표현식만 보고
for.can.be.foreach.problem.descriptor=<code>\#ref</code> 루프를 향상된 'for'로 대체할 수 있습니다. \#loc
while.can.be.foreach.problem.descriptor=<code>\#ref</code> 루프를 향상된 'for'로 대체할 수 있습니다. \#loc
too.broad.scope.problem.descriptor=변수 <code>\#ref</code>의 범위가 너무 넓습니다. \#loc
return.this.problem.descriptor=<code>\#ref</code> 반환 \#loc
constant.on.side.of.comparison.display.name=비교 중인 잘못된 쪽의 상수
constant.on.lhs.of.comparison.problem.descriptor=비교 중인 왼쪽의 상수 <code>\#ref</code> \#loc
constant.on.rhs.of.comparison.problem.descriptor=비교 중인 오른쪽의 상수 <code>\#ref</code> \#loc
control.flow.statement.without.braces.problem.descriptor=중괄호 없는 <code>{0}</code> \#loc
missorted.modifiers.problem.descriptor=잘못 정렬된 제어자 <code>{0}</code> \#loc
cstyle.array.variable.declaration.problem.descriptor={0, choice, 1\#필드|2\#매개변수|3\#레코드 구성 요소|4\#지역 변수} <code>\#ref</code> 의 C 스타일 배열 선언 \#loc
cstyle.array.method.declaration.problem.descriptor=메소드 <code>\#ref()</code>의 반환 유형의 C 스타일 배열 선언 \#loc
multiple.declaration.problem.descriptor=하나의 선언 내 여러 변수 \#loc
multiple.typed.declaration.problem.descriptor=하나의 선언 내 배열 크기가 다른 변수 \#loc
serializable.inner.class.has.serial.version.uid.field.problem.descriptor=내부 클래스 <code>\#ref</code>이(가) 'serialVersionUID' 필드를 정의하지 않습니다. \#loc
serializable.inner.class.with.non.serializable.outer.class.problem.descriptor=내부 클래스 <code>\#ref</code>이(가) 직렬화되었으나 해당 외부 클래스는 그렇지 않습니다. \#loc
busy.wait.problem.descriptor=루프 내 <code>Thread.\#ref()</code>에 대한 호출이 바쁜 대기 중일 수 있습니다. \#loc
sleep.while.holding.lock.problem.descriptor=<code>Thread.\#ref()</code>이(가) 동기화 중에 호출됩니다. \#loc
non.atomic.operation.on.volatile.field.problem.descriptor=휘발성 필드 <code>\#ref</code>의 비원자 연산 \#loc
call.to.native.method.while.locked.problem.descriptor=동기화된 컨텍스트에서 기본 메소드 <code>\#ref()</code>을(를) 호출합니다. \#loc
object.notify.problem.descriptor=<code>\#ref</code>을(를) 'notifyAll()'로 대체해야 할 것입니다. \#loc
condition.signal.problem.descriptor=<code>\#ref</code>을(를) 'signalAll()'로 대체해야 할 것입니다. \#loc
thread.with.default.run.method.problem.descriptor=디폴트 'run()' 메소드로 <code>\#ref</code>을(를) 초기화합니다. \#loc
extends.thread.problem.descriptor=클래스 <code>\#ref</code>이(가) 'java.lang.Thread'를 바로 확장합니다. \#loc
anonymous.extends.thread.problem.descriptor=익명의 클래스가 'java.lang.Thread'를 바로 확장합니다. \#loc
naked.notify.problem.descriptor=해당하는 상태 변경 없이 <code>\#ref()</code>을(를) 호출합니다. \#loc
unconditional.wait.problem.descriptor=<code>\#ref()</code>을(를) 조건 없이 호출합니다. \#loc
system.run.finalizers.on.exit.problem.descriptor=<code>System.\#ref()</code>을(를) 호출합니다. \#loc
thread.priority.problem.descriptor=<code>Thread.\#ref()</code>을(를) 호출합니다. \#loc
thread.yield.problem.descriptor=<code>Thread.\#ref()</code>을(를) 호출합니다. \#loc
thread.stop.suspend.resume.problem.descriptor=<code>Thread.\#ref()</code>을(를) 호출합니다. \#loc
while.loop.spins.on.field.problem.descriptor=<code>\#ref</code> 루프가 필드에서 스핀합니다. \#loc
wait.not.in.loop.problem.descriptor=<code>\#ref()</code>이(가) 루프에서 호출되지 않습니다. \#loc
await.not.in.loop.problem.descriptor=<code>\#ref()</code>이(가) 루프에서 호출되지 않습니다. \#loc
wait.called.on.condition.problem.descriptor=조건 객체에서 <code>\#ref()</code>이(가) 호출됩니다. \#loc
notify.called.on.condition.problem.descriptor=조건 객체에서 <code>\#ref()</code>이(가) 호출됩니다. \#loc
wait.while.holding.two.locks.problem.descriptor=<code>\#ref()</code>이(가) 2개의 잠금을 유지하는 동안 호출됩니다. \#loc
thread.run.problem.descriptor=<code>\#ref()</code> 호출을 'start()'로 대체해야 할 것입니다. \#loc
thread.start.in.construction.problem.descriptor=<code>\#ref</code>이(가) 객체 생성 중에 호출됩니다. \#loc
synchronize.on.lock.problem.descriptor={0}'' 객체의 동기화가 의도된 것 같지 않습니다. \#loc
synchronized.on.literal.object.problem.descriptor=리터럴로 초기화된 {0} <code>\#ref</code> 동기화 \#loc
synchronized.on.direct.literal.object.problem.descriptor={0} 리터럴 <code>\#ref</code> 동기화 \#loc
synchronized.on.possibly.literal.object.problem.descriptor={0} <code>\#ref</code> 동기화 \#loc
synchronize.on.non.final.field.problem.descriptor=비 final 필드 <code>\#ref</code> 동기화 \#loc
synchronized.on.literal.object.warn.on.all.option=가능한 모든 리터럴에 대해 경고
synchronize.on.this.problem.descriptor='this'에 대한 잠금 작업으로 예기치 않은 부작용이 발생할 수 있습니다. \#loc
synchronize.on.class.problem.descriptor=클래스에 대한 잠금 작업으로 예기치 않은 부작용이 발생할 수 있습니다. \#loc
nested.synchronized.statement.problem.descriptor=중첩된 <code>\#ref</code> 문 \#loc
empty.synchronized.statement.problem.descriptor=빈 <code>\#ref</code> 문 \#loc
non.synchronized.method.overrides.synchronized.method.problem.descriptor=비동기화된 메소드 <code>\#ref()</code>이(가) 동기화된 메소드를 재정의합니다. \#loc
public.field.accessed.in.synchronized.context.problem.descriptor=동기화된 컨텍스트에서 비 private 필드 <code>\#ref</code>이(가) 액세스됩니다. \#loc
field.accessed.synchronized.and.unsynchronized.problem.descriptor=필드 <code>\#ref</code>이(가) 동기화된 컨텍스트와 동기화되지 않은 컨텍스트 모두에서 액세스됩니다. \#loc
extended.for.statement.problem.descriptor=확장된 <code>\#ref</code> 문 \#loc
object.allocation.in.loop.new.descriptor=루프 내 객체 대입 <code>new \#ref()</code> \#loc
object.allocation.in.loop.problem.array.initializer.descriptor=루프 내 배열 대입 \#loc
object.allocation.in.loop.problem.call.descriptor=루프 내 <code>\#ref()</code>을(를) 통한 객체 대입 \#loc
object.allocation.in.loop.problem.methodref.descriptor=루프 내 인스턴스 바인드된 메소드 참조 <code>\#ref()</code>을(를) 통한 객체 대입 \#loc
object.allocation.in.loop.problem.lambda.descriptor=루프 내 람다 캡처를 통한 객체 대입 \#loc
object.allocation.in.loop.problem.string.concat=루프 내 문자열 연결을 통한 객체 대입 \#loc
instantiating.object.to.get.class.object.problem.descriptor=클래스 객체를 얻기 위해 객체를 인스턴스화합니다. \#loc
field.may.be.static.problem.descriptor=필드 <code>\#ref</code>이(가) 'static'이 될 수 있습니다. \#loc
method.may.be.static.problem.descriptor=메소드 <code>\#ref()</code>이(가) 'static'이 될 수 있습니다. \#loc
class.initializer.may.be.static.problem.descriptor=클래스 이니셜라이저가 'static'이 될 수 있습니다. \#loc
map.replaceable.by.enum.map.problem.descriptor=<code>\#ref</code>을(를) 'EnumMap'으로 대체할 수 있습니다. \#loc
set.replaceable.by.enum.set.problem.descriptor=<code>\#ref</code>을(를) 'EnumSet'(으)로 대체할 수 있습니다. \#loc
inner.class.may.be.static.problem.descriptor=내부 클래스 <code>\#ref</code>이(가) 'static'이 될 수 있습니다. \#loc
string.buffer.must.have.initial.capacity.problem.descriptor=초기 용량이 없는 <code>new \#ref()</code> \#loc
string.buffer.replaceable.by.string.builder.problem.descriptor=<code>StringBuffer \#ref</code>은(는) 'StringBuilder'로 선언할 수 있습니다.. \#loc
string.buffer.replaceable.by.string.problem.descriptor=<code>{0} \#ref</code>을(를) ''String''으로 대체할 수 있습니다. \#loc
new.string.buffer.replaceable.by.string.problem.descriptor=<code>\#ref</code>을(를) 'String'으로 대체할 수 있습니다. \#loc
string.replaceable.by.string.buffer.problem.descriptor=비상수 <code>String \#ref</code>은(는) 'StringBuilder'로 선언해야 할 것입니다.
collections.must.have.initial.capacity.problem.descriptor=초기 용량이 없는 <code>new \#ref()</code> \#loc
string.concatenation.in.loops.problem.descriptor=루프 내 문자열 연결 <code>\#ref</code> \#loc
string.concatenation.inside.string.buffer.append.problem.descriptor=<code>{0}.\#ref()</code> 호출에 대한 인수로서의 문자열 연결 \#loc
boolean.constructor.problem.descriptor=부울 생성자 호출 \#loc
string.buffer.to.string.in.concatenation.problem.descriptor=연결에서 <code>{0}.\#ref()</code>이(가) 호출됩니다. \#loc
tail.recursion.problem.descriptor=꼬리 재귀 호출 <code>\#ref()</code> \#loc
string.equals.empty.string.problem.descriptor=<code>\#ref("")</code>을(를) 'length()\=\=0'(으)로 대체할 수 있습니다. \#loc
string.equals.empty.string.is.empty.problem.descriptor=<code>\#ref("")</code>을(를) 'isEmpty()'로 대체할 수 있습니다. \#loc
random.double.for.random.integer.problem.descriptor=<code>Random.\#ref</code>을(를) 사용하여 임의의 정수를 생성합니다. \#loc
manual.array.copy.problem.descriptor=수동 배열 복사 \#loc
manual.array.to.collection.copy.problem.descriptor=수동 배열로 컬렉션 복사 \#loc
call.to.simple.getter.in.class.problem.descriptor=클래스 내에서 간단한 getter <code>\#ref()</code>을(를) 호출합니다. \#loc
call.to.simple.setter.in.class.problem.descriptor=클래스 내에서 간단한 setter <code>\#ref()</code>을(를) 호출합니다. \#loc
asserts.without.messages.problem.descriptor=메시지 없는 <code>\#ref()</code> \#loc
test.case.with.constructor.problem.descriptor='setUp()'이 아닌 생성자 <code>\#ref()</code>의 초기화 논리 \#loc
test.case.with.constructor.problem.descriptor.initializer='setUp()'이 아닌 이니셜라이저의 초기화 논리
misordered.assert.equals.arguments.problem.descriptor=순서가 잘못된 <code>\#ref()</code>에 대한 인수 \#loc
static.suite.problem.descriptor=JUnit <code>\#ref()</code> 메소드가 'static'으로 선언되지 않았습니다. \#loc
simplifiable.junit.assertion.problem.descriptor=<code>\#ref()</code>을(를) ''{0}''(으)로 단순화할 수 있습니다. \#loc
test.method.without.assertion.problem.descriptor=JUnit 테스트 메소드 <code>\#ref()</code>에 어설션이 없습니다. \#loc
test.case.with.no.test.methods.problem.descriptor=테스트 클래스 <code>\#ref</code>에 테스트가 없습니다. \#loc
test.case.in.product.code.problem.descriptor=테스트 케이스 <code>\#ref</code>을(를) 테스트 소스 트리에서 대체해야 할 것입니다. \#loc
test.method.in.product.code.problem.descriptor=테스트 메소드 <code>\#ref()</code>을(를) 테스트 소스 트리에서 대체해야 할 것입니다. \#loc
unconstructable.test.case.problem.descriptor=테스트 케이스 <code>\#ref</code>은(는) 대부분의 테스트 러너로 구성할 수 없습니다. \#loc
deserializable.class.in.secure.context.problem.descriptor=클래스 <code>\#ref</code>이(가) 비직렬화되어 보안이 취약해질 수 있습니다. \#loc
serializable.class.in.secure.context.problem.descriptor=클래스 <code>\#ref</code>이(가) 직렬화되어 보안이 취약해질 수 있습니다. \#loc
serializable.deserializable.class.in.secure.context.problem.descriptor=클래스 <code>\#ref</code>이(가) 직렬화 및 비직렬화되어 보안이 취약해질 수 있습니다. \#loc
cloneable.class.in.secure.context.problem.descriptor=클래스 <code>\#ref</code>이(가) 복제되어 보안이 취약해질 수 있습니다. \#loc
cloneable.class.in.secure.context.quickfix=항상 예외를 던지는 'clone()' 메소드를 생성합니다.
remove.cloneable.quickfix=구현 절에서 'Cloneable'을 제거합니다.
non.final.clone.problem.descriptor=비 final <code>\#ref()</code> 메소드로 인해 보안이 취약해질 수 있습니다. \#loc
non.static.inner.class.in.secure.context.problem.descriptor=비 'static' 내부 클래스 <code>\#ref</code>(으)로 인해 보안이 취약해질 수 있습니다. \#loc
runtime.exec.with.non.constant.string.problem.descriptor=비상수 인수가 있는 <code>Runtime.\#ref()</code>을(를) 호출합니다. \#loc
load.library.with.non.constant.string.problem.descriptor=비상수 인수가 있는 <code>{0}.\#ref()</code>을(를) 호출합니다. \#loc
jdbc.execute.with.non.constant.string.problem.descriptor=비상수 인수가 있는 <code>Statement.\#ref()</code>을(를) 호출합니다. \#loc
jdbc.prepare.statement.with.non.constant.string.problem.descriptor=비상수 인수가 있는 <code>Connection.\#ref()</code>을(를) 호출합니다. \#loc
custom.classloader.problem.descriptor=사용자 지정 ClassLoader 클래스 <code>\#ref</code> \#loc
custom.security.manager.problem.descriptor=사용자 지정 SecurityManager 클래스 <code>\#ref</code> \#loc
system.set.problem.descriptor=<code>System.\#ref()</code> 호출로 보안 문제가 발생할 수 있습니다. \#loc
class.loader.instantiation.problem.descriptor=<code>\#ref</code> 인스턴스화로 보안 문제가 발생할 수 있습니다. \#loc
public.static.array.field.problem.descriptor='public static' 배열 필드 <code>\#ref</code>(으)로 인해 보안이 취약해질 수 있습니다. \#loc
public.static.collection.field.problem.descriptor='public static' 컬렉션 필드 <code>\#ref</code>(으)로 인해 보안이 취약해질 수 있습니다. \#loc
abstract.class.with.only.one.direct.inheritor.problem.descriptor=추상 클래스 <code>\#ref</code>에 직접 상속자가 하나만 있습니다. \#loc

#other
abstract.method.overrides.abstract.method.remove.quickfix=중복 추상 메소드 선언을 제거합니다.
class.may.be.interface.convert.quickfix=클래스를 인터페이스로 변환합니다.
class.without.constructor.create.quickfix=빈 생성자를 생성합니다.
class.without.no.arg.constructor.ignore.option=클래스에 디폴트 생성자가 있는 경우 무시
extends.annotation.problem.descriptor=클래스 ''{0}'' 이(가) 어노테이션 인터페이스 <code>\#ref</code>을(를) 구현합니다 \#loc
extends.annotation.interface.problem.descriptor=인터페이스 ''{0}'' 이(가) 어노테이션 인터페이스 <code>\#ref</code>을(를) 확장합니다 \#loc
extends.concrete.collection.problem.descriptor=클래스 <code>\#ref</code>이(가) 명시적으로 ''{0}''을(를) 확장합니다. \#loc
anonymous.extends.concrete.collection.problem.descriptor=익명의 클래스가 ''{0}''을(를) 명시적으로 확장합니다. \#loc
inner.class.on.interface.ignore.option=인터페이스의 내부 인터페이스 무시
inner.class.on.interface.problem.descriptor=인터페이스 ''{0}''에 내부 클래스 <code>\#ref</code>이(가) 있습니다. \#loc
missing.deprecated.annotation.add.quickfix=@Deprecated 어노테이션을 추가합니다
missing.add.deprecated.javadoc.tag.quickfix='@deprecated' Javadoc 태그를 추가합니다.
non.protected.constructor.in.abstract.class.ignore.option=비 public 클래스 무시
public.constructor.in.non.public.class.problem.descriptor=생성자가 비 public 클래스 ''{0}''에서 <code>\#ref</code>(으)로 선언되었습니다. \#loc
static.inheritance.replace.quickfix=상속을 {0}의 정규화된 참조로 대체합니다.
utility.class.with.public.constructor.make.quickfix={0, choice, 1\#생성자|2\#생성자}를 'private'으로 만듭니다
utility.class.without.private.constructor.create.quickfix=빈 'private' 생성자를 생성합니다.
utility.class.without.private.constructor.make.quickfix=생성자를 'private'으로 만듭니다.
naming.convention.problem.descriptor.short={0} 이름 <code>\#ref</code>이(가) 너무 짧습니다({1} < {2}). \#loc
naming.convention.problem.descriptor.long={0} 이름 <code>\#ref</code>이(가) 너무 깁니다({1} > {2}). \#loc
naming.convention.problem.descriptor.regex.mismatch={0} 이름 <code>\#ref</code>이(가) 정규식 ''{1}''와(과) 일치하지 않습니다. \#loc
local.variable.naming.convention.ignore.option=for 루프 매개변수 무시
local.variable.naming.convention.ignore.catch.option='catch' 블록 매개변수 무시
method.names.differ.only.by.case.problem.descriptor=메소드 이름 <code>\#ref</code>와(과) 메소드 이름 ''{0}''이(가) 대/소문자만 다릅니다. \#loc
parameter.name.differs.from.overridden.parameter.ignore.character.option=재정의된 매개변수에 문자가 하나만 있는 경우 무시
parameter.name.differs.from.overridden.parameter.ignore.library.option=재정의된 매개변수가 라이브러리에서 온 경우 무시
parameter.name.differs.from.overridden.parameter.problem.descriptor=매개변수 이름 <code>\#ref</code>이(가) 재정의된 매개변수 ''{0}''와(과) 다릅니다. \#loc
questionable.name.column.title=이름
standard.variable.names.problem.descriptor=이름이 <code>\#ref</code>인 변수에 유형 ''{0}''이(가) 없습니다. \#loc
standard.variable.names.problem.descriptor2=이름이 <code>\#ref</code>인 변수에 유형 ''{0}'' 또는 ''{1}''이(가) 없습니다. \#loc
standard.variable.names.ignore.override.option=상위 메소드 매개변수와 동일한 매개변수 이름 무시
boolean.method.name.must.start.with.question.table.column.name=부울 메소드 이름 접두사
conditional.expression.with.identical.branches.collapse.quickfix=조건식을 접습니다.
redundant.else.unwrap.quickfix=중복 'else'를 제거합니다.
constant.conditional.expression.problem.descriptor=<code>\#ref</code>을(를) ''{0}''(으)로 단순화할 수 있습니다. \#loc
constant.conditional.expression.simplify.quickfix=단순화
constant.conditional.expression.simplify.quickfix.sideEffect=부작용을 추출하고 단순화합니다.
enum.switch.statement.which.misses.cases.problem.descriptor.single=열거형 ''{0}''에 대한 <code>\#ref</code> 문에 case ''{1}''이(가) 없습니다. \#loc
enum.switch.statement.which.misses.cases.problem.descriptor=열거형 ''{0}''에 대한 <code>\#ref</code> 문에 case {1}이(가) 없습니다. \#loc
for.loop.replaceable.by.while.ignore.option=조건 없는 루프의 'infinite' 무시
for.loop.with.missing.component.problem.descriptor1=<code>\#ref</code> 문에 이니셜라이저가 없습니다. \#loc
for.loop.with.missing.component.problem.descriptor2=<code>\#ref</code> 문에 조건이 없습니다. \#loc
for.loop.with.missing.component.problem.descriptor3=<code>\#ref</code> 문에 업데이트가 없습니다. \#loc
for.loop.with.missing.component.problem.descriptor4=<code>\#ref</code> 문에 이니셜라이저 및 조건이 없습니다. \#loc
for.loop.with.missing.component.problem.descriptor5=<code>\#ref</code> 문에 이니셜라이저 및 업데이트가 없습니다. \#loc
for.loop.with.missing.component.problem.descriptor6=<code>\#ref</code> 문에 조건 및 업데이트가 없습니다. \#loc
for.loop.with.missing.component.problem.descriptor7=<code>\#ref</code> 문에 이니셜라이저, 조건 및 업데이트가 없습니다. \#loc
foreach.replace.quickfix=향상된 'for'로 대체합니다.
unnecessary.boxing.remove.quickfix=박싱을 제거합니다.
unnecessary.unboxing.remove.quickfix=언박싱 제거
misordered.assert.equals.arguments.flip.quickfix=비교 인수를 반전시킵니다.
simplify.junit.assertion.simplify.quickfix=어설션을 단순화합니다
test.method.is.public.void.no.arg.problem.descriptor1=테스트 메소드 <code>\#ref()</code>에 매개변수가 있으면 안 될 것입니다. \#loc
test.method.is.public.void.no.arg.problem.descriptor2=테스트 메소드 <code>\#ref()</code>이(가) 'public void'로 선언되지 않았습니다. \#loc
test.method.is.public.void.no.arg.problem.descriptor3=테스트 메소드 <code>\#ref()</code>이(가) 'static'이면 안 됩니다. \#loc
system.properties.problem.descriptor=<code>Integer.\#ref()</code> 호출로 보안 문제가 발생할 수 있습니다. \#loc
system.properties.problem.descriptor1=<code>Boolean.\#ref()</code> 호출로 보안 문제가 발생할 수 있습니다. \#loc
unsecure.random.number.generation.problem.descriptor1=보안을 위해 <code>java.lang.Math.\#ref()</code> 대신 'java.security.SecureRandom'을 사용합니다. \#loc
unsecure.random.number.generation.problem.descriptor2=보안을 위해 <code>java.util.\#ref</code> 대신 'java.security.SecureRandom'을 사용합니다. \#loc
unsecure.random.number.generation.problem.descriptor3=보안을 위해 <code>\#ref</code> 대신 'java.security.SecureRandom'을 사용합니다. \#loc
serializable.has.serialization.methods.problem.descriptor=serializable 클래스 <code>\#ref</code>이(가) 'readObject()' 또는 'writeObject()'를 정의하지 않습니다. \#loc
serializable.has.serialization.methods.problem.descriptor1=serializable 클래스 <code>\#ref</code>이(가) 'writeObject()'를 정의하지 않습니다. \#loc
serializable.has.serialization.methods.problem.descriptor2=serializable 클래스 <code>\#ref</code>이(가) 'readObject()'를 정의하지 않습니다. \#loc
serializable.with.unconstructable.ancestor.problem.descriptor=<code>\#ref</code>에 비인수 생성자가 없는 비 serializable 조상 ''{0}''이(가) 있습니다. \#loc
transient.field.in.non.serializable.class.problem.descriptor=필드 ''{0}''이(가) 비 serializable 클래스에서 <code>\#ref</code>(으)로 표시되었습니다. \#loc
safe.lock.problem.descriptor=''{0}''은(는) ''try'' 블록 앞에서 잠기고 해당하는 ''finally'' 블록에서 잠금 해제되어야 합니다. \#loc
synchronized.method.problem.descriptor=메소드 ''{0}()''이(가) <code>\#ref</code>(으)로 선언되었습니다. \#loc
synchronized.method.include.option=네이티브 메소드 포함
synchronized.method.ignore.synchronized.super.option=동기화된 메소드를 재정의하는 메소드 무시
synchronized.method.move.quickfix=동기화를 메소드로 이동합니다.
volatile.field.problem.descriptor=유형 ''{0}''의 휘발성 필드 <code>\#ref</code> \#loc
string.format.choose.class=formatter 클래스 선택
string.format.class.column.name=추가 formatter 클래스
string.format.class.method.name=추가 formatter 메소드
exception.class.column.name=예외 클래스
bad.exception.thrown.problem.descriptor=금지된 예외 ''{0}''이(가) 던져졌습니다. \#loc
too.broad.catch.problem.descriptor=<code>\#ref</code>의 ''catch''가 너무 넓어 예외 ''{0}''을(를) 마스킹합니다. \#loc
too.broad.catch.problem.descriptor1=<code>\#ref</code>의 ''catch''가 너무 넓어 예외 ''{0}'' 및 ''{1}''을(를) 마스킹합니다. \#loc
add.serialversionuidfield.quickfix='serialVersionUID' 필드를 추가합니다.
delete.import.quickfix=불필요한 import 문 삭제
encapsulate.variable.quickfix=필드 ''{0}''을(를) 캡슐화합니다.
extract.method.quickfix=메소드 추출
inline.call.quickfix=호출을 인라인화합니다.
inline.variable.quickfix=인라인 변수
pointless.nullcheck.display.name=메소드 호출 전 불필요한 'null' 검사
pointless.nullcheck.problem.descriptor.call=''{0}()'' 호출 전 불필요한 ''null'' 검사
remove.redundant.polyadic.operand.fix.name=불필요한 ''{0}'' 조건을 제거합니다.
remove.redundant.polyadic.operand.fix.family.name=불필요한 조건 제거
introduce.constant.quickfix=상수를 삽입합니다.
make.initialization.explicit.quickfix=초기화를 명시적으로 만듭니다.
move.anonymous.to.inner.quickfix=이름 지정된 내부 클래스로 변환합니다.
anonymous.inner.may.be.named.static.inner.class.quickfix=이름 지정된 'static' 내부 클래스로 변환합니다.
move.class.quickfix=클래스를 이동합니다.
normalize.declaration.quickfix=개별 선언으로 분할합니다.
remove.modifier.quickfix=''{0}'' 제어자를 제거합니다
replace.inheritance.with.delegation.quickfix=상속을 위임으로 대체합니다.
cast.that.loses.precision.problem.descriptor=''{0}''에서 <code>\#ref</code>(으)로 형 변환하면 정확성이 손실될 수 있습니다. \#loc
cast.that.loses.precision.negative.problem.descriptor=''{0}''에서 <code>\#ref</code>(으)로 형 변환하면 음의 인수 정확성이 손실될 수 있습니다. \#loc
comparison.to.nan.problem.descriptor1=<code>\#ref</code>와(과)의 비교는 항상 false입니다. \#loc
comparison.to.nan.problem.descriptor2=<code>\#ref</code>와(과)의 비교는 항상 true입니다. \#loc
confusing.floating.point.literal.change.quickfix=표준 형식으로 변경합니다.
implicit.numeric.conversion.ignore.widening.conversion.option=변환 확장 무시
implicit.numeric.conversion.ignore.char.conversion.option=char에서 및 char로의 변환 무시
implicit.numeric.conversion.ignore.constant.conversion.option=상수 및 리터럴에서의 변환 무시
implicit.numeric.conversion.problem.descriptor=<code>\#ref</code>을(를) ''{0}''에서 ''{1}''(으)로 묵시적 숫자 변환합니다. \#loc
implicit.numeric.conversion.assignment.problem.descriptor=결과 값을 ''{0}''에서 ''{1}''(으)로 묵시적 숫자 변환합니다. \#loc
implicit.numeric.conversion.make.explicit.quickfix=변환을 명시적으로 만듭니다.
non.reproducible.math.call.replace.quickfix='StrictMath' 호출로 대체합니다.
overly.complex.arithmetic.expression.max.number.option=최대 항 수\:
expression.can.be.replaced.problem.descriptor=<code>\#ref</code>을(를) ''{0}''(으)로 대체할 수 있습니다. \#loc
method.complexity.limit.option=메소드 복잡성 제한\:
expression.can.be.replaced.no.quotes.problem.descriptor={0}을(를) {0}(으)로 대체할 수 있습니다.
cyclomatic.complexity.problem.descriptor=지나치게 복잡한 메소드 <code>\#ref()</code>(순환 복잡도 \= {0}) \#loc
method.coupling.limit.option=메소드 결합 제한\:
method.coupling.problem.descriptor=<code>\#ref</code>이(가) 지나치게 결합되었습니다(참조된 클래스 수 \= {0}). \#loc
method.with.multiple.loops.problem.descriptor=<code>\#ref</code>에 {0}개의 루프가 있습니다. \#loc
return.point.limit.option=반환점 제한(&R)\:
multiple.return.points.per.method.problem.descriptor=<code>\#ref</code>에 {0}개의 반환점이 있습니다. \#loc
nesting.depth.limit.option=중첩 깊이 제한\:
nesting.depth.problem.descriptor=<code>\#ref</code>이(가) 지나치게 중첩되었습니다(최대 중첩 깊이 \= {0}). \#loc
non.comment.source.statements.limit.option=주석이 아닌 소스 구문 제한\:
non.comment.source.statements.problem.descriptor=<code>\#ref</code>이(가) 너무 깁니다(주석이 아닌 소스 구문 수 \= {0}). \#loc
parameters.per.method.problem.descriptor=<code>\#ref()</code>에 매개변수가 너무 많습니다(매개변수 수 \= {0}). \#loc
parameters.per.constructor.problem.descriptor=<code>\#ref()</code>에 매개변수가 너무 많습니다(매개변수 수 \= {0}). \#loc
parameter.limit.option=매개변수 제한\:
constructor.visibility.option=가시성이 있는 생성자 무시\:
three.negations.per.method.ignore.option='equals()' 메소드의 부정 무시
three.negations.per.method.ignore.assert.option='assert' 문의 부정 무시
three.negations.per.method.problem.descriptor=<code>\#ref</code>에 {0}개의 부정이 있습니다. \#loc
thrown.exceptions.per.method.problem.descriptor=<code>\#ref</code>에 선언된 예외가 너무 많습니다(예외 수 \= {0}). \#loc
thrown.exceptions.per.method.limit.option=던져진 예외 제한\:
call.to.simple.getter.in.class.ignore.option=다른 객체의 getter 호출 무시
call.to.private.simple.getter.in.class.option=getter가 'private'인 경우에만 보고
call.to.simple.getter.in.class.inline.quickfix=getter 호출을 인라인화합니다
call.to.simple.setter.in.class.ignore.option=다른 객체의 setter 호출 무시
call.to.private.setter.in.class.option=setter가 'private'인 경우에만 보고
call.to.simple.setter.in.class.inline.quickfix=setter 호출을 인라인화합니다.
make.static.quickfix='static'으로 설정합니다.
length.one.strings.in.concatenation.replace.quickfix=문자로 대체합니다.
multiply.or.divide.by.power.of.two.replace.quickfix=시프트로 대체합니다.
boolean.expression.can.be.simplified.problem.descriptor=<code>\#ref</code>을(를) ''{0}''(으)로 단순화할 수 있습니다. \#loc
boolean.expression.does.not.modify.problem.descriptor=<code>\#ref</code>이(가) ''{0}'' 값을 한정하지 않습니다. \#loc
boolean.expression.remove.compound.assignment.quickfix=무의미한 복합 대입을 제거합니다.
trivial.string.concatenation.problem.descriptor=연결에 사용되는 빈 문자열
string.replace.quickfix=연결을 ''{0}''(으)로 대체합니다.
instantiating.object.to.get.class.object.replace.quickfix=클래스 객체 직접 액세스로 대체합니다.
method.may.be.static.only.option='private' 또는 'final' 메소드만 검사
method.may.be.static.empty.option=빈 메소드 무시
string.concatenation.in.loops.only.option=문자열이 반복적으로 추가되는 경우에만 경고
string.concatenation.inside.string.buffer.append.replace.quickfix=체인 'append()' 호출로 대체합니다.
string.equals.empty.string.option.do.not.add.null.check=null 검사가 필요한 경우 보고 안 함
tail.recursion.replace.quickfix=꼬리 재귀를 반복으로 대체합니다.
if.statement.with.too.many.branches.max.option=최대 브랜치 수\:
if.statement.with.too.many.branches.problem.descriptor=<code>\#ref</code>에 브랜치가 너무 많습니다({0}). \#loc
negated.conditional.invert.quickfix=조건을 반전시킵니다.
negated.if.else.ignore.negated.null.option='\!\=null' 비교 무시
negated.if.else.ignore.negated.zero.option='\!\= 0' 비교 무시
negated.if.else.invert.quickfix='if' 조건을 반전시킵니다.
overly.complex.boolean.expression.max.terms.option=최대 항 수\:
pointless.boolean.expression.ignore.option=무의미한 표현식 결정 시 이름 지정된 상수 무시
simplifiable.conditional.expression.problem.descriptor=<code>\#ref</code>을(를) ''{0}''(으)로 단순화할 수 있습니다. \#loc
switch.statement.density.min.option=최소 브랜치 밀도\: %
switch.statement.density.problem.descriptor=<code>\#ref</code>의 브랜치 밀도가 너무 낮습니다({0}%). \#loc
switch.statement.with.too.few.branches.min.option=최소 브랜치 수\:
switch.statement.with.too.few.branches.problem.descriptor=''switch'' 문에 case 라벨이 너무 적어({0}) ''if'' 문으로 대체해야 할 것입니다. \#loc
switch.statement.with.single.default.message='switch' 문에 'default' case만 있습니다.
switch.expression.with.too.few.branches.problem.descriptor=''switch'' 식에 case 라벨이 너무 적어({0}) ''if'' 문 또는 조건 연산자로 대체해야 할 것입니다. \#loc
switch.expression.with.single.default.message='switch' 식에 'default' case만 있습니다.
switch.statement.without.default.ignore.option=열거형 유형의 모든 case가 포함되는 경우 무시
unnecessary.label.remove.quickfix=라벨을 제거합니다.
unnecessary.return.problem.descriptor='void' 메소드의 마지막 구문으로서 <code>\#ref</code>은(는) 불필요합니다. \#loc
unnecessary.return.constructor.problem.descriptor=생성자의 마지막 구문으로서 <code>\#ref</code>은(는) 불필요합니다. \#loc
unused.label.remove.quickfix=사용되지 않는 라벨을 제거합니다.
unnecessarily.qualified.static.usage.problem.descriptor=static 메소드 호출 <code>{0}()</code>이(가) 불필요하게 정규화되었습니다. \#loc
unnecessarily.qualified.static.usage.problem.descriptor1=static 액세스 <code>{0}()</code>이(가) 불필요하게 정규화되었습니다. \#loc
unnecessarily.qualified.static.usage.ignore.field.option=불필요하게 정규화된 필드 액세스 무시
unnecessarily.qualified.static.usage.ignore.method.option=불필요하게 정규화된 메소드 호출 무시
unnecessary.interface.modifier.problem.descriptor=제어자 <code>\#ref</code>이(가) 인터페이스와 중복됩니다 \#loc
unnecessary.interface.modifier.inner.interface.of.interface.problem.descriptor=제어자 <code>\#ref</code>이(가) 내부 인터페이스와 중복됩니다 \#loc
unnecessary.interface.modifier.problem.descriptor2=제어자 <code>\#ref</code>이(가) 인터페이스 메소드와 중복됩니다 \#loc
unnecessary.interface.modifier.problem.descriptor3=제어자 <code>\#ref</code>이(가) 인터페이스의 내부 클래스와 중복됩니다 \#loc
unnecessary.interface.modifier.problem.descriptor4=제어자 <code>\#ref</code>이(가) 인터페이스 필드와 중복됩니다 \#loc
smth.unnecessary.remove.quickfix=불필요한 ''{0}''을(를) 제거합니다.
unqualified.static.usage.problem.descriptor=static 메소드 호출 <code>{0}()</code>이(가) 정규화되지 않았습니다. \#loc
unqualified.static.usage.problem.descriptor1=static 필드 액세스 <code>{0}()</code>이(가) 정규화되지 않았습니다. \#loc
unqualified.static.usage.ignore.field.option=정규화되지 않은 필드 액세스 무시
unqualified.static.usage.ignore.method.option=정규화되지 않은 메소드 호출 무시
unqualified.static.usage.qualify.field.quickfix=static 필드 액세스를 정규화합니다.
unqualified.static.usage.qualify.method.quickfix=static 메소드 호출을 정규화합니다.
too.broad.scope.allow.option=<html>새 표현식을 이니셜라이저로 사용하는 변수 보고<br>(잠재적으로 안전하지 않음\: 생성자에 비지역 부작용이 있는 경우 빠른 수정에서 의미를 수정할 수 있음)</html>
too.broad.scope.only.blocks.option=내부 블록으로 이동할 수 있는 변수만 보고
too.broad.scope.narrow.quickfix=''{0}''의 선언을 사용 위치 가까이로 이동합니다.
press.escape.to.remove.highlighting.message=강조 표시를 제거하려면 ESC를 누릅니다.
unnecessary.enum.modifier.problem.descriptor=제어자 <code>\#ref</code>이(가) 열거형 생성자와 중복됩니다 \#loc
unnecessary.enum.modifier.problem.descriptor1=제어자 <code>\#ref</code>이(가) 내부 열거형과 중복됩니다 \#loc
literal.as.arg.to.string.equals.problem.descriptor=리터럴 <code>\#ref</code>은(는) ''{0}()''의 한정자가 아닌 인수입니다. \#loc
literal.as.arg.to.string.equals.flip.quickfix=''{0}()''을(를) 반전시킵니다.
c.style.array.declaration.replace.quickfix=Java 스타일 배열 선언으로 대체합니다.
chained.method.call.ignore.option=필드 이니셜라이저의 체인 메소드 호출 무시
chained.method.call.ignore.self.types.option=둘러싸는 클래스와 동일한 유형을 반환하는 메소드 호출 무시
introduce.variable.quickfix=변수 소개
introduce.variable.may.change.semantics.quickfix=변수를 삽입합니다(의미가 변경될 수 있음).
flip.comparison.quickfix=비교를 반전시킵니다.
control.flow.statement.without.braces.add.quickfix=구문에 중괄호를 추가합니다.
control.flow.statement.without.braces.message=''{0}'' 문에 중괄호를 추가합니다.
extends.object.remove.quickfix=중복 'extends Object'를 제거합니다.
implicit.call.to.super.ignore.option='java.lang.Object'의 직접 하위 클래스 무시
implicit.call.to.super.make.explicit.quickfix='super()'를 명시적으로 호출합니다.
missorted.modifiers.require.option=어노테이션 순서 검사
missorted.modifiers.typeuse.before.type.option=대상 TYPE_USE 어노테이션은 항상 유형 앞에 작성
missorted.modifiers.sort.quickfix=제어자 정렬
nested.method.call.ignore.option=필드 이니셜라이저의 중첩된 메소드 호출 무시
ignore.calls.to.static.methods=정적 메소드 호출 무시
ignore.calls.to.property.getters=프로퍼티 getter 호출 무시
redundant.field.initialization.remove.quickfix=이니셜라이저를 제거합니다.
redundant.implements.remove.quickfix=중복 인터페이스 선언을 제거합니다.
unnecessary.constructor.remove.quickfix=중복 생성자를 제거합니다.
unnecessary.fully.qualified.name.replace.quickfix=정규화된 이름을 import 문으로 대체합니다.
unnecessary.fully.qualified.name.remove.quickfix=불필요한 정규화를 제거합니다.
unnecessary.fully.qualified.name.status.bar.escape.highlighting.message={0}개의 정규화된 {0, choice, 1\#이름|2\#이름}이 import 문으로 대체되었습니다(강조 표시를 제거하려면 Escape를 누르세요)
unnecessary.parentheses.remove.quickfix=불필요한 소괄호를 제거합니다.
unnecessary.qualifier.for.this.remove.quickfix=불필요한 한정자를 제거합니다.
unnecessary.semicolon.remove.quickfix=불필요한 세미콜론을 제거합니다.
unnecessary.super.constructor.remove.quickfix=불필요한 'super()'를 제거합니다.
unnecessary.this.remove.quickfix=불필요한 'this' 한정자를 제거합니다.
overly.strong.type.cast.problem.descriptor=<code>\#ref</code>(으)로 형 변환하면 ''{0}''(으)로 약화될 수 있습니다. \#loc
field.count.inspection.include.constant.fields.in.count.checkbox=계산 시 상수 필드 포함
field.count.inspection.static.final.fields.count.as.constant.checkbox='static final' 필드를 상수 계산
field.count.inspection.include.enum.constants.in.count=계산 시 열거형 상수 포함
make.method.final.fix.name=메소드 ''{0}()''을(를) ''final''로 설정
make.class.final.fix.name=클래스 ''{0}''을(를) ''final''로 설정
non.boolean.method.name.must.not.start.with.question.display.name=부울이 아닌 메소드 이름은 질문 단어로 시작하면 안 됩니다.
non.boolean.method.name.must.not.start.with.question.problem.descriptor=부울이 아닌 메소드 이름 <code>\#ref</code>이(가) 질문 단어로 시작합니다. \#loc
boolean.constructor.simplify.quickfix=단순화
unnecessary.temporary.on.conversion.from.string.problem.descriptor=<code>\#ref</code>을(를) ''{0}''(으)로 단순화할 수 있습니다. \#loc
only.report.qualified.static.usages.option=static 컨텍스트의 정규화된 static 액세스만 보고
unqualified,static.usage.only.report.static.usages.option=비 static 컨텍스트의 정규화된 static 액세스만 보고
assignment.to.catch.block.parameter.problem.descriptor='catch' 블록 매개변수 <code>\#ref</code>에 대입되었습니다. \#loc
assignment.to.method.parameter.problem.descriptor=메소드 매개변수 <code>\#ref</code>에 대입되었습니다. \#loc
value.of.post.increment.problem.descriptor=후행 증가 표현식 <code>\#ref</code>의 값이 사용되었습니다. \#loc
value.of.post.decrement.problem.descriptor=후행 감소 표현식 <code>\#ref</code>의 값이 사용되었습니다. \#loc
value.of.pre.increment.problem.descriptor=선행 증가 표현식 <code>\#ref</code>의 값이 사용되었습니다. \#loc
value.of.pre.decrement.problem.descriptor=선행 감소 표현식 <code>\#ref</code>의 값이 사용되었습니다. \#loc
assignment.replaceable.with.operator.assignment.problem.descriptor=<code>\#ref</code>을(를) ''{0}''(으)로 단순화할 수 있습니다. \#loc
assignment.replaceable.with.operator.assignment.ignore.conditional.operators.option=조건 연산자 무시
assignment.replaceable.with.operator.assignment.ignore.obscure.operators.option=모호한 ^ 및 % 연산자 무시
object.equality.ignore.between.objects.of.a.type.with.only.private.constructors.option='private' 생성자만 있는 유형의 객체 사이에 있는 '\=\=' 무시
redundant.method.override.display.name=메소드가 상위 메소드와 동일
redundant.method.override.problem.descriptor=메소드 <code>\#ref()</code>이(가) 상위 메소드와 동일합니다. \#loc
redundant.method.override.quickfix=중복 메소드를 제거합니다.
redundant.method.override.option.check.library.methods=라이브러리 메소드를 재정의하는 메소드 확인
refused.bequest.problem.descriptor=메소드 <code>\#ref()</code>이(가) 'super.\#ref()'을(를) 호출하지 않습니다. \#loc
refused.bequest.ignore.empty.super.methods.option=빈 상위 메소드 무시
refused.bequest.ignore.default.super.methods.option='default' 상위 메소드 무시
overly.complex.boolean.expression.ignore.option=순수 결합어 및 분리어 무시
pointless.indexof.comparison.display.name=무의미한 'indexOf()' 비교
pointless.indexof.comparison.always.true.problem.descriptor=<code>\#ref</code>이(가) 항상 true입니다. \#loc
pointless.indexof.comparison.always.false.problem.descriptor=<code>\#ref</code>이(가) 항상 false입니다. \#loc
reuse.of.local.variable.problem.descriptor=지역 변수 <code>\#ref</code> 재사용 \#loc
single.character.startswith.display.name=단일 문자 'startsWith()' 또는 'endsWith()'
single.character.startswith.problem.descriptor=단일 문자 <code>\#ref()</code>을(를) 'charAt()' 식으로 대체할 수 있습니다. \#loc
list.indexof.replaceable.by.contains.display.name='List.indexOf()' 식을 'contains()'으로 대체 가능
string.indexof.replaceable.by.contains.display.name='String.indexOf()' 식을 'contains()'로 대체 가능
overloaded.methods.with.same.number.parameters.problem.descriptor=매개변수의 수가 동일하고 이름이 <code>\#ref</code>인 여러 메소드 \#loc
overloaded.vararg.method.problem.descriptor=오버로드된 vararg 메소드 <code>\#ref()</code> \#loc
overloaded.vararg.constructor.problem.descriptor=오버로드된 vararg 생성자 <code>\#ref()</code> \#loc
cached.number.constructor.call.display.name=기본 인수가 있는 숫자 생성자 호출
cached.number.constructor.call.problem.descriptor=기본 인수가 있는 숫자 생성자 호출 \#loc
cached.number.constructor.call.ignore.string.arguments.option=문자열 인수가 있는 새 숫자 표현식 무시
cached.number.constructor.call.report.only.deprecated=생성자가 @Deprecated인 경우에만 보고
chained.equality.comparisons.problem.descriptor=체인 상등 비교 <code>\#ref</code> \#loc
confusing.octal.escape.sequence.problem.descriptor=8진 이스케이프 시퀀스 <code>\#ref</code>의 바로 뒤에 숫자가 옵니다. \#loc
field.accessed.synchronized.and.unsynchronized.option=간단한 getter와 setter도 필드 액세스로 간주됩니다
method.overrides.inaccessible.method.display.name=메소드가 상위 클래스의 메소드를 재정의
method.overrides.package.local.method.problem.descriptor=메소드 <code>\#ref()</code>이(가) 다른 패키지에 있는 하위 클래스의 package-private 메소드를 재정의합니다. \#loc
suspicious.to.array.call.display.name=의심스러운 'Collection.toArray()' 호출
suspicious.to.array.call.problem.descriptor=유형의 ''{0}[]''의 배열이 필요한데, ''{1}[]''이(가) 발견되었습니다 \#loc
suspicious.system.arraycopy.display.name=의심스러운 'System.arraycopy()' 호출
suspicious.system.arraycopy.problem.descriptor4=<code>\#ref</code>이(가) 배열 유형이 아닙니다. \#loc
suspicious.system.arraycopy.problem.descriptor5=<code>\#ref</code>이(가) 배열 유형이 아닙니다. \#loc
suspicious.system.arraycopy.problem.descriptor6=소스 매개변수 유형 ''{0}''은(는) 유형 ''{1}''의 대상 매개변수 <code>\#ref</code>에 대입할 수 없습니다. \#loc
suspicious.system.arraycopy.problem.descriptor.length.bigger.src=길이가 ''src.length - srcPos'' {0}보다 항상 깁니다.
suspicious.system.arraycopy.problem.descriptor.length.bigger.dest=길이가 ''dest.length - destPos'' {0}보다 항상 깁니다.
suspicious.system.arraycopy.problem.descriptor.ranges.intersect=교차 범위가 있는 동일한 배열로 복사합니다.
raw.use.of.parameterized.type.ignore.new.objects.option=새 객체 생성 무시
raw.use.of.parameterized.type.ignore.type.casts.option=유형 형 변환 무시
raw.use.of.parameterized.type.ignore.uncompilable.option=유형 매개변수가 컴파일되지 않는 위치 무시
raw.use.of.parameterized.type.ignore.overridden.parameter.option=재정의 메소드의 매개변수 유형 무시
method.only.used.from.inner.class.display.name=내부 클래스에서만 사용되는 private 메소드
method.only.used.from.inner.class.problem.descriptor.anonymous.extending=메소드 <code>\#ref()</code>\#loc은(는) ''{0}''을(를) 확장하는 익명 클래스에서만 사용됩니다. \#loc
method.only.used.from.inner.class.problem.descriptor.anonymous.implementing=메소드 <code>\#ref()</code>\#loc은(는) ''{0}''을(를) 구현하는 익명 클래스에서만 사용됩니다. \#loc
method.only.used.from.inner.class.problem.descriptor=메소드 <code>\#ref()</code>\#loc은(는) 내부 클래스 ''{0}''에서만 사용됩니다. \#loc
method.only.used.from.inner.class.ignore.option=익명 클래스에서 액세스된 메소드 무시(&A)
ignore.static.methods.accessed.from.a.non.static.inner.class=비 'static' 내부 클래스에서 액세스된 'static' 메소드 무시(&S)
only.report.static.methods='static' 메소드만 보고(&O)
format.decode.error.requires.both.0.and.1={0} 및 {1} 둘 다 필요합니다.
format.decode.any=임의
format.decode.date.time=날짜/시간
format.decode.char=문자
format.decode.integer.type=정수 유형
format.decode.floating.point=부동소수점
single.character.startswith.quickfix='charAt()' 식으로 대체합니다.
interface.never.implemented.option=상수만 선언하는 인터페이스 무시
size.replaceable.by.isempty.display.name='size() \=\= 0'를 'isEmpty()'로 대체 가능
size.replaceable.by.isempty.negation.ignore.option='\!isEmpty()'로 대체될 표현식 무시
ignored.classes.table=무시된 클래스
choose.class.type.to.ignore=무시할 클래스 유형 선택
loop.condition.not.updated.inside.loop.display.name=루프 변수가 루프 내에서 업데이트되지 않음
loop.variable.not.updated.inside.loop.problem.descriptor=변수 '\#ref'이(가) 루프 내에서 업데이트되지 않습니다. \#loc
loop.condition.not.updated.inside.loop.problem.descriptor=조건 '\#ref'이(가) 루프 내에서 업데이트되지 않습니다. \#loc
loop.variable.not.updated.inside.loop.option.nonlocal=가능한 비 로컬 변경 내용 무시
utility.class.without.private.constructor.option=메인 메소드만 있는 클래스 무시
super.class.logger.option=상위 클래스에서 선언된 액세스 가능한 로거가 있는 클래스 무시
static.method.only.used.in.one.class.display.name=static 멤버가 다른 클래스에서만 사용됨
static.method.only.used.in.one.class.problem.descriptor=static {0, choice, 1\#메소드|2\#필드} <code>\#ref{0, choice, 1\#()|2\#}</code>이(가) 클래스 ''{1}''에서만 사용됩니다. \#loc
static.method.only.used.in.one.anonymous.class.problem.descriptor=static {0, choice, 1\#메소드|2\#필드} <code>\#ref{0, choice, 1\#()|2\#}</code>이(가) ''{1}''에서 파생된 익명 클래스에서만 사용됩니다. \#loc
static.method.only.used.in.one.class.quickfix={0} 을(를) 사용 위치 클래스로 이동
static.method.only.used.in.one.class.ignore.test.option=테스트 클래스에서만 사용되는 경우 무시
static.method.only.used.in.one.class.ignore.anonymous.option=익명 클래스에서만 사용되는 경우 무시
static.method.only.used.in.one.class.ignore.on.conflicts=충돌 없이 메소드를 이동할 수 없는 경우 무시
static.method.only.used.in.one.class.ignore.utility.classes=유틸리티 클래스에 있는 멤버 무시
unary.plus.display.name=단항 덧셈
unary.plus.problem.descriptor=단항 <code>\#ref</code> 연산자 \#loc
await.without.corresponding.signal.display.name=해당하는 'signal()'이 없는 'await()'
await.without.corresponding.signal.problem.descriptor=해당하는 <code>signal()</code> 또는 <code>signalAll()</code> 없이 <code>\#ref</code>을(를) 호출합니다. \#loc
signal.without.corresponding.await.display.name=해당하는 'await()'가 없는 'signal()'
signal.without.corresponding.await.problem.descriptor=해당하는 <code>await()</code> 없이 <code>\#ref</code>을(를) 호출합니다. \#loc
wait.without.corresponding.notify.display.name=해당하는 'notify()'가 없는 'wait()'
wait.without.corresponding.notify.problem.descriptor=해당하는 <code>notify()</code> 또는 <code>notifyAll()</code> 없이 <code>\#ref</code>을(를) 호출합니다. \#loc
notify.without.corresponding.wait.display.name=해당하는 'wait()'가 없는 'notify()'
notify.without.corresponding.wait.problem.descriptor=해당하는 <code>wait()</code> 없이 <code>\#ref</code>을(를) 호출합니다. \#loc
integer.multiplication.implicit.cast.to.long.display.name=정수 곱하기 또는 시프트가 long으로 묵시적 형 변환
integer.multiplication.implicit.cast.to.long.problem.descriptor=\#ref\: 정수 곱하기가 long으로 묵시적 형 변환을 합니다. \#loc
integer.multiplication.implicit.cast.to.long.quickfix=long으로 형 변환합니다.
integer.shift.implicit.cast.to.long.problem.descriptor=\#ref\: 정수가 long으로 묵시적 형 변환 시프트 \#loc
integer.multiplication.implicit.cast.to.long.option=<html>오버플로가 불가능하다는 것이 정적으로 입증된 표현식 무시</html>
wait.or.await.without.timeout.display.name=시간 제한 없는 'wait()' 또는 'await()'
wait.or.await.without.timeout.problem.descriptor=시간 제한 없는 <code>\#ref</code> \#loc
method.return.always.constant.display.name=메소드가 클래스별 상수를 반환
method.return.always.constant.problem.descriptor=메소드 <code>\#ref()</code> 및 모든 파생 항목이 항상 상수를 반환합니다.
class.with.too.many.dependencies.display.name=종속 요소가 너무 많은 클래스
class.with.too.many.dependencies.problem.descriptor=클래스 ''{0}''에 종속 요소가 너무 많습니다({1} > {2}).
class.with.too.many.transitive.dependencies.display.name=이행적 종속 요소가 너무 많은 클래스
class.with.too.many.transitive.dependencies.problem.descriptor=클래스 ''{0}''에 이행적 종속 요소가 너무 많습니다({1} > {2}).
class.with.too.many.dependents.display.name=종속자가 너무 많은 클래스
class.with.too.many.dependents.problem.descriptor=클래스 ''{0}''에 종속자가 너무 많습니다({1} > {2}).
class.with.too.many.transitive.dependents.display.name=이행적 종속자가 너무 많은 클래스
class.with.too.many.transitive.dependents.problem.descriptor=클래스 ''{0}''에 이행적 종속 요소가 너무 많습니다({1} > {2}).
class.with.too.many.dependencies.max.option=최대 종속 요소 수
class.with.too.many.dependents.max.option=최대 종속자 수
class.with.too.many.transitive.dependencies.max.option=최대 이행적 종속 요소 수
class.with.too.many.transitive.dependents.max.option=최대 이행적 종속자 수
cyclic.class.dependency.display.name=순환 클래스 종속 요소
cyclic.class.dependency.problem.descriptor=클래스 ''{0}''이(가) {1}개의 다른 클래스에 순환적으로 의존합니다.
cyclic.class.dependency.1.problem.descriptor=클래스 ''{0}''이(가) 클래스 ''{1}''에 순환적으로 의존합니다.
cyclic.class.dependency.2.problem.descriptor=클래스 ''{0}''이(가) 클래스 ''{1}'' 및 ''{2}''에 순환적으로 의존합니다.
cyclic.package.dependency.display.name=순환 패키지 종속 요소
cyclic.package.dependency.problem.descriptor=패키지 ''{0}''이(가) {1}개의 다른 패키지에 순환적으로 의존합니다.
cyclic.package.dependency.1.problem.descriptor=패키지 ''{0}''이(가) 패키지 ''{1}''에 순환적으로 의존합니다.
cyclic.package.dependency.2.problem.descriptor=패키지 ''{0}''이(가) 패키지 ''{1}'' 및 ''{2}''에 순환적으로 의존합니다.
class.unconnected.to.package.display.name=해당 패키지에 의존하지 않는 클래스
class.unconnected.to.package.problem.descriptor=클래스 <code>\#ref</code>의 패키지에 종속 요소나 종속자가 없습니다.
exception.package.display.name=예외 패키지
exception.package.problem.descriptor=패키지 ''{0}''에 예외 클래스만 있습니다.
package.with.too.many.classes.display.name=클래스가 너무 많은 패키지
package.with.too.many.classes.problem.descriptor=패키지 ''{0}''에 클래스가 너무 많습니다({1} > {2}).
package.with.too.many.classes.max.option=최대 클래스 수\:
package.with.too.few.classes.display.name=클래스가 너무 적은 패키지
package.with.too.few.classes.problem.descriptor=패키지 ''{0}''에 클래스가 너무 적습니다({1} < {2}).
package.with.too.few.classes.min.option=최소 클래스 수\:
suspicious.package.private.access.display.name=의심스러운 package-private 액세스
groups.of.modules.loaded.together.label=함께 로드되는 모듈 그룹\:
groups.of.modules.loaded.together.description=동일한 클래스 로더로 로드되는 것으로 알려지고 쉼표로 구분된 모듈 이름 목록을 각 줄에서 지정하므로 이러한 모듈 간의 package-private 멤버에 대한 액세스가 보고되어서는 안 됩니다.
module.with.too.many.classes.display.name=클래스가 너무 많은 모듈
module.with.too.many.classes.problem.descriptor=모듈 ''{0}''에 클래스가 너무 많습니다({1} > {2}).
module.with.too.many.classes.max.option=최대 클래스 수\:
module.with.too.few.classes.display.name=클래스가 너무 적은 모듈
module.with.too.few.classes.problem.descriptor=모듈 ''{0}''에 클래스가 너무 적습니다({1} < {2}).
module.with.too.few.classes.min.option=최소 클래스 수\:
package.in.multiple.modules.display.name=여러 모듈의 클래스가 있는 패키지
package.in.multiple.modules.problem.descriptor=패키지 ''{0}''에 여러 모듈의 클래스가 있습니다.
disjoint.package.display.name=분리 종속 요소 그래프가 있는 패키지
disjoint.package.problem.descriptor=패키지 {0}이(가) {1}개의 독립적 패키지로 분해될 수 있습니다.
package.naming.convention.display.name=패키지 이름 지정 규칙
package.naming.convention.problem.descriptor.short=패키지 이름 <code>{0}</code>이(가) 너무 짧습니다.
package.naming.convention.problem.descriptor.long=패키지 이름 <code>{0}</code>이(가) 너무 깁니다.
package.naming.convention.problem.descriptor.regex.mismatch=패키지 이름 <code>{0}</code>이(가) 정규식 ''{1}''와(과) 일치하지 않습니다.
cyclic.class.initialization.display.name=순환 클래스 초기화 종속 요소
cyclic.class.initialization.problem.descriptor=클래스 ''{0}''의 초기화가 {1}개의 다른 클래스에 순환적으로 의존합니다.
before.or.after.is.public.void.no.arg.display.name=형식이 잘못된 @Before 또는 @After 메소드
before.or.after.is.public.void.no.arg.problem.descriptor=<code>\#ref()</code>에 @Before 또는 @After 메소드에 대한 잘못된 시그니처가 있습니다 \#loc
before.class.or.after.class.is.public.static.void.no.arg.display.name=형식이 잘못된 @BeforeClass/@BeforeAll 또는 @AfterClass/@AfterAll 메소드
before.class.or.after.class.is.public.static.void.no.arg.problem.descriptor=<code>\#ref()</code>에 @{0} 메소드에 대한 잘못된 시그니처가 있습니다 \#loc
design.for.extension.display.name=확장을 위한 설계
design.for.extension.problem.descriptor=메소드 <code>\#ref()</code>이(가) 재정의되어 해당 기능이 무시될 수 있습니다. \#loc
bad.oddness.display.name=의심스러운 홀수 테스트
bad.oddness.problem.descriptor=홀수 <code>\#ref</code> 테스트는 음수 값에서 실패합니다. \#loc
comparator.not.serializable.display.name=comparator 클래스가 serializable로 선언되지 않음
comparator.not.serializable.problem.descriptor=comparator 클래스 <code>\#ref</code>이(가) serializable로 선언되지 않았습니다. \#loc
non.serializable.field.in.serializable.class.display.name=serializable 클래스의 비 serializable 필드
non.serializable.field.in.serializable.class.problem.descriptor=serializable 클래스의 비 serializable 필드 '\#ref' \#loc
non.serializable.object.passed.to.object.stream.display.name=비 serializable 객체가 ObjectOutputStream으로 전달됨
non.serializable.object.passed.to.object.stream.problem.descriptor=비 serializable 객체가 ObjectOutputStream으로 전달되었습니다. \#loc
non.serializable.object.bound.to.http.session.display.name=비 serializable 객체가 HttpSession으로 바운드됨
non.serializable.object.bound.to.http.session.problem.descriptor=비 serializable 객체가 HttpSession으로 바운드되었습니다. \#loc
reflection.for.unavailable.annotation.display.name=소스 전용 어노테이션에 대한 리플렉티브 액세스
reflection.for.unavailable.annotation.problem.descriptor=어노테이션 '\#ref'이(가) 리플렉티브 액세스가 가능하도록 되어 있지 않습니다 \#loc
access.to.static.field.locked.on.instance.display.name=static 필드에 대한 액세스가 인스턴스 데이터에서 잠겨 있음
access.to.static.field.locked.on.instance.problem.descriptor=static 필드 <code>\#ref</code>에 대한 액세스가 인스턴스 데이터에서 잠겨 있습니다. \#loc
make.method.ctr.quickfix=메소드 생성자 생성
replace.all.dot.display.name=의심스러운 정규식 인수
replace.all.dot.problem.descriptor=''{0}()'' 호출에 의심스러운 정규식 \#ref이(가) 있습니다. \#loc
replace.all.dot.quickfix=정규식 메타 문자를 이스케이프합니다.
class.extends.utility.class.display.name=클래스가 유틸리티 클래스를 확장
class.extends.utility.class.problem.descriptor=클래스 <code>\#ref</code>이(가) 유틸리티 클래스 ''{0}''을(를) 확장합니다. \#loc
class.extends.utility.class.ignore.utility.class.option=클래스 재정의가 유틸리티 클래스인 경우 무시
public.constructor.in.non.public.class.quickfix=생성자를 ''{0}''(으)로 만듭니다.
assignment.to.method.parameter.ignore.transformation.option=<html>대입이 원본 매개변수의 변형인 경우 무시</html>
type.parameter.extends.final.class.display.name=유형 매개변수가 final 클래스를 확장
type.parameter.extends.final.class.type.parameter.problem.descriptor=유형 매개변수 <code>\#ref</code>이(가) ''final'' 클래스 ''{0}''을(를) 확장합니다. \#loc
type.parameter.extends.enum.type.parameter.problem.descriptor=유형 매개변수 <code>\#ref</code>이(가) final 열거형 클래스 ''{0}''을(를) 묵시적으로 확장합니다. \#loc
type.parameter.extends.final.class.wildcard.problem.descriptor=와일드카드 유형 인수 <code>\#ref</code>이(가) ''final'' 클래스 ''{0}''을(를) 확장합니다. \#loc
type.parameter.extends.enum.wildcard.problem.descriptor=와일드카드 유형 인수 <code>\#ref</code>이(가) final 열거형 클래스 ''{0}'' 을(를) 묵시적으로 확장합니다. \#loc
type.parameter.extends.final.class.quickfix=유형 매개변수를 실제 클래스로 대체합니다.
double.negation.display.name=이중 부정
double.negation.problem.descriptor=<code>\#ref</code>에 이중 부정이 있습니다. \#loc
double.negation.quickfix=이중 부정을 제거합니다.
exception.from.catch.which.doesntwrap.ignore.option=예외 메소드 호출의 결과가 사용되는 경우 무시
exception.from.catch.which.doesntwrap.ignore.cant.wrap.option=던져진 예외가 예외를 래핑할 수 없는 경우 무시
comparable.implemented.but.equals.not.overridden.display.name=Comparable은 구현되었으나 'equals()'가 재정의되지 않음
comparable.implemented.but.equals.not.overridden.problem.descriptor=클래스 <code>\#ref</code>이(가) 'java.lang.Comparable'을 구현하지만 'equals()'는 재정의하지 않습니다. \#loc
unqualified.field.access.display.name=인스턴스 필드 액세스가 'this'로 정규화되지 않음
unqualified.field.access.problem.descriptor=인스턴스 필드 액세스 <code>\#ref</code>이(가) 'this'로 정규화되지 않았습니다. \#loc
unqualified.method.access.display.name=인스턴스 메소드 호출이 'this'로 정규화되지 않음
unqualified.method.access.problem.descriptor=인스턴스 메소드 호출 <code>\#ref</code>이(가) 'this'로 정규화되지 않았습니다. \#loc
add.this.qualifier.quickfix='this' 한정자를 추가합니다.
while.loop.spins.on.field.ignore.non.empty.loops.option=루프가 비어 있는 경우에만 경고
method.may.be.synchronized.problem.descriptor=동기화된 블록이 있는 메소드 <code>\#ref()</code>은(는) 동기화된 메소드가 될 수 있습니다. \#loc
method.may.be.synchronized.display.name=동기화된 블록이 있는 메소드는 동기화된 메소드가 될 수 있음
method.may.be.synchronized.quickfix=메소드를 동기화하고 동기화된 블록을 제거합니다.
fallthru.in.switch.statement.quickfix='break'를 추가합니다.
law.of.demeter.display.name=메소드 호출이 데메테르의 법칙을 위반
law.of.demeter.problem.descriptor=<code>\#ref()</code> 호출이 데메테르의 법칙을 위반합니다. \#loc
law.of.demeter.ignore.library.calls.option=라이브러리 메소드의 호출 무시
assertequals.between.inconvertible.types.display.name=변환할 수 없는 유형의 객체 간의 'assertequals()'
assertequals.between.inconvertible.types.problem.descriptor=<code>\#ref()</code>이(가) 변환할 수 없는 유형인 ''{0}'' 및 ''{1}''의 객체 사이에 있습니다. \#loc
assertnotequals.between.inconvertible.types.problem.descriptor=어설션이 중복되었을 수 있습니다. 호환되지 않는 유형, ''{0}'' 및 ''{1}''이(가) 비교됩니다.
assertnotsame.between.inconvertible.types.problem.descriptor=어설션이 중복되었습니다. 호환되지 않는 유형, ''{0}'' 및 ''{1}''이(가) 비교됩니다.
enumeration.can.be.iteration.display.name=열거형은 반복이 될 수 있음
enumeration.can.be.iteration.problem.descriptor=<code>\#ref()</code>을(를) ''{0}'' 구문으로 대체할 수 있습니다. \#loc
enumeration.can.be.iteration.quickfix='Iterator' 구문으로 대체합니다.
equals.hashcode.called.on.url.display.name='java.net.URL' 객체에서 'equals()' 또는 'hashCode()' 호출
equals.hashcode.called.on.url.problem.descriptor=URL 객체에서 <code>\#ref()</code>이(가) 호출됩니다. \#loc
collection.contains.url.problem.decriptor={0} <code>\#ref</code>에 URL 객체가 있습니다. \#loc
collection.contains.url.display.name=Map 또는 Set에 'java.net.URL' 객체가 있을 수 있음
implicit.array.to.string.problem.descriptor=배열 <code>\#ref</code>의 'toString()'이 묵시적으로 호출됩니다. \#loc
explicit.array.to.string.problem.descriptor=배열의 '\#ref()'이(가) 호출됩니다. \#loc
implicit.array.to.string.method.call.problem.descriptor=배열 의 'toString()'에 대한 묵시적 호출이 <code>\#ref</code> 호출로 반환됩니다. \#loc
implicit.array.to.string.display.name=배열의 'toString()' 호출
implicit.array.to.string.quickfix=''{0}'' 식으로 래핑합니다.
suspicious.indent.after.control.statement.problem.descriptor=<code>\#ref</code> 문에 의심스러운 들여쓰기가 있습니다. \#loc
suspicious.indent.after.control.statement.display.name=중괄호 없는 제어문 뒤의 의심스러운 들여쓰기
unpredictable.big.decimal.constructor.call.display.name=예측할 수 없는 BigDecimal 생성자 호출
unpredictable.big.decimal.constructor.call.problem.descriptor=예측할 수 없는 <code>new \#ref()</code> 호출 \#loc
unpredictable.big.decimal.constructor.call.ignore.references.option=변수 또는 메소드 호출 인수가 있는 생성자 호출 무시
unpredictable.big.decimal.constructor.call.ignore.complex.literals.option=여러 리터럴이 있는 생성자 호출 무시(예\: 0.1 + 0.2)
unnecessary.unary.minus.display.name=불필요한 단항 뺄셈
unnecessary.unary.minus.problem.descriptor=불필요한 단항 뺄셈 \#loc
unnecessary.unary.minus.quickfix=단항 뺄셈을 제거하고 상위 연산 기호를 반전시킵니다.
make.field.final.quickfix=''{0}''을(를) ''final''로 만듭니다.
increment.decrement.used.as.expression.quickfix=''{0}''을(를) 별도의 구문으로 추출합니다.
ignore.classes.in.hierarchy.column.name=다음의 하위 클래스 무시
overly.strong.type.cast.ignore.in.matching.instanceof.option=일치하는 instanceof 식이 있는 형 변환 무시
access.to.non.thread.safe.static.field.from.instance.display.name=Non-thread-safe 정적 필드 액세스
access.to.non.thread.safe.static.field.from.instance.field.problem.descriptor=''{0}'' 유형의 non-thread-safe 정적 필드 <code>\#ref</code>로 액세스 \#loc
access.to.non.thread.safe.static.field.from.instance.option.title=비 스레드 안전 클래스
access.to.non.thread.safe.static.field.from.instance.class.chooser.title=비 스레드 안전 클래스 선택
transient.field.not.initialized.display.name=transient 필드는 역직렬화에서 초기화되지 않음
transient.field.not.initialized.problem.descriptor=transient 필드 <code>\#ref</code>은(는) 역직렬화에서 초기화되지 않습니다. \#loc
call.to.string.concat.can.be.replaced.by.operator.display.name='String.concat()' 호출을 '+'로 대체할 수 있습니다.
call.to.string.concat.can.be.replaced.by.operator.problem.descriptor=<code>\#ref()</code> 호출을 '+' 표현식으로 대체할 수 있습니다. \#loc
call.to.string.concat.can.be.replaced.by.operator.quickfix='concat()' 호출을 '+'로 대체합니다.
new.string.buffer.with.char.argument.display.name='char' 인수가 있는 StringBuilder 생성자 호출
new.string.buffer.with.char.argument.problem.descriptor=<code>new \#ref()</code>에 유형 'char'의 인수가 있습니다. \#loc
new.string.buffer.with.char.argument.quickfix=char 인수를 문자열 리터럴로 대체합니다.
suspicious.comparator.compare.display.name=의심스러운 'Comparator.compare()' 구현
suspicious.comparator.compare.descriptor.parameter.not.used='compare()' 매개변수 <code>\#ref</code>이(가) 사용되지 않았습니다. \#loc
suspicious.comparator.compare.descriptor.non.reflexive=Comparator가 equal 요소에 대해 0을 반환하지 않습니다.
to.array.call.style.display.name='Collection.toArray()' 호출 스타일
to.array.call.style.problem.descriptor.zero=<code>\#ref()</code> 호출에 빈 배열 인수 ''{0}''이(가) 있습니다. \#loc
to.array.call.style.problem.descriptor.presized=<code>\#ref()</code> 호출에 크기가 사전 설정된 배열 인수 ''{0}''이(가) 있습니다. \#loc
to.array.call.style.quickfix.family.name='toArray' 호출로 전달된 배열의 크기 수정
to.array.call.style.quickfix.make.presized=인수를 크기가 사전 설정된 배열로 대체합니다.
to.array.call.style.quickfix.make.zero=인수를 빈 배열로 대체합니다.
throwable.instance.never.thrown.runtime.exception.problem.descriptor=런타임 예외 인스턴스 <code>\#ref</code>이(가) 던져지지 않습니다. \#loc
throwable.instance.never.thrown.checked.exception.problem.descriptor=검사된 예외 인스턴스 <code>\#ref</code>이(가) 던져지지 않습니다. \#loc
throwable.instance.never.thrown.error.problem.descriptor=오류 인스턴스 <code>\#ref</code>이(가) 던져지지 않습니다. \#loc
throwable.instance.never.thrown.problem.descriptor=throwable 인스턴스 <code>\#ref</code>이(가) 던져지지 않습니다. \#loc
ignore.guard.clauses.option=guard 절 무시(&G)
ignore.for.equals.methods.option='equals()' 메소드 무시(&E)
caught.exception.immediately.rethrown.display.name=포착된 예외가 즉시 다시 던져짐
caught.exception.immediately.rethrown.problem.descriptor=포착된 예외 <code>\#ref</code>이(가) 즉시 다시 던져집니다. \#loc
delete.catch.section.quickfix='catch' 섹션을 삭제합니다.
loop.with.implicit.termination.condition.display.name=묵시적 종료 조건이 있는 루프
loop.with.implicit.termination.condition.dowhile.problem.descriptor=<code>\#ref-while</code> 루프에 묵시적 종료 조건이 있습니다. \#loc
loop.with.implicit.termination.condition.problem.descriptor=<code>\#ref</code> 루프에 묵시적 종료 조건이 있습니다. \#loc
loop.with.implicit.termination.condition.quickfix=조건을 명시적으로 만듭니다.
rename.catch.parameter.to.ignored=''catch'' 매개변수의 이름을 ''{0}''(으)로 변경합니다.
inspection.empty.catch.block.generate.body=템플릿에서 'catch' 본문 생성
unnecessary.super.qualifier.display.name=불필요한 'super' 한정자
unnecessary.super.qualifier.problem.descriptor=한정자 <code>\#ref</code>은(는) 이 컨텍스트에서 불필요합니다. \#loc
unnecessary.super.qualifier.quickfix=불필요한 'super' 한정자를 제거합니다.
collections.field.access.replaceable.by.method.call.display.name=Collections.EMPTY_* 필드 액세스를 'Collections.empty*()' 메소드 호출로 대체 가능
collections.field.access.replaceable.by.method.call.problem.descriptor=<code>\#ref</code>을(를) ''Collections.{0}''(으)로 대체할 수 있습니다. \#loc
synchronization.on.local.variable.or.method.parameter.display.name=지역 변수 또는 메소드 매개변수 동기화
synchronization.on.local.variable.problem.descriptor=지역 변수 <code>\#ref</code> 동기화 \#loc
synchronization.on.method.parameter.problem.descriptor=메소드 매개변수 <code>\#ref</code> 동기화 \#loc
too.broad.catch.quickfix=''{0}''에 대한 ''catch'' 절을 추가합니다.
replace.with.catch.clause.for.runtime.exception.quickfix='RuntimeException'에 대한 'catch' 절로 대체합니다.
too.broad.catch.option=RuntimeException, Exception, Error 또는 Throwable에 대해서만 경고(&O)
unnecessary.conversion.to.string.display.name=문자열로 불필요한 변환
unnecessary.tostring.call.display.name=불필요한 'toString()' 호출
unnecessary.tostring.call.problem.descriptor=<code>\#ref()</code> 호출이 불필요합니다. \#loc
throwable.not.thrown.display.name=throwable이 던져지지 않음
throwable.result.of.method.call.ignored.problem.descriptor=<code>\#ref()</code>의 결과가 던져지지 않습니다. \#loc
char.used.in.arithmetic.context.display.name=산술 컨텍스트에서 'char' 표현식 사용
char.used.in.arithmetic.context.problem.descriptor=산술 컨텍스트에서 'char' <code>\#ref</code>이(가) 사용됩니다. \#loc
char.used.in.arithmetic.context.quickfix=문자열 리터럴로 변환합니다.
char.used.in.arithmetic.context.cast.quickfix=형 변환을 {0}에 삽입합니다.
unnecessary.constant.array.creation.expression.display.name=상수 배열 생성 시의 중복 'new' 표현식
unnecessary.constant.array.creation.expression.problem.descriptor=<code>\#ref</code>을(를) 배열 이니셜라이저 표현식으로 대체할 수 있습니다. \#loc
unnecessary.constant.array.creation.expression.family.quickfix=배열 이니셜라이저 표현식으로 대체합니다.
ambiguous.method.call.display.name=상속된 메소드 호출이 지역 메소드 호출처럼 보임
ambiguous.method.call.problem.descriptor=상위 클래스 ''{0}''의 메소드 <code>\#ref()</code> 호출이 클래스 ''{1}''의 메소드 호출처럼 보입니다. \#loc
ambiguous.method.call.quickfix=메소드 호출에 'super' 한정자를 추가합니다.
change.modifier.quickfix=''{0}'' 을(를) 만듭니다
the.whole.project=전체 프로젝트
this.class=이 클래스
assertequals.may.be.assertsame.display.name='assertEquals()'가 'assertSame()'이 될 수 있음
assertequals.may.be.assertsame.problem.descriptor=<code>\#ref</code>이(가) 'assertSame()'이 될 수 있습니다. \#loc
logger.initialized.with.foreign.class.problem.descriptor=로거가 외부 클래스 <code>\#ref</code>(으)로 초기화되었습니다. \#loc
logger.initialized.with.foreign.class.display.name=로거가 외부 클래스로 초기화됨
logger.factory.method.name=로거 factory 메소드 이름
logger.factory.class.name=로거 factory 클래스 이름
make.static.final.quickfix=''{0}''을(를) static final로 만듭니다.
logging.condition.disagrees.with.log.statement.display.name=로그 조건이 로깅 호출과 일치하지 않음
logging.condition.disagrees.with.log.statement.problem.descriptor=로그 조건 <code>\#ref()</code>이(가) ''{0}()'' 로깅 호출과 일치하지 않습니다. \#loc
log.statement.guarded.by.log.condition.display.name=로깅 호출이 로그 조건으로 보호되지 않음
log.statement.guarded.by.log.condition.problem.descriptor=<code>\#ref()</code> 로킹 호출이 로그 조건으로 보호되지 않습니다. \#loc
log.statement.guarded.by.log.condition.quickfix=로그 조건으로 둘러쌉니다.
log.statement.guarded.by.log.condition.flag.all.unguarded.option=로깅 호출로 보호되지 않는 모든 항목에 플래그 표시
key.set.iteration.may.use.entry.set.display.name='keySet()' 반복을 최적화할 수 있음
key.set.iteration.may.use.entry.set.problem.descriptor=<code>\#ref()</code> 반복을 ''{0}'' 반복으로 대체할 수 있습니다. \#loc
key.set.iteration.may.use.entry.set.quickfix=Map 반복을 최적화합니다.
string.replaceable.by.string.buffer.in.loop.option=루프에 추가할 때만 경고
declare.collection.as.interface.quickfix=''{0}''(으)로 약화합니다.
non.exception.name.ends.with.exception.quickfix=''{0}''이(가) ''java.lang.Exception''을 확장하도록 합니다.
constant.value.variable.use.display.name=값이 상수로 알려진 변수 사용
constant.value.variable.use.problem.descriptor=<code>\#ref</code>의 값이 상수로 알려져 있습니다. \#loc
unnecessary.parentheses.option=명확히 구분 짓는 소괄호 추가
unnecessary.parentheses.conditional.option=조건식 조건 주위의 소괄호 무시
field.may.be.final.display.name=필드가 'final'이 될 수 있음
field.may.be.final.problem.descriptor=필드 <code>\#ref</code>이(가) 'final'이 될 수 있습니다. \#loc
cast.that.loses.precision.option=int에서 및 char로의 형 변환 무시
ignore.overflowing.byte.casts.option=int 128~255에서 byte로의 형 변환 무시
variable.not.used.inside.if.display.name='null' 검사된 참조가 'if' 내부에서 사용되지 않음
variable.not.used.inside.if.problem.descriptor='null' 검사된 <code>\#ref</code>이(가) 'if' 내부에서 사용되지 않습니다. \#loc
variable.not.used.inside.conditional.problem.descriptor='null' 검사된 <code>\#ref</code>이(가) 조건 내부에서 사용되지 않습니다. \#loc
boolean.expression.may.be.conditional.display.name=부울식을 조건식으로 대체 가능
if.may.be.conditional.problem.descriptor=<code>\#ref</code>을(를) 조건식으로 대체할 수 있습니다. \#loc
if.may.be.conditional.quickfix=조건식으로 대체합니다.
redundant.string.format.call.display.name='String.format()' 중복 호출
redundant.call.problem.descriptor=<code>\#ref</code>이(가) 중복 호출됩니다. \#loc
redundant.string.format.call.quickfix='String.format()' 중복 호출을 제거합니다.
redundant.string.formatted.call.quickfix='String.formatted()' 중복 호출을 제거합니다.
junit4.test.method.in.class.extending.junit3.testcase.display.name=JUnit 3 TestCase를 확장하는 클래스 내 JUnit 4 테스트 메소드
convert.junit3.test.case.error.string=<code>\#ref</code>을(를) JUnit4 테스트 케이스로 변환할 수 있습니다.
convert.junit3.test.case.family.name=JUnit4 테스트 케이스로 변환
convert.junit3.test.case.display.name=JUnit 3 테스트가 JUnit 4가 될 수 있음
junit4.test.method.in.class.extending.junit3.testcase.problem.descriptor=클래스 내에서 '@Test'로 어노테이션이 추가된 메소드 <code>\#ref()</code>이(가) JUnit 3 TestCase를 확장합니다 \#loc
ignore.test.method.in.class.extending.junit3.testcase.problem.descriptor='@Ignore'로 어노테이션이 추가된 JUnit 3 테스트 메소드 <code>\#ref()</code>이(가) 무시되지 않습니다 \#loc
ignore.test.method.in.class.extending.junit3.testcase.quickfix=''@Ignore''를 제거하고 메소드의 이름을 ''{0}''(으)로 변경합니다.
convert.junit3.test.class.quickfix=JUnit 3 클래스 ''{0}''을(를) JUnit 4로 변환합니다.
remove.junit4.test.annotation.quickfix='@Test' 어노테이션을 제거합니다.
remove.junit4.test.annotation.and.rename.quickfix=''@Test'' 어노테이션을 제거하고 이름을 ''{0}''(으)로 변경합니다.
equals.called.on.enum.constant.display.name=enum 값에서 'equals()' 호출
equals.called.on.enum.constant.problem.descriptor=<code>\#ref()</code>이(가) enum 값에서 호출됩니다. \#loc
int.literal.may.be.long.literal.display.name='long'으로의 'int' 리터럴 형 변환이 'long' 리터럴이 될 수 있음
int.literal.may.be.long.literal.problem.descriptor=<code>\#ref</code>을(를) ''{0}''(으)로 대체할 수 있습니다. \#loc
constant.assert.condition.display.name='assert' 문 조건이 상수임
constant.assert.condition.problem.descriptor=assert 조건 <code>\#ref</code>이(가) 상수입니다. \#loc
assert.with.side.effects.display.name=부작용이 있는 'assert' 문
assert.with.side.effects.problem.descriptor=<code>\#ref</code>에 부작용 {0}이(가) 있습니다. \#loc
method.count.ignore.getters.setters.option=간단한 getter 및 setter 메소드 무시(&I)
class.new.instance.display.name=안전하지 않은 'Class.newInstance()' 호출
class.new.instance.problem.descriptor=<code>\#ref()</code> 호출이 선언되지 않고 검사되지 않은 예외를 던질 수 있습니다. \#loc
dynamic.regex.replaceable.by.compiled.pattern.display.name=동적 정규식을 컴파일된 패턴으로 대체 가능
dynamic.regex.replaceable.by.compiled.pattern.problem.descriptor=<code>\#ref</code>을(를) 컴파일된 'java.util.regex.Pattern' 구문으로 대체할 수 있습니다. \#loc
dynamic.regex.replaceable.by.compiled.pattern.quickfix=컴파일된 'Pattern' 상수의 메소드 호출로 대체합니다.
ignore.serializable.option='java.io.Serializable' 무시
ignore.cloneable.option='java.lang.Cloneable' 무시
listener.may.use.adapter.display.name=클래스가 리스너를 구현하지 않고 어댑터를 확장할 수 있음
listener.may.use.adapter.problem.descriptor=클래스 ''{0}''이(가) <code>\#ref</code>을(를) 구현하지 않고 ''{1}''을(를) 확장합니다. \#loc
listener.may.use.adapter.emtpy.methods.option=빈 구현 메소드가 발견될 경우에만 경고(&O)
unnecessary.inherit.doc.display.name=불필요한 {@inheritDoc} Javadoc 주석
unnecessary.inherit.doc.problem.descriptor=<code>\#ref</code>만 있는 Javadoc 주석은 불필요합니다. \#loc
unnecessary.inherit.doc.field.invalid.problem.descriptor=<code>\#ref</code>이(가) 필드에서 유효하지 않습니다. \#loc
unnecessary.inherit.doc.constructor.invalid.problem.descriptor=<code>\#ref</code>이(가) 생성자에서 유효하지 않습니다. \#loc
unnecessary.inherit.doc.class.invalid.problem.descriptor=<code>\#ref</code>이(가) 클래스에서 유효하지 않습니다. \#loc
unnecessary.inherit.doc.module.invalid.problem.descriptor=<code>\#ref</code>이(가) 모듈 선언에서 유효하지 않습니다. \#loc
unnecessary.inherit.doc.constructor.no.super.problem.descriptor=Javadoc에 상속할 상위 메소드를 찾을 수 없습니다. \#loc
unnecessary.inherit.doc.quickfix=불필요한 {@inheritDoc}을 제거합니다.
multiple.exceptions.declared.on.test.method.display.name=테스트 메소드에서 선언된 여러 예외
multiple.exceptions.declared.on.test.method.problem.descriptor=<code>\#ref</code>을(를) 'throws Exception'으로 대체할 수 있습니다. \#loc
unnecessary.javadoc.link.display.name=불필요한 Javadoc 링크
unnecessary.javadoc.link.super.method.problem.descriptor=상위 메소드를 가리키는 <code>\#ref</code>은(는) 불필요합니다. \#loc
unnecessary.javadoc.link.this.method.problem.descriptor=이 메소드를 가리키는 <code>\#ref</code>은(는) 불필요합니다. \#loc
unnecessary.javadoc.link.this.class.problem.descriptor=포함 메소드를 가리키는 <code>\#ref</code>은(는) 불필요합니다. \#loc
unnecessary.javadoc.link.quickfix=불필요한 ''{0}''을(를) 제거합니다.
thread.local.not.static.final.display.name=ThreadLocal 필드가 static final로 선언되지 않음
thread.local.not.static.final.problem.descriptor=ThreadLocal <code>\#ref</code>이(가) 'static final'로 선언되지 않았습니다. \#loc
remove.try.finally.block.quickfix='try-finally' 블록을 제거합니다.
remove.finally.block.quickfix='finally' 블록을 제거합니다.
remove.leading.zero.to.make.decimal.quickfix=선행 0을 제거하여 10진수를 만듭니다.
remove.leading.zeroes.to.make.decimals.quickfix=선행 0을 제거하여 10진수를 만듭니다.
convert.octal.literal.to.decimal.literal.quickfix=8진 리터럴을 10진 리터럴로 변환합니다.
convert.octal.literals.to.decimal.literals.quickfix=8진 리터럴을 10진 리터럴로 변환합니다.
ignore.single.field.static.imports.option=단일 필드 정적 import 문 무시(&F)
ignore.single.method.static.imports.option=단일 메소드 정적 import 문 무시(&M)
ignore.methods.with.boolean.return.type.option='java.lang.&amp;Boolean' 반환 유형의 메소드 무시
ignore.boolean.methods.in.an.interface.option=@interface의 부울 메소드 무시(&I)
ignore.methods.overriding.super.method=상위 메소드를 재정의/구현하는 메소드 무시(&O)
ignore.nullable.parameters.option=@Nullable 매개변수 무시
ignored.io.resource.types=무시된 I/O 리소스 유형
choose.io.resource.type.to.ignore=무시할 I/O 리소스 유형 선택
ignore.accesses.from.the.same.class=동일한 클래스로부터의 액세스 무시
ignore.accesses.from.equals.method='equals()' 메소드로부터의 액세스 무시
ignore.branches.of.switch.statements='switch' 문의 브랜치 무시
ignore.equals.hashcode.and.tostring='equals()', 'hashCode()' 및 'toString()' 메소드 무시
ignore.methods.in.anonymous.classes=익명 클래스의 메소드 무시
class.name=클래스 이름
method.name.regex=메소드 이름 정규식
choose.class=클래스 선택
query.column.name=다음으로 시작하는 쿼리 이름
update.column.name=다음으로 시작하는 업데이트 이름
assert.keyword.is.considered.an.assertion='assert' 키워드는 어설션으로 간주됩니다
expected.exception.never.thrown.display.name=테스트 메소드 본문에 예상된 예외가 던져지지 않음
expected.exception.never.thrown.problem.descriptor=예상된 <code>\#ref</code>이(가) ''{0}()'' 본문에서 전혀 던져지지 않습니다. \#loc
choose.logger.class=로거 클래스 선택
logger.class.name=로거 클래스 이름
ignore.exceptions.declared.on.library.override.option=라이브러리 메소드를 재정의하는 메소드에서 선언된 예외 무시(&L)
allow.resource.to.be.opened.inside.a.try.block='try' 블록 내에서 리소스가 열리도록 허용
any.method.may.close.resource.argument=임의의 메소드가 리소스 인수를 닫을 수 있습니다.
log.method.name=로깅 메소드 이름
log.condition.text=로그 조건 텍스트
ignore.if.annotated.by=다음으로 어노테이션이 추가된 경우 무시
ignore.parameter.if.annotated.by=다음으로 어노테이션이 추가된 경우 매개변수 무시
ignore.classes.annotated.by=다음으로 어노테이션이 추가된 클래스 무시
ignored.class.hierarchies.border.title=다음의 하위 클래스 무시
choose.class.hierarchy.to.ignore.title=무시할 클래스 계층 구조 선택
unqualified.inner.class.access.display.name=정규화되지 않은 내부 클래스 액세스
unqualified.inner.class.access.problem.descriptor=<code>\#ref</code>이(가) 외부 클래스로 정규화되지 않았습니다. \#loc
unqualified.inner.class.access.quickfix=외부 클래스로 정규화합니다.
unnecessarily.qualified.inner.class.access.problem.descriptor=''{0}''이(가) <code>\#ref</code>(으)로 불필요하게 정규화되었습니다. \#loc
unnecessarily.qualified.inner.class.access.display.name=불필요한 내부 클래스 액세스 정규화
unnecessarily.qualified.inner.class.access.quickfix=한정자 제거
synchronization.on.static.field.display.name='static' 필드 동기화
synchronization.on.static.field.problem.descriptor='static' 필드 <code>\#ref</code> 동기화 \#loc
assertequals.called.on.arrays.display.name=배열에서 'assertEquals()' 호출
assertequals.called.on.arrays.problem.descriptor=<code>\#ref()</code>이(가) 배열에서 호출됩니다. \#loc
overly.broad.throws.clause.display.name=지나치게 넓은 'throw' 절
overly.broad.throws.clause.problem.descriptor1=<code>throws \#ref</code>이(가) 너무 넓어 예외 ''{0}''을(를) 마스킹합니다. \#loc
overly.broad.throws.clause.problem.descriptor2=<code>throws \#ref</code>이(가) 너무 넓어 예외 ''{0}'' 및 ''{1}''을(를) 마스킹합니다. \#loc
overly.broad.throws.clause.quickfix1=특정 예외를 추가합니다.
overly.broad.throws.clause.quickfix2=특정 예외로 대체합니다.
overly.broad.throws.clause.ignore.thrown.option=다른 예외를 숨기면서 스스로 던져지는 예외 무시(&H)
unnecessarily.qualified.statically.imported.element.display.name=정적으로 가져온 요소가 불필요하게 정규화됨
unnecessarily.qualified.statically.imported.element.problem.descriptor=정적으로 가져온 요소 ''{0}''이(가) <code>\#ref</code>(으)로 불필요하게 정규화되었습니다. \#loc
unnecessarily.qualified.statically.imported.element.quickfix=불필요한 한정자를 제거합니다.
ignore.instanceof.on.library.classes=라이브러리 클래스의 instanceof 무시
for.can.be.foreach.option=색인 생성된 'java.util.List' 루프 보고
for.can.be.foreach.option2=유형이 없는 컬렉션 반복을 보고 안 함
cast.conflicts.with.instanceof.quickfix1=형 변환에서 ''{0}''을(를) ''{1}''(으)로 대체합니다.
cast.conflicts.with.instanceof.quickfix2=instanceof에서 ''{0}''을(를) ''{1}''(으)로 대체합니다.
double.checked.locking.quickfix=''{0}''을(를) 휘발성으로 만듭니다.
double.literal.may.be.float.literal.display.name='float'로의 'double' 리터럴 형 변환이 'float' 리터럴이 될 수 있음
multiple.declaration.ignore.for.option='for' 루프 선언 무시
multiple.declaration.array.only.option=단일 선언에서 서로 다른 배열 크기에 대해서만 경고
simplifiable.annotation.display.name=단순화 가능한 어노테이션
simplifiable.annotation.problem.descriptor=어노테이션의 <code>\#ref</code>이(가) 불필요합니다. \#loc
simplifiable.annotation.whitespace.problem.descriptor=어노테이션의 공백이 불필요합니다. \#loc
simplifiable.annotation.quickfix=어노테이션을 단순화합니다.
overloaded.methods.with.same.number.parameters.option=<html>매개변수 유형이 확실히 호환되지 않는 오버로드된 메소드 무시</html>
string.concatenation.in.format.call.display.name='format()' 호출에 대한 인수로서의 문자열 연결
string.concatenation.in.format.call.problem.descriptor=<code>\#ref()</code> 호출에 문자열 연결 인수가 있습니다. \#loc
string.concatenation.in.format.call.quickfix=연결을 별도의 인수로 대체합니다.
string.concatenation.in.message.format.call.display.name='MessageFormat.format()' 호출에 대한 인수로서의 문자열 연결
string.concatenation.in.message.format.call.problem.descriptor='MessageFormat.format()' 호출에 대한 인수로서의 문자열 연결 \#loc
boxing.boxed.value.display.name=이미 박싱된 값을 박싱
boxing.boxed.value.problem.descriptor=이미 박싱된 <code>\#ref</code>을(를) 박싱합니다. \#loc
boxing.boxed.value.quickfix=불필요한 박싱을 제거합니다.
unnecessary.javadoc.link.option=상위 메소드에 대한 인라인 링크 무시
constant.junit.assert.argument.display.name=상수 assert 인수
constant.junit.assert.argument.problem.descriptor=인수 <code>\#ref</code>이(가) 상수입니다. \#loc
test.case.with.no.test.methods.option=테스트 메소드를 사용하는 상위 클래스가 있는 TestCase 무시
package.dot.html.may.be.package.info.display.name='package.html'을 'package-info.java'로 변환할 수 있음
package.dot.html.may.be.package.info.exists.problem.descriptor=<code>package-info.java</code>가 있으므로 <code>package.html</code>이 무시됩니다.
package.dot.html.may.be.package.info.problem.descriptor=<code>package.html</code>이 <code>package-info.java</code>로 변환될 수 있습니다.
package.dot.html.may.be.package.info.delete.quickfix='package.html'을 삭제합니다.
package.dot.html.may.be.package.info.convert.quickfix='package-info.java'로 변환합니다.
choose.super.class.to.ignore=클래스 선택
ignore.anonymous.inner.classes=익명의 내부 클래스 무시
try.with.identical.catches.display.name='try' 문의 동일한 'catch' 브랜치
try.with.identical.catches.problem.descriptor=''catch'' 브랜치가 ''{0}'' 브랜치와 동일합니다. \#loc
if.can.be.switch.display.name='if'를 'switch'로 대체 가능
if.can.be.switch.problem.descriptor=<code>\#ref</code> 문을 'switch' 문으로 대체할 수 있습니다. \#loc
if.can.be.switch.minimum.branch.option=최소 'if' 조건 브랜치 수\:
if.can.be.switch.int.option=숫자에서 switch 제안
if.can.be.switch.enum.option=열거형에서 switch 제안
if.can.be.switch.null.safe.option=null 안전 표현식에서만 제안
unnecessarily.qualified.inner.class.access.option=import 문이 필요한 참조 무시
unqualified.inner.class.access.option=지역 내부 클래스에 대한 참조 무시
try.with.identical.catches.quickfix='catch' 블록을 접습니다.
confusing.else.option='if' 문 다음에 구문이 없는 경우 보고
html.tag.can.be.javadoc.tag.display.name=<code>...</code>을 {@code ...}로 대체 가능
html.tag.can.be.javadoc.tag.problem.descriptor=<code>\#ref...\\&lt;/code\\&gt;</code>을(를) '{@code ...}'로 대체할 수 있습니다 \#loc
try.finally.can.be.try.with.resources.display.name='try finally'를 리소스가 있는 'try'로 대체 가능
try.finally.can.be.try.with.resources.problem.descriptor=<code>\#ref</code>이(가) 자동 리소스 관리를 사용할 수 있습니다. \#loc
try.finally.can.be.try.with.resources.quickfix=리소스가 있는 'try'로 대체합니다.
array.comparison.display.name='Arrays.equals()' 대신 '\=\='를 사용하여 배열 비교
array.comparison.problem.descriptor=배열 객체를 'Arrays.equals()'가 아닌 <code>\#ref</code>을(를) 사용하여 비교합니다. \#loc
array.hash.code.display.name=배열에서 'hashCode()' 호출
array.hash.code.problem.descriptor=배열에서 호출된 <code>\#ref()</code>은(는) 'Arrays.hashCode()'여야 할 것입니다. \#loc
method.can.be.variable.arity.method.display.name=메소드가 vararg 메소드가 될 수 있음
method.can.be.variable.arity.method.problem.descriptor=<code>\#ref()</code>을(를) vararg 메소드로 변환할 수 있습니다. \#loc
method.can.be.variable.arity.method.ignore.byte.short.option=유형 byte[] 또는 short[]가 있는 매개변수 무시
method.can.be.variable.arity.method.ignore.all.primitive.arrays.option=모든 기본 배열 유형 무시
method.can.be.variable.arity.method.ignore.multiple.arrays.option=배열 매개변수가 여러 개인 메소드 무시
method.can.be.variable.arity.method.ignore.multidimensional.arrays.option=여러 크기의 배열 매개변수 무시
convert.to.variable.arity.method.quickfix=vararg 메소드로 변환합니다.
mismatched.string.builder.query.update.display.name=StringBuilder의 쿼리 및 업데이트 불일치
mismatched.string.builder.updated.problem.descriptor={0} <code>\#ref</code>의 내용은 업데이트되지만 쿼리되지 않습니다. \#loc
mismatched.string.builder.queried.problem.descriptor={0} <code>\#ref</code>의 내용은 쿼리되지만 업데이트되지 않습니다. \#loc
math.random.cast.to.int.display.name='int'로 'Math.random()' 형 변환
math.random.cast.to.int.problem.descriptor=''{0}''(으)로의 <code>\#ref</code> 형 변환은 항상 ''0''으로 버림됩니다. \#loc
math.random.cast.to.int.quickfix=형 변환하기 전에 곱셈을 수행하기 위해 소괄호를 추가합니다.
boolean.variable.always.inverted.display.name=부울 변수가 항상 반전됨
boolean.field.always.inverted.problem.descriptor=부울 필드 <code>\#ref</code>이(가) 항상 반전됩니다. \#loc
boolean.variable.always.inverted.problem.descriptor=부울 변수 <code>\#ref</code>이(가) 항상 반전됩니다. \#loc
unnecessary.explicit.numeric.cast.display.name=불필요한 명시적 숫자 형 변환
unnecessary.explicit.numeric.cast.problem.descriptor=''{0}''이(가) <code>\#ref</code>(으)로 불필요하게 형 변환되었습니다. \#loc
unnecessary.explicit.numeric.cast.quickfix=형 변환을 제거합니다.
null.thrown.display.name='null'이 던져짐
null.thrown.problem.descriptor=<code>\#ref</code>이(가) 던져집니다. \#loc
unnecessary.final.on.local.variable.or.parameter.display.name=지역 변수 또는 매개변수의 불필요한 'final'
unnecessary.final.on.local.variable.problem.descriptor=변수 ''{0}''의 <code>\#ref</code>이(가) 불필요합니다. \#loc
unnecessary.final.on.parameter.problem.descriptor=매개변수 ''{0}''의 <code>\#ref</code>이(가) 불필요합니다. \#loc
unnecessary.final.report.local.variables.option=지역 변수 보고
unnecessary.final.report.parameters.option=매개변수 보고
unnecessary.final.on.parameter.only.interface.option=추상 또는 인터페이스 메소드에 대해서만 경고
choose.exception.class=예외 클래스선택
class.independent.of.module.display.name=해당 모듈에 의존하지 않는 클래스
class.independent.of.module.problem.descriptor=클래스 <code>\#ref</code>의 모듈에 종속 요소나 종속자가 없습니다. \#loc
class.only.used.in.one.module.display.name=다른 모듈에서만 사용되는 클래스
class.only.used.in.one.module.problem.descriptor=클래스 <code>\#ref</code>의 모듈 ''{0}''에 종속 요소 및/또는 종속자만 있습니다. \#loc
empty.directory.display.name=빈 디렉토리
empty.directories.problem.descriptor=빈 디렉토리 <code>{0}</code>
empty.directories.only.under.source.roots.option=원본 폴더에 있는 빈 디렉토리만 보고
empty.directories.delete.quickfix=빈 디렉토리 ''{0}''을(를) 삭제합니다.
simplifiable.equals.expression.option.non.constant=상수가 아니고 null이 아닌 인수가 있는 equals 보고
simplifiable.equals.expression.display.name='equals()' 호출 전 불필요한 'null' 검사
simplifiable.equals.expression.problem.descriptor=''{0}()'' 호출 전 불필요한 ''null'' 검사입니다. \#loc
simplifiable.equals.expression.quickfix=''.{0}()''을(를) 반전시키고 불필요한 ''null'' 검사를 제거합니다.
cast.to.concrete.class.option=추상 클래스 유형으로의 형 변환 무시
cast.to.concrete.class.ignore.equals.option=equals()에서 무시
instanceof.interfaces.option=instanceof 추상 클래스 무시
instance.variable.of.concrete.class.option=유형이 추상 클래스인 인스턴스 필드 무시
local.variable.of.concrete.class.option=유형이 추상 클래스인 지역 변수 무시
method.return.of.concrete.class.option=반환 유형이 추상 클래스인 메소드 무시
parameter.of.concrete.class.option=유형이 추상 클래스인 매개변수 무시
static.variable.of.concrete.class.option=유형이 추상 클래스인 static 필드 무시
class.only.used.in.one.package.display.name=다른 패키지에서만 사용되는 클래스
class.only.used.in.one.package.problem.descriptor=클래스 <code>\#ref</code>의 패키지 ''{0}''에 종속 요소 및/또는 종속자만 있습니다. \#loc
unnecessary.return.option='else' 브랜치가 있는 'if' 문의 브랜치에서 무시
usage.of.obsolete.assert.display.name=더 이상 사용되지 않는 'junit.framework.Assert' 메소드 사용
use.of.obsolete.assert.problem.descriptor=''{0}''의 <code>\#ref()</code> 호출을 ''org.junit.Assert''의 메소드 호출로 대체해야 합니다. \#loc
use.of.obsolete.assert.quickfix='org.junit.Assert' 메소드 호출로 대체합니다.
junit5.assertions.converter.problem.descriptor=''{0}''의 <code>\#ref()</code> 호출을 ''{1}''의 메소드 호출로 대체해야 합니다. \#loc
junit5.assertions.converter.quickfix=''{0}'' 메소드 호출로 대체합니다.
junit5.assertions.converter.familyName=JUnit 5 호환 호출로 대체
ignored.junit.test.display.name=JUnit 테스트에 '@Ignore'/'@Disabled'로 어노테이션 추가
ignored.junit.test.classproblem.descriptor=테스트 클래스 ''{0}''에 <code>\#ref</code>(으)로 어노테이션이 추가되었습니다 \#loc
ignored.junit.test.method.problem.descriptor=테스트 메소드 ''{0}()''에 <code>\#ref</code>(으)로 어노테이션이 추가되었습니다 \#loc
unclear.binary.expression.display.name=불분명한 표현식
unclear.binary.expression.problem.descriptor=표현식에 명확히 구분 짓는 소괄호를 사용할 수 있습니다. \#loc
unclear.binary.expression.quickfix=명확히 구분 짓는 소괄호를 추가합니다.
new.exception.without.arguments.display.name=인수 없이 예외 생성자 호출
new.exception.without.arguments.problem.descriptor=인수 없는 <code>new \#ref()</code> \#loc
new.exception.without.arguments.ignore.option=매개변수가 있는 생성자가 없는 예외 무시
absolute.alignment.in.user.interface.display.name=AWT/Swing 코드에서 절대 정렬 사용
absolute.alignment.in.user.interface.problem.descriptor=절대 정렬 상수 <code>{0}.\#ref</code>이(가) 사용되었습니다. \#loc
throws.runtime.exception.display.name=검사되지 않은 예외가 'throws' 절에서 선언됨
throws.runtime.exception.problem.descriptor=검사되지 않은 예외 <code>\#ref</code>이(가) 'throws' 절에서 선언되었습니다. \#loc
throws.runtime.exception.quickfix=''{0}''을(를) ''throws'' 절에서 제거합니다.
throws.runtime.exception.move.quickfix=''{0}''을(를) Javadoc ''@throws'' 태그로 이동합니다.
empty.class.ignore.parameterization.option=상위 유형의 매개변수화인 경우 클래스 무시
ambiguous.field.access.display.name=상속된 필드의 액세스가 주변 코드에 있는 요소의 액세스처럼 보임
ambiguous.field.access.hides.local.variable.problem.descriptor=상위 클래스 ''{0}''에 있는 필드 <code>\#ref</code>의 액세스가 지역 변수의 액세스처럼 보입니다. \#loc
ambiguous.field.access.hides.parameter.problem.descriptor=상위 클래스 ''{0}''에 있는 필드 <code>\#ref</code>의 액세스가 매개변수의 액세스처럼 보입니다. \#loc
ambiguous.field.access.hides.field.problem.descriptor=상위 클래스 ''{0}''에 있는 필드 <code>\#ref</code>의 액세스가 주변 클래스에 있는 필드의 액세스처럼 보입니다. \#loc
ambiguous.field.access.quickfix=필드 액세스에 'super' 한정자를 추가합니다.
add.0.to.ignore.if.annotated.by.list.quickfix=''{0}'' 을(를) ''다음으로 어노테이션이 추가된 경우 무시'' 목록에 추가합니다
non.final.field.in.enum.display.name=열거형의 비 'final' 필드
non.final.field.in.enum.problem.descriptor=열거형 ''{0}''에 비 ''final'' 필드 <code>\#ref</code>이(가) 있습니다. \#loc
externalizable.without.public.no.arg.constructor.display.name='public' 비인수 생성자가 없는 externalizable 클래스
externalizable.without.public.no.arg.constructor.problem.descriptor=externalizable 클래스 <code>\#ref</code>에 'public' 비인수 생성자가 없습니다. \#loc
make.constructor.public=생성자를 'public'으로 설정
string.concatenation.missing.whitespace.display.name=문자열 리터럴 연결에 공백 누락
string.concatenation.missing.whitespace.problem.descriptor=문자열 리터럴 연결에 공백이 누락되었습니다. \#loc
string.concatenation.missing.whitespace.option=가변 문자열과의 연결 무시
negated.equality.expression.display.name=부정된 상등 표현식
negated.equality.expression.problem.descriptor=''{0}'' 이(가) 부정되었습니다 \#loc
negated.equality.expression.quickfix=부정 제거
negated.conditional.expression.display.name=부정된 조건식
negated.conditional.expression.problem.descriptor=조건식이 부정되었습니다. \#loc
negated.conditional.expression.quickfix=부정 제거
suspicious.array.cast.display.name=의심스러운 배열 형 변환
suspicious.array.cast.problem.descriptor=<code>\#ref</code>(으)로 의심스러운 형 변환이 실행되었습니다. \#loc
public.constructor.display.name='public' 생성자
public.default.constructor.problem.descriptor=클래스 <code>\#ref</code>에 'public' 디폴트 생성자가 있습니다.
public.constructor.problem.descriptor=public 생성자 <code>\#ref()</code> \#loc
public.constructor.quickfix=factory 메소드로 생성자를 대체합니다.
junit3.style.test.method.in.junit4.class.display.name=JUnit 4 클래스의 이전 스타일 JUnit 테스트 메소드
junit3.style.test.method.in.junit4.class.problem.descriptor=JUnit 4 클래스에 이전 스타일 JUnit 테스트 메소드 <code>\#ref()</code>이(가) 있습니다. \#loc
none=없음
private=private
package.local.private=package-private \\& private
protected.package.local.private=protected, package-private \\& private
non.final.utility.class.display.name=유틸리티 클래스가 'final'이 아님
non.final.utility.class.problem.descriptor=유틸리티 클래스 <code>\#ref</code>이(가) 'final'이 아닙니다. \#loc
0.will.no.longer.be.overridable.by.1={0}을(를) {1}(으)로 더 이상 재정의할 수 없습니다.
0.will.have.incompatible.access.privileges.with.super.1={0}에 상위 {1}와(과) 호환되지 않는 액세스 권한이 있습니다.
0.will.no.longer.be.visible.from.overriding.1={0}이(가) {1} 재정의에서 더 이상 표시되지 않습니다.
make.private.quickfix='private'으로 만듭니다.
arrays.as.list.with.zero.or.one.argument.display.name=인수가 너무 적은 'Arrays.asList()' 호출
arrays.as.list.with.one.argument.problem.descriptor=인수가 하나뿐인 <code>\#ref</code>을(를) 호출합니다. \#loc
arrays.as.list.with.zero.arguments.problem.descriptor=빈 목록을 생성하기 위해 <code>\#ref</code>을(를) 호출합니다. \#loc
string.concatenation.argument.to.log.call.display.name=로깅 호출에 대한 인수로서의 비상수 문자열 연결
string.concatenation.argument.to.log.call.problem.descriptor=<code>\#ref()</code> 로깅 호출에 대한 인수로서의 비상수 문자열 연결 \#loc
string.concatenation.argument.to.log.call.quickfix=연결을 매개변수화된 로그 메시지로 대체합니다.
placeholder.count.matches.argument.count.display.name=자리표시자 수가 로깅 호출의 인수 수와 일치하지 않음
placeholder.count.matches.argument.count.more.problem.descriptor=지정된 자리표시자 수({1})보다 인수의 수({0})가 많습니다. \#loc
placeholder.count.matches.argument.count.fewer.problem.descriptor=지정된 자리표시자 수({1})보다 인수의 수({0})가 적습니다. \#loc
assignment.to.superclass.field.display.name=생성자가 상위 클래스에 정의된 필드에 값을 대입
assignment.to.superclass.field.problem.descriptor=상위 클래스 ''{1}''에서 정의된 필드 ''{0}''에 대입합니다. \#loc
junit.rule.display.name=형식이 잘못된 @Rule/@ClassRule 필드
junit.rule.problem.descriptor=''@{0}'' (으)로 어노테이션이 추가된 필드는 {1} 이어야(여야) 합니다
junit.rule.type.problem.descriptor=필드 유형은 'org.junit.rules.TestRule'의 하위 유형이어야 합니다.
junit.datapoint.display.name=형식이 잘못된 @DataPoint 필드
junit.datapoint.problem.descriptor=@DataPoint로 어노테이션이 추가된 {1} 은(는) {0} 이어야(여야) 합니다
inner.class.referenced.via.subclass.display.name=내부 클래스가 하위 클래스를 통해 참조됨
inner.class.referenced.via.subclass.problem.descriptor=내부 클래스 <code>\#ref</code>이(가) 클래스 ''{0}''에서 선언되었지만 하위 클래스 ''{1}''을(를) 통해 참조되었습니다 \#loc
inner.class.referenced.via.subclass.quickfix=내부 클래스 액세스를 합리화합니다.
boolean.parameter.display.name='boolean' 매개변수가 있는 'public' 메소드
boolean.parameter.problem.descriptor='boolean' 매개변수가 있는 'public' 메소드 <code>\#ref()</code> \#loc
boolean.parameters.problem.descriptor='boolean' 매개변수가 있는 'public' 메소드 <code>\#ref()</code> \#loc
boolean.parameter.constructor.problem.descriptor='boolean' 매개변수가 있는 'public' 생성자 <code>\#ref()</code> \#loc
boolean.parameters.constructor.problem.descriptor='boolean' 매개변수가 있는 'public' 생성자 <code>\#ref()</code> \#loc
boolean.parameter.only.report.multiple.option=부울 매개변수가 여러 개인 메소드만 보고
unnecessary.unicode.escape.display.name=불필요한 유니코드 이스케이프 시퀀스
unnecessary.unicode.escape.problem.descriptor=유니코드 이스케이프 시퀀스 <code>\#ref</code>을(를) ''{0}''(으)로 대체할 수 있습니다. \#loc
unnecessary.unicode.escape.problem.tab.descriptor=유니코드 이스케이프 시퀀스 <code>\#ref</code>을(를) 탭 문자로 대체할 수 있습니다. \#loc
unnecessary.unicode.escape.problem.newline.descriptor=유니코드 이스케이프 시퀀스 <code>\#ref</code>을(를) 줄 피드 문자로 대체할 수 있습니다. \#loc
missing.package.info.display.name='package-info.java' 누락
missing.package.info.problem.descriptor=패키지 ''{0}''에서 <code>package-info.java</code> 파일이 누락되었습니다.
missing.package.html.problem.descriptor=패키지 ''{0}''에서 <code>package.html</code> 파일이 누락되었습니다.
package.info.java.without.package.display.name='package' 문이 없는 'package-info.java'
package.info.without.package.problem.descriptor='package-info.java'에 'package' 문이 없습니다.
package.info.without.package.quickfix=''package {0};''을(를) 추가합니다.
package.info.without.package.family.quickfix=패키지 구문을 추가합니다.
auto.closeable.resource.display.name=AutoCloseable을 'try'-with-resources 없이 사용
auto.closeable.resource.problem.descriptor=''{0}''이(가) ''try''-with-resources 없이 사용되었습니다. \#loc
auto.closeable.resource.quickfix=이 메소드에서 반환된 'AutoCloseable'을 무시합니다.
auto.closeable.resource.returned.option=모든 메소드 호출에서 반환된 AutoCloseable 인스턴스 무시
problematic.varargs.method.display.name=비 vararg 메소드는 vararg 메소드를 재정의
problematic.varargs.method.override.problem.descriptor=비 vararg 메소드 <code>\#ref()</code>이(가) vararg 메소드를 재정의합니다. \#loc
negatively.named.boolean.variable.problem.descriptor=부울 변수 <code>\#ref</code>이(가) 부정적으로 이름이 지정되었습니다. \#loc
negatively.named.boolean.variable.display.name=부정적으로 이름 지정된 부울 변수
invert.quickfix.family.name=부울 반전
invert.method.quickfix=메소드를 반전시킵니다.
invert.quickfix=''{0}''을(를) 반전시킵니다.
throwable.printed.to.system.out.display.name='Throwable'을 'System.out'으로 출력
throwable.printed.to.system.out.problem.descriptor=''Throwable'' 인수 <code>\#ref</code>이(가) ''System.{0}.{1}()'' 호출로 출력됩니다.
suppress.for.tests.scope.quickfix='Tests' 범위를 억제합니다.
implicit.default.charset.usage.display.name=플랫폼의 디폴트 문자 집합을 묵시적으로 사용
implicit.default.charset.usage.problem.descriptor=<code>\#ref()</code> 호출이 플랫폼의 디폴트 문자 집합을 사용합니다.
implicit.default.charset.usage.constructor.problem.descriptor=<code>new \#ref()</code> 호출이 플랫폼의 디폴트 문자 집합을 사용합니다.
interface.may.be.annotated.functional.display.name=인터페이스에 @FunctionalInterface로 주석 추가 가능
interface.may.be.annotated.functional.problem.descriptor=인터페이스 <code>\#ref</code>에 @FunctionalInterface로 어노테이션을 추가할 수 있습니다
only.report.public.methods.option='public' 메소드만 보고
lambda.parameter.hides.member.variable.display.name=람다 매개변수가 필드를 숨김
static.initializer.references.subclass.display.name=정적 이니셜라이저가 하위 클래스를 참조
lambda.parameter.hides.member.variable.problem.descriptor=람다 매개변수 <code>\#ref</code>이(가) 클래스 ''{0}''의 필드를 숨깁니다. \#loc
lambda.parameter.hides.member.variable.ignore.invisible.option=람다에서 실제로 표시되지 않는 필드 무시
shared.thread.local.random.display.name='ThreadLocalRandom' 인스턴스를 공유할 수 있음
shared.thread.local.random.problem.descriptor='ThreadLocalRandom' 인스턴스를 스레드 간에 공유할 수 있습니다.
native.method.naming.convention.display.name='native' 메소드 이름 지정 규칙
native.method.naming.convention.element.description='native'
use.of.obsolete.date.time.api.display.name=더 이상 사용되지 않는 date-time API 사용
use.of.obsolete.date.time.api.problem.descriptor=더 이상 사용되지 않는 date-time 유형 <code>\#ref</code>이(가) 사용되었습니다. \#loc
warn.on.label=다음에 대해 경고\:
all.levels.option=모든 로그 수준
warn.level.and.lower.option=경고 수준 이하
info.level.and.lower.option=정보 수준 이하
debug.level.and.lower.option=디버그 수준 이하
trace.level.option=추적 수준
ignored.autocloseable.types.column.label=무시된 AutoCloseable 리소스 유형
choose.autocloseable.type.to.ignore.title=무시할 AutoCloseable 리소스 유형 선택
big.decimal.method.without.rounding.called.display.name=반올림 모드 인수 없이 'BigDecimal' 메소드 호출
big.decimal.method.without.rounding.called.problem.descriptor=반올림 모드 인수 없이 'BigDecimal.\#ref()'이(가) 호출됩니다.
bigdecimal.legacy.method.display.name='BigDecimal' 기존 메소드 호출
bigdecimal.legacy.method.problem.descriptor='BigDecimal.\#ref()' 호출은 'RoundingMode' 열거형 상수를 사용할 수 있습니다.
bigdecimal.legacy.method.quickfix='RoundingMode' 열거형 상수를 사용합니다.
serializable.stores.non.serializable.display.name=serializable 객체가 비 serializable 객체를 묵시적으로 저장
serializable.lambda.stores.non.serializable.problem.descriptor=serializable 람다가 유형 ''{0}'' 의 비 serializable 객체를 묵시적으로 저장합니다
serializable.local.class.stores.non.serializable.problem.descriptor=serializable 지역 클래스 ''{1}''이(가) 유형 ''{0}''의 비 serializable 객체를 묵시적으로 저장합니다.
serializable.anonymous.class.stores.non.serializable.problem.descriptor=serializable 익명 클래스가 유형 ''{0}''의 비 serializable 객체를 묵시적으로 저장합니다.
assignment.to.lambda.parameter.display.name=람다 매개변수에 대입
assignment.to.lambda.parameter.problem.descriptor=람다 매개변수 <code>\#ref</code>에 대입되었습니다. \#loc
class.with.only.private.constructors.display.name='private' 생성자만 있는 클래스는 'final'로 선언되어야 함
class.with.only.private.constructors.problem.descriptor='private' 생성자만 있는 클래스 <code>\#ref</code>은(는) 'final'로 선언되어야 합니다.
property.value.set.to.itself.display.name=자신에게 설정된 프로퍼티값
equals.with.itself.display.name=자신에서 'equals()' 호출
equals.with.itself.problem.descriptor=자신에서 <code>\#ref()</code> 호출
junit4.method.naming.convention.display.name=JUnit 4+ 테스트 메소드 이름 지정 규칙
junit4.method.naming.convention.element.description=JUnit 4+ 테스트
junit3.method.naming.convention.element.description=JUnit 3 테스트
introduce.holder.class.quickfix=holder 클래스를 삽입합니다.
double.brace.initialization.display.name=이중 중괄호 초기화
double.brace.initialization.quickfix=일반 초기화로 대체합니다.
return.of.inner.class.display.name=익명, 지역 또는 내부 클래스의 인스턴스 반환
return.of.anonymous.class.problem.descriptor=익명 클래스의 인스턴스를 반환합니다. \#loc
return.of.local.class.problem.descriptor=지역 클래스 <code>{0}</code>의 인스턴스를 반환합니다. \#loc
return.of.inner.class.problem.descriptor=비 static 내부 클래스 <code>{0}</code>의 인스턴스를 반환합니다. \#loc
return.of.inner.class.ignore.non.public.option=비 public 메소드의 반환 무시
parameter.type.prevents.overriding.display.name=매개변수 유형으로 인해 재정의 불가
parameter.type.prevents.overriding.problem.descriptor=매개변수 유형 <code>\#ref</code>은(는) ''{0}''에 있지만 상위 메소드 매개변수 유형은 ''{1}''에 있어 재정의할 수 없습니다. \#loc
parameter.type.prevents.overriding.quickfix=매개변수 유형을 ''{0}''(으)로 변경합니다.
parameter.type.prevents.overriding.family.quickfix=매개변수 유형을 '변경합니다.
suspicious.getter.setter.display.name=의심스러운 getter/setter
suspicious.setter.problem.descriptor=setter <code>\#ref()</code>이(가) 필드 ''{0}''을(를) 대입합니다. \#loc
suspicious.getter.problem.descriptor=Getter <code>\#ref()</code>이(가) 필드 ''{0}'' 을(를) 반환합니다 \#loc
unnecessary.break.display.name=불필요한 'break' 문
unnecessary.break.problem.descriptor=<code>\#ref</code> 문은 불필요합니다. \#loc
utility.class.can.be.enum.display.name=유틸리티 클래스가 'enum'이 될 수 있음
utility.class.code.can.be.enum.problem.descriptor=유틸리티 클래스 <code>\#ref</code>이(가) 'enum'이 될 수 있습니다. \#loc
utility.class.code.can.be.enum.quickfix='enum'으로 변환합니다.
non.public.clone.display.name='clone()' 메소드가 'public'이 아님
non.public.clone.problem.descriptor=<code>\#ref()</code> 메소드가 'public'이 아닙니다. \#loc
only.warn.on.public.clone.methods='public' 복제 메소드에 대해서만 경고
only.warn.on.protected.clone.methods='protected' 복제 메소드에 대해서만 경고
clone.returns.class.type.display.name='clone()'에는 포함된 클래스와 동일한 반환 유형이 있어야 함
clone.returns.class.type.problem.descriptor=''복제()''에는 반환 유형 ''{0}''이(가) 있어야 합니다. \#loc
clone.returns.class.type.quickfix=반환 유형을 ''{0}''(으)로 변경합니다.
clone.returns.class.type.family.quickfix=반환 유형을 클래스 유형으로 변경합니다.
use.of.clone.display.name='clone()' 또는 'Cloneable' 사용
use.of.clone.call.problem.descriptor=<code>\#ref()</code> 호출
use.of.clone.call.method.problem.descriptor=<code>\#ref()</code> 구현
use.of.clone.reference.problem.descriptor=<code>\#ref</code> 사용
dangling.javadoc.display.name=허상 Javadoc 주석
dangling.javadoc.problem.descriptor=허상 Javadoc 주석 \#loc
dangling.javadoc.convert.quickfix=블록 주석으로 대체합니다.
dangling.javadoc.delete.quickfix=허상 주석을 제거합니다.
equals.replaceable.by.objects.call.display.name='equals()' 식을 'Objects.equals()' 식으로 대체 가능
equals.replaceable.by.objects.call.problem.descriptor=<code>\#ref</code>을(를) 'Objects.equals()' 식으로 대체할 수 있습니다. \#loc
equals.replaceable.by.objects.check.not.null.option='a \!\= null \\&\\& a.equals(b)'와 같은 표현식을 강조 표시
array.objects.equals.display.name=배열에서 'Objects.equals()' 호출
array.objects.equals.problem.descriptor=배열의 <code>Objects.\#ref()</code>이(가) 'Arrays.equals()'일 것입니다. \#loc
array.objects.deep.equals.problem.descriptor=배열의 <code>Objects.\#ref()</code>이(가) 'Arrays.deepEquals()'일 것입니다. \#loc
extends.throwable.display.name=클래스가 'java.lang.Throwable'를 바로 확장
anonymous.extends.throwable.problem.descriptor=익명의 클래스가 'java.lang.Throwable'를 바로 확장합니다. \#loc
extends.throwable.problem.descriptor=클래스 <code>\#ref</code>이(가) 'java.lang.Throwable'를 바로 확장합니다. \#loc
lambda.parameter.naming.convention.display.name=람다 매개변수 이름 지정 규칙
lambda.parameter.naming.convention.element.description=람다 매개변수
assert.message.not.string.display.name='assert' 메시지가 문자열이 아님
assert.message.of.type.boolean.problem.descriptor=유형 ''{0}''의 ''assert'' 메시지 \#loc
assert.message.not.string.only.warn.boolean.option='assert' 메시지가 'boolean' 또는 'java.lang.Boolean'인 경우에만 경고
suspicious.literal.underscore.display.name=숫자 리터럴의 의심스러운 밑줄
suspicious.literal.underscore.problem.descriptor=밑줄이 있는 숫자 리터럴에 있는 그룹의 길이가 3이 아닙니다. \#loc
unary.plus.quickfix=단항 '+'를 제거합니다.
super.tear.down.in.finally.display.name='super.tearDown()'이 'finally' 블록에서 호출되지 않음
super.tear.down.in.finally.problem.descriptor=<code>\#ref()</code>이(가) 'finally' 블록에서 호출되지 않습니다. \#loc
confusing.floating.point.literal.option=과학적 표기에서 부동소수점 리터럴 무시
class.may.be.interface.java8.option=Java 8을 사용할 때 추상이 아닌 메소드가 포함된 클래스 보고
simplifiable.boolean.expression.display.name=단순화 가능한 부울 표현식
unnecessary.initcause.display.name=불필요한 'throwable.initCause()' 호출
unnecessary.initcause.problem.descriptor=불필요한 <code>Throwable.\#ref()</code> 호출
unnecessary.initcause.quickfix='Throwable.initCause()' 호출을 제거합니다.
consider.static.final.fields.constant.option='static final' 필드를 상수로 간주
atomic.field.updater.not.static.final.display.name=AtomicFieldUpdater 필드가 'static final'로 선언되지 않음
atomic.field.updater.not.static.final.problem.descriptor={0} 필드 <code>\#ref</code>이(가) ''static final''로 선언되지 않았습니다. \#loc
atomic.field.updater.issues.display.name=AtomicFieldUpdater 문제
field.not.found.in.class.problem.descriptor=이름이 ''{0}''인 필드를 클래스 ''{1}''에서 찾을 수 없습니다.
field.incorrect.type.problem.descriptor=필드 ''{0}''에 유형 ''{1}''이(가) 없습니다.
field.missing.volatile.modifier.problem.descriptor=필드 ''{0}''에 ''volatile'' 제어자가 없습니다.
field.has.static.modifier.problem.descriptor=필드 ''{0}''에 ''static'' 제어자가 있습니다
private.field.not.accessible.problem.descriptor=''private'' 필드 ''{0}''은(는) 여기에서 액세스할 수 없습니다.
package.local.field.not.accessible=package-private 필드 ''{0}''은(는) 여기에서 액세스할 수 없습니다.
protected.field.not.accessible.problem.descriptor=''protected'' 필드 ''{0}''은(는) 여기에서 액세스할 수 없습니다.
interface.clashes.with.object.class.display.name=인터페이스 메소드가 'java.lang.Object'의 메소드와 충돌
interface.clashes.with.object.class.problem.descriptor=<code>\#ref()</code>이(가) 'java.lang.Object'의 메소드와 충돌합니다.
optional.used.as.field.or.parameter.type.display.name='Optional'이 필드 또는 매개변수 유형으로 사용되지 않음
optional.used.as.field.type.problem.descriptor=<code>\#ref</code>이(가) 필드 ''{0}''의 유형으로 사용됩니다.
optional.used.as.parameter.type.problem.descriptor=<code>\#ref</code>이(가) 매개변수 ''{0}''의 유형으로 사용됩니다.
lambda.unfriendly.method.overload.display.name=람다 친화적이지 않은 메소드 오버로드
lambda.unfriendly.method.overload.problem.descriptor=메소드 <code>\#ref()</code>의 오버로드가 람다 친화적이지 않습니다.
lambda.unfriendly.constructor.overload.problem.descriptor=생성자 <code>\#ref()</code>의 오버로드가 람다 친화적이지 않습니다.
optional.contains.collection.display.name='Optional'에 배열 또는 컬렉션이 있음
optional.contains.collection.problem.descriptor='Optional'에 컬렉션 <code>\#ref</code>이(가) 있습니다.
optional.contains.array.problem.descriptor='Optional'에 배열 <code>\#ref</code>이(가) 있습니다.
synchronization.on.get.class.display.name='getClass()' 동기화
synchronization.on.get.class.problem.descriptor=<code>\#ref()</code> 동기화 \#loc
object.instantiation.inside.equals.or.hashcode.display.name='equals()' 또는 'hashCode()' 내의 객체 인스턴스화
object.instantiation.inside.equals.or.hashcode.problem.descriptor=''{0}()'' 내의 객체 인스턴스화 \#loc
object.instantiation.inside.equals.or.hashcode.problem.descriptor2=''{0}()''({1}) 내의 객체 인스턴스화 \#loc
lambda.body.can.be.code.block.name=람다 본문이 코드 블록이 될 수 있음
lambda.body.can.be.code.block.quickfix=람다 본문을{...}(으)로 확장합니다.
lambda.parameter.type.can.be.specified.name=람다 매개변수 유형을 지정할 수 있음
lambda.parameter.type.can.be.specified.descriptor=람다 매개변수 유형을 {0}(으)로 확장할 수 있습니다.
lambda.parameter.type.can.be.specified.quickfix=매개변수 유형을 {0}(으)로 확장합니다.
lambda.parameter.type.can.be.specified.family.quickfix=람다 매개변수 유형을 지정합니다.
diamond.can.be.replaced.with.explicit.type.arguments.name=다이아몬드를 명시적 유형 인수로 대체 가능
diamond.can.be.replaced.with.explicit.type.arguments.quickfix='<>'를 명시적 유형 인수로 대체합니다.
lambda.can.be.replaced.with.anonymous.name=람다를 익명 클래스로 대체 가능
lambda.can.be.replaced.with.anonymous.quickfix=람다를 익명 클래스로 대체합니다.
method.ref.can.be.replaced.with.lambda.name=메소드 참조를 람다로 대체 가능
method.ref.can.be.replaced.with.lambda.quickfix=메소드 참조를 람다로 대체합니다.
try.statement.with.multiple.resources.name=여러 리소스가 있는 'try' 문을 분할할 수 있음
try.statement.with.multiple.resources.quickfix=여러 리소스가 있는 'try' 문을 분할합니다.
multi.catch.can.be.split.name=여러 catch를 개별 catch 블록으로 분할할 수 있음
multi.catch.can.be.split.quickfix=여러 catch를 개별 'catch' 블록으로 분할합니다.
assertion.can.be.if.name=어설션을 if 문으로 대체 가능
assert.can.be.if.quickfix='assert'를 'if' 문으로 대체합니다.
if.can.be.assertion.name=구문을 'assert' 또는 'Objects.requireNonNull'로 대체 가능
if.can.be.assertion.replace.with.assertion.quickfix=구문을 'assert' 문으로 대체합니다.
if.can.be.assertion.replace.with.objects.requirenonnull.quickfix=구문을 'Objects.requireNonNull()'로 대체합니다.
single.statement.in.block.name=코드 블록에 단일 구문이 있음
single.statement.in.block.descriptor=''{0}''에 단일 구문이 있습니다.
single.statement.in.block.quickfix=''{0}'' 문의 중괄호를 제거합니다.
single.statement.in.block.family.quickfix=구문의 중괄호를 제거합니다.
single.element.annotation.name=단일 요소 어노테이션
single.element.annotation.quickfix='value\='를 추가합니다.
single.element.annotation.family.quickfix=어노테이션을 일반 형식으로 확장합니다.
array.creation.without.new.keyword.name='new' 식이 없는 배열 생성
array.creation.without.new.keyword.quickfix=''new {0}''을(를) 추가합니다.
array.creation.without.new.keyword.family.quickfix='new' 표현식을 추가합니다.
malformed.set.up.tear.down.display.name=형식이 잘못된 'setUp()' 또는 'tearDown()' 메소드
malformed.set.up.tear.down.problem.descriptor='\#ref()에 잘못된 시그니처가 있습니다 \#loc
method.missing.return.statement.display.name=메소드에 논리가 있지만 'return' 문이 없습니다.
method.missing.return.statement.problem.descriptor=메소드 <code>\#ref</code>에 논리가 있지만 'return' 문이 없습니다.
overly.long.lambda.display.name=지나치게 긴 람다 표현식
overly.long.lambda.problem.descriptor=Lambda 표현식이 너무 깁니다(주석이 아닌 소스 구문 수 \= {0}). \#loc
wait.notify.not.in.synchronized.context.display.name=동기화되지 않는 동안 'wait()' 또는 'notify()'
wait.notify.while.not.synchronized.on.problem.descriptor=<code>\#ref</code>이(가) ''{0}''에서 동기화되지 않는 동안 호출됩니다. \#loc
junit5.assertions.converter.display.name=JUnit 5 테스트에서 더 이상 사용되지 않는 어설션
junit5.converter.display.name=JUnit 4 테스트가 JUnit 5가 될 수 있음
junit5.converter.fix.name=JUnit 5로 마이그레이션
call.to.suspicious.string.method.display.name=의심스러운 문자열 메소드 호출
call.to.suspicious.string.method.problem.descriptor=국제화된 컨텍스트에서 <code>String.\#ref()</code>이(가) 호출됩니다. \#loc
unnecessary.string.escape.display.name=불필요하게 이스케이프된 문자
unnecessary.string.escape.problem.descriptor=<code>\#ref</code>이(가) 불필요하게 이스케이프됩니다.
unnecessary.string.escape.quickfix=불필요하게 이스케이프된 문자를 이스케이프되지 않은 것으로 교체합니다.

array.can.be.replaced.with.enum.values = 배열을 열거형 값으로 대체할 수 있습니다.
array.can.be.replaced.with.enum.values.quickfix = 배열을 {0}.values()로 대체합니다.
array.can.be.replaced.with.enum.values.family.quickfix = 배열을 EnumType.value()로 대체합니다.

string.concatenation.replace.fix=StringBuilder로 대체합니다.
string.concatenation.replace.fix.name=변수 ''{0}''을(를) 문자열에서 {1}(으)로 변환
string.concatenation.introduce.fix=StringBuilder를 삽입합니다.
string.concatenation.introduce.fix.name=새로운 {1}을(를) 삽입하여 변수 ''{0}'' 업데이트

ignored.class.names=클래스 무시(하위 클래스 포함)
junit5.platform.runner.display.name=테스트 메소드 없는 @RunWith(JUnitPlatform.class)
meta.annotation.without.runtime.retention=리플렉션에서 사용될 비 런타임 어노테이션
string.equals.char.sequence.display.name='CharSequence' 인수로 'String.equals()' 호출
string.equals.char.sequence.problem.descriptor=<code>String.\#ref()</code>이(가) ''{0}'' 인수로 호출됩니다. \#loc
object.equals.can.be.equality.display.name='equals()' 호출을 '\=\='로 대체 가능
object.equals.can.be.equality.problem.descriptor=<code>\#ref()</code>을(를) '\=\='로 대체할 수 있습니다.
not.object.equals.can.be.equality.problem.descriptor=<code>\!\#ref()</code>을(를) '\=\='로 대체할 수 있습니다.
redundant.explicit.var.type.display.name=지역 변수 유형은 생략 가능
variable.type.can.be.explicit.display.name=변수 유형이 명시적가 될 수 있음
assignment.or.return.of.field.with.mutable.type.display.name=가변 유형이 있는 필드의 대입 또는 반환
assignment.of.field.with.mutable.type.problem.descriptor=매개변수 <code>\#ref</code>에서 {0} 필드 ''{1}''(으)로 대입되었습니다. \#loc
return.of.field.with.mutable.type.problem.descriptor={0} 필드 <code>{1}</code> 반환 \#loc
ignore.private.methods.option=private 메소드의 대입 및 반환 무시

inspection.redundant.string.operation.display.name=중복 문자열 연산
inspection.redundant.string.remove.fix.name=중복 ''{0}()'' 호출 제거
inspection.redundant.string.fix.family.name=중복 호출 제거
inspection.redundant.string.call.message=<code>\#ref</code> 호출이 중복됩니다. \#loc
inspection.redundant.string.argument.message=불필요한 빈 문자열 인수입니다.
inspection.redundant.string.remove.argument.fix.name=인수 제거
inspection.redundant.string.intern.on.constant.message=컴파일 타임 상수의 <code>\#ref</code> 호출이 불필요합니다. \#loc
inspection.redundant.string.constructor.message=<code>\#ref</code>이(가) 중복됩니다. \#loc
inspection.redundant.string.replace.with.arg.fix.name=인수로 대체
inspection.redundant.string.replace.with.empty.fix.name=빈 문자열로 대체
inspection.redundant.string.option.do.not.report.string.constructors=문자열 생성자를 보고 안 함
inspection.x.call.can.be.replaced.with.y=''{0}'' 호출을 ''{1}''(으)로 대체 가능 

inspection.type.may.be.weakened.display.name=유형이 약화될 수 있음
inspection.type.may.be.weakened.problem.descriptor=변수 <code>\#ref</code>의 유형이 {0}(으)로 약화될 수 있습니다. \#loc
inspection.type.may.be.weakened.method.problem.descriptor=메소드 <code>\#ref()</code>의 반환 유형이 {0}(으)로 약화될 수 있습니다. \#loc
inspection.type.may.be.weakened.parameter.problem.descriptor=매개변수 <code>\#ref</code>의 유형이 {0}(으)로 약화될 수 있습니다. \#loc
inspection.type.may.be.weakened.field.problem.descriptor=필드 <code>\#ref</code>의 유형이 {0}(으)로 약화될 수 있습니다. \#loc
inspection.type.may.be.weakened.quickfix=유형을 ''{0}''(으)로 약화합니다.
inspection.type.may.be.weakened.ignore.option=오른쪽 유형을 대입에서 가장 약한 유형으로 사용(&R)
inspection.type.may.be.weakened.collection.method.option=메소드 호출 인수에 대한 컬렉션의 매개변수화된 유형 사용(&P)
inspection.type.may.be.weakened.do.not.weaken.to.object.option='java.lang.object'로 약화 안 함(&W)
inspection.type.may.be.weakened.add.stopper=약화를 위해 stop 클래스로 추가
inspection.type.may.be.weakened.add.stopper.single=약화를 위해 {0}을(를) stop 클래스로 추가
inspection.type.may.be.weakened.only.weaken.to.an.interface=인터페이스로만 약화
inspection.type.may.be.weakened.do.not.weaken.return.type=반환 유형을 약화하면 안 됩니다.
inspection.type.may.be.weakened.add.stop.class.family=stop 클래스 추가
inspection.type.may.be.weakened.weaken.type.family=유형 약화
inspection.type.may.be.weakened.add.stop.class.selection.table=stop 클래스
inspection.type.may.be.weakened.add.stop.class.selection.popup=stop 클래스 선택
inspection.type.may.be.weakened.do.not.weaken.inferred.variable.type='var'로 선언된 약화된 변수를 제안 안 함

inspection.catch.ignores.exception.display.name=catch 블록이 예외를 무시할 수 있음
inspection.catch.ignores.exception.option.comments='catch' 블록에 주석이 포함되어 있을 경우 경고 안 함
inspection.catch.ignores.exception.option.nonempty='catch' 블록에 주석이 비어 있을 경우 경고 안 함
inspection.catch.ignores.exception.option.ignored.used='ignore(d)'라는 예외가 실제로 무시되지 않은 경우 경고 안 함
inspection.catch.ignores.exception.used.message=이름이 <code>\#ref</code>인 'catch' 매개변수가 사용되었습니다. \#loc
inspection.catch.ignores.exception.empty.message=빈 <code>\#ref</code> 블록 \#loc
inspection.catch.ignores.exception.unused.message=사용되지 않는 'catch' 매개변수 <code>\#ref</code> \#loc
inspection.catch.ignores.exception.vm.ignored.message=일부 중요한 예외가 <code>\#ref</code> 블록에서 무시될 수 있습니다. \#loc

inspection.redundant.collection.operation.display.name=중복 컬렉션 연산
inspection.redundant.collection.operation.fix.family.name=컬렉션 연산 단순화
inspection.redundant.collection.operation.problem.arraycopy=배열을 복사하기 위해 불필요한 컬렉션이 생성되었습니다.
inspection.redundant.collection.removal.by.index.problem=색인별 제거는 객체별 제거로 대체할 수 있습니다.
inspection.redundant.collection.removal.by.index.fix=객체별 제거를 사용합니다.
inspection.redundant.collection.unnecessary.contains.problem=불필요한 ''{0}'' 검사
inspection.redundant.collection.unnecessary.contains.fix=''{0}'' 검사를 제거합니다.

comments.as.content.option=주석을 내용으로 계산
copy.constructor.misses.field.display.name=복사 생성자에 필드가 누락됨
copy.constructor.misses.field.problem.descriptor.1=복사 생성자가 필드 ''{0}''을(를) 복사하지 않습니다.
copy.constructor.misses.field.problem.descriptor.2=복사 생성자가 필드 ''{0}'', ''{1}''을(를) 복사하지 않습니다.
copy.constructor.misses.field.problem.descriptor.3=복사 생성자가 필드 ''{0}'', ''{1}'', ''{2}''을(를) 복사하지 않습니다.
copy.constructor.misses.field.problem.descriptor.many=복사 생성자가 {0}개 필드를 복사하지 않습니다.

fix.add.argument.family.name=인수 추가
fix.add.argument.name=''{0}'' 인수 추가

inspection.constant.expression.display.name=상수식을 평가할 수 있음
inspection.constant.expression.message=상수식을 ''{0}''(으)로 평가할 수 있습니다.
inspection.constant.expression.fix.name=''{0}''의 상수값 계산
inspection.constant.expression.fix.name.with.value=''{0}''을(를) 상수값 ''{1}''(으)로 대체
inspection.constant.expression.fix.family.name=상수값 계산

inspection.redundant.compare.call.display.name=중복 'compare' 메소드 호출
inspection.redundant.compare.call.fix.name='compare' 호출 인라인화

inspection.simplifiable.if.statement.display.name=if 문을 ?\:, \\&\\&, ||, \=\= 또는 \!\= 표현식으로 대체 가능
inspection.simplifiable.if.statement.message=if 문을 ''{0}''(으)로 대체할 수 있습니다.
inspection.simplifiable.if.statement.option.dont.warn.on.ternary='?\:' 연산자를 제안 안 함
inspection.simplifiable.if.statement.fix.name=''if else''를 ''{0}''(으)로 대체
inspection.simplifiable.if.statement.fix.family.name='if else'를 조건식으로 대체

inspection.list.remove.in.loop.display.name=루프에서 'List.remove()' 호출
inspection.list.remove.in.loop.message='List.subList().clear()'로 대체할 수 있습니다.

implicit.default.charset.usage.fix.family.name=UTF-8 문자 집합 지정

inspection.redundant.class.call.display.name=중복 'isInstance' 또는 'cast' 호출
inspection.new.object.equality.display.name=새 객체를 '\=\='를 사용하여 비교
inspection.new.object.equality.message=새 객체를 '\#ref'을(를) 사용하여 비교
inspection.excessive.range.check.message=''{0}''(으)로 대체할 수 있습니다.
inspection.excessive.range.check.fix.family.name=과도한 범위 검사 단순화
suspicious.integer.div.assignment.problem.descriptor=나누기 결과가 정수로 버림 처리됩니다.
suspicious.integer.div.assignment.display.name=의심스러운 정수 나눗셈 대입
suspicious.integer.div.assignment.quickfix=double로 형 병환합니다.
inspection.if.statement.missing.break.in.loop.name=조건이 충족된 후 루프를 종료할 수 있습니다.
inspection.if.statement.missing.break.in.loop.quickfix='break'를 추가합니다.

inspection.case.mismatch.display.name=문자열 연산에서 일치하지 않는 case
inspection.case.mismatch.message=메소드 ''{0}()'' 이(가) {1} 을(를) 항상 반환합니다. 인수에는 {2} 심볼이 있지만 한정자는 {3} 뿐입니다.

inspection.suspicious.date.format.display.name=의심스러운 날짜 형식 패턴
inspection.suspicious.date.format.message.upper=대문자 ''{0}''({1}) 패턴이 사용됩니다. ''{2}''({3})은(는) 의도되었을 가능성이 있습니다.
inspection.suspicious.date.format.message.lower=소문자 ''{0}''({1}) 패턴이 사용됩니다. ''{2}''({3})은(는) 의도되었을 가능성이 있습니다.

fix.replace.map.with.flat.map.description='map()'을 'flatMap()'으로 대체할 수 있습니다.

fix.eliminate.folded.if.present.name=접힌 'ifPresent' 호출 제거
fix.eliminate.folded.if.present.description=접힌 'ifPresent' 호출을 제거할 수 있습니다.

inspection.pattern.variable.can.be.used.display.name=패턴 변수 사용 가능
inspection.pattern.variable.can.be.used.message=변수 ''{0}''을(를) 패턴 변수로 대체할 수 있습니다.
inspection.pattern.variable.can.be.used.fix.family.name=패턴 변수로 대체
inspection.pattern.variable.can.be.used.fix.name=''{0}''을(를) 패턴 변수로 대체

array.hash.code.fix.family.name=묵시적 'hashCode'로 대체
unqualified.static.access.fix.family.name=static 액세스 정규화
replace.field.reference.fix.family.name=필드 참조 대체
replace.field.reference.fix.text=필드 참조를 {0}(으)로 대체 
replace.method.call.fix.family.name=메소드 호출 대체
replace.method.call.fix.text=메소드 호출을 {0}(으)로 대체
delete.unnecessary.statement.fix.family.name=중복 구문 제거
increment.decrement.used.as.expression.fix.family.name=별도의 구문으로 추출
use.of.properties.as.hashtable.fix.family.name=프로퍼티 액세스 수정
unnecessary.java.doc.link.fix.family.name=중복 태그 제거
swap.equals.fix.family.name=메소드 호출 반전
remove.modifier.fix.family.name=제어자 제거
shift.out.of.range.fix.family.name=시프트 값 수정
unnecessary.unicode.escape.fix.family.name=문자로 대체합니다.
unnecessary.unicode.escape.fix.text=라인 피드 문자로 대체
absolute.alignment.in.user.interface.fix.family.name=상수로 대체
static.inheritance.fix.family.name=상속을 정규화된 참조로 대체
suspicious.to.array.call.fix.family.name=적절한 배열로 대체
incorrect.date.format.fix.family.name=잘못된 날짜 형식 수정
referencing.subclass.0.from.superclass.1.initializer.might.lead.to.class.loading.deadlock=상위 클래스 {1} 이니셜라이저에서 하위 클래스 {0} 을(를) 참조하면 클래스 로딩 교착 상태가 발생할 수 있습니다.
collections.field.access.replaceable.by.method.call.fix.family.name=Collections.EMPTY_*를 호출로 대체
delete.catch.section.fix.family.name=catch 문 삭제
make.field.static.final.fix.family.name=static final 생성
string.concatenation.in.format.call.fix.family.name=연결을 인수로 대체합니다.
implicit.array.to.string.fix.family.name=Array.toString()을 묵시적으로 작성
listener.may.use.adapter.fix.family.name=어댑터로 대체
unnecessary.temporary.object.fix.family.name=연결 대체
make.public.static.fix.family.name=public/static 생성
utility.class.with.public.constructor.fix.family.name=생성자를 private으로 작성
change.modifier.fix.family.name=제어자 변경
unnecessary.interface.modifiers.fix.family.name=불필요한 제어자를 제거
make.field.final.fix.family.name=final로 만듭니다.
generate.to.string.quick.fix.family.name=\ 생성
generate.to.string.quick.fix.text=toString() 생성
replace.instanceof.fix.family.name=instanceOf 유형 대체
replace.cast.fix.family.name=형 변환 유형 교체
make.package.private.fix.family.name=package-private 생성
make.method.final.fix.family.name=메소드를 'final'로 설정
replace.casted.literal.with.just.literal.fix.family.name={0} 리터럴로 교체
set.constructor.modifier.fix.family.name=생성자 제어자 수정
char.used.in.arithmetic.content.cast.fix.family.name=형 변환 삽입
ignore.parentheses.around.single.no.formal.type.lambda.parameter=형식이 없는 단일 유형 람다 매개변수를 둘러싼 소괄호 무시
double.checked.locking.fix.family.name=필드를 휘발성으로 설정
declare.collection.as.interface.fix.family.name=유형 약화
string.equals.empty.string.fix.family.name=빈 문자열 검사 간소화
class.without.logger.annotations.tab=어노테이션
class.without.logger.ignored.classes.tab=무시된 클래스
class.without.logger.loggers.tab=로거
add.catch.section.fix.family.name='catch' 절 추가
inspection.autocloseable.resource.ignored.methods.title=이 메소드에서 반환된 AutoCloseable 인스턴스 무시
logger.initialized.with.foreign.class.fix.family.name=외부 클래스 대체
extend.exception.fix.family.name=클래스 확장을 '예외'로 작성
inspection.use.of.private.field.inner.classes.option=내부 클래스로부터의 액세스 무시
refused.bequest.fix.family.name=상위 메소드에 호출 삽입
mark.modules.as.loaded.together.fix.family.name=모듈이 함께 로드되도록 표시
mark.modules.as.loaded.together.fix.text=''{0}'' 및 ''{1}''모듈이 함께 로드되도록 표시
inspection.suspicious.package.private.access.description={0} 은(는) {1}이지만 다른 모듈 ''{2}''에서 선언되었습니다.
ignore.class.fix.family.name=해당 유형 무시
create.default.branch.fix.family.name='default' 브랜치 삽입
create.missing.switch.branches.fix.family.name=열거형 'switch' 브랜치 생성
unnecessary.fully.qualified.name.fix.family.name=완전히 정규화된 이름 대체
return.of.collection.field.fix.family.name=반환 컬렉션을 'unmodifiable'로 작성
remove.redundant.substring.fix.family.name=중복 'substring()' 호출 제거
remove.redundant.substring.fix.text=''{0}'' 사용 및 중복 ''substring()'' 호출 제거
make.class.final.fix.family.name=클래스를 final로 설정
side.effects.method.ref.to.lambda.fix.family.name={0} (부작용)
encapsulate.variable.fix.family.name=필드 캡슐화
method.may.be.static.replaces.qualifiers.with.class.references.option=빠른 수정 기능은 인스턴스 한정자를 클래스 참조로 대체합니다.
method.may.be.static.ignore.default.methods.option='default' 메소드 무시
make.public.static.void.fix.family.name=제어자 수정
convert.empty.anonymous.to.new.fix.family.name=제거 '{}'
replace.method.ref.with.qualifier.fix.family.name=한정자로 대체
add.throws.clause.fix.family.name='throws' 절 수정
inspection.to.array.prefer.empty.array.title=빈 배열 선호\:
too.broad.scope.inspection.fix.family.name=좁은 범위
replace.with.cast.fix.family.name=형 변환으로 대체
replace.anonymous.with.lambda.body.fix.family.name=호출을 메소드 본문으로 대체
replace.with.method.reference.fix.family.name=메소드 참조의 메소드 호출을 적절한 메소드 호출로 대체
replace.with.lambda.body.fix.family.name=람다 메소드 호출을 람다 본문으로 대체
inspection.trivial.functional.expression.usage.description=메소드 호출 간소화 가능
replace.with.var.fix.family.name=명시적 유형을 'var'로 대체
inspection.redundant.explicit.variable.type.description=지역 변수의 명시적 유형 생략 가능
add.read.write.object.methods.fix.family.name=항상 예외를 던지는 'readObject()' 및 'writeObject()' 메소드추가
add.read.write.object.methods.fix.text=항상 예외를 던지는 'writeObject()' 메소드 추가
add.read.write.object.methods.fix.text2=항상 예외를 던지는 'readObject()' 메소드 추가
replace.with.method.ref.fix.family.name=람다를 메소드 참조로 교체
qualify.call.fix.family.name=참조 정규화
replace.with.comparator.fix.family.name=static 메소드 Comparator를 사용해 비교자 간소화
replace.with.comparator.fix.text={0}(으)로 교체
inspection.comparator.combinators.description=Comparator 체인으로 교체 가능
inspection.comparator.combinators.description2=Comparator.{0}(으)로 교체 가능
inspection.unnecessary.string.escape.report.char.literals.option=char 문자열 보고
inspection.method.call.in.loop.ignore.known.methods.option=부작용이 있는 알려진 메소드 무시
fix.data.provider.signature.family.name=데이터 공급자 시그니처 수정
fix.data.provider.signature.text=@Parameterized.매개변수 데이터 공급자 생성
allow.suppressions.fix.family.name=억제 허용
allow.suppressions.fix.text=해당 억제 허용
remove.suppress.comment.fix.family.name=//{0} 제거
convert.to.j.unit.4.fix.family.name=JUnit 3 클래스를 JUnit 4로 변환
throws.runtime.exception.fix.family.name='throws' 절에서 제거
move.exception.to.javadoc.fix.family.name=Javadoc '@throws' 태그로 이동
create.package.info.java.family.name='package-info.java' 생성
remove.loop.fix.family.name=루프 제거
remove.call.fix.family.name=호출 제거
inspection.meta.annotation.without.runtime.description={0}에는 @Retention(RetentionPolicy.RUNTIME)이 포함되어야 합니다.
inspection.refused.bequest.super.annotated.option=상위 메소드가 다음과 같이 어노테이션이 추가된 경우에만 보고\:
inspection.empty.class.ignore.subclasses.option={0} 하위 클래스 무시
inspection.test.method.without.assertions.exceptions.option=예외를 선언하는 테스트 메소드 무시
inspection.collection.must.have.initial.capacity.initializers.option=필드 이니셜라이저를 보고하지 않음
utility.class.without.private.constructor.cant.generate.constructor.title=생성자 생성 불가
utility.class.without.private.constructor.cant.generate.constructor.message=유틸리티 클래스에 인스턴스 생성이 포함되며 private 생성자가 생성되지 않습니다.
inspection.suspicious.package.private.access.problem=다른 모듈 ''{2}''에서 선언된 {1}에서 package-private 메소드를 {0} 이(가) 재정의합니다.
inspection.condition.covered.by.further.condition.descr=후속 {1, choice, 1\#조건 ''''{2}''''|2\#조건} 으로 수행되는 조건 ''{0}'' 
inspection.parameterized.parameters.static.collection.display.name=데이터 공급자가 없는 @RunWith(Parameterized.class)