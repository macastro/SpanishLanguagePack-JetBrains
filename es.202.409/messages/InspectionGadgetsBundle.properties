cast.to.concrete.class.display.name=Fundido a una clase concreta
cast.to.concrete.class.problem.descriptor=Transmitir a clase concreta <code>{0}</code> #loc
class.references.subclass.display.name=La clase hace referencia a una de sus subclases
class.references.subclass.problem.descriptor=Class ''{0}'' hace referencia a la subclase <code>#ref</code> #loc
class.references.subclass.problem.descriptor.anonymous=Referencias de clase anónimas subclase <code>#ref</code> #loc
collection.declared.by.class.display.name=Colección declarada por clase, no por interfaz
collection.declared.by.class.problem.descriptor=La declaración de <code>#ref</code> probablemente debería debilitarse a ''{0}'' #loc
collection.declared.by.class.ignore.locals.option=Ignorar variables locales
collection.declared.by.class.ignore.private.members.option=Ignorar campos y métodos 'privados'
feature.envy.display.name=Característica envidia
feature.envy.problem.descriptor=Clase ''{0}'' a la que se accede repetidamente en el método <code>#ref()</code> #loc
bounded.wildcard.display.name=Puede usar comodines acotados
bounded.wildcard.contravariant.descriptor=¿Se puede generalizar a <code>? super#ref</code> #loc
bounded.wildcard.covariant.descriptor=¿Se puede generalizar a <code>? extiende#ref</code> #loc
bounded.wildcard.report.invariant.option=Informar clases invariantes
bounded.wildcard.report.private.option=Informar métodos privados
bounded.wildcard.report.instance.option=Métodos de instancia de informe
instance.variable.of.concrete.class.display.name=El tipo de campo de instancia es una clase concreta
instance.variable.of.concrete.class.problem.descriptor=El tipo de campo ''{0}'' es clase concreta <code>#ref</code> #loc
chain.of.instanceof.checks.display.name=Cadena de comprobaciones 'instanceof'
chain.of.instanceof.checks.problem.descriptor=La cadena de comprobaciones 'instanceof' indica falla de abstracción #loc
chain.of.class.equality.checks.problem.descriptor=La cadena de comprobaciones de igualdad de clases indica un fallo de abstracción #loc
instanceof.concrete.class.display.name='instancia de' una clase concreta
instanceof.concrete.class.problem.descriptor='instancia de' clase concreta <code>#ref</code> #loc
instanceof.concrete.class.equality.problem.descriptor=Comparación de clases contra clases concretas <code>#ref</code> #loc
instanceof.check.for.this.display.name='instancia de' verificar 'esto'
instanceof.check.for.this.problem.descriptor='instancia de' verificar <code>#ref</code> #loc
instanceof.check.for.this.equality.problem.descriptor=Comparación de clases para 'esto' #loc
local.variable.of.concrete.class.display.name=Variable local de la clase concreta
local.variable.of.concrete.class.problem.descriptor=Variable local ''{0}'' de clase concreta <code>#ref</code> #loc
magic.number.display.name=Número mágico
magic.number.problem.descriptor=Número mágico <code>#ref</code> #loc
method.return.concrete.class.display.name=Método de retorno de la clase concreta
method.return.concrete.class.problem.descriptor=El método devuelve una clase concreta <code>#ref</code> #loc
overly.strong.type.cast.display.name=Reparto de tipo demasiado fuerte
overly.strong.type.cast.weaken.quickfix=Debilitar elenco demasiado fuerte
concrete.class.method.parameter.display.name=Parámetro de método de la clase concreta
concrete.class.method.parameter.problem.descriptor=Parámetro ''{0}'' de la clase concreta <code>#ref</code> #loc
public.method.not.in.interface.display.name=método 'público' no expuesto en la interfaz
public.method.not.in.interface.problem.descriptor=El método 'public' <code>#ref()</code> no se expone a través de una interfaz #loc
public.method.not.in.interface.option=<html> Ignorar si la clase contenedora no implementa una interfaz que no sea de biblioteca </html>
static.variable.of.concrete.class.display.name=Campo estático de la clase concreta
static.variable.of.concrete.class.problem.descriptor=Campo estático ''{0}'' de clase concreta <code>#ref</code> #loc
incompatible.mask.operation.display.name=Operación de máscara bit a bit incompatible
incompatible.mask.operation.problem.descriptor.always.false=<code>#ref</code> es siempre falso #loc
incompatible.mask.operation.problem.descriptor.always.true=<code>#ref</code> es siempre verdadero #loc
pointless.bitwise.expression.display.name=Expresión bit a bit sin sentido
pointless.bitwise.expression.simplify.quickfix=Simplificar
shift.operation.by.inappropriate.constant.display.name=Operación de cambio por constante inapropiada
shift.operation.by.inappropriate.constant.problem.descriptor.too.large=Operación de cambio <code>#ref</code> por un valor constante demasiado grande{0}#loc
shift.operation.by.inappropriate.constant.problem.descriptor.negative=Operación de cambio <code>#ref</code> por valor constante negativo{0}#loc
shift.operation.by.inappropriate.constant.problem.descriptor.out.of.bounds=Operación de cambio <code>#ref</code> por valor fuera de límites{0}#loc
equals.called.on.array.display.name='equals()' llamado en la matriz
equals.called.on.array.problem.descriptor=<code>#ref()</code> entre matrices probablemente debería ser 'Arrays.equals()' #loc
assignment.to.null.display.name=asignación 'nula'
assignment.to.null.problem.descriptor='nulo' asignado a la variable <code>#ref</code> #loc
assignment.to.null.option=Ignorar asignaciones a campos
assignment.to.static.field.from.instance.method.display.name=Asignación a un campo estático desde el contexto de la instancia
assignment.to.static.field.from.instance.method.problem.descriptor=Asignación al campo estático <code>#ref</code> desde el contexto de la instancia #loc
assignment.used.as.condition.display.name=Asignación utilizada como condición
assignment.used.as.condition.problem.descriptor=Asignación <code>#ref</code> usada como condición #loc
cast.conflicts.with.instanceof.display.name=Cast entra en conflicto con 'instanceof'
cast.conflicts.with.instanceof.problem.descriptor=Cast <code>#ref</code> entra en conflicto con la comprobación 'instanceof' #loc circundante
casting.to.incompatible.interface.display.name=Transmitiendo a una interfaz incompatible
casting.to.incompatible.interface.problem.descriptor=Transmitir a interfaz incompatible <code>#ref</code> #loc
collection.added.to.self.display.name=Colección agregada a uno mismo
collection.added.to.self.problem.descriptor=''{0}()'' llamado en la colección <code>#ref</code> con él mismo como argumento #loc
non.final.field.compareto.display.name=Campo no final referenciado en 'compareTo()'
non.final.field.compareto.problem.descriptor=Campo no final <code>#ref</code> al que se accede en 'compareTo()' #loc
covariant.equals.display.name=Covariante 'igual()'
covariant.equals.problem.descriptor=<code>#ref()</code> debe tomar 'Objeto' como argumento #loc
empty.class.initializer.display.name=Inicializador de clase vacía
empty.class.initializer.problem.descriptor=Inicializador de clase vacía #loc
empty.class.initializer.delete.quickfix=Eliminar inicializador de clase vacío
statement.with.empty.body.display.name=Declaración con cuerpo vacío
statement.with.empty.body.problem.descriptor=<code>#ref</code> declaración tiene cuerpo vacío #loc
statement.with.empty.body.include.option=Incluir cuerpos de declaración que son bloques de código vacíos
equals.between.inconvertible.types.display.name='equals()' entre objetos de tipos inconvertibles
equals.between.inconvertible.types.problem.descriptor=<code>#ref</code> entre objetos de tipos inconvertibles ''{0}'' y ''{1}'' #loc
equals.between.inconvertible.types.no.mutual.subclass.problem.descriptor=No se encontró ninguna clase que sea un subtipo de ''{0}'' y ''{1}'' #loc
equals.between.inconvertible.types.mutual.subclass.option=Advertir si no se encuentra ninguna subclase mutua
equals.called.on.suspicious.object.display.name='equals()' llamado en StringBuilder
equals.called.on.suspicious.object.problem.descriptor=Llamada sospechosa '' es igual a '' en el objeto ''{0}''
non.final.field.in.equals.display.name=Campo no final referenciado en 'equals()'
non.final.field.in.equals.problem.descriptor=Campo no final <code>#ref</code> al que se accede en 'equals()' #loc
equals.doesnt.check.class.parameter.display.name=método 'equals()' que no verifica la clase de parámetro
equals.doesnt.check.class.parameter.problem.descriptor=<code>#ref()</code> debe verificar la clase de su parámetro #loc
non.final.field.in.hashcode.display.name=Campo no final referenciado en 'hashCode()'
non.final.field.in.hashcode.problem.descriptor=Campo no final <code>#ref</code> al que se accede en 'hashCode()' #loc
result.of.method.call.ignored.display.name=Resultado de la llamada al método ignorado
result.of.method.call.ignored.problem.descriptor=El resultado de <code>{0}. #ref()</code> se ignora #loc
result.of.method.call.ignored.class.column.title=Nombre de la clase
result.of.method.call.ignored.method.column.title=Nombre del método regex
result.of.method.call.ignored.non.library.option=Informar todas las llamadas ignoradas que no pertenecen a la biblioteca
infinite.recursion.display.name=Recursión infinita
infinite.recursion.problem.descriptor=El método <code>#ref()</code> se repite infinitamente y solo puede terminar lanzando una excepción #loc
instanceof.with.incompatible.interface.display.name='instanceof' con interfaz incompatible
instanceof.with.incompatible.interface.problem.descriptor='instancia de' interfaz incompatible <code>#ref</code> #loc
instantiation.utility.class.display.name=Creación de instancias de la clase de utilidad
instantiation.utility.class.problem.descriptor=Instanciación de la clase de utilidad <code>#ref</code> #loc
iterator.hasnext.which.calls.next.display.name='Iterator.hasNext()' que llama a 'next()'
iterator.hasnext.which.calls.next.problem.descriptor=<code>Iterator. {0}() </code> contiene la llamada a ''#ref()'' #loc
iterator.next.does.not.throw.nosuchelementexception.display.name='Iterator.next()' que no puede lanzar 'NoSuchElementException'
malformed.format.string.display.name=Cadena de formato incorrecto
malformed.format.string.problem.descriptor.malformed=La cadena de formato <code>#ref</code> está mal formada #loc
malformed.format.string.problem.descriptor.illegal=Especificador de cadena de formato ilegal:{0}#loc
malformed.format.string.problem.descriptor.too.many.arguments=Demasiados argumentos para la cadena de formato (encontrado: {0}, esperado: {1}) #loc
malformed.format.string.problem.descriptor.too.few.arguments=Muy pocos argumentos para la cadena de formato (encontrado: {0}, esperado: {1}) #loc
malformed.format.string.problem.descriptor.arguments.do.not.match.type=El tipo de argumento ''{0}'' no coincide con el tipo del especificador de formato ''{1}'' #loc
format.string.error.flags.not.allowed={2, choice, 1#flag | 1 <flags} ''{0}'' no permitido en ''{1}''
format.string.error.unexpected.flag=carácter inesperado ''{0}'' en ''{1}''
format.string.error.duplicate.flag=bandera duplicada ''{0}'' en ''{1}''
format.string.error.width.not.allowed=width (''{0}'') no permitido en ''{1}''
format.string.error.precision.not.allowed=precisión (''{0}'') no permitido en ''{1}''
format.string.error.unnecessary.position.specifier=especificador de posición de argumento innecesario ''{0}'' en ''{1}''
format.string.error.illegal.position.specifier=especificador de posición ilegal ''{0}'' en ''{1}''
format.string.error.previous.element.not.found=bandera anterior '' <'' utilizada pero no se encontró un especificador de formato anterior para ''{0}''
format.string.error.unknown.conversion=conversión desconocida en ''{0}''
format.string.error.invalid.precision=precisión no válida especificada en ''{0}''
format.string.error.illegal.flag.combination=combinación de bandera ilegal ''{0}'' y ''{1}'' en ''{2}''
format.string.error.left.justify.no.width=indicador de justificación a la izquierda '' - '' usado pero ancho no especificado en ''{0}''
format.string.error.zero.padding.no.width=marca de relleno cero ''0'' usada pero ancho no especificado en ''{0}''
mismatched.read.write.array.display.name=Lectura y escritura de matriz no coincidentes
mismatched.read.write.array.problem.descriptor.write.not.read=El contenido de la matriz <code>#ref</code> se escribe, pero nunca se lee #loc
mismatched.read.write.array.problem.descriptor.read.not.write=El contenido de la matriz <code>#ref</code> se lee, pero nunca se escribe en #loc
mismatched.update.collection.display.name=Consulta y actualización de colección no coincidentes
mismatched.update.collection.problem.descriptor.updated.not.queried=El contenido de la colección <code>#ref</code> se actualizó, pero nunca se consultó #loc
mismatched.update.collection.problem.description.queried.not.updated=Se consulta el contenido de la colección <code>#ref</code>, pero nunca se actualiza #loc
rename.quickfix=Cambiar nombre
renameto.quickfix=Cambiar nombre a ''{0}''
misspelled.equals.display.name='equal()' en lugar de 'equals()'
misspelled.equals.problem.descriptor=<code>#ref()</code> método probablemente debería ser 'equals()' #loc
non.short.circuit.boolean.expression.display.name=Expresión booleana sin cortocircuito
non.short.circuit.boolean.expression.problem.descriptor=Expresión booleana sin cortocircuito <code>#ref</code> #loc
non.short.circuit.boolean.expression.replace.quickfix=Reemplazar con expresión de cortocircuito
null.argument.to.var.arg.method.display.name=Argumento confuso para el método varargs
null.argument.to.var.arg.method.problem.descriptor=Argumento confuso <code>#ref</code>, no está claro si se desea una llamada varargs o no varargs #loc
primitive.array.argument.to.var.arg.method.display.name=Argumento de matriz primitivo confuso con el método varargs
primitive.array.argument.to.var.arg.method.problem.descriptor=Argumento de matriz primitivo confuso para el método varargs #loc
object.comparison.display.name=Comparación de objetos usando '==', en lugar de 'equals()'
object.comparison.enumerated.ignore.option=Ignorar '==' entre las variables de enumeración
object.comparison.klass.ignore.option=Ignorar '==' entre los tipos de clases finales sin la implementación de 'equals()'
object.comparison.problem.description=Los valores de los objetos se comparan usando <code>#ref</code>, no 'equals()' #loc
equality.to.safe.equals.quickfix=Reemplazar '==' con nulo seguro 'equals()'
inequality.to.safe.not.equals.quickfix=Reemplazar '! =' con null-safe '! equals()'
default.tostring.call.display.name=Llamar al valor predeterminado 'toString()'
default.tostring.call.problem.descriptor=Llamar al 'toString()' predeterminado en <code>#ref</code> #loc
octal.and.decimal.integers.in.same.array.display.name=Enteros octales y decimales en la misma matriz
octal.and.decimal.integers.in.same.array.problem.descriptor=Enteros octales y decimales en el mismo inicializador de matriz #loc
result.of.object.allocation.ignored.display.name=Resultado de la asignación del objeto ignorado
result.of.object.allocation.ignored.problem.descriptor=El resultado de <code>new #ref()</code> se ignora #loc
use.0index.in.jdbc.resultset.display.name=Uso del índice 0 en JDBC ResultSet
use.0index.in.jdbc.resultset.problem.descriptor=Uso del índice '0' en JDBC ResultSet #loc
use.0index.in.jdbc.prepared.statement.problem.descriptor=Uso del índice '0' en JDBC PreparedStatement #loc
return.of.null.display.name=Devolución de 'nulo'
return.of.null.problem.descriptor=Devolución de <code>#ref</code> #loc
return.of.null.arrays.option=Métodos de informe que devuelven matrices
return.of.null.quickfix=Anotar método como @Nullable
return.of.null.objects.option=Métodos de informe que devuelven objetos
return.of.null.collections.option=Métodos de informe que devuelven objetos de colección
return.of.null.ignore.private.option=Ignorar métodos 'privados', clases anónimas \\& lambda
static.method.via.subclass.display.name=Método estático referenciado a través de una subclase
static.method.via.subclass.problem.descriptor=Método estático <code>#ref()</code> declarado en la clase ''{0}'' pero referenciado mediante la subclase ''{1}'' #loc
static.method.via.subclass.rationalize.quickfix=Racionalizar la llamada al método estático
static.field.via.subclass.display.name=Campo estático referenciado mediante subclase
static.field.via.subclass.problem.descriptor=Campo estático <code>#ref</code> declarado en la clase ''{0}'' pero referenciado mediante la subclase ''{1}'' #loc
static.field.via.subclass.rationalize.quickfix=Racionalizar el acceso al campo estático
string.comparison.display.name=Comparación de cadenas usando '==', en lugar de 'equals()'
number.comparison.display.name=Comparación de números usando '==', en lugar de 'equals()'
string.comparison.problem.descriptor=Los valores de cadena se comparan usando <code>#ref</code>, no 'equals()' #loc
number.comparison.problem.descriptor=Los objetos numéricos se comparan usando <code>#ref</code>, no 'equals()' #loc
subtraction.in.compareto.display.name=Resta en 'compareTo()'
subtraction.in.compareto.problem.descriptor=La resta <code>#ref</code> en 'compareTo()' puede resultar en desbordamiento o pérdida de precisión #loc
text.label.in.switch.statement.display.name=Etiqueta de texto en la declaración 'switch'
text.label.in.switch.statement.problem.descriptor=Etiqueta de texto <code> #ref: </code> in ''switch'' {0, choice, 1#statement | 2#expression} #loc
properties.object.as.hashtable.display.name=Uso del objeto Propiedades como Hashtable
properties.object.as.hashtable.problem.descriptor=Llamada a <code> Hashtable. #ref()</code> en el objeto de propiedades #loc
assignment.replaceable.with.operator.assignment.display.name=Asignación reemplazable por asignación de operador
unnecessary.code.block.display.name=Bloque de código innecesario
unnecessary.code.block.unwrap.quickfix=Desenvolver bloque
redundant.local.variable.display.name=Variable local redundante
redundant.local.variable.ignore.option=Ignorar variables devueltas o lanzadas inmediatamente
redundant.local.variable.annotation.option=Ignorar las variables que tienen una anotación
static.collection.display.name=Colección estática
static.collection.problem.descriptor=Colección estática <code>#ref</code> #loc
static.collection.ignore.option=Ignorar colecciones o mapas estáticos débiles
stringbuffer.field.display.name=campo StringBuilder
stringbuffer.field.problem.descriptor=''{0}'' campo <code>#ref</code> #loc
gc.call.display.name=Llamadas a 'System.gc()' o 'Runtime.gc()'
gc.call.problem.descriptor=<code>#ref</code> no se debe llamar en el código de producción #loc
array.allocation.zero.length.display.name=Asignación de matriz de longitud cero
array.allocation.zero.length.problem.descriptor=Asignación de matriz de longitud cero #loc
constant.for.zero.length.array.display.name=Uso innecesario de matriz de longitud cero
constant.for.zero.length.array.problem.descriptor=La matriz de longitud cero se puede cambiar a constante #loc
constant.for.zero.length.array.quickfix.family=Reemplazar con constante
multiple.loggers.display.name=Clase con varios registradores
logger.name.option=Registrador y nombre de clase:
multiple.loggers.problem.descriptor=Class <code>#ref</code> declara múltiples registradores #loc
no.logger.display.name=Clase sin registrador
no.logger.problem.descriptor=Class <code>#ref</code> no declara un registrador #loc
non.constant.logger.display.name=Registrador no constante
non.constant.logger.problem.descriptor=Campo de registrador no constante <code>#ref</code> #loc
public.method.without.logging.display.name=método 'público' sin registro
public.method.without.logging.problem.descriptor=El método 'public' <code>#ref()</code> no tiene una llamada de registro #loc
ignore.trivial.finalizers.option=Ignorar las implementaciones triviales de 'finalize()'
finalize.declaration.display.name=declaración 'finalize()'
finalize.declaration.problem.descriptor=<code>#ref()</code> declarado #loc
finalize.not.declared.protected.display.name='finalize()' no declarado 'protegido'
finalize.not.declared.protected.problem.descriptor=<code>#ref()</code> no declarado 'protegido' #loc
finalize.called.explicitly.display.name='finalize()' llamado explícitamente
finalize.called.explicitly.problem.descriptor=<code>#ref()</code> llamado explícitamente #loc
java.lang.import.display.name=importación 'java.lang'
java.lang.import.problem.descriptor=Importación innecesaria del paquete 'java.lang' #loc
import.display.name=Importar '*'
import.problem.descriptor=Importación de paquete <code>#ref</code> #loc
redundant.import.display.name=Importación redundante
redundant.import.problem.descriptor=Importación redundante <code>#ref</code> #loc
import.from.same.package.display.name=Importar desde el mismo paquete
import.from.same.package.problem.descriptor=Importación innecesaria desde el mismo paquete <code>#ref</code> #loc
single.class.import.display.name=Importación de clase única
single.class.import.problem.descriptor=Importación de clase única <code>#ref</code> #loc
static.import.display.name=Importación estática
static.import.problem.descriptor=Importación estática <code>#ref</code> #loc
static.import.replace.quickfix=Reemplazar con importación no estática
unused.import.problem.descriptor=Importación no utilizada <code>#ref</code> #loc
clone.instantiates.objects.with.constructor.display.name='clone()' crea una instancia de los objetos con el constructor
clone.instantiates.objects.with.constructor.problem.descriptor='clone()' crea nuevas instancias de <code>#ref</code> #loc
clone.instantiates.new.array.problem.descriptor=''clone()'' crea una nueva matriz{0}#loc
clone.doesnt.declare.clonenotsupportedexception.display.name='clone()' no declara 'CloneNotSupportedException'
clone.doesnt.declare.clonenotsupportedexception.problem.descriptor=<code>#ref()</code> #loc no declara 'CloneNotSupportedException'
clone.doesnt.declare.clonenotsupportedexception.declare.quickfix=Agregar 'CloneNotSupportedException' a la cláusula throws
clone.method.in.non.cloneable.class.display.name=método 'clone()' en una clase no clonable
clone.method.in.non.cloneable.class.problem.descriptor=<code>#ref()</code> definido en la clase no clonable ''{0}'' #loc
clone.method.in.non.cloneable.anonymous.class.problem.descriptor=<code>#ref()</code> definido en una clase anónima no clonable derivada de ''{0}'' #loc
clone.method.in.non.cloneable.interface.problem.descriptor=<code>#ref()</code> definido en la interfaz no clonable ''{0}'' #loc
cloneable.class.without.clone.display.name=Clase clonable sin método 'clone()'
cloneable.class.without.clone.problem.descriptor=<code>#ref</code> no define 'clone()' #loc
cloneable.class.without.clone.ignore.option=Ignorar clases clonables debido a herencia
cloneable.class.without.clone.quickfix=Generar método 'clone()'
class.without.tostring.display.name=Clase sin 'toString()'
class.without.tostring.problem.descriptor=Class <code>#ref</code> probablemente debería implementar 'toString()', con fines de depuración #loc
use.obsolete.collection.type.display.name=Uso de tipo de colección obsoleto
use.obsolete.collection.type.problem.descriptor=Tipo de colección obsoleto <code>#ref</code> usado #loc
use.obsolete.collection.type.ignore.library.arguments.option=Ignore los tipos de colección obsoletos cuando sean necesarios
inspection.suppression.annotation.display.name=Anotación de supresión de inspección
inspection.suppression.annotation.problem.descriptor=Anotación de supresión de inspección <code>#ref</code> #loc
use.system.out.err.display.name=Uso de System.out o System.err
use.system.out.err.problem.descriptor=Los usos de <code>#ref</code> probablemente deberían reemplazarse con un registro más sólido #loc
dumpstack.call.display.name=Llamada a 'Thread.dumpStack()'
dumpstack.call.problem.descriptor=Llamada a <code> Thread. #ref()</code> probablemente debería reemplazarse con un registro más robusto #loc
printstacktrace.call.display.name=Llamar a 'printStackTrace()'
printstacktrace.call.problem.descriptor=La llamada a <code>#ref()</code> probablemente debería reemplazarse con un registro más sólido #loc
abstract.method.call.in.constructor.display.name=Método abstracto llamado durante la construcción del objeto
abstract.method.call.in.constructor.problem.descriptor=Llamada al método 'abstracto' <code>#ref()</code> durante la construcción del objeto #loc
instance.variable.may.not.be.initialized.display.name=El campo de instancia no se puede inicializar
instance.variable.may.not.be.initialized.problem.descriptor=El campo de instancia <code>#ref</code> puede no inicializarse durante la construcción del objeto #loc
instance.Variable.may.not.be.initialized.problem.descriptor.junit=El campo de instancia <code>#ref</code> no se puede inicializar durante la construcción del objeto o la llamada 'setUp()' #loc
primitive.fields.ignore.option=Ignorar campos primitivos
instance.variable.used.before.initialized.display.name=Campo de instancia usado antes de la inicialización
instance.variable.used.before.initialized.problem.descriptor=Campo de instancia <code>#ref</code> usado antes de inicializado #loc
non.final.static.variable.initialization.display.name=El campo estático no final se usa durante la inicialización de la clase
non.final.static.variable.initialization.problem.descriptor=Campo estático no final <code>#ref</code> utilizado durante la inicialización de la clase #loc
overridable.method.call.in.constructor.display.name=Método reemplazable llamado durante la construcción del objeto
overridable.method.call.in.constructor.problem.descriptor=Llamada al método reemplazable <code>#ref()</code> durante la construcción del objeto #loc
overridden.method.call.in.constructor.display.name=Método anulado llamado durante la construcción del objeto
overridden.method.call.in.constructor.problem.descriptor=Llamada al método reemplazado <code>#ref()</code> durante la construcción del objeto #loc
static.variable.may.not.be.initialized.display.name=El campo estático no se puede inicializar
static.variable.may.not.be.initialized.problem.descriptor=El campo estático <code>#ref</code> no se puede inicializar durante la inicialización de la clase #loc
static.variable.used.before.initialization.display.name=Campo estático usado antes de la inicialización
static.variable.used.before.initialization.problem.descriptor=Campo estático <code>#ref</code> usado antes de la inicialización #loc
this.reference.escaped.in.construction.display.name='this' referencia escapada en la construcción del objeto
this.reference.escaped.in.construction.problem.descriptor=Escape de <code>#ref</code> durante la construcción del objeto #loc
assignment.to.catch.block.parameter.display.name=Asignación al parámetro del bloque de captura
extract.parameter.as.local.variable.quickfix=Extraer parámetro como variable local
assignment.to.for.loop.parameter.display.name=Asignación al parámetro de bucle 'for'
assignment.to.for.loop.parameter.check.foreach.option=Verifique los parámetros mejorados de bucle 'for'
assignment.to.for.loop.parameter.problem.descriptor=Asignación al parámetro de bucle for <code>#ref</code> #loc
assignment.to.method.parameter.display.name=Asignación al parámetro del método
chained.equality.comparisons.display.name=Comparaciones encadenadas de igualdad
confusing.octal.escape.sequence.display.name=Secuencia de escape octal confusa
increment.decrement.display.name=Valor de ++ o - usado
nested.assignment.display.name=Resultado de la asignación utilizada
nested.assignment.problem.descriptor=Resultado de la expresión de asignación utilizada #loc
overloaded.methods.with.same.number.parameters.display.name=Métodos sobrecargados con el mismo número de parámetros
overloaded.vararg.method.display.name=Método varargs sobrecargado
refused.bequest.display.name=El método no llama al súper método
reuse.of.local.variable.display.name=Reutilización de variable local
reuse.of.local.variable.split.quickfix=Dividir variable local
character.comparison.display.name=Comparación de personajes
character.comparison.problem.descriptor=Comparación de caracteres <code>#ref</code> en un contexto internacionalizado #loc
package.visible.field.display.name=Campo visible del paquete
package.visible.field.problem.descriptor=Campo visible del paquete <code>#ref</code> #loc
package.visible.inner.class.display.name=Clase anidada visible al paquete
package.visible.inner.class.problem.descriptor=Clase anidada visible al paquete <code>#ref</code> #loc
package.visible.inner.class.ignore.enum.option=Ignorar enumeraciones internas visibles del paquete
package.visible.inner.class.ignore.interface.option=Ignorar interfaces internas visibles para paquetes
protected.field.display.name=Campo protegido
protected.field.problem.descriptor=Campo protegido <code>#ref</code> #loc
protected.inner.class.display.name=Clase anidada protegida
protected.inner.class.problem.descriptor=Clase anidada protegida <code>#ref</code> #loc
protected.inner.class.ignore.enum.option=Ignorar enumeraciones internas 'protegidas'
protected.inner.class.ignore.interface.option=Ignorar interfaces internas 'protegidas'
public.field.display.name=campo 'público'
public.field.problem.descriptor=campo 'público' <code>#ref</code> #loc
public.field.ignore.enum.type.fields.option=Ignorar los campos 'final públicos' de un tipo de enumeración
public.inner.class.display.name=clase anidada 'pública'
public.inner.class.problem.descriptor=clase anidada 'public' <code>#ref</code> #loc
public.inner.class.ignore.enum.option=Ignorar enumeraciones internas 'públicas'
public.inner.class.ignore.interface.option=Ignorar interfaces internas 'públicas'
accessing.non.public.field.of.another.object.display.name=Accediendo a un campo no público de otro objeto
accessing.non.public.field.of.another.object.problem.descriptor=Acceso directo del campo no público <code>#ref</code> en otro objeto #loc
call.to.date.tostring.display.name=Llamar a 'Date.toString()'
call.to.date.tostring.problem.descriptor=<code> Date. #ref()</code> usado en un contexto internacionalizado #loc
magic.character.display.name=Personaje mágico
magic.character.problem.descriptor=Carácter mágico <code>#ref</code> en un contexto internacionalizado #loc
call.to.numeric.tostring.display.name=Llamar a numérico 'toString()'
call.to.numeric.tostring.problem.descriptor=<code>#ref()</code> numérico llamado en un contexto internacionalizado #loc
instantiating.simpledateformat.without.locale.display.name=Creación de una instancia de SimpleDateFormat sin una configuración regional
instantiating.simpledateformat.without.locale.problem.descriptor=Crear una instancia de un <code>#ref</code> sin especificar un Locale en un contexto internacionalizado #loc
string.concatenation.display.name=Concatenación de cadenas
string.concatenation.problem.descriptor=Concatenación de cadenas <code>#ref</code> en un contexto internacionalizado #loc
inspection.option.ignore.system.out=Ignorar los argumentos de 'System.out.print'
inspection.option.ignore.system.err=Ignorar los argumentos 'System.err.print'
inspection.option.ignore.assert=Ignorar los argumentos de descripción de la declaración de afirmación
inspection.option.ignore.exceptions=Ignorar los argumentos del constructor de las subclases Throwable
inspection.option.ignore.nonnls=Ignorar cuando se anota a través de @NonNls
inspection.option.ignore.constant.initializers=Ignorar para inicializadores de campos constantes
inspection.option.ignore.in.annotations=Ignorar en anotaciones
inspection.option.ignore.in.tostring=Ignorar dentro de los métodos toString()
inspection.option.ignore.as.initial.capacity=Ignorar la capacidad inicial para StringBuilders y Colecciones
inspection.option.ignore.in.hashcode=Ignorar constantes en métodos 'hashCode()'
string.touppercase.tolowercase.without.locale.display.name=Llamada a 'String.toUpperCase()' o 'toLowerCase()' sin una configuración regional
string.touppercase.tolowercase.without.locale.problem.descriptor=<code> String. #ref()</code> llamado sin especificar un Locale usando cadenas internacionalizadas #loc
use.stringtokenizer.display.name=Uso de StringTokenizer
use.stringtokenizer.problem.descriptor=<code>#ref</code> en un contexto internacionalizado #loc
time.tostring.call.display.name=Llamar a 'Time.toString()'
time.tostring.call.problem.descriptor=<code> Time. #ref()</code> en un contexto internacionalizado #loc
class.escapes.defined.scope.display.name=La clase no accesible está expuesta
class.escapes.defined.scope.display.module.option=La API del módulo expone clases no exportadas (Java 9+)
class.escapes.defined.scope.display.public.option=La API pública expone clases no accesibles
class.escapes.defined.scope.display.package.option=La API local del paquete expone clases privadas
class.escapes.defined.scope.problem.descriptor=La clase <code>#ref</code> está expuesta fuera de su alcance definido #loc
class.escapes.defined.scope.java9.modules.descriptor=La clase <code>#ref</code> no se exporta desde el módulo ''{0}''
field.name.hides.in.superclass.display.name=El nombre del campo oculta el campo en la superclase
field.name.hides.in.superclass.problem.descriptor=Field <code>#ref</code> oculta el campo en la superclase #loc
field.name.hides.in.superclass.ignore.option=Ignorar campos no accesibles
field.name.hides.in.superclass.ignore.static.field.option=Ignorar campos estáticos que ocultan campos estáticos
inner.class.field.hides.outer.display.name=El campo de clase interior oculta el campo de clase exterior
inner.class.field.hides.outer.ignore.option=Ignorar los campos externos no visibles desde la clase interna
inner.class.field.hides.outer.problem.descriptor=El campo de clase interior <code>#ref</code> oculta el campo de clase exterior #loc
local.variable.hides.member.variable.display.name=La variable local oculta el campo
local.variable.hides.member.variable.problem.descriptor=La variable local <code>#ref</code> oculta el campo en la clase ''{0}'' #loc
local.variable.hides.member.variable.ignore.option=Ignorar variables locales en un contexto estático ocultando campos no estáticos
method.overloads.display.name=El método sobrecarga el método de la superclase
method.overloads.problem.descriptor=El método <code>#ref()</code> sobrecarga un método compatible de una superclase, cuando podría haber sido la anulación #loc
method.overloads.report.incompatible.option=Informe incluso si los tipos de parámetros no son compatibles
method.overrides.private.display.name.problem.descriptor=El método <code>#ref()</code> anula un método 'privado' de una superclase #loc
method.overrides.static.display.name=El método intenta anular el método estático de la superclase
method.overrides.static.problem.descriptor=El método <code>#ref()</code> intenta anular un método estático de una superclase #loc
parameter.hides.member.variable.display.name=El parámetro oculta el campo
parameter.hides.member.variable.problem.descriptor=El parámetro <code>#ref</code> oculta el campo en la clase ''{0}'' #loc
parameter.hides.member.variable.ignore.setters.option=Ignorar para los establecedores de propiedades
parameter.hides.member.variable.ignore.superclass.option=Ignorar los campos de superclase no visibles desde la subclase
parameter.hides.member.variable.ignore.constructors.option=Ignorar para constructores
parameter.hides.member.variable.ignore.abstract.methods.option=Ignorar para métodos abstractos
parameter.hides.member.variable.ignore.static.parameters.option=Ignorar los parámetros de métodos estáticos que ocultan campos de instancia
type.parameter.hides.visible.type.display.name=El parámetro de tipo oculta el tipo visible
type.parameter.hides.visible.type.problem.descriptor=El parámetro de tipo <code>#ref</code> oculta el tipo visible ''{0}'' #loc
type.parameter.hides.type.parameter.problem.descriptor=El parámetro de tipo <code>#ref</code> oculta el parámetro de tipo ''{0}'' #loc
anonymous.class.variable.hides.containing.method.variable.display.name=La variable de clase anónima oculta la variable en el método contenedor
anonymous.class.parameter.hides.containing.method.variable.problem.descriptor=El parámetro de clase anónimo <code>#ref</code> oculta la variable en el método contenedor #loc
anonymous.class.field.hides.containing.method.variable.problem.descriptor=El campo de clase anónimo <code>#ref</code> oculta la variable en el método contenedor #loc
anonymous.class.variable.hides.containing.method.variable.problem.descriptor=La variable local de clase anónima <code>#ref</code> oculta la variable en el método contenedor #loc
channel.opened.not.closed.display.name=Canal abierto pero no cerrado de forma segura
drivermanager.call.display.name=Uso de DriverManager para obtener la conexión JDBC
drivermanager.call.problem.descriptor=Llamar a <code> DriverManager. #ref()</code> #loc
hibernate.resource.opened.not.closed.display.name=Recurso de hibernación abierto pero no cerrado de forma segura
i.o.resource.opened.not.closed.display.name=Recurso de E/S abierto pero no cerrado de forma segura
resource.opened.not.closed.problem.descriptor=''{0}'' debe abrirse frente a un bloque '' try '' y cerrarse en el bloque '' finalmente '' correspondiente #loc
jdbc.resource.opened.not.closed.display.name=recurso JDBC abierto pero no cerrado de forma segura
jndi.resource.opened.not.closed.display.name=Recurso JNDI abierto pero no cerrado de forma segura
socket.opened.not.closed.display.name=Enchufe abierto pero no cerrado de forma segura
annotation.class.display.name=Clase de anotación
annotation.class.problem.descriptor=Clase de anotación <code>#ref</code> #loc
annotation.display.name=Anotación
annotation.problem.descriptor=Anotación <code>#ref</code> #loc
use.assert.as.identifier.display.name=Uso de 'assert' como identificador
use.assert.as.identifier.problem.descriptor=Uso de <code>#ref</code> como identificador #loc
assert.statement.display.name=declaración 'assert'
statement.problem.descriptor=<code>#ref</code> declaración #loc
auto.boxing.display.name=Auto-boxing
auto.boxing.problem.descriptor=Auto-boxing <code>#ref</code> #loc
auto.boxing.make.boxing.explicit.quickfix=Hacer explícito el boxeo
auto.boxing.ignore.added.to.collection.option=Ignorar expresiones agregadas a una colección
auto.unboxing.display.name=Auto-desempaquetado
auto.unboxing.problem.descriptor=Desempaquetado automático <code>#ref</code> #loc
auto.unboxing.make.unboxing.explicit.quickfix=Hacer explícito el unboxing
use.enum.as.identifier.display.name=Uso de 'enum' como identificador
use.enum.as.identifier.problem.descriptor=Uso de <code>#ref</code> como identificador #loc
enumerated.class.display.name=Clase enumerada
enumerated.class.problem.descriptor=Clase enumerada <code>#ref</code> #loc
extended.for.statement.display.name=Extendido 'para' declaración
extended.for.statement.replace.quickfix=Reemplazar con la antigua declaración 'for'
variable.argument.method.display.name=Método Varargs
variable.argument.method.problem.descriptor=Método de Varargs <code>#ref()</code> #loc
variable.argument.method.quickfix=Convertir el parámetro varargs en una matriz
hardcoded.file.separator.display.name=Separador de archivos codificado
hardcoded.file.separator.problem.descriptor=Separador de archivos codificado <code>#ref</code> #loc
hardcoded.file.separator.include.option=Incluir "ejemplo/*" en tipos de medios MIME reconocidos
hardcoded.line.separator.display.name=Separador de línea codificado
hardcoded.line.separator.problem.descriptor=Separador de línea codificado <code>#ref</code> #loc
native.method.display.name=Método nativo
native.method.problem.descriptor=Los métodos declarados <code>#ref</code> no son portátiles #loc
runtime.exec.call.display.name=Llamar a 'Runtime.exec()'
runtime.exec.call.problem.descriptor=Llamada a <code> Runtime. #ref()</code> no es portátil #loc
system.exit.call.display.name=Llamada a 'System.exit()' o métodos relacionados
system.exit.call.problem.descriptor=La llamada a <code> {0}. #ref()</code> no es portátil #loc
system.exit.call.ignore.option=Ignorar en el método principal
system.getenv.call.display.name=Llamar a 'System.getenv()'
system.getenv.call.problem.descriptor=La llamada a <code> System. #ref()</code> no es portátil #loc
use.of.awt.peer.class.display.name=Uso de la clase de pares AWT
use.of.awt.peer.class.problem.descriptor=El uso de la clase de pares AWT <code>#ref</code> no es portátil #loc
use.of.concrete.jdbc.driver.class.display.name=Uso de una clase de controlador JDBC concreta
use.of.concrete.jdbc.driver.class.problem.descriptor=El uso de la clase de controlador JDBC concreto <code>#ref</code> no es portátil #loc
use.processbuilder.class.display.name=Uso de la clase 'java.lang.ProcessBuilder'
use.processbuilder.class.problem.descriptor=El uso de <code>#ref</code> no es portátil #loc
use.sun.classes.display.name=Uso de clases sun. *
use.sun.classes.problem.descriptor=El uso de la clase <code>#ref</code> proporcionada por Sun no es portátil #loc
abstract.class.with.only.one.direct.inheritor.display.name=Clase abstracta que tiene un solo heredero directo
anonymous.inner.may.be.named.static.inner.class.display.name=La clase anónima puede ser una clase interna 'estática' con nombre
anonymous.inner.may.be.named.static.inner.class.problem.descriptor=La clase anónima <code>#ref</code> puede ser una clase interna 'estática' nombrada #loc
array.length.in.loop.condition.display.name=Array.length en condición de bucle
array.length.in.loop.condition.problem.descriptor=Verificación de la matriz <code>#ref</code> en condición de bucle #loc
large.array.allocation.no.outofmemoryerror.display.name=Asignación de matriz grande sin verificación de OutOfMemoryError
large.array.allocation.no.outofmemoryerror.problem.descriptor=Asignación de matriz grande que no se comprueba para la condición de falta de memoria #loc
large.array.allocation.no.outofmemoryerror.maximum.number.of.elements.option=Número máximo de elementos:
connection.opened.not.safely.closed.display.name=Conexión abierta pero no cerrada de forma segura
interface.one.inheritor.display.name=Interfaz que tiene un solo heredero directo
interface.one.inheritor.problem.descriptor=La interfaz <code>#ref</code> tiene solo un heredero directo #loc
method.call.in.loop.condition.display.name=Llamada al método en condición de bucle
method.call.in.loop.condition.problem.descriptor=Llamada al método <code>#ref()</code> en condición de bucle #loc
large.initializer.primitive.type.array.display.name=Inicializador demasiado grande para una matriz de tipo primitivo
large.initializer.primitive.type.array.problem.descriptor=Inicializador de matriz primitivo con demasiados elementos ({0}) #loc
large.initializer.primitive.type.array.maximum.number.of.elements.option=Número máximo de elementos:
private.member.access.between.outer.and.inner.classes.display.name=Llamada de acceso sintético
private.member.access.between.outer.and.inner.classes.problem.descriptor=El acceso al miembro 'privado' de la clase ''{0}'' requiere acceso sintético #loc
private.member.access.between.outer.and.inner.classes.make.local.quickfix=Hacer ''{0}'' paquete-privado
private.member.access.between.outer.and.inner.classes.make.constructor.package.local.quickfix=Hacer privado el paquete del constructor ''{0}''
recordstore.opened.not.safely.closed.display.name=RecordStore abierto pero no cerrado de forma segura
overly.complex.anonymous.inner.class.display.name=Clase anónima demasiado compleja
cyclomatic.complexity.limit.option=Límite de complejidad ciclomática:
overly.complex.anonymous.inner.class.problem.descriptor=Clase anónima demasiado compleja (complejidad ciclomática={0}) #loc
anonymous.inner.class.with.too.many.methods.display.name=Clase interna anónima con demasiados métodos
method.count.limit.option=Límite de recuento de métodos:
anonymous.inner.class.with.too.many.methods.problem.descriptor=Clase interna anónima con demasiados métodos (cuenta de métodos={0}) #loc
overly.complex.class.display.name=Clase demasiado compleja
overly.complex.class.problem.descriptor=Clase demasiado compleja <code>#ref</code> (complejidad ciclomática={0}) #loc
overly.coupled.class.display.name=Clase demasiado acoplada
overly.coupled.class.class.coupling.limit.option=Límite de acoplamiento de clase:
include.java.system.classes.option=Incluir acoplamientos a las clases del sistema java
include.library.classes.option=Incluir acoplamientos a las clases de la biblioteca
overly.coupled.class.problem.descriptor=<code>#ref</code> está demasiado acoplado (dependencias={0}) #loc
class.too.deep.display.name=Clase demasiado profunda en el árbol de herencia
class.too.deep.inheritance.depth.limit.option=Límite de profundidad de herencia:
class.too.deep.problem.descriptor=<code>#ref</code> está demasiado profundo en el árbol de herencia (profundidad de herencia={0}) #loc
inner.class.too.deeply.nested.display.name=Clase interna demasiado anidada
inner.class.too.deeply.nested.nesting.limit.option=Límite de anidamiento:
inner.class.too.deeply.nested.problem.descriptor=<code>#ref</code> está demasiado anidado (nivel de anidamiento={0}) #loc
too.many.constructors.display.name=Clase con demasiados constructores
too.many.constructors.count.limit.option=Límite de recuento de constructores:
too.many.constructors.ignore.deprecated.option=Ignorar constructores obsoletos
too.many.constructors.problem.descriptor=<code>#ref</code> tiene demasiados constructores (constructor count={0}) #loc
too.many.fields.display.name=Clase con demasiados campos
too.many.fields.count.limit.option=Límite de recuento de campos:
too.many.fields.problem.descriptor=<code>#ref</code> tiene demasiados campos (field count={0}) #loc
too.many.methods.display.name=Clase con demasiados métodos
too.many.methods.problem.descriptor=<code>#ref</code> tiene demasiados métodos (método count={0}) #loc
externalizable.with.serialization.methods.display.name=Clase externalizable con 'readObject()' o 'writeObject()'
externalizable.with.serialization.methods.problem.descriptor.both=La clase externalizable <code>#ref</code> define 'readObject()' y 'writeObject()' #loc
externalizable.with.serialization.methods.problem.descriptor.write=La clase externalizable <code>#ref</code> define 'writeObject()' #loc
externalizable.with.serialization.methods.problem.descriptor.read=La clase externalizable <code>#ref</code> define 'readObject()' #loc
non.serializable.with.serialversionuid.display.name=Clase no serializable con 'serialVersionUID'
non.serializable.class.with.serialversionuid.problem.descriptor=La clase no serializable <code>#ref</code> define un campo 'serialVersionUID' #loc
non.serializable.interface.with.serialversionuid.problem.descriptor=Interfaz no serializable <code>#ref</code> define un campo 'serialVersionUID' #loc
non.serializable.@interface.with.serialversionuid.problem.descriptor=No serializable @interface <code>#ref</code> define un campo 'serialVersionUID' #loc
non.serializable.anonymous.with.serialversionuid.problem.descriptor=Clase anónima no serializable que extiende <code>#ref</code> define un campo 'serialVersionUID' #loc
non.serializable.class.with.readwriteobject.display.name=Clase no serializable con 'readObject()' o 'writeObject()'
non.serializable.class.with.readwriteobject.problem.descriptor.both=La clase no serializable <code>#ref</code> define 'readObject()' y 'writeObject()' #loc
non.serializable.class.with.readwriteobject.problem.descriptor.write=Clase no serializable <code>#ref</code> define 'writeObject()' #loc
non.serializable.class.with.readwriteobject.problem.descriptor.read=Clase no serializable <code>#ref</code> define 'readObject()' #loc
non.serializable.anonymous.with.readwriteobject.problem.descriptor.both=Clase anónima no serializable que extiende <code>#ref</code> define 'readObject()' y 'writeObject()' #loc
non.serializable.anonymous.with.readwriteobject.problem.descriptor.write=Clase anónima no serializable que extiende <code>#ref</code> define 'writeObject()' #loc
non.serializable.anonymous.with.readwriteobject.problem.descriptor.read=Clase anónima no serializable que se extiende <code>#ref</code> define 'readObject()' #loc
readwriteobject.private.display.name='readObject()' o 'writeObject()' no declarado como 'privado'
readwriteobject.private.problem.descriptor=<code>#ref</code> no declarado 'privado' #loc
readobject.initialization.display.name=El campo de instancia no puede ser inicializado por 'readObject()'
readobject.initialization.problem.descriptor=Es posible que el campo de instancia <code>#ref</code> no se inicialice durante la llamada de 'readObject()' #loc
readresolve.writereplace.protected.display.name='readResolve()' o 'writeReplace()' no declarado 'protegido'
readresolve.writereplace.protected.problem.descriptor=<code>#ref()</code> no declarado 'protegido' #loc
serialpersistentfields.with.wrong.signature.display.name=El campo 'serialPersistentFields' no se declaró 'Private static final ObjectStreamField[]'
serialpersistentfields.with.wrong.signature.problem.descriptor=El campo <code>#ref</code> de una clase serializable no se declara 'private static final ObjectStreamField []' #loc
serialversionuid.private.static.final.long.display.name='serialVersionUID' campo no declarado 'private static final long'
serialversionuid.private.static.final.long.problem.descriptor=El campo <code>#ref</code> de una clase serializable no se declara 'private static final long' #loc
serialversionuid.private.static.final.long.quickfix=Hacer serialVersionUID 'privado estático final'
serializable.class.without.serialversionuid.display.name=Clase serializable sin 'serialVersionUID'
serializable.class.without.serialversionuid.problem.descriptor=<code>#ref</code> no define un campo 'serialVersionUID' #loc

#dinámica
non.protected.constructor.in.abstract.class.display.name=constructor 'público' en clase 'abstracta'
unnecessary.qualifier.for.this.display.name=Calificador innecesario para 'esto' o 'super'
multiple.declaration.display.name=Varias variables en una declaración
thread.priority.display.name=Llamada a 'Thread.setPriority()'
too.broad.scope.display.name=El alcance de la variable es demasiado amplio
infinite.loop.statement.display.name=Declaración de bucle infinito
asserts.without.messages.display.name=Falta el mensaje en la afirmación
constant.naming.convention.display.name=Convención de nomenclatura constante
constant.naming.convention.element.description=Constante
constant.with.mutable.field.naming.convention.element.description=Constante con tipo de campo mutable
random.double.for.random.integer.display.name=Usando 'Random.nextDouble()' para obtener un entero aleatorio
test.method.without.assertion.display.name=Método de prueba JUnit sin ninguna afirmación
string.buffer.replaceable.by.string.builder.display.name='StringBuffer' puede ser 'StringBuilder'
comparison.of.short.and.char.display.name=Comparación de valores 'short' y 'char'
unnecessary.fully.qualified.name.display.name=Nombre completamente calificado innecesario
ignore.in.module.statements.option=Ignorar en las declaraciones del módulo Java 9
unnecessary.label.on.break.statement.display.name=Etiqueta innecesaria en la declaración 'break'
exception.name.doesnt.end.with.exception.display.name=El nombre de la clase de excepción no termina con 'Exception'
bad.exception.declared.display.name=Excepción prohibida declarada
pointless.boolean.expression.display.name=Expresión booleana sin sentido
class.without.constructor.display.name=Clase sin constructor
break.statement.display.name=declaración 'break'
unconditional.wait.display.name=Llamada incondicional 'wait()'
cyclomatic.complexity.display.name=Método demasiado complejo
final.class.display.name=clase 'final'
labeled.statement.display.name=Declaración etiquetada
notify.called.on.condition.display.name='notificar()' o 'notificar a todos()' llamado en el objeto 'java.util.concurrent.locks.Condition'
loop.statements.that.dont.loop.display.name=Declaración de bucle que no se repite
ignore.enhanced.for.loop.statements=Ignorar bucles mejorados para
thread.run.display.name=Llamada a 'Thread.run()'
non.synchronized.method.overrides.synchronized.method.display.name=El método no sincronizado anula el método sincronizado
synchronize.on.this.display.name=Sincronización en 'esto'
switch.statement.with.too.many.branches.display.name=declaración 'switch' con demasiadas ramas
utility.class.without.private.constructor.display.name=Clase de utilidad sin constructor 'privado'
throw.caught.locally.display.name='throw' atrapado conteniendo la declaración 'try'
exception.from.catch.which.doesnt.wrap.display.name='lanzar' dentro del bloque 'captura' que ignora la excepción detectada
type.parameter.naming.convention.display.name=Convención de nomenclatura de parámetros de tipo
type.parameter.naming.convention.element.description=Tipo de parámetro
multiply.or.divide.by.power.of.two.display.name=Multiplicar o dividir por potencia de dos
multiply.or.divide.by.power.of.two.divide.option=Verifica las divisiones por una potencia de dos también
serializable.with.unconstructable.ancestor.display.name=Clase serializable con ancestro inconstructable
missorted.modifiers.display.name=Modificadores mal clasificados
sleep.while.holding.lock.display.name=Llamar a 'Thread.sleep()' mientras está sincronizado
singleton.display.name=Singleton
thread.death.rethrown.display.name='java.lang.ThreadDeath' no relanzado
if.statement.with.too.many.branches.display.name=declaración 'if' con demasiadas ramas
redundant.implements.display.name=Declaración de interfaz redundante
nesting.depth.display.name=Método demasiado anidado
return.this.display.name=Retorno de 'esto'
busy.wait.display.name=Espera ocupada
utility.class.display.name=Clase de utilidad
instantiating.object.to.get.class.object.display.name=Creación de instancias de objeto para obtener un objeto de clase
abstract.class.extends.concrete.class.display.name=La clase abstracta extiende la clase concreta
parameter.naming.convention.display.name=Convención de nomenclatura de parámetros de método
parameter.naming.convention.element.description=Parámetro
integer.division.in.floating.point.context.display.name=División entera en contexto de punto flotante
interface.naming.convention.display.name=Convención de nomenclatura de la interfaz
interface.naming.convention.element.description=Interfaz
length.one.strings.in.concatenation.display.name=Concatenación de cadena de un solo carácter
length.one.string.in.indexof.display.name=Argumento de cadena de un solo carácter en la llamada 'String.indexOf()'
thread.yield.display.name=Llamada a 'Thread.yield()'
confusing.floating.point.literal.display.name=Confuso literal de punto flotante
wait.not.in.loop.display.name='wait()' not in loop
string.concatenation.inside.string.buffer.append.display.name=Concatenación de cadenas como argumento para la llamada 'StringBuilder.append()'
class.initializer.display.name=Inicializador no 'estático'
enumerated.class.naming.convention.element.description=Enumeración
non.thread.safe.lazy.initialization.display.name=Inicialización perezosa insegura del campo 'estático'
call.to.simple.setter.in.class.display.name=Llamada a establecedor simple desde dentro de la clase
comparison.to.nan.display.name=Comparación con Double.NaN o Float.NaN
instance.method.naming.convention.display.name=Convención de nomenclatura del método de instancia
new.method.naming.convention.display.name=Convención de nomenclatura de métodos
instance.method.naming.convention.element.description=Instancia
unnecessary.semicolon.display.name=Punto y coma innecesario
fallthru.in.switch.statement.display.name=Fallthrough en la declaración 'switch'
call.to.native.method.while.locked.display.name=Llamar a un método nativo mientras está bloqueado
switch.statement.display.name=declaración 'switch'
custom.classloader.display.name=Cargador de clases personalizado
nested.conditional.expression.display.name=Expresión condicional anidada
duplicate.condition.display.name=Condición duplicada
method.with.multiple.loops.display.name=Método con múltiples bucles
non.comment.source.statements.display.name=Método demasiado largo
local.variable.naming.convention.display.name=Convención de nomenclatura de variables locales
local.variable.naming.convention.element.description=Variable local
negated.if.else.display.name=declaración 'if' con condición negada
class.naming.convention.display.name=Convención de nomenclatura de clases
class.naming.convention.element.description=Clase
abstract.class.naming.convention.display.name=Convención de nomenclatura de clases abstractas
abstract.class.naming.convention.element.description=Clase abstracta
serializable.inner.class.with.non.serializable.outer.class.display.name=Clase interna serializable no 'estática' con clase externa no serializable
pointless.arithmetic.expression.display.name=Expresión aritmética sin sentido
method.name.same.as.class.name.display.name=El nombre del método es el mismo que el de la clase
unnecessary.temporary.on.conversion.to.string.display.name=Objeto temporal innecesario en conversión a String
unnecessary.continue.display.name=Declaración 'continuar' innecesaria
inner.class.on.interface.display.name=Clase interna de interfaz
unused.label.display.name=Etiqueta no utilizada
overly.complex.boolean.expression.display.name=Expresión booleana demasiado compleja
continue.statement.with.label.display.name=declaración 'continue' con etiqueta
class.loader.instantiation.display.name=instanciación de ClassLoader
return.from.finally.block.display.name='regresar' dentro del bloque 'finalmente'
unnecessary.boxing.display.name=Boxeo innecesario
annotation.naming.convention.element.description=Anotación
checked.exception.class.display.name=Clase de excepción marcada
switch.statement.with.confusing.declaration.display.name=Variable local utilizada y declarada en diferentes ramas 'switch'
cast.that.loses.precision.display.name=Reparto numérico que pierde precisión
manual.array.copy.display.name=Copia manual de matriz
manual.array.to.collection.copy.display.name=Copia manual de matriz a colección
long.literals.ending.with.lowercase.l.display.name='long' literal que termina con 'l' en lugar de 'L'
overly.complex.arithmetic.expression.display.name=Expresión aritmética demasiado compleja
junit.abstract.test.class.naming.convention.element.description=Prueba abstracta
unnecessary.parentheses.display.name=Paréntesis innecesarios
test.case.in.product.code.display.name=JUnit TestCase en la fuente del producto
test.method.in.product.code.display.name=Método de prueba JUnit en la fuente del producto
serializable.class.in.secure.context.display.name=Clase serializable en contexto seguro
static.variable.naming.convention.display.name=convención de nomenclatura de campos 'estáticos'
static.variable.naming.convention.element.description=campo 'estático'
nested.method.call.display.name=Llamada al método anidado
throw.from.finally.block.display.name='lanzar' dentro del bloque 'finalmente'
field.accessed.synchronized.and.unsynchronized.display.name=Campo al que se accede tanto en contextos sincronizados como no sincronizados
abstract.method.overrides.abstract.method.display.name=El método abstracto anula el método abstracto
static.non.final.field.display.name=campo 'estático', no 'final'
static.non.final.field.option=Solo reportar campos 'públicos'
class.without.no.arg.constructor.display.name=Clase sin constructor sin argumentos
unnecessary.return.display.name=Declaración de 'retorno' innecesaria
final.static.method.display.name=método 'estático' declarado 'final'
constant.declared.in.abstract.class.display.name=Constante declarada en clase abstracta
too.broad.catch.display.name=Bloque 'catch' demasiado amplio
floating.point.equality.display.name=Comparación de igualdad de punto flotante
thrown.exceptions.per.method.display.name=Método con demasiadas excepciones declaradas
public.static.array.field.display.name=campo de matriz 'público estático'
await.not.in.loop.display.name='await()' no está en el bucle
method.names.differ.only.by.case.display.name=Los nombres de los métodos difieren solo por caso
unsecure.random.number.generation.display.name=Generación insegura de números aleatorios
parameters.per.method.display.name=Método con demasiados parámetros
parameters.per.constructor.display.name=Constructor con demasiados parámetros
unnecessary.unboxing.display.name=Unboxing innecesario
extends.thread.display.name=La clase extiende directamente 'java.lang.Thread'
test.case.with.constructor.display.name=JUnit TestCase con constructores no triviales
parameter.name.differs.from.overridden.parameter.display.name=El nombre del parámetro difiere del parámetro en el método anulado
final.private.method.display.name=método 'privado' declarado 'final'
enum.switch.statement.which.misses.cases.display.name=Enum 'switch' statement que no usa mayúsculas y minúsculas
enum.switch.statement.which.misses.cases.option=Ignorar declaraciones de cambio con una rama predeterminada
unconstructable.test.case.display.name=JUnit TestCase no construible
string.buffer.must.have.initial.capacity.display.name=StringBuilder sin capacidad inicial
method.may.be.static.display.name=El método puede ser 'estático'
class.initializer.may.be.static.display.name=El inicializador de clase puede ser 'estático'
class.initializer.option=Solo advertir cuando la clase tiene uno o más constructores
class.initializer.move.code.to.constructor.quickfix=Mover el código inicializador al constructor
nested.switch.statement.display.name='interruptor' anidado
c.style.array.declaration.display.name=Declaración de matriz de estilo C
final.method.in.final.class.display.name=método 'final' en la clase 'final'
extends.annotation.display.name=La clase extiende la interfaz de anotación
naked.notify.display.name='notificar()' o 'notificar a todos()' sin el cambio de estado correspondiente
switch.statement.density.display.name=declaración 'switch' con una densidad de rama demasiado baja
switch.statement.with.too.few.branches.display.name=declaración 'switch' con muy pocas ramas
upper.case.field.name.not.constant.display.name=Campo no constante con nombre en mayúsculas
unnecessary.label.on.continue.statement.display.name=Etiqueta innecesaria en la declaración 'continuar'
jdbc.prepare.statement.with.non.constant.string.display.name=Llamada a 'Connection.prepare *()' con una cadena no constante
synchronize.on.non.final.field.display.name=Sincronización en un campo no final
noop.method.in.abstract.class.display.name=Método sin operación en clase abstracta
non.final.field.of.exception.display.name=Campo no final de la clase de excepción
nested.try.statement.display.name=Declaración 'try' anidada
condition.signal.display.name=Llamada a 'signal()' en lugar de 'signalAll()'
jdbc.execute.with.non.constant.string.display.name=Llamada a 'Statement.execute()' con una cadena no constante
system.set.security.manager.display.name=Llamar a 'System.setSecurityManager()'
system.set.security.manager.problem.descriptor=La llamada a <code> System. #ref()</code> puede plantear problemas de seguridad #loc
control.flow.statement.without.braces.display.name=Declaración de flujo de control sin llaves
trivial.if.display.name=Declaración 'if' redundante
trivial.if.fix.family.name=Simplificar 'si más'
trivial.if.option.ignore.chained=Ignorar declaraciones 'if' encadenadas
thread.with.default.run.method.display.name=Crear una instancia de un hilo con el método predeterminado 'run()'
while.loop.spins.on.field.display.name='while' loop gira en el campo
while.loop.spins.on.field.fix.family.name=Corregir bucle de giro
while.loop.spins.on.field.fix.volatile=Hacer ''{0}'' volátil
while.loop.spins.on.field.fix.spinwait=Agregar hilo.onSpinWait()
while.loop.spins.on.field.fix.volatile.spinwait=Hacer ''{0}'' volátil y agregar Thread.onSpinWait()
test.method.is.public.void.no.arg.display.name=Método de prueba mal formado
if.statement.with.identical.branches.display.name=declaración 'if' con partes comunes
inspection.common.if.parts.message.variables.only=Extraer variables de ''if'' {0}
inspection.common.if.parts.message.with.variables.extract=Extraer parte común con variables de ''if'' {0}
inspection.common.if.parts.message.without.variables.extract=Extraer parte común de ''if'' {0}
inspection.common.if.parts.message.whole.branch=Extraer parte común quitando rama {0}
inspection.common.if.parts.message.complete.duplicate=Contraer la instrucción ''if'' {0}
inspection.common.if.parts.message.complete.duplicate.side.effect=Contraer la declaración "si" y extraer el efecto secundario
inspection.common.if.parts.description.variables.only=Las variables se pueden extraer de ''if'' {0}
inspection.common.if.parts.description.with.variables.extract=Las partes comunes con variables se pueden extraer de ''if'' {0}
inspection.common.if.parts.description.without.variables.extract=La parte común se puede extraer de ''if'' {0}
inspection.common.if.parts.description.whole.branch=La parte común se puede extraer quitando la rama {0}
inspection.common.if.parts.description.complete.duplicate=La declaración ''if'' se puede contraer {0}
inspection.common.if.parts.description.complete.duplicate.side.effect=La declaración 'if' se puede contraer con la extracción de efectos secundarios
inspection.note.may.change.semantics=puede cambiar la semántica
multiple.return.points.per.method.display.name=Método con múltiples puntos de retorno
break.statement.with.label.display.name=declaración 'break' con etiqueta
public.constructor.in.non.public.class.display.name=constructor 'público' en una clase no pública
questionable.name.display.name=Nombre cuestionable
empty.finally.block.display.name=Bloque 'finalmente' vacío
abstract.method.overrides.concrete.method.display.name=El método abstracto anula el método concreto
thread.stop.suspend.resume.display.name=Llamada a 'Thread.stop()', 'suspend()' o 'resume()'
constant.math.call.display.name=Llamada constante a 'java.lang.Math'
volatile.array.field.display.name=Campo de matriz volátil
literal.as.arg.to.string.equals.display.name='expresión.equals ("literal")' en lugar de '"literal" .equals (expresión)'
inner.class.may.be.static.display.name=La clase interna puede ser 'estática'
static.suite.display.name='suite()' método no declarado 'estático'
redundant.field.initialization.display.name=Inicialización de campo redundante
string.buffer.to.string.in.concatenation.display.name='StringBuilder.toString()' en concatenación
utility.class.with.public.constructor.display.name=Clase de utilidad con constructor 'público'
for.loop.replaceable.by.while.display.name=El bucle 'for' se puede reemplazar con el bucle 'while'
missing.deprecated.annotation.display.name=Falta anotación @Deprecated
cloneable.class.in.secure.context.display.name=Clase clonable en contexto seguro
static.inheritance.display.name=Herencia estática
class.name.prefixed.with.package.name.display.name=Nombre de clase con el prefijo del nombre del paquete
call.to.simple.getter.in.class.display.name=Llamar a un captador simple desde dentro de la clase
class.name.differs.from.file.name.display.name=El nombre de la clase difiere del nombre del archivo
protected.member.in.final.class.display.name=miembro 'protegido' en la clase 'final'
load.library.with.non.constant.string.display.name=Llamada a 'System.loadLibrary()' con una cadena no constante
instanceof.catch.parameter.display.name='instanceof' en el parámetro 'catch'
implicit.numeric.conversion.display.name=Conversión numérica implícita
unnecessary.interface.modifier.display.name=Modificador de interfaz innecesario
confusing.main.method.display.name=Método 'main()' confuso
octal.literal.display.name=Entero octal
misordered.assert.equals.arguments.display.name=Argumentos 'assertEquals()' mal ordenados
unnecessary.constructor.display.name=Constructor redundante sin argumentos
method.name.same.as.parent.name.display.name=El nombre del método es el mismo que el de la clase principal
while.can.be.foreach.display.name='while' bucle reemplazable con bucle mejorado 'for'
big.decimal.equals.display.name='equals()' llamado en 'java.math.BigDecimal'
implicit.call.to.super.display.name=Llamada implícita a 'super()'
empty.catch.block.display.name=Bloque 'catch' vacío
unqualified.static.usage.display.name=Acceso estático no calificado
simplifiable.junit.assertion.display.name=Aserción simplificable
object.notify.display.name=Llamar a 'notificar()' en lugar de 'notificar a todos()'
thread.start.in.construction.display.name=Llamada a 'Thread.start()' durante la construcción del objeto
non.final.clone.display.name='clone()' no final en contexto seguro
unnecessary.temporary.on.conversion.from.string.display.name=Objeto temporal innecesario en la conversión de String
unnecessary.this.display.name=Calificador 'este' innecesario
unnecessary.this.ignore.assignments.option=Ignorar asignaciones de campo
runtime.exec.with.non.constant.string.display.name=Llamada a 'Runtime.exec()' con una cadena no constante
system.properties.display.name=Acceso a las propiedades del sistema
chained.method.call.display.name=Llamadas a métodos encadenados
safe.lock.display.name=Bloqueo adquirido pero no desbloqueado de forma segura
system.run.finalizers.on.exit.display.name=Llamada a 'System.runFinalizersOnSalir()'
for.can.be.foreach.display.name=bucle 'for' reemplazable con bucle 'for' mejorado
type.parameter.extends.object.display.name=El parámetro de tipo extiende explícitamente 'java.lang.Object'
type.parameter.extends.object.ignore.annotated=Ignorar cuando se anota java.lang.Object
marker.interface.display.name=Interfaz de marcador
limited.scope.inner.class.display.name=Clase interna de alcance limitado
switch.statements.without.default.display.name=declaración 'switch' sin rama 'predeterminada'
unchecked.exception.class.display.name=Clase de excepción sin marcar
for.loop.with.missing.component.display.name=bucle 'for' con componentes faltantes
for.loop.with.missing.component.collection.loop.option=Ignorar iteraciones de colección
double.checked.locking.display.name=Bloqueo con doble verificación
double.checked.locking.problem.descriptor=Bloqueo con doble verificación #loc
double.checked.locking.ignore.on.volatiles.option=Ignore el bloqueo doblemente verificado en campos volátiles
string.buffer.replaceable.by.string.display.name='StringBuilder' puede ser reemplazado por 'String'
boolean.method.name.must.start.with.question.display.name=El nombre del método booleano debe comenzar con la palabra pregunta
class.name.same.as.ancestor.name.display.name=Nombre de clase igual al nombre del ancestro
error.rethrown.display.name='java.lang.Error' no relanzado
serializable.has.serialization.methods.display.name=Clase serializable sin 'readObject()' y 'writeObject()'
serializable.has.serialization.methods.ignore.option=Ignorar clases que no definen campos de instancia
missing.override.annotation.display.name=Falta la anotación @Override
wait.while.holding.two.locks.display.name='wait()' mientras mantiene dos candados
empty.class.display.name=Clase vacía
trivial.string.concatenation.display.name=Concatenación con cadena vacía
empty.synchronized.statement.display.name=Declaración vacía 'sincronizada'
unnecessary.default.display.name='predeterminado' innecesario para la declaración de enum 'switch'
simplifiable.conditional.expression.display.name=Expresión condicional simplificable
unnecessary.super.constructor.display.name=Llamada innecesaria a 'super()'
unnecessarily.qualified.static.usage.display.name=Acceso estático innecesariamente calificado
bad.exception.caught.display.name=Excepción prohibida capturada
custom.security.manager.display.name=Administrador de seguridad personalizado
string.concatenation.in.loops.display.name=Concatenación de cadenas en bucle
boolean.constructor.display.name=Llamada al constructor booleano
continue.statement.display.name=declaración 'continue'
extends.object.display.name=La clase extiende explícitamente 'java.lang.Object'
serializable.inner.class.has.serial.version.uid.field.display.name=Clase interna serializable no 'estática' sin 'serialVersionUID'
static.method.naming.convention.display.name=convención de nomenclatura de métodos 'estáticos'
static.method.naming.convention.element.description='static'
empty.try.block.display.name=Bloque vacío 'try'
field.has.setter.but.no.getter.display.name=El campo tiene un setter pero no un getter
three.negations.per.method.display.name=Método con más de tres negaciones
conditional.expression.display.name=Expresión condicional (? :)
unnecessary.enum.modifier.display.name=Modificador de enumeración innecesario
string.equals.empty.string.display.name='String.equals ("")'
synchronize.on.lock.display.name=Sincronización en un objeto de bloqueo
synchronized.on.literal.object.name=Sincronización en un objeto inicializado con un literal
field.may.be.static.display.name=El campo puede ser 'estático'
class.may.be.interface.display.name=La clase abstracta puede ser interfaz
abstract.class.without.abstract.methods.display.name=Clase abstracta sin métodos abstractos
divide.by.zero.display.name=Dividir por cero
default.not.last.case.in.switch.display.name='default' no es el último caso en la declaración 'switch'
nested.synchronized.statement.display.name=Declaración 'sincronizada' anidada
constant.conditional.expression.display.name=Expresión condicional constante
redundant.else.display.name='else' redundante
public.field.accessed.in.synchronized.context.display.name=Campo no privado al que se accede en contexto sincronizado
string.replaceable.by.string.buffer.display.name=La cadena no constante debe ser StringBuilder
junit.test.class.naming.convention.display.name=Convención de nomenclatura de clases de prueba JUnit
junit.test.class.naming.convention.element.description=Prueba
junit.test.suite.naming.convention.element.description=Conjunto de pruebas
method.coupling.display.name=Método demasiado acoplado
collections.must.have.initial.capacity.display.name=Colección sin capacidad inicial
anonymous.inner.class.display.name=Clase interna anónima
negated.conditional.display.name=Expresión condicional con condición negada
non.reproducible.math.call.display.name=Llamada no reproducible a 'java.lang.Math'
multiple.top.level.classes.in.file.display.name=Varias clases de nivel superior en un solo archivo
set.replaceable.by.enum.set.display.name=Conjunto reemplazable con EnumSet
non.static.inner.class.in.secure.context.display.name=Clase interna no 'estática' en contexto seguro
tail.recursion.display.name=Recursión de cola
finally.block.cannot.complete.normally.display.name='finalmente' bloque que no se puede completar normalmente
non.atomic.operation.on.volatile.field.display.name=Operación no atómica en campo volátil
public.static.collection.field.display.name=campo de colección 'público estático'
non.exception.name.ends.with.exception.display.name=El nombre de la clase que no es una excepción termina con 'Exception'
synchronized.method.display.name=método 'sincronizado'
enumerated.constant.naming.convention.element.description=Constante enumerada
final.method.display.name=método 'final'
transient.field.in.non.serializable.class.display.name=Campo transitorio en clase no serializable
bad.exception.thrown.display.name=Se ha lanzado una excepción prohibida
conditional.expression.with.identical.branches.display.name=Expresión condicional con ramas idénticas
conditional.can.be.pushed.inside.expression.display.name=El condicional se puede insertar dentro de la expresión de la rama
conditional.can.be.pushed.inside.expression.option=Ignorar cuando condicional será el único argumento de una llamada de método
conditional.can.be.pushed.inside.expression.quickfix=Insertar expresión condicional dentro de la rama
raw.use.of.parameterized.type.display.name=Uso sin procesar de la clase parametrizada
standard.variable.names.display.name=Nombres de variables estándar
field.naming.convention.display.name=Convención de nomenclatura de campos
instance.variable.naming.convention.element.description=Campo de instancia
dollar.sign.in.name.display.name=Uso de '$' en el identificador
map.replaceable.by.enum.map.display.name=Mapa reemplazable con EnumMap
extends.concrete.collection.display.name=La clase extiende explícitamente una clase de Colección
continue.or.break.from.finally.block.display.name='continuar' o 'romper' dentro del bloque 'finalmente'
abstract.method.with.missing.implementations.display.name=Método abstracto con implementaciones faltantes
object.allocation.in.loop.display.name=Asignación de objetos en bucle
wait.called.on.condition.display.name='wait()' llamado en el objeto 'java.util.concurrent.locks.Condition'
test.case.with.no.test.methods.display.name=Clase de prueba sin pruebas
abstract.class.never.implemented.display.name=Clase abstracta que no tiene subclase concreta
interface.never.implemented.display.name=Interfaz que no tiene una subclase concreta
constant.declared.in.interface.display.name=Constante declarada en la interfaz


# descriptores de problemas
exception.name.doesnt.end.with.exception.problem.descriptor=El nombre de la clase de excepción <code>#ref</code> no termina con 'Exception' #loc
non.exception.name.ends.with.exception.problem.descriptor=El nombre de clase sin excepción <code>#ref</code> termina con 'Exception' #loc
class.name.prefixed.with.package.name.problem.descriptor=El nombre de la clase <code>#ref</code> comienza con su nombre de paquete #loc
class.name.same.as.ancestor.name.problem.descriptor=El nombre de la clase <code>#ref</code> es el mismo que uno de los nombres de su superclase #loc
method.name.same.as.class.name.problem.descriptor=El nombre del método <code>#ref</code> es el mismo que su nombre de clase #loc
method.name.same.as.parent.name.problem.descriptor=El nombre del método <code>#ref</code> es el mismo que el nombre de la clase principal #loc
boolean.method.name.must.start.with.question.problem.descriptor=El nombre del método booleano <code>#ref</code> no comienza con la palabra de pregunta #loc
questionable.name.problem.descriptor=Nombre cuestionable <code>#ref</code> #loc
confusing.main.method.problem.descriptor=Método llamado <code>#ref</code> sin firma 'public static void main (String [])' #loc
upper.case.field.name.not.constant.problem.descriptor=Campo no constante <code>#ref</code> con nombre de estilo constante #loc
dollar.sign.in.name.problem.descriptor=El identificador <code>#ref</code> contiene '$' #loc
integer.division.in.floating.point.context.problem.descriptor=<code>#ref</code>: división de enteros en contexto de punto flotante #loc
comparison.of.short.and.char.problem.descriptor=Comparación de igualdad <code>#ref</code> de valores cortos y char #loc
big.decimal.equals.problem.descriptor=<code>#ref()</code> entre los valores BigDecimal probablemente debería ser 'compareTo()' #loc
divide.by.zero.problem.descriptor=División por cero #loc
non.reproducible.math.call.problem.descriptor=<code> Math. #ref()</code> puede producir resultados no reproducibles #loc
constant.math.call.problem.descriptor=La llamada constante a <code>#ref()</code> se puede simplificar #loc
floating.point.equality.problem.descriptor=<code>#ref</code>: valores de punto flotante comparados para la igualdad exacta #loc
fallthru.in.switch.statement.problem.descriptor=Fallthrough in 'switch' statement #loc
switch.statements.without.default.problem.descriptor=<code>#ref</code> declaración sin rama 'predeterminada' #loc
default.not.last.case.in.switch.problem.descriptor=<code>#ref</code> rama no es el último caso en 'switch'{0}#loc
loop.statements.that.dont.loop.problem.descriptor=La declaración <code>#ref</code> no se repite #loc
conditional.expression.with.identical.branches.problem.descriptor=Expresión condicional <code>#ref</code> con ramas idénticas #loc
conditional.can.be.pushed.inside.expression.problem.descriptor=La expresión condicional se puede insertar dentro de la rama #loc
duplicate.condition.problem.descriptor=Condición duplicada <code>#ref</code> #loc
duplicate.condition.ignore.method.calls.option=Ignorar condiciones con efectos secundarios
duplicate.boolean.branch.problem.descriptor=Rama duplicada <code>#ref</code> #loc
iterator.next.does.not.throw.nosuchelementexception.problem.descriptor=<code>Iterator. #ref()</code> que no puede lanzar 'NoSuchElementException' #loc
infinite.loop.statement.problem.descriptor=<code>#ref</code> declaración no se puede completar sin lanzar una excepción #loc
confusing.floating.point.literal.problem.descriptor=Confuso literal de coma flotante <code>#ref</code> #loc
overly.complex.arithmetic.expression.problem.descriptor=Expresión aritmética demasiado compleja #loc
overly.complex.boolean.expression.problem.descriptor=Expresión booleana demasiado compleja ({0} términos) #loc
labeled.statement.problem.descriptor=Instrucción etiquetada <code> #ref: </code> #loc
break.statement.with.label.problem.descriptor=<code>#ref</code> declaración con etiqueta #loc
continue.statement.with.label.problem.descriptor=<code>#ref</code> declaración con etiqueta #loc
conditional.expression.problem.descriptor=Expresión condicional <code>#ref</code> #loc
conditional.expression.option=Ignorar para asignaciones simples y devoluciones
conditional.expression.expression.context.option=Ignorar lugares donde una declaración if no es posible
conditional.expression.quickfix=Reemplazar con la declaración 'if'
nested.conditional.expression.problem.descriptor=Expresión condicional anidada <code>#ref</code> #loc
long.literals.ending.with.lowercase.l.problem.descriptor='long' literal <code>#ref</code> termina en minúscula 'l' #loc
nested.switch.statement.problem.descriptor=<code>#ref</code> anidado{0}#loc
chained.method.call.problem.descriptor=Llamada al método encadenado <code>#ref()</code> #loc
nested.method.call.problem.descriptor=Llamada al método anidado <code>#ref()</code> #loc
octal.literal.problem.descriptor=Entero octal <code>#ref</code> #loc
implicit.call.to.super.problem.descriptor=Llamada implícita a 'super()' #loc
negated.if.else.problem.descriptor=<code>#ref</code> declaración con condición negada #loc
negated.conditional.problem.descriptor=Expresión condicional con condición negada #loc
redundant.else.problem.descriptor=<code>#ref</code> rama se puede desenvolver, ya que la rama 'if' nunca se completa normalmente #loc
switch.statement.with.confusing.declaration.problem.descriptor=Variable local <code>#ref</code> declarada en una rama 'switch' y utilizada en otra #loc
raw.use.of.parameterized.type.problem.descriptor=Uso sin procesar de la clase parametrizada <code>#ref</code> #loc
final.class.problem.descriptor=Clase declarada <code>#ref</code> #loc
empty.class.problem.descriptor=La clase <code>#ref</code> está vacía #loc
empty.enum.problem.descriptor=Enum <code>#ref</code> está vacío #loc
empty.class.file.without.class.problem.descriptor=El archivo Java no declara ninguna clase #loc
empty.anonymous.class.problem.descriptor=La clase anónima está vacía #loc
anonymous.inner.class.problem.descriptor=Clase interna anónima <code>#ref</code> #loc
limited.scope.inner.class.problem.descriptor=Clase interna de alcance limitado <code>#ref</code> #loc
final.method.problem.descriptor=Método declarado <code>#ref</code> #loc
class.initializer.problem.descriptor=Inicializador no 'estático' #loc
class.may.be.interface.problem.descriptor=La clase abstracta <code>#ref</code> puede ser la interfaz #loc
non.protected.constructor.in.abstract.class.problem.descriptor=El constructor <code>#ref()</code> no está declarado 'protegido' en la clase 'abstracta' #loc
class.without.constructor.problem.descriptor=Class <code>#ref</code> no tiene constructor #loc
abstract.class.without.abstract.methods.problem.descriptor=La clase <code>#ref</code> se declara 'abstracta' y no tiene métodos 'abstractos' #loc
final.method.in.final.class.problem.descriptor=Método declarado <code>#ref</code> en la clase 'final' #loc
protected.member.in.final.class.problem.descriptor=Miembro de clase declarado <code>#ref</code> en la clase 'final' #loc
utility.class.with.public.constructor.problem.descriptor=La clase <code>#ref</code> solo tiene miembros 'estáticos' y un constructor 'público' #loc
utility.class.without.private.constructor.problem.descriptor=La clase <code>#ref</code> solo tiene miembros 'estáticos' y carece de un constructor 'privado' #loc
abstract.method.overrides.concrete.method.problem.descriptor=El método abstracto <code>#ref()</code> anula el método concreto #loc
abstract.method.with.missing.implementations.problem.descriptor=El método abstracto <code>#ref()</code> no está implementado en todas las subclases #loc
abstract.method.overrides.abstract.method.problem.descriptor=El método abstracto <code>#ref()</code> anula el método abstracto #loc
abstract.method.overrides.abstract.method.ignore.different.javadoc.option=Ignorar métodos con un Javadoc diferente al de sus súper métodos
abstract.class.extends.concrete.class.problem.descriptor=La clase <code>#ref</code> se declara 'abstracta' y extiende una clase concreta #loc
static.non.final.field.problem.descriptor=campo 'estático' no 'final' <code>#ref</code> #loc
constant.declared.in.abstract.class.problem.descriptor=Constante <code>#ref</code> declarada en la clase abstracta #loc
constant.declared.in.interface.problem.descriptor=Constante <code>#ref</code> declarada en la interfaz #loc
static.inheritance.problem.descriptor=La interfaz <code>#ref</code> se implementa solo para sus constantes 'estáticas' #loc
utility.class.problem.descriptor=La clase <code>#ref</code> solo tiene miembros 'estáticos', lo que indica la construcción de procedimientos #loc
singleton.problem.descriptor=Class <code>#ref</code> es un singleton #loc
enum.singleton.problem.descriptor=Enum <code>#ref</code> es un singleton #loc
final.private.method.problem.descriptor=método 'privado' declarado <code>#ref</code> #loc
noop.method.in.abstract.class.problem.descriptor=El método sin operación <code>#ref()</code> debe hacerse abstracto #loc
final.static.method.problem.descriptor=método 'estático' declarado <code>#ref</code> #loc
class.without.no.arg.constructor.problem.descriptor=<code>#ref</code> no tiene constructor sin argumentos #loc
multiple.top.level.classes.in.file.problem.descriptor=Varias clases de nivel superior en el archivo
class.name.differs.from.file.name.problem.descriptor=El nombre de la clase <code>#ref</code> difiere del nombre de archivo #loc
marker.interface.problem.descriptor=Interfaz de marcador <code>#ref</code> #loc
field.has.setter.but.no.getter.problem.descriptor=Field <code>#ref</code> tiene setter pero no getter #loc
abstract.class.never.implemented.problem.descriptor=La clase abstracta <code>#ref</code> no tiene una subclase concreta #loc
interface.never.implemented.problem.descriptor=Interface <code>#ref</code> no tiene una subclase concreta #loc
missing.deprecated.annotation.problem.descriptor=Falta la anotación '@Deprecated' #loc
missing.deprecated.tag.problem.descriptor=Falta la explicación de la etiqueta Javadoc '@deprecated' #loc
missing.deprecated.tag.option=Advertir sobre la explicación de la etiqueta Javadoc @deprecated que falta
missing.override.annotation.problem.descriptor=Falta la anotación '@Override' en <code>#ref()</code> #loc
missing.override.annotation.in.overriding.problem.descriptor=Los métodos anulados no se anotan con '@Override'
non.thread.safe.lazy.initialization.problem.descriptor=La inicialización diferida del campo 'estático' <code>#ref</code> no es seguro para subprocesos #loc
empty.finally.block.problem.descriptor=Bloque <code>#ref</code> vacío #loc
finally.block.cannot.complete.normally.problem.descriptor=<code>#ref</code> el bloque no se puede completar normalmente #loc
empty.try.block.problem.descriptor=Bloque <code>#ref</code> vacío #loc
throw.from.finally.block.problem.descriptor=<code>#ref</code> dentro del bloque 'finalmente' #loc
possible.throw.from.finally.block.problem.descriptor=<code>{0}</code> podría ser lanzado dentro del bloque '' finalmente '' #loc
throw,from.finally.block.everywhere.option=Advertir en todos los lugares donde se pueden lanzar excepciones declaradas
throw.caught.locally.problem.descriptor=<code>#ref</code> detectado al contener la declaración 'try' #loc
throw.caught.locally.ignore.option=Ignorar las excepciones repetidas
return.from.finally.block.problem.descriptor=<code>#ref</code> dentro del bloque 'finalmente' #loc
continue.or.break.from.finally.block.problem.descriptor=<code>#ref</code> dentro del bloque 'finalmente' #loc
bad.exception.declared.problem.descriptor=Excepción prohibida <code>#ref</code> declarada #loc
bad.exception.caught.problem.descriptor=Excepción prohibida <code>#ref</code> capturada #loc
checked.exception.class.problem.descriptor=Clase de excepción marcada <code>#ref</code> #loc
unchecked.exception.class.problem.descriptor=Clase de excepción sin marcar <code>#ref</code> #loc
thread.death.rethrown.problem.descriptor=ThreadDeath <code>#ref</code> no relanzado #loc
error.rethrown.problem.descriptor=Error <code>#ref</code> no reiniciado #loc
nested.try.statement.problem.descriptor=Instrucción <code>#ref</code> anidada #loc
exception.from.catch.which.doesnt.wrap.problem.descriptor=<code>#ref</code> dentro del bloque 'catch' ignora la excepción detectada #loc
instanceof.catch.parameter.problem.descriptor='instanceof' en el parámetro 'catch' <code>#ref</code> #loc
non.final.field.of.exception.problem.descriptor=Campo no final <code>#ref</code> de la clase de excepción #loc
unnecessary.label.on.break.statement.problem.descriptor=Etiqueta innecesaria en la declaración <code>#ref</code> #loc
unnecessary.label.on.continue.statement.problem.descriptor=Etiqueta innecesaria en la declaración <code>#ref</code> #loc
trivial.if.problem.descriptor=<code>#ref</code> declaración se puede simplificar #loc
unnecessary.parentheses.problem.descriptor=Los paréntesis alrededor de <code>#ref</code> son innecesarios #loc
unnecessary.local.variable.problem.descriptor=La variable local <code>#ref</code> es redundante #loc
unnecessary.this.problem.descriptor=<code>#ref</code> no es necesario en este contexto #loc
unnecessary.block.statement.problem.descriptor=Las llaves alrededor de esta declaración son innecesarias #loc
unnecessary.continue.problem.descriptor=<code>#ref</code> no es necesario como última declaración en un bucle #loc
unnecessary.semicolon.problem.descriptor=Punto y coma innecesario <code>#ref</code> #loc
unnecessary.semicolon.ignore.after.enum.constants.option=Ignorar puntos y comas innecesarios después de las constantes enum
unnecessary.fully.qualified.name.problem.descriptor1=El calificador <code>#ref</code> no es necesario y puede reemplazarse con un #loc de importación
unnecessary.fully.qualified.name.problem.descriptor2=El calificador <code>#ref</code> es innecesario y se puede eliminar #loc
unnecessary.qualifier.for.this.problem.descriptor=El calificador <code>#ref</code> en 'esto' es innecesario en este contexto #loc
unnecessary.qualifier.for.super.problem.descriptor=El calificador <code>#ref</code> en 'super' no es necesario en este contexto #loc
unused.label.problem.descriptor=Etiqueta no utilizada <code>#ref</code> #loc
redundant.field.initialization.problem.descriptor=La inicialización del campo a <code>#ref</code> es redundante #loc
redundant.implements.problem.descriptor=Declaración de interfaz redundante <code>#ref</code> #loc
extends.object.problem.descriptor=Class <code>#ref</code> extiende explícitamente 'java.lang.Object' #loc
type.parameter.extends.object.problem.descriptor1=El parámetro de tipo <code>#ref</code> extiende explícitamente 'java.lang.Object' #loc
type.parameter.extends.object.problem.descriptor2=El argumento de tipo comodín <code>#ref</code> extiende explícitamente 'java.lang.Object' #loc
unnecessary.super.constructor.problem.descriptor=<code>#ref</code> es innecesario #loc
unnecessary.constructor.problem.descriptor=El constructor sin argumentos <code>#ref()</code> es redundante #loc
unnecessary.constructor.annotation.option=Ignorar constructores con una anotación
for.loop.replaceable.by.while.problem.descriptor=<code>#ref</code> La declaración de bucle se puede reemplazar por el bucle 'while' #loc
unnecessary.default.problem.descriptor=<code>#ref</code> rama es innecesaria #loc
unnecessary.default.expressions.option=Solo reportar expresiones de cambio
unnecessary.default.quickfix=Eliminar la rama 'predeterminada'
unnecessary.boxing.problem.descriptor=Boxeo innecesario <code>#ref</code> #loc
unnecessary.boxing.inside.value.of.problem.descriptor=Boxing redundante dentro de <code>#ref</code> #loc
unnecessary.unboxing.problem.descriptor=Desembalaje innecesario <code>#ref</code> #loc
unnecessary.boxing.superfluous.option=Solo reportar expresiones verdaderamente superfluas en cajas
unnecessary.unboxing.superfluous.option=Solo reportar expresiones verdaderamente superfluas sin caja
for.can.be.foreach.problem.descriptor=<code>#ref</code> bucle reemplazable con mejorado 'for' #loc
while.can.be.foreach.problem.descriptor=<code>#ref</code> bucle reemplazable con mejorado 'for' #loc
too.broad.scope.problem.descriptor=El alcance de la variable <code>#ref</code> es demasiado amplio #loc
return.this.problem.descriptor=Devolución de <code>#ref</code> #loc
constant.on.side.of.comparison.display.name=Constante en el lado equivocado de la comparación
constant.on.lhs.of.comparison.problem.descriptor=Constante <code>#ref</code> en el lado izquierdo de la comparación #loc
constant.on.rhs.of.comparison.problem.descriptor=Constante <code>#ref</code> en el lado derecho de la comparación #loc
control.flow.statement.without.braces.problem.descriptor=<code>{0}</code> sin llaves #loc
missorted.modifiers.problem.descriptor=Modificadores mal clasificados <code>{0}</code> #loc
cstyle.array.variable.declaration.problem.descriptor=Declaración de matriz de estilo C de {0, choice, 1#campo | 2#parámetro | 3#componente de registro | 4#variable local} <code>#ref</code> #loc
cstyle.array.method.declaration.problem.descriptor=Declaración de matriz de estilo C del tipo de retorno del método <code>#ref()</code> #loc
multiple.declaration.problem.descriptor=Varias variables en una declaración #loc
multiple.typed.declaration.problem.descriptor=Variables con diferente dimensión de matriz en una declaración #loc
serializable.inner.class.has.serial.version.uid.field.problem.descriptor=La clase interna <code>#ref</code> no define un campo 'serialVersionUID' #loc
serializable.inner.class.with.non.serializable.outer.class.problem.descriptor=La clase interna <code>#ref</code> es serializable mientras que su clase externa no es #loc
busy.wait.problem.descriptor=Llamada a <code>Thread. #ref()</code> en un bucle, probablemente ocupado esperando #loc
sleep.while.holding.lock.problem.descriptor=Llamar a <code>Thread. #ref()</code> mientras está sincronizado #loc
non.atomic.operation.on.volatile.field.problem.descriptor=Operación no atómica en campo volátil <code>#ref</code> #loc
call.to.native.method. while.locked.problem.descriptor=Llamada al método nativo <code>#ref()</code> en un contexto sincronizado #loc
object.notify.problem.descriptor=<code>#ref</code> probablemente debería reemplazarse con 'notifyAll()' #loc
condition.signal.problem.descriptor=<code>#ref</code> probablemente debería reemplazarse con 'signalAll()' #loc
thread.with.default.run.method.problem.descriptor=Creación de una instancia de un <code>#ref</code> con el método 'run()' predeterminado #loc
extends.thread.problem.descriptor=Class <code>#ref</code> extiende directamente 'java.lang.Thread' #loc
anonymous.extends.thread.problem.descriptor=La clase anónima extiende directamente 'java.lang.Thread' #loc
naked.notify.problem.descriptor=Llamar a <code>#ref()</code> sin el cambio de estado correspondiente #loc
unconditional.wait.problem.descriptor=Llamada incondicional a <code>#ref()</code> #loc
system.run.finalizers.on.exit.problem.descriptor=Llamar a <code>System. #ref()</code> #loc
thread.priority.problem.descriptor=Llamada a <code>Thread. #ref()</code> #loc
thread.yield.problem.descriptor=Llamada a <code>Thread. #ref()</code> #loc
thread.stop.suspend.resume.problem.descriptor=Llamada a <code>Thread. #ref()</code> #loc
while.loop.spins.on.field.problem.descriptor=<code>#ref</code> bucle gira en el campo #loc
wait.not.in.loop.problem.descriptor=La llamada a <code>#ref()</code> no se realiza en un bucle #loc
await.not.in.loop.problem.descriptor=La llamada a <code>#ref()</code> no se realiza en un bucle #loc
wait.called.on.condition.problem.descriptor=Llamar a <code>#ref()</code> en el objeto Condición #loc
notify.called.on.condition.problem.descriptor=Llamar a <code>#ref()</code> en el objeto Condición #loc
wait.while.holding.two.locks.problem.descriptor=La llamada a <code>#ref()</code> se realiza mientras se mantienen dos bloqueos #loc
thread.run.problem.descriptor=Las llamadas a <code>#ref()</code> probablemente deberían reemplazarse con 'start()' #loc
thread.start.in.construction.problem.descriptor=Llamar a <code>#ref</code> durante la construcción del objeto #loc
synchronize.on.lock.problem.descriptor=Es poco probable que la sincronización en un objeto ''{0}'' sea intencional #loc
synchronized.on.literal.object.problem.descriptor=Sincronización en{0}<code>#ref</code> que se inicializa con un #loc literal
synchronized.on.direct.literal.object.problem.descriptor=Sincronización en{0}literal <code>#ref</code> #loc
synchronized.on.possibly.literal.object.problem.descriptor=Sincronización en{0}<code>#ref</code> #loc
synchronize.on.non.final.field.problem.descriptor=Sincronización en un campo no final <code>#ref</code> #loc
synchronized.on.literal.object.warn.on.all.option=Advertir sobre todos los literales posibles
synchronize.on.this.problem.descriptor=Las operaciones de bloqueo en 'esto' pueden tener efectos secundarios imprevistos #loc
synchronize.on.class.problem.descriptor=Las operaciones de bloqueo en una clase pueden tener efectos secundarios imprevistos #loc
nested.synchronized.statement.problem.descriptor=instrucción <code>#ref</code> anidada #loc
empty.synchronized.statement.problem.descriptor=Vacío <code>#ref</code> declaración #loc
non.synchronized.method.overrides.synchronized.method.problem.descriptor=El método no sincronizado <code>#ref()</code> anula el método sincronizado #loc
public.field.accessed.in.synchronized.context.problem.descriptor=Campo no privado <code>#ref</code> al que se accede en contexto sincronizado #loc
field.accessed.synchronized.and.unsynchronized.problem.descriptor=Se accede al campo <code>#ref</code> en contextos sincronizados y no sincronizados #loc
extended.for.statement.problem.descriptor=Extendida <code>#ref</code> declaración #loc
object.allocation.in.loop.new.descriptor=Asignación de objetos <code>new#ref()</code> en el bucle #loc
object.allocation.in.loop.problem.array.initializer.descriptor=Asignación de matriz en el bucle #loc
object.allocation.in.loop.problem.call.descriptor=Asignación de objetos a través de la llamada <code>#ref()</code> en el bucle #loc
object.allocation.in.loop.problem.methodref.descriptor=Asignación de objetos a través de la referencia del método vinculado a la instancia <code>#ref()</code> en el bucle #loc
object.allocation.in.loop.problem.lambda.descriptor=Asignación de objetos mediante la captura de lambda en el bucle #loc
object.allocation.in.loop.problem.string.concat=Asignación de objetos a través de la concatenación de cadenas en el bucle #loc
instantiating.object.to.get.class.object.problem.descriptor=Creación de instancias del objeto para obtener el objeto Class #loc
field.may.be.static.problem.descriptor=El campo <code>#ref</code> puede ser #loc 'estático'
method.may.be.static.problem.descriptor=El método <code>#ref()</code> puede ser 'estático' #loc
class.initializer.may.be.static.problem.descriptor=El inicializador de clase puede ser 'estático' #loc
map.replaceable.by.enum.map.problem.descriptor=<code>#ref</code> reemplazable por 'EnumMap' #loc
set.replaceable.by.enum.set.problem.descriptor=<code>#ref</code> reemplazable por 'EnumSet' #loc
inner.class.may.be.static.problem.descriptor=La clase interna <code>#ref</code> puede ser 'estática' #loc
string.buffer.must.have.initial.capacity.problem.descriptor=<code>new#ref()</code> sin capacidad inicial #loc
string.buffer.replaceable.by.string.builder.problem.descriptor=<code>StringBuffer#ref</code> puede declararse como 'StringBuilder' #loc
string.buffer.replaceable.by.string.problem.descriptor=<code>{0}#ref</code> se puede reemplazar con '' String '' #loc
new.string.buffer.replaceable.by.string.problem.descriptor=<code>#ref</code> se puede reemplazar con 'String' #loc
string.replaceable.by.string.buffer.problem.descriptor=El <code>String#ref</code> no constante probablemente debería declararse como '' StringBuilder '' #loc
collections.must.have.initial.capacity.problem.descriptor=<code>new#ref()</code> sin capacidad inicial #loc
string.concatenation.in.loops.problem.descriptor=Concatenación de cadenas <code>#ref</code> en el bucle #loc
string.concatenation.inside.string.buffer.append.problem.descriptor=Concatenación de cadenas como argumento para <code> {0}. #ref()</code> llamada #loc
boolean.constructor.problem.descriptor=Llamada al constructor booleano #loc
string.buffer.to.string.in.concatenation.problem.descriptor=Llamada a <code> {0}. #ref()</code> en concatenación #loc
tail.recursion.problem.descriptor=Tail recursive call <code>#ref()</code> #loc
string.equals.empty.string.problem.descriptor=<code>#ref("") </code> se puede reemplazar con 'length() == 0' #loc
string.equals.empty.string.is.empty.problem.descriptor=<code>#ref("") </code> se puede reemplazar con 'isEmpty()' #loc
random.double.for.random.integer.problem.descriptor=Usando <code> Random.#Ref </code> para crear un número entero aleatorio #loc
manual.array.copy.problem.descriptor=Copia manual de matriz #loc
manual.array.to.collection.copy.problem.descriptor=Matriz manual a copia de colección #loc
call.to.simple.getter.in.class.problem.descriptor=Llamada al getter simple <code>#ref()</code> desde dentro de la clase #loc
call.to.simple.setter.in.class.problem.descriptor=Llamada a simple setter <code>#ref()</code> desde dentro de la clase #loc
assert.without.message.problem.descriptor=<code>#ref()</code> sin mensaje #loc
test.case.with.constructor.problem.descriptor=Lógica de inicialización en el constructor <code>#ref()</code> en lugar de 'setUp()' #loc
test.case.with.constructor.problem.descriptor.initializer=Lógica de inicialización en el inicializador en lugar de 'setUp()'
misordered.assert.equals.arguments.problem.descriptor=Argumentos para <code>#ref()</code> en orden incorrecto #loc
static.suite.problem.descriptor=JUnit <code>#ref()</code> métodos no declarados 'estáticos' #loc
simplifiable.junit.assertion.problem.descriptor=<code>#ref()</code> puede simplificarse a ''{0}'' #loc
test.method.without.assertion.problem.descriptor=El método de prueba JUnit <code>#ref()</code> no contiene aserciones #loc
test.case.with.no.test.methods.problem.descriptor=La clase de prueba <code>#ref</code> no tiene pruebas #loc
test.case.in.product.code.problem.descriptor=El caso de prueba <code>#ref</code> probablemente debería colocarse en un árbol de fuentes de prueba #loc
test.method.in.product.code.problem.descriptor=El método de prueba <code>#ref()</code> probablemente debería colocarse en un árbol de fuentes de prueba #loc
unconstructable.test.case.problem.descriptor=La mayoría de los corredores de pruebas no pueden construir el caso de prueba <code>#ref</code>
deserializable.class.in.secure.context.problem.descriptor=La clase <code>#ref</code> puede ser deserializada, comprometiendo la seguridad #loc
serializable.class.in.secure.context.problem.descriptor=La clase <code>#ref</code> puede ser serializada, comprometiendo la seguridad #loc
serializable.deserializable.class.in.secure.context.problem.descriptor=La clase <code>#ref</code> puede ser serializada y deserializada, comprometiendo la seguridad #loc
cloneable.class.in.secure.context.problem.descriptor=La clase <code>#ref</code> puede ser clonada, comprometiendo la seguridad #loc
cloneable.class.in.secure.context.quickfix=Genera el método 'clone()' que siempre arroja una excepción
remove.cloneable.quickfix=Eliminar 'Cloneable' de la cláusula de implementos
non.final.clone.problem.descriptor=Método <code>#ref()</code> no final, comprometiendo la seguridad #loc
non.static.inner.class.in.secure.context.problem.descriptor=Clase interna no 'estática' <code>#ref</code>, comprometiendo la seguridad #loc
runtime.exec.with.non.constant.string.problem.descriptor=Llamada a <code>Runtime. #ref()</code> con argumento no constante #loc
load.library.with.non.constant.string.problem.descriptor=Llamada a <code>{0}. #ref()</code> con argumento no constante #loc
jdbc.execute.with.non.constant.string.problem.descriptor=Llamada a <code>Statement. #ref()</code> con argumento no constante #loc
jdbc.prepare.statement.with.non.constant.string.problem.descriptor=Llamada a <code>Connection. #ref()</code> con argumento no constante #loc
custom.classloader.problem.descriptor=Clase ClassLoader personalizada <code>#ref</code> #loc
custom.security.manager.problem.descriptor=Clase de SecurityManager personalizada <code>#ref</code> #loc
system.set.problem.descriptor=La llamada a <code>System. #ref()</code> puede plantear problemas de seguridad #loc
class.loader.instantiation.problem.descriptor=La creación de instancias de <code>#ref</code> puede plantear problemas de seguridad #loc
public.static.array.field.problem.descriptor=campo de matriz 'public static' <code>#ref</code>, comprometiendo la seguridad #loc
public.static.collection.field.problem.descriptor=campo de colección 'public static' <code>#ref</code>, comprometiendo la seguridad #loc
abstract.class.with.only.one.direct.inheritor.problem.descriptor=La clase abstracta <code>#ref</code> tiene solo un heredero directo #loc

#otro
abstract.method.overrides.abstract.method.remove.quickfix=Eliminar la declaración de método abstracto redundante
class.may.be.interface.convert.quickfix=Convertir clase en interfaz
class.without.constructor.create.quickfix=Generar constructor vacío
class.without.no.arg.constructor.ignore.option=Ignorar si la clase tiene un constructor predeterminado
extends.annotation.problem.descriptor=Class ''{0}'' implementa la interfaz de anotación <code>#ref</code> #loc
extends.annotation.interface.problem.descriptor=Interfaz ''{0}'' extiende la interfaz de anotaciones <code>#ref</code> #loc
extends.concrete.collection.problem.descriptor=Class <code>#ref</code> extiende explícitamente ''{0}'' #loc
anonymous.extends.concrete.collection.problem.descriptor=La clase anónima extiende explícitamente ''{0}'' #loc
inner.class.on.interface.ignore.option=Ignorar interfaces internas de interfaces
inner.class.on.interface.problem.descriptor=La interfaz ''{0}'' tiene una clase interna <code>#ref</code> #loc
missing.deprecated.annotation.add.quickfix=Agregar anotación @Deprecated
missing.add.deprecated.javadoc.tag.quickfix=Agregar etiqueta Javadoc '@deprecated'
non.protected.constructor.in.abstract.class.ignore.option=Ignorar para clases no públicas
public.constructor.in.non.public.class.problem.descriptor=El constructor se declara <code>#ref</code> en la clase no pública ''{0}'' #loc
static.inheritance.replace.quickfix=Reemplazar herencia con referencias calificadas en {0}
utility.class.with.public.constructor.make.quickfix=Make {0, choice, 1#constructor | 2#constructors} 'privado'
utility.class.without.private.constructor.create.quickfix=Generar constructor 'privado' vacío
utility.class.without.private.constructor.make.quickfix=Hacer que el constructor sea 'privado'
naming.convention.problem.descriptor.short={0} name <code>#ref</code> is too short ({1} <{2}) #loc
naming.convention.problem.descriptor.long={0} name <code>#ref</code> is too long ({1}> {2}) #loc
naming.convention.problem.descriptor.regex.mismatch={0} name <code>#ref</code> no coincide con regex ''{1}'' #loc
local.variable.naming.convention.ignore.option=Ignorar parámetros de bucle for
local.variable.naming.convention.ignore.catch.option=Ignorar los parámetros del bloque 'catch'
method.names.differ.only.by.case.problem.descriptor=El nombre del método <code>#ref</code> y el nombre del método ''{0}'' difieren solo en el caso #loc
parameter.name.differs.from.overridden.parameter.ignore.character.option=Ignorar si el parámetro reemplazado contiene solo un carácter
parameter.name.differs.from.overridden.parameter.ignore.library.option=Ignorar si el parámetro reemplazado es de una biblioteca
parameter.name.differs.from.overridden.parameter.problem.descriptor=El nombre del parámetro <code>#ref</code> es diferente del parámetro ''{0}'' anulado #loc
questionable.name.column.title=Nombre
standard.variable.names.problem.descriptor=La variable denominada <code>#ref</code> no tiene el tipo ''{0}'' #loc
standard.variable.names.problem.descriptor2=La variable denominada <code>#ref</code> no tiene el tipo ''{0}'' o ''{1}'' #loc
standard.variable.names.ignore.override.option=Ignorar los nombres de los parámetros idénticos a los parámetros del súper método
boolean.method.name.must.start.with.question.table.column.name=Prefijo de nombre de método booleano
conditional.expression.with.identical.branches.collapse.quickfix=Colapsar expresión condicional
redundant.else.unwrap.quickfix=Eliminar el 'else' redundante
constant.conditional.expression.problem.descriptor=<code>#ref</code> se puede simplificar a ''{0}'' #loc
constant.conditional.expression.simplify.quickfix=Simplificar
constant.conditional.expression.simplify.quickfix.sideEffect=Extrae efectos secundarios y simplifica
enum.switch.statement.which.misses.cases.problem.descriptor.single=<code>#ref</code> declaración sobre el tipo de enumeración ''{0}'' falta caso ''{1}'' #loc
enum.switch.statement.which.misses.cases.problem.descriptor=<code>#ref</code> declaración en el tipo de enumeración ''{0}'' casos de error: {1} #loc
for.loop.replaceable.by. while.ignore.option=Ignorar 'infinito' para bucles sin condiciones
for.loop.with.missing.component.problem.descriptor1=La declaración <code>#ref</code> carece de inicializador #loc
for.loop.with.missing.component.problem.descriptor2=La declaración <code>#ref</code> carece de la condición #loc
for.loop.with.missing.component.problem.descriptor3=La declaración <code>#ref</code> carece de actualización #loc
for.loop.with.missing.component.problem.descriptor4=La declaración <code>#ref</code> carece de inicializador y condición #loc
for.loop.with.missing.component.problem.descriptor5=La declaración <code>#ref</code> carece de inicializador y actualización #loc
for.loop.with.missing.component.problem.descriptor6=La declaración <code>#ref</code> carece de condición y actualiza #loc
for.loop.with.missing.component.problem.descriptor7=La declaración <code>#ref</code> carece de inicializador, condición y actualización #loc
foreach.replace.quickfix=Reemplazar con mejorado 'for'
unnecessary.boxing.remove.quickfix=Eliminar el boxeo
unnecessary.unboxing.remove.quickfix=Eliminar unboxing
misordered.assert.equals.arguments.flip.quickfix=Cambiar argumentos comparados
simplify.junit.assertion.simplify.quickfix=Simplificar la afirmación
test.method.is.public.void.no.arg.problem.descriptor1=El método de prueba <code>#ref()</code> probablemente no debería tener parámetros #loc
test.method.is.public.void.no.arg.problem.descriptor2=El método de prueba <code>#ref()</code> no se declara 'public void' #loc
test.method.is.public.void.no.arg.problem.descriptor3=El método de prueba <code>#ref()</code> no debe ser 'estático' #loc
system.properties.problem.descriptor=La llamada a <code> Integer. #ref()</code> puede plantear problemas de seguridad #loc
system.properties.problem.descriptor1=La llamada a <code> Boolean. #ref()</code> puede plantear problemas de seguridad #loc
unsecure.random.number.generation.problem.descriptor1=Por motivos de seguridad, utilice 'java.security.SecureRandom' en lugar de <code> java.lang.Math. #ref()</code> #loc
unsecure.random.number.generation.problem.descriptor2=Por motivos de seguridad, utilice 'java.security.SecureRandom' en lugar de <code> java.util.#ref </code> #loc
unsecure.random.number.generation.problem.descriptor3=Por motivos de seguridad, utilice 'java.security.SecureRandom' en lugar de <code>#ref</code> #loc
serializable.has.serialization.methods.problem.descriptor=La clase serializable <code>#ref</code> no define 'readObject()' o 'writeObject()' #loc
serializable.has.serialization.methods.problem.descriptor1=La clase serializable <code>#ref</code> no define 'writeObject()' #loc
serializable.has.serialization.methods.problem.descriptor2=La clase serializable <code>#ref</code> no define 'readObject()' #loc
serializable.with.unconstructable.ancestor.problem.descriptor=<code>#ref</code> tiene un ancestro no serializable ''{0}'' sin constructor sin argumentos #loc
transient.field.in.non.serializable.class.problem.descriptor=El campo ''{0}'' está marcado como <code>#ref</code>, en la clase no serializable #loc
safe.lock.problem.descriptor=''{0}'' debe estar bloqueado frente a un bloque '' try '' y desbloqueado en el bloque '' finalmente '' correspondiente #loc
synchronized.method.problem.descriptor=Método '' {0}() '' declarado <code>#ref</code> #loc
synchronized.method.include.option=Incluir métodos nativos
synchronized.method.ignore.synchronized.super.option=Ignorar métodos que anulan un método sincronizado
synchronized.method.move.quickfix=Mover la sincronización al método
volatile.field.problem.descriptor=Campo volátil <code>#ref</code> de tipo ''{0}'' #loc
string.format.choose.class=Elija la clase Formatter
string.format.class.column.name=Clases de formateador adicionales
string.format.class.method.name=Métodos de formateador adicionales
exception.class.column.name=Clase de excepción
bad.exception.thrown.problem.descriptor=Excepción prohibida ''{0}'' lanzada #loc
too.broad.catch.problem.descriptor='' catch '' de <code>#ref</code> es demasiado amplio, enmascarando la excepción ''{0}'' #loc
too.broad.catch.problem.descriptor1='' catch '' de <code>#ref</code> es demasiado amplio y enmascara las excepciones ''{0}'' y ''{1}'' #loc
add.serialversionuidfield.quickfix=Agregar campo 'serialVersionUID'
delete.import.quickfix=Eliminar importación innecesaria
encapsulate.variable.quickfix=Encapsular campo ''{0}''
extract.method.quickfix=Método de extracción
inline.call.quickfix=Llamada en línea
inline.variable.quickfix=Variable en línea
pointless.nullcheck.display.name=Verificación 'nula' innecesaria antes de la llamada al método
pointless.nullcheck.problem.descriptor.call=Verificación '' nula '' innecesaria antes de la llamada '' {0}() ''
remove.redundant.polyadic.operand.fix.name=Eliminar condición innecesaria ''{0}''
remove.redundant.polyadic.operand.fix.family.name=Eliminar condición innecesaria
introduce.constant.quickfix=Introduce constante
make.initialization.explicit.quickfix=Hacer explícita la inicialización
move.anonymous.to.inner.quickfix=Convertir a clase interna con nombre
anonymous.inner.may.be.named.static.inner.class.quickfix=Convertir a clase interna 'estática' nombrada
move.class.quickfix=Mover clase
normalize.declaration.quickfix=Dividir en declaraciones separadas
remove.modifier.quickfix=Eliminar modificador ''{0}''
replace.inheritance.with.delegation.quickfix=Reemplazar herencia con delegación
cast.that.loses.precision.problem.descriptor=La conversión de ''{0}'' a <code>#ref</code> puede provocar una pérdida de precisión #loc
cast.that.loses.precision.negative.problem.descriptor=La conversión de ''{0}'' a <code>#ref</code> puede resultar en la pérdida de precisión para el argumento negativo #loc
comparison.to.nan.problem.descriptor1=La comparación con <code>#ref</code> es siempre falsa #loc
comparison.to.nan.problem.descriptor2=La comparación con <code>#ref</code> es siempre verdadera #loc
confusing.floating.point.literal.change.quickfix=Cambiar a forma canónica
implicit.numeric.conversion.ignore.widening.conversion.option=Ignorar conversiones de ampliación
implicit.numeric.conversion.ignore.char.conversion.option=Ignorar conversiones desde y hacia char
implicit.numeric.conversion.ignore.constant.conversion.option=Ignorar conversiones de constantes y literales
implicit.numeric.conversion.problem.descriptor=Conversión numérica implícita de <code>#ref</code> de ''{0}'' a ''{1}'' #loc
implicit.numeric.conversion.assignment.problem.descriptor=Conversión numérica implícita del valor del resultado de ''{0}'' a ''{1}'' #loc
implicit.numeric.conversion.make.explicit.quickfix=Hacer explícita la conversión
non.reproducible.math.call.replace.quickfix=Reemplazar con llamada 'StrictMath'
overly.complex.arithmetic.expression.max.number.option=Número máximo de términos:
expression.can.be.replaced.problem.descriptor=<code>#ref</code> se puede reemplazar con ''{0}'' #loc
method.complexity.limit.option=Límite de complejidad del método:
expression.can.be.replaced.no.quotes.problem.descriptor={0} se puede reemplazar con {1}
cyclomatic.complexity.problem.descriptor=Método demasiado complejo <code>#ref()</code> (complejidad ciclomática={0}) #loc
method.coupling.limit.option=Límite de acoplamiento del método:
method.coupling.problem.descriptor=<code>#ref</code> está demasiado acoplado (# clases referenciadas={0}) #loc
method.with.multiple.loops.problem.descriptor=<code>#ref</code> contiene{0}bucles #loc
return.point.limit.option=&Límite de punto de retorno:
multiple.return.points.per.method.problem.descriptor=<code>#ref</code> tiene{0}puntos de retorno #loc
nesting.depth.limit.option=Límite de profundidad de anidación:
nesting.depth.problem.descriptor=<code>#ref</code> está demasiado anidado (profundidad máxima de anidamiento={0}) #loc
non.comment.source.statements.limit.option=Límite de declaraciones de fuentes sin comentarios:
non.comment.source.statements.problem.descriptor=<code>#ref</code> es demasiado largo (# declaraciones de origen sin comentarios={0}) #loc
parameters.per.method.problem.descriptor=<code>#ref()</code> tiene demasiados parámetros (num parameters={0}) #loc
parameters.per.constructor.problem.descriptor=<code>#ref()</code> tiene demasiados parámetros (num parameters={0}) #loc
parameter.limit.option=Límite de parámetro:
constructor.visibility.option=Ignorar constructores con visibilidad:
three.negations.per.method.ignore.option=Ignorar negaciones en métodos 'equals()'
three.negations.per.method.ignore.assert.option=Ignorar negaciones en declaraciones 'assert'
three.negations.per.method.problem.descriptor=<code>#ref</code> contiene{0}negaciones #loc
thrown.exceptions.per.method.problem.descriptor=<code>#ref</code> tiene demasiadas excepciones declaradas (num exceptions={0}) #loc
thrown.exceptions.per.method.limit.option=Límite de excepciones lanzadas:
call.to.simple.getter.in.class.ignore.option=Ignorar las llamadas de getter en otros objetos
call.to.private.simple.getter.in.class.option=Solo informar cuando getter es 'privado'
call.to.simple.getter.in.class.inline.quickfix=Llamada en línea al getter
call.to.simple.setter.in.class.ignore.option=Ignorar las llamadas del setter en otros objetos
call.to.private.setter.in.class.option=Solo informar cuando el setter es 'privado'
call.to.simple.setter.in.class.inline.quickfix=Llamada en línea a setter
make.static.quickfix=Hacer 'estático'
length.one.strings.in.concatenation.replace.quickfix=Reemplazar con carácter
multiply.or.divide.by.power.of.two.replace.quickfix=Reemplazar con turno
boolean.expression.can.be.simplified.problem.descriptor=<code>#ref</code> puede simplificarse a ''{0}'' #loc
boolean.expression.does.not.modify.problem.descriptor=<code>#ref</code> no modifica el valor de ''{0}'' #loc
boolean.expression.remove.compound.assignment.quickfix=Eliminar asignación compuesta sin sentido
trivial.string.concatenation.problem.descriptor=Cadena vacía utilizada en la concatenación
string.replace.quickfix=Reemplazar la concatenación con ''{0}''
instantiating.object.to.get.class.object.replace.quickfix=Reemplazar con acceso directo al objeto de clase
method.may.be.static.only.option=Solo verifique los métodos 'privados' o 'finales'
method.may.be.static.empty.option=Ignorar métodos vacíos
string.concatenation.in.loops.only.option=Solo advertir si se agrega una cadena repetidamente
string.concatenation.inside.string.buffer.append.replace.quickfix=Reemplazar con llamadas encadenadas 'append()'
string.equals.empty.string.option.do.not.add.null.check=No informar cuando pueda ser necesaria una verificación nula
tail.recursion.replace.quickfix=Reemplazar la recursividad de cola con iteración
if.statement.with.too.many.branches.max.option=Número máximo de ramas:
if.statement.with.too.many.branches.problem.descriptor=<code>#ref</code> tiene demasiadas ramas ({0}) #loc
negated.conditional.invert.quickfix=Condición de inversión
negated.if.else.ignore.negated.null.option=Ignorar comparaciones '!=null'
negated.if.else.ignore.negated.zero.option=Ignore '!=0' comparaciones
negated.if.else.invert.quickfix=Invertir la condición 'if'
overly.complex.boolean.expression.max.terms.option=Número máximo de términos:
pointless.boolean.expression.ignore.option=Ignore las constantes nombradas al determinar expresiones sin sentido
simplifiable.conditional.expression.problem.descriptor=<code>#ref</code> se puede simplificar a ''{0}'' #loc
switch.statement.density.min.option=Densidad mínima de ramas:%
switch.statement.density.problem.descriptor=<code>#ref</code> tiene una densidad de rama demasiado baja ({0}%) #loc
switch.statement.with.too.few.branches.min.option=Número mínimo de ramas:
switch.statement.with.too.few.branches.problem.descriptor=La declaración ''switch'' tiene muy pocas etiquetas de caso ({0}), y probablemente debería reemplazarse con una declaración ''if'' #loc
switch.statement.with.single.default.message=la declaración 'switch' solo tiene el caso 'predeterminado'
switch.expression.with.too.few.branches.problem.descriptor=La expresión ''switch'' tiene muy pocas etiquetas de mayúsculas y minúsculas ({0}), y probablemente debería reemplazarse con una declaración ''if'' o un operador condicional#loc
switch.expression.with.single.default.message=La expresión 'switch' solo tiene el caso 'predeterminado'
switch.statement.without.default.ignore.option=Ignorar si todos los casos de un tipo de enumeración están cubiertos
unnecessary.label.remove.quickfix=Eliminar etiqueta
unnecessary.return.problem.descriptor=<code>#ref</code> es innecesario como última declaración en un método 'void' #loc
unnecessary.return.constructor.problem.descriptor=<code>#ref</code> no es necesario como última declaración en un constructor #loc
unused.label.remove.quickfix=Eliminar etiqueta no utilizada
unnecessarily.qualified.static.usage.problem.descriptor=Llamada a método estático innecesariamente calificado <code> {0}() </code> #loc
unnecessarily.qualified.static.usage.problem.descriptor1=Acceso estático innecesariamente calificado <code>{0}</code> #loc
unnecessarily.qualified.static.usage.ignore.field.option=Ignorar accesos de campo innecesariamente calificados
unnecessarily.qualified.static.usage.ignore.method.option=Ignorar llamadas a métodos innecesariamente calificados
unnecessary.interface.modifier.problem.descriptor=El modificador <code>#ref</code> es redundante para interfaces #loc
unnecessary.interface.modifier.inner.interface.of.interface.problem.descriptor=Modificador <code>#ref</code> es redundante para interfaces internas #loc
unnecessary.interface.modifier.problem.descriptor2=El modificador <code>#ref</code> es redundante para los métodos de interfaz #loc
unnecessary.interface.modifier.problem.descriptor3=El modificador <code>#ref</code> es redundante para las clases internas de interfaces #loc
unnecessary.interface.modifier.problem.descriptor4=El modificador <code>#ref</code> es redundante para los campos de interfaz #loc
smth.unnecessary.remove.quickfix=Eliminar innecesarios ''{0}''
unqualified.static.usage.problem.descriptor=Llamada de método estático no calificado <code>#ref()</code> #loc
unqualified.static.usage.problem.descriptor1=Acceso a campo estático no calificado <code>#ref</code> #loc
unqualified.static.usage.ignore.field.option=Ignorar accesos de campo no calificados
unqualified.static.usage.ignore.method.option=Ignorar llamadas a métodos no calificados
unqualified.static.usage.qualify.field.quickfix=Calificar el acceso al campo estático
unqualified.static.usage.qualify.method.quickfix=Calificar llamada de método estático
too.broad.scope.allow.option=<html> Informar variables con una nueva expresión como inicializador <br> (Potencialmente inseguro: la solución rápida puede modificar la semántica si el constructor tiene efectos secundarios no locales) </html>
too.broad.scope.only.blocks.option=Solo reportar variables que se pueden mover a bloques internos
too.broad.scope.narrow.quickfix=Mueve la declaración de ''{0}'' más cerca de los usos
press.escape.to.remove.highlighting.message=Presione Escape para eliminar el resaltado
unnecessary.enum.modifier.problem.descriptor=El modificador <code>#ref</code> es redundante para los constructores de enumeración #loc
unnecessary.enum.modifier.problem.descriptor1=El modificador <code>#ref</code> es redundante para enumeraciones internas #loc
literal.as.arg.to.string.equals.problem.descriptor=El <code>#ref</code> literal es el argumento de '' {0}() '', en lugar de su calificador #loc
literal.as.arg.to.string.equals.flip.quickfix=Voltear '' {0}() ''
c.style.array.declaration.replace.quickfix=Reemplazar con declaración de matriz de estilo Java
chained.method.call.ignore.option=Ignorar llamadas a métodos encadenados en inicializadores de campo
chained.method.call.ignore.self.types.option=Ignorar las llamadas a los métodos que devuelven el mismo tipo que su clase adjunta
introduce.variable.quickfix=Introducir variable
introduce.variable.may.change.semantics.quickfix=Introducir variable (puede cambiar la semántica)
flip.comparison.quickfix=Comparación de volteo
control.flow.statement.without.braces.add.quickfix=Agregar llaves a la declaración
control.flow.statement.without.braces.message=Agregar llaves a la declaración ''{0}''
extends.object.remove.quickfix=Eliminar el 'objeto extendido' redundante
implicit.call.to.super.ignore.option=Ignorar las subclases directas de 'java.lang.Object'
implicit.call.to.super.make.explicit.quickfix=Hacer una llamada a 'super()' explícita
missorted.modifiers.require.option=Verificar el orden de las anotaciones
missorted.modifiers.typeuse.before.type.option=Las anotaciones de TYPE_USE de destino siempre van antes del tipo
missorted.modifiers.sort.quickfix=Modificadores de clasificación
nested.method.call.ignore.option=Ignorar las llamadas a métodos anidados en los inicializadores de campo
ignore.calls.to.static.methods=Ignorar llamadas a métodos estáticos
ignore.calls.to.property.getters=Ignorar llamadas a captadores de propiedades
redundant.field.initialization.remove.quickfix=Eliminar inicializador
redundant.implements.remove.quickfix=Eliminar declaración de interfaz redundante
unnecessary.constructor.remove.quickfix=Eliminar constructor redundante
unnecessary.fully.qualified.name.replace.quickfix=Reemplazar nombre calificado con importación
unnecessary.fully.qualified.name.remove.quickfix=Eliminar la calificación innecesaria
unnecessary.fully.qualified.name.status.bar.escape.highlighting.message={0} totalmente calificado {0, choice, 1#name | 2#names} reemplazado con import (presione Escape para eliminar el resaltado)
unnecessary.parentheses.remove.quickfix=Elimina los paréntesis innecesarios
unnecessary.qualifier.for.this.remove.quickfix=Eliminar calificador innecesario
unnecessary.semicolon.remove.quickfix=Eliminar el punto y coma innecesario
unnecessary.super.constructor.remove.quickfix=Eliminar 'super()' innecesario
unnecessary.this.remove.quickfix=Elimina el calificador innecesario 'este'
overly.strong.type.cast.problem.descriptor=La conversión a <code>#ref</code> se puede debilitar a ''{0}'' #loc
field.count.inspection.include.constant.fields.in.count.checkbox=Incluir campos constantes en el recuento
field.count.inspection.static.final.fields.count.as.constant.checkbox=los campos 'static final' cuentan como constantes
field.count.inspection.include.enum.constants.in.count=Incluir constantes de enumeración en el recuento
make.method.final.fix.name=Crear método ''{0}()'' ''final''
make.class.final.fix.name=Hacer clase ''{0}'' ''final''
non.boolean.method.name.must.not.start.with.question.display.name=El nombre del método no booleano no debe comenzar con una palabra de pregunta
non.boolean.method.name.must.not.start.with.question.problem.descriptor=El nombre del método no booleano <code>#ref</code> comienza con una palabra de pregunta #loc
boolean.constructor.simplify.quickfix=Simplificar
unnecessary.temporary.on.conversion.from.string.problem.descriptor=<code>#ref</code> #loc se puede simplificar a ''{0}''
only.report.qualified.static.usages.option=Informar solo acceso estático calificado desde un contexto estático
unqualified,static.usage.only.report.static.usages.option=Solo informa el acceso estático desde un contexto no estático
assignment.to.catch.block.parameter.problem.descriptor=Asignación al parámetro de bloque 'catch' <code>#ref</code> #loc
assignment.to.method.parameter.problem.descriptor=Asignación al parámetro del método <code>#ref</code> #loc
value.of.post.increment.problem.descriptor=Se usa el valor de la expresión posterior al incremento <code>#ref</code> #loc
value.of.post.decrement.problem.descriptor=Se usa el valor de la expresión de post-decremento <code>#ref</code> #loc
value.of.pre.increment.problem.descriptor=Se usa el valor de la expresión de preincremento <code>#ref</code> #loc
value.of.pre.decrement.problem.descriptor=Se usa el valor de la expresión de pre-decremento <code>#ref</code> #loc
assignment.replaceable.with.operator.assignment.problem.descriptor=<code>#ref</code> podría simplificarse a ''{0}'' #loc
assignment.replaceable.with.operator.assignment.ignore.conditional.operators.option=Ignorar operadores condicionales
assignment.replaceable.with.operator.assignment.ignore.obscure.operators.option=Ignorar los operadores oscuros ^ y%
object.equality.ignore.between.objects.of.a.type.with.only.private.constructors.option=Ignore '==' entre objetos de un tipo con solo constructores 'privados'
redundant.method.override.display.name=El método es idéntico a su súper método
redundant.method.override.problem.descriptor=El método <code> #ref()</code> es idéntico a su súper método #loc
redundant.method.override.quickfix=Eliminar método redundante
redundant.method.override.option.checked.library.methods=Comprobar métodos que anulan los métodos de la biblioteca
refused.bequest.problem.descriptor=El método <code> #ref()</code> no llama a 'super.#ref()' #loc
refused.bequest.ignore.empty.super.methods.option=Ignorar supermétodos vacíos
refused.bequest.ignore.default.super.methods.option=Ignorar los súper métodos 'predeterminados'
overly.complex.boolean.expression.ignore.option=Ignorar conjunciones y disyunciones puras
pointless.indexof.comparison.display.name=Comparación sin sentido 'indexOf()'
pointless.indexof.comparison.always.true.problem.descriptor=<code>#ref</code> es siempre verdadero #loc
pointless.indexof.comparison.always.false.problem.descriptor=<code>#ref</code> es siempre falso #loc
reuse.of.local.variable.problem.descriptor=Reutilización de la variable local <code>#ref</code> #loc
single.character.startswith.display.name=Carácter único 'startsWith()' o 'endsWith()'
single.character.startswith.problem.descriptor=Un solo carácter <code>#ref()</code> podría reemplazarse con la expresión 'charAt()' #loc
list.indexof.replaceable.by.contains.display.name=La expresión 'List.indexOf()' es reemplazable por 'contains()'
string.indexof.replaceable.by.contains.display.name=La expresión 'String.indexOf()' es reemplazable por 'contains()'
overloaded.methods.with.same.number.parameters.problem.descriptor=Varios métodos llamados <code>#ref</code> con el mismo número de parámetros #loc
overloaded.vararg.method.problem.descriptor=Método varargs sobrecargado <code>#ref()</code> #loc
overloaded.vararg.constructor.problem.descriptor=Constructor de varargs sobrecargado <code>#ref()</code> #loc
cached.number.constructor.call.display.name=Llamada al constructor de números con argumento primitivo
cached.number.constructor.call.problem.descriptor=Llamada al constructor de números con argumento primitivo #loc
cached.number.constructor.call.ignore.string.arguments.option=Ignorar nuevas expresiones numéricas con un argumento de cadena
cached.number.constructor.call.report.only.deprecated=Informar solo cuando el constructor es @Deprecated
chained.equality.comparisons.problem.descriptor=Comparación de igualdad encadenada <code>#ref</code> #loc
confusing.octal.escape.sequence.problem.descriptor=Secuencia de escape octal <code>#ref</code> seguida inmediatamente por el dígito #loc
field.accessed.synchronized.and.unsynchronized.option=Los getters y setters simples también se consideran accesos de campo
method.overrides.inaccessible.method.display.name=El método anula el método inaccesible de la superclase
method.overrides.package.local.method.problem.descriptor=El método <code>#ref()</code> anula un método privado de paquete de una superclase ubicada en otro paquete #loc
suspicious.to.array.call.display.name=Llamada sospechosa 'Collection.toArray()'
suspicious.to.array.call.problem.descriptor=Se esperaba una matriz de tipo ''{0}[] '', se encontró #loc
suspicious.system.arraycopy.display.name=Llamada sospechosa 'System.arraycopy()'
suspicious.system.arraycopy.problem.descriptor4=<code>#ref</code> no es de un tipo de matriz #loc
suspicious.system.arraycopy.problem.descriptor5=<code>#ref</code> no es de un tipo de matriz #loc
suspicious.system.arraycopy.problem.descriptor6=El tipo de parámetro de origen ''{0}'' no se puede asignar al parámetro de destino <code>#ref</code> de tipo ''{1}'' #loc
suspicious.system.arraycopy.problem.descriptor.length.bigger.src=La longitud siempre es mayor que '' src.length - srcPos '' {0}
suspicious.system.arraycopy.problem.descriptor.length.bigger.dest=La longitud siempre es mayor que '' dest.length - destPos '' {0}
suspicious.system.arraycopy.problem.descriptor.ranges.intersect=Copiando a la misma matriz con rangos de intersección
raw.use.of.parameterized.type.ignore.new.objects.option=Ignorar la construcción de nuevos objetos
raw.use.of.parameterized.type.ignore.type.casts.option=Ignorar tipos de conversión
raw.use.of.parameterized.type.ignore.uncompilable.option=Ignorar dónde no se compilaría un parámetro de tipo
raw.use.of.parameterized.type.ignore.overridden.parameter.option=Ignorar tipos de parámetros de métodos de reemplazo
method.only.used.from.inner.class.display.name=Método privado solo usado desde la clase interna
method.only.used.from.inner.class.problem.descriptor.anonymous.extending=El método <code>#ref()</code> #loc solo se usa desde una clase anónima que se extiende a ''{0}''#loc
method.only.used.from.inner.class.problem.descriptor.anonymous.implementing=El método <code>#ref()</code> #loc solo se usa desde una clase anónima que implementa ''{0}''#loc
method.only.used.from.inner.class.problem.descriptor=El método <code>#ref()</code> #loc solo se usa desde la clase interna ''{0}'' #loc
method.only.used.from.inner.class.ignore.option=Ignorar los métodos a los que se accede desde una clase &anónima
ignore.static.methods.accessed.from.a.non.static.inner.class=Ignorar métodos '&static' a los que se accede desde una clase interna no 'estática'
only.report.static.methods=&Solo reportar métodos 'estáticos'
format.decode.error.requires.both.0.and.1=requiere tanto{0}como {1}
format.decode.any=cualquiera
format.decode.date.time=Fecha/Hora
format.decode.char=char
format.decode.integer.type=tipo entero
format.decode.floating.point=punto flotante
single.character.startswith.quickfix=Reemplazar con la expresión 'charAt()'
interface.never.implemented.option=Ignorar interfaces que solo declaran constantes
size.replaceable.by.isempty.display.name='size() == 0' reemplazable por 'isEmpty()'
size.replaceable.by.isempty.negation.ignore.option=Ignorar expresiones que serían reemplazadas por '!isEmpty()'
ignored.classes.table=Clases ignoradas
choose.class.type.to.ignore=Elija el tipo de clase para ignorar
loop.condition.not.updated.inside.loop.display.name=Variable de bucle no actualizada dentro del bucle
loop.variable.not.updated.inside.loop.problem.descriptor=La variable '#ref' no se actualiza dentro del bucle #loc
loop.condition.not.updated.inside.loop.problem.descriptor=La condición '#ref' no se actualiza dentro del bucle #loc
loop.variable.not.updated.inside.loop.option.nonlocal=Ignorar posibles cambios no locales
utility.class.without.private.constructor.option=Ignorar clases con solo un método principal
super.class.logger.option=Ignorar clases con un registrador accesible declarado en una superclase
static.method.only.used.in.one.class.display.name=Miembro estático que solo se usa de otra clase
static.method.only.used.in.one.class.problem.descriptor=Static {0, choice, 1#method | 2#field} <code>#ref{0, choice, 1 #() | 2 #} </code> solo se usa desde la clase ''{1}'' #loc
static.method.only.used.in.one.anonymous.class.problem.descriptor=Static {0, choice, 1#method | 2#field} <code>#ref{0, choice, 1 #() | 2 #} </code> solo se usa a partir de una clase anónima derivada de ''{1}'' #loc
static.method.only.used.in.one.class.quickfix=Mover{0} a la clase de uso
static.method.only.used.in.one.class.ignore.test.option=Ignorar cuando solo se usa desde una clase de prueba
static.method.only.used.in.one.class.ignore.anonymous.option=Ignorar cuando solo se usa desde una clase anónima
static.method.only.used.in.one.class.ignore.on.conflicts=Ignorar cuando el método no se puede mover sin conflictos
static.method.only.used.in.one.class.ignore.utility.classes=Ignorar miembros ubicados en clases de servicios públicos
unary.plus.display.name=Unario más
unary.plus.problem.descriptor=Operador <code>#ref</code> unario #loc
await.without.corresponding.signal.display.name='await()' sin la correspondiente 'señal()'
await.without.corresponding.signal.problem.descriptor=Llamar a <code>#ref</code> sin el <code> signal() </code> o <code> signalAll() </code> correspondiente #loc
signal.without.corresponding.await.display.name='signal()' sin el correspondiente 'await()'
signal.without.corresponding.await.problem.descriptor=Llamar a <code>#ref</code> sin el <code> await() </code> #loc correspondiente
wait.without.corresponding.notify.display.name='wait()' sin el correspondiente 'notificar()'
wait.without.corresponding.notify.problem.descriptor=Llamar a <code>#ref</code> sin el correspondiente <code> notify() </code> o <code> notifyAll() </code> #loc
notify.without.corresponding.wait.display.name='notificar()' sin el correspondiente 'esperar()'
notify.without.corresponding.wait.problem.descriptor=Llamar a <code>#ref</code> sin el <code> wait() </code> #loc correspondiente
integer.multiplication.implicit.cast.to.long.display.name=Multiplicación de enteros o cambio de conversión implícita a largo
integer.multiplication.implicit.cast.to.long.problem.descriptor=# ref: multiplicación de enteros convertida implícitamente en long #loc
integer.multiplication.implicit.cast.to.long.quickfix=Lanzar demasiado
integer.shift.implicit.cast.to.long.problem.descriptor=# ref: integer shift implícitamente convertido a long #loc
integer.multiplication.implicit.cast.to.long.option=<html> Ignore las expresiones en las que se haya comprobado estáticamente que el desbordamiento es imposible </html>
wait.or.await.without.timeout.display.name='wait()' o 'await()' sin tiempo de espera
wait.or.await.without.timeout.problem.descriptor=<code>#ref</code> sin tiempo de espera #loc
method.return.always.constant.display.name=El método devuelve constante por clase
method.return.always.constant.problem.descriptor=El método <code>#ref()</code> y todas sus derivables siempre devuelven constantes
class.with.too.many.dependencies.display.name=Clase con demasiadas dependencias
class.with.too.many.dependencies.problem.descriptor=La clase ''{0}'' tiene demasiadas dependencias ({1}> {2})
class.with.too.many.transitive.dependencies.display.name=Clase con demasiadas dependencias transitivas
class.with.too.many.transitive.dependencies.problem.descriptor=Class ''{0}'' tiene demasiadas dependencias transitivas ({1}> {2})
class.with.too.many.dependents.display.name=Clase con demasiados dependientes
class.with.too.many.dependents.problem.descriptor=La clase ''{0}'' tiene demasiados dependientes ({1}> {2})
class.with.too.many.transitive.dependents.display.name=Clase con demasiados dependientes transitivos
class.with.too.many.transitive.dependents.problem.descriptor=La clase ''{0}'' tiene demasiadas dependencias transitivas ({1}> {2})
class.with.too.many.dependencies.max.option=Número máximo de dependencias
class.with.too.many.dependents.max.option=Número máximo de dependientes
class.with.too.many.transitive.dependencies.max.option=Número máximo de dependencias transitivas
class.with.too.many.transitive.dependents.max.option=Número máximo de dependientes transitivos
cyclic.class.dependency.display.name=Dependencia de clase cíclica
cyclic.class.dependency.problem.descriptor=La clase ''{0}'' depende cíclicamente de {1} otras clases
cyclic.class.dependency.1.problem.descriptor=La clase ''{0}'' depende cíclicamente de la clase ''{1}''
cyclic.class.dependency.2.problem.descriptor=La clase ''{0}'' depende cíclicamente de las clases ''{1}'' y ''{2}''
cyclic.package.dependency.display.name=Dependencia cíclica del paquete
cyclic.package.dependency.problem.descriptor=El paquete ''{0}'' depende cíclicamente de {1} otros paquetes
cyclic.package.dependency.1.problem.descriptor=El paquete ''{0}'' depende cíclicamente del paquete ''{1}''
cyclic.package.dependency.2.problem.descriptor=El paquete ''{0}'' depende cíclicamente de los paquetes ''{1}'' y ''{2}''
class.unconnected.to.package.display.name=Clase independiente de su paquete
class.unconnected.to.package.problem.descriptor=Class <code>#ref</code> no tiene dependencias ni dependientes en su paquete
exception.package.display.name=Paquete de excepción
exception.package.problem.descriptor=El paquete ''{0}'' contiene solo clases de excepción
package.with.too.many.classes.display.name=Paquete con demasiadas clases
package.with.too.many.classes.problem.descriptor=El paquete ''{0}'' contiene demasiadas clases ({1}> {2})
package.with.too.many.classes.max.option=Número máximo de clases:
package.with.too.few.classes.display.name=Paquete con muy pocas clases
package.with.too.few.classes.problem.descriptor=El paquete ''{0}'' contiene muy pocas clases ({1} <{2})
package.with.too.few.classes.min.option=Número mínimo de clases:
suspicious.package.private.access.display.name=Acceso privado al paquete sospechoso
groups.of.modules.loaded.together.label=Grupos de módulos que se cargan juntos:
groups.of.modules.loaded.together.description=Cada línea especifica una lista separada por comas de los nombres de los módulos que se sabe que son cargados por el mismo cargador de clases y, por lo tanto, no se debe informar el acceso a los miembros privados del paquete entre dichos módulos.
module.with.too.many.classes.display.name=Módulo con demasiadas clases
module.with.too.many.classes.problem.descriptor=El módulo ''{0}'' contiene demasiadas clases ({1}> {2})
module.with.too.many.classes.max.option=Número máximo de clases:
module.with.too.few.classes.display.name=Módulo con muy pocas clases
module.with.too.few.classes.problem.descriptor=El módulo ''{0}'' contiene muy pocas clases ({1} <{2})
module.with.too.few.classes.min.option=Número mínimo de clases:
package.in.multiple.modules.display.name=Paquete con clases en varios módulos
package.in.multiple.modules.problem.descriptor=El paquete ''{0}'' tiene clases en varios módulos
disjoint.package.display.name=Paquete con gráfico de dependencia disjunto
disjoint.package.problem.descriptor=El paquete{0}se puede descomponer en {1} paquetes independientes
package.naming.convention.display.name=Convención de nomenclatura de paquetes
package.naming.convention.problem.descriptor.short=El nombre del paquete <code>{0}</code> es demasiado corto
package.naming.convention.problem.descriptor.long=El nombre del paquete <code>{0}</code> es demasiado largo
package.naming.convention.problem.descriptor.regex.mismatch=El nombre del paquete <code>{0}</code> no coincide con la expresión regular ''{1}''
cyclic.class.initialization.display.name=Dependencia de inicialización de clase cíclica
cyclic.class.initialization.problem.descriptor=La inicialización de la clase ''{0}'' depende cíclicamente de {1} otras clases
before.or.after.is.public.void.no.arg.display.name=Método @Before o @After incorrecto
before.or.after.is.public.void.no.arg.problem.descriptor=<code>#ref()</code> tiene una firma incorrecta para un método @Before o @After #loc
before.class.or.after.class.is.public.static.void.no.arg.display.name=Malformed @BeforeClass/@BeforeAll o @AfterClass/@AfterAll método
before.class.or.after.class.is.public.static.void.no.arg.problem.descriptor=<code>#ref()</code> tiene una firma incorrecta para un método @{0}#loc
design.for.extension.display.name=Diseño para extensión
design.for.extension.problem.descriptor=El método <code>#ref()</code> puede ser anulado y su funcionalidad ignorada #loc
bad.oddness.display.name=Prueba sospechosa de rareza
bad.oddness.problem.descriptor=La prueba de rareza <code>#ref</code> fallará en valores negativos #loc
comparator.not.serializable.display.name=Clase de comparador no declarada serializable
comparator.not.serializable.problem.descriptor=La clase de comparador <code>#ref</code> no se declara como serializable #loc
non.serializable.field.in.serializable.class.display.name=Campo no serializable en una clase serializable
non.serializable.field.in.serializable.class.problem.descriptor=Campo no serializable '#ref' en una clase serializable #loc
non.serializable.object.passed.to.object.stream.display.name=Objeto no serializable pasado a ObjectOutputStream
non.serializable.object.passed.to.object.stream.problem.descriptor=Objeto no serializable pasado a ObjectOutputStream #loc
non.serializable.object.bound.to.http.session.display.name=Objeto no serializable vinculado a HttpSession
non.serializable.object.bound.to.http.session.problem.descriptor=Objeto no serializable vinculado a HttpSession #loc
reflection.for.unavailable.annotation.display.name=Acceso reflectante a una anotación de solo fuente
reflection.for.unavailable.annotation.problem.descriptor=La anotación '#ref' no se retiene para el acceso reflectante #loc
access.to.static.field.locked.on.instance.display.name=Acceso al campo estático bloqueado en datos de instancia
access.to.static.field.locked.on.instance.problem.descriptor=Acceso al campo estático <code>#ref</code> bloqueado en datos de instancia #loc
make.method.ctr.quickfix=Crear constructor de método
replace.all.dot.display.name=Argumento de expresión regular sospechosa
replace.all.dot.problem.descriptor=Expresión regex sospechosa#refen la llamada a ''{0}()'' #loc
replace.all.dot.quickfix=Escape del metacarácter de expresión regular
class.extends.utility.class.display.name=La clase extiende la clase de utilidad
class.extends.utility.class.problem.descriptor=Class <code>#ref</code> extiende la clase de utilidad ''{0}'' #loc
class.extends.utility.class.ignore.utility.class.option=Ignorar si la clase de reemplazo es una clase de utilidad
public.constructor.in.non.public.class.quickfix=Hacer constructor ''{0}''
assignment.to.method.parameter.ignore.transformation.option=<html> Ignorar si la asignación es una transformación del parámetro original </html>
type.parameter.extends.final.class.display.name=El parámetro de tipo extiende la clase final
type.parameter.extends.final.class.type.parameter.problem.descriptor=Tipo de parámetro <code>#ref</code> extiende ''final'' clase ''{0}'' #loc
type.parameter.extends.enum.type.parameter.problem.descriptor=Tipo de parámetro <code>#ref</code> se extiende implícitamente enum final ''{0}'' #loc
type.parameter.extends.final.class.wildcard.problem.descriptor=El argumento de tipo comodín <code>#ref</code> extiende ''final'' clase ''{0}'' #loc
type.parameter.extends.enum.wildcard.problem.descriptor=El argumento de tipo comodín <code>#ref</code> extiende implícitamente la enumeración final ''{0}'' #loc
type.parameter.extends.final.class.quickfix=Reemplazar el parámetro de tipo con la clase real
double.negation.display.name=Doble negación
double.negation.problem.descriptor=Doble negación en <code>#ref</code> #loc
double.negation.quickfix=Eliminar la doble negación
exception.from.catch.which.doesntwrap.ignore.option=Ignorar si se usa el resultado de la llamada al método de excepción
exception.from.catch.which.doesntwrap.ignore.cant.wrap.option=Ignorar si la excepción lanzada no puede envolver una excepción
comparable.implemented.but.equals.not.overridden.display.name=Comparable implementado pero 'equals()' no anulado
comparable.implemented.but.equals.not.overridden.problem.descriptor=Class <code>#ref</code> implementa 'java.lang.Comparable' pero no anula 'equals()' #loc
unqualified.field.access.display.name=El acceso al campo de la instancia no está calificado con 'esto'
unqualified.field.access.problem.descriptor=El acceso al campo de instancia <code>#ref</code> no está calificado con 'this' #loc
unqualified.method.access.display.name=Llamada al método de instancia no calificada con 'this'
unqualified.method.access.problem.descriptor=La llamada al método de instancia <code>#ref</code> no está calificada con 'this' #loc
add.this.qualifier.quickfix=Agregar 'este' calificador
while.loop.spins.on.field.ignore.non.empty.loops.option=Advertir solo si el bucle está vacío
method.may.be.synchronized.problem.descriptor=El método <code>#ref()</code> con bloque sincronizado podría sincronizarse método #loc
method.may.be.synchronized.display.name=El método con bloque sincronizado podría ser un método sincronizado
method.may.be.synchronized.quickfix=Hacer que el método esté sincronizado y eliminar el bloque sincronizado
fallthru.in.switch.statement.quickfix=Agregar 'descanso'
law.of.demeter.display.name=La llamada al método viola la ley de Demeter
law.of.demeter.problem.descriptor=<code>#ref()</code> la llamada viola la ley de Demeter #loc
law.of.demeter.ignore.library.calls.option=Ignorar las llamadas a los métodos de la biblioteca
assertequals.between.inconvertible.types.display.name='assertEquals()' entre objetos de tipos inconvertibles
assertequals.between.inconvertible.types.problem.descriptor=<code>#ref()</code> entre objetos de tipos inconvertibles ''{0}'' y ''{1}'' #loc
assertnotequals.between.inconvertible.types.problem.descriptor=Posible aserción redundante: los tipos incompatibles se comparan ''{0}'' y ''{1}''
assertnotsame.between.inconvertible.types.problem.descriptor=Aserción redundante: los tipos incompatibles se comparan ''{0}'' y ''{1}''
enumeration.can.be.iteration.display.name=La enumeración puede ser iteración
enumeration.can.be.iteration.problem.descriptor=<code>#ref()</code> se puede reemplazar con ''{0}'' construct #loc
enumeration.can.be.iteration.quickfix=Reemplazar con la construcción 'Iterator'
equals.hashcode.called.on.url.display.name='equals()' o 'hashCode()' llamado en el objeto 'java.net.URL'
equals.hashcode.called.on.url.problem.descriptor=Llamar a <code>#ref()</code> en el objeto URL #loc
collection.contains.url.problem.decriptor={0} <code>#ref</code> puede contener objetos URL #loc
collection.contains.url.display.name=El mapa o el conjunto pueden contener objetos 'java.net.URL'
implicit.array.to.string.problem.descriptor=Llamada implícita a 'toString()' en la matriz <code>#ref</code> #loc
explicit.array.to.string.problem.descriptor=Llamada a '#ref()' en la matriz #loc
implicit.array.to.string.method.call.problem.descriptor=Llamada implícita a 'toString()' en la matriz devuelta por la llamada a <code>#ref</code> #loc
implicit.array.to.string.display.name=Llamar a 'toString()' en la matriz
implicit.array.to.string.quickfix=Ajustar con expresión ''{0}''
suspicious.indent.after.control.statement.problem.descriptor=<code>#ref</code> declaración tiene sangría sospechosa #loc
suspicious.indent.after.control.statement.display.name=Sangría sospechosa después de la declaración de control sin llaves
unpredictable.big.decimal.constructor.call.display.name=Llamada al constructor BigDecimal impredecible
unpredictable.big.decimal.constructor.call.problem.descriptor=Impredecible <code> new#ref()</code> llamada #loc
unpredictable.big.decimal.constructor.call.ignore.references.option=Ignorar las llamadas al constructor con argumentos de llamada de variable o método
unpredictable.big.decimal.constructor.call.ignore.complex.literals.option=Ignorar las llamadas al constructor con varios literales (por ejemplo, 0,1 + 0,2)
unnecessary.unary.minus.display.name=Menos unario innecesario
unnecessary.unary.minus.problem.descriptor=Unario innecesario menos #loc
unnecessary.unary.minus.quickfix=Eliminar el signo menos unario e invertir el signo de operación principal
make.field.final.quickfix=Hacer ''{0}'' ''final''
increment.decrement.used.as.expression.quickfix=Extraer ''{0}'' a una declaración separada
ignore.classes.in.hierarchy.column.name=Ignorar subclases de
overly.strong.type.cast.ignore.in.matching.instanceof.option=Ignorar las conversiones con una instancia de expresión coincidente
access.to.non.thread.safe.static.field.from.instance.display.name=Acceso a campo estático no seguro para subprocesos
access.to.non.thread.safe.static.field.from.instance.field.problem.descriptor=Acceso al campo estático no seguro para subprocesos <code>#ref</code> de tipo ''{0}' '#loc
access.to.non.thread.safe.static.field.from.instance.option.title=Clases no seguras para subprocesos
access.to.non.thread.safe.static.field.from.instance.class.chooser.title=Elija una clase no segura para subprocesos
transient.field.not.initialized.display.name=El campo transitorio no se inicializa en la deserialización
transient.field.not.initialized.problem.descriptor=El campo transitorio <code>#ref</code> no se inicializó en la deserialización #loc
call.to.string.concat.can.be.replaced.by.operator.display.name=La llamada a 'String.concat()' se puede reemplazar con '+'
call.to.string.concat.can.be.replaced.by.operator.problem.descriptor=La llamada a <code>#ref()</code> se puede reemplazar con la expresión '+' #loc
call.to.string.concat.can.be.replaced.by.operator.quickfix=Reemplazar la llamada 'concat()' con '+'
new.string.buffer.with.char.argument.display.name=Llamada al constructor StringBuilder con argumento 'char'
new.string.buffer.with.char.argument.problem.descriptor=<code> new#ref()</code> con argumento de tipo 'char' #loc
new.string.buffer.with.char.argument.quickfix=Reemplazar el argumento char con el literal String
suspicious.comparator.compare.display.name=Implementación sospechosa de 'Comparator.compare()'
suspicious.comparator.compare.descriptor.parameter.not.used=El parámetro <code>#ref</code> 'compare()' no se usa #loc
suspicious.comparator.compare.descriptor.non.reflexive=El comparador no devuelve 0 para elementos iguales
to.array.call.style.display.name=Estilo de llamada 'Collection.toArray()'
to.array.call.style.problem.descriptor.zero=Llamar a <code>#ref()</code> con un argumento de matriz vacío ''{0}'' #loc
to.array.call.style.problem.descriptor.presized=Llamada a <code>#ref()</code> con argumento de matriz de tamaño predeterminado ''{0}'' #loc
to.array.call.style.quickfix.family.name=Corregir el tamaño de la matriz pasada a la llamada 'toArray'
to.array.call.style.quickfix.make.presized=Reemplazar argumento con una matriz de tamaño predeterminado
to.array.call.style.quickfix.make.zero=Reemplazar argumento con una matriz vacía
throwable.instance.never.thrown.runtime.exception.problem.descriptor=La instancia de excepción de tiempo de ejecución <code>#ref</code> no se lanza #loc
throwable.instance.never.thrown.checked.exception.problem.descriptor=La instancia de excepción marcada <code>#ref</code> no se lanza #loc
throwable.instance.never.thrown.error.problem.descriptor=La instancia de error <code>#ref</code> no se lanza #loc
throwable.instance.never.thrown.problem.descriptor=La instancia lanzada <code>#ref</code> no se lanza #loc
ignore.guard.clauses.option=Ignorar y proteger cláusulas
ignore.for.equals.methods.option=Ignorar los métodos '&equals()'
caught.exception.immediately.rethrown.display.name=La excepción capturada se vuelve a lanzar inmediatamente
caught.exception.immediately.rethrown.problem.descriptor=La excepción capturada <code>#ref</code> se vuelve a lanzar inmediatamente #loc
delete.catch.section.quickfix=Eliminar la sección 'captura'
loop.with.implicit.termination.condition.display.name=Bucle con condición de terminación implícita
loop.with.implicit.termination.condition.dowhile.problem.descriptor=<code>#ref-while </code> loop con condición de terminación implícita #loc
loop.with.implicit.termination.condition.problem.descriptor=<code>#ref</code> bucle con condición de terminación implícita #loc
loop.with.implicit.termination.condition.quickfix=Hacer explícita la condición
rename.catch.parameter.to.ignored=Cambiar el nombre del parámetro '' catch '' a ''{0}''
inspection.empty.catch.block.generate.body=Generar cuerpo 'captura' a partir de plantilla
unnecessary.super.qualifier.display.name=Calificador 'super' innecesario
unnecessary.super.qualifier.problem.descriptor=El calificador <code>#ref</code> es innecesario en este contexto #loc
unnecessary.super.qualifier.quickfix=Elimina el calificador 'super' innecesario
collections.field.access.replaceable.by.method.call.display.name=Collections.EMPTY_ * acceso al campo reemplazable con la llamada al método 'Collections.empty *()'
collections.field.access.replaceable.by.method.call.problem.descriptor=<code>#ref</code> reemplazable por '' Colecciones.{0}'' #loc
synchronization.on.local.variable.or.method.parameter.display.name=Sincronización en variable local o parámetro de método
synchronization.on.local.variable.problem.descriptor=Sincronización en la variable local <code>#ref</code> #loc
synchronization.on.method.parameter.problem.descriptor=Sincronización en el parámetro del método <code>#ref</code> #loc
too.broad.catch.quickfix=Agregar cláusula '' catch '' para ''{0}''
replace.with.catch.clause.for.runtime.exception.quickfix=Reemplazar con la cláusula 'catch' para 'RuntimeException'
too.broad.catch.option=&Solo advertir sobre RuntimeException, Exception, Error o Throwable
unnecessary.conversion.to.string.display.name=Conversión innecesaria a cadena
unnecessary.tostring.call.display.name=Llamada innecesaria a 'toString()'
unnecessary.tostring.call.problem.descriptor=<code>#ref()</code> innecesaria llamada #loc
throwable.not.thrown.display.name=Lanzable no arrojado
throwable.result.of.method.call.ignored.problem.descriptor=Resultado de <code>#ref()</code> no arrojado #loc
char.used.in.arithmetic.context.display.name='char' expresión utilizada en contexto aritmético
char.used.in.arithmetic.context.problem.descriptor='char' <code>#ref</code> usado en contexto aritmético #loc
char.used.in.arithmetic.context.quickfix=Convertir a literal de cadena
char.used.in.arithmetic.context.cast.quickfix=Insertar conversión en {0}
unnecessary.constant.array.creation.expression.display.name=Expresión 'nueva' redundante en la creación constante de matrices
unnecessary.constant.array.creation.expression.problem.descriptor=<code>#ref</code> se puede reemplazar con la expresión del inicializador de matriz #loc
unnecessary.constant.array.creation.expression.family.quickfix=Reemplazar con la expresión del inicializador de matriz
ambiguous.method.call.display.name=La llamada al método heredado parece una llamada al método local
ambiguous.method.call.problem.descriptor=Llamada al método <code>#ref()</code> desde la superclase ''{0}'' parece una llamada al método desde la clase ''{1}'' #loc
ambiguous.method.call.quickfix=Agregar calificador 'super' a la llamada al método
change.modifier.quickfix=Hacer ''{0}''
the.whole.project=el proyecto completo
this.class=esta clase
assertequals.may.be.assertsame.display.name='assertEquals()' puede ser 'assertSame()'
assertequals.may.be.assertsame.problem.descriptor=<code>#ref()</code> puede ser 'assertSame()' #loc
logger.initialized.with.foreign.class.problem.descriptor=Registrador inicializado con clase extranjera <code>#ref</code> #loc
logger.initialized.with.foreign.class.display.name=Logger inicializado con clase extranjera
logger.factory.method.name=Nombre del método de fábrica del registrador
logger.factory.class.name=Nombre de clase de la fábrica de registradores
make.static.final.quickfix=Hacer ''{0}'' estático final
logging.condition.disagrees.with.log.statement.display.name=La condición de registro no coincide con la llamada de registro
logging.condition.disagrees.with.log.statement.problem.descriptor=La condición de registro <code>#ref()</code> no coincide con la llamada de registro '' {0}() '' #loc
log.statement.guarded.by.log.condition.display.name=Llamada de registro no protegida por la condición de registro
log.statement.guarded.by.log.condition.problem.descriptor=<code>#ref()</code> registro de llamadas no protegido por la condición de registro #loc
log.statement.guarded.by.log.condition.quickfix=Rodear con condición de registro
log.statement.guarded.by.log.condition.flag.all.unguarded.option=Marcar todas las llamadas de registro no vigiladas
key.set.iteration.may.use.entry.set.display.name=La iteración sobre 'keySet()' puede optimizarse
key.set.iteration.may.use.entry.set.problem.descriptor=La iteración sobre <code>#ref</code> se puede reemplazar con ''{0}'' iteración #loc
key.set.iteration.may.use.entry.set.quickfix=Optimizar iteración del mapa
string.replaceable.by.string.buffer.in.loop.option=Solo advertir cuando se agrega en un bucle
declare.collection.as.interface.quickfix=Debilitado a ''{0}''
non.exception.name.ends.with.exception.quickfix=Hacer ''{0}'' extender '' java.lang.Exception ''
constant.value.variable.use.display.name=Uso de variable cuyo valor se sabe que es constante
constant.value.variable.use.problem.descriptor=Se sabe que el valor de <code>#ref</code> es constante #loc
unnecessary.parentheses.option=Ignorar los paréntesis aclaratorios
unnecessary.parentheses.conditional.option=Ignore los paréntesis alrededor de la condición de las expresiones condicionales
field.may.be.final.display.name=El campo puede ser 'final'
field.may.be.final.problem.descriptor=El campo <code>#ref</code> puede ser #loc 'final'
cast.that.loses.precision.option=Ignorar conversiones de int a char
ignore.overflowing.byte.casts.option=Ignorar conversiones de int 128-255 a byte
variable.not.used.inside.if.display.name=La referencia marcada para 'nulo' no se usa dentro de 'if'
variable.not.used.inside.if.problem.descriptor=<code>#ref</code> marcado para 'nulo' no se usa dentro de 'if' #loc
variable.not.used.inside.conditional.problem.descriptor=<code>#ref</code> verificado para 'nulo' no se usa dentro del #loc condicional
boolean.expression.may.be.conditional.display.name=La expresión booleana podría reemplazarse con una expresión condicional
if.may.be.conditional.problem.descriptor=<code>#ref</code> podría reemplazarse con la expresión condicional #loc
if.may.be.conditional.quickfix=Reemplazar con expresión condicional
redundant.string.format.call.display.name=Llamada redundante a 'String.format()'
redundant.call.problem.descriptor=Llamada redundante a <code>#ref()</code> #loc
redundant.string.format.call.quickfix=Eliminar la llamada redundante a 'String.format()'
redundant.string.formatted.call.quickfix=Eliminar la llamada redundante a 'String.formatted()'
junit4.test.method.in.class.extending.junit3.testcase.display.name=Método de prueba JUnit 4 en la clase que extiende JUnit 3 TestCase
convert.junit3.test.case.error.string=<code>#ref</code> podría convertirse al caso de prueba JUnit4
convert.junit3.test.case.family.name=Convertir a caso de prueba JUnit 4
convert.junit3.test.case.display.name=La prueba JUnit 3 puede ser JUnit 4
junit4.test.method.in.class.extending.junit3.testcase.problem.descriptor=Método <code>#ref()</code> anotado con '@Test' dentro de la clase que extiende JUnit 3 TestCase #loc
ignore.test.method.in.class.extending.junit3.testcase.problem.descriptor=El método de prueba JUnit 3 <code>#ref()</code> anotado con '@Ignore' no será ignorado #loc
ignore.test.method.in.class.extending.junit3.testcase.quickfix=Eliminar '' @Ignore '' y cambiar el nombre del método a ''{0}''
convert.junit3.test.class.quickfix=Convertir la clase JUnit 3 ''{0}'' a JUnit 4
remove.junit4.test.annotation.quickfix=Eliminar la anotación '@Test'
remove.junit4.test.annotation.and.rename.quickfix=Eliminar la anotación '' @Test '' y cambiar el nombre a ''{0}''
equals.called.on.enum.constant.display.name='equals()' llamado en el valor Enum
equals.called.on.enum.constant.problem.descriptor=<code>#ref()</code> llamado en el valor Enum #loc
int.literal.may.be.long.literal.display.name='int' literal convertido a 'long' podría ser literal 'long'
int.literal.may.be.long.literal.problem.descriptor=<code>#ref</code> podría reemplazarse con ''{0}'' #loc
constant.assert.condition.display.name=la condición de la declaración 'assert' es constante
constant.assert.condition.problem.descriptor=Afirmar la condición <code>#ref</code> es constante #loc
assert.with.side.effects.display.name=declaración 'assert' con efectos secundarios
assert.with.side.effects.problem.descriptor=<code>#ref</code> tiene efectos secundarios:{0}#loc
method.count.ignore.getters.setters.option=&Ignorar métodos simples getter y setter
class.new.instance.display.name=Llamada no segura a 'Class.newInstance()'
class.new.instance.problem.descriptor=La llamada a <code>#ref()</code> puede generar excepciones marcadas no declaradas #loc
dynamic.regex.replaceable.by.compiled.pattern.display.name=La expresión regular dinámica podría ser reemplazada por un patrón compilado
dynamic.regex.replaceable.by.compiled.pattern.problem.descriptor=<code>#ref()</code> podría reemplazarse con la construcción compilada 'java.util.regex.Pattern' #loc
dynamic.regex.replaceable.by.compiled.pattern.quickfix=Reemplazar con una llamada al método de la constante compilada 'Patrón'
ignore.serializable.option=Ignorar 'java.io.Serializable'
ignore.cloneable.option=Ignorar 'java.lang.Cloneable'
listener.may.use.adapter.display.name=La clase puede extender el adaptador en lugar de implementar el oyente
listener.may.use.adapter.problem.descriptor=Class ''{0}'' puede extender ''{1}'' en lugar de implementar <code>#ref</code> #loc
listener.may.use.adapter.emtpy.methods.option=&Advertir solo cuando se encuentran métodos de implementación vacíos
unnecessary.inherit.doc.display.name=Comentario de Javadoc {@inheritDoc} innecesario
unnecessary.inherit.doc.problem.descriptor=El comentario de Javadoc que contiene solo <code>#ref</code> es innecesario #loc
unnecessary.inherit.doc.field.invalid.problem.descriptor=<code>#ref</code> no es válido en los campos #loc
unnecessary.inherit.doc.constructor.invalid.problem.descriptor=<code>#ref</code> no es válido en constructores #loc
unnecessary.inherit.doc.class.invalid.problem.descriptor=<code>#ref</code> no es válido en las clases #loc
unnecessary.inherit.doc.module.invalid.problem.descriptor=<code>#ref</code> no es válido en declaraciones de módulo #loc
unnecessary.inherit.doc.constructor.no.super.problem.descriptor=No se ha encontrado un súper método para heredar Javadoc de #loc
unnecessary.inherit.doc.quickfix=Eliminar {@inheritDoc} innecesario
multiple.exceptions.declared.on.test.method.display.name=Varias excepciones declaradas en el método de prueba
multiple.exceptions.declared.on.test.method.problem.descriptor=<code>#ref</code> podría reemplazarse con 'throws Exception' #loc
unnecessary.javadoc.link.display.name=Enlace Javadoc innecesario
unnecessary.javadoc.link.super.method.problem.descriptor=<code>#ref</code> apuntar al súper método es innecesario #loc
unnecessary.javadoc.link.this.method.problem.descriptor=<code>#ref</code> apuntar a este método es innecesario #loc
unnecessary.javadoc.link.this.class.problem.descriptor=<code>#ref</code> apuntar a la clase contenedora es innecesario #loc
unnecessary.javadoc.link.quickfix=Elimina innecesarios ''{0}''
thread.local.not.static.final.display.name=El campo ThreadLocal no se declaró estático final
thread.local.not.static.final.problem.descriptor=ThreadLocal <code>#ref</code> no está declarado 'static final' #loc
remove.try.finally.block.quickfix=Eliminar el bloque 'intentar finalmente'
remove.finally.block.quickfix=Eliminar el bloque 'finalmente'
remove.leading.zero.to.make.decimal.quickfix=Elimina el cero inicial para hacer decimal
remove.leading.zeroes.to.make.decimals.quickfix=Elimina los ceros iniciales para hacer decimales
convert.octal.literal.to.decimal.literal.quickfix=Convertir literal octal en literal decimal
convert.octal.literals.to.decimal.literals.quickfix=Convertir literales octales en literales decimales
ignore.single.field.static.imports.option=Ignorar importaciones estáticas individuales y de campo
ignore.single.method.static.imports.option=Ignorar importaciones estáticas de un solo &método
ignore.methods.with.boolean.return.type.option=Ignorar métodos con el tipo de retorno 'java.lang. &Boolean'
ignore.boolean.methods.in.an.interface.option=Ignorar métodos booleanos en una interfaz @&
ignore.methods.overriding.super.method=Ignorar el mét&odo para anular/implementar un súper método
ignore.nullable.parameters.option=Ignorar los parámetros de @Nullable
ignored.io.resource.types=Tipos de recursos de E/S ignorados
choose.io.resource.type.to.ignore=Elija el tipo de recurso de E/S para ignorar
ignore.accesses.from.the.same.class=Ignorar accesos de la misma clase
ignore.accesses.from.equals.method=Ignorar accesos desde el método 'equals()'
ignore.branches.of.switch.statements=Ignorar ramas de declaraciones 'switch'
ignore.equals.hashcode.and.tostring=Ignorar los métodos 'equals()', 'hashCode()' y 'toString()'
ignore.methods.in.anonymous.classes=Ignorar métodos en clases anónimas
class.name=Nombre de la clase
method.name.regex=Nombre del método regex
choose.class=Elige clase
query.column.name=Los nombres de las consultas comienzan con
update.column.name=Los nombres de actualización comienzan con
assert.keyword.is.considered.an.assertion=la palabra clave 'assert' se considera una aserción
expected.exception.never.thrown.display.name=Excepción esperada nunca lanzada en el cuerpo del método de prueba
expected.exception.never.thrown.problem.descriptor=Se esperaba <code>#ref</code> nunca incluido en el cuerpo de '' {0}() '' #loc
choose.logger.class=Elija la clase de registrador
logger.class.name=Nombre de la clase del registrador
ignore.exceptions.declared.on.library.override.option=Ignore las excepciones declaradas en los métodos que anulan un método &library
allow.resource.to.be.opened.inside.a.try.block=Permitir que el recurso se abra dentro de un bloque 'try'
any.method.may.close.resource.argument=Cualquier método puede cerrar el argumento del recurso
log.method.name=Nombre del método de registro
log.condition.text=Log condition text
ignore.if.annotated.by=Ignore if annotated by
ignore.parameter.if.annotated.by=Ignore parameter if it is annotated by
ignore.classes.annotated.by=Ignore classes annotated by
ignored.class.hierarchies.border.title=Ignore subclasses of
choose.class.hierarchy.to.ignore.title=Choose Class Hierarchy to Ignore
unqualified.inner.class.access.display.name=Unqualified inner class access
unqualified.inner.class.access.problem.descriptor=<code>#ref</code> is not qualified with outer class #loc
unqualified.inner.class.access.quickfix=Qualify with outer class
unnecessarily.qualified.inner.class.access.problem.descriptor=''{0}'' is unnecessarily qualified with <code>#ref</code> #loc
unnecessarily.qualified.inner.class.access.display.name=Unnecessarily qualified inner class access
unnecessarily.qualified.inner.class.access.quickfix=Remove qualifier
synchronization.on.static.field.display.name=Synchronization on 'static' field
synchronization.on.static.field.problem.descriptor=Synchronization on 'static' field <code>#ref</code> #loc
assertequals.called.on.arrays.display.name='assertEquals()' called on array
assertequals.called.on.arrays.problem.descriptor=<code>#ref()</code> called on array #loc
overly.broad.throws.clause.display.name=Overly broad 'throws' clause
overly.broad.throws.clause.problem.descriptor1=<code>throws #ref</code> is too broad, masking exception ''{0}'' #loc
overly.broad.throws.clause.problem.descriptor2=<code>throws #ref</code> is too broad, masking exceptions ''{0}'' and ''{1}'' #loc
overly.broad.throws.clause.quickfix1=Add specific exceptions
overly.broad.throws.clause.quickfix2=Replace with specific exceptions
overly.broad.throws.clause.ignore.thrown.option=Ignore exceptions which &hide others but are themselves thrown
unnecessarily.qualified.statically.imported.element.display.name=Unnecessarily qualified statically imported element
unnecessarily.qualified.statically.imported.element.problem.descriptor=Statically imported element ''{0}'' is unnecessarily qualified with <code>#ref</code> #loc
unnecessarily.qualified.statically.imported.element.quickfix=Remove unnecessary qualifier
ignore.instanceof.on.library.classes=Ignore instanceof on library classes
for.can.be.foreach.option=Report indexed 'java.util.List' loops
for.can.be.foreach.option2=Do not report iterations over untyped collections
cast.conflicts.with.instanceof.quickfix1=Replace ''{0}'' with ''{1}'' in cast
cast.conflicts.with.instanceof.quickfix2=Replace ''{0}'' with ''{1}'' in instanceof
double.checked.locking.quickfix=Make ''{0}'' volatile
double.literal.may.be.float.literal.display.name='double' literal cast to 'float' could be 'float' literal
multiple.declaration.ignore.for.option=Ignore 'for' loop declarations
multiple.declaration.array.only.option=Only warn on different array dimensions in a single declaration
simplifiable.annotation.display.name=Simplifiable annotation
simplifiable.annotation.problem.descriptor=Unnecessary <code>#ref</code> in annotation #loc
simplifiable.annotation.whitespace.problem.descriptor=Unnecessary whitespace in annotation #loc
simplifiable.annotation.quickfix=Simplify annotation
overloaded.methods.with.same.number.parameters.option=<html>Ignore overloaded methods whose parameter types are definitely incompatible</html>
string.concatenation.in.format.call.display.name=String concatenation as argument to 'format()' call
string.concatenation.in.format.call.problem.descriptor=<code>#ref()</code> call has a String concatenation argument #loc
string.concatenation.in.format.call.quickfix=Replace concatenation with separate argument
string.concatenation.in.message.format.call.display.name=String concatenation as argument to 'MessageFormat.format()' call
string.concatenation.in.message.format.call.problem.descriptor=String concatenation as argument to 'MessageFormat.format()' call #loc
boxing.boxed.value.display.name=Boxing of already boxed value
boxing.boxed.value.problem.descriptor=Boxing of already boxed <code>#ref</code> #loc
boxing.boxed.value.quickfix=Remove unnecessary boxing
unnecessary.javadoc.link.option=Ignore inline links to super methods
constant.junit.assert.argument.display.name=Constant assert argument
constant.junit.assert.argument.problem.descriptor=Argument <code>#ref</code> is constant #loc
test.case.with.no.test.methods.option=Ignore test cases which have superclasses with test methods
package.dot.html.may.be.package.info.display.name='package.html' may be converted to 'package-info.java'
package.dot.html.may.be.package.info.exists.problem.descriptor=<code>package.html</code> is ignored because <code>package-info.java</code> exists
package.dot.html.may.be.package.info.problem.descriptor=<code>package.html</code> may be converted to <code>package-info.java</code>
package.dot.html.may.be.package.info.delete.quickfix=Delete 'package.html'
package.dot.html.may.be.package.info.convert.quickfix=Convert to 'package-info.java'
choose.super.class.to.ignore=Choose class
ignore.anonymous.inner.classes=Ignore anonymous inner classes
try.with.identical.catches.display.name=Identical 'catch' branches in 'try' statement
try.with.identical.catches.problem.descriptor=''catch'' branch identical to ''{0}'' branch #loc
if.can.be.switch.display.name='if' replaceable with 'switch'
if.can.be.switch.problem.descriptor=<code>#ref</code> statement replaceable with 'switch' statement #loc
if.can.be.switch.minimum.branch.option=Minimum number of 'if' condition branches:
if.can.be.switch.int.option=Suggest switch on numbers
if.can.be.switch.enum.option=Suggest switch on enums
if.can.be.switch.null.safe.option=Only suggest on null-safe expressions
unnecessarily.qualified.inner.class.access.option=Ignore references for which an import is needed
unqualified.inner.class.access.option=Ignore references to local inner classes
try.with.identical.catches.quickfix=Collapse 'catch' blocks
confusing.else.option=Report when there are no more statements after the 'if' statement
html.tag.can.be.javadoc.tag.display.name=<code>...</code> can be replaced with {@code...}
html.tag.can.be.javadoc.tag.problem.descriptor=<code>#ref...\\&lt;/code\\&gt;</code> can be replaced with '{@code...}' #loc
try.finally.can.be.try.with.resources.display.name='try finally' replaceable with 'try' with resources
try.finally.can.be.try.with.resources.problem.descriptor=<code>#ref</code> can use automatic resource management #loc
try.finally.can.be.try.with.resources.quickfix=Replace with 'try' with resources
array.comparison.display.name=Array comparison using '==', instead of 'Arrays.equals()'
array.comparison.problem.descriptor=Array objects are compared using <code>#ref</code>, not 'Arrays.equals()' #loc
array.hash.code.display.name='hashCode()' called on array
array.hash.code.problem.descriptor=<code>#ref()</code> called on array should probably be 'Arrays.hashCode()' #loc
method.can.be.variable.arity.method.display.name=Method can be varargs method
method.can.be.variable.arity.method.problem.descriptor=<code>#ref()</code> can be converted to varargs method #loc
method.can.be.variable.arity.method.ignore.byte.short.option=Ignore parameters with type byte[] or short[]
method.can.be.variable.arity.method.ignore.all.primitive.arrays.option=Ignore all primitive array types
method.can.be.variable.arity.method.ignore.multiple.arrays.option=Ignore methods with multiple array parameters
method.can.be.variable.arity.method.ignore.multidimensional.arrays.option=Ignore multidimensional array parameters
convert.to.variable.arity.method.quickfix=Convert to varargs method
mismatched.string.builder.query.update.display.name=Mismatched query and update of StringBuilder
mismatched.string.builder.updated.problem.descriptor=Contents of{0}<code>#ref</code> are updated, but never queried #loc
mismatched.string.builder.queried.problem.descriptor=Contents of{0}<code>#ref</code> are queried, but never updated #loc
math.random.cast.to.int.display.name='Math.random()' cast to 'int'
math.random.cast.to.int.problem.descriptor=<code>#ref</code> cast to ''{0}'' is always rounded down to ''0'' #loc
math.random.cast.to.int.quickfix=Add parentheses to perform multiplication before cast
boolean.variable.always.inverted.display.name=Boolean variable is always inverted
boolean.field.always.inverted.problem.descriptor=Boolean field <code>#ref</code> is always inverted #loc
boolean.variable.always.inverted.problem.descriptor=Boolean variable <code>#ref</code> is always inverted #loc
unnecessary.explicit.numeric.cast.display.name=Unnecessary explicit numeric cast
unnecessary.explicit.numeric.cast.problem.descriptor=''{0}'' unnecessarily cast to <code>#ref</code> #loc
unnecessary.explicit.numeric.cast.quickfix=Remove cast
null.thrown.display.name='null' thrown
null.thrown.problem.descriptor=<code>#ref</code> thrown #loc
unnecessary.final.on.local.variable.or.parameter.display.name=Unnecessary 'final' on local variable or parameter
unnecessary.final.on.local.variable.problem.descriptor=Unnecessary <code>#ref</code> on variable ''{0}'' #loc
unnecessary.final.on.parameter.problem.descriptor=Unnecessary <code>#ref</code> on parameter ''{0}'' #loc
unnecessary.final.report.local.variables.option=Report local variables
unnecessary.final.report.parameters.option=Report parameters
unnecessary.final.on.parameter.only.interface.option=Only warn on abstract or interface methods
choose.exception.class=Choose Exception class
class.independent.of.module.display.name=Class independent of its module
class.independent.of.module.problem.descriptor=Class <code>#ref</code> has no dependencies or dependents in its module #loc
class.only.used.in.one.module.display.name=Class only used from one other module
class.only.used.in.one.module.problem.descriptor=Class <code>#ref</code> has only dependencies on and/or dependents in module ''{0}'' #loc
empty.directory.display.name=Empty directory
empty.directories.problem.descriptor=Empty directory <code>{0}</code>
empty.directories.only.under.source.roots.option=Only report empty directories located under a source folder
empty.directories.delete.quickfix=Delete empty directory ''{0}''
simplifiable.equals.expression.option.non.constant=Report equals with non-constant not-null argument
simplifiable.equals.expression.display.name=Unnecessary 'null' check before 'equals()' call
simplifiable.equals.expression.problem.descriptor=Unnecessary ''null'' check before ''{0}()'' call #loc
simplifiable.equals.expression.quickfix=Flip ''.{0}()'' and remove unnecessary ''null'' check
cast.to.concrete.class.option=Ignore casts to an abstract class type
cast.to.concrete.class.ignore.equals.option=Ignore in equals()
instanceof.interfaces.option=Ignore instanceof abstract class
instance.variable.of.concrete.class.option=Ignore instance fields whose type is an abstract class
local.variable.of.concrete.class.option=Ignore local variables whose type is an abstract class
method.return.of.concrete.class.option=Ignore methods whose return type is an abstract class
parameter.of.concrete.class.option=Ignore parameters whose type is abstract class
static.variable.of.concrete.class.option=Ignore static fields whose type is an abstract class
class.only.used.in.one.package.display.name=Class only used from one other package
class.only.used.in.one.package.problem.descriptor=Class <code>#ref</code> has only dependencies on and/or dependents in package ''{0}'' #loc
unnecessary.return.option=Ignore in then branch of 'if' statement with 'else' branch
usage.of.obsolete.assert.display.name=Usage of obsolete 'junit.framework.Assert' method
use.of.obsolete.assert.problem.descriptor=Call to <code>#ref()</code> from ''{0}'' should be replaced with call to method from ''org.junit.Assert'' #loc
use.of.obsolete.assert.quickfix=Replace with 'org.junit.Assert' method call
junit5.assertions.converter.problem.descriptor=Call to <code>#ref()</code> from ''{0}'' should be replaced with call to method from ''{1}'' #loc
junit5.assertions.converter.quickfix=Replace with ''{0}'' method call
junit5.assertions.converter.familyName=Replace with JUnit 5 compatible call
ignored.junit.test.display.name=JUnit test annotated with '@Ignore'/'@Disabled'
ignored.junit.test.classproblem.descriptor=Test class ''{0}'' annotated with <code>#ref</code> #loc
ignored.junit.test.method.problem.descriptor=Test method ''{0}()'' annotated with <code>#ref</code> #loc
unclear.binary.expression.display.name=Unclear expression
unclear.binary.expression.problem.descriptor=Expression could use clarifying parentheses #loc
unclear.binary.expression.quickfix=Add clarifying parentheses
new.exception.without.arguments.display.name=Exception constructor called without arguments
new.exception.without.arguments.problem.descriptor=<code>new #ref()</code> without arguments #loc
new.exception.without.arguments.ignore.option=Ignore for exceptions that have no constructors with parameters
absolute.alignment.in.user.interface.display.name=Absolute alignment used in AWT/Swing code
absolute.alignment.in.user.interface.problem.descriptor=Absolute alignment constant <code>{0}.#ref</code> used #loc
throws.runtime.exception.display.name=Unchecked exception declared in 'throws' clause
throws.runtime.exception.problem.descriptor=Unchecked exception <code>#ref</code> declared in 'throws' clause #loc
throws.runtime.exception.quickfix=Remove ''{0}'' from ''throws'' clause
throws.runtime.exception.move.quickfix=Move ''{0}'' to Javadoc ''@throws'' tag
empty.class.ignore.parameterization.option=Ignore class if it is a parameterization of a super type
ambiguous.field.access.display.name=Access of inherited field looks like access of element in surrounding code
ambiguous.field.access.hides.local.variable.problem.descriptor=Access of field <code>#ref</code> from superclass ''{0}'' looks like access of local variable #loc
ambiguous.field.access.hides.parameter.problem.descriptor=Access of field <code>#ref</code> from superclass ''{0}'' looks like access of parameter #loc
ambiguous.field.access.hides.field.problem.descriptor=Access of field <code>#ref</code> from superclass ''{0}'' looks like access of field from surrounding class #loc
ambiguous.field.access.quickfix=Add 'super' qualifier to field access
add.0.to.ignore.if.annotated.by.list.quickfix=Add ''{0}'' to ''Ignore if annotated by'' list
non.final.field.in.enum.display.name=Non-'final' field in enum
non.final.field.in.enum.problem.descriptor=non-''final'' field <code>#ref</code> in enum ''{0}'' #loc
externalizable.without.public.no.arg.constructor.display.name=Externalizable class without 'public' no-arg constructor
externalizable.without.public.no.arg.constructor.problem.descriptor=Externalizable class <code>#ref</code> has no 'public' no-arg constructor #loc
make.constructor.public=Make constructor 'public'
string.concatenation.missing.whitespace.display.name=String literal concatenation missing whitespace
string.concatenation.missing.whitespace.problem.descriptor=String literal concatenation missing whitespace #loc
string.concatenation.missing.whitespace.option=Ignore concatenations with variable strings
negated.equality.expression.display.name=Negated equality expression
negated.equality.expression.problem.descriptor=Negating ''{0}'' #loc
negated.equality.expression.quickfix=Remove negation
negated.conditional.expression.display.name=Negated conditional expression
negated.conditional.expression.problem.descriptor=Negating conditional expression #loc
negated.conditional.expression.quickfix=Remove negation
suspicious.array.cast.display.name=Suspicious array cast
suspicious.array.cast.problem.descriptor=Suspicious cast to <code>#ref</code> #loc
public.constructor.display.name='public' constructor
public.default.constructor.problem.descriptor=Class <code>#ref</code> has 'public' default constructor
public.constructor.problem.descriptor=Public constructor <code>#ref()</code> #loc
public.constructor.quickfix=Replace constructor with factory method
junit3.style.test.method.in.junit4.class.display.name=Old style JUnit test method in JUnit 4 class
junit3.style.test.method.in.junit4.class.problem.descriptor=Old style JUnit test method <code>#ref()</code> in JUnit 4 class #loc
none=none
private=private
package.local.private=package-private \\& private
protected.package.local.private=protected, package-private \\& private
non.final.utility.class.display.name=Utility class is not 'final'
non.final.utility.class.problem.descriptor=Utility class <code>#ref</code> is not 'final' #loc
0.will.no.longer.be.overridable.by.1={0} will no longer be overridable by {1}
0.will.have.incompatible.access.privileges.with.super.1={0} will have incompatible access privileges with super {1}
0.will.no.longer.be.visible.from.overriding.1={0} will no longer be visible from overriding {1}
make.private.quickfix=Make 'private'
arrays.as.list.with.zero.or.one.argument.display.name=Call to 'Arrays.asList()' with too few arguments
arrays.as.list.with.one.argument.problem.descriptor=Call to <code>#ref</code> with only one argument #loc
arrays.as.list.with.zero.arguments.problem.descriptor=Call to <code>#ref</code> to create an empty List #loc
string.concatenation.argument.to.log.call.display.name=Non-constant string concatenation as argument to logging call
string.concatenation.argument.to.log.call.problem.descriptor=Non-constant string concatenation as argument to <code>#ref()</code> logging call #loc
string.concatenation.argument.to.log.call.quickfix=Replace concatenation with parameterized log message
placeholder.count.matches.argument.count.display.name=Number of placeholders does not match number of arguments in logging call
placeholder.count.matches.argument.count.more.problem.descriptor=More arguments provided ({0}) than placeholders specified ({1}) #loc
placeholder.count.matches.argument.count.fewer.problem.descriptor=Fewer arguments provided ({0}) than placeholders specified ({1}) #loc
assignment.to.superclass.field.display.name=Constructor assigns value to field defined in superclass
assignment.to.superclass.field.problem.descriptor=Assignment to field ''{0}'' defined in superclass ''{1}'' #loc
junit.rule.display.name=Malformed @Rule/@ClassRule field
junit.rule.problem.descriptor=Fields annotated with ''@{0}'' should be {1}
junit.rule.type.problem.descriptor=Field type should be subtype of 'org.junit.rules.TestRule'
junit.datapoint.display.name=Malformed @DataPoint field
junit.datapoint.problem.descriptor={1}s annotated with @DataPoint should be {0}
inner.class.referenced.via.subclass.display.name=Inner class referenced via subclass
inner.class.referenced.via.subclass.problem.descriptor=Inner class <code>#ref</code> declared in class ''{0}'' but referenced via subclass ''{1}'' #loc
inner.class.referenced.via.subclass.quickfix=Rationalize inner class access
boolean.parameter.display.name='public' method with 'boolean' parameter
boolean.parameter.problem.descriptor='public' method <code>#ref()</code> with 'boolean' parameter #loc
boolean.parameters.problem.descriptor='public' method <code>#ref()</code> with 'boolean' parameters #loc
boolean.parameter.constructor.problem.descriptor='public' constructor <code>#ref()</code> with 'boolean' parameter #loc
boolean.parameters.constructor.problem.descriptor='public' constructor <code>#ref()</code> with 'boolean' parameters #loc
boolean.parameter.only.report.multiple.option=Only report methods with multiple boolean parameters
unnecessary.unicode.escape.display.name=Unnecessary unicode escape sequence
unnecessary.unicode.escape.problem.descriptor=Unicode escape sequence <code>#ref</code> can be replaced with ''{0}'' #loc
unnecessary.unicode.escape.problem.tab.descriptor=Unicode escape sequence <code>#ref</code> can be replaced with a tab character #loc
unnecessary.unicode.escape.problem.newline.descriptor=Unicode escape sequence <code>#ref</code> can be replaced with a line feed character #loc
missing.package.info.display.name=Missing 'package-info.java'
missing.package.info.problem.descriptor=Package ''{0}'' is missing a <code>package-info.java</code> file
missing.package.html.problem.descriptor=Package ''{0}'' is missing a <code>package.html</code> file
package.info.java.without.package.display.name='package-info.java' without 'package' statement
package.info.without.package.problem.descriptor='package-info.java' does not have a 'package' statement
package.info.without.package.quickfix=Add ''package {0};''
package.info.without.package.family.quickfix=Add package statement
auto.closeable.resource.display.name=AutoCloseable used without 'try'-with-resources
auto.closeable.resource.problem.descriptor=''{0}'' used without ''try''-with-resources statement #loc
auto.closeable.resource.quickfix=Ignore 'AutoCloseable' returned by this method
auto.closeable.resource.returned.option=Ignore AutoCloseable instances returned from all method calls
problematic.varargs.method.display.name=Non-varargs method overrides varargs method
problematic.varargs.method.override.problem.descriptor=Non-varargs method <code>#ref()</code> overrides varargs method #loc
negatively.named.boolean.variable.problem.descriptor=Boolean variable <code>#ref</code> is negatively named #loc
negatively.named.boolean.variable.display.name=Negatively named boolean variable
invert.quickfix.family.name=Invert boolean
invert.method.quickfix=Invert method
invert.quickfix=Invert ''{0}''
throwable.printed.to.system.out.display.name='Throwable' printed to 'System.out'
throwable.printed.to.system.out.problem.descriptor='Throwable' argument <code>#ref</code> to ''System.{0}.{1}()'' call
suppress.for.tests.scope.quickfix=Suppress for 'Tests' scope
implicit.default.charset.usage.display.name=Implicit usage of platform's default charset
implicit.default.charset.usage.problem.descriptor=Call to <code>#ref()</code> uses the platform's default charset
implicit.default.charset.usage.constructor.problem.descriptor=<code>new #ref()</code> call uses the platform's default charset
interface.may.be.annotated.functional.display.name=Interface may be annotated @FunctionalInterface
interface.may.be.annotated.functional.problem.descriptor=Interface <code>#ref</code> may be annotated with @FunctionalInterface
only.report.public.methods.option=Only report 'public' methods
lambda.parameter.hides.member.variable.display.name=Lambda parameter hides field
static.initializer.references.subclass.display.name=Static initializer references subclass
lambda.parameter.hides.member.variable.problem.descriptor=Lambda parameter <code>#ref</code> hides field in class ''{0}'' #loc
lambda.parameter.hides.member.variable.ignore.invisible.option=Ignore fields not actually visible from the lambda
shared.thread.local.random.display.name='ThreadLocalRandom' instance might be shared
shared.thread.local.random.problem.descriptor='ThreadLocalRandom' instance might be shared between threads
native.method.naming.convention.display.name='native' method naming convention
native.method.naming.convention.element.description='native'
use.of.obsolete.date.time.api.display.name=Use of obsolete date-time API
use.of.obsolete.date.time.api.problem.descriptor=Obsolete date-time type <code>#ref</code> used #loc
warn.on.label=Warn on:
all.levels.option=all log levels
warn.level.and.lower.option=warn level and lower
info.level.and.lower.option=info level and lower
debug.level.and.lower.option=debug level and lower
trace.level.option=trace level
ignored.autocloseable.types.column.label=Ignored AutoCloseable resource types
choose.autocloseable.type.to.ignore.title=Choose AutoCloseable resource type to ignore
big.decimal.method.without.rounding.called.display.name=Call to 'BigDecimal' method without a rounding mode argument
big.decimal.method.without.rounding.called.problem.descriptor='BigDecimal.#ref()' called without a rounding mode argument
bigdecimal.legacy.method.display.name='BigDecimal' legacy method called
bigdecimal.legacy.method.problem.descriptor=Call to 'BigDecimal.#ref()' can use 'RoundingMode' enum constant
bigdecimal.legacy.method.quickfix=Use 'RoundingMode' enum constant
serializable.stores.non.serializable.display.name=Serializable object implicitly stores non-Serializable object
serializable.lambda.stores.non.serializable.problem.descriptor=Serializable lambda implicitly stores non-Serializable object of type ''{0}''
serializable.local.class.stores.non.serializable.problem.descriptor=Serializable local class ''{1}'' implicitly stores non-Serializable object of type ''{0}''
serializable.anonymous.class.stores.non.serializable.problem.descriptor=Serializable anonymous class implicitly stores non-Serializable object of type ''{0}''
assignment.to.lambda.parameter.display.name=Assignment to lambda parameter
assignment.to.lambda.parameter.problem.descriptor=Assignment to lambda parameter <code>#ref</code> #loc
class.with.only.private.constructors.display.name=Class with only 'private' constructors should be declared 'final'
class.with.only.private.constructors.problem.descriptor=Class <code>#ref</code> with only 'private' constructors should be declared 'final'
property.value.set.to.itself.display.name=Property value set to itself
equals.with.itself.display.name='equals()' called on itself
equals.with.itself.problem.descriptor=<code>#ref()</code> called on itself
junit4.method.naming.convention.display.name=JUnit 4+ test method naming convention
junit4.method.naming.convention.element.description=JUnit 4+ test
junit3.method.naming.convention.element.description=JUnit 3 test
introduce.holder.class.quickfix=Introduce holder class
double.brace.initialization.display.name=Double brace initialization
double.brace.initialization.quickfix=Replace with regular initialization
return.of.inner.class.display.name=Return of instance of anonymous, local or inner class
return.of.anonymous.class.problem.descriptor=Return of instance of anonymous class #loc
return.of.local.class.problem.descriptor=Return of instance of local class <code>{0}</code> #loc
return.of.inner.class.problem.descriptor=Return of instance of non-static inner class <code>{0}</code> #loc
return.of.inner.class.ignore.non.public.option=Ignore returns from non-public methods
parameter.type.prevents.overriding.display.name=Parameter type prevents overriding
parameter.type.prevents.overriding.problem.descriptor=Parameter type <code>#ref</code> is located in ''{0}'' while super method parameter type is located in ''{1}'' preventing overriding #loc
parameter.type.prevents.overriding.quickfix=Change type of parameter to ''{0}''
parameter.type.prevents.overriding.family.quickfix=Change type of parameter
suspicious.getter.setter.display.name=Suspicious getter/setter
suspicious.setter.problem.descriptor=Setter <code>#ref()</code> assigns field ''{0}'' #loc
suspicious.getter.problem.descriptor=Getter <code>#ref()</code> returns field ''{0}'' #loc
unnecessary.break.display.name=Unnecessary 'break' statement
unnecessary.break.problem.descriptor=<code>#ref</code> statement is unnecessary #loc
utility.class.can.be.enum.display.name=Utility class can be 'enum'
utility.class.code.can.be.enum.problem.descriptor=Utility class <code>\#ref</code> can be 'enum' #loc
utility.class.code.can.be.enum.quickfix=Convert to 'enum'
non.public.clone.display.name='clone()' method not 'public'
non.public.clone.problem.descriptor=<code>#ref()</code> method not 'public' #loc
only.warn.on.public.clone.methods=Only warn on 'public' clone methods
only.warn.on.protected.clone.methods=Only warn on 'protected' clone methods
clone.returns.class.type.display.name='clone()' should have return type equal to the class it contains
clone.returns.class.type.problem.descriptor=''clone()'' should have return type ''{0}'' #loc
clone.returns.class.type.quickfix=Change return type to ''{0}''
clone.returns.class.type.family.quickfix=Change return type to class type
use.of.clone.display.name=Use of 'clone()' or 'Cloneable'
use.of.clone.call.problem.descriptor=Call to <code>#ref()</code>
use.of.clone.call.method.problem.descriptor=Implementation of <code>#ref()</code>
use.of.clone.reference.problem.descriptor=Use of <code>#ref</code>
dangling.javadoc.display.name=Dangling Javadoc comment
dangling.javadoc.problem.descriptor=Dangling Javadoc comment #loc
dangling.javadoc.convert.quickfix=Replace with block comment
dangling.javadoc.delete.quickfix=Remove dangling comment
equals.replaceable.by.objects.call.display.name='equals()' expression replaceable by 'Objects.equals()' expression
equals.replaceable.by.objects.call.problem.descriptor=<code>#ref</code> replaceable by 'Objects.equals()' expression #loc
equals.replaceable.by.objects.checked.not.null.option=Highlight expressions like 'a != null \\&\\& a.equals(b)'
array.objects.equals.display.name='Objects.equals()' called on arrays
array.objects.equals.problem.descriptor=<code>Objects.#ref()</code> on arrays should probably be 'Arrays.equals()' #loc
array.objects.deep.equals.problem.descriptor=<code>Objects.#ref()</code> on arrays should probably be 'Arrays.deepEquals()' #loc
extends.throwable.display.name=Class directly extends 'java.lang.Throwable'
anonymous.extends.throwable.problem.descriptor=Anonymous class directly extends 'java.lang.Throwable' #loc
extends.throwable.problem.descriptor=class <code>#ref</code> directly extends 'java.lang.Throwable' #loc
lambda.parameter.naming.convention.display.name=Lambda parameter naming convention
lambda.parameter.naming.convention.element.description=Lambda parameter
assert.message.not.string.display.name='assert' message is not a String
assert.message.of.type.boolean.problem.descriptor=''assert'' message of type ''{0}'' #loc
assert.message.not.string.only.warn.boolean.option=Only warn when 'assert' message is 'boolean' or 'java.lang.Boolean'
suspicious.literal.underscore.display.name=Suspicious underscore in number literal
suspicious.literal.underscore.problem.descriptor=Group in number literal with underscores does not have length 3 #loc
unary.plus.quickfix=Remove unary '+'
super.tear.down.in.finally.display.name='super.tearDown()' not called from 'finally' block
super.tear.down.in.finally.problem.descriptor=<code>#ref()</code> not called from 'finally' block #loc
confusing.floating.point.literal.option=Ignore floating point literals in scientific notation
class.may.be.interface.java8.option=Report classes containing non-abstract methods when using Java 8
simplifiable.boolean.expression.display.name=Simplifiable boolean expression
unnecessary.initcause.display.name=Unnecessary call to 'Throwable.initCause()'
unnecessary.initcause.problem.descriptor=Unnecessary <code>Throwable.#ref()</code> call
unnecessary.initcause.quickfix=Remove 'Throwable.initCause()' call
consider.static.final.fields.constant.option=Consider 'static final' fields constant
atomic.field.updater.not.static.final.display.name=AtomicFieldUpdater field not declared 'static final'
atomic.field.updater.not.static.final.problem.descriptor={0} field <code>#ref</code> is not declared ''static final'' #loc
atomic.field.updater.issues.display.name=AtomicFieldUpdater issues
field.not.found.in.class.problem.descriptor=No field named ''{0}'' found in class ''{1}''
field.incorrect.type.problem.descriptor=Field ''{0}'' does not have type ''{1}''
field.missing.volatile.modifier.problem.descriptor=Field ''{0}'' does not have ''volatile'' modifier
field.has.static.modifier.problem.descriptor=Field ''{0}'' has ''static'' modifier
private.field.not.accessible.problem.descriptor=''private'' field ''{0}'' is not accessible from here
package.local.field.not.accessible=Package-private field ''{0}'' is not accessible from here
protected.field.not.accessible.problem.descriptor=''protected'' field ''{0}'' is not accessible from here
interface.clashes.with.object.class.display.name=Interface method clashes with method in 'java.lang.Object'
interface.clashes.with.object.class.problem.descriptor=<code>#ref()</code> clashes with method in 'java.lang.Object'
optional.used.as.field.or.parameter.type.display.name='Optional' used as field or parameter type
optional.used.as.field.type.problem.descriptor=<code>#ref</code> used as type for field ''{0}''
optional.used.as.parameter.type.problem.descriptor=<code>#ref</code> used as type for parameter ''{0}''
lambda.unfriendly.method.overload.display.name=Lambda-unfriendly method overload
lambda.unfriendly.method.overload.problem.descriptor=Lambda-unfriendly overload of method <code>#ref()</code>
lambda.unfriendly.constructor.overload.problem.descriptor=Lambda-unfriendly overload of constructor <code>#ref()</code>
optional.contains.collection.display.name='Optional' contains array or collection
optional.contains.collection.problem.descriptor='Optional' contains collection <code>#ref</code>
optional.contains.array.problem.descriptor='Optional' contains array <code>#ref</code>
synchronization.on.get.class.display.name=Synchronization on 'getClass()'
synchronization.on.get.class.problem.descriptor=Synchronization on <code>#ref()</code> #loc
object.instantiation.inside.equals.or.hashcode.display.name=Object instantiation inside 'equals()' or 'hashCode()'
object.instantiation.inside.equals.or.hashcode.problem.descriptor=Object instantiation inside ''{0}()'' #loc
object.instantiation.inside.equals.or.hashcode.problem.descriptor2=Object instantiation inside ''{0}()'' ({1})#loc
lambda.body.can.be.code.block.name=Lambda body can be code block
lambda.body.can.be.code.block.quickfix=Expand lambda body to {...}
lambda.parameter.type.can.be.specified.name=Lambda parameter type can be specified
lambda.parameter.type.can.be.specified.descriptor=Lambda parameter types can be expanded to {0}
lambda.parameter.type.can.be.specified.quickfix=Expand parameter types to {0}
lambda.parameter.type.can.be.specified.family.quickfix=Specify lambda parameter type
diamond.can.be.replaced.with.explicit.type.arguments.name=Diamond can be replaced with explicit type arguments
diamond.can.be.replaced.with.explicit.type.arguments.quickfix=Replace '<>' with explicit type arguments
lambda.can.be.replaced.with.anonymous.name=Lambda can be replaced with anonymous class
lambda.can.be.replaced.with.anonymous.quickfix=Replace lambda with anonymous class
method.ref.can.be.replaced.with.lambda.name=Method reference can be replaced with lambda
method.ref.can.be.replaced.with.lambda.quickfix=Replace method reference with lambda
try.statement.with.multiple.resources.name='try' statement with multiple resources can be split
try.statement.with.multiple.resources.quickfix=Split 'try' statement with multiple resources
multi.catch.can.be.split.name=Multi-catch can be split into separate catch blocks
multi.catch.can.be.split.quickfix=Split multi-catch into separate 'catch' blocks
assertion.can.be.if.name=Assertion can be replaced with if statement
assert.can.be.if.quickfix=Replace 'assert' with 'if' statement
if.can.be.assertion.name=Statement can be replaced with 'assert' or 'Objects.requireNonNull'
if.can.be.assertion.replace.with.assertion.quickfix=Replace statement with 'assert' statement
if.can.be.assertion.replace.with.objects.requirenonnull.quickfix=Replace statement with 'Objects.requireNonNull()'
single.statement.in.block.name=Code block contains single statement
single.statement.in.block.descriptor=''{0}'' contains single statement
single.statement.in.block.quickfix=Remove braces from ''{0}'' statement
single.statement.in.block.family.quickfix=Remove braces from statement
single.element.annotation.name=Single-element annotation
single.element.annotation.quickfix=Add 'value='
single.element.annotation.family.quickfix=Expand annotation to normal form
array.creation.without.new.keyword.name=Array creation without 'new' expression
array.creation.without.new.keyword.quickfix=Add ''new {0}''
array.creation.without.new.keyword.family.quickfix=Add 'new' expression
malformed.set.up.tear.down.display.name=Malformed 'setUp()' or 'tearDown()' method
malformed.set.up.tear.down.problem.descriptor='#ref()' has incorrect signature #loc
method.missing.return.statement.display.name=Method contains logic but is missing a 'return' statement
method.missing.return.statement.problem.descriptor=Method <code>#ref</code> contains logic but is missing a 'return' statement
overly.long.lambda.display.name=Overly long lambda expression
overly.long.lambda.problem.descriptor=Lambda expression is too long (# Non-comment source statements={0}) #loc
wait.notify.not.in.synchronized.context.display.name='wait()' or 'notify()' while not synchronized
wait.notify.while.not.synchronized.on.problem.descriptor=Call to <code>#ref</code> while not synchronized on ''{0}'' #loc
junit5.assertions.converter.display.name=Obsolete assertions in JUnit 5 tests
junit5.converter.display.name=JUnit 4 test can be JUnit 5
junit5.converter.fix.name=Migrate to JUnit 5
call.to.suspicious.string.method.display.name=Call to suspicious String method
call.to.suspicious.string.method.problem.descriptor=<code>String.#ref()</code> called in internationalized context #loc
unnecessary.string.escape.display.name=Unnecessarily escaped character
unnecessary.string.escape.problem.descriptor=<code>#ref</code> is unnecessarily escaped
unnecessary.string.escape.quickfix=Replace unnecessarily escaped chars with unescaped

array.can.be.replaced.with.enum.values=Array can be replaced with enum values
array.can.be.replaced.with.enum.values.quickfix=Replace array with {0}.values()
array.can.be.replaced.with.enum.values.family.quickfix=Replace array with EnumType.values()

string.concatenation.replace.fix=Replace with StringBuilder
string.concatenation.replace.fix.name=Convert variable ''{0}'' from String to {1}
string.concatenation.introduce.fix=Introduce StringBuilder
string.concatenation.introduce.fix.name=Introduce new {1} to update variable ''{0}''

ignored.class.names=Ignore classes (including subclasses)
junit5.platform.runner.display.name=@RunWith(JUnitPlatform.class) without test methods
meta.annotation.without.runtime.retention=Non-runtime annotation to be used by reflection
string.equals.char.sequence.display.name='String.equals()' called with 'CharSequence' argument
string.equals.char.sequence.problem.descriptor=<code>String.#ref()</code> called with ''{0}'' argument #loc
object.equals.can.be.equality.display.name='equals()' call can be replaced with '=='
object.equals.can.be.equality.problem.descriptor=<code>#ref()</code> can be replaced with '=='
not.object.equals.can.be.equality.problem.descriptor=<code>!#ref()</code> can be replaced with '!='
redundant.explicit.var.type.display.name=Local variable type can be omitted
variable.type.can.be.explicit.display.name=Variable type can be explicit
assignment.or.return.of.field.with.mutable.type.display.name=Assignment or return of field with mutable type
assignment.of.field.with.mutable.type.problem.descriptor=Assignment to{0}field ''{1}'' from parameter <code>#ref</code> #loc
return.of.field.with.mutable.type.problem.descriptor=Return of{0}field <code>{1}</code> #loc
ignore.private.methods.option=Ignore assignments in and returns from private methods

inspection.redundant.string.operation.display.name=Redundant String operation
inspection.redundant.string.remove.fix.name=Remove redundant ''{0}()'' call
inspection.redundant.string.fix.family.name=Remove redundant call
inspection.redundant.string.call.message=Call to <code>#ref</code> is redundant #loc
inspection.redundant.string.argument.message=Unnecessary empty string argument
inspection.redundant.string.remove.argument.fix.name=Remove argument
inspection.redundant.string.intern.on.constant.message=Call to <code>#ref</code> on compile-time constant is unnecessary #loc
inspection.redundant.string.constructor.message=<code>#ref</code> is redundant #loc
inspection.redundant.string.replace.with.arg.fix.name=Replace with argument
inspection.redundant.string.replace.with.empty.fix.name=Replace with empty string
inspection.redundant.string.option.do.not.report.string.constructors=Do not report String constructors
inspection.x.call.can.be.replaced.with.y=The ''{0}'' call can be replaced with ''{1}''

inspection.type.may.be.weakened.display.name=Type may be weakened
inspection.type.may.be.weakened.problem.descriptor=Type of variable <code>#ref</code> may be weakened to{0}#loc
inspection.type.may.be.weakened.method.problem.descriptor=Return type of method <code>#ref()</code> may be weakened to{0}#loc
inspection.type.may.be.weakened.parameter.problem.descriptor=Type of parameter <code>#ref</code> may be weakened to{0}#loc
inspection.type.may.be.weakened.field.problem.descriptor=Type of field <code>#ref</code> may be weakened to{0}#loc
inspection.type.may.be.weakened.quickfix=Weaken type to ''{0}''
inspection.type.may.be.weakened.ignore.option=Use &righthand type as weakest type in assignments
inspection.type.may.be.weakened.collection.method.option=Use &parameterized type of collection for method call arguments
inspection.type.may.be.weakened.do.not.weaken.to.object.option=Do not &weaken to 'java.lang.Object'
inspection.type.may.be.weakened.add.stopper=Add as stop class for weakening
inspection.type.may.be.weakened.add.stopper.single=Add{0}as stop class for weakening
inspection.type.may.be.weakened.only.weaken.to.an.interface=Only weaken to an interface
inspection.type.may.be.weakened.do.not.weaken.return.type=Do not weaken return type
inspection.type.may.be.weakened.add.stop.class.family=Add stopclass
inspection.type.may.be.weakened.weaken.type.family=Weaken type
inspection.type.may.be.weakened.add.stop.class.selection.table=Stop classes
inspection.type.may.be.weakened.add.stop.class.selection.popup=Select stop class
inspection.type.may.be.weakened.do.not.weaken.inferred.variable.type=Do not suggest weaken variable declared as 'var'

inspection.catch.ignores.exception.display.name=Catch block may ignore exception
inspection.catch.ignores.exception.option.comments=Do not warn when 'catch' block contains a comment
inspection.catch.ignores.exception.option.nonempty=Do not warn when 'catch' block is not empty
inspection.catch.ignores.exception.option.ignored.used=Do not warn when exception named 'ignore(d)' is not actually ignored
inspection.catch.ignores.exception.used.message='catch' parameter named <code>#ref</code> is used #loc
inspection.catch.ignores.exception.empty.message=Empty <code>#ref</code> block #loc
inspection.catch.ignores.exception.unused.message=Unused 'catch' parameter <code>#ref</code> #loc
inspection.catch.ignores.exception.vm.ignored.message=Some important exceptions might be ignored in a <code>#ref</code> block #loc

inspection.redundant.collection.operation.display.name=Redundant Collection operation
inspection.redundant.collection.operation.fix.family.name=Simplify collection operation
inspection.redundant.collection.operation.problem.arraycopy=Unnecessary collection created to copy an array
inspection.redundant.collection.removal.by.index.problem=Removal by index can be replaced with removal by object
inspection.redundant.collection.removal.by.index.fix=Use removal by object
inspection.redundant.collection.unnecessary.contains.problem=Unnecessary ''{0}'' check
inspection.redundant.collection.unnecessary.contains.fix=Remove the ''{0}'' check

comments.as.content.option=Comments count as content
copy.constructor.misses.field.display.name=Copy constructor misses field
copy.constructor.misses.field.problem.descriptor.1=Copy constructor does not copy field ''{0}''
copy.constructor.misses.field.problem.descriptor.2=Copy constructor does not copy fields ''{0}'' and ''{1}''
copy.constructor.misses.field.problem.descriptor.3=Copy constructor does not copy fields ''{0}'', ''{1}'' and ''{2}''
copy.constructor.misses.field.problem.descriptor.many=Copy constructor does not copy{0}fields

fix.add.argument.family.name=Add argument
fix.add.argument.name=Add ''{0}'' argument

inspection.constant.expression.display.name=Constant expression can be evaluated
inspection.constant.expression.message=Constant expression can be evaluated to ''{0}''
inspection.constant.expression.fix.name=Compute constant value of ''{0}''
inspection.constant.expression.fix.name.with.value=Replace ''{0}'' with constant value ''{1}''
inspection.constant.expression.fix.family.name=Compute constant value

inspection.redundant.compare.call.display.name=Redundant 'compare' method call
inspection.redundant.compare.call.fix.name=Inline 'compare' call

inspection.simplifiable.if.statement.display.name=If statement can be replaced with ?:, \\&\\&, ||, ==, or != expression
inspection.simplifiable.if.statement.message=If statement can be replaced with ''{0}''
inspection.simplifiable.if.statement.option.dont.warn.on.ternary=Don't suggest '?:' operator
inspection.simplifiable.if.statement.fix.name=Replace ''if else'' with ''{0}''
inspection.simplifiable.if.statement.fix.family.name=Replace ''if else'' with conditional expression

inspection.list.remove.in.loop.display.name='List.remove()' called in loop
inspection.list.remove.in.loop.message=Can be replaced with 'List.subList().clear()'

implicit.default.charset.usage.fix.family.name=Specify UTF-8 charset

inspection.redundant.class.call.display.name=Redundant 'isInstance' or 'cast' call
inspection.new.object.equality.display.name=New object is compared using '=='
inspection.new.object.equality.message=New object is compared using '#ref'
inspection.excessive.range.check.message=Can be replaced with ''{0}''
inspection.excessive.range.check.fix.family.name=Simplify excessive range check
suspicious.integer.div.assignment.problem.descriptor=Division result is truncated to integer
suspicious.integer.div.assignment.display.name=Suspicious integer division assignment
suspicious.integer.div.assignment.quickfix=Cast to double
inspection.if.statement.missing.break.in.loop.name=Loop can be terminated after condition is met
inspection.if.statement.missing.break.in.loop.quickfix=Add 'break'

inspection.case.mismatch.display.name=Mismatched case in String operation
inspection.case.mismatch.message=Method ''{0}()'' always returns {1}: the argument contains {2} symbol while the qualifier is {3}-only

inspection.suspicious.date.format.display.name=Suspicious date format pattern
inspection.suspicious.date.format.message.upper=Uppercase ''{0}'' ({1}) pattern is used: probably ''{2}'' ({3}) was intended
inspection.suspicious.date.format.message.lower=Lowercase ''{0}'' ({1}) pattern is used: probably ''{2}'' ({3}) was intended

fix.replace.map.with.flat.map.description='map()' can be replaced with 'flatMap()'

fix.eliminate.folded.if.present.name=Remove folded 'ifPresent' call
fix.eliminate.folded.if.present.description=Folded 'ifPresent' call can be eliminated

inspection.pattern.variable.can.be.used.display.name=Pattern variable can be used
inspection.pattern.variable.can.be.used.message=Variable ''{0}'' can be replaced with pattern variable
inspection.pattern.variable.can.be.used.fix.family.name=Replace with pattern variable
inspection.pattern.variable.can.be.used.fix.name=Replace ''{0}'' with pattern variable

array.hash.code.fix.family.name=Replace with implicit 'hashCode'
unqualified.static.access.fix.family.name=Qualify static access
replace.field.reference.fix.family.name=Replace Field Reference
replace.field.reference.fix.text=Replace field reference with {0}
replace.method.call.fix.family.name=Replace Method Call
replace.method.call.fix.text=Replace method call with {0}
delete.unnecessary.statement.fix.family.name=Remove redundant statement
increment.decrement.used.as.expression.fix.family.name=Extract to separate statement
use.of.properties.as.hashtable.fix.family.name=Fix property access
unnecessary.java.doc.link.fix.family.name=Remove redundant tag
swap.equals.fix.family.name=Flip method call
remove.modifier.fix.family.name=Remove modifier
shift.out.of.range.fix.family.name=Fix shift value
unnecessary.unicode.escape.fix.family.name=Replace with character
unnecessary.unicode.escape.fix.text=Replace with line feed character
absolute.alignment.in.user.interface.fix.family.name=Replace with constant
static.inheritance.fix.family.name=Replace inheritance with qualified reference
suspicious.to.array.call.fix.family.name=Replace with proper array
incorrect.date.format.fix.family.name=Fix incorrect date format
referencing.subclass.0.from.superclass.1.initializer.might.lead.to.class.loading.deadlock=Referencing subclass{0}from superclass {1} initializer might lead to class loading deadlock
collections.field.access.replaceable.by.method.call.fix.family.name=Replace Collections.EMPTY_* with call
delete.catch.section.fix.family.name=Delete catch statement
make.field.static.final.fix.family.name=Make static final
string.concatenation.in.format.call.fix.family.name=Replace concatenation with argument
implicit.array.to.string.fix.family.name=Make Array.toString() implicit
listener.may.use.adapter.fix.family.name=Replace with adapter
unnecessary.temporary.object.fix.family.name=Replace concatenation
make.public.static.fix.family.name=Make public/static
utility.class.with.public.constructor.fix.family.name=Make constructors private
change.modifier.fix.family.name=Change modifier
unnecessary.interface.modifiers.fix.family.name=Remove unnecessary modifiers
make.field.final.fix.family.name=Make final
generate.to.string.quick.fix.family.name=Generate
generate.to.string.quick.fix.text=Generate toString()
replace.instanceof.fix.family.name=Replace instanceOf type
replace.cast.fix.family.name=Replace cast type
make.package.private.fix.family.name=Make package-private
make.method.final.fix.family.name=Make method 'final'
replace.casted.literal.with.just.literal.fix.family.name=Replace with{0}literal
set.constructor.modifier.fix.family.name=Fix constructor modifier
char.used.in.arithmetic.content.cast.fix.family.name=Insert cast
ignore.parentheses.around.single.no.formal.type.lambda.parameter=Ignore parentheses around single no formal type lambda parameter
double.checked.locking.fix.family.name=Make field volatile
declare.collection.as.interface.fix.family.name=Weaken type
string.equals.empty.string.fix.family.name=Simplify empty string check
class.without.logger.annotations.tab=Annotations
class.without.logger.ignored.classes.tab=Ignored classes
class.without.logger.loggers.tab=Loggers
add.catch.section.fix.family.name=Add 'catch' clause
inspection.autocloseable.resource.ignored.methods.title=Ignore AutoCloseable instances returned from these methods
logger.initialized.with.foreign.class.fix.family.name=Replace foreign class
extend.exception.fix.family.name=Make class extend 'Exception'
inspection.use.of.private.field.inner.classes.option=Ignore accesses from inner classes
refused.bequest.fix.family.name=Insert call to super method
mark.modules.as.loaded.together.fix.family.name=Mark modules as loaded together
mark.modules.as.loaded.together.fix.text=Mark ''{0}'' and ''{1}'' modules as loaded together
inspection.suspicious.package.private.access.description={0} is {1}, but declared in a different module ''{2}''
ignore.class.fix.family.name=Ignore for these types
create.default.branch.fix.family.name=Insert 'default' branch
create.missing.switch.branches.fix.family.name=Create enum switch branches
unnecessary.fully.qualified.name.fix.family.name=Replace fully qualified name
return.of.collection.field.fix.family.name=Make return collection 'unmodifiable'
remove.redundant.substring.fix.family.name=Remove redundant 'substring()' call
remove.redundant.substring.fix.text=Use ''{0}'' and remove redundant ''substring()'' call
make.class.final.fix.family.name=Make class final
side.effects.method.ref.to.lambda.fix.family.name={0} (side effects)
encapsulate.variable.fix.family.name=Encapsulate field
method.may.be.static.replaces.qualifiers.with.class.references.option=Quick fix replaces instance qualifiers with class references
method.may.be.static.ignore.default.methods.option=Ignore 'default' methods
make.public.static.void.fix.family.name=Fix modifiers
convert.empty.anonymous.to.new.fix.family.name=Remove '{}'
replace.method.ref.with.qualifier.fix.family.name=Replace with qualifier
add.throws.clause.fix.family.name=Fix 'throws' clause
inspection.to.array.prefer.empty.array.title=Prefer empty array:
too.broad.scope.inspection.fix.family.name=Narrow scope
replace.with.cast.fix.family.name=Replace with cast
replace.anonymous.with.lambda.body.fix.family.name=Replace call with method body
replace.with.method.reference.fix.family.name=Replace method call on method reference with corresponding method call
replace.with.lambda.body.fix.family.name=Replace method call on lambda with lambda body
inspection.trivial.functional.expression.usage.description=Method call can be simplified
replace.with.var.fix.family.name=Replace explicit type with 'var'
inspection.redundant.explicit.variable.type.description=Explicit type of local variable can be omitted
add.read.write.object.methods.fix.family.name=Add 'readObject()' and 'writeObject()' methods which always throw exception
add.read.write.object.methods.fix.text=Add 'writeObject()' methods which always throws exception
add.read.write.object.methods.fix.text2=Add 'readObject()' method which always throws exception
replace.with.method.ref.fix.family.name=Replace lambda with method reference
qualify.call.fix.family.name=Qualify call
replace.with.comparator.fix.family.name=Simplify comparator using Comparator static methods
replace.with.comparator.fix.text=Replace with {0}
inspection.comparator.combinators.description=Can be replaced with Comparator chain
inspection.comparator.combinators.description2=Can be replaced with Comparator.{0}
inspection.unnecessary.string.escape.report.char.literals.option=Report char literals
inspection.method.call.in.loop.ignore.known.methods.option=Ignore known methods with side-effects
fix.data.provider.signature.family.name=Fix data provider signature
fix.data.provider.signature.text=Create @Parameterized.Parameters data provider
allow.suppressions.fix.family.name=Allow suppressions
allow.suppressions.fix.text=Allow these suppressions
remove.suppress.comment.fix.family.name=Remove //{0}
convert.to.j.unit.4.fix.family.name=Convert JUnit 3 class to JUnit 4
throws.runtime.exception.fix.family.name=Remove from 'throws' clause
move.exception.to.javadoc.fix.family.name=Move to Javadoc '@throws'
create.package.info.java.family.name=Create 'package-info.java'
remove.loop.fix.family.name=Remove loop
remove.call.fix.family.name=Remove call
inspection.meta.annotation.without.runtime.description={0} should have @Retention(RetentionPolicy.RUNTIME)
inspection.refused.bequest.super.annotated.option=Only report when super method is annotated by:
inspection.empty.class.ignore.subclasses.option=Ignore subclasses of {0}
inspection.test.method.without.assertions.exceptions.option=Ignore test methods which declare exceptions
inspection.collection.must.have.initial.capacity.initializers.option=Don't report field initializers
utility.class.without.private.constructor.cant.generate.constructor.title=Can't Generate Constructor
utility.class.without.private.constructor.cant.generate.constructor.message=Utility class has instantiations, private constructor will not be created
inspection.suspicious.package.private.access.problem={0} overrides a package-private method from {1} which is declared in a different module ''{2}''
inspection.condition.covered.by.further.condition.descr=Condition ''{0}'' covered by subsequent {1, choice, 1#condition ''''{2}''''|2#conditions}
inspection.parameterized.parameters.static.collection.display.name=@RunWith(Parameterized.class) without data provider
