0.1.be.lifted.out.of.2=Elimine {0} de ''{2}''{1}.
0.1.could.be.private={0} ''{1}'' puede ser privado.
0.1.is.never.used={0} ''{1}'' nunca se utiliza.
0.already.exists={0} ya existe
0.always.returns.non.null.type=''{0}'' siempre devuelve un tipo no nulo
0.call.could.be.simplified.to.1=La llamada {0} se puede simplificar a {1}.
0.call.should.be.replaced.with.array.literal=La llamada a ''{0}'' debe reemplazarse con un literal de matriz [...].
0.from.1={0} de {1}
0.has.detected.1.code.fragments.in.2.that.can.be.replaced.with.3={0} detectó {1} código {1,choice,1\#piece|2\#piece} en {2} que puede reemplazarse por {3}. ¿Le gustaría revisar y cambiar {1,choice,1\#code snippet|2\#code snippet}?
0.has.empty.body=El cuerpo de ''{0}'' está vacío.
0.in.1.will.require.class.instance=''{0}'' en {1} requiere una instancia de clase
0.interface.1=La interfaz ''{1}'' es {0}.
0.is.always.non.null.type=''{0}'' siempre es de tipo no nulo
0.is.expected.to.be.used.since.kotlin.1.3=''{0}'' se utilizará a partir de Kotlin 1.3
0.is.missing.documentation=A {0} le falta un documento.
0.is.overridden.by.declaration.s.in.a.subclass={0} se redefine como una declaración en una subclase
0.may.break.code={0} (puede romper tu código)
0.on.a.readonly.1.creates.a.new.1.under.the.hood=''{0}'' en {1} de solo lectura crea un nuevo {1} internamente
0.references.type.parameters.of.the.containing.class={0} parámetro de tipo de referencia de la clase contenida
0.should.return.unit={0} debe devolver la unidad.
0.try.1.with.2.fails.and.3.verifications={0} [{2} falló en {1} intentos, verificado {3} veces]
0.will.become.invisible.after.extraction={0} se volverá invisible después de la extracción.
0.will.no.longer.be.accessible.after.extraction={0} quedará inaccesible después de la extracción.
a.constructor.call.is.not.yet.supported=Las llamadas al constructor aún no son compatibles
a.field.without.an.initializer.is.not.yet.supported=Los campos sin inicializadores aún no son compatibles
accessing.non.final.property.0.in.constructor=Accediendo a la propiedad no final {0} en el constructor
action.CacheResetOnProcessCanceledToggleAction.text=Restablecer caché para ProcessCanceledException
action.CheckComponentsUsageSearchAction.text=Confirmar la búsqueda de ubicación de uso de la función del componente
action.ConfigureKotlinInProject.text=Configurar Kotlin en el proyecto
action.ConvertJavaToKotlin.text=Convierta archivos Java a archivos Kotlin
action.CopyAsDiagnosticTest.text=Copiar el archivo actual como prueba de diagnóstico
action.CopyKotlinProjectInformation.text=Copiar el esquema del proyecto de Kotlin al portapapeles
action.DecompileKotlinToJava.text=Descompilar Kotlin en Java
action.DumbModeTremble.text=Temblar modo tonto
action.ExtractFunction.text=_Función…
action.ExtractFunctionToScope.text=Función al rango (_S)…
action.FindImplicitNothingAction.text=Encuentra llamadas nada implícitas
action.GotoSuperClass.MainMenu.text=Clase principal (_U)
action.GotoSuperClass.text=Ir a la clase principal (_U)
action.GotoSuperInterface.MainMenu.text=Interfaz principal (_U)
action.GotoSuperInterface.text=Ir a la interfaz principal (U_)
action.GotoSuperProperty.MainMenu.text=Propiedad principal (_U)
action.GotoSuperProperty.description=Ir a la declaración de una propiedad que la propiedad actual anula o implementa
action.GotoSuperProperty.text=Mover a propiedad principal (_U)
action.HighlightingBenchmarkAction.text=Resaltado de puntos de referencia
action.InspectBreakpointApplicability.text=Comprobación de la aplicabilidad del punto de interrupción
action.IntroduceProperty.text=_Propiedad…
action.IntroduceTypeAlias.text=Escriba alias (_A)…
action.IntroduceTypeParameter.text=Parámetro de _tipo…
action.Kotlin.ClearScratch.description=Eliminación de arañazos de Kotlin
action.Kotlin.ClearScratch.text=Eliminación de arañazos de Kotlin
action.Kotlin.Gradle.ShowDslLogs.text=Mostrar registros DSL de Kotlin Gradle
action.Kotlin.NewFile.description=Crea una nueva clase o archivo Kotlin
action.Kotlin.NewFile.text=Clase/archivo de Kotlin
action.Kotlin.NewScript.description=Cree un nuevo script u hoja de trabajo de Kotlin
action.Kotlin.NewScript.text=Secuencia de comandos Kotlin
action.Kotlin.RunScratch.description=Ejecutando Kotlin Scratch
action.Kotlin.RunScratch.text=Ejecutando Kotlin Scratch
action.Kotlin.StopScratch.description=Detener la ejecución de Scratch
action.Kotlin.StopScratch.text=Detener la ejecución de Scratch
action.Kotlin.XDebugger.CoroutinesDump.text=Obtener volcado de rutina
action.Kotlin.XDebugger.ToggleKotlinVariableView.text=Mostrar solo variables de Kotlin
action.KotlinCodeMigration.text=Ejecutar la migración de código
action.KotlinCodeMigrationToggle.text=Habilitar la detección de migración(experimental)
action.KotlinConfigurePlugin.text=Configuración del complemento Kotlin
action.KotlinConsoleREPL.text=REPL de Kotlin
action.KotlinFormattingSettingsStatusAction.text=Acerca de la configuración de la herramienta de formato
action.KotlinGenerateDataMethod.text=Función de parámetro
action.KotlinGenerateEqualsAndHashCode.text=Es igual a() y hashCode()
action.KotlinGenerateMavenCompileExecutionAction.text=Ejecutando la compilación de Kotlin
action.KotlinGenerateMavenPluginAction.text=Complemento de Kotlin
action.KotlinGenerateMavenTestCompileExecutionAction.text=Ejecute la compilación de prueba de Kotlin
action.KotlinGenerateSecondaryConstructor.text=Constructor secundario
action.KotlinGenerateSetUpMethod.text=Función de configuración
action.KotlinGenerateTearDownMethod.text=Función de desmontaje
action.KotlinGenerateTestMethod.text=Función de prueba
action.KotlinGenerateToString.text=Encadenar()
action.KotlinShellExecute.description=Ejecute el código Kotlin en la consola
action.KotlinShellExecute.text=Ejecutando código Kotlin
action.KotlinThrowException.text=Eliminar errores en los complementos de Kotlin
action.LibraryToSourceDependencySupportToggleAction.text=Cambiar la biblioteca al soporte de dependencia de origen
action.LocalCompletionBenchmarkAction.text=Escenario local
action.PrintOutNotPropertyMatches.text=Búsqueda de candidatos no inmobiliarios
action.ShowKotlinBytecode.text=Visualización del código de bytes de Kotlin
action.StoredExceptionsThrowToggleAction.text=Lanzamiento de PCE en caché
action.TestMoveRefactiringAction.text=Probar Go Refactoring en un proyecto abierto
action.TopLevelCompletionBenchmarkAction.text=Escenario superior
action.add.import.chooser.title=Importar
action.generate.equals.choose.equals=Seleccionar propiedades para incluir en' 'equals ()'
action.generate.equals.choose.hashcode=Seleccionar propiedades para incluir en' 'hashCode ()'
action.generate.functions.already.defined=La función {0} ya está definida para la clase {1}. ¿Está seguro de que desea eliminar esa función y continuar?
action.generate.secondary.constructor.choose.properties=Seleccionar propiedades para inicializar con el constructor
action.generate.secondary.constructor.error.already.exists=El constructor ya existe.
action.generate.super.type=Especificar el supertipo explícitamente
action.generate.test.support.choose.framework=Elija un marco
action.generate.test.support.choose.test.name=Elija el nombre de la prueba\:
action.generate.test.support.edit.template=Editar plantilla
action.generate.test.support.error.cant.convert.java.template=No se pudo convertir la plantilla Java a Kotlin.
action.generate.test.support.error.cant.generate.method=No se pudo crear el método {0}.
action.generate.test.support.error.no.template.found=No se pudo encontrar la plantilla para {0}. {1}
action.generate.tostring.choose.implementation=Elija implementación\:
action.generate.tostring.choose.implementation.mnemonic=I
action.generate.tostring.generate.super.call=Generar llamada a super.toString()
action.generate.tostring.generate.super.call.mnemonic=S
action.generate.tostring.name=Crear toString()
action.generate.tostring.template.multiple=Varias plantillas con conexiones
action.generate.tostring.template.single=Plantilla única
action.hints.settings.text=Configuración de sugerencias...
action.j2k.correction.errors.multiple=''{0}'' y {1} otros archivos Java contienen errores de sintaxis, que pueden resultar en conversiones incorrectas.
action.j2k.correction.errors.single=''{0}'' contiene un error de sintaxis, que puede dar como resultado resultados de conversión incorrectos.
action.j2k.correction.investigate=Investigar errores
action.j2k.correction.proceed=Conversión en curso
action.j2k.correction.required=Esta transformación puede requerir que corrija algo de código en el resto de su proyecto. ¿Le gustaría encontrar el código y arreglarlo juntos?
action.j2k.error.cant.find.document=No se encontró documentación para ''{0}''.
action.j2k.error.cant.save.result=No se pudo guardar el resultado de la conversión {0}.
action.j2k.error.nothing.to.convert=No hay nada que convertir.<br>No se encontraron archivos Java grabables
action.j2k.error.read.only=El archivo ''{0}'' es de solo lectura
action.j2k.name=Convertir Java a Kotlin
action.j2k.task.name=Convertir archivo de Java a Kotlin
action.move.method=Ir al método...
action.new.file.dialog.annotation.title=Anotación
action.new.file.dialog.class.title=Clase
action.new.file.dialog.data.class.title=Clase de datos
action.new.file.dialog.enum.title=Clase Enum
action.new.file.dialog.file.title=Archivo
action.new.file.dialog.interface.title=Interfaz
action.new.file.dialog.object.title=Objeto
action.new.file.dialog.sealed.class.title=Clase sellada
action.new.file.dialog.sealed.interface.title=Interfaz sellada
action.new.file.dialog.title=Nuevas clases/archivo Kotlin
action.new.file.error.empty.name=Debe tener un nombre.
action.new.file.error.empty.name.part=El nombre no debe contener espacios en blanco.
action.new.script.dialog.title=Nuevo script de Kotlin
action.new.script.name=Guión de Kotlin
action.new.worksheet.name=Hoja de trabajo de Kotlin
action.text.append=Añadir
action.text.cancel=Cancelar
action.text.install=Instalación
action.text.overwrite=Sobrescribir
action.usage.update.command=Actualizar dónde usar
add.0.constructor.to.1=Agregue el constructor {0} a ''{1}''.
add.0.to.argument=Agregue ''{0} \='' al argumento
add.0.to.module.1.compiler.arguments=Agregue ''{0}'' a los argumentos del compilador del módulo {1}.
add.an.opt.in.requirement.marker.compiler.argument=Agregue argumentos opcionales del compilador de marcadores de requisitos.
add.braces=Agregar llaves
add.braces.to.0.statement=Agregue llaves a la declaración ''{0}''.
add.braces.to.all.branches=Agregue llaves a todas las ramas
add.braces.to.if.all.statements=Agregue llaves a todas las declaraciones 'si'
add.braces.to.when.all.entries=Agregue llaves a todos los elementos 'cuándo'
add.braces.to.when.entry=Añadir llaves a la entrada ''cuándo''
add.call.or.unwrap.type.fix.text=Agregue ''.{0}()'' al resultado de la función (sitios de uso separados).
add.call.or.unwrap.type.fix.text1=Desenvuelva el tipo de devolución ''{0}'' (sitios de uso separados).
add.constructor.keyword=Agregue la palabra clave ''constructor''.
add.constructor.parameters.from.0.1=Agregue los parámetros del constructor de {0}{1}.
add.constructor.parameters.from.superclass=Agregue parámetros de constructor para la clase principal.
add.documentation.fix.text=Añade un documento.
add.empty.argument.list=Agregar lista de argumentos vacía
add.empty.brackets.after.primary.constructor=Agregue corchetes vacíos después del constructor predeterminado.
add.explicit.parameter.to.outer.lambda.fix.text=Agregue nombres de parámetros explícitos a la lambda externa.
add.explicit.type.arguments=Agregar argumentos de tipo explícito
add.external.keyword=Agregar palabra clave externa
add.full.qualifier=Agregar calificador completo
add.fun.modifier.to.0=Agregue un controlador ''divertido'' a ''{0}''
add.import.for.0=Agregar declaración de importación de ''{0}''
add.import.for.member=Agregar declaración de importación de miembros
add.indices.to.for.loop=Agregar índice al bucle ''for''
add.initializer=Agregue un inicializador.
add.jvminline.annotation=Agregar la anotación '@JvmInline'
add.jvmoverloads.annotation=Agregar la anotación ''@JvmOverloads''
add.jvmoverloads.annotation.to.0=Agregue la anotación ''@JvmOverloads'' a {0}
add.jvmstatic.annotation=Agregar la anotación ''@JvmStatic''
add.labeled.return.to.last.expression.in.a.lambda=Eliminar el retorno etiquetado de la última expresión dentro de lambda
add.method=Agregar método
add.method.0.to.1=Agregue el método ''{0}'' a ''{1}''.
add.missing.class.keyword=Agregar la palabra clave "clase" que falta
add.missing.component=Agregar componentes faltantes
add.modifier=Agregar controlador
add.name.to.argument=Agregar nombre al argumento
add.names.in.comment.to.call.arguments=Llame a argumentos agregando sus nombres en los comentarios.
add.names.to.call.arguments=Agregar nombre al argumento de llamada
add.names.to.this.argument.and.following.arguments=Agregar nombre a este argumento y al siguiente argumento
add.operator.modifier=Agregue el controlador ''operador''.
add.remaining.branches=Agrega las ramas restantes.
add.replacewith.argument.to.specify.replacement.pattern=Agregue el argumento ''replaceWith'' para especificar el patrón de reemplazo.
add.return.at.0=Añadir retorno@{0}
add.return.expression=Agregar una expresión de 'retorno'
add.source.retention=Agregue un elemento de archivo de origen.
add.throws.annotation=Agregar la anotación ''@Throws''
add.underscores=Añadir subrayado
add.use.site.target=Agregar destino del sitio de uso
add.val.to.parameter.0=Agregue ''val'' al parámetro ''{0}''
add.val.var.to.parameter.0=Agregue val/var al parámetro ''{0}''
add.val.var.to.primary.constructor.parameter=Agregue val/var a los parámetros predeterminados del constructor
add.variance.fix.family.name=Agregar variación
add.variance.fix.text=Agregue la variación ''{0}''.
advanced.setting.kotlin.mpp.experimental=Multiplataforma experimental
advanced.setting.kotlin.mpp.experimental.description=Habilita funciones IDE multiplataforma experimentales
all.expected.and.actual.classes.must.be.sealed.classes=Todas las clases previstas y reales deben ser clases selladas.\n
all.inheritors.must.be.nested.objects.of.the.class.itself.and.may.not.inherit.from.other.classes.or.interfaces=Todos los herederos deben ser objetos anidados de la propia clase y no deben heredar de otras clases o interfaces.\n
ambiguous.coroutinecontext.due.to.coroutinescope.receiver.of.suspend.function=CoroutineContext oscurecido por el receptor CoroutineScope en función de suspensión
ambiguous.non.local.break.or.continue=''{0}'' ambiguo, no local (''{1}'' frente a ''{2}''). Utilice una etiqueta claramente distintiva o agregue un contrato ''callsInPlace''.
ambiguous.non.local.break.or.continue.display.name='romper' o 'continuar' ambiguo no local
analyzed.0.classes.no.difference.found=Se analizaron {0} clases, pero no se encontraron diferencias.
analyzing.functions=Analizando la función...
analyzing.members=Analizando miembros...
and.delete.initializer=Eliminar \ e inicializador
apply.also.to.internal.members=También se aplica a los miembros internos.
apply.also.to.private.members=También se aplica a miembros privados.
apply.in.the.project.0=Aplicar desde el proyecto\: {0}
apply.only.to.public.or.protected.members=Se aplica sólo a miembros públicos o protegidos.
applying.0=Aplicar ''{0}''
array.property.in.data.class.it.s.recommended.to.override.equals.hashcode=Se recomienda anular las propiedades de la matriz \: equals()/hashCode() de la clase de datos.
assert.should.be.replaced.with.operator=Las afirmaciones deben ser reemplazadas por operadores.
assign.backing.field.fix.text=Sustituya el campo de respaldo.
base.property.0=Propiedades básicas {0}
block.body=Cuerpo del bloque
boolean.literal.argument.without.parameter.name=Argumento literal booleano sin nombre de parámetro
boolean.property.in.external.interface.should.be.nullable=Las propiedades booleanas dentro de interfaces externas deben ser anulables
breadcrumbs.tooltip.indexing=Indexación…
button.add.package=Agregar paquete
button.rename.base=Cambiar nombre base
button.rename.current=Cambiar el nombre del elemento actual
button.text.move.nested.class.0.to.another.class=Mover la clase anidada {0} a otra clase
button.text.move.nested.class.0.to.upper.level=Mover la clase anidada {0} a un nivel superior
call.chain.length.to.transform=Longitud de la cadena de llamadas para convertir\:
call.chain.on.collection.could.be.converted.into.sequence.to.improve.performance=Para mejorar el rendimiento, puede convertir la cadena de llamadas de una colección en una "Secuencia".
call.chain.on.collection.type.may.be.simplified=Puede simplificar la cadena de llamadas para los tipos de cobranza.
call.is.replaceable.with.another.scope.function=Puede reemplazar la llamada con otra función de ámbito.
call.of.inline.function.with.nullable.extension.receiver.can.cause.npe.in.kotlin.1.2=En Kotlin 1.2 y versiones anteriores, llamar a 'diversión en línea' con un receptor que acepta valores NULL puede resultar en 'NPE'
call.of.java.mutator.0.on.immutable.kotlin.collection.1=Invocación del modificador de Java ''{0}'' en la colección Kotlin inmutable ''{1}''
call.on.collection.type.may.be.reduced=Esto puede reducir las llamadas a tipos de cobranza.
call.on.not.null.type.may.be.reduced=Esto puede reducir las llamadas a tipos no nulos.
call.replaceable.with.binary.operator=Llamadas que pueden ser reemplazadas por operadores binarios
call.with.arguments.will.be.skipped.0=Saltar llamadas con argumentos. {0}
callable.reference.fix.family.name=Agregar ''{0}'' explícito
callable.reference.transformation.is.not.supported.0=No se admite la conversión de referencias invocables. {0}
calling.non.final.function.0.in.constructor=Llamar a la función no final {0} en el constructor
calls.with.explicit.extension.receiver.won.t.be.processed.0=Las llamadas con receptores extendidos explícitos no se procesan. {0}
can.be.converted.to.to=Se puede convertir a ''a''.
can.be.joined.with.assignment=Se puede combinar con la tarea.
can.convert.argument.to.set=Los argumentos se pueden convertir a 'Establecer' para un mejor rendimiento.
can.t.finish.while.indexing.is.in.progress=No se puede completar mientras la indexación está en curso.
can.t.modify.0={0} no se puede modificar
can.t.replace.foreign.reference.with.call.expression.0=No puede reemplazar una referencia externa con una expresión de llamada. {0}
can.t.replace.non.kotlin.reference.with.call.expression.0=Las referencias que no son de Kotlin no se pueden reemplazar con expresiones de invocación. {0}
cannot.extract.super.call=No se puede extraer la llamada de los padres.
cannot.get.or.create.results.file=No se puede importar o generar el archivo de resultados
cannot.get.project.root.directory=No se puede obtener el directorio raíz del proyecto
cannot.infer.type.for.this.declaration=No se puede inferir el tipo de esta declaración.
cannot.inline.property.with.accessor.s.and.backing.field=Las propiedades con descriptores de acceso y campos de respaldo no se pueden insertar en línea.
cannot.introduce.parameter.of.0.type=No se puede insertar un parámetro de tipo ''{0}''.
cannot.refactor.expression.has.unit.type=No se puede insertar una expresión de tipo unidad.
cannot.refactor.no.container=La refactorización no es posible aquí.
cannot.refactor.no.expression=La refactorización no se puede realizar sin expresiones.
cannot.refactor.no.type=La refactorización no se puede realizar sin tipos.
cannot.refactor.not.expression=No se pudo encontrar la expresión a insertar.
cannot.refactor.package.expression=No se puede insertar la referencia del paquete.
cannot.refactor.syntax.errors=La refactorización no es posible debido a un código incorrecto.
cannot.refactor.synthesized.function=No se puede refactorizar la función de unión ''{0}''.
cascade.if.should.be.replaced.with.when=Cascada If debe reemplazarse por cuándo.
cast.explicitly.fix.text=Transmitir explícitamente.
category.class=Kotlin/basado en clases
category.comments=Kotlin/anotaciones, KDoc y metadatos
category.declaration=Kotlin/Declaración
category.expressions=Kotlin/Expresiones
category.interesting=Kotlin/Interés
category.operators=Kotlin/Operadores
change.all.usages.of.0.in.this.file.to.1=Cambie todas las apariciones de ''{0}'' en este archivo a ''{1}''.
change.all.usages.of.0.in.this.file.to.a.kotlin.class=Cambie todos los usos de ''{0}'' en este archivo a clases de Kotlin.
change.existent.retention.to.source=Cambia un archivo existente a una fuente.
change.main.function.return.type.to.unit.fix.text=Agregue un tipo de devolución de Unidad explícito.
change.main.function.return.type.to.unit.fix.text2=Cambie el tipo de devolución a Unidad.
change.signature.conflict.text.kotlin.default.parameter.in.non.kotlin.files=Es posible que los parámetros predeterminados no sean compatibles con otros idiomas
change.signature.conflict.text.kotlin.default.value.in.non.kotlin.files=Los valores de llamada predeterminados de Kotlin pueden generar código incorrecto en otros idiomas
change.to.0=Cambie a ''{0}''.
change.to.constructor.invocation=Cambie a una llamada al constructor.
change.to.correct.long.suffix.l=Cambie al sufijo largo correcto ''L''.
change.to.correct.primitive.type=Cambie al tipo predeterminado correcto.
change.to.kotlin.class=Cambie a la clase Kotlin.
change.to.val=Cambiar a valor.
change.to.var=Cambiar a var.
change.type.of.0.to.1=Cambie el tipo de {0} a ''{1}''.
change.type.to.0=Cambiar tipo a ''{0}''
change.type.to.mutable.fix.text=Cambie el tipo a Variable.
change.visibility.modifier=Cambiar controlador de visibilidad
checkbox.text.declare.with.var=&Declarar con var
checkbox.text.delete.empty.source.files=&Eliminar archivos fuente vacíos
checkbox.text.extension.property=Propiedades e&xtendidas\:
checkbox.text.introduce.default.value=Insertar valor predeterminado
checkbox.text.open.moved.files.in.editor=Abrir miembro movido en el editor
checkbox.text.replace.all.occurrences.0=Reemplazar todos los usos ({0})
checkbox.text.search.references=&Recuperar referencia
checkbox.text.specify.type.explicitly=Especificar el tipo explícitamente
checkbox.text.update.package.directive=Actualizar directivas de paquetes (archivos Kotlin)
checking.data.class.0.of.1=Comprobando la clase de datos {0}/{1}....
checking.data.classes=Comprobar clase de datos
choose.actual.members.title=Seleccionar miembros reales
choose.an.appropriate.kotlin.class=Seleccione la clase de Kotlin adecuada.
choose.class.container=Seleccione el contenedor de clase.
choose.target.class.or.interface=Seleccione la clase o interfaz de destino.
class=Clase
class.0.already.contains.1=La clase ''{0}'' ya contiene {1}
class.name.prompt=Nombre de clase (&N)\:
class.should.be.external.interface=La clase debe ser una interfaz externa.
clipboard.content.copied.from.java.file.do.you.want.to.convert.it.to.kotlin.code=El contenido del portapapeles se copió de un archivo Java. ¿Le gustaría convertir a código Kotlin?
code.insight.workspace.settings.title=Kotlin
codestyle.layout.import.aliases.separately=Importar alias individualmente
codestyle.name.kotlin=Kotlin
column.name.default.parameter=Parámetros predeterminados:
column.name.receiver=Receptor\:
column.name.val.var=Val/Var
command.generate.test.support.generate.test.function=Crear función de prueba
command.move.declarations=Movimiento de declaración
comment=Comentario
companion.object.already.contains.0=El objeto complementario ya contiene {0}
compiling.project=Compilando proyecto...
condition.is.always.0=La condición es siempre ''{0}''.
configuration.kotlin.code.style.group.name=Estilo de código oficial de Kotlin disponible
configuration.maven.group.name=Importar proyecto Kotlin Maven
configuration.message.enter.fully.qualified.method.name=Ingrese el nombre completo del método\:
configuration.migration.group.name=Kotlin: Es posible la migración a una nueva versión
configuration.name.method=Método
configuration.status.text.installing=Instalación...
configuration.title.add.exclusion=Agregar exclusión
configuration.title.edit.exclusion=Editar excluir
const.might.be.used.instead.of.jvmfield=Puede utilizar ''const'' en lugar de ''@JvmField''.
const.property=Propiedad constante
constructor=Constructor
constructor.has.non.null.self.reference.parameter=El constructor tiene un parámetro de autorreferencia no nulo.
constructor.parameter.is.never.used.as.a.property=Los parámetros del constructor no se utilizan como propiedades.
context.default=Por defecto
context.property.getter.or.setter=Propiedades con captadores/definidores explícitos
convert.0.to.1=Convertir ''{0}'' a ''{1}''
convert.anonymous.function.to.lambda.expression=Convertir función anónima a expresión lambda
convert.argument.to.set.fix.text=Convertir argumento a 'Establecer'
convert.body.to.expression=Convertir cuerpo en expresión
convert.boolean.const.to.elvis=¿Booleano? \=\= Convertir constante a elvis
convert.call.chain.into.sequence.fix.text=Convierta la cadena de llamadas a ''Secuencia''.
convert.class.0.to.kotlin=Convertir la clase ''{0}'' a Kotlin
convert.collection.constructor.to.function=Convertir el constructor de la colección en función
convert.concatenation.to.build.string=Convertir la conexión a la llamada 'buildString'
convert.concatenation.to.raw.string=Convertir concatenación a cadena sin formato
convert.concatenation.to.template=Convertir una conexión en una plantilla
convert.concatenation.to.template.before.text=Una concatenación de 'cadena' se puede convertir en una plantilla
convert.expression.to.0=Convierte la expresión a ''{0}''.
convert.expression.to.0.by.inserting.1=Convierte la expresión a ''{0}'' insertando ''.{1}''.
convert.extension.function.type.to.regular.function.type=Convierte un tipo de función extendida en un tipo de función normal.
convert.extension.property.initializer.to.getter=Convierte un inicializador de propiedad de extensión en un captador.
convert.from.class.to.kclass=Convertir 'KClass' en 'Clase'
convert.function.to.property=Convertir función en propiedad
convert.function.type.parameter.to.receiver=Convertir parámetro de tipo de función a receptor
convert.function.type.receiver.to.parameter=Convertir receptor de tipo de función a parámetro
convert.lambda.expression.to.anonymous.function=Convertir expresión lambda en función anónima
convert.lambda.to.reference=Convertir lambda a referencia
convert.lambda.to.reference.before.text=Lambda se puede convertir a referencia
convert.left.hand.side.to.0=Convertir izquierda a ''{0}''
convert.member.to.extension=Convierte un miembro en una extensión.
convert.na.n.equality.quick.fix.text=Reemplazar con ''isNaN()'
convert.object.literal.to.class=Convertir objeto literal a clase
convert.object.literal.to.lambda=Convertir objeto literal a lambda
convert.pair.constructor.to.to.fix.text=Se convierte a ''a''.
convert.parameter.to.receiver=Convertir parámetro a receptor
convert.property.getter.to.initializer=Convertir captador de propiedad en inicializador
convert.property.initializer.to.getter=Convertir el inicializador de propiedad en captador
convert.property.to.function=Convertir propiedades en funciones
convert.put.to.assignment=Convierte la tarea asignada.
convert.receiver.to.parameter=Convertir receptor a parámetro
convert.reference.to.lambda=Convertir referencia a lambda
convert.reference.to.lambda.before.text=Puedes convertir una referencia a una lambda.
convert.right.hand.side.to.0=Convertir a la derecha a ''{0}''
convert.scope.function.fix.family.name=Convertir a ''{0}''
convert.sealed.subclass.to.object.fix.family.name=Convertir subclase sellada en objeto
convert.string.template.to.build.string=Se convierte en una llamada a 'buildString'
convert.string.to.character.literal=Convertir cadena a carácter literal
convert.supertype.to.0=Convierta el tipo principal a ''{0}''.
convert.template.to.concatenated.string=Convertir plantilla en cadena concatenada
convert.to.0=Convertir a {0}.
convert.to.0.as.1=Convertir ''{1} a {0}''
convert.to.0.unsafecast.1=Convertir a ''{0}.unsafeCast<{1}>()''
convert.to.a.range.check=Lo convierte en una verificación de rango.
convert.to.anonymous.function=Convertir a función anónima
convert.to.anonymous.object=Conviértelo en un objeto anónimo.
convert.to.array.parameter=Convertir a parámetro de matriz
convert.to.assignment.expression=Convertir asignación en expresión de asignación
convert.to.block.body=Convertir a cuerpo de bloque
convert.to.comparisons=Convertir para comparar
convert.to.concatenated.string.statement.analyzing.entry.type=Analizando tipo de elemento...
convert.to.data.object=Convertir a 'objeto de datos' (el significado puede cambiar)
convert.to.enum.class=Convertir a clase de enumeración
convert.to.expression.body.fix.text=Convertir al cuerpo de expresión.
convert.to.indexed.function.call=Convertir a llamada de función indexada
convert.to.lambda=Convertir a lambda
convert.to.lambda.expression=Convertir a expresión lambda
convert.to.lateinit.var=Convertir a lateinit var
convert.to.lazy.property=Convertir en propiedad perezosa
convert.to.notnull.delegate=Se convierte en delegado no nulo.
convert.to.nullable.type=Convertir a tipo anulable.
convert.to.nullable.type.fix.text=Convertir a un tipo que acepta valores NULL.
convert.to.nullable.var=Convertir a var anulable
convert.to.object.declaration=Convertir a declaración de objeto
convert.to.ordinary.property=Convertir a propiedad regular
convert.to.ordinary.string.literal=Convertir a literal de cadena simple
convert.to.primary.constructor=Convertir al constructor predeterminado
convert.to.primary.constructor.before.text=El constructor secundario debe convertirse en constructor primario.
convert.to.raw.string.literal=Convertir a literal de cadena sin formato
convert.to.sealed.class=Convertir a clase sellada
convert.to.secondary.constructor=Convertir a constructor auxiliar
convert.to.trim.indent=Se convierte en una llamada a 'trimIndent()'
convert.to.trim.margin=Se convierte en una llamada a 'trimMargin()'
convert.to.unicode.escape=Convertir a escape Nicode
convert.to.unsafe.cast=Conversión a transmisión insegura
convert.to.unsafecast.call=Convertir a llamada unsafeCast()
convert.to.vararg.parameter=Convertir al parámetro vararg
convert.too.long.character.literal.to.string=Convierta literales de caracteres demasiado largos en cadenas.
convert.try.finally.to.use=Convertir try-finally a .use()
convert.try.finally.to.use.before.text=Puedes reemplazar try-finally con 'use()'
copy.concatenation.text.to.clipboard=Copie el texto de la conexión al portapapeles.
copy.method.of.data.class.is.called.without.named.arguments=El método ''copia'' de la clase de datos se llama sin argumentos con nombre.
copy.paste.reference.notification=Se agregaron {0} {0, choice,1\#import statement|2\#import statement}. <p><span><a href\=''show''> Revise las declaraciones de importación agregadas....</ A ></span>
copy.paste.resolve.references=Resolver referencias pegadas
copy.text.adding.imports=Añadiendo declaraciones de importación...
copy.text.clipboard.content.seems.to.be.java.code.do.you.want.to.convert.it.to.kotlin=El contenido del portapapeles parece ser código Java. ¿Le gustaría convertir a Kotlin?
copy.text.convert.java.to.kotlin.title=Convertir Java a Kotlin
copy.text.copied.kotlin.code=Código Kotlin copiado
copy.text.resolving.references=Resolviendo referencias...
copy.title.convert.code.from.java=Convertir código en Java
could.be.replaced.with.size=Puedes cambiarlo a "tamaño".
could.be.replaced.with.unboxed.first=Puedes cambiarlo a "primero" sin caja.
could.be.replaced.with.unboxed.last=Puede cambiarlo a "último" sin empaquetar.
create.0=Crear {0}
create.0.1=Crea {0} ''{1}''.
create.0.in.1=Produzca {0} a partir de {1}.
create.actual.0.for.module.1.2=Cree {0} real para el módulo {1} ({2}).
create.expected.0.in.common.module.1=Genera el {0} requerido a partir del módulo genérico {1}.
create.file=Crear archivo
create.kotlin.file=Crear archivo Kotlin
create.kotlin.subclass=Creando subclases de Kotlin
create.label=Crea una etiqueta.
create.label.0=Crea la etiqueta {0}@.
create.package.0=Creando paquete ''{0}''.
create.parameter.0=Crear parámetro ''{0}''
create.property.0.as.constructor.parameter=Cree la propiedad ''{0}'' como parámetro del constructor.
create.subclass=Crear subclase
create.test=Crear pruebas
dangerous.array.comparison=Comparación de matrices peligrosas
declaration.has.type.inferred.from.a.platform.call.which.can.lead.to.unchecked.nullability.issues=La declaración tiene un tipo inferido de la llamada a la plataforma, lo que puede provocar problemas de nulidad no controlados. Especifica explícitamente el tipo como anulable o no anulable.
declarations.are.used.outside.of.selected.code.fragment=La siguiente declaración se utiliza fuera del fragmento de código seleccionado:
declarations.will.move.out.of.scope=Las siguientes declaraciones no se pueden utilizar fuera del cuerpo de la función extraída:
deferred.result.is.never.used=Los resultados diferidos nunca se utilizan.
delegating.to.var.property.does.not.take.its.changes.into.account=Delegar a una propiedad ''var'' no tiene en cuenta ese cambio.
delete.0={0} Eliminar
delete.equals.and.hash.code.fix.text=Elimine iguales()/hashCode().
delete.fix.family.name=Eliminación de flecha
delete.redundant.extension.property=Eliminar propiedades extendidas duplicadas.
delete.with.usage.search=Eliminar (usando la búsqueda de ubicación)
demorgan.law=Ley de demorgan
deprecated.annotation.without.replacewith.argument=@Anotación obsoleta sin argumento ''replaceWith''
description.a.reference.to.extracted.type.parameter=Referencia al parámetro de tipo extraído
destination.not.found.for.package.0=No se pudo encontrar el destino del paquete ''{0}''.
diagnostic.name.should.be.replaced.by.the.new.one=Debe cambiar el nombre del diagnóstico al nuevo nombre.
dialog.import.on.paste.title3=Seleccione la importación para eliminar
dialog.message.incorrect.target.path.directory.not.specified=Ruta de destino no válida. No se especificó ningún directorio.
dialog.message.none.elements.were.selected=No se ha seleccionado ningún elemento
dialog.progress.collect.members.to.generate=Recoge miembros...
dialog.title.resolving.inheritable.status=El estado hereditario se está resolviendo...
difference.found.for.data.class.0.found.1.2=No se encontraron diferencias para la clase de datos {0}. Se encontraron {1} usos, pero se necesitan {2}.
do.you.want.to.delete.expected.declaration.together.with.all.related.actual.ones=¿Quiere eliminar la declaración esperada y todas las declaraciones reales relacionadas?
do.you.want.to.delete.this.parameter.in.expected.declaration.and.all.related.actual.ones=¿Quiere eliminar este parámetro de la declaración esperada y de todas las declaraciones reales relacionadas?
do.you.want.to.make.new.extension.an.expected.declaration=¿Le gustaría hacer de una nueva expansión una declaración de anticipación?
doesn.t.match.regex.0=No coincide con la expresión regular ''{0}''.
don.t.show.this.dialog.next.time=&No mostrar este cuadro de diálogo la próxima vez
double.negation.fix.text=Elimine los negativos duplicados.
editor.checkbox.title.auto.add.val.keyword.to.data.value.class.constructor.parameters=Agregue automáticamente la palabra clave 'val' al parámetro del constructor de clase de datos/valor
editor.checkbox.title.convert.pasted.java.code.to.kotlin=Convertir código Java pegado a Kotlin
editor.checkbox.title.don.t.show.java.to.kotlin.conversion.dialog.on.paste=No mostrar en el diálogo de conversión de Java a Kotlin al pegar
editor.title.kotlin=Kotlin
enter.package.fqname=Introduzca el nombre Fq del paquete.
enum.entry=Elemento de enumeración
equality.check.0.be.used.instead.of.elvis.for.nullable.boolean.check=Utilice la comprobación de igualdad {0} en lugar de elvis para la comprobación booleana anulable{0}.
equality.check.with.nan.should.be.replaced.with.isnan=La prueba de igualdad con NaN debe cambiarse a ''isNaN()''.
equals.between.objects.of.inconvertible.types=''es igual a()'' entre objetos de tipos no convertibles
equals.hashcode.in.object.declaration=Es igual a()/hashCode() en la declaración de objeto
equals.should.take.any.as.its.argument=''iguales'' deben tomar ''¿Alguno?'' como argumento.
equals.text=Crea ''igual()''
error.cant.refactor.vararg.functions=Las funciones con argumentos variables no se pueden refactorizar.
error.context.getter.or.setter=Este contexto solo se aplica a propiedades con captadores/definidores explícitos. (Establezca el formato de archivo en Kotlin)
error.expected.an.expression=Se requiere expresión
error.expected.catch.or.finally=Requiere 'atrapar' o 'finalmente'
error.hint.cannot.modify.0.declaration.from.1.file=No se puede cambiar la declaración ''{0}'' en el archivo {1}''
error.hint.library.declarations.cannot.be.changed=Las declaraciones de la biblioteca no se pueden cambiar
error.hint.text.cannot.inline.0.from.a.decompiled.file=''{0}'' en el archivo descompilado no se puede insertar.
error.param.can.t.be.null.at.index.0.in.1=El parámetro no puede ser nulo en el índice {0} en {1}.
error.text.can.t.change.signature.of.method=La firma del método {0} no se puede cambiar.
error.text.can.t.copy.class.to.the.containing.file=Las clases no se pueden copiar en archivos de inclusión.
error.text.can.t.generate.0.1=No se pudo crear {0}. {Uno}
error.text.can.t.introduce.constant.for.this.expression=No se puede insertar una constante para esta expresión
error.text.can.t.introduce.constant.for.this.expression.because.not.constant=No se puede insertar una constante para una expresión no constante
error.text.can.t.introduce.lambda.parameter.for.this.expression=No puede insertar un parámetro lambda para esta expresión.
error.text.can.t.introduce.property.for.this.expression=No se puede insertar una propiedad para esta expresión.
error.text.different.name.expected=Estoy esperando un nombre diferente.
error.text.expression.has.no.type=La expresión no tiene tipo.
error.text.extraction.from.expect.class.is.not.yet.supported=Aún no se admite la extracción de la clase esperada.
error.text.extraction.from.non.jvm.class.is.not.yet.supported=Aún no se admite la extracción de clases que no sean JVM.
error.text.inline.function.is.not.supported.for.functions.with.multiple.return.statements=La inserción de funciones no es compatible con funciones con múltiples declaraciones de devolución.
error.text.inline.function.is.not.supported.for.functions.with.return.statements.not.at.the.end.of.the.body=La inserción de funciones no es compatible con funciones que no tienen una declaración de retorno al final de su cuerpo.
error.text.interface.cannot.be.extracted.from.an.annotation.class=Las interfaces no se pueden extraer de clases anotadas
error.text.introduce.parameter.is.not.available.for.default.value=La inserción de parámetros no se puede utilizar para los valores predeterminados.
error.text.introduce.parameter.is.not.available.inside.of.annotation.entries=La inyección de parámetros no se puede utilizar dentro de un elemento de anotación
error.text.invalid.name=Nombre equivocado
error.text.invalid.parameter.name=Nombre de parámetro no válido
error.text.invalid.parameter.type=Tipo de parámetro no válido
error.text.invalid.receiver.type=Tipo de receptor no válido
error.text.invalid.return.type=Tipo de devolución no válido
error.text.no.type.to.refactor=No hay tipos para refactorizar.
error.text.refactoring.is.not.applicable.in.the.current.context=La refactorización no se puede aplicar en el contexto actual.
error.text.superclass.cannot.be.extracted.from.an.annotation.class=Las clases principales no se pueden extraer de las clases anotadas
error.text.type.reference.is.expected=Se requiere una referencia de tipo.
error.types.in.generated.function=No puede crear una función con un tipo de devolución no válido.
error.wrong.caret.position.function.or.constructor.name=El cursor debe estar en la posición del nombre de la función o del constructor que se va a refactorizar.
evaluate.compile.time.expression=Evaluación de expresiones en tiempo de compilación
excluded.methods=Métodos excluidos
existing.backing.field.is.not.assigned.by.the.setter=El campo de respaldo existente no está asignado como configurador
expand.boolean.expression.to.if.else=Expandir expresiones booleanas en declaraciones ''if else''
experimental.coroutines.usages.are.obsolete.since.1.3=Las ubicaciones de uso de rutinas experimentales están obsoletas a partir de 1.3.
explicit.0.call=Llamada explícita a ''{0}''
explicit.this.expression.fix.family.name=Eliminar duplicado ''{0}''
explicitly.given.type.is.redundant.here=Los tipos especificados explícitamente son redundantes aquí.
expression=Expresión
external.interface.contains.non.nullable.property.name=La interfaz externa tiene una propiedad booleana que no admite valores NULL
external.interface.contains.val.property.name=La interfaz externa tiene una propiedad val.
extract.function=Extracción de funciones
extract.new.parameter.name.receiver=<Receptor>
failed.to.create.a.wrapper.for.inlining.to.kotlin=No se pudo crear un contenedor para alinearlo con Kotlin
family.name.update.usages.on.declarations.cut.paste=Actualizar la ubicación de uso al cortar/pegar declaraciones
file.0.already.exists.but.does.not.correspond.to.kotlin.file=El archivo {0} ya existe, pero no es un archivo Kotlin.
file.entity=Archivo
file.lines=Línea de archivo
files.to.visit=Archivo de referencia
find.declaration.constructor.usages.checkbox=&Dónde utilizar el constructor
find.declaration.derived.classes.checkbox=&clases derivadas
find.declaration.derived.interfaces.checkbox=& Interfaces derivadas
find.declaration.functions.usages.checkbox=&Dónde utilizar las funciones
find.declaration.implementing.methods.checkbox=Implementación de funciones
find.declaration.implementing.properties.checkbox=Implementación de propiedad
find.declaration.include.overloaded.methods.checkbox=Incluye funciones y extensiones sobrecargadas.
find.declaration.overriding.methods.checkbox=&Redefinir función
find.declaration.overriding.properties.checkbox=Redefinir y redefinir propiedades
find.declaration.properties.usages.checkbox=Dónde usar propiedades
find.declaration.property.readers.checkbox=Líder
find.declaration.property.writers.checkbox=Encendedor
find.usages.checkbox.name.expected.classes=Clase requerida
find.usages.checkbox.name.expected.functions=Función requerida
find.usages.checkbox.name.expected.properties=Propiedades requeridas
find.usages.checkbox.text.fast.data.class.component.search=Búsqueda rápida de componentes de clase de datos
find.usages.class=Clase
find.usages.class.name.anonymous=Anónimo
find.usages.companion.object=Objeto compañero
find.usages.constructor=Constructor
find.usages.facade.class=Clase de fachada
find.usages.for.property={0} en propiedad
find.usages.function=Función
find.usages.getter=Getter
find.usages.import.alias=Alias de declaración de importación
find.usages.interface=Interfaz
find.usages.label=Etiqueta
find.usages.lambda=Lambda
find.usages.object=Objeto
find.usages.parameter=Parámetro
find.usages.prepare.dialog.progress=Preparar cuadro de diálogo
find.usages.progress.text.declaration.superMethods=Resolviendo el método principal...
find.usages.property=Propiedades
find.usages.property.accessor=Accesor de propiedad
find.usages.setter=Setter
find.usages.text.find.usages.for.data.class.components.and.destruction.declarations=<p>La detección de usos de componentes de clases de datos y declaraciones de desestructuración se ha <br/> <a href="{0}">deshabilitada una vez</a> o <a href="{1}">en el proyecto. Puede estar desactivado</a></p>
find.usages.tool.tip.text.disable.search.for.data.class.components.and.destruction.declarations.project.wide.setting=Deshabilite la búsqueda de componentes de clase de datos y declaraciones de desestructuración (configuración para todo el proyecto).
find.usages.type.alias=Escriba alias
find.usages.type.callable.reference=Referencia invocable
find.usages.type.class.object=Clases/Objetos anidados
find.usages.type.companion.object=Objeto compañero
find.usages.type.constructor.delegation.reference=Referencia de delegación de constructores
find.usages.type.delegate=Mandato
find.usages.type.extension.receiver.type=Tipo de receptor extendido
find.usages.type.function.call=Llamada de función
find.usages.type.function.return.type=Tipo de retorno de función
find.usages.type.implicit.get='obtener' implícito
find.usages.type.implicit.invoke='invocar' implícita
find.usages.type.implicit.iteration=Repetición implícita
find.usages.type.implicit.set='conjunto' implícito
find.usages.type.is=Tipo de destino de operación 'is'
find.usages.type.named.argument=Argumento con nombre
find.usages.type.nonLocal.property.type=Tipo de propiedad de clase/objeto
find.usages.type.packageDirective=Directiva de paquete
find.usages.type.packageMemberAccess=Acceso para miembros del paquete
find.usages.type.parameter=Tipo de parámetro
find.usages.type.property.delegation=Delegación de Propiedad
find.usages.type.receiver=Receptor
find.usages.type.super.type.qualifier=Calificador de supertipo
find.usages.type.superType=Tipo de padre
find.usages.type.type.alias=Escriba alias
find.usages.type.type.constraint=Restricciones de tipo
find.usages.type.value.parameter.type=Tipo de parámetro
find.usages.variable=Variable
fix.add.annotation.family=Agregar anotación
fix.add.annotation.target=Agregar destino de anotación
fix.add.annotation.text.constructor=Agregue la anotación ''@{0}'' al constructor
fix.add.annotation.text.containing.class=@{0} '' Agregar anotación a la clase contenedora ''{1}
fix.add.annotation.text.containing.file=Agregue la anotación ''@{0}'' que contenga el archivo ''{1}''
fix.add.annotation.text.declaration=@{0} '' Agregar anotación a ''{1}
fix.add.annotation.text.self=''@{0} '' agregar anotación
fix.add.annotation.with.arguments.text.copy=Copiar la anotación ''@{0} de ''{1}'' a ''{2}''
fix.add.argument.name.family=Agregar nombre al argumento
fix.add.argument.name.step.choose.parameter.title=Seleccione el nombre del parámetro
fix.add.argument.name.text=Agregar nombre al argumento ''{0}''.
fix.add.argument.name.text.generic=Agregar nombre al argumento...
fix.add.array.of.type.family='' arrayOf '' Agregar contenedor
fix.add.array.of.type.text=Agregue el contenedor {0}.
fix.add.constructor.parameter=Agregar parámetro de constructor ''{0}''.
fix.add.default.constructor='' esperar '' Agregar un constructor predeterminado a la clase.
fix.add.else.branch.when=Agregar otra rama.
fix.add.eq.eq.true=Añadir ''\=\= verdadero''
fix.add.exception.to.throws=Añadir ''{0}''
fix.add.explicit.import=Agregar declaración de importación explícita.
fix.add.function.body=Agregar cuerpo de función.
fix.add.function.parameters.add.parameter.constructor={0, número, ordinal} ésimo {1,choice,1\#parameter|2\#parameter} agregar al constructor ''{2}'' hacer.
fix.add.function.parameters.add.parameter.function={0, número, ordinal} ésimo {1,choice,1\#parameter|2\#parameter} agregar a la función ''{2}'' hacer.
fix.add.function.parameters.add.parameter.generic.constructor={0,choice,1\#parameters|2\#parameters} al constructor ''{1}''
fix.add.function.parameters.add.parameter.generic.function={0,choice,1\#parameter|2\#parameter} para funcionar ''{1}''
fix.add.function.parameters.change.signature.constructor=Cambiar la firma del constructor ''{0}''
fix.add.function.parameters.change.signature.function=Cambiar la firma de la función ''{0}''
fix.add.generic.upperbound.family=Agregar límite principal genérico
fix.add.generic.upperbound.text=Agregar ''{0}'' como límite superior de ''{1}''.
fix.add.is.to.when=Agregue '' es '' antes de ''{0}''.
fix.add.loop.label.text=Agregue ''{0}'' a {1}.
fix.add.loop.label.text.generic=Agregar etiqueta al bucle.
fix.add.member.supertype.add.to=Agregue ''{0}'' a ''{1}''.
fix.add.member.supertype.choose.type=Seleccione tipo
fix.add.member.supertype.family=Agregue {0} al tipo principal
fix.add.member.supertype.progress=Añade {0} para escribir
fix.add.member.supertype.text=Agregando {0} al tipo principal...
fix.add.modifier.family=Agregar modificador
fix.add.modifier.inline.function.family=Agregar '' en línea '' a la función
fix.add.modifier.inline.function.text=Agregar '' en línea '' a la función ''{0}''.
fix.add.modifier.inline.parameter.family=Agregue ''{0}'' al parámetro.
fix.add.modifier.inline.parameter.text=Agregue ''{0}'' al parámetro ''{1}''.
fix.add.modifier.text=Hacer {0} ''{1}''
fix.add.modifier.text.generic=''{0}'' agregar modificador
fix.add.new.line.after.annotations=Agregar una nueva línea después de las anotaciones
fix.add.remaining.branches=Agregar ramas restantes.
fix.add.remaining.branches.with.star.import=* Agregue las ramas restantes con declaraciones de importación.
fix.add.return.before.expression=Agregar '' return '' antes de la expresión.
fix.add.return.before.lambda.expression=Agregar '' ejecutar '' antes de la expresión lambda.
fix.add.return.last.expression=Agregue '' return '' a la última expresión.
fix.add.semicolon.lambda.expression=Terminar la llamada anterior con punto y coma.
fix.add.spread.operator.after.sam=Agregue el operador de propagación antes de la matriz cuando pase como '' vararg ''.
fix.add.star.projection.family=Agregar proyección de estrella
fix.add.star.projection.text=Agregue ''{0}''.
fix.add.suspend.modifier.function=Suspender {0}
fix.add.suspend.modifier.function.generic=Pausar la función de inclusión
fix.add.suspend.modifier.receiver=Tipo de pausa {0}.
fix.add.suspend.modifier.receiver.generic=Pausar tipo de receptor.
fix.add.tostring.call.family=Agregar llamada '' toString() ''
fix.add.tostring.call.text=Agregar una llamada a '' toString() ''
fix.add.tostring.call.text.safe=Agregar llamada segura ''? .toString() ''.
fix.add.type.annotation.family=Agregar anotación de tipo
fix.add.type.annotation.text=Agregue el tipo ''{0}'' al parámetro ''{1}''.
fix.assign.to.property=Asignar a propiedad.
fix.cast.expression.family=Convertir expresión
fix.cast.expression.text=Transmitir expresión ''{0}'' a ''{1}''.
fix.change.accessor.family=Cambiar tipo de acceso
fix.change.accessor.getter=Cambia el tipo de captador a {0}
fix.change.accessor.setter.parameter=Cambiar el tipo de parámetro del setter a {0}
fix.change.jvm.name=Cambiar nombre de JVM
fix.change.mutability.change.to.val=Cambiar ''{0}'' a val.
fix.change.object.to.class=Objeto '' a '' clase
fix.change.package.family=Cambiar el paquete en el archivo para que coincida con el directorio
fix.change.package.text=Cambie el paquete en el archivo a {0}.
fix.change.progress.analyzing.class.hierarchy=Analizando la jerarquía de clases…
fix.change.progress.looking.inheritors=Buscando herederos de la clase {0}…
fix.change.return.type.command.function=Cambie el tipo de parámetro ''{0}'' de la función ''{1}'' a ''{2}''
fix.change.return.type.command.primary.constructor=Cambie el tipo de parámetro ''{0}'' del constructor predeterminado de la clase ''{1}'' a ''{2}''
fix.change.return.type.family=Tipo de cambio
fix.change.return.type.lambda=Cambiar el tipo de retorno de la expresión lambda a {0}.
fix.change.return.type.presentation.accessed={0} accedido
fix.change.return.type.presentation.base=Base {0}
fix.change.return.type.presentation.called=Llamado {0}
fix.change.return.type.presentation.called.function=Función llamada
fix.change.return.type.presentation.enclosing=Incluyendo {0}
fix.change.return.type.presentation.enclosing.function=Función de cierre
fix.change.return.type.presentation.function=Función {0}
fix.change.return.type.presentation.property=Propiedad {0}
fix.change.return.type.remove.explicit.return.type=Eliminar un tipo de retorno especificado explícitamente.
fix.change.return.type.remove.explicit.return.type.of=Elimina el tipo de devolución especificado explícitamente de {0}.
fix.change.return.type.return.type.text=Cambiar el tipo de retorno a ''{0}''.
fix.change.return.type.return.type.text.of=Cambiar el tipo de retorno de {0} a ''{1}''
fix.change.return.type.text.function=Cambiar parámetro ''{0}'' tipo de función ''{1}'' a ''{2}''.
fix.change.return.type.text.primary.constructor=Cambiar parámetro ''{0}'' tipo de constructor primario de clase ''{1}'' a ''{2}''.
fix.change.return.type.type.text=Cambiar tipo a ''{0}''
fix.change.return.type.type.text.of=Cambiar el tipo de {0} a ''{1}''
fix.change.signature.error=<error>
fix.change.signature.family=Cambiar la firma de la función/constructor
fix.change.signature.function.family=Cambiar la firma de la función
fix.change.signature.function.popup.title=Seleccionar firma
fix.change.signature.function.text=Cambiar la firma de la función a ''{0}''.
fix.change.signature.function.text.generic=Cambiar la firma de la función...
fix.change.signature.lambda=Cambiar la firma de la expresión lambda
fix.change.signature.lambda.command=Cambiar la firma de una expresión lambda
fix.change.signature.prepare=preparando...
fix.change.signature.remove.parameter=Eliminar parámetro ''{0}''.
fix.change.signature.remove.parameter.command=Eliminar parámetro ''{0}''
fix.change.signature.unavailable=<no disponible>
fix.change.signature.unnamed.parameter=Parámetros
fix.change.suspend.hierarchy.add=Agrega el modificador '' suspender '' a todas las funciones en la jerarquía.
fix.change.suspend.hierarchy.remove=Elimina el modificador '' suspender '' de todas las funciones de la jerarquía.
fix.change.to.function.invocation=Cambio a la invocación de función.
fix.change.to.labeled.return.family=Cambiar para devolver con etiqueta
fix.change.to.labeled.return.text=Cambiar a ''{0}''
fix.change.to.mutable.type=Cambiar el tipo a {0}.
fix.change.to.property.access.family.change=Cambiar al acceso a la propiedad
fix.change.to.property.access.family.remove=Eliminar llamada
fix.change.to.star.projection.family=Cambiar a proyección de estrellas
fix.change.to.star.projection.text=Cambiar tipo de argumento a {0}.
fix.change.to.use.spread.operator.family=Cambiar para usar el operador de propagación
fix.change.to.use.spread.operator.text={0}'' un ''{1}
fix.change.type.argument=Cambiar tipo de argumento a {0}.
fix.change.type.family=Tipo de cambio
fix.change.type.text=Tipo de cambio de ''{0}'' a ''{1}''.
fix.convert.to.is.array.of.call=Se convierte en llamada 'isArrayOf'
fix.copy.mismatched.annotation.to.actual.declaration.may.change.semantics=Copie la anotación ''{0}'' que no coincide de la declaración esperada a la real (la semántica puede cambiar)
fix.create.declaration.error=No se pudo crear {0}. {1}
fix.create.declaration.error.inaccessible.type=Tipo inaccesible
fix.create.declaration.error.some.types.inaccessible=Tipos no accesibles\:
fix.create.expect.actual=Cree una declaración wait/actual.
fix.create.from.usage.dialog.title=Crear desde la ubicación de uso
fix.create.from.usage.family=Crear desde la ubicación de uso
fix.create.from.usage.local.variable=Crear variable local ''{0}''.
fix.create.missing.actual.declarations=Agregar declaración real faltante
fix.create.missing.actual.declarations.title=Agregar declaración real faltante
fix.create.missing.actual.members=Agregar miembros reales que faltan.
fix.import=Importar
fix.import.exclude=Excluir ''{0}'' de la importación automática.
fix.import.kind.0.name.1.2={0} Obtenga ''{1}''{2,choice,0#|1# y {2} más}
fix.import.kind.0.name.1.and.name.2={0} importar ''{1}'', ''{2}''
fix.import.kind.component.functions=Funciones de los componentes
fix.import.kind.delegate.accessors=Acceso delegado.
fix.import.question=¿Quieres recuperar {0}?
fix.insert.delegation.call=Insertar llamada '' {0}()''
fix.introduce.non.null.assertion=Agregar llamadas de aserción no nulas (\! \!).
fix.make.data.class=Hacer ''{0}'' una clase de datos.
fix.make.field.public=Hacer público el campo ''{0}''
fix.make.type.parameter.reified=Refinar {0} y en línea {1}.
fix.make.upperbound.not.nullable.any.text=Agregue ''Cualquiera'' como límite superior en {0} para que no admita valores NULL
fix.make.upperbound.not.nullable.family=Hacer que los parámetros de tipo comunes no admitan nulos
fix.make.upperbound.not.nullable.remove.nullability.text=Cambie el límite superior de {0} a ''{1}'' para que {0} no admita valores NULL.
fix.move.file.to.package.dir.name.text=Raíz fuente
fix.move.file.to.package.family=Mover el archivo al directorio donde coincide el paquete
fix.move.file.to.package.text=Mueva el archivo a {0}.
fix.move.to.sealed.family=Mover un miembro de la jerarquía al paquete/módulo del padre del miembro
fix.move.to.sealed.text=Mover {0} al paquete/módulo en {1}
fix.move.typealias.to.top.level=Mover el alias de tipo al nivel superior
fix.opt_in.annotation.family=Anotación de uso de la función de inclusión voluntaria
fix.opt_in.migrate.experimental.annotation.remove=Eliminar la anotación obsoleta '@Experimental'
fix.opt_in.migrate.experimental.annotation.replace=Reemplace la anotación obsoleta '@Experimental' con '@RequiresOptIn'
fix.opt_in.move.requirement.from.getter.to.property=Mover el requisito de participación ''{0}'' del captador a la propiedad
fix.opt_in.move.requirement.from.value.parameter.to.property=Mover el requisito de participación ''{0}'' del parámetro de valor a la propiedad
fix.opt_in.remove.all.forbidden.targets=Eliminar objetivos de anotación de participación voluntaria prohibidos
fix.opt_in.remove.forbidden.retention=Eliminar el archivo de anotaciones de suscripción prohibidas
fix.opt_in.text.propagate.constructor=Pase el requisito de suscripción ''{0}'' a ''{0}''
fix.opt_in.text.propagate.containing.class=Pasar ''{0}'' a la clase ''{1}'' que contiene el requisito de suscripción
fix.opt_in.text.propagate.containing.object=''{0}'' pasó al objeto ''{1}'' que contiene el requisito de participación
fix.opt_in.text.propagate.declaration=Pasar el requisito de suscripción ''{0}'' a ''{1}''
fix.opt_in.text.use.constructor=Optar por ''{0}'' en el constructor
fix.opt_in.text.use.containing.anonymous.object=Optar por ''{0}'' en el objeto principal
fix.opt_in.text.use.containing.class=Suscribirse ''{0}'' en la clase que contiene ''{1}''
fix.opt_in.text.use.containing.file=Suscribirse ''{0} en el archivo que contiene ''{1}''
fix.opt_in.text.use.containing.object=Optar por ''{0}'' en el objeto principal ''{1}''
fix.opt_in.text.use.declaration=Suscríbete a ''{0}'' de ''{1}''
fix.opt_in.text.use.statement=Optar por ''{0}'' en la sintaxis
fix.potentially.broken.inheritance.message=Este cambio podría causar problemas a tus herederos.\n¿Quieres continuar?
fix.potentially.broken.inheritance.title=Herencia potencialmente problemática
fix.remove.annotation.text=Eliminar anotación
fix.remove.argument.text=Eliminar argumento
fix.remove.mismatched.annotation.from.expect.declaration.may.change.semantics=Eliminar la anotación no coincidente ''{0}'' de la declaración esperada (puede cambiar de significado)
fix.remove.non.null.assertion=Eliminar aserciones innecesarias no nulas (\! \!)
fix.remove.redundant.star.text=Eliminar duplicados *
fix.replace.annotation.family=Cambiar anotación
fix.replace.annotation.text=Reemplace la anotación con ''@{0}''
fix.replace.mismatched.annotation.args.on.actual.declaration.may.change.semantics=Reemplazar argumentos para la anotación ''{0}'' que no coincide en la declaración real (puede cambiar de significado)
fix.replace.mismatched.annotation.args.on.expect.declaration.may.change.semantics=Reemplazar argumentos para la anotación ''{0}'' que no coincide en la declaración esperada (la semántica puede cambiar)
fix.replace.with.assign.function.call=Reemplazar con la llamada ''{0}''.
fix.replace.with.declaring.java.class=Reemplazado con 'declarandoJavaClass'
fix.text=Elimine los puntos y comas redundantes.
fix.unused.receiver.parameter.remove=Eliminar parámetros duplicados del receptor.
fix.use.fully.qualified.call=Utilice llamadas totalmente calificadas
fix.with.asdynamic=Modifíquelo a ''asDynamic''.
flatten.when.expression=Aplanar expresiones ''cuándo''
flip.0=Invertir ''{0}''
flip.binary.expression=Invertir expresión binaria
flip.equals=Invertir ''equals''
floating.point.literal.precision.inspection=Los literales de coma flotante no se pueden representar con la precisión requerida
floating.point.literal.precision.inspection.display.name=El literal de coma flotante excede la precisión disponible
foldable.if.then=Plegable si-entonces
following.expression.won.t.be.processed.since.refactoring.can.t.preserve.its.semantics.0=Las siguientes expresiones no se procesan porque su significado no se puede conservar durante la refactorización: {0}
following.problems.are.found=Se encontraron los siguientes problemas:\n
for.0=Para ''{0}''
for.api.stability.it.s.recommended.to.specify.explicitly.declaration.types=Para la estabilidad de la API, recomendamos especificar explícitamente el tipo de declaración.
for.api.stability.it.s.recommended.to.specify.explicitly.public.protected.declaration.types=Para la estabilidad de la API, recomendamos especificar explícitamente los tipos de declaración pública y protegida.
for.loop.over.indices.could.be.replaced.with.loop.over.elements=Puede reemplazar el bucle for sobre el índice con un bucle sobre los elementos.
formatter.button.text.use.import.with=Usando una declaración de importación con '' * ''
formatter.button.text.use.import.with.when.at.least=Usar declaraciones de importación con '' * '' cuando
formatter.button.text.use.single.name.import=Usar declaración de importación de nombre único
formatter.checkbox.text.insert.imports.for.nested.classes=Insertar declaraciones de importación para clases anidadas
formatter.checkbox.text.use.trailing.comma=Usar coma al final
formatter.settings.title=Configuración del formateador de Kotlin
formatter.text.names.used=\ Nombres utilizados
formatter.text.use.defaults.from=Usar valores predeterminados\:
formatter.title.after.colon.before.declaration.type=Después de dos puntos, antes del tipo de declaración
formatter.title.after.colon.in.new.type.definition=Después de dos puntos en la nueva definición de tipo
formatter.title.align.when.branches.in.columns=Alinear '' cuando '' se ramifica en columnas
formatter.title.around.arrow.in="when" alrededor de la flecha en la cláusula
formatter.title.around.arrow.in.function.types=Alrededor de flechas de tipos de funciones
formatter.title.around.when.branches.with=Alrededor de la rama '' cuando '' con {}
formatter.title.before.colon.after.declaration.name=Antes de los dos puntos, después del nombre de la declaración
formatter.title.before.colon.in.new.type.definition=Antes de los dos puntos en la nueva definición de tipo
formatter.title.before.declaration.with.comment.or.annotation=Antes de la declaración anotada o anotada
formatter.title.before.lambda.arrow=Antes de la flecha lambda
formatter.title.chained.function.calls=Llamar a funciones encadenadas
formatter.title.elvis.expressions=Expresiones de Elvis
formatter.title.expression.body.functions=Funciones del cuerpo de la expresión
formatter.title.function.annotations=Anotaciones de funciones
formatter.title.function.call.arguments=Argumentos de llamada a función
formatter.title.function.declaration.parameters=Parámetros de declaración de función
formatter.title.function.parentheses=Paréntesis de funciones
formatter.title.in.simple.one.line.methods=Un método simple de una línea
formatter.title.java.statics.and.enum.members=Miembros de enumeración y estática de Java
formatter.title.line.break.after.multiline.when.entry=Nueva línea después de varias líneas de entrada
formatter.title.load.save=Cargar/Guardar
formatter.title.other=Otro
formatter.title.property.annotations=Anotaciones de propiedad
formatter.title.put.left.brace.on.new.line=Coloque la llave izquierda en la nueva línea
formatter.title.range.operator=Operador de rango (..)
formatter.title.top.level.symbols=Símbolos principales
formatter.title.trailing.comma=Coma final
formatter.title.use.continuation.indent=Usar sangría continua
formatter.title.use.continuation.indent.in.conditions=Utilice sangría continua en condiciones
formatter.title.when.parentheses=''cuándo'' paréntesis
formatter.title.when.statements=Sintaxis ''cuándo''
function=Función
function.0=Función ''{0}''
function.0.returning.1.without.the.corresponding=Una función que devuelve {3}'' Una función que devuelve ''{1}'' sin ''{2}'' ''{0}
function.01=Función "{0}"
function.name.is.invalid=El nombre de la función es incorrecto.
function.returning.0.with.a.name.that.does.not.end.with.1=Función que devuelve {0} cuyo nombre no termina en {1}
function.should.have.operator.modifier=La función debe tener un controlador ''operador''.
generate.equals.and.hashcode.fix.text=Generar iguales() y hashCode()
generate.identity.equals.fix.family.name=Generar iguales y hashCode por ID
goto.related.provider.in.module.0=(en el módulo {0})
goto.super.chooser.class.title=Seleccione la clase o interfaz principal
goto.super.chooser.function.title=Seleccionar función principal
goto.super.chooser.property.title=Seleccionar propiedad principal
group.InternalKotlin.text=Acciones dentro de Kotlin
group.KotlinCompletionBenchmarkGroup.text=Finalización del punto de referencia
group.KotlinInternalGroup.text=Kotlin
group.KotlinRefactoringTesting.text=Pruebas de refactorización de Kotlin
group.KotlinToolsGroup.text=Kotlin
group.advanced.settings.kotlin=Kotlin
group.names.gradle=Gradle
group.names.java.interop.issues=Problemas de interoperabilidad de Java
group.names.kotlin=Kotlin
group.names.logging=Grabación
group.names.maven=Experto
group.names.migration=Migración
group.names.naming.conventions=Reglas de creación de nombres
group.names.other.problems=Otros asuntos
group.names.probable.bugs=Errores que puedes encontrar
group.names.redundant.constructs=Sintaxis innecesaria
group.names.style.issues=Problemas de estilo
group.path.kotlin.migration=Kotlin, migración
hash.code.text=Crea ''hashCode()''
hierarchy.legend.member.defined.in.superclass=Los miembros se definen en la clase principal, no en la clase.
hierarchy.legend.member.is.defined.in.class=Los miembros se definen en clases.
hierarchy.legend.member.should.be.defined=Como la clase no es abstracta, debe definir miembros.
hierarchy.text.anonymous=[anónimo]
hierarchy.text.in=\{0} mi
highlight.usages.of.receiver=Resaltando dónde usar el receptor
highlighter.action.text.go.to.actual.declarations=Ir a la declaración real
highlighter.action.text.go.to.expected.declaration=Ir a la declaración esperada
highlighter.action.text.go.to.implementations=Ir a Implementación
highlighter.action.text.go.to.overridden.methods=Ir al método anulado
highlighter.action.text.go.to.overridden.properties=Ir a propiedad anulada
highlighter.action.text.go.to.subclasses=Ir a la subclase
highlighter.action.text.go.to.super.method=Ir al método principal
highlighter.action.text.go.to.super.property=Ir a la propiedad principal
highlighter.descriptor.text.android.extensions.property=Propiedades y variables //Propiedades de integración de extensiones de Android
highlighter.descriptor.text.annotation=Anotación//nombre de la anotación
highlighter.descriptor.text.annotation.attribute.name=Anotación//Nombre de propiedad de anotación
highlighter.descriptor.text.arrow=Paréntesis y operadores//flechas
highlighter.descriptor.text.builtin.annotation=Palabra clave//Controlador
highlighter.descriptor.text.builtin.keyword=Palabra clave//Palabra clave
highlighter.descriptor.text.builtin.keyword.val=Palabra clave//''val''
highlighter.descriptor.text.builtin.keyword.var=Palabra clave//''var''
highlighter.descriptor.text.captured.variable=Propiedades y Variables//Variables y valores capturados en cierres
highlighter.descriptor.text.closure.braces=Paréntesis y operadores//Paréntesis y flechas de expresión lambda
highlighter.descriptor.text.colon=Paréntesis y operadores//dos puntos
highlighter.descriptor.text.constructor.call=Función//Llamada al constructor
highlighter.descriptor.text.double.colon=Paréntesis y operadores//Doble colon
highlighter.descriptor.text.dynamic.fun.call=Función // Llamada de función dinámica
highlighter.descriptor.text.dynamic.property=Propiedades y variables//Propiedades dinámicas
highlighter.descriptor.text.enum=Clases e interfaces//Enumeraciones
highlighter.descriptor.text.enumEntry=Clases e interfaces//Elementos de enumeración
highlighter.descriptor.text.exclexcl=Paréntesis y operadores // Afirmación no nula
highlighter.descriptor.text.extension.fun.call=Función//Llamada de función extendida
highlighter.descriptor.text.extension.property=Propiedades y variables//Propiedades extendidas
highlighter.descriptor.text.field=Propiedades y variables//Variables de campo de respaldo
highlighter.descriptor.text.fun=Función//Declaración de función
highlighter.descriptor.text.fun.call=Función//Llamada de función
highlighter.descriptor.text.instance.property=Propiedades y variables//Propiedades de instancia
highlighter.descriptor.text.instance.property.custom.property.declaration=Propiedades y variables // Propiedades de instancia con declaraciones de propiedades personalizadas
highlighter.descriptor.text.it=Parámetros//Parámetros predeterminados de la expresión lambda
highlighter.descriptor.text.kdoc.comment=Comentarios//KDoc//Comentarios de KDoc
highlighter.descriptor.text.kdoc.tag=Comentarios//KDoc//Etiqueta KDoc
highlighter.descriptor.text.kdoc.value=Comentarios//KDoc//Enlaces dentro de etiquetas KDoc
highlighter.descriptor.text.label=Etiqueta
highlighter.descriptor.text.local.variable=Propiedades y variables//Variables o valores locales
highlighter.descriptor.text.named.argument=Argumento con nombre
highlighter.descriptor.text.object=Clases e Interfaces//Objetos
highlighter.descriptor.text.package.fun.call=Función // Llamada de función a nivel de paquete
highlighter.descriptor.text.package.property=Propiedades y variables//Propiedades a nivel de paquete
highlighter.descriptor.text.package.property.custom.property.declaration=Propiedades y variables//Propiedades a nivel de paquete con declaraciones de propiedades personalizadas
highlighter.descriptor.text.quest=Paréntesis y operadores//Tipo Marcador de posibilidad de valor nulo
highlighter.descriptor.text.safe.access=Paréntesis y operadores//Período de acceso seguro
highlighter.descriptor.text.smart.cast=Reparto inteligente//valor de reparto inteligente
highlighter.descriptor.text.smart.cast.receiver=Smart cast//receptor implícito de smart cast
highlighter.descriptor.text.smart.constant=Reparto inteligente//constante inteligente
highlighter.descriptor.text.string.escape=String// escapando dentro de paréntesis de cadena y plantilla
highlighter.descriptor.text.suspend.fun.call=Función//Pausar llamada a función
highlighter.descriptor.text.synthetic.extension.property=Propiedades y variables//Propiedades de extensión integradas
highlighter.descriptor.text.typeAlias=Clases e interfaces//Alias de tipo
highlighter.descriptor.text.var=Propiedades y variables//Var (variable variable, parámetro o propiedad)
highlighter.descriptor.text.variable.as.function.call=Propiedades y variables//Variables como llamadas a funciones
highlighter.descriptor.text.variable.as.function.like.call=Propiedades y variables // Variables como llamadas como funciones
highlighter.message.suspend.function.call=Pausar llamada a función
highlighter.message.suspending.iteration=Pausa Repetir
highlighter.name.dsl=Dsl//
highlighter.name.dsl.markers=Marcador DSL
highlighter.name.expect.actual.line.markers=Marcador de línea 'esperado'//'real' de Kotlin
highlighter.name.implemented.declaration=Declaración implementada
highlighter.name.implementing.declaration=Implementación de la declaración
highlighter.name.kotlin.line.markers=Marcadores de línea de Kotlin
highlighter.name.multiplatform.actual.declaration=Manifiesto Real Multiplataforma
highlighter.name.multiplatform.expect.declaration=Declaración de expectativas multiplataforma
highlighter.name.overridden.declaration=Declaración redefinida
highlighter.name.overriding.declaration=Anular declaración
highlighter.name.style=estilo
highlighter.notification.text.navigation.to.overriding.classes.is.not.possible.during.index.update=La navegación que anula una clase no es posible durante una actualización de índice.
highlighter.prefix.text.has.actuals.in=Real incluido
highlighter.text.click.for.navigate=Haga clic en {0} para navegar
highlighter.text.has.functional.implementations=Incluye implementación de funciones.
highlighter.text.implements=Avatar
highlighter.text.in=''{1}'' en mi {0}
highlighter.text.or.press=Presione \ o {0}
highlighter.text.overrides=Reiniciar
highlighter.title.overriding.declarations.of=Anular la declaración de {0}
highlighter.title.searching.for.overriding.declarations=Buscar declaraciones que anulen
highlighter.title.searching.for.overriding.methods=Buscar métodos primordiales
highlighter.tool.tip.has.expect.declaration.in={0} módulo tiene el valor esperado
highlighter.tool.tip.marker.annotation.for.dsl=Anotaciones de marcador para DSL
highlighter.tool.tip.text.function=Función
highlighter.tool.tip.text.property=Propiedades
highlighter.tool.tip.text.recursive.call=Llamada recursiva
hint.text.no.expression.found=Expresión no encontrada
hints.codevision.implementations.format={0,choice,1\#1 implementación|2\#{0,number} implementaciones}
hints.codevision.implementations.too_many.format={0,number} o más implementaciones
hints.codevision.inheritors.format={0,choice,1\#1 heredero|2\#{0,number} herederos}
hints.codevision.inheritors.to_many.format={0,number} o más herederos
hints.codevision.overrides.format={0,choice,1\#1 anulación|2\#{0,número} anulación}
hints.codevision.overrides.to_many.format={0,number} o más anulaciones
hints.codevision.settings=Configuración...
hints.codevision.usages.format={0, choice,1\#1 referencia|2\#{0,number} referencia}
hints.codevision.usages.too_many.format={0,number} o más usos
hints.ranges.greaterOrEqual=≥
hints.ranges.less=<
hints.ranges.lessOrEqual=≤
hints.settings.common.items=Mostrar sugerencias para\:
hints.settings.dont.show.lambda.receivers.parameters=Suprimir sugerencias implícitas de parámetros y receptores
hints.settings.dont.show.lambda.return=Suprimir sugerencias de expresión de retorno
hints.settings.dont.show.ranges=Suprimir sugerencias de rango
hints.settings.dont.show.suspending=Suprimir sugerencias de llamada de parada
hints.settings.dont.show.types.parameter=Suprimir sugerencias de tipo de parámetro de función
hints.settings.dont.show.types.property=Suprimir sugerencias de tipo de propiedad
hints.settings.dont.show.types.return=Suprimir sugerencias de tipo de retorno de función
hints.settings.dont.show.types.variable=Suprimir sugerencias de tipo de variable local
hints.settings.lambda.receivers.parameters=Receptores y parámetros implícitos
hints.settings.lambda.return=Expresión de retorno
hints.settings.lambdas=Lambdas
hints.settings.ranges=Rango
hints.settings.show.lambda.receivers.parameters=Mostrar sugerencias implícitas de parámetros y receptores
hints.settings.show.lambda.return=Mostrar sugerencia de expresión de retorno
hints.settings.show.ranges=Mostrar sugerencias de rango
hints.settings.show.suspending=Mostrar sugerencia de parada de llamada
hints.settings.show.types.parameter=Mostrar sugerencia de tipo de parámetro de función
hints.settings.show.types.property=Mostrar sugerencias de tipo de propiedad
hints.settings.show.types.return=Mostrar sugerencias de tipo de retorno de función
hints.settings.show.types.variable=Mostrar sugerencias de tipo de variable local
hints.settings.suspending=Suspender llamadas
hints.settings.types=Tipos
hints.settings.types.parameter=Tipos de parámetros de función
hints.settings.types.property=Tipos de propiedad
hints.settings.types.return=Tipo de retorno de función
hints.settings.types.variable=Tipos de variables locales
hints.settings.values.ranges=Ámbito
hints.title.argument.name.enabled=Nombre del argumento
hints.title.codevision=Code Vision
hints.title.dont.show.argument.name.enabled=Suprimir sugerencias de nombres de argumentos
hints.title.show.argument.name.enabled=Mostrar sugerencias de nombres de argumentos
hints.types=Escriba sugerencia
if.null.return.break.foldable.to=If-Null return/break/... plegable con ''?\:''
if.then.foldable.to=Si-Entonces plegable con ''?\:''
implement.abstract.class=Implementación de clase abstracta
implement.abstract.function=Implementación de funciones abstractas
implement.abstract.member=Implementación de miembros abstractos
implement.abstract.property=Implementando propiedades abstractas
implement.as.constructor.parameter=Implementado como parámetro del constructor.
implement.interface=Implementación de interfaz
implement.sealed.class=Implementación de clase sellada
implicit.nothing.s=Nada implícito
implicit.parameter.it.of.enclosing.lambda.is.shadowed=El parámetro implícito "it" de la lambda adjunta está sombreado.
implicit.unsafe.cast.from.dynamic.to.0=Transmisión implícita (insegura) de dinámica a {0}
import.members.from.0=Obtener miembros de ''{0}''
import.members.with=Obtener miembros con ''*''
import.optimizer.notification.text.unused.imports.not.found=No se puede encontrar una declaración de importación obsoleta.
import.optimizer.progress.indicator.text.collect.imports.for=Recopile declaraciones de importación para {0}.
import.optimizer.text.import={0,choice, 0\#importar declaración|2\#importar declaración}
import.optimizer.text.non.zero=Elimine {0} {1} {2,choice, 0\#|1\# y agregue {2} {3}}
import.optimizer.text.zero=Declaraciones de importación reordenadas
import.order.button.text.add.package=Agregar paquete
import.order.button.text.down=Bajo
import.order.button.text.remove=Eliminar
import.order.button.text.up=Consuelo
import.progress.text.resolve.imports=Encuentre todas las declaraciones de importación...
import.text.all.alias.imports=Obtener todos los alias
import.text.all.other.imports=Todas las demás declaraciones de importación
import.text.import=Importar
in.class.0=\ dentro de la clase ''{0}''
inaccessible.declaration=Declaración inaccesible
incomplete.destructuring.declaration.text=Declaración de desestructuración incompleta
incomplete.destructuring.fix.family.name=Agregar variables faltantes a la declaración de desestructuración
indent.raw.string=Sangría de cadena sin formato
index.is.not.used.in.the.loop.body=El índice no se utiliza en el cuerpo del bucle.
inheritance.of.kotlin.sealed=Java {0,choice,0#interface|1#class} no puede ser parte de la jerarquía sellada de Kotlin
initialize.with.constructor.parameter=Inicializar con parámetros del constructor.
inlay.kotlin.call.chains.hints=Mostrar sugerencias incrustadas para la cadena de llamadas
inlay.kotlin.lambdas.hints=Mostrar sugerencias de incrustaciones para Lambda
inlay.kotlin.lambdas.hints.hints.lambda.receivers.parameters=Mostrar sugerencias incrustadas para receptores y parámetros implícitos
inlay.kotlin.lambdas.hints.hints.lambda.return=Mostrar sugerencias incrustadas para expresiones de retorno
inlay.kotlin.references.types.hints=Mostrar sugerencia de incrustación para el tipo
inlay.kotlin.references.types.hints.hints.type.function.parameter=Parámetro lambda cuyo tipo no se especifica explícitamente.
inlay.kotlin.references.types.hints.hints.type.function.return=Una función con un tipo de retorno inferido.
inlay.kotlin.references.types.hints.hints.type.property=Por ejemplo, una declaración de propiedad cuyo tipo no aparece claramente en el lado derecho de la asignación cuando se obtiene de una secuencia o método de fábrica.
inlay.kotlin.references.types.hints.hints.type.variable=Por ejemplo, una declaración de variable local cuyo tipo no aparece claramente en el lado derecho de la asignación cuando se obtiene en una llamada a un método.
inlay.kotlin.values.hints=Mostrar sugerencias incrustadas para valores
inlay.kotlin.values.hints.kotlin.values.ranges=Mostrar sugerencias incrustadas para rangos
inline.type.parameter=Insertar el parámetro de tipo.
inline.variable=Variables en línea
inline.when.argument=Incluir el argumento 'cuándo'
insert.curly.braces.around.variable=Insertar llaves alrededor de las variables
insert.explicit.delegation.call=Inserta una llamada de delegación explícita.
insert.number.conversion=Inserte una conversión numérica.
inspection.add.conversion.call.display.name=A partir de 1.9 necesitas convertir explícitamente desde 'Int'
inspection.add.operator.modifier.display.name=La función debe tener un controlador ''operador''.
inspection.add.variance.modifier.display.name=Los parámetros de tipo pueden tener distribución ''dentro'' o ''fuera''
inspection.ambiguous.expression.when.branch.migration.display.name=A partir de 1.7, existen expresiones lógicas ambiguas en la rama 'cuándo'.
inspection.array.in.data.class.display.name=Propiedades de matriz en clases de datos
inspection.boolean.literal.argument.display.name=Argumento literal booleano sin nombre de parámetro
inspection.can.be.parameter.display.name=Los parámetros del constructor no se utilizan como propiedades.
inspection.can.be.primary.constructor.property.display.name=La propiedad se asigna explícitamente al parámetro del constructor.
inspection.can.be.val.display.name=La ''var'' local no está calificada y puede declararse como ''val''
inspection.can.sealed.subclass.be.object.display.name=Subclase sellada sin estado y sin iguales anulados
inspection.cascade.if.display.name=Cascada si se puede cambiar a cuándo
inspection.class.name.display.name=Convención de nomenclatura de clases
inspection.complex.redundant.let.display.name=Llamada ''let'' basada en argumentos duplicados
inspection.conflicting.extension.property.display.name=La propiedad extendida entra en conflicto con la propiedad integrada
inspection.const.property.name.display.name=Convención de nomenclatura de propiedades constantes
inspection.constant.condition.if.display.name=La condición de la expresión ''si'' es una constante.
inspection.control.flow.with.empty.body.display.name=Control de flujo con cuerpo vacío.
inspection.convert.argument.to.set.display.name=Los argumentos se pueden convertir a 'Establecer' para un mejor rendimiento.
inspection.convert.call.chain.into.sequence.display.name=Para mejorar el rendimiento, puede convertir la cadena de llamadas de una colección en una "Secuencia".
inspection.convert.lambda.to.reference.display.name=Se puede reemplazar con referencia de función
inspection.convert.na.n.equality.display.name=Convierta la comprobación de igualdad con ''NaN'' para llamar a ''isNaN''
inspection.convert.object.to.data.object.display.name=Convertir 'objeto' en 'objeto de datos'
inspection.convert.pair.constructor.to.to.function.display.name=Convertir el constructor de pares en la función ''a''
inspection.convert.reference.to.lambda.display.name=Se puede reemplazar con lambda.
inspection.convert.secondary.constructor.to.primary.display.name=Convertir al constructor predeterminado
inspection.convert.to.string.template.display.name=Concatenar cadenas que se pueden convertir en plantillas de cadenas
inspection.convert.try.finally.to.use.call.display.name=Convierta la llamada try/finally a use()
inspection.convert.two.comparisons.to.range.check.display.name=Debe convertir los dos elementos de comparación en una verificación de rango.
inspection.copy.without.named.arguments.display.name=El método ''copia'' de la clase de datos se llama sin argumentos con nombre.
inspection.data.class.private.constructor.display.name=Constructor de clase de datos privados expuesto mediante el método ''copiar''
inspection.deferred.is.result.display.name=Función que devuelve Diferido directamente
inspection.deferred.result.unused.display.name=Los resultados diferidos nunca se utilizan.
inspection.delegation.to.var.property.display.name=Delegar a la propiedad ''var''
inspection.deprecated.callable.add.replace.with.display.name=@Anotación obsoleta sin argumento ''replaceWith''
inspection.deprecated.enum.declaring.class.property=Propiedad 'Enum.declaringClass' obsoleta
inspection.deprecated.gradle.dependency.display.name=Biblioteca obsoleta utilizada en Gradle
inspection.deprecated.inline.class.text=Clases en línea obsoletas
inspection.deprecated.inline.classes.migration.display.name=Las clases en línea están en desuso desde 1.5
inspection.deprecated.maven.dependency.display.name=Se utilizó una biblioteca obsoleta en Maven
inspection.destructure.display.name=Usando declaraciones desestructurantes
inspection.destructuring.wrong.name.display.name=Una variable en una declaración de desestructuración utiliza el nombre de una propiedad de clase de datos incorrecta.
inspection.different.kotlin.gradle.version.display.name=Las versiones de los complementos Kotlin Gradle e IDE son diferentes
inspection.different.kotlin.maven.version.display.name=Las versiones de los complementos Maven e IDE son diferentes
inspection.different.maven.stdlib.version.display.name=Las versiones del complemento Library y Maven son diferentes
inspection.different.stdlib.gradle.version.display.name=Las versiones de la biblioteca Kotlin y del complemento Gradle son diferentes
inspection.do.not.propagate.method.deprecation.through.overrides=A partir de 1.9, no pase la eliminación de interrupción del método mediante anulación
inspection.empty.range.display.name=Los rangos con inicio mayor que endInclusive quedan vacíos.
inspection.enum.entry.name.display.name=Convenciones de nomenclatura de elementos de enumeración
inspection.enum.values.method.soft.deprecate.in.java.display.name=A partir de Kotlin 1.9, se recomienda reemplazar 'Enum.values()' por 'Enum.getEntries()'
inspection.enum.values.method.soft.deprecate.migration.display.name=A partir de 1.9, se recomienda reemplazar 'Enum.values()' por 'Enum.entries'
inspection.equals.or.hash.code.display.name=''equals()'' y ''hashCode()'' no son un par
inspection.explicit.this.display.name=Duplicar explícito esto ''
inspection.fake.jvm.field.constant.display.name=Propiedades de Kotlin no constantes utilizadas como constantes de Java
inspection.filter.is.instance.call.with.class.literal.argument.display.name=Llame a 'filterIsInstance' con un argumento literal de clase
inspection.filter.is.instance.call.with.class.literal.argument.quick.fix.text=Conversión de argumentos literales de clase en parámetros de tipo materializado
inspection.fold.initializer.and.if.to.elvis.display.name=If-Null return/break/... plegable con ''?\:''
inspection.for.each.parameter.not.used.display.name=Los elementos repetidos no se utilizan en forEach
inspection.from.closed.range.migration.display.name=MIN_VALUE paso desdeClosedRange() desde 1.3
inspection.function.name.display.name=Convención de nomenclatura de funciones
inspection.function.with.lambda.expression.body.display.name=Funciones con ''\={... }'' y tipos de retorno inferidos
inspection.gradle.kotlinx.coroutines.deprecation.display.name=La dependencia incompatible de kotlinx.coroutines en Gradle se utiliza en Kotlin 1.3+
inspection.has.platform.type.display.name=La función o propiedad tiene un tipo de plataforma.
inspection.if.then.to.elvis.display.name=Si-Entonces plegable con ''?\:''
inspection.if.then.to.safe.access.display.name=Si-Entonces eso se puede contraer en ''?''.
inspection.implicit.nullable.nothing.type.display.name=Tipo implícito "¿Nada?"
inspection.implicit.this.action.name=Añade 'esto' explícito
inspection.implicit.this.display.name=Implícito "esto"
inspection.incomplete.destructuring.declaration.display.name=Declaración de desestructuración incompleta
inspection.inconsistent.comment.for.java.parameter.display.name=Anotaciones inconsistentes para parámetros Java
inspection.introduce.when.subject.display.name=''cuándo'' se puede simplificar mediante la inserción de argumentos
inspection.java.collections.static.method.display.name=Las llamadas a métodos estáticos de la colección Java se pueden reemplazar con Kotlin stdlib
inspection.java.collections.static.method.on.immutable.list.display.name=Llamada de modificador de Java en una colección Kotlin inmutable''
inspection.java.io.serializable.object.must.have.read.resolve.display.name=Los objetos serializables deben implementar 'readResolve'
inspection.java.io.serializable.object.must.have.read.resolve.quick.fix.name=Implementación de 'readResolve'
inspection.java.io.serializable.object.must.have.read.resolve.warning=Los objetos serializables deben implementar 'readResolve'
inspection.java.map.for.each.display.name=Debe reemplazar la llamada al método Java Map.forEach con forEach de Kotlin.
inspection.join.declaration.and.assignment.display.name=Combinando declaración y cesión
inspection.join.declaration.and.assignment.option.report.with.complex.initialization.of.member.properties=Analizando la inicialización compleja de propiedades de miembros
inspection.k.doc.missing.documentation.display.name=Falta el comentario de KDoc en la declaración pública
inspection.k.doc.unresolved.reference.display.name=Referencias no resueltas dentro de KDoc
inspection.kotlin.catch.may.ignore.exception.display.name=Los bloques 'catch' pueden ignorar excepciones
inspection.kotlin.constant.conditions.display.name=Condición constante
inspection.kotlin.covariant.equals.display.name=Covarianza ''es igual()''
inspection.kotlin.deprecation.display.name=Dónde utilizar sintaxis redundante o obsoleta o símbolos obsoletos
inspection.kotlin.double.negation.action.name=Eliminar dobles negativos innecesarios
inspection.kotlin.double.negation.display.name=Doble negativo redundante
inspection.kotlin.equals.between.inconvertible.types.display.name=''es igual a()'' entre objetos de tipos no convertibles
inspection.kotlin.internal.in.java.display.name=Dónde usar declaraciones dentro de Kotlin en Java
inspection.kotlin.invalid.bundle.or.property.display.name=Clave de propiedad no válida
inspection.kotlin.jvm.annotation.in.java.description=La anotación Kotlin JVM ''{0}'' no tiene efecto en Java
inspection.kotlin.jvm.annotation.in.java.display.name=Anotaciones de Kotlin JVM en Java
inspection.kotlin.maven.plugin.phase.display.name=El complemento Kotlin Maven está configurado incorrectamente
inspection.kotlin.redundant.override.display.name=Método anulado duplicado
inspection.kotlin.redundant.suppression.display.name=Suprimir diagnósticos innecesarios
inspection.kotlin.sealed.in.java.display.name=Kotlin interfaz sellada/herencia de clases en Java
inspection.kotlin.test.j.unit.display.name=Puedes usar kotlin-test-junit
inspection.kotlin.throwable.not.thrown.display.name=Arrojable no es arrojado
inspection.kotlin.unused.import.display.name=Directiva de importación obsoleta
inspection.kotlin.unused.variable.display.name=Variable sin usar
inspection.lateinit.var.overrides.lateinit.var.display.name=La propiedad lateinit var anula la propiedad lateinit var
inspection.leaking.this.display.name=''esta'' fuga en el constructor
inspection.lift.return.or.assignment.display.name=La devolución o cesión se puede eliminar
inspection.lift.return.or.assignment.option.only.single.statement=Informar solo cuando la sucursal sea una declaración única
inspection.local.variable.name.display.name=Convenciones de nomenclatura de variables locales
inspection.logger.initialized.with.foreign.class.display.name=El registrador se ha inicializado como una clase externa.
inspection.logger.placeholder.count.matches.argument.count.display.name=El número de marcadores de posición no coincide con el número de argumentos en la llamada de registro
inspection.loop.to.call.chain.display.name=Los bucles se pueden reemplazar con operaciones stdlib
inspection.main.function.return.unit.display.name=La función de punto de entrada debe devolver la Unidad
inspection.map.get.with.not.null.assertion.operator.display.name=''map.get()'' con operador de aserción no nulo (\!\!)
inspection.maven.coroutines.deprecation.display.name=La dependencia de kotlinx.coroutines incompatible de Maven se usa en Kotlin 1.3+
inspection.may.be.constant.display.name=Puede ser "constante".
inspection.member.visibility.can.be.private.display.name=Los miembros de la clase pueden tener visibilidad "privada"
inspection.message.cast.will.always.fail=La conversión de tipos siempre falla
inspection.message.condition.always.false=La condición siempre es falsa
inspection.message.condition.always.false.when.reached=Cuando se alcanza la condición siempre es falsa.
inspection.message.condition.always.true=La condición siempre es verdadera
inspection.message.condition.always.true.when.reached=Siempre es cierto cuando se cumple la condición
inspection.message.empty.catch.block=Bloque de captura vacío
inspection.message.for.never.visited=El alcance 'for' siempre está en blanco
inspection.message.inconsistent.parameter.name.for.0=Nombre de parámetro inconsistente para ''{0}''
inspection.message.index.out.of.bounds=El índice siempre está fuera de rango
inspection.message.nonnull.cast.will.always.fail=La operación siempre falla porque el operando siempre es nulo.
inspection.message.object.with.manual.tostring.can.be.converted.to.data.object=Objeto' con 'toString' manual se puede convertir en 'objeto de datos
inspection.message.sealed.object.can.be.converted.to.data.object=Un subobjeto 'sellado' se puede convertir en un 'objeto de datos'
inspection.message.value.always.false=El valor siempre es falso
inspection.message.value.always.null=El valor siempre es nulo
inspection.message.value.always.true=El valor siempre es cierto
inspection.message.value.always.zero=El valor siempre es 0
inspection.message.when.condition.always.false=Nunca se puede acceder a la sucursal 'cuándo'
inspection.migrate.diagnostic.suppression.display.name=Es necesario cambiar el nombre del diagnóstico.
inspection.move.lambda.outside.parentheses.display.name=Argumentos lambda entre paréntesis
inspection.move.suspicious.callable.reference.into.parentheses.display.name=Referencia invocable sospechosa utilizada como resultado lambda
inspection.move.variable.declaration.into.when.display.name=La declaración de variable se puede mover dentro de ''cuando''
inspection.nested.lambda.shadowed.implicit.parameter.display.name=Lambda anidada tiene parámetros implícitos ocultos
inspection.non.exhaustive.when.statement.migration.display.name=Las declaraciones incompletas de "cuándo" están prohibidas desde la versión 1.7
inspection.null.checks.to.safe.call.display.name=Verificación nula que se puede reemplazar con una llamada segura
inspection.nullable.boolean.elvis.action.name=Utilice la prueba de igualdad en lugar de Elvis para pruebas booleanas anulables
inspection.nullable.boolean.elvis.display.name=Se puede utilizar la prueba de igualdad en lugar de Elvis para pruebas booleanas anulables
inspection.object.literal.to.lambda.display.name=Los literales de objetos se pueden convertir en lambdas.
inspection.object.private.property.name.display.name=Convención de nomenclatura de propiedad privada de objetos
inspection.object.property.name.display.name=Convención de nomenclatura de propiedades de objetos
inspection.obsolete.experimental.coroutines.display.name=Las ubicaciones de uso de rutinas experimentales están obsoletas a partir de 1.3
inspection.obsolete.kotlin.js.packages.display.name=El paquete ''kotlin.browser'' min ''kotlin.dom'' está en desuso desde 1.4
inspection.optional.expectation.display.name=La anotación requerida opcionalmente no tiene anotación real
inspection.package.directory.mismatch.display.name=El nombre del paquete no coincide con el directorio que lo contiene
inspection.package.name.display.name=Convención de nomenclatura de paquetes
inspection.platform.extension.receiver.of.inline.display.name=Llamada insegura de función en línea con receptor extendido anulable
inspection.private.property.name.display.name=Convención de nomenclatura de propiedad privada
inspection.progression.resolution.change.migration.display.name=Cambio de resolución a partir de 1.9
inspection.prohibit.jvm.overloads.on.constructors.of.annotation.classes.migration.display.name=A partir de la versión 1.4, la anotación ''@JvmOverloads'' no se puede utilizar en el constructor de una clase anotada.
inspection.prohibit.repeated.use.site.target.annotations.migration.display.name=Las anotaciones repetibles sin ''@Repeatable'' no están permitidas desde la versión 1.4
inspection.prohibit.type.parameters.for.local.variables.migration.display.name=Desde 1.4, las variables locales no pueden tener parámetros de tipo.
inspection.prohibit.use.site.target.annotations.on.super.types.migration.display.name=Las anotaciones en superclases no tienen sentido a partir de 1.4.
inspection.property.name.display.name=Convención de nomenclatura de propiedades
inspection.protected.in.final.display.name=La visibilidad "protegida" es efectivamente "privada" en una clase final.
inspection.public.api.implicit.type.display.name=La declaración de API pública tiene un tipo de retorno implícito.
inspection.recursive.equals.call.display.name=Llamada recursiva igual a
inspection.recursive.property.accessor.display.name=Accesor de propiedad recursivo
inspection.redundant.anonymous.function.description=Crear funciones anónimas duplicadas
inspection.redundant.assequence.call=Llamada duplicada ''asSequence''
inspection.redundant.async.display.name=Llamadas ''asincrónicas'' duplicadas
inspection.redundant.companion.reference.display.name=Referencia complementaria duplicada
inspection.redundant.else.in.if.display.name=Duplicar ''else'' dentro de ''if''
inspection.redundant.elvis.return.null.descriptor=Duplicar ''?\: devolver nulo''
inspection.redundant.elvis.return.null.display.name=Duplicar ''?\: devolver nulo''
inspection.redundant.empty.initializer.block.display.name=Duplicar bloque inicializador vacío
inspection.redundant.enum.constructor.invocation.display.name=Llamadas duplicadas al constructor de enumeraciones
inspection.redundant.explicit.type.display.name=Los tipos especificados explícitamente son redundantes aquí.
inspection.redundant.getter.display.name=Captador de propiedades duplicadas
inspection.redundant.if.display.name=Declaraciones ''si'' duplicadas
inspection.redundant.inner.class.modifier.descriptor=Controlador ''interno'' duplicado
inspection.redundant.inner.class.modifier.display.name=Controlador ''interno'' duplicado
inspection.redundant.label.migration.display.name=Etiquetas duplicadas desde 1.4
inspection.redundant.label.text=Etiqueta duplicada
inspection.redundant.lambda.arrow.display.name=Flechas lambda duplicadas
inspection.redundant.lambda.description=Creando lambdas duplicadas
inspection.redundant.lambda.or.anonymous.function.display.name=Creación duplicada de lambdas o funciones anónimas.
inspection.redundant.lambda.or.anonymous.function.fix=En línea el texto
inspection.redundant.modality.modifier.display.name=Controlador de modalidad redundante
inspection.redundant.not.null.extension.receiver.of.inline.display.name=Los receptores de extensión no nulos de funciones en línea se pueden convertir en anulables
inspection.redundant.nullable.return.type.display.name=Tipo de retorno anulable duplicado
inspection.redundant.object.type.check.display.name=Comprobación de tipos duplicados para objetos
inspection.redundant.require.not.null.call.display.name=Llamadas duplicadas ''requireNotNull'' o ''checkNotNull''
inspection.redundant.return.label.display.name=Etiqueta de ''devolución'' duplicada
inspection.redundant.run.catching.display.name=Llamada ''runCatching'' duplicada
inspection.redundant.sam.constructor.display.name=Constructor SAM duplicado
inspection.redundant.semicolon.display.name=Punto y coma duplicado
inspection.redundant.setter.display.name=Establecedor de propiedades duplicadas
inspection.redundant.suspend.modifier.display.name=Controlador ''suspendido'' duplicado
inspection.redundant.unit.expression.display.name=Duplicar ''Unidad''
inspection.redundant.unit.return.type.action.name=Eliminar el tipo de retorno 'Unidad' innecesario
inspection.redundant.unit.return.type.display.name=Tipo de retorno ''Unidad'' duplicado
inspection.redundant.value.argument.annotation=El argumento del valor coincide con el valor predeterminado del parámetro ''{0}''
inspection.redundant.value.argument.display.name=Argumento de valor innecesario
inspection.redundant.visibility.modifier.display.name=Controladores de visibilidad duplicados
inspection.redundant.with.display.name=Duplicar llamadas ''con''
inspection.remove.curly.braces.from.template.display.name=Llaves duplicadas en plantilla de cadena
inspection.remove.empty.class.body.display.name=Reemplazo de un cuerpo de clase vacío
inspection.remove.empty.parentheses.from.annotation.entry.display.name=Elimine los paréntesis innecesarios.
inspection.remove.empty.parentheses.from.lambda.call.action.name=Eliminar paréntesis innecesarios de llamadas a funciones con lambdas
inspection.remove.empty.parentheses.from.lambda.call.display.name=Eliminar paréntesis innecesarios de llamadas a funciones con lambdas
inspection.remove.empty.primary.constructor.display.name=Eliminar el constructor predeterminado vacío
inspection.remove.empty.secondary.constructor.body.display.name=Eliminar el cuerpo del constructor vacío
inspection.remove.explicit.super.qualifier.display.name=Normalización de supertipo innecesaria
inspection.remove.explicit.type.arguments.display.name=Argumentos de tipo innecesarios
inspection.remove.for.loop.indices.display.name=Índice de bucle no utilizado
inspection.remove.redundant.backticks.display.name=Elimine las comillas invertidas redundantes.
inspection.remove.redundant.calls.of.conversion.methods.display.name=Eliminar llamadas duplicadas a métodos de conversión
inspection.remove.redundant.qualifier.name.display.name=Elimine los nombres de calificadores duplicados.
inspection.remove.redundant.spread.operator.display.name=Operador de extensión redundante
inspection.remove.setter.parameter.type.display.name=Tipos de parámetros de establecimiento duplicados
inspection.remove.single.expression.string.template.display.name=Eliminar plantillas de cadenas duplicadas
inspection.remove.to.string.in.string.template.display.name=Eliminar llamadas redundantes ''toString()'' dentro de plantillas de cadenas
inspection.replace.array.equality.op.with.arrays.equals.display.name=Reemplace ''\=\='' con ''Arrays.equals''
inspection.replace.array.of.with.literal.display.name=Es posible reemplazar la llamada ''arrayOf'' con un literal de matriz [...]
inspection.replace.assert.boolean.with.assert.equality.display.name=Reemplace la afirmación booleana con la afirmación de igualdad.
inspection.replace.associate.function.display.name=Reemplace ''asociar'' con ''asociarPor'' o ''asociarCon''
inspection.replace.call.with.binary.operator.display.name=Se puede convertir a operadores binarios.
inspection.replace.collection.count.with.size.display.name=Los agregados de la colección se pueden convertir al tamaño
inspection.replace.get.or.set.display.name=Llamada explícita ''get'' o ''set''
inspection.replace.guard.clause.with.function.call.display.name=Reemplace la cláusula de protección con una llamada de función en Kotlin
inspection.replace.isempty.with.ifempty.display.name=Puede reemplazar la condición 'si' con una llamada lambda
inspection.replace.java.static.method.with.kotlin.analog.display.name=Conversión de métodos estáticos de Java a análogos de Kotlin
inspection.replace.manual.range.with.indices.calls.display.name=Convertir un rango manual para indexar o repetir colecciones
inspection.replace.mapIndexed.with.list.generator.display.name=Convirtiendo 'mapIndexed' en un generador de listas
inspection.replace.negated.is.empty.with.is.not.empty.display.name=Reemplace ''isEmpty''/''isBlank'' negado por ''isNotEmpty''/''isNotBlank''
inspection.replace.not.null.assertion.with.elvis.return.display.name=Reemplace ''\!\!'' por ''?\: return''.
inspection.replace.put.with.assignment.display.name=''map.put()'' se puede convertir en asignación
inspection.replace.range.start.end.inclusive.with.first.last.display.name=Reemplace el rango ''inicio'' o ''endInclusive'' con ''primero'' o ''último''
inspection.replace.range.to.with.rangeUntil.display.name=Las llamadas a 'rangeTo' o '..' deben reemplazarse por '..<'
inspection.replace.range.to.with.until.display.name=Las llamadas ''rangeTo'' o ''..'' se pueden reemplazar con ''hasta''
inspection.replace.readline.with.readln.display.name=ReadLine' se puede reemplazar con 'readln' o 'readlnOrNull
inspection.replace.size.check.with.is.not.empty.display.name=Cambie la verificación de tamaño a ''isNotEmpty()''
inspection.replace.size.zero.check.with.is.empty.display.name=Reemplace la verificación de tamaño cero con ''isEmpty()''
inspection.replace.string.format.with.literal.display.name=Reemplazar con plantilla de cadena
inspection.replace.substring.with.drop.last.display.name=Reemplace la llamada ''subcadena'' con una llamada ''dropLast''.
inspection.replace.substring.with.indexing.operation.display.name=Reemplace la llamada ''subcadena'' con una llamada a la operación de índice.
inspection.replace.substring.with.substring.after.display.name=Reemplace la llamada ''subcadena'' con una llamada ''subcadenaDespués''.
inspection.replace.substring.with.substring.before.display.name=Reemplace la llamada ''subcadena'' con una llamada ''subcadenaAntes''.
inspection.replace.substring.with.take.display.name=Reemplace la llamada ''subcadena'' con una llamada ''take''.
inspection.replace.to.string.with.string.template.display.name=Reemplace ''toString'' con una plantilla de cadena.
inspection.replace.to.with.infix.form.display.name=Convertir ''a'' a formato infijo
inspection.replace.until.with.rangeUntil.operator.display.name=Reemplace 'hasta' con el operador '..<'
inspection.replace.with.enum.map.display.name=Reemplácelo con EnumMap.
inspection.replace.with.ignore.case.equals.display.name=Reemplazar con ''equals(..., ignoreCase \= true)''
inspection.replace.with.import.alias.display.name=Puede reemplazar un nombre completo con un alias de importación existente
inspection.replace.with.operator.assignment.display.name=Asignación que se puede cambiar mediante la asignación del operador
inspection.replace.with.string.builder.append.range.display.name=Llame a 'StringBuilder.append(CharArray, offset, len)' en JVM
inspection.restrict.return.statement.target.migration.display.name=A partir de 1.4, las etiquetas de destino no indican funciones
inspection.safe.cast.with.return.display.name=Los lanzamientos seguros con "retorno" deben reemplazarse con comprobaciones de tipo "si"
inspection.scope.function.conversion.display.name=Las funciones de rango se pueden convertir en otras funciones.
inspection.self.assignment.display.name=Autoasignación de variables
inspection.self.reference.constructor.parameter.display.name=El constructor tiene un parámetro de autorreferencia no nulo.
inspection.setter.backing.field.assignment.display.name=Un campo de respaldo existente no se asigna como definidor.
inspection.simple.redundant.let.display.name=Llamadas "let" duplicadas basadas en el receptor
inspection.simplifiable.call.chain.display.name=Puede simplificar las cadenas de llamadas para tipos de colección.
inspection.simplifiable.call.display.name=Las llamadas a funciones de biblioteca se pueden simplificar
inspection.simplifiable.scope.function.display.name=Puede simplificar las funciones de rango con forEach anidado
inspection.simplify.assert.not.null.display.name=Las llamadas ''assert'' se pueden reemplazar con ''\!\!'' o ''?\:''
inspection.simplify.boolean.with.constants.display.name=Expresiones booleanas simplificables
inspection.simplify.negated.binary.expression.display.name=Expresiones booleanas negadas que se pueden simplificar
inspection.simplify.when.with.boolean.constant.condition.display.name=''cuándo'' se puede simplificar
inspection.sort.modifiers.display.name=Orden de controlador no estándar
inspection.suspend.function.on.coroutine.scope.display.name=CoroutineContext oscurecido por el receptor CoroutineScope en función de suspensión
inspection.suspicious.as.dynamic.display.name=Llamada sospechosa al miembro ''asDynamic''
inspection.suspicious.collection.reassignment.display.name=La asignación aumentada crea una nueva colección en el interior.
inspection.suspicious.equals.combination.display.name=Combinación sospechosa de \=\= y \=\=\=
inspection.suspicious.var.property.display.name=Propiedad sospechosa ''var'': su colocador no afecta el resultado de su captador.
inspection.test.function.name.display.name=Convención de nomenclatura de funciones de prueba
inspection.this.class.does.not.have.a.constructor=Llamada de constructor prohibida
inspection.trailing.comma.add.line.break=Agregar salto de línea
inspection.trailing.comma.add.trailing.comma=Agregar una coma al final
inspection.trailing.comma.comma.loses.the.advantages.in.this.position=En esta posición se pierde el beneficio de la coma.
inspection.trailing.comma.display.name=Se recomienda coma al final
inspection.trailing.comma.fix.comma.position=Corregir la posición de la coma
inspection.trailing.comma.missing.line.break=Falta salto de línea
inspection.trailing.comma.missing.trailing.comma=Falta la coma final
inspection.trailing.comma.remove.trailing.comma=Elimine las comas finales.
inspection.trailing.comma.report.also.a.missing.comma=Informe también las comas faltantes o los saltos de línea
inspection.trailing.comma.useless.trailing.comma=Coma final innecesaria
inspection.unlabeled.return.inside.lambda.display.name=Retorno sin etiqueta dentro de lambda
inspection.unnecessary.opt_in.annotation.display.name=Anotación '@OptIn' innecesaria
inspection.unnecessary.opt_in.redundant.annotation=Los marcadores de suscripción están duplicados. No se ha utilizado la API experimental correspondiente.
inspection.unnecessary.opt_in.redundant.marker=Los marcadores de suscripción están duplicados. La API experimental marcada ''{0}'' ha quedado obsoleta.
inspection.unnecessary.opt_in.remove.annotation.fix.family.name=Eliminar anotación
inspection.unnecessary.opt_in.remove.marker.fix.family.name=Eliminar marcador de suscripción
inspection.unnecessary.variable.display.name=Variables locales innecesarias
inspection.unnecessary.variable.option.report.immediately.returned.variables=Variables del informe devueltas inmediatamente
inspection.unsafe.cast.from.dynamic.display.name=Conversión implícita (insegura) de tipo dinámico
inspection.unused.equals.display.name=Expresión igual a obsoleta
inspection.unused.lambda.expression.body.display.name=Valor de retorno no utilizado de la función con cuerpo de expresión lambda
inspection.unused.main.parameter.display.name=No se requieren parámetros clave
inspection.unused.receiver.parameter=El parámetro del receptor no se utiliza en absoluto.
inspection.unused.receiver.parameter.display.name=Parámetros del receptor obsoletos
inspection.unused.result.of.data.class.copy=Resultado de copiar clases de datos no utilizadas
inspection.unused.symbol.display.name=Símbolo no utilizado
inspection.unused.unary.operator.display.name=Operador unario obsoleto
inspection.use.expression.body.display.name=Aquí se recomienda la sintaxis del cuerpo de la expresión:
inspection.use.property.access.syntax.display.name=Llamadas a accesores que pueden reemplazarse con declaraciones de acceso a propiedades
inspection.use.with.index.display.name=Las variables de índice incrementadas manualmente se pueden reemplazar usando ''withIndex()''
inspection.useless.call.on.collection.display.name=Llamadas innecesarias a tipos de cobranza
inspection.useless.call.on.not.null.display.name=Llamada innecesaria a tipo no nulo
inspection.verbose.nullability.and.emptiness.call=Reemplace la siguiente verificación con una llamada a ''{0}()''
inspection.verbose.nullability.and.emptiness.display.name=Prolongada nulabilidad y comprobación de espacios en blanco
inspection.warning.on.main.unused.parameter.migration.display.name=''args'' en ''main'' está en desuso desde 1.4
inspection.when.with.only.else.action.name=Simplifique 'cuándo' a una sola rama 'más'
inspection.when.with.only.else.display.name=Simplifica porque ''cuando'' solo tiene una rama ''else''
inspection.wrap.unary.operator.display.name=Usar operadores unarios ambiguos con constantes numéricas
intention.add.import.alias.group.name=Agregar alias de declaración de importación
intention.change.package.text=Cambiar paquete
intention.convert.lambda.line=Convertir a lambda en {0,choice,0\#single|1\#multiple} líneas
intention.extract.declarations.from.file.text=Extraer declaración del archivo actual
intention.extract.declarations.from.file.text.details=''{0}'' {1,choice, 0#| en el archivo actual 1# y extraer subclases }
intention.flow.on.dispatchers.io=\ Flujo 'Dispatchers.IO'
intention.name.specify.supertype=Especificar tipo de padre
intention.name.use.correct.parameter.name=Utilice nombres de parámetros correctos
intention.switch.context.to.dispatchers.io=Cambiar al contexto 'Dispatchers.IO'
intention.trailing.comma.custom.text=La herramienta de formato tiene por defecto la coma final en {0,choice,0\#enable|1\#disable}
intention.trailing.comma.text=Activar/desactivar comas finales en herramientas de formato
intention.wrap.in.with.context=Salto de línea con 'withContext'
interface=Interfaz
interface.member.dependency.required.by.interfaces=Requerido para {0,choice,1#interface|2#interface}
interface.should.be.external=La interfaz debe ser externa.
internal.toggle.throwing.cached.pce.title=Interno: Conversión de lanzamiento de PCE en caché
introduce.0.as.subject.0.when=Insertando ''{0}'' como destino de ''cuándo''.
introduce.anonymous.parameter.fix.family.name=Insertar parámetros anónimos
introduce.backing.property=Propiedad de respaldo
introduce.constant=Insertar constante
introduce.import.alias=Insertar alias de declaraciones de importación
introduce.property=Insertar propiedad
introduce.type.parameter=Insertar parámetro de tipo
introduce.type.parameter.to.declaration=Insertar parámetros de tipo en las declaraciones.
introduce.variable=Insertar variable
introduce.when.subject=Inserte el objetivo ''cuándo''.
invert.if.condition=Invierte la condición ''si''.
it.s.prohibited.to.call.0.with.min.value.step.since.1.3=A partir de la versión 1.3, está prohibido llamar a {0} con el paso MIN_VALUE.
iterate.over.0=Repetir ''{0}''
iterate.over.collection=Repetir colección
java.collections.static.method.call.should.be.replaced.with.kotlin.stdlib=Las llamadas a métodos estáticos de la colección Java deben reemplazarse con Kotlin stdlib.
java.map.foreach.method.call.should.be.replaced.with.kotlin.s.foreach=Debe reemplazar la llamada al método Java Map.forEach con forEach de Kotlin.
join.declaration.and.assignment=Combinando declaración y cesión
join.with.initializer.fix.text=Combinado con un inicializador.
junit.static.methods=Métodos estáticos JUnit
kdoc.comment.unresolved=Sin resolver
kdoc.section.title.author=Autor
kdoc.section.title.constructor=Constructor
kdoc.section.title.parameters=Parámetros
kdoc.section.title.properties=Propiedades
kdoc.section.title.receiver=Receptor
kdoc.section.title.returns=Devoluciones
kdoc.section.title.samples=Muestras
kdoc.section.title.see.also=Temas relacionados
kdoc.section.title.since=Hora de inicio
kdoc.section.title.suppress=Suprimir
kdoc.section.title.throws=Procesando
kotlin.call.chains.hints=Kotlin: muestra sugerencias incrustadas para la cadena de llamadas
kotlin.compiler.configurable=Compilador kotlin
kotlin.dist.downloading.failed.group.name=Error en la descarga de Kotlin dist
kotlin.external.compiler.updates.notification.group.name=Actualización del compilador externo de Kotlin disponible
kotlin.jps.plugin.group.name=Complemento Kotlin JPS
kotlin.lambdas.hints=Kotlin: Mostrar sugerencia de incrustación para lambda
kotlin.lambdas.hints.hints.lambda.receivers.parameters=Kotlin: muestra sugerencias incrustadas para receptores y parámetros implícitos
kotlin.lambdas.hints.hints.lambda.return=Kotlin: muestra sugerencias incrustadas para expresiones de retorno
kotlin.references.types.hints=Kotlin: muestra sugerencias incrustadas para tipos
kotlin.references.types.hints.hints.type.function.parameter=Kotlin: muestra sugerencias incrustadas para tipos de parámetros de función
kotlin.references.types.hints.hints.type.function.return=Kotlin: muestra sugerencias incrustadas para el tipo de retorno de función
kotlin.references.types.hints.hints.type.property=Kotlin: muestra sugerencias incrustadas para tipos de propiedades
kotlin.references.types.hints.hints.type.variable=Kotlin: muestra sugerencias incrustadas para tipos de variables locales
kotlin.script.definitions.model.name.autoReloadScriptDependencies=Recarga automática
kotlin.script.definitions.model.name.autoReloadScriptDependencies.description=Habilite la recarga automática para cargar automáticamente la configuración del script cuando los archivos cambien.
kotlin.script.definitions.model.name.is.enabled=Habilitado
kotlin.script.definitions.model.name.name=Nombre
kotlin.script.definitions.model.name.pattern.extension=Patrón/Extensión
kotlin.script.definitions.title=Administrar definiciones de scripts
kotlin.script.in.beta.stage=Las secuencias de comandos de Kotlin se encuentran actualmente en versión beta
kotlin.script.in.beta.stage.link=Https://kotlinlang.org/docs/components-stability.html#stability-levels-explained
kotlin.script.in.project.sources=No se garantiza la compatibilidad con IDE para scripts incluidos en el código fuente del proyecto.
kotlin.script.in.project.sources.1.9=<html>El script no debe estar dentro de la raíz fuente. A partir de Kotlin 1.9, los scripts se ignoran durante la compilación del módulo.</html>
kotlin.script.in.project.sources.allow=Permiso...
kotlin.script.in.project.sources.hide=Esconder
kotlin.script.in.project.sources.later=Decide después
kotlin.script.in.project.sources.link=Https://youtrack.jetbrains.com/issue/KTIJ-19432
kotlin.script.in.project.sources.move=Ir a...
kotlin.script.lookup.definitions=Buscando la definición del script Kotlin...
kotlin.script.sources.index=Índice
kotlin.script.sources.not.yet.indexed=Los archivos fuente no están indexados para reducir el tiempo de inicio del proyecto.
kotlin.script.warning.more.info=Más información
kotlin.scripting.configurable=Secuencia de comandos Kotlin
kotlin.values.hints=Mostrar sugerencias incrustadas para valores
kotlin.values.hints.kotlin.values.ranges=Kotlin: Mostrar sugerencia de incrustación para el rango
label.text.default.receiver.value=Valor predeterminado del receptor (&D)\:
label.text.destination=Objetivo:
label.text.destination.directory=Directorio de destino\:
label.text.file=Archivo:
label.text.file.name=&Nombre del archivo\:
label.text.introduce.as=Insertar &yo\:
label.text.move.expect.actual.counterparts=Mover correspondencia esperada/real
label.text.name=Nombre(&N)\:
label.text.package=Paquete:
label.text.package.name=&Nombre del paquete\:
label.text.receiver.type=Tipo de receptor (&T)\:
label.text.source.sets=Conjunto de fuentes:
label.text.target.file.name=Nombre del archivo de destino\:
label.text.to.class=A clase\:
label.text.to.file=Archivo de destino &\:
label.text.to.object=Al objeto\:
label.text.to.package=Como &paquete\:
label.text.type=Escriba &T\:
label.text.visibility=&Visibilidad\:
lambda.argument.0.be.moved.out=Saque el argumento lambda {0} del paréntesis{0}.
leaking.this.in.constructor.of.enum.class.0.with.overridable.members=Filtrar ''esto'' en el constructor de la clase de enumeración {0} (con miembros reemplazables)
leaking.this.in.constructor.of.non.final.class.0=Filtrar ''esto'' en el constructor de la clase no final {0}
let.0.1=Deje que {0} haga {1}.
let.type.implement.interface=Hace que el tipo implemente una interfaz.
lift.assignment.out.fix.text.0=Eliminar la asignación de ''{0}''.
lift.assignment.out.of.try.expression=Eliminar la asignación de la expresión ''try''.
lift.function.call.out.of.if=Eliminar llamada de función de 'si'
lift.function.call.out.of.when=Eliminar llamada de función de 'cuando'
lift.return.out.fix.text.0=Eliminar devolución de ''{0}''
lift.return.out.of.if.expression=Eliminar el retorno de la expresión ''if''
listbox.import.package=Paquete
listbox.import.with.subpackages=Incluir subpaquetes
livetemplate.description.anonymous=Clase anónima
livetemplate.description.closure=Cierre (función sin nombre)
livetemplate.description.exfun=Función de extensión
livetemplate.description.exval=Propiedad extendida de solo lectura
livetemplate.description.exvar=Propiedades extendidas de lectura/escritura
livetemplate.description.fun0=Función sin parámetros
livetemplate.description.fun1=Función con 1 parámetro
livetemplate.description.fun2=Función con 2 parámetros
livetemplate.description.ifn=Inserte la expresión '' if null ''.
livetemplate.description.inn=Inserte la expresión '' si no es nulo ''.
livetemplate.description.interface=Interfaz
livetemplate.description.iter=Iterar sobre un elemento iterable (bucle for-in).
livetemplate.description.main=Función main ()
livetemplate.description.maina=Función principal (argumentos)
livetemplate.description.singleton=Único
livetemplate.description.soutp=Salida de los nombres y valores de los parámetros de la función a System.out.
livetemplate.description.void=La función no devuelve nada
local.variable=Variable local
logger.initialized.with.foreign.class=Registrador inicializado con clase externa ''{0}''
looking.for.usages.and.conflicts=Buscando ubicaciones de uso y conflictos...
looking.for.usages.in.java.files=Buscando usos en un archivo Java...
loop.can.be.replaced.with.stdlib.operations=Puede reemplazar bucles con operaciones stdlib
loop.parameter.0.is.unused=El parámetro de bucle ''{0}'' está en desuso.
loop.to.call.fix.family.name=Operación de conversión a stdlib
loop.to.call.fix.family.name2=Reemplazar con operaciones stdlib usando ''asSequence()''
make.0=Crear {0}.
make.0.1=Hacer de ''{0}'' un {1}
make.0.1.explicitly=Convirtiendo explícitamente ''{0}'' en {1}.
make.0.an.annotation.class=Crear clase anotada ''{0}''
make.0.explicitly=Haga {0} explícito.
make.0.in.1.open=Abra ''{0}'' en {1}.
make.0.not.1=Haga que {0} no sea {1}.
make.class.an.annotation.class=Convertir la clase en una clase de anotación
make.constructor.parameter.a.property.0=Convierta el parámetro del constructor en la propiedad {0}.
make.member.static.quickfix=Establecer ''{0}'' como estático
make.not.nullable=Hazlo no nulo.
make.open=Crear abierto
make.open.fix.text=Abre la clase.
make.primary.constructor.0=Crear constructor predeterminado {0}
make.private.and.0.1=Privado y haga {0} ''{1}''.
make.private.fix.text=Establecer en privado
make.type.parameter.reified.and.function.inline=Materializar parámetros de tipo y funciones en línea.
making.member.static=Hacer miembros estáticos...
map.get.with.not.null.assertion.operator=Map.get() con operador de aserción no nulo (\!\!)
map.put.should.be.converted.to.assignment=Necesitamos convertir map.put() en una tarea.
mark.as.deprecated.level.deprecationlevel.hidden=Marcado como @Deprecated(..., nivel \= DeprecationLevel.HIDDEN).
max.functions.to.visit=Función máxima a referencia
maximum.count.of.applied.refactoring.before.validity.check=Número máximo de refactorizaciones aplicadas antes de la validación
may.contain.only.letters.and.digits=Sólo puede contener letras y números.
may.contain.only.letters.digits.or.underscores=Sólo puede contener letras, números o guiones bajos.
member.info.abstract.0=Resumen {0}
member.info.companion.0=Compañero {0}
merge.else.if=Fusionar declaraciones ''else if''
merge.if.s=Fusionar declaraciones ''si''
message.change.signature.is.not.applicable.to.dynamically.invoked.functions=Los cambios de firma no se aplican a funciones llamadas dinámicamente.
message.do.not.show.for.local.variables.in.future=Posteriormente no se da ninguna indicación para las variables locales.
message.text.property.receiver.type.cannot.be.resolved=El tipo de receptor de propiedad ''{0}'' no se pudo resolver.\n¿Quiere continuar?
message.text.property.type.cannot.be.resolved=No se pudo resolver el tipo de propiedad ''{0}''.\n¿Quieres continuar?
message.text.return.type.cannot.be.resolved=No se pudo resolver el tipo de devolución ''{0}''.\n¿Quieres continuar?
message.type.for.cannot.be.resolved=No se pudo resolver el tipo ''{0}'' de ''{1}''.\n¿Quieres continuar?
methods.are.absent.in.coroutines.class.since.1.3=Los métodos desaparecen de las clases de rutina a partir de 1.3.
microservices.url.path.inlay.hints=Kotlin: Mostrar sugerencia incrustada para la ruta URL
might.be.const=Puede ser "constante".
migrate.type.parameter.list.syntax=Migrar la sintaxis de la lista de parámetros de tipo.
migrate.unsupported.yield.syntax=Migrar declaraciones de rendimiento no admitidas.
minimal.line.count=Número mínimo de líneas
missing.documentation=Falta el documento.
modifiers.should.follow.annotations=El controlador debe venir después de la anotación.
move.annotation.to.receiver.type=Mover la anotación al tipo de receptor
move.else.branch.to.the.end=Mueve la rama else hasta el final.
move.lambda.argument.into.parentheses=Mover los argumentos lambda entre paréntesis
move.lambda.argument.out.of.parentheses=Saque el argumento lambda del paréntesis.
move.members.from=Mueva los siguientes miembros:
move.out.of.companion.object=Mover fuera del objeto complementario
move.refactoring.error.text.cannot.perform.refactoring.since.the.following.files.already.exist=No se puede realizar la refactorización porque ya existe el siguiente archivo:\n\n
move.refactoring.test=Mover pruebas de refactorización
move.refactoring.testing=Mover pruebas de refactorización
move.reference.into.parentheses=Mover referencias dentro de paréntesis
move.to.class.body=Ir al cuerpo de la clase
move.to.companion.object=Ir dentro del objeto complementario
move.to.companion.object.command=Ir al objeto complementario
move.to.constructor=Ir al constructor
move.to.constructor.parameters=Vaya a los parámetros del constructor.
move.to.top.level=Ir al nivel superior
move.type.parameter.constraint.to.where.clause=Mueva las restricciones de los parámetros de tipo a la cláusula ''dónde''.
move.unary.operator.to.previous.line.fix.text=Mover operador unario a la línea anterior
move.variable.declaration.into.when=Mueva la declaración de variable a ''cuándo''.
moving.to.companion.object=Moviéndose al objeto complementario...
name=Nombre(&N)\:
name.extract.interface=Extracción de interfaz
name.introduce.import.alias=Insertar alias de declaraciones de importación
name.introduce.lambda.parameter=Insertar parámetros Lambda
name.introduce.parameter1=Insertar parámetro
name.introduce.type.alias=Insertar alias de tipo
name.specify.supertype.command.title=Especificar tipo de padre
naming.convention.will.be.violated.after.rename=Cambiar el nombre viola las reglas de nomenclatura.
negated.operation.can.be.simplified=Las operaciones negadas se pueden simplificar
nested.1.call.in.0.could.be.simplified.to.2=Las llamadas anidadas ''{1}'' en ''{0}'' se pueden simplificar a {2}
non.canonical.modifiers.order=Orden de controlador no estándar
non.external.classifier.extending.state.or.props.name=Clasificadores no externos que amplían State o Props
not.found.in.0.files=No encontrado en {0} archivos.
nothing.to.do=No hay nada que hacer.
notification.navigation.to.overriding.classes=No puede navegar a una clase primordial durante una actualización de índice
notification.text.kotlin.js.compiler.body=Reduzca el tamaño del paquete de su aplicación y genere automáticamente definiciones de TypeScript (d.ts) utilizando el nuevo compilador Kotlin/JS IR.
notification.text.kotlin.js.compiler.learn.more=Aprender más
notification.text.kotlin.js.compiler.link=Https://kotl.in/jsirstable
notification.text.kotlin.js.compiler.title=¡Kotlin/JS IR es estable para la versión 1.8.0 y superior!
null.checks.replaceable.with.safe.calls=Verificación nula reemplazable con llamada segura
null.checks.to.safe.call.check.fix.text=Reemplace las comprobaciones nulas encadenadas con llamadas seguras.
number.of.attempts.then.files.in.project.0=Número de intentos > Archivos en proyecto, {0}
object.0=Objeto "{0}"
object.or.top.level.property=Objeto o propiedad de nivel superior
object.private.property=Propiedades privadas de objetos
object.should.be.external.interface=El objeto debe ser una interfaz externa.
obsolete.coroutine.usage.fix.family.name=Se corrigió la ubicación de uso de rutina experimental.
obsolete.coroutine.usage.in.whole.fix.family.name=Modifique dónde se utilizan las rutinas experimentales en su proyecto
obsolete.kotlin.js.packages.usage.in.whole.fix.family.name=Corrija el uso de los paquetes ''kotlin.dom'' y ''kotlin.browser'' en su proyecto.
obsolete.package.usage.fix.family.name=Arreglar el uso del paquete ''{0}''
one.line.return=Devolver una línea
open.moved.members.in.editor=Abrir miembro movido en el editor
open.moved.method.in.editor=Abrir un método movido en el editor
optimize.imports=Optimización de declaración import
optimize.imports.collect.unused.imports=Recopilar declaraciones de importación no utilizadas
optimize.imports.task.removing.redundant.imports=Eliminar declaraciones de importación duplicadas
optionally.expected.annotation.has.no.actual.annotation.in.module.0.for.platform.1=Una anotación opcional requerida en el módulo {0} para la plataforma {1} no tiene una anotación real
overridden.marker.implementation=Implementado en <br/>
overridden.marker.implementations.choose.implementation.find.usages=Propiedad reemplazada de {0}
overridden.marker.implementations.choose.implementation.title=Selección de implementación de {0}
overridden.marker.implementations.multiple=Hay implementaciones.
overridden.marker.overrides=Anulado desde. <br/>
overridden.marker.overrides.choose.implementation.find.usages=Mayor implementación de {0}
overridden.marker.overrides.choose.implementation.title=Elija la implementación principal de {0}
overridden.marker.overrides.multiple=Anulado en subclases.
override.declaration.choose.to.delete=Elija un elemento para eliminar.
override.declaration.delete.multiple.parameters={0} es parte de la jerarquía del método. ¿Está seguro de que desea eliminar varios parámetros?
override.declaration.member=Miembro
override.declaration.unused.overriding.methods.description=Tiene un miembro obsoleto que reemplaza un método que acaba de eliminar
override.declaration.unused.overriding.methods.title=Miembro superior obsoleto
override.declaration.x.implements.y=Implementar {0} en {1} a {2} en {3}.
override.declaration.x.in.y={0} de {1}
override.declaration.x.overrides.y.in.class.list={0} anula la declaración en la siguiente clase/interfaz, {1}. ¿Le gustaría {2} declaraciones predeterminadas?
package.0.already.contains.1=El paquete ''{0}'' ya contiene {1}
package.name=Nombre del paquete
package.usages.are.obsolete.since.1.4=El uso del paquete ''{0}'' está obsoleto a partir de 1.4
parameter.0=Parámetro "{0}"
parameter.hints.old=Kotlin: muestra sugerencias incrustadas para parámetros
parameter.name.is.invalid=El nombre del parámetro ''{0}'' no es válido
parameter.name.prompt=Nombre del parámetro &M\:
parameter.type.is.invalid=El tipo de parámetro ''{0}'' no es válido
parameter.types.are.not.denotable=El método no se puede extraer para los siguientes tipos porque no son visibles en el ámbito de destino:
parameter.used.in.declaration.body.warning=''{0} se utiliza en el cuerpo de la declaración
parentheses.should.be.removed=Debes eliminar los paréntesis.
pass.outer.class.instance.as.parameter=Pasar una instancia de una clase externa como parámetro
perform.refactoring=Realizar refactorización...
placeholder.count.matches.argument.count.fewer.problem.descriptor=Hay menos argumentos ({0}) que el número de marcadores de posición especificados ({1}) #loc
placeholder.count.matches.argument.count.more.problem.descriptor=#loc Hay más argumentos ({0}) que el número de marcadores de posición especificados ({1})
popup.title.choose.supertype=Seleccionar tipo de padre
popup.title.elements=Elemento
popup.title.expressions=Expresión
popup.title.types=Tipo
predefined.configuration.all.methods.of.the.class=Todos los métodos en la clase
predefined.configuration.all.vars.of.the.class=Todas las var/vals en clase
predefined.configuration.all.vars.of.the.object=Cualquier var/val en el objeto u objeto complementario
predefined.configuration.also.match.vals=Tanto var como val coinciden
predefined.configuration.annotations=Anotación
predefined.configuration.anonymous.class=Clase anónima
predefined.configuration.array.access=Acceso a la matriz
predefined.configuration.assert.not.null=Operador de aserción no nulo
predefined.configuration.assignments=Admisiones universitarias
predefined.configuration.casts=Encasillar
predefined.configuration.class.annotation=Clase comentada
predefined.configuration.comments.containing.word=Comentarios que contienen palabras dadas
predefined.configuration.companion.object.method.calls=Llamada a método desde objeto complementario
predefined.configuration.do.while=Hacer... mientras bucle
predefined.configuration.elvis=Operador de elvis
predefined.configuration.for=En bucle
predefined.configuration.function.annotation=Funciones anotadas
predefined.configuration.function.explicit.inferred.type=Tipos explícitos e inferidos
predefined.configuration.function.signature=Firma de función
predefined.configuration.ifs=Si
predefined.configuration.instance=Instancia
predefined.configuration.kdoc.tag=Etiqueta KDoc
predefined.configuration.lambda=Expresión lambda
predefined.configuration.method.calls=Llamada al método
predefined.configuration.object.companion.object=Crear objetos y objetos complementarios.
predefined.configuration.properties.getter=Propiedades con captadores explícitos
predefined.configuration.safe.call.operator=Operador de llamada segura
predefined.configuration.string.literals=Literal de cadena
predefined.configuration.strings=Cadena
predefined.configuration.strings.with.long.template=Cadena con plantilla larga
predefined.configuration.trys=Intentar
predefined.configuration.vars.of.given.type=Var y val de tipo dado
predefined.configuration.when=Cuando la expresión
predefined.configuration.while=Mientras bucle
premature.end.of.template=La plantilla no está completada correctamente.
presentation.text.for.receiver.in.container.paren=(objetivo {0} dentro de {1})
presentation.text.for.receiver.in.container.paren.no.brackets=Objetivo: {0} dentro de {1}
presentation.text.in.container={0} de {1}
presentation.text.in.container.paren=(dentro de {0})
presentation.text.in.container.paren.no.brackets={0} mi
presentation.text.object.in.container={0} mi objeto
presentation.text.paren=({0})
presentation.text.paren.no.brackets={0}
print.should.be.replaced.with.logging=Puede que sea mejor reemplazar <code>{0}</code> con una función de registro más potente.
private.data.class.constructor.is.exposed.via.the.generated.copy.method=El constructor de la clase de datos privados se expone mediante el método ''copia'' generado.
private.property=Propiedades privadas
progress.finding.implicit.nothing.s=No encontrar nada implícito
progress.looking.up.add.annotation.usage=Encontrar dónde utilizar las anotaciones...
progress.looking.up.sealed.subclass.usage=Buscando dónde usar la subclase sellada...
progress.title.analyze.extraction.data=Extraer análisis de datos...
progress.title.calculating.type=Tipo de cálculo...
progress.title.collect.hierarchy=Recopilar jerarquía ''{0}''...
progress.title.searching.for.expected.actual=Buscando esperado/real…
project.view.class.error.name=Nombre no proporcionado
project.view.class.initializer=\ inicializador de clase
project.view.expression=Expresión
property=Propiedades
property.0=Propiedad "{0}"
property.has.an.actual.declaration.in.the.class.constructor=La declaración real de la propiedad está en el constructor de la clase.
property.in.external.interface.should.be.var=Las propiedades de la interfaz externa deben ser var.
property.is.explicitly.assigned.to.parameter.0.can=Puede declarar una propiedad directamente en el constructor asignándola explícitamente al parámetro {0}.
property.overloaded.in.child.class.constructor=Propiedades sobrecargadas en constructores de subclases
protected.visibility.is.effectively.private.in.a.final.class=La visibilidad "protegida" es efectivamente "privada" en una clase final.
provide.return.value=Proporcionar un valor de retorno
put.arguments.on.one.line=Coloque los argumentos en una línea.
put.arguments.on.separate.lines=Colocar argumentos en líneas separadas
put.calls.on.separate.lines=Realizar llamadas en líneas separadas
put.expressions.on.separate.lines=Colocar expresiones en líneas separadas
put.parameters.on.one.line=Colocar parámetros en una línea.
put.parameters.on.separate.lines=Colocar parámetros en líneas separadas
quick.doc.no.documentation=No hay documentación disponible.
quick.doc.section.deprecated=Funciones obsoletas\:
quick.doc.section.java.declaration=Declaración de Java\:
quick.doc.section.replace.with=Reemplazar con\:
quick.doc.text.enum.ordinal=Enum constante ordinal\: {0}
quick.doc.text.lateinit='' lateinit '' es el <a href\="https\://kotlinlang.org/docs/reference/properties.html\#late-initialized-properties-and-variables"> constructor Permite la inicialización de propiedades externas no nulas</a>.
quick.doc.text.tailrec='' tailrec '' hace que las funciones <a href\="https\://kotlinlang.org/docs/reference/functions.html\#tail-recursive-functions"> tail sean recursivas</ a> (permite al compilador convertir la recursividad en iteración).
quickFix.add.property.text=Agregue la propiedad ''{0}{1}'' ''{2}'' a ''{3}''
quickfix.add.property.familyName=Agregar propiedad
random.seed=Semilla aleatoria
range.could.be.replaced.with.indices.call=Puede cambiar el rango llamando a ''.indices''.
recursive.equals.call=Llamada recursiva igual a
recursive.property.accessor=Accesor de propiedad recursivo
recursive.synthetic.property.accessor=Accesor de propiedad unificado recursivo
redundant.0=Duplicar ''@{0}''
redundant.0.call=Llamada ''{0}'' duplicada
redundant.0.modifier=Controlador ''{0}'' innecesario
redundant.async.call.may.be.reduced.to.0=Las llamadas ''asincrónicas'' redundantes se pueden reducir a ''{0}''.
redundant.companion.reference=Referencia complementaria duplicada
redundant.constructor.keyword=Palabra clave 'constructor' duplicada
redundant.curly.braces.in.string.template=Llaves duplicadas en plantilla de cadena
redundant.double.negation=Doble negativo redundante
redundant.else=Duplicar ''más''
redundant.empty.class.body=Cuerpo de clase vacío duplicado
redundant.empty.initializer.block=Duplicar bloque inicializador vacío
redundant.enum.constructor.invocation=Llamadas duplicadas al constructor de enumeraciones
redundant.explicit.this=Duplicar explícito esto
redundant.getter=Captador duplicado
redundant.getter.body=Cuerpo getter innecesario
redundant.if.option.ignore.chained=Ignorar declaraciones 'si' encadenadas
redundant.if.statement=Declaraciones ''si'' duplicadas
redundant.if.statement.analyzing.type=Analizando el tipo de condición...
redundant.lambda.arrow=Flechas lambda duplicadas
redundant.let.call.could.be.removed=Se pueden eliminar las llamadas "let" redundantes.
redundant.modality.modifier=Controlador de modalidad redundante
redundant.override.fix.text=Elimine los métodos de anulación redundantes.
redundant.overriding.method=Método anulado duplicado
redundant.qualifier.name=Nombre calificador duplicado
redundant.qualifier.unnecessary.non.direct.parent.class.qualifier=Calificador de superclase indirecto innecesario
redundant.runcatching.call.may.be.reduced.to.0=Las llamadas ''runCatching'' redundantes se pueden reducir a ''{0}''.
redundant.sam.constructor=Constructor SAM duplicado
redundant.sam.constructors=Constructor SAM duplicado
redundant.semicolon=Punto y coma duplicado
redundant.setter=Configurador duplicado
redundant.setter.body=Cuerpo colocador innecesario
redundant.setter.parameter.type=Tipos de parámetros de establecimiento duplicados
redundant.string.template=Plantilla de cadena duplicada
redundant.suspend.modifier=Controlador ''suspendido'' duplicado
redundant.tostring.call.in.string.template=Llamada duplicada ''toString()'' dentro de la plantilla de cadena
redundant.type.checks.for.object=Comprobación de tipos duplicados para objetos
redundant.unit=Duplicar ''Unidad''
redundant.unit.return.type=Tipo de retorno ''Unidad'' duplicado
redundant.visibility.modifier=Controladores de visibilidad duplicados
refactoring.cannot.be.applied.no.sources.attached=La refactorización {0} no se puede aplicar porque no hay fuentes vinculadas
refactoring.cannot.be.applied.to.abstract.declaration={0} la refactorización no se puede aplicar a declaraciones abstractas
refactoring.cannot.be.applied.to.anonymous.function.without.invocation={0} la refactorización no se puede aplicar a funciones anónimas sin llamadas
refactoring.cannot.be.applied.to.expect.declaration={0} la refactorización no se puede aplicar a la declaración esperada
refactoring.cannot.be.applied.to.lambda.expression.without.invocation={0} la refactorización no se puede aplicar a expresiones lambda sin llamadas
refactoring.extract.to.separate.file.text=Extraer en archivo separado
refactoring.move.non.kotlin.file=El objetivo debe ser un archivo Kotlin.
refactoring.the.function.cannot.be.converted.to.anonymous.function=Las funciones no se pueden convertir en funciones anónimas.
refactoring.the.function.not.found=Función no encontrada
refactoring.the.invocation.cannot.be.resolved=La llamada no se puede resolver.
remove.0=Quitar ''.{0}''
remove.0.from.parameter=Elimine ''{0}'' del parámetro.
remove.0.from.property=Eliminar {0} de la propiedad.
remove.0.modifier=Elimine el calificador ''{0}''.
remove.0.variance.from.1=Elimine la variación ''{0}'' de ''{1}''.
remove.all.argument.names=Eliminar todos los nombres de argumentos
remove.annotation.doesnt.have.any.effect=La anotación no tiene ningún efecto, así que elimínela. Referencia: https://youtrack.jetbrains.com/issue/KT-48141
remove.argument.name=Eliminar nombre del argumento
remove.as.dynamic.call.fix.text=Elimine la llamada ''asDynamic''.
remove.assequence.call.fix.text=Eliminar la llamada ''asSequence''
remove.braces=Quitar los frenillos
remove.braces.fix.text=Quitar los frenillos
remove.braces.from.0.statement=Elimine las llaves de la declaración ''{0}''.
remove.braces.from.all.branches=Quitar llaves de todas las ramas.
remove.braces.from.if.all.statements=Eliminar llaves de todas las declaraciones 'si'
remove.braces.from.when.all.entries=Quitar llaves de todos los elementos "cuándo"
remove.braces.from.when.entry=Quitar llaves de la entrada ''cuándo''
remove.branch=Quitar rama
remove.condition=Eliminar condición
remove.conflicting.import.0=Elimine la declaración de importación conflictiva {0}.
remove.constructor.call=Eliminar la llamada al constructor.
remove.conversion.from.kclass.to.class=Elimine la conversión de ''KClass'' a ''Class''.
remove.curly.braces=Retire los tirantes.
remove.default.parameter.value=Elimina los valores de parámetros predeterminados.
remove.deprecated.symbol.import=Elimine las declaraciones de importación para símbolos obsoletos.
remove.element=Elimina un elemento.
remove.else=''{0}'' para eliminar el else.
remove.else.branch=Retire la rama else.
remove.empty.constructor.body=Eliminar el cuerpo del constructor vacío
remove.empty.parentheses.from.annotation.entry.fix.text=Elimine los paréntesis innecesarios.
remove.empty.primary.constructor=Eliminar el constructor predeterminado vacío
remove.enum.constructor.invocation.fix.text=Eliminar las llamadas al constructor de enumeraciones.
remove.explicit.lambda.parameter.types.may.break.code=Eliminar tipos de parámetros lambda explícitos (puede romper el código)
remove.explicit.supertype.qualification=Eliminar la normalización de supertipo explícita
remove.explicit.type.arguments=Eliminar argumentos de tipo explícito
remove.explicit.type.specification=Eliminar especificación de tipo explícita
remove.explicit.type.specification.from.0=Eliminar la especificación de tipo explícita de ''{0}''
remove.expression=Eliminar {0}
remove.expression.target=Elimina el objetivo de expresión.
remove.extension.function.type.annotation=Eliminar la anotación @ExtensionFunctionType inaplicable
remove.final.upper.bound=Final Elimina el límite superior.
remove.fix.text=Eliminar una expresión.
remove.from.annotation.argument=Eliminar @ de los argumentos de anotación
remove.function.body=Elimina el cuerpo de la función.
remove.identifier.from.anonymous.function=Elimina identificadores de funciones anónimas.
remove.indices.in.for.loop=Eliminar índice en bucle ''for''
remove.initializer.block.fix.text=Retire el bloque inicializador.
remove.jvmfield.annotation=Eliminar la anotación @JvmField
remove.jvmoverloads.annotation=Eliminar la anotación @JvmOverloads
remove.labeled.return.from.last.expression.in.a.lambda=Eliminar el retorno etiquetado de la última expresión dentro de lambda
remove.let.call=Elimine la llamada "dejar".
remove.modifier=Quitar controlador
remove.modifier.fix=Hacer ''{0}'' no {1}
remove.modifier.fix.family=No crear {0}
remove.parameter.0=Eliminar el parámetro ''{0}''.
remove.parts.from.property=Retire parte de la propiedad.
remove.redundant=Eliminar duplicado ''?''.
remove.redundant.0.modifier=Eliminar el controlador ''{0}'' duplicado.
remove.redundant.assignment=Eliminar asignaciones duplicadas
remove.redundant.backticks.quick.fix.text=Elimine las comillas invertidas redundantes.
remove.redundant.call.fix.text=Eliminar llamadas duplicadas
remove.redundant.calls.of.the.conversion.method=Eliminar llamadas duplicadas a métodos de conversión
remove.redundant.companion.reference.fix.text=Elimine las referencias complementarias duplicadas.
remove.redundant.constructor.keyword.fix.text=Eliminar la palabra clave duplicada 'constructor'
remove.redundant.else.fix.text=Elimine el ''else'' redundante.
remove.redundant.elvis.return.null.text=¿Eliminar duplicado ''?\: devolver nulo''
remove.redundant.empty.class.body=Eliminar cuerpos de clase vacíos innecesarios
remove.redundant.getter.body.fix.text=Eliminar el cuerpo getter innecesario
remove.redundant.getter.fix.text=Eliminar captadores duplicados.
remove.redundant.if.expression=Elimine las expresiones "if" redundantes.
remove.redundant.if.may.change.semantics.with.floating.point.types=Elimine la declaración 'if' innecesaria (la semántica de los tipos de punto flotante puede cambiar)
remove.redundant.if.text=Elimine las declaraciones "si" redundantes.
remove.redundant.initializer=Eliminar inicializadores innecesarios
remove.redundant.label=Eliminar etiquetas duplicadas.
remove.redundant.modality.modifier=Eliminar controladores de modalidad innecesarios
remove.redundant.qualifier.name.quick.fix.text=Elimina nombres de calificadores duplicados
remove.redundant.sam.constructor=Elimine los constructores SAM redundantes.
remove.redundant.sam.constructors=Elimine los constructores SAM redundantes.
remove.redundant.setter.body.fix.text=Eliminar el cuerpo del colocador innecesario
remove.redundant.setter.fix.text=Elimina configuradores duplicados
remove.redundant.spread.operator.quickfix.text=Elimine los operadores de propagación redundantes.
remove.redundant.unit.fix.text=Eliminar ''Unidad'' duplicada.
remove.redundant.visibility.modifier=Eliminar controladores de visibilidad innecesarios
remove.redundant.with.fix.text=Eliminar llamadas "con" redundantes.
remove.require.not.null.call.fix.text=Eliminar llamada ''{0}''
remove.return.0=Devolver@{0} eliminar
remove.return.label.fix.family=Eliminar etiquetas duplicadas.
remove.return.label.fix.text=Eliminar duplicado ''@{0}''.
remove.self.assignment.fix.text=Eliminar autoasignación
remove.single.expression.string.template=Eliminar plantilla de cadena de expresión única
remove.single.lambda.parameter.declaration=Elimine la declaración de parámetro lambda único.
remove.star=''*'' eliminar
remove.supertype=Quitar tipo padre
remove.to.string.fix.text=Elimine la llamada ''toString()''.
remove.token.from.function.declaration=Elimine el token ''\='' de la declaración de función.
remove.type.arguments=Eliminar argumento de tipo
remove.type.parameters=Elimine el parámetro de tipo.
remove.unary.operator.fix.text=Elimina los operadores unarios no utilizados.
remove.underscores=Eliminar subrayado
remove.unnecessary.parentheses=Elimine los paréntesis innecesarios.
remove.unnecessary.parentheses.from.function.call.with.lambda=Eliminar paréntesis innecesarios de llamadas a funciones con lambdas
remove.use.site.get.target=Elimine 'get:' para que la anotación sea válida (cambia la semántica, consulte: https://youtrack.jetbrains.com/issue/KT-48141)
remove.useless=Elimine los ''?'' innecesarios.
remove.useless.cast=Retire los yesos innecesarios.
remove.useless.elvis.operator=Elimine los operadores de Elvis innecesarios.
remove.useless.is.check=Elimina controles innecesarios.
remove.val.or.var.from.parameter=Elimine 'val' o 'var' de los parámetros.
remove.var.keyword.text=Eliminar var
remove.variable=Eliminar variable
remove.variable.0=Eliminar la variable ''{0}''.
rename.base.0=Cambiar el nombre predeterminado {0,choice,1#función|2#propiedad|3#miembro|4#método|11#función|12#propiedad|13#miembro|14#método}
rename.class.to.0=Cambiar el nombre de la clase a {0}
rename.class.to.containing.file.name=Cambiar el nombre de la clase al nombre del archivo incrustado
rename.declaration.title.0.implements.1.2.of.3={0} {1,choice,1#implementación|2#override} {2} de {3}
rename.file=Cambiar nombre de archivo
rename.file.0=Cambiar el nombre del archivo a ''{0}''
rename.file.to.0.1=Cambie el nombre del archivo a {0}.{1}
rename.file.to.match.top.level.class.name=Cambie el nombre del archivo para que coincida con el nombre de la clase de nivel superior
rename.identifier.fix.text=Rebautizar
rename.only.current.0=Cambiar el nombre actual de {0,choice,1#function|2#property}
rename.parameter.to.match.overridden.method=Cambie el nombre del parámetro para que coincida con el método anulado.
rename.searching.for.all.overrides=Buscando todas las anulaciones
rename.searching.for.super.declaration=Buscando superdeclaración en la parte inferior
rename.to.0=Cambiar el nombre a ''{0}''
rename.to.01=Cambiar nombre a {0}
rename.to.fix.text=Cambiar el nombre a ''{0}''
rename.to.underscore=Cambiar el nombre a _
rename.useless.call.fix.text=Cambie la llamada a ''{0}''.
reorder.parameters=Reordenar parámetros
reorder.parameters.command=Reordenar parámetros
repair.actual.members=Modifica el miembro real.
replace.&&.with.||=Cambie '\\&\\&' a '||'
replace.0.call.with.indexing.operator=Reemplace la llamada a ''{0}'' con el operador de indexación.
replace.0.name.with.spaces=Cambiar el nombre de {0} al espacio
replace.0.with=Reemplace ''{0}()'' con ''+\=''
replace.0.with.1=Reemplace ''{0}'' con ''{1}''
replace.0.with.1.and.vice.versa=Intercambiar ''{0}'' y ''{1}''
replace.annotation=Cambiar la anotación
replace.annotation.with.0=Reemplace la anotación con {0}
replace.array.of.boxed.with.array.of.primitive=Reemplace la matriz de boxeo con la matriz predeterminada.
replace.assert.boolean.with.assert.equality=Reemplace la afirmación booleana con la afirmación de igualdad.
replace.assert.with.operator=Reemplace las afirmaciones con operadores.
replace.assignment.with.if.expression=Cambiar la asignación a la expresión ''si''
replace.assignment.with.when.expression=Cambiar la asignación a la expresión ''cuando''
replace.by.0=Reemplazar con ''{0}''
replace.by.reconstructed.type=Reemplazar con tipo recreado
replace.call.with.unary.operator=Conversión de llamadas a operadores unarios
replace.cast.with.call.to.to.0=Reemplace la conversión de tipo con una llamada a ''to{0}()''.
replace.cast.with.primitive.conversion.method=Reemplace la conversión de tipos con el método de conversión predeterminado.
replace.collection.count.with.size.quick.fix.text=Reemplace ''recuento'' por ''tamaño''.
replace.contains.call.with.in.operator=Reemplace la llamada "contiene" con el operador "en"
replace.deprecated.symbol.usage=Reemplaza símbolos obsoletos.
replace.deprecated.symbol.usage.in.whole.project=Reemplaza el uso de un símbolo obsoleto en todo el proyecto.
replace.diagnostic.name.fix.family.name=Cambiar nombre de diagnóstico
replace.diagnostic.name.fix.text={0} un {1}
replace.elvis.expression.with.if.expression=Convirtiendo expresiones de Elvis en expresiones ''si''
replace.explicit.lambda.parameter.with.it=Reemplazar un parámetro lambda explícito con ''it''
replace.explicit.parameter.0.with.it=Reemplace el parámetro explícito ''{0}'' con ''it''
replace.expression.with.if.expression=Cambiando la expresión ''\!\!'' a la expresión ''if''
replace.function.call.with.if=Reemplazo de llamadas a funciones con 'si'
replace.function.call.with.the.opposite=Reemplazar una llamada de función con su llamada de función opuesta
replace.function.call.with.when=Reemplazo de llamadas a funciones con 'cuándo'
replace.get.or.set.call.with.indexing.operator=Reemplace las llamadas de obtención o configuración con operadores de indexación.
replace.guard.clause.with.kotlin.s.function.call=Reemplace la cláusula de protección con una llamada de función en Kotlin
replace.if.expression.with.elvis.expression=Reemplace la expresión ''si'' con una expresión de Elvis.
replace.if.expression.with.return=Cambie la expresión ''si'' para regresar
replace.if.expression.with.safe.access.expression=Reemplace la expresión ''if'' con una expresión de acceso seguro.
replace.if.expression.with.safe.cast.expression=Reemplace la expresión ''if'' con una expresión de conversión segura.
replace.if.with.elvis.operator=Reemplace ''si'' con el operador de Elvis.
replace.if.with.when=Cambie ''si'' por ''cuándo''
replace.index.loop.with.collection.loop.quick.fix.text=Reemplácelo con un bucle sobre los elementos.
replace.infix.call.with.ordinary.call=Convertir llamadas infijas en llamadas ordinarias
replace.int.range.end.inclusive.with.last.quick.fix.text=Reemplace ''endInclusive'' por ''último''.
replace.int.range.start.with.first.quick.fix.text=Reemplace ''inicio'' por ''primero''.
replace.invalid.positioned.arguments.for.annotation=Reemplazar argumentos fuera de lugar para anotaciones
replace.invoke.with.direct.call=Reemplace ''invocar'' con llamada directa
replace.it.with.explicit.parameter=Reemplace ''eso'' con un parámetro explícito
replace.jvmfield.with.const=Reemplace ''@JvmField'' por ''const''.
replace.manual.range.with.indices.call.quick.fix.text=Reemplazar con índice.
replace.modifier=Cambiar controlador.
replace.negated.0.operation.with.1=Reemplace la operación negada ''{0}'' por ''{1}''.
replace.negated.0.operation.with.1.may.change.semantics.with.floating.point.types=Reemplace la operación de negación ''{0}'' con ''{1}'' (el significado puede cambiar con el tipo de punto flotante)
replace.negated.0.with.1=Reemplaza ''{0}'' negado por ''{1}''.
replace.overloaded.operator.with.function.call=Convertir operadores sobrecargados en llamadas a funciones
replace.property.initializer.with.if.expression=Cambiando el inicializador de propiedad a la expresión ''if''
replace.property.initializer.with.when.expression=Cambiando el inicializador de propiedad a la expresión ''cuando''
replace.return.with.if.expression=Cambiar volver a la expresión ''si''
replace.return.with.when.expression=Cambiar volver a la expresión ''cuando''
replace.safe.access.expression.with.if.expression=Conversión de expresiones de acceso seguro a expresiones ''if''
replace.scope.function.with.safe.call=Reemplace las funciones de alcance con llamadas seguras (?.).
replace.size.check.with.0=Reemplace la verificación de tamaño con ''{0}''
replace.size.check.with.isnotempty=Cambie la verificación de tamaño a ''isNotEmpty''
replace.size.zero.check.with.isempty=Reemplace la verificación de tamaño cero con ''isEmpty''
replace.substring.call.with.droplast.call=Reemplace la llamada ''subcadena'' con una llamada ''dropLast''.
replace.substring.call.with.indexing.operation.call=Reemplace la llamada ''subcadena'' con una llamada a la operación de índice.
replace.substring.call.with.substringafter.call=Reemplace la llamada ''subcadena'' con una llamada ''subcadenaDespués''.
replace.substring.call.with.substringbefore.call=Reemplace la llamada ''subcadena'' con una llamada ''subcadenaAntes''.
replace.substring.call.with.take.call=Reemplace la llamada ''subcadena'' con una llamada ''take''.
replace.to.with.infix.form.quickfix.text=Reemplace ''a'' con formato infijo.
replace.tostring.with.string.template=Reemplace ''toString'' con una plantilla de cadena.
replace.total.order.equality.with.ieee.754.equality=Reemplace la igualdad total del orden con la igualdad IEEE 754.
replace.usages.of.0.in.whole.project=Reemplaza el uso de ''{0}'' en todo el proyecto.
replace.when.with.if=Cambie ''cuándo'' por ''si''
replace.with.0=Reemplazar con ''{0}''
replace.with.0.1.2={0}[{1}] ?\: Reemplazar con {2}
replace.with.0.call=Reemplace con una llamada a ''{0}()''.
replace.with.0.operator=Reemplazar con el operador ''{0}''
replace.with.a.for.loop=Reemplazar con un bucle ''for''
replace.with.a.foreach.function.call=Reemplazar con llamada a función ''forEach''
replace.with.array.call=Reemplace con llamadas de matriz:
replace.with.array.literal.fix.family.name=Cambiar a [...]
replace.with.arrayof=Reemplace con 'matriz de'.
replace.with.assignment.fix.text=Reemplazar con asignación (el original está vacío).
replace.with.binary.operator=Reemplace con operadores binarios.
replace.with.block.comment=Convertir para bloquear comentario
replace.with.contentequals=Reemplace ''\!\='' por ''contentEquals''.
replace.with.contentequals2=Reemplace ''\=\='' por ''contentEquals''.
replace.with.contentequals3=Reemplace con ''contentEquals''.
replace.with.dot.call=Reemplácelo con una llamada de punto.
replace.with.elvis.error.fix.text=Reemplácelo con ''?\: error("")''.
replace.with.elvis.return.fix.text=Reemplazar con ''?\: return{0}''.
replace.with.end.of.line.comment=Cambiar al comentario de final de línea
replace.with.enum.map.fix.text=Reemplácelo con EnumMap.
replace.with.equality.check.fix.text=Cambiar a prueba de igualdad.
replace.with.equality.fix.text=Reemplace ''{0}'' con ''{1}''
replace.with.error=Reemplazar con ''?\: error(...)''.
replace.with.explicit.type=Convertir '_' a un tipo explícito
replace.with.field.fix.text=Reemplace con ''campo''.
replace.with.filter.fix.text=Cambiar para filtrar.
replace.with.generated.publishedapi.bridge.call.0=Reemplace la llamada puente @PublishedApi generada por ''{0}''.
replace.with.get.or.else.fix.text=Reemplácelo con una llamada a ''getOrElse''.
replace.with.get.value.call.fix.text=Reemplace con una llamada ''getValue''.
replace.with.if.fix.text=Reemplace con verificación de tipo ''si''.
replace.with.import.alias=Reemplazar con alias de importación
replace.with.in.when=En cuándo, reemplace '','' por ''||''.
replace.with.indexing.and.elvis.operator=Reemplazar con operador de indexación y operador de Elvis
replace.with.infix.function.call=Reemplazar con llamada de función infija
replace.with.kotlin.analog.function.family.name=Cambiar al análogo de Kotlin
replace.with.kotlin.analog.function.text=Convertir a la función ''{0}''
replace.with.kotlin.s.foreach=Reemplace con forEach de Kotlin.
replace.with.kotlin.s.function.call=Reemplazar con llamada de función en Kotlin
replace.with.label.0.at=Reemplazar con {0}@.
replace.with.list.generator.fix.text=Convertir a generador de listas
replace.with.operator.assignment=Cambiar a asignación de operador.
replace.with.ordinary.assignment=Convertir a tarea regular
replace.with.parameter.name=Reemplace ''_'' con el nombre del parámetro
replace.with.publishedapi.bridge.call=Reemplace @PublishedApi con una llamada puente.
replace.with.rangeUntil.quick.fix.text=Reemplazar con '..<'
replace.with.repeat.fix.family.name=Reemplazar con ''repetir()''
replace.with.return=Reemplace ''\!\!'' por ''?\: return''.
replace.with.safe.call=Reemplácelo con una llamada segura (?.).
replace.with.safe.this.call=Reemplácelo con una llamada segura (¿esta?).
replace.with.std.lib.fix.text=Reemplazar con {0}.{1}.
replace.with.stdlib.operations=Operación de conversión a stdlib
replace.with.stdlib.operations.with.use.of.assequence=Reemplazar con operaciones stdlib usando ''asSequence()''
replace.with.string.literal.fix.family.name=Reemplazar con plantilla de cadena
replace.with.underscore=Cambiar tipo explícito a '_'
replace.with.until.quick.fix.text=Cámbielo a hasta.
replace.with1=Reemplazar con ''+\=''
replace.||.with.&&=Cambiar '||' a '\\&\\&'
replaceable.with.enummap=Puedes reemplazarlo con EnumMap.
replaceable.with.operator.assignment=Se puede cambiar mediante sustitución de operador.
report.also.for.a.variables.without.a.whitespace.around=También informa sobre variables sin espacios circundantes.
report.also.on.call.with.single.boolean.literal.argument=También informa sobre llamadas con un único argumento literal booleano.
report.also.on.statement=La sintaxis también informa.
report.for.types.with.platform.arguments=Informes sobre qué tipos de argumentos de plataforma existen.
reports.only.function.calls.from.kotlinx.coroutines=Informa solo llamadas a funciones en kotlinx.coroutines.
reset.files=Restablecer archivo...
resolve.pasted.references=Resolver referencias pegadas
result.of.0.call.is.not.thrown=El resultado de la llamada ''{0}'' no se genera.
rethrow.stored.pce.as.a.new.runtime.exception=Volver a lanzar un PCE guardado como una nueva excepción de tiempo de ejecución
return.type=Tipo de devolución (&R)\:
return.type.is.invalid=El tipo de devolución no es válido.
return.when=Cuando regrese
revert.applied.imports.command=Revertir importación aplicada
roots.description.text.update.source.roots.for.non.jvm.modules.in.kotlin.project=Actualice la raíz de origen para los módulos que no son JVM en su proyecto Kotlin.
round.using.0=Utilice {0}() para redondear.
safe.delete.constructor=Constructor de eliminación segura
saving.files=Guardando archivo...
scanning.files.0.fo.1.file.2.occurrences.found=Comprobando archivos: {0}/{1} archivos. {2} usos encontrados.
script.action.text.ignore=Ignorar
script.action.text.open.settings=Configuración abierta
script.action.text.show.all=Mostrar todo
script.name.kotlin.scripting=Secuencia de comandos Kotlin
script.text.multiple.script.definitions.are.applicable.for.this.script=Se pueden aplicar varias definiciones de script a este script. Se utiliza {0}.
sealed.sub.class.has.no.state.and.no.overridden.equals=La subclase sellada no tiene ningún estado ni iguales anulados.
search.for.not.property.candidates=Busque candidatos, no propiedades.
search.for.text.occurrences=&Buscar dónde se utiliza el texto
search.in.comments.and.strings=Buscar en comentarios y cadenas
searching.0=Buscando {0}....
searching.for.0=Buscando {0}
searching.for.imports.to.delete.title=Buscar importaciones para eliminar
searching.for.not.property.candidates=Búsqueda de candidatos no inmobiliarios
searching.for.overriding.methods=Buscar métodos de reemplazo
searching.inheritors=Buscando heredero...
searching.usages.of.0.parameter=Buscando el uso del parámetro ''{0}''
select.lambda.to.label=Seleccione la lambda que desea etiquetar.
select.loop.statement.to.label=Seleccione la declaración de bucle que desea etiquetar.
select.target.code.block.file=Seleccione el bloque/archivo de código de destino.
select.target.file=Seleccione el archivo de destino.
selected.code.fragment.has.multiple.exit.points=El fragmento de código seleccionado tiene múltiples puntos de salida.
selected.code.fragment.has.multiple.output.values=El fragmento de código seleccionado tiene tres o más salidas.
selected.code.fragment.has.output.values.and.exit.points=El fragmento de código seleccionado tiene salida y un punto de salida alternativo.
setter.of.0.will.become.invisible.after.extraction=El definidor de {0} se vuelve invisible después de la extracción.
should.be.replaced.with.if.type.check=Debería reemplazarse con una verificación de tipo "si".
should.be.replaced.with.indexing=Esto debería reemplazarse con indexación.
should.be.replaced.with.kotlin.function=Debe convertirse a una función de Kotlin.
should.be.replaced.with.list.generator=Necesitas cambiarlo a un generador de listas.
should.not.contain.lowercase.letter=No se pueden utilizar letras minúsculas
should.not.contain.underscores=No debe haber ningún subrayado.
should.not.contain.underscores.in.the.middle.or.the.end=No debe haber un guión bajo en el medio ni al final.
should.not.contain.underscores.with.camel.case=Los guiones bajos no se pueden utilizar cuando se utiliza la notación camello.
should.not.start.with.an.underscore=No debe comenzar con un guión bajo.
should.not.start.with.an.uppercase.letter=No debe comenzar con mayúscula.
should.start.with.a.lowercase.letter=Debe comenzar con una letra minúscula.
should.start.with.an.uppercase.letter=Debe comenzar con mayúscula.
signature.preview=Vista previa de firma
simplify.0.to.1=Simplifica {0} a ''{1}''.
simplify.boolean.expression=Simplificar expresiones booleanas
simplify.call.chain.fix.text=Fusione la cadena de llamadas en ''{0}''.
simplify.call.fix.text=Convierta la llamada ''{0}'' a ''{1}''.
simplify.comparison=Simplifica la comparación.
simplify.fix.text=Simplificar expresiones
simplify.foldable.if.then=Simplifica los si-entonces plegables.
simplify.negated.operation=Simplifica las operaciones negadas.
simplify.when.fix.text=Simplifique ''cuándo''.
since.kotlin.1.3.main.parameter.is.not.necessary=A partir de Kotlin 1.3, el parámetro principal no es necesario.
slicer.text.in=A mí
slicer.text.tracking.enclosing.lambda=\ (traza lambda adjunta)
slicer.text.tracking.lambda.argument=\ (seguimiento de parámetros lambda)
slicer.text.tracking.lambda.calls=\ (rastreo de llamadas lambda)
slicer.text.tracking.lambda.receiver=\ (traza del receptor lambda)
slicer.title.dataflow.from.here=Flujo de datos desde aquí
slicer.title.dataflow.to.here=Los datos fluyen aquí
slicer.tool.tip.text.variable.dereferenced=Variable desreferenciada
some.types.are.not.accessible.from.0.1=Escriba inaccesible en {0}\:\n{1}
sort.modifiers=Alineación del controlador
specify.all.types.explicitly.in.destructuring.declaration=Especifique explícitamente todos los tipos en declaraciones de desestructuración.
specify.explicit.lambda.signature=Especificación de firma lambda explícita
specify.override.explicitly=Especifica la anulación explícitamente.
specify.override.for.0.explicitly=Especifica explícitamente una anulación para ''{0}''.
specify.return.type.explicitly=Especifique explícitamente el tipo de devolución.
specify.super.type=Especificar explícitamente el supertipo ''{0}''
specify.type.explicitly=Especifique el tipo explícitamente.
split.if.into.two=Dividir ''si'' en dos partes
split.property.declaration=División de declaraciones de propiedad
spring.secured.urls.inlay.hints=Kotlin: muestra sugerencias incrustadas en URL seguras de Spring
ssr.modifier.match.call.semantically=Asegúrese de que las llamadas coincidan semánticamente
ssr.modifier.match.companion.object=Coincidencia de objetos complementarios
ssr.modifier.match.val=Coincidencia de valores
ssr.modifier.match.var=Coincidencia de valores
start.import.button.text.add=Suma
start.import.button.text.remove=Eliminar
statement=Construcción
status=(situación)
step.1.collecting.0.1.2=Paso 1\: Recoge {0}\:{1}\:{2}
step.2.0.of.1=Paso 2\: {1} de {0}
step.3.0.of.1=Paso 3\: {1} de {0}
surround.with.0=Rodear con *{0}(...)
surround.with.array.of=Rodeando con arrayOf(...)
surround.with.lambda=Rodéalo con lambda.
surround.with.null.check=Rodeado de cheques nulos.
surround.with.star.0=Rodeado de *{0}(...).
suspicious.asdynamic.member.invocation=Llamada sospechosa al miembro ''asDynamic''
suspicious.callable.reference.as.the.only.lambda.element=Referencia invocable sospechosa como único elemento lambda
suspicious.combination.of.and=Combinación sospechosa de \=\= y \=\=\=
suspicious.var.property.its.setter.does.not.influence.its.getter.result=Propiedad ''var'' sospechosa\: su definidor no afecta el resultado de su captador.
test.function=Función de prueba
test.integration.button.text.cancel=Cancelar
test.integration.button.text.rewrite=Volver a escribir
test.integration.message.text.create.test.in.the.same.source.root=¿Le gustaría crear pruebas desde la misma raíz de origen?
test.integration.message.text.kotlin.class=La clase Kotlin ''{0}'' ya existe. ¿Te gustaría actualizar?
test.integration.title.no.test.roots.found=Raíz de prueba no encontrada
test.result.log.file.will.be.placed.here=Los archivos de registro de resultados de las pruebas se colocan aquí
text.0.1.must.be.moved.with.sealed.parent.class.and.all.its.subclasses={0} ''{1}'' debe moverse con su clase principal sellada y todas sus subclases.
text.0.already.contains.1={0} ya contiene {1}.
text.0.already.contains.nested.class.1=Una clase anidada con nombre {1} ya está contenida en {0}.
text.0.already.declared.in.1={0} ya está definido en {1}.
text.0.have.no.inheritors.warning={0} no tiene herederos.\nAl mover un miembro hacia abajo, se eliminará ese miembro. ¿Quieres continuar?
text.0.in.1.will.override.corresponding.member.of.2.after.refactoring={1} en {0} redefine un miembro en {2} después de la refactorización.
text.0.inherits.from.1.it.will.not.be.affected.by.refactoring={0} se hereda de {1}.\nNo se ve afectado por la refactorización.
text.0.is.invalid.destination.package=''{0}'' es un nombre de paquete de destino no válido.
text.0.is.not.allowed.in.the.target.context=''{0}'' no está permitido en la interfaz
text.0.is.not.valid.package.name={0} no es un nombre de paquete válido.
text.0.to.inline={0} a en línea
text.0.uses.1.which.is.not.accessible.from.2={0} utiliza {1} al que no puede acceder {2}.
text.0.uses.1.which.will.be.inaccessible.after.move={0} usa {1}, que quedará inaccesible después del traslado.
text.0.uses.1.which.will.not.be.accessible.from.subclass={0} usa {1}, lo que lo hace inaccesible para las subclases.
text.0.uses.internal.1.which.will.be.inaccessible.after.move={0} utiliza {1} interno al que quedará inaccesible después del traslado.
text.0.will.be.shadowed.by.1={0} está sombreado por {1}.
text.0.will.clash.with.existing.1.in.2=Cambiar el nombre hace que {0} entre en conflicto con el {1} existente en {2}.
text.0.will.no.longer.be.accessible.after.signature.change={0} quedará inaccesible después de cambiar su firma.
text.Assignment=Admisiones universitarias
text.Function=Función
text.Name=Nombre
text.Package=Paquete
text.Property=Propiedades
text.Return=Devolver
text.abstract=Abstracto
text.add.getter=Agregar captador
text.add.getter.and.setter=Agregar captadores y definidores
text.add.setter=Agregar configurador
text.add.use.site.target.0=Agregar objetivo de sitio de uso ''{0}''
text.all.declarations.must.belong.to.the.same.directory.or.class=Todas las declaraciones deben pertenecer al mismo directorio o clase.
text.annotation=Anotación
text.annotation.class=Clase de anotación
text.anonymous=[anónimo]
text.anonymous.function=Función anónima
text.at.least.one.file.must.be.selected=Debes seleccionar al menos un miembro.
text.callee.text.would.be.shown.here=El texto del destinatario aparece aquí.
text.caller.text.with.highlighted.callee.call.would.be.shown.here=El texto de la persona que llama aparece aquí con la llamada de la persona que llama resaltada.
text.can=Puede
text.cannot.create.target.directory.0=No se puede crear el directorio de destino {0}.
text.cannot.determine.source.directory=El directorio de origen no se puede resolver.
text.cannot.find.package.corresponding.to.0=No se pudo encontrar el paquete correspondiente a {0}.
text.cannot.find.target.package.name=No se encontró el nombre del paquete de destino.
text.cannot.inline.reference.from.0.to.1=No se puede insertar una referencia de {0} a {1}
text.cannot.move.expect.actual.declaration.to.file=No se pudo trasladar la declaración esperada/real al archivo
text.cannot.move.for.current.project=No puedes moverte para el proyecto actual.
text.cannot.move.inner.class.0.into.itself=La clase anidada {0} no se puede mover dentro de sí misma.
text.cannot.move.to.original.file=No puedes ir al archivo original.
text.change.file.package.to.0=Cambie el paquete del archivo a ''{0}''.
text.choose.containing.file=Seleccione los archivos incluidos.
text.class=Clase
text.class.0={0,choice,1#clase|2#clase}
text.class.0.already.contains.member.1={0} ya contiene {1}.
text.class.0.already.exists.in.package.1=El paquete {1} ya existe en la clase {0}.
text.class.0.already.exists.in.the.target.scope=La clase {0} ya existe en el ámbito de destino.
text.class.0.is.final={0} es definitivo.
text.constructor=Constructor
text.convert._it_.to.explicit.lambda.parameter=Convierta ''it'' en un parámetro lambda explícito.
text.create=Producir
text.create.destructuring.declaration=Genera una declaración desestructurante.
text.create.single.variable=Crea una única variable.
text.declaration=Declaración
text.declarations.clash.move.0.destination.1.declared.in.scope.2=Las siguientes declaraciones entran en conflicto: Mueva {0} y apunte a {1} declarado en el ámbito {2}.
text.default.value=\ // Valor predeterminado \={0}
text.destination.class.should.be.kotlin.class=La clase objetivo debe ser una clase Kotlin.
text.do.you.want.to.rename.0.as.well=¿También le gustaría cambiar el nombre de {0}()?
text.do.you.want.to.rename.base.property=¿Le gustaría cambiar el nombre de la propiedad predeterminada?
text.do.you.want.to.rename.base.property.from.0=¿Le gustaría cambiar el nombre de la propiedad predeterminada en {0}?
text.done=Completo
text.duplicating.local.variable=Variable local duplicada ''{0}''
text.duplicating.parameter=Parámetro duplicado ''{0}''
text.duplicating.property=Propiedad duplicada ''{0}''
text.enum=Enumeración
text.enum.class=Clase de enumeración
text.enum.constant=Constantes de enumeración
text.explicit.receiver.is.already.present.in.call.element.0=Ya existe un receptor explícito en el elemento llamante. {0}
text.extend=Expansión
text.extension=Expansión
text.extension.function=Función de extensión
text.extension.function.0=Extensión {0,choice,1#función|2#función}
text.extension.property=Propiedades extendidas
text.extension.property.0=Extensión {0,choice,1#propiedad|2#propiedad}
text.extract.superclass=Extracción de clase principal
text.file.0.already.exists.in.1=El archivo {0} ya existe en {1}.
text.file.name.cannot.be.empty=Es posible que el nombre del archivo no esté vacío.
text.function=Función
text.function.0={0,choice,1#función|2#función}
text.function.already.exists=La función ya existe. ''{0}''
text.function.in.ticks.0=Función ''{0}''
text.getter=Adquiridor
text.implement=Avatar
text.implements=Avatar
text.implicit.companion.object.will.be.inaccessible.0=Los objetos complementarios implícitos se vuelven inaccesibles. {0}
text.incorrect.target.path.directory.0.does.not.belong.to.current.project=Ruta de destino no válida. El directorio {0} no pertenece al proyecto actual.
text.indirect.outer.instances.will.not.be.extracted.0=Las instancias externas indirectas no se extraen. {0}
text.initializer=Iniciador
text.inline.0={0} en línea
text.inline.all.references.and.verb.0.the.kind.1.occurrences.2=Inserte todas las referencias y reemplace {1} {2} con {0}
text.inline.function.not.supported=Las funciones en línea aún no son compatibles
text.inline.recursive.function.is.supported.only.on.references=La incorporación de funciones recursivas solo se admite por referencia.
text.inline.this.reference.and.keep.the.0=Insertar esta referencia y mantener {0}
text.inlined.0.overrides.0.1={0} en línea anula {0} {1}
text.inlining.0.1={0} {1} en línea
text.inner.class.0.cannot.be.moved.to.interface={0} es una clase interna y no se puede mover a una interfaz.
text.interface=Interfaz
text.introduce.default.value=&Insertar valor predeterminado
text.invalid.target.path.0=Ruta de destino no válida {0}
text.invalid.target.specified=Orientación incorrecta
text.keep=Mantener
text.lambda.parameter=Parámetro lambda
text.lambda.parameters=Parámetros lambda (&P)\:
text.lambda.return.type=Tipo de retorno lambda (&T)
text.lazy.property=Propiedades de retardo
text.local.property=Propiedades
text.local.variable=Variable local
text.looking.for.usages=Buscando ubicación de uso
text.member=Miembro
text.member.0.in.super.class.will.clash.with.existing.member.of.1={0} en la clase principal entra en conflicto con un miembro existente en {1}.
text.member.extension.call.will.not.be.processed.0=Las llamadas de extensión de miembros no se procesan. {0}
text.move.declaration.no.support.for.companion.objects=No se admiten declaraciones en movimiento para objetos complementarios.
text.move.declaration.no.support.for.enums=No se admite el movimiento declarativo para elementos de enumeración.
text.move.declaration.no.support.for.nested.declarations=Move declaration is not supported for nested declarations
text.move.declaration.proceed.move.without.mpp.counterparts.text=Esta refactorización puede causar errores de compilación porque mueve declaraciones seleccionadas sin sus contrapartes esperadas/reales.\n¿Quiere continuar?
text.move.declaration.proceed.move.without.mpp.counterparts.title=Las declaraciones MPP no son compatibles con esta refactorización
text.move.declaration.supports.only.top.levels.and.nested.classes=Mover declaraciones solo se admite para declaraciones de nivel superior y clases anidadas.
text.move.declarations=Movimiento de declaración
text.move.file.0=Empresa de mudanzas {0}
text.move.method.is.not.supported.for.generic.classes=El método de movimiento no es compatible con clases genéricas.
text.move.method.is.not.supported.for.non.project.methods=El método de movimiento no es compatible con métodos que no son de proyecto.
text.move.method.is.not.supported.when.method.is.a.part.of.inheritance.hierarchy=El método de movimiento no es compatible si el método es parte de una jerarquía de herencia.
text.move.refactoring.not.available.during.indexing=La refactorización de movimientos no está disponible mientras la indexación está en curso.
text.moving.multiple.nested.classes.to.top.level.not.supported=No se admite mover varias clases anidadas al nivel superior.
text.name=Nombre
text.nested.classes.to.upper.level=De clases anidadas a niveles superiores
text.no.destination.object.specified=No se ha especificado ningún objeto de destino
text.no.elements.to.move.are.selected=No se ha seleccionado ningún elemento para mover.
text.no.files.to.move=No se especifica ningún archivo para mover.
text.no.name.provided.for.type.alias=No se proporcionó ningún nombre para el alias de tipo.
text.no.package.corresponds.to.directory=No hay ningún paquete correspondiente en este directorio.
text.non.kotlin.0.will.not.be.affected.by.refactoring={0} que no sea Kotlin no se ve afectado por la refactorización.
text.object=Objeto
text.object.0={0,choice,1#objeto|2#objeto}
text.operator.0={0,choice,1#operador|2#operador}
text.overload=Sobrecarga
text.overrides=Reiniciar
text.package.directive.dont.match.file.location=La directiva del paquete no coincide con la ubicación del archivo.
text.parameter=Parámetro
text.parameter.0=Parámetro ''{0}''
text.parameter.name=&Nombre del parámetro\:
text.parameter.reference.can.t.be.safely.replaced.with.0.since.1.is.ambiguous.in.this.context={1} es ambiguo en este contexto y la referencia del parámetro no se puede reemplazar de forma segura con {0}.
text.parameter.reference.can.t.be.safely.replaced.with.0.since.target.function.can.t.be.referenced.in.this.context=La referencia del parámetro no se puede reemplazar de forma segura con {0} porque no se puede hacer referencia a la función de destino en este contexto.
text.parameter.type=Tipo de parámetro (&T)\:
text.parameters=&Parámetro\:
text.part=Trabajo de medio tiempo
text.pattern=Patrón
text.primary=Básico
text.primary.constructor=Constructor predeterminado
text.proceed.with.extraction=Progreso de extracción
text.process.duplicates=Duplicación de procesos
text.processing.file.0=Procesando {0}
text.property=Propiedades
text.property.0={0,choice,1#propiedad|2#propiedad}
text.property.in.ticks.0=Propiedad ''{0}''
text.property.with.getter=Propiedades con captadores
text.property.with.initializer=Propiedades con inicializadores
text.pushed.member.will.not.be.available.in.0=El miembro enviado ya no estará disponible en ''{0}''.
text.qualified.call.will.not.be.processed.0=Las llamadas calificadas no se procesan. {0}
text.receiver=Receptor
text.receiver.can.t.be.safely.transformed.to.value.argument=Un receptor no se puede convertir de forma segura en un argumento de valor. {0}
text.refactoring.can.t.be.performed.on.the.selected.code.element=La refactorización no se puede realizar en el elemento de código seleccionado.
text.refactoring.is.not.applicable.to.this.code.fragment=No se aplica ninguna refactorización a este fragmento de código.
text.reference.cannot.be.converted.to.a.lambda=La referencia no se puede convertir a lambda
text.references.in.code.to.0.1.and.its.declarations={0} Referencias en código a {1} y sus declaraciones
text.references.to.outer.classes.have.to.be.added.manually=Las referencias a clases externas deben agregarse manualmente después de moverse
text.remove=Eliminar
text.remove.0.no.longer.used=Elimine {0} que ya no se utiliza.
text.remove.question=\ ''?'' eliminar
text.rename.as.part.of.phrase=Rebautizar
text.rename.is.not.applicable.to.compiler.plugin.generated.declarations=Cambiar nombre no se puede utilizar en declaraciones generadas por el compilador
text.rename.is.not.applicable.to.secondary.constructors=El cambio de nombre no afecta a los constructores secundarios.
text.rename.is.not.applicable.to.synthetic.declarations=Los cambios de nombre no aplican a las declaraciones de integración.
text.rename.not.applicable.to.backing.field.reference=Los cambios de nombre no afectan las referencias de los campos de respaldo.
text.rename.not.applicable.to.dynamically.invoked.methods=Los cambios de firma no se aplican a los miembros llamados dinámicamente.
text.rename.overloads.title=Cambiar nombre de sobrecarga
text.rename.parameters.title=Cambiar nombre del parámetro
text.return=Devolver
text.sealed.broken.hierarchy.none.in.target=La jerarquía sellada de ''{0}'' está dividida. El paquete ''{1}'' en el módulo ''{2}'' no tiene miembros. {3}
text.sealed.broken.hierarchy.still.in.source=La jerarquía sellada de ''{0}'' está dividida. El paquete ''{1}'' en el módulo ''{2}'' todavía contiene miembros. {3}
text.sealed.class.0.must.be.moved.with.all.its.subclasses=La clase sellada ''{0}'' debe moverse con todas sus subclases.
text.secondary=Asistente
text.secondary.constructor=Constructor secundario
text.select.target.code.block=Seleccione el bloque de código de destino.
text.select.target.code.block.file=Seleccione el bloque/archivo de código de destino.
text.select.target.file=Seleccione el archivo de destino.
text.setter=Conjuntos
text.should=Debería
text.there.is.already.a.parameter=El parámetro ''{0}'' ya existe en {1}, por lo que entrará en conflicto con el nuevo parámetro.
text.there.is.already.a.variable.0.in.1.it.will.conflict.with.the.new.parameter=La variable ''{0}'' ya existe en {1}, por lo que entrará en conflicto con el nuevo parámetro.
text.type=Categoría
text.type.alias=Escriba alias
text.type.alias.0=Escriba {0,choice,1#alias|2#alias}
text.type.alias.cannot.refer.to.types.which.aren.t.accessible.in.the.scope.where.it.s.defined=Un alias de tipo no puede hacer referencia a un tipo al que no se puede acceder desde el ámbito en el que está definido.
text.type.alias.name.must.be.a.valid.identifier.0=El nombre del alias del tipo debe ser un identificador válido. {0}
text.type.already.exists.in.the.target.scope=El tipo {0} ya existe en el ámbito de destino.
text.type.parameter=Escriba {0,choice, 0\#parámetro|2\#parámetro}
text.type.parameter.names.must.be.distinct=Los nombres de los parámetros de tipo deben ser únicos.
text.type.parameters=Tipo y parámetro
text.unexpected.element.type.0=Tipo de elemento inesperado\: {0}
text.update.usages.to.reflect.declaration.0.move=Actualice el uso para reflejar {0,choice, 0\#declaración|1\#declaración}.
text.updating.usages.progress=Actualizando ubicación de uso...
the.anonymous.object=Objeto anónimo
the.declaration.has.0.modifier=La declaración tiene el controlador ''{0}''
the.function.declaration.shouldn.t.have.a.default.implementation=La declaración de función no debe tener una implementación predeterminada.
there.are.possible.side.effects.found.in.expressions.assigned.to.the.variable.0=Se ha detectado un posible efecto secundario en la expresión asignada a la variable ''{0}.<br>Para resolver el problema:<br>-\\&nbsp;<b>Elimine</b><br toda la asignación >. -\\&nbsp;Convierte la asignación del lado derecho a su propia sintaxis.</b><br>
there.is.own.replacewith.on.0.that.is.used.through.this.alias.please.replace.usages.first=''{0}'' usado a través de este alias tiene su propio ''ReplaceWith''. Primero, cambie la ubicación de uso.
these.declarations.cannot.be.transformed=Esta declaración no se puede convertir.
this.call.is.useless.with=Esta llamada no es necesaria si usas ?.
this.property.conflicts.with.synthetic.extension.and.should.be.removed.or.renamed.to.avoid.breaking.code.by.future.changes.in.the.compiler=Esta propiedad entra en conflicto con la extensión de integración, por lo que debe eliminarla o cambiarle el nombre para evitar que cambios futuros en el compilador rompan su código.
this.range.is.empty=Este rango está vacío.
this.range.is.empty.did.you.mean.to.use.0=Este rango está vacío. ¿Quieres utilizar ''{0}''?
this.type.probably.can.be.changed.to.nullable=Este tipo se puede cambiar para que admita valores NULL.
this.when.is.simplifiable=Este "cuándo" se puede simplificar.
throwable.instance.0.is.not.thrown=La instancia arrojable ''{0}'' no se lanzará.
titile.not.found=Extraviado
title.choose.destination.object=Seleccionar objeto de destino
title.choose.logger.factory.class=Seleccione la clase de fábrica del registrador
title.choose.use.site.target=Seleccione un sitio para usar
title.done=Completo
title.error=Error
title.import.layout=Obtener diseño
title.inline.function=Función en línea
title.inline.property=Propiedades en línea
title.inline.type.alias=Alias de tipo incorporados
title.introduce.parameter.to.declaration=Insertar parámetros en declaraciones.
title.kdoc.for.abstracts=KDoc sobre abstracción
title.lateinit.var.overrides.lateinit.var=Lateinit var' anula el padre 'lateinit var
title.logger.factory.class.name=Nombre de clase de fábrica del registrador
title.logger.factory.method.name=Nombre del método de fábrica del registrador
title.move.method=Método de movimiento
title.move.nested.classes.to.upper.level=Pasar a un nivel superior en una clase anidada
title.packages.to.use.import.with=Paquetes que utilizan declaraciones de importación que contienen ''*''
title.parameters=Parámetro
title.rename.file=Cambiar nombre de archivo
title.rename.file.to=Cambie el nombre del archivo a:
title.rename.overloads.to=Cambiar nombre de sobrecarga:
title.rename.warning=Advertencia de cambio de nombre
title.select.a.name.for.this.parameter=''this@{0}'' Seleccione el nombre del parámetro
title.select.target.code.block=Seleccionar bloque de código de destino
title.success=Correcto
to.fully.qualified.name=Destino (nombre completo)\:
tooltip.implements.function=Implementar la función en:
tooltip.implements.property=Implementar la propiedad en:
tooltip.is.implemented.by=Implementado por
tooltip.is.subclassed.by=Se convierte en una subclase de
tooltip.overrides.function=Anula la función en:
tooltip.overrides.property=Anula la propiedad en:
top.level=Arriba
two.comparisons.should.be.converted.to.a.range.check=Debe convertir los dos elementos de comparación en una verificación de rango.
type.0.1.is.not.accessible.from.target.module={0,choice, 0\#type|2\#type} {1} no es accesible en el módulo de destino.
type.alias.0=Escriba el alias "{0}"
type.arguments.will.be.lost.after.conversion.0=Los argumentos de tipo se pierden cuando se convierten. {0}
type.parameter.0=Escriba el parámetro "{0}"
type.parameter.can.have.0.variance=El parámetro de tipo debe tener una variación de {0}.
type.provider.anonymous.object=Objeto anónimo
type.provider.no.expression.found=Expresión no encontrada
type.provider.smart.cast.from=(transmisión inteligente de {0})
type.provider.unknown.type=Tipo desconocido
unclear.precedence.of.binary.expression.inspection=Debe utilizar paréntesis para separar claramente las expresiones.
unclear.precedence.of.binary.expression.inspection.display.name=Múltiples operadores con diferente precedencia
unclear.precedence.of.binary.expression.quickfix=Agregue paréntesis para mayor claridad
unclear.precedence.of.binary.expression.report.even.obvious.cases.checkbox=Informe de caso muy claro.
unknown.types.title=Tipo desconocido
unlabeled.return.inside.lambda=Retorno sin etiqueta dentro de lambda
unrecognized.reference.will.be.skipped.0=Se omiten las referencias no reconocidas. {0}
unsupported.usage.0=Uso no admitido\: {0}
until.can.be.replaced.with.rangeUntil.operator=Hasta' se puede reemplazar con el operador '..<
unused.equals.expression=Expresión igual a obsoleta
unused.import.directive=Directiva de importación obsoleta
unused.return.value.of.a.function.with.lambda.expression.body=Valor de retorno no utilizado de la función con cuerpo de expresión lambda
unused.unary.operator=Operador unario obsoleto
unwrap.else=Desenvolver más en ''{0}''.
unwrap.expression=''{0}'' desenvolver
unwrap.parameter=Desenvolver ''{0}'' argumento ''{1}''
update.indices=Actualización del índice...
update.obsolete.label.syntax=Actualice la sintaxis de la etiqueta obsoleta.
usage.of.kotlin.internal.declaration.from.different.module=Dónde utilizar las declaraciones internas de Kotlin en otros módulos
usage.of.redundant.or.deprecated.syntax.or.deprecated.symbols=Dónde utilizar sintaxis redundante o obsoleta o símbolos obsoletos
usage.provider.text.property.of.0={0} de {1}
usage.provider.text.unnamed=<nombre no especificado>
usages.of.outer.class.instance.inside.of.property.0.won.t.be.processed=El uso de una instancia de clase externa dentro de la propiedad ''{0}'' no se procesa
use.destructuring.declaration=Usando declaraciones desestructurantes
use.expression.body.instead.of.0=Utilice el cuerpo de la expresión en lugar de {0}.
use.inherited.visibility=Utilice visibilidad heredada.
use.of.getter.method.instead.of.property.access.syntax=Utilice métodos getter en lugar de sintaxis de acceso a propiedades
use.of.non.const.kotlin.property.as.java.constant.is.incorrect.will.be.forbidden.in.1.4=El uso de propiedades de Kotlin no constantes como constantes de Java es incorrecto y estará prohibido en 1.4.
use.of.setter.method.instead.of.property.access.syntax=Utilice métodos de establecimiento en lugar de sintaxis de acceso a propiedades
use.property.access.syntax=Usar la sintaxis de acceso a la propiedad
use.property.access.syntax.option.report.non.trivial.accessors=Informes de acceso no obvio
use.withindex.instead.of.manual.index.increment=Utilice withIndex() en lugar del incremento de índice manual
useless.call.on.collection.type=Llamadas innecesarias a tipos de cobranza
useless.call.on.not.null.type=Llamada innecesaria a tipo no nulo
variable.0.is.assigned.to.itself=La variable ''{0}'' está autoasignada.
variable.declaration.could.be.inlined=Puede incorporar declaraciones de variables.
variable.declaration.could.be.moved.into.when=Puede mover declaraciones de variables a ''cuándo''.
variable.is.never.modified.and.can.be.declared.immutable.using.val=Las variables no están calificadas y pueden declararse inmutables usando ''val''.
variable.is.same.as.0.and.should.be.inlined=La variable debe ser igual a ''{0}'' y estar insertada.
variable.name.0.matches.the.name.of.a.different.component=El nombre de la variable ''{0}'' coincide con el nombre de otro componente.
variable.used.only.in.following.return.and.should.be.inlined=La variable se usa solo en la próxima devolución y debe estar insertada.
vcs.code.author=Kotlin: muestra sugerencias incrustadas a los autores de código
version={versión}
visibility=&Visibilidad\:
when.has.only.else.branch.and.should.be.simplified=Dado que "cuándo" sólo tiene una rama "else", necesitamos simplificarla.
when.with.subject.should.be.used=Debes usar ''cuando'' con un objeto.
wrap.argument.with.parentheses=Envolver argumentos entre paréntesis
wrap.element.with.0.call=Envuelva el elemento con una llamada a ''{0}()''.
wrap.expression.in.parentheses=Rodear expresiones entre paréntesis
wrap.run.fix.text=Convertir para ejecutar {...}.
wrap.unary.operator.quickfix.text=Envuelva operadores y valores unarios con ().
wrap.with=Envuélvalo con [].
wrap.with.array.literal=Envuélvalo en una matriz literal.
wrap.with.collection.literal.call=Envuélvalo en una llamada literal de colección.
wrap.with.coroutine.scope.fix.family.name=Envolviendo con coroutineScope
wrap.with.coroutine.scope.fix.text=Envuelva el cuerpo de la función con ''coroutineScope {... }''.
wrap.with.coroutine.scope.fix.text2=Complete la llamada con ''coroutineScope {... }''.
wrap.with.coroutine.scope.fix.text3=Retire el receptor y envuélvalo con ''coroutineScope {... }''.
wrap.with.let.call=Envuélvalo con una llamada a ''?.let {... }''.
