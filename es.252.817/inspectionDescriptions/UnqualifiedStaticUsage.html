<html>
<body>
Informa el uso de miembros static que no están cualificados
con el nombre de clase.
<p>
Esto es legal si el miembro static está en
la misma clase, pero puede resultar confuso.
</p>
<p><b>Ejemplo:</b></p>
<pre><code>
  class Foo {
    static void foo() {}
    static int x;

    void bar() {
      foo();
      System.out.println(x);
    }

    static void baz() { foo(); }
  }
</code></pre>
<p>Después de aplicar la corrección rápida:</p>
<pre><code>
  class Foo {
    static void foo() {}
    static int x;

    void bar() {
      Foo.foo();
      System.out.println(Foo.x);
    }

    static void baz() { Foo.foo(); }
  }
</code></pre>
<!-- tooltip end -->
<p>Usa la configuración de inspección para alternar el informe de los siguientes elementos:</p>
<ul>
  <li>
    <p>
      acceso a campos static<br>
      <code>void bar() { System.out.println(x); }</code>
    </p>
  </li>
  <li>
    <p>
      llamadas a métodos static<br>
      <code>void bar() { foo(); }</code><br>
      <code>static void baz() { foo(); }</code>
    </p>
  </li>
</ul>
<p>
  También puedes configurar la inspección para que solo informe el uso de miembros static desde un contexto no estático.
  En el ejemplo anterior, no se informará <code>static void baz() { foo(); }</code>.
</p>
</body>
</html>