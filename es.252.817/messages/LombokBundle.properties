action.defaultLombokData.description=Acción para reemplazar métodos getter/setter/equals/hashcode/toString con la anotación @Data de lombok
action.defaultLombokData.text=@Data por defecto
action.defaultLombokEqualsAndHashcode.description=Acción para reemplazar métodos equals y hashcode con la anotación @EqualsAndHashcode de lombok
action.defaultLombokEqualsAndHashcode.text=@EqualsAndHashcode por defecto
action.defaultLombokGetter.description=Acción para reemplazar todos los métodos getter con la anotación @Getter de lombok
action.defaultLombokGetter.text=@Getter por defecto
action.defaultLombokLogger.description=Acción para reemplazar logger con la anotación @Log de lombok
action.defaultLombokLogger.text=@Log (y similares)
action.defaultLombokSetter.description=Acción para reemplazar todos los métodos setter con la anotación @Setter de lombok
action.defaultLombokSetter.text=@Setter por defecto
action.defaultLombokToString.description=Acción para reemplazar método toString con la anotación @ToString de lombok
action.defaultLombokToString.text=@ToString por defecto
action.delombokAny.description=Acción para reemplazar todas las anotaciones lombok con métodos java puros
action.delombokAny.text=Todas las anotaciones Lombok
action.delombokBuilder.description=Acción para reemplazar la anotación @Builder de lombok con métodos java puros
action.delombokBuilder.text=@Builder
action.delombokConstructor.description=Acción para reemplazar las anotaciones @NoArgsConstructor, @RequiredArgsConstructor y @AllArgsConstructor de lombok con métodos java puros
action.delombokConstructor.text=@Constructors
action.delombokData.description=Acción para reemplazar la anotación @Data de lombok con métodos java puros
action.delombokData.text=@Data
action.delombokDelegate.description=Acción para reemplazar la anotación @Delegate de lombok con métodos java puros
action.delombokDelegate.text=@Delegate
action.delombokEqualsAndHashCode.description=Acción para reemplazar la anotación @EqualsAndHashCode de lombok con métodos java puros
action.delombokEqualsAndHashCode.text=@EqualsAndHashCode
action.delombokFieldNameCostants.description=Acción para reemplazar la anotación @FieldNameConstants de lombok con campos java puros
action.delombokFieldNameCostants.text=@FieldNameConstants
action.delombokGetter.description=Acción para reemplazar la anotación @Getter de lombok con métodos getter puros
action.delombokGetter.text=@Getter
action.delombokLogger.description=Acción para reemplazar la anotación @Log (y otras) de lombok con campo log puro
action.delombokLogger.text=@Log (y similares)
action.delombokSetter.description=Acción para reemplazar la anotación @Setter de lombok con métodos setter puros
action.delombokSetter.text=@Setter
action.delombokStandardException.description=Acción para reemplazar la anotación @StandardException de lombok con métodos java puros
action.delombokStandardException.text=@StandardException
action.delombokSuperBuilder.description=Acción para reemplazar la anotación @SuperBuilder de lombok con métodos java puros
action.delombokSuperBuilder.text=@SuperBuilder
action.delombokToString.description=Acción para reemplazar la anotación @ToString de lombok con métodos java puros
action.delombokToString.text=@ToString
action.delombokUtilityClass.description=Acción para reemplazar la anotación @UtilityClass de lombok con campos java puros
action.delombokUtilityClass.text=@UtilityClass
action.delombokValue.description=Acción para reemplazar la anotación @Value de lombok con métodos java puros
action.delombokValue.text=@Value
action.delombokWither.description=Acción para reemplazar la anotación @Wither de lombok con métodos java puros
action.delombokWither.text=@Wither
checkbox.settings.jps.fix=Agregar automáticamente la opción de compilación '-Djps.track.ap.dependencies\=false' para versiones antiguas de lombok (<1.18.16)
checkbox.settings.version.warning=Habilitar advertencia de versión lombok para versiones antiguas de lombok
color.settings.clear=Limpiar
color.settings.comment=Comentario
color.settings.key=Clave
color.settings.separator=Separador
color.settings.value=Valor
config.warn.annotation-processing.disabled.title=Lombok requiere el procesamiento de anotaciones habilitado
config.warn.dependency.outdated.message=<br>El proyecto "{0}" parece tener una dependencia de Lombok desactualizada.<br>Versión configurada "{1}", pero ya existe al menos la versión "{2}" disponible<br><a href\="https\://projectlombok.org/download">¿Desea actualizar?</a> <br>
config.warn.dependency.outdated.title=La dependencia de Lombok posiblemente está desactualizada
configurable.name.lombok.config=Configuración de Lombok
dialog.message.logger.field.s.not.private.sfinal.field.named.s.refactor.anyway=Campo Logger\: "{0}" no es un campo private {1, choice, 0\#|1\#static }final llamado "{2}". ¿Refactorizar de todos modos?
dialog.message.this.element.cannot.be.renamed=Este elemento no puede ser renombrado.
dialog.title.attention=¡Atención\!
filetype.lombok.config.description=Archivo de configuración de Lombok
group.DelombokActionGroup.description=Refactorizar código eliminando anotaciones lombok
group.DelombokActionGroup.text=Delombok
group.LombokActionGroup.description=Refactorizar código con anotaciones lombok
group.LombokActionGroup.text=Lombok
inspection.builder.static.import.name=Usando import estático para métodos generados por Lombok
inspection.deprecated.lombok.display.name=Anotaciones Lombok deprecadas
inspection.lombok.display.name=Anotaciones Lombok
inspection.lombok.getter.may.be.used.display.class.message=La clase ''{0}'' puede usar Lombok @Getter
inspection.lombok.getter.may.be.used.display.field.message=El campo ''{0}'' puede tener Lombok @Getter
inspection.lombok.getter.may.be.used.display.fix.family.name=Reemplazar método getter explícito con Lombok @Getter
inspection.lombok.getter.may.be.used.display.fix.name=Usar lombok @Getter para ''{0}''
inspection.lombok.getter.may.be.used.display.name=Se puede usar Lombok @Getter
inspection.lombok.group.name.lombok=Lombok
inspection.lombok.group.name.redundant.definitions=Definiciones redundantes
inspection.lombok.group.name.redundant.modifiers=Modificadores redundantes
inspection.lombok.setter.may.be.used.display.class.message=La clase ''{0}'' puede usar Lombok @Setter
inspection.lombok.setter.may.be.used.display.field.message=El campo ''{0}'' puede tener Lombok @Setter
inspection.lombok.setter.may.be.used.display.fix.family.name=Reemplazar método setter explícito con Lombok @Setter
inspection.lombok.setter.may.be.used.display.fix.name=Usar lombok @Setter para ''{0}''
inspection.lombok.setter.may.be.used.display.name=Se puede usar Lombok @Setter
inspection.message.annotation.copy.duplicate=La anotación ''{0}'' ya está presente en el campo y será duplicada por la configuración onX
inspection.message.annotation.not.lombok.copyable=Lombok no copia la anotación ''{0}'' al constructor
inspection.message.annotation.only.supported.on.class.or.enum.type={0} solo está soportado en una clase o enum.
inspection.message.builder.can.be.used.only=@Builder solo está soportado en clases, records, constructores y métodos.
inspection.message.builder.default.requires.builder.annotation=@Builder.Default requiere @Builder o @SuperBuilder en la clase para tener significado.
inspection.message.builder.default.requires.initializing.expression=@Builder.Default requiere una expresión de inicialización (' \= algo;').
inspection.message.builder.default.singular.cannot.be.mixed=@Builder.Default y @Singular no pueden mezclarse.
inspection.message.can.t.singularize.this.name=No se puede singularizar este nombre\: ''{0}''; especifique la forma singular explícitamente (ej. @Singular("sheep"))
inspection.message.cleanup.legal.only.on.local.variable.declaration.inside.block=@Cleanup\: solo es válido en una declaración de variable local dentro de un bloque
inspection.message.cleanup.legal.only.on.local.variable.declarations=@Cleanup solo es válido en declaraciones de variables locales
inspection.message.cleanup.method.s.not.found.on.target.class=@Cleanup\: método ''{0}()'' no encontrado en la clase destino
inspection.message.cleanup.value.cannot.be.empty.string=@Cleanup\: el valor no puede ser una cadena vacía
inspection.message.cleanup.variable.declarations.need.to.be.initialized=Las declaraciones de variables @Cleanup necesitan ser inicializadas.
inspection.message.constructor.noargs.needs.to.be.forced=La clase contiene campos requeridos, debe forzar NoArgsConstructor.
inspection.message.constructor.with.d.parameters.already.defined=El constructor con ''{0}'' parámetros ya está definido
inspection.message.constructor.without.parameters.already.defined=El constructor sin parámetros ya está definido
inspection.message.custom.log.does.not.allow.topic=@CustomLog no permite un topic.
inspection.message.custom.log.not.configured.correctly=@CustomLog no está configurado correctamente; configure log.custom.declaration en lombok.config.
inspection.message.custom.log.requires.topic=@CustomLog requiere un topic.
inspection.message.data.only.supported.on.class.type=@Data solo está soportado en un tipo de clase
inspection.message.default.constructor.doesn.t.exist=El constructor por defecto no existe
inspection.message.delegate.can.only.use.concrete.class.types=@Delegate solo puede usar tipos de clase concretos, no comodines, arrays, variables de tipo o primitivos. ''{0}'' es un tipo de clase incorrecto
inspection.message.delegate.does.not.support.recursion.delegating=@Delegate no admite recursión (delegación a un tipo que tiene miembros @Delegate). El miembro ''{0}'' es @Delegate en el tipo ''{1}''
inspection.message.delegate.legal.only.on.instance.fields=@Delegate solo es válido en campos de instancia o métodos de instancia sin argumentos.
inspection.message.delegate.legal.only.on.no.argument.methods=@Delegate solo es válido en métodos sin argumentos.
inspection.message.delegate.unknown.type.method=No se puede encontrar el método ''{0}''
inspection.message.equals.and.hashcode.only.supported.on.class.type=@EqualsAndHashCode solo es compatible con tipos de clase
inspection.message.exclude.are.mutually.exclusive.exclude.parameter.will.be.ignored=Los parámetros 'exclude' y 'of' son mutuamente excluyentes; el parámetro 'exclude' será ignorado
inspection.message.existing.builder.must.be.abstract.static.inner.class=El Builder existente debe ser una clase interna static abstracta.
inspection.message.field.name.constants.inner.type=El tipo interno @FieldNameConstants ya existe, pero asEnum\={0} no coincide con el tipo existente
inspection.message.field.name.constants.only.supported.on.class.enum.or.field.type=@FieldNameConstants solo es compatible con tipos de clase, enum, record o campo
inspection.message.field.name.constants.only.supported.on.class.or.enum=@FieldNameConstants solo es compatible con una clase, un enum o un record.
inspection.message.field.s.does.not.exist=El campo ''{0}'' no existe.
inspection.message.field.s.does.not.exist.exclude=El campo ''{0}'' no existe
inspection.message.field.s.does.not.exist.field=El campo ''{0}'' no existe
inspection.message.field.s.would.have.been.excluded.anyway=El campo ''{0}'' habría sido excluido de todas formas
inspection.message.generating.equals.hashcode.implementation=Generando implementación de equals/hashCode sin llamada a la superclase, aunque esta clase no extiende java.lang.Object. Si esto es intencional, agregue '(callSuper\=false)' a su tipo.
inspection.message.generating.equals.hashcode.with.super.call=Generar equals/hashCode con una llamada super a java.lang.Object no tiene sentido.
inspection.message.getter.only.supported.on.class.enum.or.field.type=@Getter solo es compatible con tipos de clase, enum o campo
inspection.message.jacksonized.builder.on.abstract.classes=Los builders en clases abstractas no pueden ser @Jacksonized (el builder nunca se usaría).
inspection.message.jacksonized.cannot.process.both.builder.superbuilder=@Jacksonized no puede procesar tanto @Builder como @SuperBuilder en la misma clase.
inspection.message.jacksonized.jsondeserialize.already.exists=@JsonDeserialize ya existe en la clase. Elimine @JsonDeserialize o elimine @Jacksonized y configure Jackson manualmente.
inspection.message.jacksonized.requires.builder.superbuilder=@Jacksonized requiere @Builder o @SuperBuilder para tener significado.
inspection.message.lazy.does.not.work.with.access.level.none='lazy' no funciona con AccessLevel.NONE.
inspection.message.lazy.not.supported.for.getter.on.type='lazy' no es compatible con @Getter en un tipo
inspection.message.lazy.requires.field.initialization='lazy' requiere inicialización del campo.
inspection.message.lazy.requires.field.to.be.private.final='lazy' requiere que el campo sea private y final
inspection.message.lombok.annotation.deprecated.not.supported=La anotación de Lombok ''{0}'' está obsoleta y ya no es compatible con el plugin de Lombok. Use ''{1}'' en su lugar.
inspection.message.lombok.annotations.are.not.allowed.on.builder.class=Las anotaciones de Lombok no están permitidas en la clase builder.
inspection.message.lombok.builder.needs.proper.constructor.for.this.class=Lombok @Builder necesita un constructor apropiado para esta clase
inspection.message.lombok.does.not.know=Lombok no puede generar métodos builder en forma singular para el tipo ''{0}''
inspection.message.lombok.needs.default.constructor.in.base.class=Lombok necesita un constructor por defecto en la clase base
inspection.message.method.s.matched.static.constructor.name.already.defined=El método ''{0}'' que coincide con staticConstructorName ya está definido
inspection.message.method.s.with.d.parameters.matched.static.constructor.name.already.defined=El método ''{0}'' con ''{1}'' parámetros que coincide con staticConstructorName ya está definido
inspection.message.not.allowed.in.old.style.for.loops=No se permite ''{0}'' en bucles for de estilo antiguo
inspection.message.not.allowed.with.lambda.expressions=No se permite ''{0}'' con expresiones lambda.
inspection.message.not.compatible.with.array.initializer.expressions=''{0}'' no es compatible con expresiones inicializadoras de arrays. Use la forma completa (new int[] '{' ... '}' en lugar de solo '{' ... '}')
inspection.message.not.generated.s.method.with.same.name.already.exists=No se generó ''{0}()''\: Ya existe un método con el mismo nombre
inspection.message.not.generated.s.method.with.similar.name.s.already.exists=No se generó ''{0}()''\: Ya existe un método con nombre similar ''{0}''
inspection.message.not.generating.constant=No se genera constante para este campo\: El nombre de la constante sería igual al nombre de este campo.
inspection.message.not.generating.equals.hashcode=No se generan equals y hashCode\: Ya existe un método con uno de esos nombres. (Se generarán ambos métodos o ninguno).
inspection.message.not.generating.field.s.field.with.same.name.already.exists=No se genera el campo ''{0}''\: Ya existe un campo con el mismo nombre
inspection.message.not.generating.getter.for.this.field=No se genera getter para este campo\: No coincide con su lista de prefijos @Accessors.
inspection.message.not.generating.s.method.with.that.name.already.exists=No se genera ''{0}()''\: Ya existe un método con ese nombre
inspection.message.not.generating.setter.for.this.field.it=No se genera setter para este campo\: No coincide con su lista de prefijos @Accessors.
inspection.message.not.generating.setter.for.this.field.setters=No se genera setter para este campo\: No se pueden generar setters para campos final.
inspection.message.not.generating.wither=No se genera wither para este campo\: No se pueden generar withers para campos static.
inspection.message.not.generating.wither.for.this.field.withers=No se genera wither para este campo\: No se pueden generar withers para campos que comienzan con $.
inspection.message.not.generating.wither.for.this.field.withers.cannot.be.generated=No se genera wither para este campo\: No se pueden generar withers para campos final inicializados.
inspection.message.obtain.via.is.static.true.not.valid.unless.method.has.been.set=@ObtainVia(isStatic \= true) no es válido a menos que se haya establecido 'method'.
inspection.message.on.local.variable.requires.initializer.expression=''{0}'' en una variable local requiere una expresión inicializadora
inspection.message.s.legal.only.on.classes.enums=''@{0}'' solo es válido en clases y enums
inspection.message.s.not.valid.identifier=''{0}'' no es un identificador válido
inspection.message.setter.only.supported.on.class.or.field.type=@Setter solo es compatible con tipos de clase o campo
inspection.message.slf4j.logger.defined.explicitly=El Logger Slf4j está definido explícitamente. Use la anotación Lombok @Slf4j en su lugar.
inspection.message.sneakythrows.calls.to.sibling.super.constructors.excluded=Las llamadas a constructores hermanos/super siempre están excluidas de @SneakyThrows; @SneakyThrows ha sido ignorado porque no hay otro código en este constructor.
inspection.message.standardexception.accesslevel.none.not.valid=AccessLevel.NONE no es válido aquí
inspection.message.standardexception.class.only.supported.on.class=@StandardException solo es compatible con una clase
inspection.message.standardexception.should.extend.throwable=@StandardException requiere que extienda un tipo Throwable
inspection.message.superbuilder.can.be.used.on.classes.only=@SuperBuilder solo es compatible con clases.
inspection.message.superbuilder.can.be.used.on.static.inner.classes.only=@SuperBuilder no es compatible con clases anidadas no static.
inspection.message.synchronized.field.is.not.static=El campo ''{0}'' es no static y no puede usarse en este método static
inspection.message.synchronized.legal.only.on.concrete.methods=@Synchronized solo es válido en métodos concretos.
inspection.message.synchronized.legal.only.on.methods.in.classes.enums=@Synchronized solo es válido en métodos de clases y enums.
inspection.message.syntax.either.obtain.via.field=La sintaxis es @ObtainVia(field \= "fieldName") o @ObtainVia(method \= "methodName").
inspection.message.to.string.only.supported.on.class.or.enum.type=@ToString solo es compatible con tipos de clase o enum
inspection.message.utility.class.already.marks.class.final=@UtilityClass ya marca la clase como final.
inspection.message.utility.class.already.marks.fields.static=@UtilityClass ya marca los campos como static.
inspection.message.utility.class.already.marks.inner.classes.static=@UtilityClass ya marca las clases internas como static.
inspection.message.utility.class.already.marks.methods.static=@UtilityClass ya marca los métodos como static.
inspection.message.utility.class.automatically.makes.class.static=@UtilityClass hace la clase static automáticamente, sin embargo, esta clase no puede hacerse static.
inspection.message.utility.class.cannot.be.placed=@UtilityClass no puede colocarse en una clase local de método o clase interna anónima, ni en ninguna clase anidada en dicha clase.
inspection.message.utility.class.only.supported.on.class=@UtilityClass solo es compatible con una clase (no puede ser una interfaz, enum o anotación).
inspection.message.utility.classes.cannot.have.declared.constructors=@UtilityClasses no puede tener constructores declarados.
inspection.message.val.already.marks.variables.final='val' ya marca las variables como final.
inspection.message.val.works.only.on.local.variables='val' solo funciona en variables locales y bucles foreach
inspection.message.value.already.marks.class.final=@Value ya marca la clase como final.
inspection.message.value.already.marks.non.static.fields.final=@Value ya marca los campos no static como final.
inspection.message.value.already.marks.non.static.package.local.fields.private=@Value ya marca los campos package-local no static como private.
inspection.message.value.only.supported.on.class.type=@Value solo es compatible con un tipo de clase
inspection.message.var.works.only.on.local.variables.on.for.foreach.loops='var' solo funciona en variables locales y bucles for/foreach
inspection.message.wither.needs.constructor.for.all.fields.d.parameters=@Wither necesita constructor para todos los campos (''{0}'' parámetros)
inspection.message.wither.only.supported.on.class.or.field=@Wither solo es compatible con una clase o un campo.
inspection.redundant.modifiers.utility.class.lombok.display.name=Modificadores @UtilityClass
inspection.redundant.modifiers.val.lombok.display.name=final innecesario antes de 'val'
inspection.redundant.modifiers.value.lombok.display.name=Modificadores @Value
inspection.redundant.slf.4.j.definition.display.name=@Slf4j
inspection.springqualifiercopyable.lombok.display.name=@Qualifier no es copiable por Lombok
inspection.static.method.import.error=Las importaciones static de métodos generados por Lombok no funcionan con javac
intention.category.lombok=Java/Lombok
intention.family.name.slf4j.annotation=Reemplazar campo logger con anotación @Slf4j
intention.name.create.new.field.s=Crear nuevo campo ''{0}''
intention.name.replace.with.lombok=Reemplazar con Lombok
make.abstract.and.static.modifier.quickfix=Hacer ''{0}'' abstract y static
make.abstract.and.static.modifier.quickfix.family.name=Cambiar modificador
notification.enable.annotation.processing=Habilitar procesamiento de anotaciones
notification.group.lombok=Problema de integración de Lombok
plugin.settings.title=Lombok
popup.content.java.annotation.processing.has.been.enabled=Se ha habilitado el procesamiento de anotaciones Java
replace.0.with.explicit.type.lombok=Reemplazar ''{0}'' con tipo explícito (Lombok)
replace.explicit.type.with.0.lombok=Reemplazar tipo explícito con ''{0}'' (Lombok)
replace.synchronized.lombok.intention=Reemplazar con Lombok @Synchronized
replace.with.annotations.lombok=Reemplazar con anotaciones (Lombok)