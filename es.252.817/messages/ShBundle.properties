0.is.true.use.false.instead='[ 0 ]' es verdadero. Usa 'falso' en vez.
action.ShGenerateForLoop.description=Crea un bucle for
action.ShGenerateForLoop.text=Ciclo For
action.ShGenerateUntilLoop.description=Crea un bucle hasta
action.ShGenerateUntilLoop.text=Bucle de until
action.ShGenerateWhileLoop.description=Crea un búcle while
action.ShGenerateWhileLoop.text=Ciclo While
action.runShellFileAction.description=Ejecutar archivo shell actual en la terminal
action.runShellFileAction.text=Ejecutar archivo
add.dev.null.to.prevent.ssh.from.swallowing.stdin=Agrega '< /dev/null' para evitar que SSH consuma stdin.
aliases.can.t.use.positional.parameters.use.a.function=Los alias no pueden utilizar parámetros posicionales. Usa una función.
argument.mixes.string.and.array.use.or.separate.argument=El argumento combina cadena y array. Usar '*' o un argumento separado.
argument.to.implicit.n.is.always.true.due.to.literal.strings=El argumento para el parámetro '-n' implícito es siempre verdadero debido a los strings literales.
arrays.don.t.work.as.operands.in.use.a.loop.or.concatenate.with.instead.of=Los arrays no funcionan como operandos en '[ ]'. Usa un bucle (o concatena con '*' en lugar de '@').
arrays.implicitly.concatenate.in.use.a.loop.or.explicit.instead.of=Los arrays se concatenan implícitamente en `[[ ]]`. Utiliza un bucle (o '*' explícito en lugar de '@').
ash.scripts.will.be.checked.as.dash.add.shellcheck.shell.dash.to.silence=Los scripts Ash serán comprobados como Dash. Añade '# shellcheck shell=dash' para silenciar.
assigning.an.array.to.a.string.assign.as.array.or.use.instead.of.to.concatenate=¡Asignando una matriz a una cadena! Asigne como matriz o utilice '*' en lugar de '@' para concatenar.
bash.does.not.support.multidimensional.arrays.use.1d.or.associative.arrays=Bash no es compatible con arrays multidimensionales. Utilice sólo arrays asociativos o unidimensionales.
bash.doesn.t.support.variables.in.brace.range.expansions=Bash no admite variables en expansiones de rango entre llaves.
bin.sh.was.specified.so.is.not.supported.even.when.sh.is.actually.bash='#!/bin/sh' fue especificado, por lo que  no es compatible, incluso cuando sh es en realidad bash.
brace.expansion.doesn.t.happen.in.use.a.loop=La expansión de llaves no pasa en `[[ ]]`. Usa un loop.
brace.expansions.and.globs.are.literal.in.assignments.quote.it.or.use.an.array=Las expansiones de llaves y globs son literales en las asignaciones. Usa comillas o una matriz.
brace.expansions.don.t.work.as.operands.in.use.a.loop=Las expansiones de llaves no funcionan como operandos en "[ ]". Usa un bucle.
break.is.only.valid.in.loops=`break` es válido únicamente en bucles.
can.only.exit.with.status.0.255.other.data.should.be.written.to.stdout.stderr=Solo se puede salir con el estado 0-255. Los demás datos se deben escribir en stdout/stderr.
can.only.return.0.255.other.data.should.be.written.to.stdout=Solo puede devolver 0-255. Otros datos deben escribirse en stdout.
can.t.match.globs.use.or.grep=`[ .. ]` no puede coincidir con globos. Usar `[[ .. ]]` o grep.
can.t.use.in.use.instead=No puedes usar `=~` en `[ ]`. Usa `[[..]]` en su lugar.
can.t.use.sudo.with.builtins.like.cd.did.you.want.sudo.sh.c.instead=No se puede usar 'sudo' con funciones integradas como 'cd'. Usa 'sudo sh -c' en su lugar.
check.1008.this.shebang.was.unrecognized.shellcheck.only.supports.sh.bash.dash.ksh.add.a.shell.directive.to.specify=Este shebang no fue reconocido. ShellCheck solo acepta sh/bash/dash/ksh. Añade una directiva de 'shell' para especificar.
check.1009.the.mentioned.parser.error.was.in=El error del analizador mencionado fue en ...
check.1010.use.semicolon.or.linefeed.before.done.or.quote.to.make.it.literal=Deber ser un punto y coma o un salto de línea antes del 'done' (o entre comillas para hacerlo literal).
check.1011.this.apostrophe.terminated.the.single.quoted.string=¡Esta apóstrofe ha terminado la cadena entre comillas simples!
check.1012.is.just.literal.t.here.for.tab.use.printf.instead=`	` es aquí solo un carácter `t`. Para insertar una tabulación, usa "$(printf '	')" en su lugar.
check.1014.use.if.cmd.then.to.check.exit.code.or.if.cmd.to.check.output=Emplear 'if cmd; then ...' para comprobar el código de salida, o 'if [ "$(cmd)" = .. ]' para comprobar la salida.
check.1015.this.is.a.unicode.double.quote.delete.and.retype.it=Esto es una comilla doble Unicode. Elimínala y vuélvela a escribir.
check.1016.this.is.a.unicode.single.quote.delete.and.retype.it=Esto es una comilla simple Unicode. Bórrala y vuelve a escribirla.
check.1017.literal.carriage.return.run.script.through.tr.d=Retorno de carro literal. Ejecuta el script mediante `tr -d '\n'` .
check.1018.this.is.a.unicode.non.breaking.space.delete.it.and.retype.as.space=Este es un espacio en blanco irrompible Unicode. Elimínelo y vuelva a colocarlo con la tecla espacio.
check.1019.expected.this.to.be.an.argument.to.the.unary.condition=Se esperaba que este fuera un argumento de la condición unaria.
check.1020.you.need.a.space.before.the.if.single.then.else=Agrega un espacio antes del `]` o `]]`
check.1026.if.grouping.expressions.inside.use=Si se agrupan expresiones dentro de [[..]], usa (..).
check.1028.in.you.have.to.escape.or.preferably.combine.expressions=En [..] debes escapar ( ) o preferiblemente combinar expresiones [..].
check.1029.in.you.shouldn.t.escape.or=En `[[..]]` no deberías escapar `(` o `)`.
check.1035.you.need.a.space.here=Debes añadir un espacio aquí.
check.1036.is.invalid.here.did.you.forget.to.escape.it=`(` es inválido aquí. ¿Olvidó escaparlo?
check.1037.braces.are.required.for.positionals.over.9.e.g.10=Se requieren llaves para los argumentos posicionales mayores a 9, por ejemplo, 10.
check.1038.shells.are.space.sensitive.use.cmd.not.cmd=Los shells son sensibles a los espacios. Usar '< <(cmd)', no '<<(cmd)'.
check.1039.remove.indentation.before.end.token.or.use.and.indent.with.tabs=Quitar sangría antes del token de fin (o usar `<<-` y sangrar con pestañas).
check.1040.when.using.you.can.only.indent.with.tabs=Al utilizar <<-, sangrar con tabuladores.
check.1041.found.eof.further.down.but.not.on.a.separate.line=Se encontró 'eof' más abajo, pero no en una línea separada.
check.1042.found.eof.further.down.but.not.on.a.separate.line=Encontrado 'eof' más adelante, pero no en una línea separada.
check.1044.couldn.t.find.end.token.eof.in.the.here.document=No se pudo encontrar el símbolo final `EOF` en el documento heredado.
check.1045.expected.then=Se esperaba un 'then'
check.1045.it.s.not.foo.bar.just.foo.bar=Punto y coma redundante en 'foo ; bar'. Debería ser 'foo  bar'.
check.1046.couldn.t.find.fi.for.this.if=No se pudo encontrar 'fi' para este 'if'.
check.1047.expected.fi.matching.previously.mentioned.if=Se espera que 'fi' concuerde con el 'if' mencionado anteriormente.
check.1048.can.t.have.empty.then.clauses.use.true.as.a.no.op=No se puede tener cláusulas then vacías (usar 'true' como un no-op).
check.1049.did.you.forget.the.then.for.this.if=¿Se olvidó de especificar 'then' para este 'if'?
check.1051.semicolons.directly.after.then.are.not.allowed.just.remove.it=Tras 'then' no se permite el punto y coma. Elimínelo.
check.1052.semicolons.directly.after.then.are.not.allowed.just.remove.it=No se permiten punto y coma justo después de 'then'. Sólo elimínalo.
check.1053.semicolons.directly.after.else.are.not.allowed.just.remove.it=Los Punto y coma directamente después de 'else' no están permitidos, simplemente elimínalos.
check.1054.you.need.a.space.after.the=Agregar un espacio después de '{'.
check.1058.expected.do=Se esperaba `do`.
check.1061.couldn.t.find.done.for.this.do=No se pudo encontrar 'hecho' para este 'hacer'.
check.1062.expected.done.matching.previously.mentioned.do=Se esperaba 'done' en concordancia con el 'do' previamente mencionado.
check.1064.expected.a.to.open.the.function.definition=Se esperaba un '{' para abrir la definición de función.
check.1065.trying.to.declare.parameters.don.t.use.and.refer.to.params.as.1.2=No declarar parámetros. Usar () y referenciar los parámetros como $1, $2, etc.
check.1066.don.t.use.on.the.left.side.of.assignments=No uses '$' en el lado izquierdo de las asignaciones.
check.1068.don.t.put.spaces.around.the.in.assignments=No coloques espacios alrededor de '=' en asignaciones.
check.1069.you.need.a.space.before.the=Agrega un espacio antes de '['
check.1071.shellcheck.only.supports.sh.bash.dash.ksh.scripts.sorry=ShellCheck sólo admite sh/bash/dash/ksh scripts.
check.1072.unexpected=Inesperado ..
check.1073.couldn.t.parse.this.thing.fix.to.allow.more.checks=No se pudo analizar esto. Corrija para permitir más comprobaciones.
check.1075.use.elif.instead.of.else.if=Usa 'elif' en lugar de 'else if'.
check.1077.for.command.expansion.the.tick.should.slant.left.vs=Para expansión de comandos, usa backticks: (` vs ´).
check.1078.did.you.forget.to.close.this.double.quoted.string=¿Olvidó cerrar esta cadena con comillas dobles?
check.1079.this.is.actually.an.end.quote.but.due.to.next.char.it.looks.suspect=Esta es una comilla final, pero debido al siguiente carácter, parece sospechosa.
check.1081.scripts.are.case.sensitive.use.if.not.if=Los scripts distinguen entre mayúsculas y minúsculas. Usa 'if', no 'If'.
check.1082.this.file.has.a.utf.8.bom.remove.it.with.lc.ctype.c.sed.1s.yourscript=Este archivo tiene un BOM UTF-8. Elimínelo con el siguiente comando: LCCTYPE=C sed '1s/^...//' < elscript
check.1083.this.is.literal.check.expression.missing.or.quote.it=Esta `{`, `}` es literal. Verifica si falta `;` o pon la expresión entre comillas.
check.1084.use.not.for.the.shebang=El shebang es '#!', no '!#'
check.1086.don.t.use.on.the.iterator.name.in.for.loops=No usar '$' en el nombre del iterador en bucles for
check.1087.use.braces.when.expanding.arrays.e.g.array.idx.or.var.to.quiet=Usa llaves al expandir arreglos, por ejemplo: ${array[idx]} (o ${var}[.. para suprimir).
check.1088.parsing.stopped.here.invalid.use.of.parentheses=El análisis se detuvo aquí. ¿Uso no válido de paréntesis?
check.1089.parsing.stopped.here.is.this.keyword.correctly.matched.up=El análisis sintáctico se detuvo aquí. ¿Esta palabra clave está correctamente emparejada?
check.1090.can.t.follow.non.constant.source.use.a.directive.to.specify.location=No se puede seguir un origen no constante. Use una directiva para especificar la ubicación.
check.1091.not.following.error.message.here=No seguido: (mensaje de error aquí)
check.1094.parsing.of.sourced.file.failed.ignoring.it=El análisis del archivo de origen falló. Ignorándolo.
check.1095.you.need.a.space.or.linefeed.between.the.function.name.and.body=Necesitas un espacio o un salto de línea entre el nombre de la función y el cuerpo.
check.1097.unexpected.for.assignment.use.for.comparison.use=Inesperado '=='. Para asignación, use '='. Para comparación, coloque la expresión '==' entre corchetes.
check.1098.quote.escape.special.characters.when.using.eval.e.g.eval.a.b=Coloca entre comillas o escapa los caracteres especiales cuando uses eval, por ejemplo: eval "a=(b)".
check.1099.you.need.a.space.before.the=Añade un espacio antes del '#'
check.1100.this.is.a.unicode.dash.delete.and.retype.as.ascii.minus=Este es un guion Unicode. Elimina y vuelve a escribir como el carácter menos de ASCII.
check.1101.delete.trailing.spaces.after.to.break.line.or.use.quotes.for.literal.space=Eliminar espacios finales después de  para separar la línea (o usar comillas para el espacio literal).
check.1102.shells.disambiguate.differently.or.not.at.all.if.the.first.should.start.command.substitution.add.a.space.after.it=Los Shells llaman a $(( de forma distinta o no lo llaman en absoluto. Si el primer $( tiene que empezar a llamar una sustitución de comando, añadele un espacio tras él.
check.1104.use.not.just.for.the.shebang=El shebang es '#!', no '!'.
check.1105.shells.disambiguate.differently.or.not.at.all.if.the.first.should.start.a.subshell.add.a.space.after.it=Los shell distinguen (( de diferentes maneras o no de ninguna manera. Si el primer ( debe comenzar un subshell, agrega un espacio después de él.
check.1107.this.directive.is.unknown.it.will.be.ignored=Esta directiva es desconocida. Será ignorada.
check.1108.you.need.a.space.before.and.after.the=Añade un espacio antes y después de '='.
check.1109.this.is.an.unquoted.html.entity.replace.with.corresponding.character=Esta es una entidad HTML sin comillas. Reemplace con el carácter correspondiente.
check.1110.this.is.a.unicode.quote.delete.and.retype.it.or.quote.to.make.literal=Esta es una comilla Unicode. Eliminarla o volver a escribirla (o usar comillas para convertirla en literal).
check.1111.this.is.a.unicode.quote.delete.and.retype.it.or.ignore.singlequote.for.literal=Esto es una comilla Unicode. Reemplázala o vuelve a ingresala (o usa comillas simples para que sea un literal).
check.1112.this.is.a.unicode.quote.delete.and.retype.it.or.ignore.doublequote.for.literal=Esto es una cita Unicode. Elimínela y vuelva a escribirla (o use comillas dobles para que sea literal).
check.1113.use.not.just.for.the.sheban=El shebang es '#!', no '#'.
check.1114.remove.leading.spaces.before.the.shebang=Eliminar espacios iniciales antes del shebang
check.1115.remove.spaces.between.and.in.the.shebang=Eliminar espacios entre '#' y '!' en el shebang.
check.1116.missing.on.a.expression.or.use.for.arrays=$((..)) expresión con '$' faltante? Si es una matriz, utilice '( ('
check.1117.backslash.is.literal.in.prefer.explicit.escaping.n=La barra diagonal invertida es literal en "\n". Prefiere el escape explícito: "\n".
check.1118.delete.whitespace.after.the.here.doc.end.token=Eliminar el espacio en blanco después del token de finalización del documento heredado.
check.1119.add.a.linefeed.between.end.token.and.terminating=Añade un salto de línea entre el token de cierre y el término ')'.
check.1120.no.comments.allowed.after.here.doc.token.comment.the.next.line.instead=No se permiten comentarios después del token del documento here. Comenta la siguiente línea en su lugar.
check.1121.add.terminators.and.other.syntax.on.the.line.with.the.not.here=Añada terminadores ;/ (y otra sintaxis) en la línea con '<<', no aquí.
check.1122.nothing.allowed.after.end.token.to.continue.a.command.put.it.on.the.line.with.the=Nada permitido tras el token de fin. Para continuar el comando, colócalo en la línea con `<<`.
check.1123.shellcheck.directives.are.only.valid.in.front.of.complete.compound.commands.like.if.not.e.g.individual.elif.branches=Las directivas de ShellCheck son solo válidas delante de comandos completos compuestos, como `if`.
check.1124.shellcheck.directives.are.only.valid.in.front.of.complete.commands.like.case.statements.not.individual.case.branches=Las directivas de ShellCheck solo son válidas frente a comandos completos como sentencias 'case', no frente a ramas de casos individuales.
check.1126.place.shellcheck.directives.before.commands.not.after=Colocar directivas ShellCheck antes de comandos, no después.
check.1127.was.this.intended.as.a.comment.use.in.sh=Si es un comentario, use `#`.
check.1128.the.shebang.must.be.on.the.first.line.delete.blanks.and.move.comments=El shebang debe estar en la primera línea. Borrar espacios en blanco y mover comentarios.
check.1129.you.need.a.space.before.the=Agrega un espacio antes de '!'.
check.1130.you.need.a.space.before.the=Necesitas un espacio antes de ':'.
check.1131.use.elif.to.start.another.branch=Utiliza `elif` para comenzar otra rama.
check.exit.code.directly.with.e.g.if.mycmd.not.indirectly.with=Comprobar el código de salida directamente con 'if mycmd;', no indirectamente con '$'?
check1000.is.not.used.specially.and.should.therefore.be.escaped=$ debe ser escapado.
check1001.this.o.will.be.a.regular.o.in.this.context=Este o será una 'o' regular en este contexto.
check1003.want.to.escape.a.single.quote.echo.this.is.how.it.s.done=¿Quiere escapar un apóstrofo? echo 'Esto es como se hace'.
check1004.this.backslash.linefeed.is.literal.break.outside.single.quotes.if.you.just.want.to.break.the.line=Esta barra invertida+salto de línea es literal. Rompa fuera de las comillas simples si solo quiere romper la línea.
check1007.remove.space.after.if.trying.to.assign.a.value.or.for.empty.string.use.var=Quitar espacio después de '=' para asignar un valor (o usar var='' para cadena vacía).
consider.adding.a.default.case.even.if.it.just.exits.with.error=Considera agregar un caso por defecto '*' incluso si solo sale con error.
consider.using.cmd1.cmd2.file.instead.of.individual.redirects=Considera usar '{ cmd1; cmd2; } >> archivo' en lugar de redirecciones individuales.
consider.using.grep.c.instead.of.grep.wc=Considerar usar 'grep -c' en lugar de 'grep|wc'.
d.only.applies.to.the.first.expansion.of.this.glob.use.a.loop.to.check.any.all='-d' sólo se aplica a la primera expansión de este glob. Use un bucle para comprobar cualquiera/todos.
decimals.are.not.supported.either.use.integers.only.or.use.bc.or.awk.to.compare=Los decimales no son soportados. Utilice enteros o bc/awk para comparar.
declare.and.assign.separately.to.avoid.masking.return.values=Declare y asigne por separado para evitar enmascarar valores de retorno.
did.you.mean.ifs=¿Quiso decir IFS=$'	' ?
display.name.shell.check=ShellCheck
doesn.t.support.decimals.use.bc.or.awk='(( ))' no admite decimales. Utilice 'bc' o 'awk'.
don.t.quote.rhs.of.it.ll.match.literally.rather.than.as.a.regex=No entrecomillar el miembro derecho de =~; este hará coincidir literalmente, en lugar de como una expresión regular.
don.t.use.around.ranges.in.tr.it.replaces.literal.square.brackets=No usar '[]' alrededor de los rangos en 'tr', reemplaza los corchetes literales.
don.t.use.ls.grep.use.a.glob.or.a.for.loop.with.a.condition.to.allow.non.alphanumeric.filenames=No usar 'ls | grep'. Usar glob o un bucle for con una condición para permitir nombres de archivos no alfanuméricos.
don.t.use.variables.in.the.printf.format.string.use.printf.s.foo=No uses variables en la cadena de formato printf. En su lugar, usa la siguiente sintaxis: printf "..%s.." "$foo".
double.quote.array.expansions.to.avoid.re.splitting.elements=Expansiones de matrices entre comillas dobles para evitar volver a dividir elementos.
double.quote.to.prevent.globbing.and.word.splitting="Utiliza comillas dobles para evitar globbing y división de palabras"
e.doesn.t.work.with.globs.use.a.for.loop='-e' no funciona con globs, utiliza un bucle for.
echo.doesn.t.read.from.stdin.are.you.sure.you.should.be.piping.to.it='echo' no lee desde stdin; no se recomienda pasarlo por tubería.
echo.won.t.expand.escape.sequences.consider.printf='echo' no expandirá secuencias de escape. Considerar 'printf'.
egrep.is.non.standard.and.deprecated.use.grep.e.instead=egrep no es estándar y está deprecada. Utilice grep -E en su lugar.
elements.in.associative.arrays.need.index.e.g.array.index.value=Los elementos en matrices asociativas necesitan un índice, por ej: array=( [índice]=valor ).
ensure.the.shebang.uses.the.absolute.path.to.the.interpreter=Asegúrese de que el shebang utilice la ruta absoluta para el intérprete.
eq.is.for.integer.comparisons.use.instead='-eq' es para comparaciones de enteros. Utiliza '=' en su lugar.
error.message.can.t.find.info.in.your.path=No se puede encontrar la información en la variable $PATH.
error.message.cannot.determine.shell.script.parent.directory=No se puede determinar el directorio principal del script de shell
exec.does.not.automatically.invoke.a.shell.use.exec.sh.c.for.that='-exec' no invoca un shell automáticamente. Usar '-exec sh -c' para eso.
expanding.an.array.without.an.index.only.gives.the.first.element=Expandir una matriz sin un índice solo da el primer elemento.
expr.is.antiquated.consider.rewriting.this.using.or='expr' es obsoleto. Considera reescribirlo usando '$((..))', '${}' o '[[ ]]'.
expressions.don.t.expand.in.single.quotes.use.double.quotes.for.that=Las expresiones no se expanden en las comillas simples, utiliza comillas dobles para ello.
false.is.true.remove.the.brackets='[ false ]' es true. Quita los corchetes.
fgrep.is.non.standard.and.deprecated.use.grep.f.instead=fgrep no es estándar y está obsoleto. Usa grep -F en su lugar.
filetype.sh.shell.script.description=Script de shell
find.usages.type.function=función
flip.leading.and.if.this.should.be.a.quoted.substitution=Intercambia el '$' y las comillas iniciales si esta debe ser una sustitución entre comillas.
foo.appears.unused.verify.it.or.export.it='foo' parece no estar en uso. Verifícala o expórtala
foo.references.arguments.but.none.are.ever.passed=foo referencias argumentos, pero nunca se pasa ninguno
for.loops.over.find.output.are.fragile.use.find.exec.or.a.while.read.loop=Los bucles for sobre la salida de find son frágiles. Use 'find -exec' o un bucle while read.
function.keyword.is.non.standard.delete.it='function' palabra clave no es estándar. Elimínala.
getopts.specified.n.but.it.s.not.handled.by.this.case='getopts' especificó '-n', pero este 'case' no lo maneja.
globs.are.ignored.in.except.right.of.use.a.loop=Los globs se ignoran en `[[ ]]` excepto a la derecha de '=' y '!='. Usa un bucle.
globs.don.t.work.as.operands.in.use.a.loop=Los globs no funcionan como operandos en '[ ]'. Utilice un bucle.
grep.uses.regex.but.this.looks.like.a.glob=Grep utiliza expresiones regulares, pero este parece un patrón de coincidencia de archivos
i.do.mind.path.placeholder=prefiero mente
if.you.wanted.to.assign.the.output.of.the.pipeline.use.a.b.c=Si quieres asignar la salida de la tubería, usa 'a=$(b | c)'.
in.dash.something.is.not.supported=Esta funcionalidad no soporta dash.
in.functions.use.return.instead.of.break=En las funciones, usa "return" en vez de "break".
in.posix.sh.something.is.undefined=En POSIX sh, algo no está definido.
in.use.instead.of.a=En '[[..]]', usa '' en lugar de '-a'.
in.use.instead.of.o=En '[[..]]', usa '||' en lugar de '-o'.
increase.precision.by.replacing.a.b.c.with.a.c.b=Incrementar precisión reemplazando 'a/b*c' por 'a*c/b'.
injecting.filenames.is.fragile.and.insecure.use.parameters=Inyectar nombres de archivos es inseguro y frágil. Usar parámetros.
instead.of.1.use.true=En lugar de '[ 1 ]', usa 'true'.
instead.of.a.b.use.a.b=En lugar de '[ a || b ]', usar '[ a ] || [ b ]'.
instead.of.a.b.use.a.b2=En vez de '[ a  b ]', usa '[ a ]  [ b ]'.
instead.of.let.expr.prefer.expr=En lugar de `let expr`, prefiere `(( expr ))` .
instead.of.true.just.use.true=En lugar de '[ true ]', use 'true'.
intention.shell.script=Script de Shell
invalid.flags.are.not.handled.add.a.case=Los flags inválidos no se manejan. Agrega un case `*)`
is.a.subshell.did.you.mean.a.test.expression='(..)' es un sub-shell. ¿Quiso decir '[ .. ]', una expresión de prueba?
is.for.regex.but.this.looks.like.a.glob.use.instead='=~' es para expresiones regulares, pero este parece un glob. Utilice '=' en su lugar.
is.for.string.comparisons.use.gt.instead='>' es para comparaciones de cadenas. Utiliza '-gt' en su lugar.
is.not.a.valid.operator.use.a.b.instead='>=' no es un operador válido. Utiliza '! a < b' en su lugar.
is.unnecessary.on.arithmetic.variables='$ y ${} no son necesarias para variables aritméticas.
iterating.over.ls.output.is.fragile.use.globs=Iterar sobre la salida de ls es frágil. Usar máscaras de archivos
line.marker.run.0=Ejecutar {0}
literal.tilde.in.path.works.poorly.across.programs=El carácter tilde literal en PATH funciona deficientemente entre programas.
local.is.only.valid.in.functions='local' solo es válido dentro de funciones.
make.sure.all.escape.sequences.are.enclosed.in.to.prevent.line.wrapping.issues=Asegúrate de que todas las secuencias de escape estén encerradas en "`[..]` para evitar problemas de ajuste de línea
missing.or.terminating.exec.you.can.t.use.and.has.to.be.a.separate.quoted.argument=Falta ';' o '+' para terminar '-exec'. No usar |/||/, y usar comillas para ';'.
modification.of.var.is.local.to.subshell.caused.by.pipeline=La modificación de 'var' es local (al subshell causado por la tubería).
n.doesn.t.work.with.unquoted.arguments.quote.or.use=`-n` no funciona con argumentos sin comillas. Entrecomillar o usar ''[[ ]]''.
named.class.needs.outer.e.g.digit=La clase nombrada necesita un "[]" externo, por ejemplo: [[:digit:]]
note.that.a.b.c.is.not.if.then.else.c.may.run.when.a.is.true=Tenga en cuenta que 'A  B || C' no es 'if-then-else'. C puede ejecutarse cuando A es verdadero.
note.that.unescaped.this.expands.on.the.client.side=Si no se escapa, esto se expande en el lado del cliente.
note.that.unlike.globs.o.here.matches.ooo.but.not.oscar=Tenga en cuenta que a diferencia de los globs, 'o*' aquí coincide con 'ooo' pero no con 'oscar'
notification.group.shell.script=Herramientas de script de Shell disponibles
numbers.with.leading.0.are.considered.octal=Los números con un 0 inicial se consideran octales.
numerical.eq.does.not.dereference.in.expand.or.use.string.operator=El '-'eq numérico no desreferencia en [..]. Expanda o use el operador de cadena.
on.most.os.shebangs.can.only.specify.a.single.parameter=En la mayoría de los SO, las shebangs sólo pueden especificar un parámetro
only.one.integer.0.255.can.be.returned.use.stdout.for.other.data=Sólo se puede devolver un entero 0-255. Usa stdout para otros datos.
path.is.the.shell.search.path.use.another.name=PATH es la ruta de búsqueda del shell. Usa otro nombre.
piping.to.rm.a.command.that.doesn.t.read.stdin.wrong.command.or.missing.xargs=Pipeado a 'rm', un comando que no lee stdin. ¿Comando erróneo o xargs faltante?
possible.misspelling.myvariable.may.not.be.assigned.but.my.variable.is=Posible error de ortografía: MYVARIABLE pudiera no estar asignada, pero MYVARIABLE sí lo está.
prefer.explicit.n.to.check.for.output.or.run.command.without.to.check.for.success=Es preferible un '-n' explícito para comprobar la salida. Ejecutar el comando sin '[' y '[[' para comprobar el éxito.
prefer.explicit.n.to.check.non.empty.string.or.use.ne.to.check.boolean.integer=Prefiera explícito '-n' para verificar cadenas no vacías. Usar '=' o '-ne' para verificar booleanos y enteros.
prefer.mapfile.or.read.a.to.split.command.output.or.quote.to.avoid.splitting=Se prefiere 'mapfile' o 'read -a' para dividir la salida del comando (o usar comillas para evitar división).
prefer.p.q.as.p.a.q.is.not.well.defined=Prefiere '[ p ]  [ q ]' porque '[ p -a q ]' no está bien definido.
quote.arguments.to.unset.so.they.re.not.glob.expanded=Introduce las variables entre comillas para ignorar la sintaxis glob.
quote.eof.to.make.here.document.expansions.happen.on.the.server.side.rather.than.on.the.client=Agrega comillas alrededor de "EOF" para hacer que los documentos aquí se expandan en el lado del servidor en lugar de en el lado del cliente.
quote.expansions.in.this.for.loop.glob.to.prevent.wordsplitting.e.g.dir.txt=Encierre entre comillas las expansiones en este glob de bucle for para evitar la división de palabras, por ejemplo: "$dir"/*.txt
quote.parameters.to.tr.to.prevent.glob.expansion=Entrecomillar los parámetros de 'tr' para evitar la expansión glob.
quote.the.grep.pattern.so.the.shell.won.t.interpret.it=Cotizar el patrón grep para que el shell no lo interprete.
quote.the.parameter.to.name.so.the.shell.won.t.interpret.it=Citar el parámetro de '-name' para que el shell no lo interprete.
quote.the.rhs.of.in.to.prevent.glob.matching="Entre comillas la 'rhs of =' en '[[ ]]' para impedir el emparejamiento de más de un carácter (glob)."
quote.this.invalid.brace.expansion.since.it.should.be.passed.literally.to.eval=Poner entre comillas esta expansión de llaves no válida, ya que se debería pasar literalmente a eval.
quote.this.to.prevent.word.splitting=Adjuntar comillas a esto para evitar la partición de palabras
quote.to.prevent.word.splitting.or.split.robustly.with.mapfile.or.read.a=Cita para prevenir división de palabras, o división robusta con 'mapfile' o 'read -a'.
quotes.backslashes.in.this.variable.will.not.be.respected=Las comillas y las barras invertidas en esta variable no se tendrán en cuenta
quotes.backslashes.will.be.treated.literally.use.an.array=Las comillas y las barras invertidas se tratarán literalmente, utilizar un arreglo.
ranges.can.only.match.single.chars.mentioned.due.to.duplicates=Las rangos sólo pueden coincidir con caracteres individuales (mencionados debido a duplicados)
read.without.r.will.mangle.backslashes='read' sin '-r' mutilará las barras invertidas.
redirecting.to.echo.a.command.that.doesn.t.read.stdin.bad.quoting.or.missing.xargs=Redirigiendo a 'echo', un comando que no lee stdin. ¿Codificación incorrecta o falta xargs?
redirecting.to.from.command.name.instead.of.file.did.you.want.pipes.xargs.or.quote.to.ignore=Redireccionando a o desde un nombre de comando en lugar de un archivo. En su lugar, use tuberías o xargs (o comillas para ignorar).
redirection.applies.to.the.find.command.itself.rewrite.to.work.per.action.or.move.to.end=La redirección se aplica al comando 'buscar' en sí mismo. Reescribir para que funcione por acción (o mover al final).
remove.backticks.to.avoid.executing.output=Remueve las comillas invertidas para evitar ejecutar la salida
remove.exec.if.script.should.continue.after.this.command=Quitar "exec " si el script debe continuar despúes de este comando.
remove.for.numeric.index.or.escape.it.for.string=Eliminar '$' y '${}' para índice numérico, o escaparlos para cadena.
remove.or.use.expr.to.avoid.executing.output=Remover '$' o utilizar '_=$((expr))' para evitar ejecutar la salida.
remove.superfluous.around.condition=Quitar paréntesis `(..)` superfluos alrededor de la condición.
remove.superfluous.around.test.command=Eliminar superfluos `(..)` alrededor del comando de prueba.
remove.surrounding.to.avoid.executing.output=Remueve el '$()' que rodea para evitar ejecutar la salida.
sc2001.see.if.you.can.use.variable.search.replace.instead=SC2001: Ver si puedes utilizar ${variable//search/replace} en su lugar.
sc2009.consider.using.pgrep.instead.of.grepping.ps.output=SC2009 Considera usar pgrep en lugar de utilizar grep para el resultado de ps.
sc2094.make.sure.not.to.read.and.write.the.same.file.in.the.same.pipeline=SC2094 Asegúrate de no leer y escribir el mismo archivo en el mismo pipeline.
sc2106.this.only.exits.the.subshell.caused.by.the.pipeline=SC2106: Esto solo sale del subshell causado por el pipeline.
sh.code.style.binary.ops.like.and.may.start.a.line=Permitir saltos de línea después de operadores binarios
sh.code.style.choose.path=Seleccionar ruta a Shfmt:
sh.code.style.download.link=Descargar formateador shfmt
sh.code.style.keep.column.alignment.padding=Mantener el relleno de alineación de las columnas
sh.code.style.minify.program.to.reduce.its.size=Minificar programa para reducir su tamaño
sh.code.style.redirect.operators.will.be.followed.by.a.space=Añadir espacio después de los operadores de redirección
sh.code.style.switch.cases.will.be.indented=Las sentencias 'case' estarán sangradas
sh.code.style.unix.line.separator=Usar separadores de línea Unix (\n)
sh.color.backquotes=Backquotes
sh.color.braces.curly.brackets=Llaves//llaves rizadas
sh.color.braces.parentheses=Llaves//Paréntesis
sh.color.braces.square.brackets=Llaves//corchetes
sh.color.commands.generic.command=Comandos//comando genérico
sh.color.commands.subshell.command=Comandos//comando subshell
sh.color.conditional.operators=Operadores condicionales
sh.color.function.declaration=Declaración de función
sh.color.here.documents=Documentos here
sh.color.here.documents.end=Fin de here documents
sh.color.here.documents.start=Inicio de documentos heredados
sh.color.keyword=Palabra clave
sh.color.line.comment=Comentario de línea
sh.color.number=Número
sh.color.raw.string=Literal de cadena
sh.color.redirection=Redirección
sh.color.shebang.comment=Comentario de shebang
sh.color.string=Cadena
sh.color.variables.composed.variable=Variables//variable compuesta
sh.color.variables.variable.declaration=Variables//declaración variable
sh.color.variables.variable.usage=Variables//Uso de variables
sh.disable.inspection.text=Desactivar inspección {0}
sh.download=Descargar
sh.explain.command.to.explain=Comando a Explicar
sh.explain.inspection.text=Explorar Shell
sh.explain.message.nothing.to.explain=Sin contenido que explicar
sh.explain.title.nothing.to.explain=Nada para explicar
sh.fmt.cannot.download=No se puede descargar el formateador shfmt. Instálalo manualmente.
sh.fmt.cannot.update=No es posible actualizar el formateador shfmt. Se restauró la versión anterior.
sh.fmt.formatter=Formateador de Shfmt
sh.fmt.indent.label=Sangría
sh.fmt.install.question=¿Desea instalar un formateador de shell script?
sh.fmt.missing.formatter=falta formateador
sh.fmt.success.install=El formateador del script de shell se instaló correctamente
sh.fmt.success.update=Formateador del script shell actualizado correctamente
sh.fmt.update.question=¿Quieres actualizar el formateador de script de shell de "{0}" a "{1}"?
sh.install=Instalar
sh.invalid.path=Ruta no válida.
sh.label.choose.interpreter=Selecciona Interpretador
sh.label.choose.script.working.directory=Seleccionar directorio de trabajo del script
sh.label.choose.shell.script=Elegir script de shell
sh.label.download.shfmt.formatter=Descargar formateador shfmt
sh.livetemplate.description.array.add=Agrega un nuevo elemento al final del arreglo
sh.livetemplate.description.array.all=Todos los elementos del array
sh.livetemplate.description.array.at.index=Elementos en índice
sh.livetemplate.description.array.create=Crear arreglo
sh.livetemplate.description.array.delete=Eliminar array
sh.livetemplate.description.array.delete.at=Eliminar del array
sh.livetemplate.description.array.iteration=Iterar por el array
sh.livetemplate.description.array.length=Longitud de array
sh.livetemplate.description.array.set.element=Establecer elemento de matriz en el índice
sh.livetemplate.description.case=Sentencia case
sh.livetemplate.description.cmd=Sustitución de comandos
sh.livetemplate.description.cmd.success.check=Comprobación exitosa del comando
sh.livetemplate.description.command.exists=El comando existe
sh.livetemplate.description.curl=Solicitud HTTP
sh.livetemplate.description.directory.exists=El directorio existe
sh.livetemplate.description.elif=elif expresión
sh.livetemplate.description.file.equals=Archivo es igual
sh.livetemplate.description.file.executable=Archivo ejecutable
sh.livetemplate.description.file.exists=El archivo existe
sh.livetemplate.description.file.newer=Archivo más nuevo
sh.livetemplate.description.file.not.empty=El archivo no está vacío
sh.livetemplate.description.file.older=El archivo es más antiguo
sh.livetemplate.description.file.readable=Archivo legible
sh.livetemplate.description.file.writable=Archivo escribible
sh.livetemplate.description.find=Buscar archivo o directorio
sh.livetemplate.description.for=Bucle for por índice
sh.livetemplate.description.fori=Bucle `for` en una lista
sh.livetemplate.description.function=Definir una función
sh.livetemplate.description.git.branch.create=Crear rama
sh.livetemplate.description.git.commit=Confirmar cambios
sh.livetemplate.description.git.push=Empujar rama a remoto
sh.livetemplate.description.heredoc=Cadena multilínea
sh.livetemplate.description.if=Instrucción if
sh.livetemplate.description.mkdir=Crear directorio
sh.livetemplate.description.number.equal=Los números son iguales
sh.livetemplate.description.number.greater=Número mayor que
sh.livetemplate.description.number.greater.or.equal=Número mayor o igual
sh.livetemplate.description.number.less=Número menor que
sh.livetemplate.description.number.less.or.equal=Número menor o igual
sh.livetemplate.description.number.not.equal=Números diferentes
sh.livetemplate.description.path.exists=Ruta existe
sh.livetemplate.description.rm=Eliminar fichero o dir
sh.livetemplate.description.select=Seleccionar expresión
sh.livetemplate.description.string.equal=Cadenas son iguales
sh.livetemplate.description.string.is.empty=La cadena está vacía
sh.livetemplate.description.string.not.empty=Cadena no está vacía
sh.livetemplate.description.string.not.equal=La cadena no es igual
sh.livetemplate.description.system.info.linux=Información del sistema Linux
sh.livetemplate.description.system.info.mac=Información del sistema Mac OS
sh.livetemplate.description.system.kernel.info=Información del kernel
sh.livetemplate.description.tar.compress=compresión tar
sh.livetemplate.description.tar.decompress=descomprimir tar
sh.livetemplate.description.until=Hasta el bucle por condición
sh.livetemplate.description.while=Bucle while por condición
sh.livetemplate.description.xargs=Ejecutar comandos desde la entrada estándar
sh.markdown.runner.title=Ejecutar en Terminal
sh.no.thanks=No
sh.parser.expected.similar.close.bracket=Se esperaba un corchete de cierre similar
sh.path.label=Ruta:
sh.rename.all.occurrences=Renombrar todas las apariciones
sh.rename.occurence=Renombrar {0}
sh.run.configuration.description.0.configuration={0} configuración
sh.run.environment.variables=Variables de entorno:
sh.run.execute=Ejecutar:
sh.run.execute.script.file=Archivo de Script
sh.run.execute.script.text=Texto del script
sh.run.execute.script.text.title=Texto del script:
sh.run.execute.terminal=Ejecutar en la terminal
sh.run.interpreter=Intérprete
sh.run.interpreter.not.found=Intérprete no encontrado
sh.run.interpreter.options=Opciones del intérprete:
sh.run.interpreter.path=Ruta del intérprete:
sh.run.interpreter.should.be.executable=El intérprete debe ser un archivo ejecutable
sh.run.script.not.found=No se encontró el script del Shell
sh.run.script.options=Opciones del script:
sh.run.script.path=Ruta de script:
sh.run.working.dir=Directorio de trabajo:
sh.run.working.dir.not.found=Directorio de trabajo no encontrado
sh.shell.script=Script Shell
sh.shellcheck.cannot.download=No se puede descargar shellcheck. Instala manualmente.
sh.shellcheck.cannot.update=No se puede actualizar shellcheck. Vuelta atrás a la versión anterior.
sh.shellcheck.download.label.text=Descargar shellcheck
sh.shellcheck.install.question=¿Desea instalar shellcheck para verificar sus scripts shell?
sh.shellcheck.missing=Falta shellcheck
sh.shellcheck.path.label=Selecciona la ruta a Shellcheck:
sh.shellcheck.success.install=El Shellcheck se ha instalado correctamente
sh.shellcheck.success.update=Shellcheck se actualizó correctamente
sh.shellcheck.update.question=¿Deseas actualizar shellcheck de "{0}" a "{1}"?
sh.skip.version=Omitir esta versión
sh.suppress.inspection=Suprimir {0}
sh.unnamed.element.presentable.name=sin nombre
sh.update=Actualizar
shell.functions.can.t.be.passed.to.external.commands=No se pueden pasar funciones de shell a comandos externos.
sigkill.sigstop.can.not.be.trapped=SIGKILL y SIGSTOP no se pueden interceptar
since.you.double.quoted.this.it.will.not.word.split.and.the.loop.will.only.run.once=Dado que lo incluiste entre comillas dobles, no se dividirá en palabras y el bucle solo se ejecutará una vez.
some.finds.don.t.have.a.default.path.specify.explicitly=Algunos no tienen una ruta predeterminada. Especifica '.' explícitamente.
sudo.doesn.t.affect.redirects.use.sudo.tee.file=`sudo` no afecta las redirecciones. Use `..| sudo tee file`
tempfile.is.deprecated.use.mktemp.instead=tempfile está en desuso. Utiliza mktemp en su lugar.
the.arguments.to.this.comparison.can.never.be.equal.make.sure.your.syntax.is.correct=Los argumentos de esta comparación nunca pueden ser iguales. Asegúrese de que su sintaxis es correcta.
the.dot.command.does.not.support.arguments.in.sh.dash.set.them.as.variables=El comando punto no admite argumentos en sh/dash. Definirlas como variables.
the.exit.status.can.only.be.one.integer.0.255.use.stdout.for.other.data=El código de salida solo puede ser un entero entre 0 y 255. Usa stdout para otros datos.
the.here.is.literal.to.assign.by.index.use.index.value.with.no.spaces.to.keep.as.literal.quote.it=Aquí el igual '=' es literal. Para asignar por índice, usar ( [índice]=valor ) sin espacios. Para mantener como literal, usar comilla.
the.surrounding.quotes.actually.unquote.this.remove.or.escape.them=Las comillas circundantes liberan las comillas de este texto. Quítelas o escápelas.
this.action.ignores.everything.before.the.o.use.to.group=Esta acción ignora todo lo anterior a '-o'. Utilizar ( ) para agrupar.
this.array.element.has.no.value.remove.spaces.after.or.use.for.empty.string=Este elemento de la matriz no tiene valor. Quita los espacios después de '=' o usa "" para una cadena vacía.
this.assignment.is.only.seen.by.the.forked.process=Esta asignación sólo es visible para el proceso bifurcado.
this.case.is.not.specified.by.getopts=Este caso no está especificado en 'getopts'.
this.cp.has.no.destination.check.the.arguments=Este 'cp' no tiene destino. Revisa los argumentos.
this.default.assignment.may.cause.dos.due.to.globbing.quote.it=Esta asignación por defecto puede provocarDoS debido al globbing. Cítalo.
this.does.not.export.foo.remove.for.that.or.use.var.to.quiet=Esto no exporta 'FOO'. Remueve '$' y '${}' para eso, o usa '${var?}' para silenciar.
this.does.not.read.foo.remove.for.that.or.use.var.to.quiet=Esto no lee 'foo'. Remueva '$' y '${}' o use '${var?}' para ocultar.
this.expands.when.defined.not.when.used.consider.escaping=Esto se expande cuando se define, no cuando se usa. Considera escapar.
this.expansion.will.not.see.the.mentioned.assignment=Esta expansión no verá la asignación mencionada.
this.expression.is.constant.did.you.forget.a.somewhere=La expresión es constante. ¿Ha olvidado un `$` en algún lugar?
this.expression.is.constant.did.you.forget.the.on.a.variable=Esta expresión es constante. ¿Olvidó escribir `$` en una variable?
this.flag.is.used.as.a.command.name.bad.line.break.or.missing=Esta bandera se usa como nombre de comando. ¿Retorno de carro incorrecto o falta `[ .. ]`?
this.format.string.has.2.variables.but.is.passed.1.arguments=Esta cadena de formato tiene 2 variables, pero se le pasó 1 argumento
this.function.is.only.defined.later.move.the.definition.up=Esta función solo se define más adelante. Suba la definición.
this.is.a.file.redirection.was.it.supposed.to.be.a.comparison.or.fd.operation=Esta es una redirección de archivo. ¿Debió ser una comparación o una operación de descriptor de archivo?
this.is.a.glob.used.as.a.command.name.was.it.supposed.to.be.in.array.or.is.it.missing.quoting=Este es un glob usado como nombre de comando. ¿Se suponía que debía estar en '${..}' o en un array? De no ser así, usa comillas.
this.is.a.literal.string.to.run.as.a.command.use.instead.of=Esta es una cadena literal. Para ejecutar como un comando, usa '$(..)' en lugar de '..'.
this.is.interpreted.as.a.shell.file.redirection.not.a.comparison=Se interpreta como una redirección de un archivo de shell, no como una comparación.
this.ln.has.no.destination.check.the.arguments.or.specify.explicitly=Este 'ln' no tiene destino. Revisa los argumentos o especifica explícitamente '.'.
this.loop.will.only.ever.run.once.for.a.constant.value.did.you.perhaps.mean.to.loop.over.dir.var.or.cmd=Este bucle solo se ejecutará una vez para un valor constante. ¿Quizás pretendías ejecutar el bucle en 'dir/*', '$var' o '$(cmd)'?
this.mv.has.no.destination.check.the.arguments=Este 'mv' no tiene destino. Revisa los argumentos.
this.nested.loop.overrides.the.index.variable.of.its.parent=Este bucle anidado sobreescribe la variable de índice de su padre
this.parent.loop.has.its.index.variable.overridden=Este bucle padre tiene su variable de índice sobreescrita.
this.pattern.always.overrides.a.later.one=Este patrón siempre sobrescribe uno posterior.
this.pattern.never.matches.because.of.a.previous.pattern=Este patrón nunca coincide debido a un patrón previo.
this.pattern.will.never.match.the.case.statement.s.word.double.check.them=Este patrón nunca coincidirá con la palabra de la sentencia 'case'. Verifíquelos de nuevo.
this.printf.format.string.has.no.variables.other.arguments.are.ignored=La cadena de formato printf no contiene variables. Se ignoran otros argumentos.
this.redirection.doesn.t.have.a.command.move.to.its.command.or.use.true.as.no.op=Esta redirección no tiene comando. Moverse a su comando (o usar 'true' como no-op).
this.shebang.specifies.a.directory.ensure.the.interpreter.is.a.file=Este shebang especifica un directorio. Asegúrese de que el intérprete es un archivo.
this.terminates.the.command.escape.it.or.add.space.after.to.silence=Este '' termina el comando. Escápalo o agrega un espacio después de '' para silenciarlo.
this.will.expand.once.before.find.runs.not.per.file.found=Esto se expandirá una vez antes de que se ejecute la búsqueda, no por cada archivo encontrado.
this.word.is.constant.did.you.forget.the.on.a.variable=Esta palabra es una constante. ¿Olvidó el carácter '$' de una variable?
this.word.is.outside.of.quotes.did.you.intend.to.nest.single.quotes.instead=Esta palabra está fuera de las comillas. ¿Pretende 'anidar '"'comillas simples'"' en su lugar?
tilde.does.not.expand.in.quotes.use.home=El símbolo ~ dentro de comillas no se expande. Usa $HOME.
time.is.undefined.for.compound.commands.time.sh.c.instead='time' no está definido para comandos compuestos. Usa 'time sh -c' en su lugar.
time.is.undefined.for.pipelines.time.single.stage.or.bash.c.instead="time" está indefinido para pipelines. Usa `time` en una sola etapa o `time bash -c` en su lugar.
tips.depend.on.target.shell.and.yours.is.unknown.add.a.shebang=Los consejos dependen del shell de destino. Agrega un sha-bang.
to.assign.a.variable.use.just.var.value.no.set=Para asignar una variable, usa 'var=valor', no 'set ..'.
to.assign.the.output.of.a.command.use.var.cmd=Para asignar la salida de un comando, usar 'var=$(cmd)'.
to.expand.via.indirection.use.name.foo.n.echo.name=Para expandir mediante indirección, utilice name="foo$n"; echo "${!name}".
to.read.lines.rather.than.words.pipe.redirect.to.a.while.read.loop=Para leer líneas en vez de palabras, canaliza o redirige la salida hacia un bucle 'while read'.
to.redirect.stdout.stderr.2.1.must.be.last.or.use.cmd.file.2.1.to.clarify=Para redireccionar stdout+stderr, '2>1' debe ser el último (o use '{ cmd > archivo; } 2>1' para clarificar).
to.run.commands.as.another.user.use.su.c.or.sudo=Para ejecutar comandos como otro usuario, usa 'su -c' o 'sudo'.
tr.replaces.sets.of.chars.not.words.mentioned.due.to.duplicates='tr' reemplaza conjuntos de caracteres, no palabras (mencionado debido a duplicados).
trapping.signals.by.number.is.not.well.defined.prefer.signal.names=No está bien definido atrapar señales por número. Prefiere nombres de señales.
unexpected.start.of.line.if.breaking.lines.should.be.at.the.end.of.the.previous.one=Inicio inesperado de una nueva línea. Si hay saltos de línea, |/||/ debe estar al final de la anterior.
unknown.binary.operator=Operador binario desconocido
unknown.unaryoperator=Operador unario desconocido.
use.a.subshell.to.avoid.having.to.cd.back=Usa una ( subshell ) para evitar tener que cd back.
use.array.item.to.append.items.to.an.array=Usa 'array+=("elemento")' para anexar elementos a un array.
use.cd.exit.in.case.cd.fails=Utilizar cd ... || exit en caso de que la implementación continua falle.
use.false.instead.of.empty.conditionals=Usa 'false' en lugar de empty '[' y '[[' conditionals.
use.find.instead.of.ls.to.better.handle.non.alphanumeric.filenames=Utiliza `find` en lugar de `ls` para gestionar mejor los nombres de archivo no alfanuméricos.
use.foo.if.function.s.1.should.mean.script.s.1=Utiliza 'foo "$@"' si el argumento '$1' de la función debe indicar el argumento '$1' de la secuencia de comandos.
use.for.arithmetics.e.g.i.i.2=Para operaciones aritméticas, utiliza `$((..))`, por ejemplo: i=$((i + 2))
use.glob.or.glob.so.names.with.dashes.won.t.become.options=Usa './*glob*' o '-- *glob*' de manera que los nombres con guiones no se conviertan en opciones.
use.grep.q.instead.of.comparing.output.with.n=Utiliza 'grep -q' en lugar de comparar la salida con '[ -n .. ]'.
use.instead.of.deprecated=Usa '$((..))' en lugar del '$[..]' que está deprecado.
use.instead.of.to.avoid.subshell.overhead=Usa `{ ..; }` en lugar de `(..)` para evitar la sobrecarga del subshell.
use.lower.to.support.accents.and.foreign.alphabets=Utiliza '[:lower:]' para soportar acentos y alfabetos extranjeros
use.n.instead.of.z=Utiliza `[ -n .. ]` en lugar de `! [ -z .. ]`.
use.n.instead.of.z2=Usar `-n` en lugar de `! -z`.
use.notation.instead.of.legacy.backticked=Use la notación '$(...)' en lugar de la legacy backticked '' `...` ''.
use.or.quote.arguments.to.v.to.avoid.glob.expansion=Usa `[[ ]]` o cita argumentos de la opción '-v' para evitar la expansión glob.
use.own.script.or.sh.c.to.run.this.from.su=Usa tu propio script o sh -c '..' para ejecutar esto desde su.
use.print0.0.or.find.exec.to.allow.for.non.alphanumeric.filenames=Utiliza '-print0', '-0' o 'find -exec +' para permitir nombres de archivo no alfanuméricos
use.single.quotes.otherwise.this.expands.now.rather.than.when.signalled=Usa solo comillas simples para expandir sólo cuando se señale, no ahora mismo.
use.spaces.not.commas.to.separate.array.elements=Usa espacios, no comas, para separar elementos de array
use.upper.to.support.accents.and.foreign.alphabets=Utilizar '[:upper:]' para soportar acentos y alfabetos extranjeros.
use.var.command.to.assign.output.or.quote.to.assign.string=Utilice "var=$(comando)" para asignar la salida (o comillas para asignar una cadena).
use.var.to.ensure.this.never.expands.to=Use "${var:?}" para asegurar que nunca se expande a /*.
use.with.quotes.to.prevent.whitespace.problems=Utiliza "$@" (entre comillas dobles) para prevenir problemas con los espacios en blanco.
useless.cat.consider.cmd.file.or.cmd.file.instead=Uso redundante de 'cat'. Considere 'cmd < file | ..' o 'cmd file | ..' en su lugar.
useless.echo.instead.of.cmd.echo.foo.just.use.cmd.foo=¿echo redundante? En lugar de 'cmd $(echo foo)', use 'cmd foo'.
useless.echo.instead.of.echo.cmd.just.use.cmd=¿`echo` redundante? En vez de `echo $(cmd)`, utiliza `cmd`.
var.is.referenced.but.not.assigned=var está referenciada pero no asignada
var.was.modified.in.a.subshell.that.change.might.be.lost='var' fue modificada en un subshell. Ese cambio podría perderse
variable.was.used.as.an.array.but.is.now.assigned.a.string=Variable fue usada como arreglo pero ahora se le asigno una cadena.
warning.deletes.a.system.directory=Advertencia: borra un directorio del sistema.
when.used.with.p.m.only.applies.to.the.deepest.directory=Cuando se usa con "-p", "-m" solo aplica al directorio más profundo
which.is.non.standard.use.builtin.command.v.instead=El comando "which" no es estándar. Utilice el comando integrado "command -v" en su lugar.
word.is.on.the.form.a.b.c.b.indicated.did.you.mean.abc.or.a.b.c=La palabra tiene la forma "A"B"C" (B indicado). ¿Quiere decir "ABC" o "A"B"C"?
you.can.t.have.between.this.redirection.and.the.command.it.should.apply.to=No puede haber '|' entre esta redirección y el comando al que se aplica.
you.need.spaces.around.the.comparison.operator=Necesitas espacios alrededor del operador de comparación.
you.probably.wanted.here=Usa ''.