0.is.true.use.false.instead='[ 0 ]' es verdadero. Use 'false' en su lugar.
action.ShGenerateForLoop.description=Crea bucle for
action.ShGenerateForLoop.text=For Loop
action.ShGenerateUntilLoop.description=Crea bucle until
action.ShGenerateUntilLoop.text=Until Loop
action.ShGenerateWhileLoop.description=Crea bucle while
action.ShGenerateWhileLoop.text=While Loop
action.runShellFileAction.description=Ejecutar archivo shell actual en la terminal
action.runShellFileAction.text=Ejecutar archivo
add.dev.null.to.prevent.ssh.from.swallowing.stdin=Agregue '< /dev/null' para evitar que ssh consuma stdin.
aliases.can.t.use.positional.parameters.use.a.function=Los alias no pueden usar parámetros posicionales. Use una función.
argument.mixes.string.and.array.use.or.separate.argument=El argumento mezcla cadena y array. Use '*' o argumento separado.
argument.to.implicit.n.is.always.true.due.to.literal.strings=El argumento para '-n' implícito siempre es verdadero debido a cadenas literales.
arrays.don.t.work.as.operands.in.use.a.loop.or.concatenate.with.instead.of=Los arrays no funcionan como operandos en '[ ]'. Use un bucle (o concatene con '*' en lugar de '@').
arrays.implicitly.concatenate.in.use.a.loop.or.explicit.instead.of=Los arrays se concatenan implícitamente en `[[ ]]`. Use un bucle (o '*' explícito en lugar de '@').
ash.scripts.will.be.checked.as.dash.add.shellcheck.shell.dash.to.silence=Los scripts Ash serán verificados como Dash. Agregue '\# shellcheck shell\=dash' para silenciar.
assigning.an.array.to.a.string.assign.as.array.or.use.instead.of.to.concatenate=¡Asignando un array a una cadena\! Asigne como array, o use '*' en lugar de '@' para concatenar.
bash.does.not.support.multidimensional.arrays.use.1d.or.associative.arrays=Bash no soporta arrays multidimensionales. Use solo arrays unidimensionales o asociativos.
bash.doesn.t.support.variables.in.brace.range.expansions=Bash no soporta variables en expansiones de rango con llaves.
bin.sh.was.specified.so.is.not.supported.even.when.sh.is.actually.bash=Se especificó '\#\!/bin/sh', por lo que ____ no está soportado, incluso cuando sh es realmente bash.
brace.expansion.doesn.t.happen.in.use.a.loop=La expansión de llaves no ocurre en `[[ ]]`. Use un bucle.
brace.expansions.and.globs.are.literal.in.assignments.quote.it.or.use.an.array=Las expansiones de llaves y globs son literales en asignaciones. Use comillas o un array.
brace.expansions.don.t.work.as.operands.in.use.a.loop=Las expansiones de llaves no funcionan como operandos en '[ ]'. Use un bucle.
break.is.only.valid.in.loops=`break` solo es válido en bucles.
can.only.exit.with.status.0.255.other.data.should.be.written.to.stdout.stderr=Solo puede salir con estado 0-255. Otros datos deben escribirse a stdout/stderr.
can.only.return.0.255.other.data.should.be.written.to.stdout=Solo puede retornar 0-255. Otros datos deben escribirse a stdout.
can.t.match.globs.use.or.grep=`[ .. ]` no puede coincidir con globs. Use `[[ .. ]]` o grep.
can.t.use.in.use.instead=No se puede usar `\=~` en `[ ]`. Use `[[..]]` en su lugar.
can.t.use.sudo.with.builtins.like.cd.did.you.want.sudo.sh.c.instead=No se puede usar 'sudo' con comandos integrados como 'cd'. Use 'sudo sh -c' en su lugar.
check.1008.this.shebang.was.unrecognized.shellcheck.only.supports.sh.bash.dash.ksh.add.a.shell.directive.to.specify=Este shebang no fue reconocido. ShellCheck solo soporta sh/bash/dash/ksh. Agregue una directiva 'shell' para especificar.
check.1009.the.mentioned.parser.error.was.in=El error del parser mencionado estaba en…
check.1010.use.semicolon.or.linefeed.before.done.or.quote.to.make.it.literal=Use punto y coma o salto de línea antes de 'done' (o use comillas para hacerlo literal).
check.1011.this.apostrophe.terminated.the.single.quoted.string=¡Este apóstrofe terminó la cadena con comillas simples\!
check.1012.is.just.literal.t.here.for.tab.use.printf.instead=`\t` es solo literal `t` aquí. Para agregar una tabulación, use "$(printf '\t')" en su lugar.
check.1014.use.if.cmd.then.to.check.exit.code.or.if.cmd.to.check.output=Use 'if cmd; then ...' para verificar el código de salida, o 'if [ "$(cmd)" \= .. ]' para verificar la salida.
check.1015.this.is.a.unicode.double.quote.delete.and.retype.it=Esta es una comilla doble Unicode. Elimínela y vuelva a escribirla.
check.1016.this.is.a.unicode.single.quote.delete.and.retype.it=Esta es una comilla simple Unicode. Elimínela y vuelva a escribirla.
check.1017.literal.carriage.return.run.script.through.tr.d=Retorno de carro literal. Ejecute el script a través de `tr -d '\n'`.
check.1018.this.is.a.unicode.non.breaking.space.delete.it.and.retype.as.space=Este es un espacio indivisible Unicode. Elimínelo y vuelva a escribirlo con la tecla de espacio.
check.1019.expected.this.to.be.an.argument.to.the.unary.condition=Se esperaba que esto fuera un argumento para la condición unaria.
check.1020.you.need.a.space.before.the.if.single.then.else=Agregue un espacio antes de `]` o `]]`
check.1026.if.grouping.expressions.inside.use=Si agrupa expresiones dentro de [[..]], use ( .. ).
check.1028.in.you.have.to.escape.or.preferably.combine.expressions=En [..] debe escapar \\( \\) o preferiblemente combinar expresiones [..].
check.1029.in.you.shouldn.t.escape.or=En `[[..]]` no debe escapar `(` o `)`.
check.1035.you.need.a.space.here=Agregue un espacio aquí.
check.1036.is.invalid.here.did.you.forget.to.escape.it=`(` no es válido aquí. ¿Olvidó escaparlo?
check.1037.braces.are.required.for.positionals.over.9.e.g.10=Se requieren llaves para posicionales mayores a 9, ej. 10.
check.1038.shells.are.space.sensitive.use.cmd.not.cmd=Los shells son sensibles a espacios. Use '< <(cmd)', no '<<(cmd)'.
check.1039.remove.indentation.before.end.token.or.use.and.indent.with.tabs=Elimine la indentación antes del token final (o use `<<-` e indente con tabulaciones).
check.1040.when.using.you.can.only.indent.with.tabs=Al usar <<-, indente con tabulaciones.
check.1041.found.eof.further.down.but.not.on.a.separate.line=Se encontró 'eof' más abajo, pero no en una línea separada.
check.1042.found.eof.further.down.but.not.on.a.separate.line=Se encontró 'eof' más abajo, pero no en una línea separada.
check.1044.couldn.t.find.end.token.eof.in.the.here.document=No se pudo encontrar el token final `EOF' en el documento here.
check.1045.expected.then=Se esperaba 'then'.
check.1045.it.s.not.foo.bar.just.foo.bar=Punto y coma redundante en 'foo \\&; bar'. Debería ser 'foo \\& bar'.
check.1046.couldn.t.find.fi.for.this.if=No se pudo encontrar 'fi' para este 'if'.
check.1047.expected.fi.matching.previously.mentioned.if=Se esperaba 'fi' correspondiente al 'if' mencionado anteriormente.
check.1048.can.t.have.empty.then.clauses.use.true.as.a.no.op=No puede haber cláusulas then vacías (use 'true' como no-op).
check.1049.did.you.forget.the.then.for.this.if=¿Olvidó especificar 'then' para este 'if'?
check.1051.semicolons.directly.after.then.are.not.allowed.just.remove.it=No se permiten punto y coma directamente después de 'then'.
check.1052.semicolons.directly.after.then.are.not.allowed.just.remove.it=No se permiten punto y coma directamente después de 'then'.
check.1053.semicolons.directly.after.else.are.not.allowed.just.remove.it=No se permiten punto y coma directamente después de 'else'.
check.1054.you.need.a.space.after.the=Agregue un espacio después de '{'.
check.1058.expected.do=Se esperaba `do`.
check.1061.couldn.t.find.done.for.this.do=No se pudo encontrar 'done' para este 'do'.
check.1062.expected.done.matching.previously.mentioned.do=Se esperaba 'done' correspondiente al 'do' mencionado anteriormente.
check.1064.expected.a.to.open.the.function.definition=Se esperaba '{' para abrir la definición de función.
check.1065.trying.to.declare.parameters.don.t.use.and.refer.to.params.as.1.2=No declare parámetros. Use () y refiérase a los parámetros como $1, $2, etc.
check.1066.don.t.use.on.the.left.side.of.assignments=No use '$' en el lado izquierdo de las asignaciones.
check.1068.don.t.put.spaces.around.the.in.assignments=No ponga espacios alrededor de '\=' en asignaciones.
check.1069.you.need.a.space.before.the=Agregue un espacio antes de '['.
check.1071.shellcheck.only.supports.sh.bash.dash.ksh.scripts.sorry=ShellCheck solo soporta scripts sh/bash/dash/ksh.
check.1072.unexpected=Inesperado ..
check.1073.couldn.t.parse.this.thing.fix.to.allow.more.checks=No se pudo analizar esto. Corríjalo para permitir más verificaciones.
check.1075.use.elif.instead.of.else.if=Use 'elif' en lugar de 'else if'.
check.1077.for.command.expansion.the.tick.should.slant.left.vs=Para expansión de comandos, use backtick\: (` vs ´).
check.1078.did.you.forget.to.close.this.double.quoted.string=¿Olvidó cerrar esta cadena con comillas dobles?
check.1079.this.is.actually.an.end.quote.but.due.to.next.char.it.looks.suspect=Esta es una comilla de cierre, pero debido al siguiente carácter, parece sospechoso.
check.1081.scripts.are.case.sensitive.use.if.not.if=Los scripts distinguen mayúsculas y minúsculas. Use 'if', no 'If'.
check.1082.this.file.has.a.utf.8.bom.remove.it.with.lc.ctype.c.sed.1s.yourscript=Este archivo tiene un BOM UTF-8. Elimínelo con el siguiente comando\: LC_CTYPE\=C sed '1s/^...//' < yourscript
check.1083.this.is.literal.check.expression.missing.or.quote.it=Este `{`/`}` es literal. Verifique si falta `;` o entrecomille la expresión.
check.1084.use.not.for.the.shebang=El shebang es '\#\!', no '\!\#'.
check.1086.don.t.use.on.the.iterator.name.in.for.loops=No use '$' en el nombre del iterador en bucles for.
check.1087.use.braces.when.expanding.arrays.e.g.array.idx.or.var.to.quiet=Use llaves al expandir arrays, por ejemplo\: ${array[idx]} (o ${var}[.. para silenciar).
check.1088.parsing.stopped.here.invalid.use.of.parentheses=El análisis se detuvo aquí. ¿Uso inválido de paréntesis?
check.1089.parsing.stopped.here.is.this.keyword.correctly.matched.up=El análisis se detuvo aquí. ¿Está esta palabra clave correctamente emparejada?
check.1090.can.t.follow.non.constant.source.use.a.directive.to.specify.location=No se puede seguir fuente no constante. Use una directiva para especificar la ubicación.
check.1091.not.following.error.message.here=No siguiendo\: (mensaje de error aquí)
check.1094.parsing.of.sourced.file.failed.ignoring.it=Falló el análisis del archivo fuente. Ignorándolo.
check.1095.you.need.a.space.or.linefeed.between.the.function.name.and.body=Necesita un espacio o salto de línea entre el nombre de la función y el cuerpo.
check.1097.unexpected.for.assignment.use.for.comparison.use=Inesperado '\=\='. Para asignación, use '\='. Para comparación, ponga la expresión '\=\=' en corchetes.
check.1098.quote.escape.special.characters.when.using.eval.e.g.eval.a.b=Entrecomille o escape caracteres especiales al usar eval, por ejemplo\: eval "a\=(b)".
check.1099.you.need.a.space.before.the=Agregue un espacio antes de '\#'.
check.1100.this.is.a.unicode.dash.delete.and.retype.as.ascii.minus=Este es un guion Unicode. Elimínelo y vuelva a escribirlo como carácter ASCII menos.
check.1101.delete.trailing.spaces.after.to.break.line.or.use.quotes.for.literal.space=Elimine espacios finales después de \\ para romper la línea (o use comillas para espacio literal).
check.1102.shells.disambiguate.differently.or.not.at.all.if.the.first.should.start.command.substitution.add.a.space.after.it=Los shells desambiguan $(( de manera diferente o no lo hacen. Si el primer $( debe iniciar sustitución de comando, agregue un espacio después.
check.1104.use.not.just.for.the.shebang=El shebang es '\#\!', no '\!'.
check.1105.shells.disambiguate.differently.or.not.at.all.if.the.first.should.start.a.subshell.add.a.space.after.it=Los shells desambiguan (( de manera diferente o no lo hacen. Si el primer ( debe iniciar un subshell, agregue un espacio después.
check.1107.this.directive.is.unknown.it.will.be.ignored=Esta directiva es desconocida. Será ignorada.
check.1108.you.need.a.space.before.and.after.the=Agregue un espacio antes y después de '\='.
check.1109.this.is.an.unquoted.html.entity.replace.with.corresponding.character=Esta es una entidad HTML sin comillas. Reemplázala con el carácter correspondiente.
check.1110.this.is.a.unicode.quote.delete.and.retype.it.or.quote.to.make.literal=Esta es una comilla Unicode. Bórrala y reescríbela (o usa comillas para hacerla literal).
check.1111.this.is.a.unicode.quote.delete.and.retype.it.or.ignore.singlequote.for.literal=Esta es una comilla Unicode. Bórrala y reescríbela (o usa comillas simples para hacerla literal).
check.1112.this.is.a.unicode.quote.delete.and.retype.it.or.ignore.doublequote.for.literal=Esta es una comilla Unicode. Bórrala y reescríbela (o usa comillas dobles para hacerla literal).
check.1113.use.not.just.for.the.sheban=El shebang es '\#\!', no '\#'.
check.1114.remove.leading.spaces.before.the.shebang=Elimina los espacios iniciales antes del shebang.
check.1115.remove.spaces.between.and.in.the.shebang=Elimina los espacios entre '\#' y '\!' en el shebang.
check.1116.missing.on.a.expression.or.use.for.arrays=¿Falta '$' en una expresión '$((..))'? Si es un array, usa '( ('.
check.1117.backslash.is.literal.in.prefer.explicit.escaping.n=La barra invertida es literal en "\n". Preferible escape explícito\: "\\n".
check.1118.delete.whitespace.after.the.here.doc.end.token=Elimina el espacio en blanco después del token de fin del here document.
check.1119.add.a.linefeed.between.end.token.and.terminating=Añade un salto de línea entre el token de fin y el ')' de terminación.
check.1120.no.comments.allowed.after.here.doc.token.comment.the.next.line.instead=No se permiten comentarios después del token here document. Comenta la siguiente línea en su lugar.
check.1121.add.terminators.and.other.syntax.on.the.line.with.the.not.here=Añade terminadores ;/\\& (y otra sintaxis) en la línea con '<<', no aquí.
check.1122.nothing.allowed.after.end.token.to.continue.a.command.put.it.on.the.line.with.the=Nada permitido después del token de fin. Para continuar un comando, ponlo en la línea con `<<`.
check.1123.shellcheck.directives.are.only.valid.in.front.of.complete.compound.commands.like.if.not.e.g.individual.elif.branches=Las directivas ShellCheck solo son válidas delante de comandos compuestos completos, como `if`, no ramas `elif` individuales.
check.1124.shellcheck.directives.are.only.valid.in.front.of.complete.commands.like.case.statements.not.individual.case.branches=Las directivas ShellCheck solo son válidas delante de comandos completos como sentencias 'case', no ramas case individuales.
check.1126.place.shellcheck.directives.before.commands.not.after=Coloca las directivas ShellCheck antes de los comandos, no después.
check.1127.was.this.intended.as.a.comment.use.in.sh=Si esto es un comentario, usa `\#`.
check.1128.the.shebang.must.be.on.the.first.line.delete.blanks.and.move.comments=El shebang debe estar en la primera línea. Elimina espacios en blanco y mueve comentarios.
check.1129.you.need.a.space.before.the=Añade un espacio antes de '\!'.
check.1130.you.need.a.space.before.the=Añade un espacio antes de '\:'.
check.1131.use.elif.to.start.another.branch=Usa `elif` para comenzar otra rama.
check.exit.code.directly.with.e.g.if.mycmd.not.indirectly.with=Verifica el código de salida directamente con 'if mycmd;', no indirectamente con '$'?.
check1000.is.not.used.specially.and.should.therefore.be.escaped=$ debe ser escapado.
check1001.this.o.will.be.a.regular.o.in.this.context=Este \\o será una 'o' regular en este contexto.
check1003.want.to.escape.a.single.quote.echo.this.is.how.it.s.done=¿Quieres escapar una comilla simple? Haz echo 'This is how it'\\''s done'.
check1004.this.backslash.linefeed.is.literal.break.outside.single.quotes.if.you.just.want.to.break.the.line=Esta barra invertida+salto de línea es literal. Si quieres romper la línea, hazlo fuera de las comillas simples.
check1007.remove.space.after.if.trying.to.assign.a.value.or.for.empty.string.use.var=Elimina el espacio después de '\=' para asignar un valor (o para cadena vacía, usa var\='' ... ).
consider.adding.a.default.case.even.if.it.just.exits.with.error=Considera añadir un case '*)' por defecto, incluso si solo sale con error.
consider.using.cmd1.cmd2.file.instead.of.individual.redirects=Considera usar '{ cmd1; cmd2; } >> file' en lugar de redirecciones individuales.
consider.using.grep.c.instead.of.grep.wc=Considera usar 'grep -c' en lugar de 'grep|wc'.
d.only.applies.to.the.first.expansion.of.this.glob.use.a.loop.to.check.any.all='-d' solo se aplica a la primera expansión de este glob. Usa un bucle para verificar cualquiera/todos.
decimals.are.not.supported.either.use.integers.only.or.use.bc.or.awk.to.compare=Los decimales no están soportados. Usa solo enteros, o usa 'bc' o 'awk' para comparar.
declare.and.assign.separately.to.avoid.masking.return.values=Declara y asigna por separado para evitar enmascarar valores de retorno.
did.you.mean.ifs=¿Querías decir IFS\=$'\t' ?
display.name.shell.check=ShellCheck
doesn.t.support.decimals.use.bc.or.awk='(( ))' no soporta decimales. Usa 'bc' o 'awk'.
don.t.quote.rhs.of.it.ll.match.literally.rather.than.as.a.regex=No pongas comillas en el lado derecho de \=~, coincidirá literalmente en lugar de como regex.
don.t.use.around.ranges.in.tr.it.replaces.literal.square.brackets=No uses '[]' alrededor de rangos en 'tr', reemplaza corchetes literales.
don.t.use.ls.grep.use.a.glob.or.a.for.loop.with.a.condition.to.allow.non.alphanumeric.filenames=No uses 'ls | grep'. Usa un glob o un bucle for con una condición para permitir nombres de archivo no alfanuméricos.
don.t.use.variables.in.the.printf.format.string.use.printf.s.foo=No uses variables en la cadena de formato printf. En su lugar, usa esta sintaxis\: printf "..%s.." "$foo".
double.quote.array.expansions.to.avoid.re.splitting.elements=Usa comillas dobles en expansiones de arrays para evitar re-división de elementos.
double.quote.to.prevent.globbing.and.word.splitting=Usa comillas dobles para prevenir globbing y división de palabras.
e.doesn.t.work.with.globs.use.a.for.loop='-e' no funciona con globs. Usa un bucle for.
echo.doesn.t.read.from.stdin.are.you.sure.you.should.be.piping.to.it='echo' no lee de stdin. No se recomienda redirigir mediante pipe hacia él.
echo.won.t.expand.escape.sequences.consider.printf='echo' no expandirá secuencias de escape. Considera usar 'printf'.
egrep.is.non.standard.and.deprecated.use.grep.e.instead=egrep no es estándar y está obsoleto. Usa grep -E en su lugar.
elements.in.associative.arrays.need.index.e.g.array.index.value=Los elementos en arrays asociativos requieren un índice, por ejemplo\: array\=( [index]\=value ).
ensure.the.shebang.uses.the.absolute.path.to.the.interpreter=Asegúrate de que el shebang especifica la ruta absoluta al intérprete.
eq.is.for.integer.comparisons.use.instead='-eq' es para comparaciones de enteros. Usa '\=' en su lugar.
error.message.can.t.find.info.in.your.path=No se puede encontrar la información en tu variable $PATH.
error.message.cannot.determine.shell.script.parent.directory=No se puede determinar el directorio padre del script shell
exec.does.not.automatically.invoke.a.shell.use.exec.sh.c.for.that='-exec' no invoca automáticamente un shell. Usa '-exec sh -c' para eso.
expanding.an.array.without.an.index.only.gives.the.first.element=Expandir un array sin índice solo devuelve el primer elemento.
expr.is.antiquated.consider.rewriting.this.using.or='expr' está obsoleto. Considera reescribir esto usando '$((..))', '${}' o '\\[\\[ \\]\\]'.
expressions.don.t.expand.in.single.quotes.use.double.quotes.for.that=Las expresiones no se expanden en comillas simples, usa comillas dobles para eso.
false.is.true.remove.the.brackets='[ false ]' es true. Elimina los corchetes.
fgrep.is.non.standard.and.deprecated.use.grep.f.instead=fgrep no es estándar y está obsoleto. Usa grep -F en su lugar.
filetype.sh.shell.script.description=Script Shell
find.usages.type.function=función
flip.leading.and.if.this.should.be.a.quoted.substitution=Invierte el '$' y '"' inicial si esto debe ser una sustitución entrecomillada.
foo.appears.unused.verify.it.or.export.it='foo' parece sin usar. Verifícalo o expórtalo.
foo.references.arguments.but.none.are.ever.passed='foo' referencia argumentos, pero ninguno es pasado.
for.loops.over.find.output.are.fragile.use.find.exec.or.a.while.read.loop=Los bucles for sobre la salida de find son frágiles. Usa 'find -exec' o un bucle while read.
function.keyword.is.non.standard.delete.it=La palabra clave 'function' no es estándar. Elimínala.
getopts.specified.n.but.it.s.not.handled.by.this.case='getopts' especificó '-n', pero no es manejado por este 'case'.
globs.are.ignored.in.except.right.of.use.a.loop=Los globs se ignoran en `[[ ]]` excepto a la derecha de '\=' y '\!\='. Usa un bucle.
globs.don.t.work.as.operands.in.use.a.loop=Los globs no funcionan como operandos en '[ ]'. Usa un bucle.
grep.uses.regex.but.this.looks.like.a.glob=Grep usa regex, pero esto parece un glob.
i.do.mind.path.placeholder=Me importa
if.you.wanted.to.assign.the.output.of.the.pipeline.use.a.b.c=Si querías asignar la salida del pipeline, usa 'a\=$(b | c)'.
in.dash.something.is.not.supported=Esta característica no está soportada en dash.
in.functions.use.return.instead.of.break=En funciones, usa 'return' en lugar de 'break'.
in.posix.sh.something.is.undefined=En POSIX sh, algo está indefinido.
in.use.instead.of.a=En '[\\[..]]', usa '\\&\\&' en lugar de '-a'.
in.use.instead.of.o=En '[\\[..]]', usa '||' en lugar de '-o'.
increase.precision.by.replacing.a.b.c.with.a.c.b=Aumenta la precisión reemplazando 'a/b\\*c' con 'a\\*c/b'.
injecting.filenames.is.fragile.and.insecure.use.parameters=Inyectar nombres de archivo es frágil e inseguro. Usa parámetros.
instead.of.1.use.true=En lugar de '[ 1 ]', usa 'true'.
instead.of.a.b.use.a.b=En lugar de '[ a || b ]', usa '[ a ] || [ b ]'.
instead.of.a.b.use.a.b2=En lugar de '[ a \\&\\& b ]', usa '[ a ] \\&\\& [ b ]'.
instead.of.let.expr.prefer.expr=En lugar de `let expr`, prefiere `(( expr ))`.
instead.of.true.just.use.true=En lugar de '[ true ]', usa 'true'.
intention.shell.script=Script Shell
invalid.flags.are.not.handled.add.a.case=No se manejan flags inválidos. Añade un case `*)`.
is.a.subshell.did.you.mean.a.test.expression='(..)' es un subshell. ¿Querías decir '[ .. ]', una expresión de test?
is.for.regex.but.this.looks.like.a.glob.use.instead='\=~' es para regex, pero esto parece un glob. Usa '\=' en su lugar.
is.for.string.comparisons.use.gt.instead='>' es para comparaciones de cadenas. Usa '-gt' en su lugar.
is.not.a.valid.operator.use.a.b.instead='>\=' no es un operador válido. Usa '\! a < b' en su lugar.
is.unnecessary.on.arithmetic.variables='$' y '${}' son innecesarios en variables aritméticas.
iterating.over.ls.output.is.fragile.use.globs=Iterar sobre la salida de ls es frágil. Usa globs.
line.marker.run.0=Ejecutar {0}
literal.tilde.in.path.works.poorly.across.programs=La tilde literal en PATH funciona mal entre programas.
local.is.only.valid.in.functions='local' solo es válido en funciones.
make.sure.all.escape.sequences.are.enclosed.in.to.prevent.line.wrapping.issues=Asegúrate de que todas las secuencias de escape estén encerradas en `\\[..\\]` para prevenir problemas de ajuste de línea
missing.or.terminating.exec.you.can.t.use.and.has.to.be.a.separate.quoted.argument=Falta ';' o '+' terminando '-exec'. No uses |/||/\\&\\&, y usa comillas para ';'.
modification.of.var.is.local.to.subshell.caused.by.pipeline=La modificación de 'var' es local (al subshell causado por el pipeline).
n.doesn.t.work.with.unquoted.arguments.quote.or.use=`-n` no funciona con argumentos sin comillas. Usa comillas o ``[[ ]]``.
named.class.needs.outer.e.g.digit=La clase nombrada necesita '[]' exterior, por ejemplo\: [[\:digit\:]\\]
note.that.a.b.c.is.not.if.then.else.c.may.run.when.a.is.true=Nota que 'A \\&\\& B || C' no es 'if-then-else'. C puede ejecutarse cuando A es true.
note.that.unescaped.this.expands.on.the.client.side=Si no está escapado, esto se expande en el lado del cliente.
note.that.unlike.globs.o.here.matches.ooo.but.not.oscar=Note que a diferencia de globs, 'o*' aquí coincide con 'ooo' pero no con 'oscar'
notification.group.shell.script=Herramientas de script shell disponibles
numbers.with.leading.0.are.considered.octal=Los números con 0 inicial son considerados octales.
numerical.eq.does.not.dereference.in.expand.or.use.string.operator=El numérico '-'eq no desreferencia en [..]. Expanda o use operador de cadena.
on.most.os.shebangs.can.only.specify.a.single.parameter=En la mayoría de los SO, shebangs solo pueden especificar un único parámetro.
only.one.integer.0.255.can.be.returned.use.stdout.for.other.data=Solo se puede devolver un entero 0-255. Use stdout para otros datos.
path.is.the.shell.search.path.use.another.name=PATH es la ruta de búsqueda del shell. Use otro nombre.
piping.to.rm.a.command.that.doesn.t.read.stdin.wrong.command.or.missing.xargs=Enviando por pipe a 'rm', un comando que no lee stdin. ¿Comando incorrecto o falta xargs?
possible.misspelling.myvariable.may.not.be.assigned.but.my.variable.is=Posible error ortográfico\: MYVARIABLE puede no estar asignada, pero MY_VARIABLE sí lo está.
prefer.explicit.n.to.check.for.output.or.run.command.without.to.check.for.success=Prefiera '-n' explícito para verificar salida. Ejecute el comando sin '[' y '[[' para verificar éxito.
prefer.explicit.n.to.check.non.empty.string.or.use.ne.to.check.boolean.integer=Prefiera '-n' explícito para verificar cadenas no vacías. Use '\=' o '-ne' para verificar booleanos y enteros.
prefer.mapfile.or.read.a.to.split.command.output.or.quote.to.avoid.splitting=Prefiera 'mapfile' o 'read -a' para dividir la salida del comando (o ponga entre comillas para evitar división).
prefer.p.q.as.p.a.q.is.not.well.defined=Prefiera '[ p ] \\&\\& [ q ]' porque '[ p -a q ]' no está bien definido.
quote.arguments.to.unset.so.they.re.not.glob.expanded=Ponga los argumentos entre comillas para ignorar la sintaxis glob.
quote.eof.to.make.here.document.expansions.happen.on.the.server.side.rather.than.on.the.client=Agregue comillas alrededor de 'EOF' para que los documentos here se expandan en el lado del servidor en lugar del cliente.
quote.expansions.in.this.for.loop.glob.to.prevent.wordsplitting.e.g.dir.txt=Ponga entre comillas las expansiones en este glob de bucle for para prevenir división de palabras, por ejemplo\: "$dir"/*.txt
quote.parameters.to.tr.to.prevent.glob.expansion=Ponga entre comillas los parámetros de 'tr' para prevenir la expansión glob.
quote.the.grep.pattern.so.the.shell.won.t.interpret.it=Ponga entre comillas el patrón grep para que el shell no lo interprete.
quote.the.parameter.to.name.so.the.shell.won.t.interpret.it=Ponga entre comillas el parámetro de '-name' para que el shell no lo interprete.
quote.the.rhs.of.in.to.prevent.glob.matching=Ponga entre comillas el 'rhs of \=' en '[[ ]]' para prevenir coincidencia glob.
quote.this.invalid.brace.expansion.since.it.should.be.passed.literally.to.eval=Ponga entre comillas esta expansión de llaves inválida ya que debe pasarse literalmente a eval.
quote.this.to.prevent.word.splitting=Ponga esto entre comillas para prevenir la división de palabras.
quote.to.prevent.word.splitting.or.split.robustly.with.mapfile.or.read.a=Ponga entre comillas para prevenir división de palabras, o divida de manera robusta con 'mapfile' o 'read -a'.
quotes.backslashes.in.this.variable.will.not.be.respected=Las comillas y barras invertidas en esta variable no serán respetadas.
quotes.backslashes.will.be.treated.literally.use.an.array=Las comillas y barras invertidas serán tratadas literalmente. Use un array.
ranges.can.only.match.single.chars.mentioned.due.to.duplicates=Los rangos solo pueden coincidir con caracteres únicos (mencionado debido a duplicados).
read.without.r.will.mangle.backslashes='read' sin '-r' alterará las barras invertidas.
redirecting.to.echo.a.command.that.doesn.t.read.stdin.bad.quoting.or.missing.xargs=Redirigiendo a 'echo', un comando que no lee stdin. ¿Comillas incorrectas o falta xargs?
redirecting.to.from.command.name.instead.of.file.did.you.want.pipes.xargs.or.quote.to.ignore=Redirigiendo hacia o desde un nombre de comando en lugar de un archivo. Use pipes o xargs en su lugar (o ponga entre comillas para ignorar).
redirection.applies.to.the.find.command.itself.rewrite.to.work.per.action.or.move.to.end=La redirección se aplica al comando 'find' mismo. Reescriba para trabajar por acción (o mueva al final).
remove.backticks.to.avoid.executing.output=Elimine las comillas invertidas para evitar ejecutar la salida.
remove.exec.if.script.should.continue.after.this.command=Elimine "exec " si el script debe continuar después de este comando.
remove.for.numeric.index.or.escape.it.for.string=Elimine '$' y '${}'para índice numérico, o escápelo para cadena.
remove.or.use.expr.to.avoid.executing.output=Elimine '$' o use '_\=$((expr))' para evitar ejecutar la salida.
remove.superfluous.around.condition=Elimine `(..)` superfluo alrededor de la condición.
remove.superfluous.around.test.command=Elimine `(..)` superfluo alrededor del comando test.
remove.surrounding.to.avoid.executing.output=Elimine el '$()' envolvente para evitar ejecutar la salida.
sc2001.see.if.you.can.use.variable.search.replace.instead=SC2001\: Vea si puede usar ${variable//search/replace} en su lugar.
sc2009.consider.using.pgrep.instead.of.grepping.ps.output=SC2009 Considere usar pgrep en lugar de hacer grep a la salida de ps.
sc2094.make.sure.not.to.read.and.write.the.same.file.in.the.same.pipeline=SC2094 Asegúrese de no leer y escribir el mismo archivo en el mismo pipeline.
sc2106.this.only.exits.the.subshell.caused.by.the.pipeline=SC2106\: Esto solo sale del subshell causado por el pipeline.
sh.code.style.binary.ops.like.and.may.start.a.line=Permitir saltos de línea después de operadores binarios
sh.code.style.choose.path=Elegir ruta a Shfmt\:
sh.code.style.download.link=Descargar formateador shfmt
sh.code.style.keep.column.alignment.padding=Mantener el relleno de alineación de columnas
sh.code.style.minify.program.to.reduce.its.size=Minificar programa para reducir su tamaño
sh.code.style.redirect.operators.will.be.followed.by.a.space=Agregar espacio después de operadores de redirección
sh.code.style.switch.cases.will.be.indented=Indentar sentencias case
sh.code.style.unix.line.separator=Usar separadores de línea Unix (\\n)
sh.color.backquotes=Comillas invertidas
sh.color.braces.curly.brackets=Llaves//llaves
sh.color.braces.parentheses=Llaves//Paréntesis
sh.color.braces.square.brackets=Llaves//corchetes
sh.color.commands.generic.command=Comandos//comando genérico
sh.color.commands.subshell.command=Comandos//comando subshell
sh.color.conditional.operators=Operadores condicionales
sh.color.function.declaration=Declaración de función
sh.color.here.documents=Documentos Here
sh.color.here.documents.end=Fin de documentos Here
sh.color.here.documents.start=Inicio de documentos Here
sh.color.keyword=Palabra clave
sh.color.line.comment=Comentario de línea
sh.color.number=Número
sh.color.raw.string=Cadena sin formato
sh.color.redirection=Redirección
sh.color.shebang.comment=Comentario shebang
sh.color.string=Cadena
sh.color.variables.composed.variable=Variables//variable compuesta
sh.color.variables.variable.declaration=Variables//declaración de variable
sh.color.variables.variable.usage=Variables//uso de variable
sh.disable.inspection.text=Deshabilitar inspección {0}
sh.download=Descargar
sh.explain.command.to.explain=Comando a explicar
sh.explain.inspection.text=Explicar shell
sh.explain.message.nothing.to.explain=Nada que explicar
sh.explain.title.nothing.to.explain=Nada que explicar
sh.fmt.cannot.download=No se puede descargar el formateador shfmt. Instálelo manualmente.
sh.fmt.cannot.update=No se puede actualizar el formateador shfmt. Se ha revertido a la versión anterior.
sh.fmt.formatter=Formateador Shfmt
sh.fmt.indent.label=Indentación
sh.fmt.install.question=¿Desea instalar un formateador de scripts shell?
sh.fmt.missing.formatter=falta el formateador
sh.fmt.success.install=El formateador de scripts shell se instaló correctamente
sh.fmt.success.update=El formateador de scripts shell se actualizó correctamente
sh.fmt.update.question=¿Desea actualizar el formateador de scripts shell de "{0}" a "{1}"?
sh.install=Instalar
sh.invalid.path=Ruta inválida.
sh.label.choose.interpreter=Elegir intérprete
sh.label.choose.script.working.directory=Elegir directorio de trabajo del script
sh.label.choose.shell.script=Elegir script Shell
sh.label.download.shfmt.formatter=Descargar formateador shfmt
sh.livetemplate.description.array.add=Agregar nuevo elemento al final del array
sh.livetemplate.description.array.all=Todos los elementos del array
sh.livetemplate.description.array.at.index=Elementos en el índice
sh.livetemplate.description.array.create=Crear array
sh.livetemplate.description.array.delete=Eliminar array
sh.livetemplate.description.array.delete.at=Eliminar del array
sh.livetemplate.description.array.iteration=Iterar a través del array
sh.livetemplate.description.array.length=Longitud del array
sh.livetemplate.description.array.set.element=Elemento del array en índice
sh.livetemplate.description.case=Sentencia Case
sh.livetemplate.description.cmd=Sustitución de comando
sh.livetemplate.description.cmd.success.check=Verificación de éxito de Cmd
sh.livetemplate.description.command.exists=Comando existe
sh.livetemplate.description.curl=Petición HTTP
sh.livetemplate.description.directory.exists=Directorio existe
sh.livetemplate.description.elif=Expresión Elif
sh.livetemplate.description.file.equals=Archivo igual
sh.livetemplate.description.file.executable=Archivo ejecutable
sh.livetemplate.description.file.exists=Archivo existe
sh.livetemplate.description.file.newer=Archivo más nuevo
sh.livetemplate.description.file.not.empty=Archivo no está vacío
sh.livetemplate.description.file.older=Archivo más antiguo
sh.livetemplate.description.file.readable=Archivo legible
sh.livetemplate.description.file.writable=Archivo escribible
sh.livetemplate.description.find=Buscar archivo o directorio
sh.livetemplate.description.for=Bucle for por índice
sh.livetemplate.description.fori=Bucle for en lista
sh.livetemplate.description.function=Definir una función
sh.livetemplate.description.git.branch.create=Crear branch
sh.livetemplate.description.git.commit=Commit de cambios
sh.livetemplate.description.git.push=Push de branch al remoto
sh.livetemplate.description.heredoc=String multilínea
sh.livetemplate.description.if=Sentencia If
sh.livetemplate.description.mkdir=Crear directorio
sh.livetemplate.description.number.equal=Números son iguales
sh.livetemplate.description.number.greater=Número mayor que
sh.livetemplate.description.number.greater.or.equal=Número mayor o igual que
sh.livetemplate.description.number.less=Número menor que
sh.livetemplate.description.number.less.or.equal=Número menor o igual que
sh.livetemplate.description.number.not.equal=Números no son iguales
sh.livetemplate.description.path.exists=Ruta existe
sh.livetemplate.description.rm=Eliminar archivo o directorio
sh.livetemplate.description.select=Expresión select
sh.livetemplate.description.string.equal=Strings son iguales
sh.livetemplate.description.string.is.empty=String está vacío
sh.livetemplate.description.string.not.empty=String no está vacío
sh.livetemplate.description.string.not.equal=Strings no son iguales
sh.livetemplate.description.system.info.linux=Información del sistema Linux
sh.livetemplate.description.system.info.mac=Información del sistema Mac OS
sh.livetemplate.description.system.kernel.info=Información del kernel
sh.livetemplate.description.tar.compress=Compresión tar
sh.livetemplate.description.tar.decompress=Descompresión tar
sh.livetemplate.description.until=Bucle until por condición
sh.livetemplate.description.while=Bucle while por condición
sh.livetemplate.description.xargs=Ejecutar comandos desde entrada estándar
sh.markdown.runner.title=Ejecutar en Terminal
sh.no.thanks=No
sh.parser.expected.similar.close.bracket=Se esperaba un corchete de cierre similar
sh.path.label=Ruta\:
sh.rename.all.occurrences=Renombrar todas las ocurrencias
sh.rename.occurence=Renombrar {0}
sh.run.configuration.description.0.configuration=Configuración {0}
sh.run.environment.variables=Variables de entorno\:
sh.run.execute=Ejecutar\:
sh.run.execute.script.file=Archivo de script
sh.run.execute.script.text=Texto del script
sh.run.execute.script.text.title=Texto del script\:
sh.run.execute.terminal=Ejecutar en la terminal
sh.run.interpreter=Intérprete
sh.run.interpreter.not.found=Intérprete no encontrado
sh.run.interpreter.options=Opciones del intérprete\:
sh.run.interpreter.path=Ruta del intérprete\:
sh.run.interpreter.should.be.executable=El intérprete debe ser un archivo ejecutable
sh.run.script.not.found=Script Shell no encontrado
sh.run.script.options=Opciones del script\:
sh.run.script.path=Ruta del script\:
sh.run.working.dir=Directorio de trabajo\:
sh.run.working.dir.not.found=Directorio de trabajo no encontrado
sh.shell.script=Script Shell
sh.shellcheck.cannot.download=No se puede descargar shellcheck. Instálelo manualmente.
sh.shellcheck.cannot.update=No se puede actualizar shellcheck. Se ha revertido a la versión anterior.
sh.shellcheck.download.label.text=Descargar shellcheck
sh.shellcheck.install.question=¿Desea instalar shellcheck para verificar sus scripts shell?
sh.shellcheck.missing=\ falta shellcheck
sh.shellcheck.path.label=Elegir ruta a Shellcheck\:
sh.shellcheck.success.install=Shellcheck se ha instalado correctamente
sh.shellcheck.success.update=Shellcheck se ha actualizado correctamente
sh.shellcheck.update.question=¿Desea actualizar shellcheck de "{0}" a "{1}"?
sh.skip.version=Omitir esta versión
sh.suppress.inspection=Suprimir {0}
sh.unnamed.element.presentable.name=<unnamed>
sh.update=Actualizar
shell.functions.can.t.be.passed.to.external.commands=Las funciones Shell no pueden pasarse a comandos externos.
sigkill.sigstop.can.not.be.trapped=SIGKILL y SIGSTOP no pueden ser capturados.
since.you.double.quoted.this.it.will.not.word.split.and.the.loop.will.only.run.once=Como usó comillas dobles, no se dividirá por palabras y el bucle solo se ejecutará una vez.
some.finds.don.t.have.a.default.path.specify.explicitly=Algunos finds no tienen una ruta predeterminada. Especifique '.' explícitamente.
sudo.doesn.t.affect.redirects.use.sudo.tee.file=`sudo` no afecta a las redirecciones. Use `..| sudo tee file`
tempfile.is.deprecated.use.mktemp.instead=tempfile está obsoleto. Use mktemp en su lugar.
the.arguments.to.this.comparison.can.never.be.equal.make.sure.your.syntax.is.correct=Los argumentos de esta comparación nunca pueden ser iguales. Asegúrese de que su sintaxis sea correcta.
the.dot.command.does.not.support.arguments.in.sh.dash.set.them.as.variables=El comando dot no admite argumentos en sh/dash. Configúrelos como variables.
the.exit.status.can.only.be.one.integer.0.255.use.stdout.for.other.data=El estado de salida solo puede ser un entero 0-255. Use stdout para otros datos.
the.here.is.literal.to.assign.by.index.use.index.value.with.no.spaces.to.keep.as.literal.quote.it=El carácter igual '\=' aquí es literal. Para asignar por índice, use ( [índice]\=valor ) sin espacios. Para mantener como literal, use comillas.
the.surrounding.quotes.actually.unquote.this.remove.or.escape.them=Las comillas circundantes realmente eliminan las comillas. Elimínelas o escápelas.
this.action.ignores.everything.before.the.o.use.to.group=Esta acción ignora todo antes de '-o'. Use \\( \\) para agrupar.
this.array.element.has.no.value.remove.spaces.after.or.use.for.empty.string=Este elemento del array no tiene valor. Elimine los espacios después de '\=' o use "" para una cadena vacía.
this.assignment.is.only.seen.by.the.forked.process=Esta asignación solo es visible por el proceso fork.
this.case.is.not.specified.by.getopts=Este case no está especificado por 'getopts'.
this.cp.has.no.destination.check.the.arguments=Este 'cp' no tiene destino. Verifique los argumentos.
this.default.assignment.may.cause.dos.due.to.globbing.quote.it=Esta asignación por defecto puede causar DoS debido al globbing. Póngala entre comillas.
this.does.not.export.foo.remove.for.that.or.use.var.to.quiet=Esto no exporta 'FOO'. Elimine '$' y '${}' para eso, o use '${var?}' para silenciar.
this.does.not.read.foo.remove.for.that.or.use.var.to.quiet=Esto no lee 'foo'. Elimine '$' y '${}' o use '${var?}' para silenciar.
this.expands.when.defined.not.when.used.consider.escaping=Esto se expande cuando se define, no cuando se usa. Considere escapar.
this.expansion.will.not.see.the.mentioned.assignment=Esta expansión no verá la asignación mencionada.
this.expression.is.constant.did.you.forget.a.somewhere=Esta expresión es constante. ¿Olvidó un `$` en alguna parte?
this.expression.is.constant.did.you.forget.the.on.a.variable=Esta expresión es constante. ¿Olvidó el `$` en una variable?
this.flag.is.used.as.a.command.name.bad.line.break.or.missing=Esta bandera se usa como nombre de comando. ¿Salto de línea incorrecto o falta `[ .. ]`?
this.format.string.has.2.variables.but.is.passed.1.arguments=Esta cadena de formato tiene 2 variables, pero se le pasa 1 argumento.
this.function.is.only.defined.later.move.the.definition.up=Esta función solo se define más adelante. Mueva la definición hacia arriba.
this.is.a.file.redirection.was.it.supposed.to.be.a.comparison.or.fd.operation=Esto es una redirección de archivo. ¿Debería ser una comparación o una operación fd?
this.is.a.glob.used.as.a.command.name.was.it.supposed.to.be.in.array.or.is.it.missing.quoting=Esto es un glob usado como nombre de comando. ¿Debería estar en '${..}' o en un array? Si no, use comillas.
this.is.a.literal.string.to.run.as.a.command.use.instead.of=Esto es una cadena literal. Para ejecutar como comando, use '$(..)' en lugar de '..' .
this.is.interpreted.as.a.shell.file.redirection.not.a.comparison=Esto se interpreta como una redirección de archivo shell, no una comparación.
this.ln.has.no.destination.check.the.arguments.or.specify.explicitly=Este 'ln' no tiene destino. Verifique los argumentos o especifique '.' explícitamente.
this.loop.will.only.ever.run.once.for.a.constant.value.did.you.perhaps.mean.to.loop.over.dir.var.or.cmd=Este bucle solo se ejecutará una vez para un valor constante. ¿Quiso hacer un bucle sobre 'dir/*', '$var', o '$(cmd)'?
this.mv.has.no.destination.check.the.arguments=Este 'mv' no tiene destino. Verifique los argumentos.
this.nested.loop.overrides.the.index.variable.of.its.parent=Este bucle anidado sobrescribe la variable de índice de su padre.
this.parent.loop.has.its.index.variable.overridden=Este bucle padre tiene su variable de índice sobrescrita.
this.pattern.always.overrides.a.later.one=Este patrón siempre sobrescribe uno posterior.
this.pattern.never.matches.because.of.a.previous.pattern=Este patrón nunca coincide debido a un patrón anterior.
this.pattern.will.never.match.the.case.statement.s.word.double.check.them=Este patrón nunca coincidirá con la palabra de la sentencia case.
this.printf.format.string.has.no.variables.other.arguments.are.ignored=Esta cadena de formato printf no tiene variables. Se ignoran otros argumentos.
this.redirection.doesn.t.have.a.command.move.to.its.command.or.use.true.as.no.op=Esta redirección no tiene un comando. Muévalo a su comando (o use 'true' como no-op).
this.shebang.specifies.a.directory.ensure.the.interpreter.is.a.file=Este shebang especifica un directorio. Asegúrese de que el intérprete sea un archivo.
this.terminates.the.command.escape.it.or.add.space.after.to.silence=Este `\\&` termina el comando. Escápelo o agregue un espacio después de `\\&` para silenciarlo.
this.will.expand.once.before.find.runs.not.per.file.found=Esto se expandirá una vez antes de que find se ejecute, no por cada archivo encontrado.
this.word.is.constant.did.you.forget.the.on.a.variable=Esta palabra es una constante. ¿Olvidó el carácter '$' en una variable?
this.word.is.outside.of.quotes.did.you.intend.to.nest.single.quotes.instead=Esta palabra está fuera de las comillas. ¿Pretendía 'anidar '"'comillas simples'"' en su lugar?
tilde.does.not.expand.in.quotes.use.home=La tilde no se expande entre comillas. Use $HOME.
time.is.undefined.for.compound.commands.time.sh.c.instead='time' no está definido para comandos compuestos. Use 'time sh -c' en su lugar.
time.is.undefined.for.pipelines.time.single.stage.or.bash.c.instead='time' no está definido para pipelines. Use `time` en una sola etapa o `time bash -c` en su lugar.
tips.depend.on.target.shell.and.yours.is.unknown.add.a.shebang=Los consejos dependen del shell objetivo. Agregue un shebang.
to.assign.a.variable.use.just.var.value.no.set=Para asignar una variable, use 'var\=value', no 'set ..'.
to.assign.the.output.of.a.command.use.var.cmd=Para asignar la salida de un comando, use 'var\=$(cmd)'.
to.expand.via.indirection.use.name.foo.n.echo.name=Para expandir por indirección, use name\="foo$n"; echo "${\!name}".
to.read.lines.rather.than.words.pipe.redirect.to.a.while.read.loop=Para leer líneas en lugar de palabras, redirija la salida mediante pipe a un bucle 'while read'.
to.redirect.stdout.stderr.2.1.must.be.last.or.use.cmd.file.2.1.to.clarify=Para redirigir stdout+stderr, '2>\\&1' debe ser el último (o use '{ cmd > file; } 2>\\&1' para aclarar).
to.run.commands.as.another.user.use.su.c.or.sudo=Para ejecutar comandos como otro usuario, use 'su -c' o 'sudo'.
tr.replaces.sets.of.chars.not.words.mentioned.due.to.duplicates='tr' reemplaza conjuntos de caracteres, no palabras (mencionado debido a duplicados).
trapping.signals.by.number.is.not.well.defined.prefer.signal.names=Capturar señales por número no está bien definido. Prefiera nombres de señales.
unexpected.start.of.line.if.breaking.lines.should.be.at.the.end.of.the.previous.one=Inicio inesperado de una nueva línea. Si se rompen líneas, |/||/\\&\\& debe estar al final de la línea anterior.
unknown.binary.operator=Operador binario desconocido.
unknown.unaryoperator=Operador unario desconocido.
use.a.subshell.to.avoid.having.to.cd.back=Use un ( subshell ) para evitar tener que hacer cd de vuelta.
use.array.item.to.append.items.to.an.array=Use 'array+\=("item")' para agregar elementos a un array.
use.cd.exit.in.case.cd.fails=Use cd ... || exit en caso de que cd falle.
use.false.instead.of.empty.conditionals=Use 'false' en lugar de condicionales '[' y '[[' vacíos.
use.find.instead.of.ls.to.better.handle.non.alphanumeric.filenames=Use `find` en lugar de `ls` para manejar mejor los nombres de archivo no alfanuméricos.
use.foo.if.function.s.1.should.mean.script.s.1=Use 'foo "$@"' si el argumento '$1' de la función debe significar el argumento '$1' del script.
use.for.arithmetics.e.g.i.i.2=Use `$((..))` para aritmética, por ejemplo\: i\=$((i + 2))
use.glob.or.glob.so.names.with.dashes.won.t.become.options=Use './\\*glob*' o '-- \\*glob*' para que los nombres con guiones no se conviertan en opciones.
use.grep.q.instead.of.comparing.output.with.n=Use 'grep -q' en lugar de comparar la salida con '[ -n .. ]'.
use.instead.of.deprecated=Use '$((..))' en lugar del obsoleto '$[..]'.
use.instead.of.to.avoid.subshell.overhead=Use `{ ..; }` en lugar de `(..)` para evitar la sobrecarga del subshell.
use.lower.to.support.accents.and.foreign.alphabets=Use '[\:lower\:]' para soportar acentos y alfabetos extranjeros.
use.n.instead.of.z=Use `[ -n .. ]` en lugar de `\! [ -z .. ]`.
use.n.instead.of.z2=Use `-n` en lugar de `\! -z`.
use.notation.instead.of.legacy.backticked=Use la notación '$(...)' en lugar de las comillas invertidas heredadas `` `...` ``.
use.or.quote.arguments.to.v.to.avoid.glob.expansion=Use `[[ ]]` o ponga entre comillas los argumentos de la opción '-v' para evitar la expansión glob.
use.own.script.or.sh.c.to.run.this.from.su=Use script propio o sh -c '..' para ejecutar esto desde su.
use.print0.0.or.find.exec.to.allow.for.non.alphanumeric.filenames=Use '-print0', '-0', o 'find -exec +' para permitir nombres de archivo no alfanuméricos.
use.single.quotes.otherwise.this.expands.now.rather.than.when.signalled=Use comillas simples para expandir solo cuando se señale, no inmediatamente.
use.spaces.not.commas.to.separate.array.elements=Use espacios, no comas, para separar elementos del array.
use.upper.to.support.accents.and.foreign.alphabets=Use '[\:upper\:]' para soportar acentos y alfabetos extranjeros.
use.var.command.to.assign.output.or.quote.to.assign.string=Use 'var\=$(command)' para asignar salida (o use comillas para asignar cadena).
use.var.to.ensure.this.never.expands.to=Use "${var\:?}" para asegurar que esto nunca se expanda a /* .
use.with.quotes.to.prevent.whitespace.problems=Use "$@" (con comillas) para prevenir problemas de espacios en blanco.
useless.cat.consider.cmd.file.or.cmd.file.instead='cat' redundante. Considere usar 'cmd < file | ..' o 'cmd file | ..' en su lugar.
useless.echo.instead.of.cmd.echo.foo.just.use.cmd.foo=¿Echo redundante? En lugar de 'cmd $(echo foo)', use 'cmd foo'.
useless.echo.instead.of.echo.cmd.just.use.cmd=¿`echo` redundante? En lugar de `echo $(cmd)`, use `cmd`.
var.is.referenced.but.not.assigned='var' está referenciado pero no asignado.
var.was.modified.in.a.subshell.that.change.might.be.lost='var' fue modificado en un subshell. Ese cambio podría perderse.
variable.was.used.as.an.array.but.is.now.assigned.a.string=La variable se usó como array pero ahora se le asigna una cadena.
warning.deletes.a.system.directory=Advertencia\: elimina un directorio del sistema.
when.used.with.p.m.only.applies.to.the.deepest.directory=Cuando se usa con '-p', '-m' solo se aplica al directorio más profundo.
which.is.non.standard.use.builtin.command.v.instead='which' no es estándar. Use el comando incorporado 'command -v' en su lugar.
word.is.on.the.form.a.b.c.b.indicated.did.you.mean.abc.or.a.b.c=\ La palabra tiene la forma "A"B"C" (B indicada). ¿Quiso decir "ABC" o "A\\"B\\"C"?
you.can.t.have.between.this.redirection.and.the.command.it.should.apply.to=No puede tener '|' entre esta redirección y el comando al que se aplica.
you.need.spaces.around.the.comparison.operator=Necesita espacios alrededor del operador de comparación.
you.probably.wanted.here=Use '\\&\\&'.