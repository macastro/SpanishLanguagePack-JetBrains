action.find.similar.stack.call.methods.not.found=No se encontraron clases similares
advanced.setting.process.console.output.to.find.class.names=Procesar salida de terminal para encontrar y resaltar nombres de clase
allow.suppressions.fix.family.name=Permitir supresiones
allow.suppressions.fix.text=Permitir estas supresiones
assertequals.between.inconvertible.types.display.name='assertEquals()' entre objetos de tipos no convertibles
can.t.build.uast.tree.for.file=No se puede construir árbol UAST para el archivo
checkbox.comments.and.javadoc.count.as.content=Los comentarios y javadoc cuentan como contenido
current.version=Versión actual\:
dialog.title.choose.annotation=Elegir {0}
group.advanced.settings.jvm=Lenguajes JVM
ignored.suppressions=Supresiones ignoradas\:
inspection.empty.method.delete.quickfix=Eliminar método(s) innecesario(s)
inspection.empty.method.display.name=Método vacío
inspection.empty.method.problem.descriptor=El método solo llama a su super
inspection.empty.method.problem.descriptor1=Método vacío sobrescribe método vacío
inspection.empty.method.problem.descriptor2=El método está vacío
inspection.empty.method.problem.descriptor3=El método y todos sus derivables están vacíos
inspection.empty.method.problem.descriptor4=Todas las implementaciones de este método están vacías
inspection.message.illegal.dependency.module.doesn.t.export=Dependencia ilegal\: el módulo ''{0}'' no exporta el paquete ''{1}''
inspection.suppression.annotation.display.name=Anotación de supresión de inspección
inspection.suppression.annotation.problem.descriptor=La anotación suprime {0} \#loc
inspection.suppression.comment.problem.descriptor=El comentario suprime {0} \#loc
jvm.class.filter.choose.calls=Llamadas de log similares\:
jvm.inspection.log.guarded.display.name=Llamadas de logging protegidas por condición de log
jvm.inspection.log.guarded.fix.family.name=Desenvolver condición de protección de log
jvm.inspection.log.guarded.problem.descriptor=Llamada de logging protegida por condición de log \#loc
jvm.inspection.log.guarded.warn.if.fix.possible=Advertir solo si hay una corrección disponible
jvm.inspection.log.statement.not.guarded.all.levels.option=todos los niveles de log
jvm.inspection.log.statement.not.guarded.debug.level.and.lower.option=nivel debug e inferiores
jvm.inspection.log.statement.not.guarded.display.name=Llamada de logging no protegida por condición de log
jvm.inspection.log.statement.not.guarded.info.level.and.lower.option=nivel info e inferiores
jvm.inspection.log.statement.not.guarded.log.fix.family.name=Rodear con una condición de logging
jvm.inspection.log.statement.not.guarded.log.problem.descriptor=Llamada de logging no protegida por una condición de logging \#loc
jvm.inspection.log.statement.not.guarded.trace.level.option=nivel trace
jvm.inspection.log.statement.not.guarded.unguarded.constant.option=Procesar llamadas de logging no protegidas con mensajes constantes
jvm.inspection.log.statement.not.guarded.unguarded.constant.option.comment=Procesar todas las llamadas de log no protegidas, no solo aquellas con argumentos no constantes
jvm.inspection.log.statement.not.guarded.warn.level.and.lower.option=nivel warn e inferiores
jvm.inspection.log.statement.not.guarded.warn.on.label=Advertir sobre\:
jvm.inspection.logging.condition.disagrees.with.log.statement.display.name=La condición de log no coincide con la llamada de logging
jvm.inspection.logging.condition.disagrees.with.log.statement.fix.family.name=Cambiar nivel de log
jvm.inspection.logging.condition.disagrees.with.log.statement.fix.name=Cambiar nivel de la {0, choice, 0\#condición|1\#llamada}
jvm.inspection.logging.condition.disagrees.with.log.statement.problem.descriptor=El nivel de la condición ''{0}'' no coincide con el nivel de la llamada de logging ''{1}''
jvm.inspection.logging.placeholder.count.matches.argument.count.display.name=El número de placeholders no coincide con el número de argumentos en la llamada de logging
jvm.inspection.logging.placeholder.count.matches.argument.count.fewer.problem.descriptor=Se proporcionaron menos argumentos ({0}) que placeholders especificados ({1}) \#loc
jvm.inspection.logging.placeholder.count.matches.argument.count.fewer.problem.partial.descriptor=Se proporcionaron menos argumentos ({0}) que placeholders especificados (al menos {1}) \#loc
jvm.inspection.logging.placeholder.count.matches.argument.count.incorrect.problem.descriptor=Especificador de formato de cadena ilegal \#loc
jvm.inspection.logging.placeholder.count.matches.argument.count.more.problem.descriptor=Se proporcionaron más argumentos ({0}) que placeholders especificados ({1}) \#loc
jvm.inspection.logging.placeholder.count.matches.argument.count.slf4j.throwable.option=SLF4J usa Log4j 2 como implementación
jvm.inspection.logging.placeholder.count.matches.argument.count.slf4j.throwable.option.auto=Comprobar automáticamente
jvm.inspection.logging.placeholder.count.matches.argument.count.slf4j.throwable.option.no=No
jvm.inspection.logging.placeholder.count.matches.argument.count.slf4j.throwable.option.yes=Sí
jvm.inspection.logging.similar.message.display.name=Llamadas de logging no distinguibles
jvm.inspection.logging.similar.message.problem.descriptor=Mensajes de log similares
jvm.inspection.logging.similar.message.problem.min.similar.length=Longitud mínima de una secuencia similar
jvm.inspection.logging.similar.message.problem.skip.on.error=No reportar llamadas con nivel de log `error`
jvm.inspection.logging.string.template.as.argument.all.levels.option=todos los niveles de log
jvm.inspection.logging.string.template.as.argument.debug.level.and.lower.option=nivel debug e inferiores
jvm.inspection.logging.string.template.as.argument.display.name=Plantilla de cadena como argumento en llamada de logging
jvm.inspection.logging.string.template.as.argument.info.level.and.lower.option=nivel info e inferiores
jvm.inspection.logging.string.template.as.argument.problem.descriptor=Plantilla de cadena como argumento en llamada de logging <code>\#ref()</code> \#loc
jvm.inspection.logging.string.template.as.argument.quickfix.name=Reemplazar con placeholders
jvm.inspection.logging.string.template.as.argument.skip.on.only.exception=No advertir cuando la llamada solo tiene una excepción como argumento después del argumento de mensaje.
jvm.inspection.logging.string.template.as.argument.skip.on.primitives=No advertir cuando solo se incluyen expresiones con tipos primitivos, sus wrappers o String
jvm.inspection.logging.string.template.as.argument.trace.level.option=nivel trace
jvm.inspection.logging.string.template.as.argument.warn.level.and.lower.option=nivel warn e inferiores
jvm.inspection.logging.string.template.as.argument.warn.on.label=Advertir sobre\:
jvm.inspection.test.failed.line.display.name=Línea fallida en test
jvm.inspections.1.5.problem.descriptor=Uso de API documentada como @since {0}+
jvm.inspections.1.7.problem.descriptor=Uso de API generalizada después de 1.6 que causaría problemas de compilación con JDK {0}
jvm.inspections.1.8.problem.descriptor={0, choice, 0\#Los métodos|1\#El método|2\#Los métodos} por defecto no están sobrescritos. Causaría problemas de compilación con JDK {1}
jvm.inspections.1.8.problem.single.descriptor=El método por defecto ''{0}'' no está sobrescrito. Causaría problemas de compilación con JDK {1}
jvm.inspections.api.display.name=Usos de API no disponible en el nivel de lenguaje configurado
jvm.inspections.api.no.extension.class.description=La clase ''{0}'' no debe extenderse
jvm.inspections.api.no.extension.display.name=La clase, interfaz o método no debe extenderse
jvm.inspections.api.no.extension.interface.extend.description=La interfaz ''{0}'' no debe extenderse
jvm.inspections.api.no.extension.interface.implement.description=La interfaz ''{0}'' no debe implementarse
jvm.inspections.api.no.extension.method.overriding.description=El método ''{0}'' no debe sobrescribirse
jvm.inspections.api.override.only.description=El método ''{0}'' solo puede sobrescribirse
jvm.inspections.api.override.only.display.name=El método solo puede sobrescribirse
jvm.inspections.assertequals.between.inconvertible.types.problem.descriptor=<code>\#ref()</code> entre objetos de tipos no convertibles ''{0}'' y ''{1}'' \#loc
jvm.inspections.assertnotequals.between.inconvertible.types.problem.descriptor=Posible aserción redundante\: se comparan tipos incompatibles ''{0}'' y ''{1}''
jvm.inspections.assertnotsame.between.inconvertible.types.problem.descriptor=Aserción redundante\: se comparan tipos incompatibles ''{0}'' y ''{1}''
jvm.inspections.blocking.method.annotation.blocking=Anotaciones bloqueantes\:
jvm.inspections.blocking.method.annotation.configure.add.blocking.title=Agregar anotación bloqueante
jvm.inspections.blocking.method.annotation.configure.add.non-blocking.title=Agregar anotación no bloqueante
jvm.inspections.blocking.method.annotation.non-blocking=Anotaciones no bloqueantes\:
jvm.inspections.blocking.method.consider.suspend.context.non.blocking=Considerar el contexto suspend de Kotlin como no bloqueante
jvm.inspections.blocking.method.consider.unknown.context.blocking=Considerar contextos desconocidos como bloqueantes
jvm.inspections.blocking.method.consider.unknown.context.nonblocking=Considerar contextos desconocidos como no bloqueantes
jvm.inspections.blocking.method.display.name=Llamada potencialmente bloqueante en contexto no bloqueante
jvm.inspections.blocking.method.in.implicit.ctr.problem.descriptor=La llamada potencialmente bloqueante desde una llamada implícita al constructor en un contexto no bloqueante podría causar inanición de hilos
jvm.inspections.blocking.method.in.implicit.ctr.problem.wildcard.descriptor=La llamada potencialmente bloqueante desde una llamada implícita al constructor en {0} podría causar inanición de hilos
jvm.inspections.blocking.method.intention.text=Habilita la opción de inspección ''{0}''.
jvm.inspections.blocking.method.problem.descriptor=La llamada potencialmente bloqueante en un contexto no bloqueante podría causar inanición de hilos
jvm.inspections.blocking.method.problem.wildcard.descriptor=La llamada potencialmente bloqueante en {0} podría causar inanición de hilos
jvm.inspections.collection.contains.url.problem.descriptor=''{0}'' puede contener objetos URL \#loc
jvm.inspections.dependency.display.name=Dependencias de paquete ilegales
jvm.inspections.dependency.edit.rules.family=Editar reglas de dependencia
jvm.inspections.dependency.edit.rules.text=Editar regla de dependencia "{0}"
jvm.inspections.dependency.intention.description=Abre un diálogo para configurar reglas de dependencia entre ámbitos.
jvm.inspections.dependency.on.internal.display.name=Dependencia ilegal en paquete interno
jvm.inspections.dependency.violator.problem.descriptor=Se viola la regla de dependencia ''{0}.''
jvm.inspections.equals.hashcode.called.on.url.display.name=Llamada a 'equals()' o 'hashCode()' en objeto 'URL'
jvm.inspections.equals.hashcode.called.on.url.problem.descriptor=Llamada a ''{0}'' en objeto URL
jvm.inspections.group.name=Lenguajes JVM
jvm.inspections.logging.frameworks.group.name=Logging
jvm.inspections.missing.deprecated.annotation.on.scheduled.for.removal.api.description=La API programada para eliminación también debe estar marcada con la anotación '@Deprecated'
jvm.inspections.missing.deprecated.annotation.on.scheduled.for.removal.api.display.name=Falta la anotación '@Deprecated' en la API programada para eliminación
jvm.inspections.must.already.be.removed.api.current.version.description=La API debe eliminarse en la versión actual {0}
jvm.inspections.must.already.be.removed.api.display.name=La API ya debe estar eliminada
jvm.inspections.must.already.be.removed.api.earlier.version.description=La API debería haberse eliminado en la versión {0} pero la versión actual es {1}
jvm.inspections.scheduled.for.removal.api.is.declared.in.marked.api=''{0}'' está declarado en {1} ''{2}'' programado para eliminarse en {3}
jvm.inspections.scheduled.for.removal.api.is.marked.itself=''{0}'' está programado para eliminarse en {1}
jvm.inspections.scheduled.for.removal.future.version=una versión futura
jvm.inspections.scheduled.for.removal.method.overridden.declared.in.marked.api=El método sobrescrito ''{0}'' está declarado en {1} ''{2}'' programado para eliminarse en {3}
jvm.inspections.scheduled.for.removal.method.overridden.marked.itself=El método sobrescrito ''{0}'' está programado para eliminarse en {1}
jvm.inspections.scheduled.for.removal.predefined.version=versión {0}
jvm.inspections.scheduled.for.removal.scheduled.for.removal.type.is.used.in.signature.of.referenced.api=''{0}'' está programado para eliminarse porque su firma hace referencia a {1} ''{2}'' programado para eliminarse en {3}
jvm.inspections.serializable.class.without.serialversionuid.display.name=Clase Serializable sin 'serialVersionUID'
jvm.inspections.serializable.class.without.serialversionuid.problem.descriptor=<code>\#ref</code> no define un campo 'serialVersionUID' \#loc
jvm.inspections.source.to.sink.flow.assigned.unknown=String desconocido asignado a variable segura
jvm.inspections.source.to.sink.flow.assigned.unsafe=String no seguro asignado a variable segura
jvm.inspections.source.to.sink.flow.common.unknown=String desconocido usado en contexto seguro
jvm.inspections.source.to.sink.flow.common.unsafe=String no seguro usado en contexto seguro
jvm.inspections.source.to.sink.flow.display.name=String no seguro pasado a método seguro
jvm.inspections.source.to.sink.flow.passed.unknown=String desconocido usado como parámetro seguro
jvm.inspections.source.to.sink.flow.passed.unsafe=String no seguro usado como parámetro seguro
jvm.inspections.source.to.sink.flow.returned.unknown=String desconocido devuelto desde método seguro
jvm.inspections.source.to.sink.flow.returned.unsafe=String no seguro devuelto desde método seguro
jvm.inspections.source.to.sink.flow.too.complex=Demasiado complejo para verificar si el string es seguro en un contexto seguro
jvm.inspections.source.unsafe.to.sink.flow.check.private.methods=Considerar parámetros de métodos private como seguros
jvm.inspections.source.unsafe.to.sink.flow.check.private.methods.comment=Si está habilitado, los parámetros de métodos private se considerarán seguros, de lo contrario se considerarán desconocidos
jvm.inspections.source.unsafe.to.sink.flow.check.warn.if.complex=Informar si el caso es demasiado complejo para verificar
jvm.inspections.source.unsafe.to.sink.flow.check.warn.if.complex.comment=Informar objetos que no se pueden verificar debido a su complejidad
jvm.inspections.source.unsafe.to.sink.flow.checked.types=Tipos verificados\:
jvm.inspections.source.unsafe.to.sink.flow.config=La anotación Untainted se agregará a la configuración de inspección para el elemento ''{0}''
jvm.inspections.source.unsafe.to.sink.flow.depth.inside=Profundidad de análisis dentro del método\:
jvm.inspections.source.unsafe.to.sink.flow.impossible=La anotación Untainted no es compatible con el elemento ''{0}''. El elemento será omitido
jvm.inspections.source.unsafe.to.sink.flow.index.parameter=Índice de Parámetro
jvm.inspections.source.unsafe.to.sink.flow.mark.as.safe.command.name=Marcar como Requiere Validación
jvm.inspections.source.unsafe.to.sink.flow.mark.as.safe.family=Marcar como requiere validación
jvm.inspections.source.unsafe.to.sink.flow.mark.as.safe.text=Marcar elementos como requieren validación
jvm.inspections.source.unsafe.to.sink.flow.not.number=No es un número
jvm.inspections.source.unsafe.to.sink.flow.place.class.column.title=Nombre de Clase del Contexto
jvm.inspections.source.unsafe.to.sink.flow.place.method.column.title=Regex del Nombre de Método del Contexto
jvm.inspections.source.unsafe.to.sink.flow.preview=Agregar anotación '@Untainted'
jvm.inspections.source.unsafe.to.sink.flow.preview.propagate=Mostrar árbol de propagación
jvm.inspections.source.unsafe.to.sink.flow.propagate.safe.family=Árbol de propagación
jvm.inspections.source.unsafe.to.sink.flow.propagate.safe.preview=Abre una ventana de herramientas para verificar la propagación de la anotación segura
jvm.inspections.source.unsafe.to.sink.flow.propagate.safe.text=Mostrar árbol de propagación desde aquí
jvm.inspections.source.unsafe.to.sink.flow.propagate.safe.toolwindow.annotate=Anotar Todo excepto Excluidos
jvm.inspections.source.unsafe.to.sink.flow.propagate.safe.toolwindow.title=Miembros No Seguros
jvm.inspections.source.unsafe.to.sink.flow.propagate.safe.toolwindow.unsafe.flow=Flujo no seguro
jvm.inspections.source.unsafe.to.sink.flow.qualifier.cleaner.arguments=Argumentos
jvm.inspections.source.unsafe.to.sink.flow.qualifier.cleaner.classes=Clases
jvm.inspections.source.unsafe.to.sink.flow.qualifier.cleaner.comment=Estos métodos marcan los calificadores como 'untainted' (Los argumentos deben separarse por comas)
jvm.inspections.source.unsafe.to.sink.flow.qualifier.cleaner.methods=Métodos
jvm.inspections.source.unsafe.to.sink.flow.qualifier.cleaner.table=Métodos para limpiar calificadores\:
jvm.inspections.source.unsafe.to.sink.flow.safe.class=Clases seguras\:
jvm.inspections.source.unsafe.to.sink.flow.safe.class.comment=Estas clases no pueden contener datos no seguros
jvm.inspections.source.unsafe.to.sink.flow.show.unknown.object=Reportar objeto desconocido
jvm.inspections.source.unsafe.to.sink.flow.show.unsafe.object=Reportar objeto inseguro
jvm.inspections.source.unsafe.to.sink.flow.tainted.annotations=Anotaciones contaminadas\:
jvm.inspections.source.unsafe.to.sink.flow.tainted.annotations.comment=Estas anotaciones se usarán como anotaciones '@Tainted' durante el análisis
jvm.inspections.source.unsafe.to.sink.flow.tainted.methods=Métodos contaminados\:
jvm.inspections.source.unsafe.to.sink.flow.tainted.methods.comment=Se considera que estos métodos solo devuelven objetos no seguros
jvm.inspections.source.unsafe.to.sink.flow.tainted.parameters=Parámetros contaminados\:
jvm.inspections.source.unsafe.to.sink.flow.tainted.parameters.comment=Estos parámetros se consideran con anotación '@Tainted'
jvm.inspections.source.unsafe.to.sink.flow.untainted.annotations=Anotaciones no contaminadas\:
jvm.inspections.source.unsafe.to.sink.flow.untainted.annotations.comment=Estas anotaciones se usarán como anotaciones '@Untainted' durante el análisis. La primera anotación de esta lista se usará para propagación si existe en el classpath.
jvm.inspections.source.unsafe.to.sink.flow.untainted.fields=Campos no contaminados\:
jvm.inspections.source.unsafe.to.sink.flow.untainted.fields.comment=Se considera que estos campos solo contienen objetos seguros
jvm.inspections.source.unsafe.to.sink.flow.untainted.fields.name=Nombre del campo
jvm.inspections.source.unsafe.to.sink.flow.untainted.methods=Métodos no contaminados\:
jvm.inspections.source.unsafe.to.sink.flow.untainted.methods.comment=Se considera que estos métodos solo devuelven objetos seguros
jvm.inspections.source.unsafe.to.sink.flow.untainted.parameters=Parámetros no contaminados\:
jvm.inspections.source.unsafe.to.sink.flow.untainted.parameters.comment=Estos parámetros se consideran con anotación '@Untainted'
jvm.inspections.source.unsafe.to.sink.flow.untainted.process.as.qualifier.arguments=Considerar métodos externos como no contaminados si los receptores y argumentos no están contaminados
jvm.inspections.source.unsafe.to.sink.flow.untainted.process.as.qualifier.arguments.comment=Si está habilitado, los métodos externos fuera de la clase actual se considerarán seguros si sus receptores y argumentos son seguros. En algunos casos no es aplicable, pero puede ser útil para clases sin estado. De lo contrario, todos los métodos externos se considerarán inseguros
jvm.inspections.string.touppercase.tolowercase.without.locale.description=<code>String.{0}()</code> llamado sin especificar un Locale usando cadenas internacionalizadas \#loc
jvm.inspections.system.get.property.display.name=La llamada a 'System.getProperty(str)' podría simplificarse
jvm.inspections.system.get.property.problem.descriptor=La llamada <code>\#ref</code> puede simplificarse para ''{0}''
jvm.inspections.test.case.in.product.source.display.name=Prueba en código fuente de producción
jvm.inspections.test.case.in.product.source.problem.descriptor=El caso de prueba <code>\#ref</code> probablemente debería estar en un árbol de fuentes de prueba \#loc
jvm.inspections.test.case.with.constructor.display.name=TestCase con constructores no triviales
jvm.inspections.test.case.with.constructor.problem.descriptor=Lógica de inicialización en constructor <code>\#ref()</code> en lugar del método de ciclo de vida 'setup()' \#loc
jvm.inspections.test.case.with.constructor.problem.descriptor.initializer=Lógica de inicialización en inicializador en lugar del método de ciclo de vida 'setup()'
jvm.inspections.test.case.without.test.methods.display.name=Clase de prueba sin tests
jvm.inspections.test.case.without.test.methods.option=Ignorar casos de prueba que tienen superclases con métodos de prueba
jvm.inspections.test.case.without.test.methods.problem.descriptor=La clase de prueba <code>\#ref</code> no tiene tests \#loc
jvm.inspections.test.frameworks.group.name=Frameworks de prueba
jvm.inspections.test.method.in.product.source.problem.descriptor=El método de prueba <code>\#ref()</code> probablemente debería estar en un árbol de fuentes de prueba \#loc
jvm.inspections.test.method.without.assertion.display.name=Método de prueba sin aserciones
jvm.inspections.test.method.without.assertion.problem.descriptor=El método de prueba <code>\#ref()</code> no contiene aserciones \#loc
jvm.inspections.testonly.class.reference=Clase exclusiva de pruebas referenciada en código de producción
jvm.inspections.testonly.display.name=Uso exclusivo de pruebas en código de producción
jvm.inspections.testonly.field.reference=Campo exclusivo de pruebas referenciado en código de producción
jvm.inspections.testonly.method.call=Método exclusivo de pruebas llamado en código de producción
jvm.inspections.testonly.visiblefortesting=@VisibleForTesting tiene poco sentido en código @TestOnly
jvm.inspections.thread.run.display.name=Llamada a 'Thread.run()'
jvm.inspections.unstable.api.usage.annotations.list=Anotaciones de API inestable\:
jvm.inspections.unstable.api.usage.api.is.declared.in.unstable.api=''{0}'' está declarado en {1} inestable ''{2}'' marcado con @{3}
jvm.inspections.unstable.api.usage.api.is.marked.unstable.itself=''{0}'' está marcado como inestable con @{1}
jvm.inspections.unstable.api.usage.display.name=Uso de API inestable
jvm.inspections.unstable.api.usage.ignore.declared.inside.this.project=Ignorar API declarada en este proyecto
jvm.inspections.unstable.api.usage.ignore.inside.imports=Ignorar dentro de las importaciones
jvm.inspections.unstable.api.usage.overridden.method.is.declared.in.unstable.api=El método sobrescrito ''{0}'' está declarado en {1} inestable ''{2}'' marcado con @{3}
jvm.inspections.unstable.api.usage.overridden.method.is.marked.unstable.itself=El método sobrescrito ''{0}'' está marcado como inestable con @{1}
jvm.inspections.unstable.api.usage.unstable.type.is.used.in.signature.of.referenced.api=''{0}'' es inestable porque su firma referencia {1} inestable ''{2}'' marcado con @{3}
jvm.inspections.unstable.type.used.in.class.signature.description=La clase debe estar marcada con la anotación ''@{0}'' porque su declaración referencia el tipo inestable ''{1}''
jvm.inspections.unstable.type.used.in.field.signature.description=El campo debe estar marcado con la anotación ''@{0}'' porque su tipo referencia el tipo inestable ''{1}''
jvm.inspections.unstable.type.used.in.method.signature.description=El método debe estar marcado con la anotación ''@{0}'' porque su firma referencia el tipo inestable ''{1}''
jvm.inspections.unstable.type.used.in.signature.display.name=Se usa un tipo inestable en la firma
jvm.inspections.usages.of.obsolete.api.description=Se usa una API obsoleta
jvm.inspections.usages.of.obsolete.api.display.name=Usos de ApiStatus.@Obsolete
jvm.options.general.color.descriptor.logging.string.placeholder=Cadena de log//Placeholder
propagated.from=Razón de la propagación\:
propagated.to=Objetivo a propagar\:
remove.suppress.comment.fix.family.name=Eliminar //{0}
title.uast=UAST