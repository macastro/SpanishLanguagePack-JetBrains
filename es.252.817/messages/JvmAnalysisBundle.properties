action.find.similar.stack.call.methods.not.found=No se encontraron clases similares
advanced.setting.process.console.output.to.find.class.names=Procesar la terminal de salida para encontrar nombres de clase y resaltarlos
allow.suppressions.fix.family.name=Permitir supresiones
allow.suppressions.fix.text=Permitir estos bloqueos
assertequals.between.inconvertible.types.display.name='assertEquals()' entre objetos de tipos inconvertibles
can.t.build.uast.tree.for.file=No se puede compilar el árbol UAST para el archivo
checkbox.comments.and.javadoc.count.as.content=Comentarios y javadoc cuentan como contenido
current.version=versión actual
dialog.title.choose.annotation=Seleccionar {0}
group.advanced.settings.jvm=Lenguajes JVM
ignored.suppressions=Supresiones ignoradas:
inspection.empty.method.delete.quickfix=Eliminar método(s) innecesario(s)
inspection.empty.method.display.name=Método vacío
inspection.empty.method.problem.descriptor=El método solo llama a su superclase
inspection.empty.method.problem.descriptor1=Método vacío anula método vacío
inspection.empty.method.problem.descriptor2=El método está vacío
inspection.empty.method.problem.descriptor3=El método y todos sus derivables están vacíos
inspection.empty.method.problem.descriptor4=Todas las implementaciones de este método están vacías
inspection.message.illegal.dependency.module.doesn.t.export=Dependencia ilegal: el módulo ''{0}'' no exporta el paquete ''{1}''
inspection.suppression.annotation.display.name=Anotación de supresión de inspección
inspection.suppression.annotation.problem.descriptor=La anotación suprime {0} #loc
inspection.suppression.comment.problem.descriptor=Comentario suprime {0} #loc
jvm.class.filter.choose.calls=Llamadas de registro similares:
jvm.inspection.log.guarded.display.name=Llamadas de registro protegidas por condiciones de registro
jvm.inspection.log.guarded.fix.family.name=Liberar condición protegida de registro
jvm.inspection.log.guarded.problem.descriptor=Llamada de registro protegida por condición de registro #loc
jvm.inspection.log.guarded.warn.if.fix.possible=Solo mostrar un aviso si se puede aplicar una corrección
jvm.inspection.log.statement.not.guarded.all.levels.option=Todos los niveles de registro
jvm.inspection.log.statement.not.guarded.debug.level.and.lower.option=Nivel de depuración y opción más baja
jvm.inspection.log.statement.not.guarded.display.name=Llamada de registro no protegida por condición de registro
jvm.inspection.log.statement.not.guarded.info.level.and.lower.option=Nivel de información y más bajo
jvm.inspection.log.statement.not.guarded.log.fix.family.name=rodear con una condición de registro
jvm.inspection.log.statement.not.guarded.log.problem.descriptor=La llamada de registro no está protegida por una condición de registro
jvm.inspection.log.statement.not.guarded.trace.level.option=Nivel de traza
jvm.inspection.log.statement.not.guarded.unguarded.constant.option=Manejar llamadas de registro sin protección con mensajes constantes
jvm.inspection.log.statement.not.guarded.unguarded.constant.option.comment=Tratar todas las llamadas de registro sin protección, no solo aquellas con argumentos no constantes
jvm.inspection.log.statement.not.guarded.warn.level.and.lower.option=Nivel de advertencia y más bajo
jvm.inspection.log.statement.not.guarded.warn.on.label=Advertencia para:
jvm.inspection.logging.condition.disagrees.with.log.statement.display.name=La condición de registro no coincide con la llamada de registro
jvm.inspection.logging.condition.disagrees.with.log.statement.fix.family.name=Cambiar nivel de registro
jvm.inspection.logging.condition.disagrees.with.log.statement.fix.name=Cambiar el nivel de la {0, choice, 0#condición|1#llamada}
jvm.inspection.logging.condition.disagrees.with.log.statement.problem.descriptor=El nivel de condición ''{0}'' no coincide con el nivel de la llamada de registro ''{1}''
jvm.inspection.logging.placeholder.count.matches.argument.count.display.name=El número de marcadores de posición no coincide con el número de argumentos en la llamada de registro
jvm.inspection.logging.placeholder.count.matches.argument.count.fewer.problem.descriptor=Se han proporcionado menos argumentos ({0}) que los marcadores de posición especificados ({1}) #loc
jvm.inspection.logging.placeholder.count.matches.argument.count.fewer.problem.partial.descriptor=Se proporcionaron menos argumentos ({0}) de los especificados en los marcadores de posición (al menos {1}) #loc
jvm.inspection.logging.placeholder.count.matches.argument.count.incorrect.problem.descriptor=Especificador de cadena de formato ilegal #loc
jvm.inspection.logging.placeholder.count.matches.argument.count.more.problem.descriptor=Se aportaron más argumentos ({0}) que los marcadores de posición especificados ({1}) #loc
jvm.inspection.logging.placeholder.count.matches.argument.count.slf4j.throwable.option=SLF4J utiliza Log4j 2 como implementación
jvm.inspection.logging.placeholder.count.matches.argument.count.slf4j.throwable.option.auto=Auto comprobación
jvm.inspection.logging.placeholder.count.matches.argument.count.slf4j.throwable.option.no=No
jvm.inspection.logging.placeholder.count.matches.argument.count.slf4j.throwable.option.yes=Sí
jvm.inspection.logging.similar.message.display.name=Llamadas de registro no diferenciables
jvm.inspection.logging.similar.message.problem.descriptor=Mensajes de log similares
jvm.inspection.logging.similar.message.problem.min.similar.length=Longitud mínima de una secuencia similar
jvm.inspection.logging.similar.message.problem.skip.on.error=No reportar llamadas con el nivel de registro `error`
jvm.inspection.logging.string.template.as.argument.all.levels.option=todos los niveles de registro
jvm.inspection.logging.string.template.as.argument.debug.level.and.lower.option=nivel de depuración y menor
jvm.inspection.logging.string.template.as.argument.display.name=Cadena de plantilla como argumento a la llamada de registro
jvm.inspection.logging.string.template.as.argument.info.level.and.lower.option=Nivel info y más bajo
jvm.inspection.logging.string.template.as.argument.problem.descriptor=Plantilla de cadena como argumento de la llamada de registro `#ref()` #loc
jvm.inspection.logging.string.template.as.argument.quickfix.name=Reemplazar con marcadores de posición
jvm.inspection.logging.string.template.as.argument.skip.on.only.exception=No advertir cuando la llamada tiene solo una excepción como argumento tras el argumento del mensaje.
jvm.inspection.logging.string.template.as.argument.skip.on.primitives=No avisar cuando solo se incluyan expresiones con tipos primitivos, sus encapsuladores o String
jvm.inspection.logging.string.template.as.argument.trace.level.option=nivel de seguimiento
jvm.inspection.logging.string.template.as.argument.warn.level.and.lower.option=nivel de advertencia e inferior
jvm.inspection.logging.string.template.as.argument.warn.on.label=Avisar sobre:
jvm.inspection.test.failed.line.display.name=Línea de prueba fallida
jvm.inspections.1.5.problem.descriptor=Uso de API documentada como @since {0}+
jvm.inspections.1.7.problem.descriptor=El uso de {0} genérico después de una API 1.6 causaría problemas de compilación con JDK {1}
jvm.inspections.1.8.problem.descriptor=Por defecto {0, choice, 0#|1#método|2#métodos} no sobreescrito. Causará problemas de compilación con JDK {1}
jvm.inspections.1.8.problem.single.descriptor=Método predeterminado ''{0}'' no sobreescrito. Causará problemas de compilación con JDK {1}
jvm.inspections.api.display.name=Usos de API que no está disponible en el nivel de lenguaje configurado
jvm.inspections.api.no.extension.class.description=La clase ''{0}'' no debe ser extendida
jvm.inspections.api.no.extension.display.name=No se deben extender las clases, interfaces o métodos
jvm.inspections.api.no.extension.interface.extend.description=La interfaz ''{0}'' no debe extenderse
jvm.inspections.api.no.extension.interface.implement.description=La interfaz ''{0}'' no puede implementarse
jvm.inspections.api.no.extension.method.overriding.description=No se debe sobreescribir el método ''{0}''
jvm.inspections.api.no.extension.on.invalid.target.class.description={0} ''{1}'' está marcado con ''@ApiStatus.NonExtendable'', pero no se puede extender
jvm.inspections.api.no.extension.on.invalid.target.method.description=El método ''{0}'' está marcado con ''@ApiStatus.NonExtendable'', pero no se puede sobrescribir
jvm.inspections.api.no.extension.on.redundant.target.method.description=La anotación '@ApiStatus.NonExtendable' es redundante
jvm.inspections.api.override.only.description=El método ''{0}'' solo puede ser sobreescrito
jvm.inspections.api.override.only.display.name=El método solo se puede sobreescribir
jvm.inspections.api.override.only.on.invalid.class.description={0} ''{1}'' está marcado con ''@ApiStatus.OverrideOnly'', pero no se puede extender, ni se pueden sobrescribir sus métodos
jvm.inspections.api.override.only.on.invalid.method.description=El método ''{0}'' está marcado con ''@ApiStatus.OverrideOnly'', pero no se puede sobrescribir
jvm.inspections.api.override.only.on.invalid.method.redundant.description=La anotación '@ApiStatus.OverrideOnly' es redundante
jvm.inspections.assertequals.between.inconvertible.types.problem.descriptor=<code>#ref()</code> entre objetos de tipos inconvertibles ''{0}'' y ''{1}'' #loc
jvm.inspections.assertnotequals.between.inconvertible.types.problem.descriptor=Aserción posiblemente redundante: se comparan tipos incompatibles ''{0}'' y ''{1}''
jvm.inspections.assertnotsame.between.inconvertible.types.problem.descriptor=Aserción redundante: se comparan tipos incompatibles ''{0}'' y ''{1}''
jvm.inspections.blocking.method.annotation.blocking=anotaciones de bloqueo:
jvm.inspections.blocking.method.annotation.configure.add.blocking.title=Añadir anotación de bloqueo
jvm.inspections.blocking.method.annotation.configure.add.non-blocking.title=Añadir anotación de no bloqueo
jvm.inspections.blocking.method.annotation.non-blocking=Anotaciones del método no bloqueantes:
jvm.inspections.blocking.method.consider.suspend.context.non.blocking=Considerar contexto de suspensión Kotlin no bloqueante
jvm.inspections.blocking.method.consider.unknown.context.blocking=Tener en cuenta el bloqueo de contextos desconocidos
jvm.inspections.blocking.method.consider.unknown.context.nonblocking=Considerar los contextos desconocidos como no bloqueantes
jvm.inspections.blocking.method.display.name=Llamada posiblemente bloqueante en un contexto no bloqueante
jvm.inspections.blocking.method.in.implicit.ctr.problem.descriptor=Una posible llamada bloqueante desde una llamada implícita a un constructor en un contexto no bloqueante puede provocar inanición de subproceso
jvm.inspections.blocking.method.in.implicit.ctr.problem.wildcard.descriptor=La llamada al método bloqueante desde la llamada al constructor implícito en {0} podría llevar a la inanición del hilo
jvm.inspections.blocking.method.intention.text=Activa la opción de inspección '{0}'.
jvm.inspections.blocking.method.problem.descriptor=Llamada potencialmente bloqueadora en un contexto sin bloqueo podría provocar inanición del subproceso
jvm.inspections.blocking.method.problem.wildcard.descriptor=Llamada probablemente bloqueante en {0} podría provocar falta de subprocesos
jvm.inspections.collection.contains.url.problem.descriptor=''{0}'' puede contener objetos URL #loc
jvm.inspections.dependency.display.name=Dependencias del paquete ilegales
jvm.inspections.dependency.edit.rules.family=Reglas de edición de dependencias
jvm.inspections.dependency.edit.rules.text=Editar la regla de dependencia "{0}"
jvm.inspections.dependency.intention.description=Abre un diálogo para configurar reglas de dependencia entre alcances.
jvm.inspections.dependency.on.internal.display.name=Dependencia ilegal en package interno
jvm.inspections.dependency.violator.problem.descriptor=Se ha infringido la regla de dependencia ''{0}.''
jvm.inspections.equals.hashcode.called.on.url.display.name=Llamada a 'equals()' o 'hashCode()' en el objeto 'URL'
jvm.inspections.equals.hashcode.called.on.url.problem.descriptor=Llamada a ''{0}'' en el objeto URL
jvm.inspections.group.name=Lenguajes JVM
jvm.inspections.logging.frameworks.group.name=Registro
jvm.inspections.missing.deprecated.annotation.on.scheduled.for.removal.api.description=La API prevista para eliminación también debe tener el annotation '@Deprecated'
jvm.inspections.missing.deprecated.annotation.on.scheduled.for.removal.api.display.name=Falta la anotación '@Deprecated' en las API programadas para su eliminación
jvm.inspections.must.already.be.removed.api.current.version.description=La API debe ser eliminada en la versión actual {0}
jvm.inspections.must.already.be.removed.api.display.name=La API debe ya estar eliminada
jvm.inspections.must.already.be.removed.api.earlier.version.description=La API debe haberse eliminado en la versión {0}, pero la versión actual es la {1}
jvm.inspections.scheduled.for.removal.api.is.declared.in.marked.api=''{0}'' se declara en {1} ''{2}'' programado para quitar en {3}
jvm.inspections.scheduled.for.removal.api.is.marked.itself=''{0}'' tiene previsto eliminarse en {1}
jvm.inspections.scheduled.for.removal.future.version=en una versión futura
jvm.inspections.scheduled.for.removal.method.overridden.declared.in.marked.api=Método sobreescrito ''{0}'' se declara en el {1} ''{2}'' marcado para quitar en {3}
jvm.inspections.scheduled.for.removal.method.overridden.marked.itself=El método anulado ''{0}'' está programado para eliminarse en {1}
jvm.inspections.scheduled.for.removal.predefined.version=versión {0}
jvm.inspections.scheduled.for.removal.scheduled.for.removal.type.is.used.in.signature.of.referenced.api=''{0}'' está programado para eliminación porque su firma referencia {1} ''{2}'' programado para eliminación en {3}
jvm.inspections.serializable.class.without.serialversionuid.display.name=Clase serializable sin 'serialVersionUID'
jvm.inspections.serializable.class.without.serialversionuid.problem.descriptor=<code>#ref</code> sin un campo `serialVersionUID` #loc
jvm.inspections.source.to.sink.flow.assigned.unknown=Se asigna una cadena desconocida a una variable segura
jvm.inspections.source.to.sink.flow.assigned.unsafe=Se asigna una cadena no segura a una variable segura
jvm.inspections.source.to.sink.flow.common.unknown=Se utiliza un string desconocido en un contexto seguro
jvm.inspections.source.to.sink.flow.common.unsafe=Se utiliza una cadena no segura en un contexto seguro
jvm.inspections.source.to.sink.flow.display.name=Se pasa una cadena no segura a un método seguro
jvm.inspections.source.to.sink.flow.passed.unknown=Cadena desconocida usada como parámetro seguro
jvm.inspections.source.to.sink.flow.passed.unsafe=Se usa una cadena no segura como parámetro seguro
jvm.inspections.source.to.sink.flow.returned.unknown=Cadena desconocida devuelta desde método seguro
jvm.inspections.source.to.sink.flow.returned.unsafe=Se devuelve una cadena no-segura desde un método seguro
jvm.inspections.source.to.sink.flow.too.complex=Demasiado complejo verificar que la cadena sea segura en un contexto seguro
jvm.inspections.source.unsafe.to.sink.flow.check.private.methods=Considere los parámetros de métodos privados como seguros
jvm.inspections.source.unsafe.to.sink.flow.check.private.methods.comment=Si está activo, los parámetros de los métodos privados se consideran seguros, de lo contrario se considerarán desconocidos
jvm.inspections.source.unsafe.to.sink.flow.check.warn.if.complex=Informar si el caso es demasiado complejo para comprobar
jvm.inspections.source.unsafe.to.sink.flow.check.warn.if.complex.comment=Reportar objetos complejos que no pueden ser comprobados
jvm.inspections.source.unsafe.to.sink.flow.checked.types=Tipos comprobados:
jvm.inspections.source.unsafe.to.sink.flow.config=Se agregará la anotación Untainted a la configuración de inspección para el elemento ''{0}''
jvm.inspections.source.unsafe.to.sink.flow.depth.inside=Profundidad del análisis dentro del método:
jvm.inspections.source.unsafe.to.sink.flow.impossible=La anotación Untainted no es compatible con el elemento {0}. El elemento se omitirá
jvm.inspections.source.unsafe.to.sink.flow.index.parameter=Índice del parámetro
jvm.inspections.source.unsafe.to.sink.flow.mark.as.safe.command.name=Marcar como que requiere validación
jvm.inspections.source.unsafe.to.sink.flow.mark.as.safe.family=Marcar como requiere validación
jvm.inspections.source.unsafe.to.sink.flow.mark.as.safe.text=Marcar elementos como que requieren validación
jvm.inspections.source.unsafe.to.sink.flow.not.number=No es un número
jvm.inspections.source.unsafe.to.sink.flow.place.class.column.title=Nombre de clase de contexto
jvm.inspections.source.unsafe.to.sink.flow.place.method.column.title=Expresión regular del nombre de método en contexto
jvm.inspections.source.unsafe.to.sink.flow.preview=**@Untainted**
jvm.inspections.source.unsafe.to.sink.flow.preview.propagate=Mostrar árbol de propagación
jvm.inspections.source.unsafe.to.sink.flow.propagate.safe.family=Árbol de propagación
jvm.inspections.source.unsafe.to.sink.flow.propagate.safe.preview=Abre una ventana de herramientas para verificar la propagación de la anotación segura
jvm.inspections.source.unsafe.to.sink.flow.propagate.safe.text=Mostrar árbol de propagación desde aquí
jvm.inspections.source.unsafe.to.sink.flow.propagate.safe.toolwindow.annotate=Anotar todos salvo los excluidos
jvm.inspections.source.unsafe.to.sink.flow.propagate.safe.toolwindow.title=Miembros no seguros
jvm.inspections.source.unsafe.to.sink.flow.propagate.safe.toolwindow.unsafe.flow=Flujo no seguro
jvm.inspections.source.unsafe.to.sink.flow.qualifier.cleaner.arguments=Argumentos
jvm.inspections.source.unsafe.to.sink.flow.qualifier.cleaner.classes=Clases
jvm.inspections.source.unsafe.to.sink.flow.qualifier.cleaner.comment=Estos métodos marcan calificadores como 'no contaminados'. (Los argumentos deben estar separados con comas)
jvm.inspections.source.unsafe.to.sink.flow.qualifier.cleaner.methods=Métodos
jvm.inspections.source.unsafe.to.sink.flow.qualifier.cleaner.table=Métodos para limpiar calificadores:
jvm.inspections.source.unsafe.to.sink.flow.safe.class=Clases seguras:
jvm.inspections.source.unsafe.to.sink.flow.safe.class.comment=Estas clases no pueden contener datos no seguros
jvm.inspections.source.unsafe.to.sink.flow.show.unknown.object=Mostrar objeto desconocido
jvm.inspections.source.unsafe.to.sink.flow.show.unsafe.object=Reportar objeto inseguro
jvm.inspections.source.unsafe.to.sink.flow.tainted.annotations=Anotaciones contaminadas:
jvm.inspections.source.unsafe.to.sink.flow.tainted.annotations.comment=Estas anotaciones se usarán como anotaciones '@Tainted' durante el análisis
jvm.inspections.source.unsafe.to.sink.flow.tainted.methods=Métodos teñidos:
jvm.inspections.source.unsafe.to.sink.flow.tainted.methods.comment=Estos métodos se consideran que sólo devuelven objetos no seguros
jvm.inspections.source.unsafe.to.sink.flow.tainted.parameters=Parámetros contaminados:
jvm.inspections.source.unsafe.to.sink.flow.tainted.parameters.comment=Estos parámetros se consideran que tienen anotación '@Tainted'
jvm.inspections.source.unsafe.to.sink.flow.untainted.annotations=Anotaciones no contaminadas:
jvm.inspections.source.unsafe.to.sink.flow.untainted.annotations.comment=Estas anotaciones se usarán como anotaciones '@Uncontaminated' durante el análisis. La primera anotación de esta lista se usará para la propagación si existe en la classpath.
jvm.inspections.source.unsafe.to.sink.flow.untainted.fields=Campos no contaminados:
jvm.inspections.source.unsafe.to.sink.flow.untainted.fields.comment=Se considera que estos campos contienen solo objetos seguros
jvm.inspections.source.unsafe.to.sink.flow.untainted.fields.name=Nombre de campo
jvm.inspections.source.unsafe.to.sink.flow.untainted.methods=Métodos no contaminados:
jvm.inspections.source.unsafe.to.sink.flow.untainted.methods.comment=Se considera que estos métodos devuelven solo objetos seguros
jvm.inspections.source.unsafe.to.sink.flow.untainted.parameters=Parámetros no contaminados:
jvm.inspections.source.unsafe.to.sink.flow.untainted.parameters.comment=Estos parámetros se consideran que tienen anotación '@Untainted'
jvm.inspections.source.unsafe.to.sink.flow.untainted.process.as.qualifier.arguments=Ten en cuenta que los métodos externos no están contaminados si los receptores y argumentos no lo están
jvm.inspections.source.unsafe.to.sink.flow.untainted.process.as.qualifier.arguments.comment=Si está habilitado, los métodos externos fuera de la clase actual se considerarán seguros si su receptor y sus argumentos son seguros. En algunos casos, no es aplicable, pero puede ser útil para clases sin estado. De lo contrario, todos los métodos externos se considerarán no seguros
jvm.inspections.string.touppercase.tolowercase.without.locale.description=<code>String.{0}()</code> llamado sin especificar una Configuración Regional usando cadenas internacionalizadas #loc
jvm.inspections.system.get.property.display.name=La llamada a 'System.getProperty(str)' se puede simplificar
jvm.inspections.system.get.property.problem.descriptor=La llamada <code>#ref</code> se puede simplificar para ''{0}''
jvm.inspections.test.case.in.product.source.display.name=Probar en el código fuente del producto
jvm.inspections.test.case.in.product.source.problem.descriptor=Posiblemente, pruebas de caso <code>#ref</code> deberían estar en un repositorio fuente de pruebas #loc
jvm.inspections.test.case.with.constructor.display.name=TestCase con constructores no triviales
jvm.inspections.test.case.with.constructor.problem.descriptor=La lógica de inicialización en el constructor <code>#ref()</code> en lugar del método del ciclo de vida 'setup()' #loc
jvm.inspections.test.case.with.constructor.problem.descriptor.initializer=Lógica de inicialización en el inicializador en lugar del método de ciclo de vida 'setup()'
jvm.inspections.test.case.without.test.methods.display.name=Clase de prueba sin pruebas
jvm.inspections.test.case.without.test.methods.option=Ignorar casos de prueba que tienen superclases con métodos de prueba
jvm.inspections.test.case.without.test.methods.problem.descriptor=La clase de prueba <code>#ref</code> no tiene pruebas #loc
jvm.inspections.test.frameworks.group.name=Marcos de prueba
jvm.inspections.test.method.in.product.source.problem.descriptor=El método de prueba <code>#ref()</code> probablemente debería estar en un árbol de origen de prueba #loc
jvm.inspections.test.method.without.assertion.display.name=Método de prueba sin aserciones
jvm.inspections.test.method.without.assertion.problem.descriptor=El método de prueba <code>#ref()</code> no contiene aserciones #loc
jvm.inspections.testonly.class.reference=Clase únicamente de prueba referenciada en código de producción
jvm.inspections.testonly.display.name=Uso exclusivo de pruebas en código de producción
jvm.inspections.testonly.field.reference=Campo exclusivo de pruebas referenciado en código de producción
jvm.inspections.testonly.method.call=Se llamó al método únicamente de prueba en un código de producción
jvm.inspections.testonly.visiblefortesting=@VisibleForTesting tiene poco sentido en el código @TestOnly
jvm.inspections.thread.run.display.name=Llamada a 'Thread.run()'
jvm.inspections.unstable.api.usage.annotations.list=Anotaciones de API inestables:
jvm.inspections.unstable.api.usage.api.is.declared.in.unstable.api=''{0}'' está declarado en la API inestable ''{1}'' ''{2}'' marcada con @{3}
jvm.inspections.unstable.api.usage.api.is.marked.unstable.itself=''{0}'' está marcado como inestable con @{1}
jvm.inspections.unstable.api.usage.display.name=Uso de API inestable
jvm.inspections.unstable.api.usage.ignore.declared.inside.this.project=Ignorar API declarada en este proyecto
jvm.inspections.unstable.api.usage.ignore.inside.imports=Ignorar dentro de las importaciones
jvm.inspections.unstable.api.usage.overridden.method.is.declared.in.unstable.api=El método anulado ''{0}'' se declara en la API inestable {1} ''{2}'' marcada con @{3}
jvm.inspections.unstable.api.usage.overridden.method.is.marked.unstable.itself=Método reemplazado ''{0}'' se marca como inestable con @{1}
jvm.inspections.unstable.api.usage.unstable.type.is.used.in.signature.of.referenced.api=''{0}'' es inestable porque su firma referencia un {1} inestable ''{2}'' marcado con @{3}
jvm.inspections.unstable.type.used.in.class.signature.description=La clase debe marcarse con la anotación ''@{0}'' porque su declaración referencia el tipo inestable ''{1}''
jvm.inspections.unstable.type.used.in.field.signature.description=El campo debe estar marcado con la anotación ''@{0}'' porque su tipo hace referencia al tipo inestable ''{1}''
jvm.inspections.unstable.type.used.in.method.signature.description=El método debe marcarse con la anotación ''@{0}'' porque su firma hace referencia al tipo inestable ''{1}''
jvm.inspections.unstable.type.used.in.signature.display.name=Se utiliza un tipo inestable en la firma
jvm.inspections.usages.of.obsolete.api.description=Se utiliza una API obsoleta
jvm.inspections.usages.of.obsolete.api.display.name=Usos de ApiStatus.@Obsolete
jvm.options.general.color.descriptor.logging.string.placeholder=Cadena de registro//Marcador de posición
propagated.from=Motivo de Propagación:
propagated.to=Objetivo de Propagación:
remove.suppress.comment.fix.family.name=Eliminar //{0}
title.uast=UAST