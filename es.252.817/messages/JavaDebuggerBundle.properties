action.AnActionButton.description.disable.selected=Deshabilitar Seleccionados
action.AnActionButton.description.duplicate=Duplicar
action.AnActionButton.description.enable.selected=Habilitar Seleccionados
action.AnActionButton.description.export=Exportar
action.AnActionButton.description.import=Importar
action.AnActionButton.text.disable.selected=Deshabilitar Seleccionados
action.AnActionButton.text.duplicate=Duplicar
action.AnActionButton.text.enable.selected=Habilitar Seleccionados
action.AnActionButton.text.export=Exportar
action.AnActionButton.text.import=Importar
action.add.field.watchpoint.text=Agregar puntos de inspección de Campo
action.auto.variables.mode=Mostrar Solo Variables Cerca del Punto de Ejecución
action.auto.variables.mode.description=Mostrar solo variables utilizadas cerca del punto de ejecución
action.calculate.retained.size.info=Los objetos retenidos de ''{0}'' están resaltados
action.calculate.retained.size.text=El tamaño retenido de ''{0}'' es {1}, el tamaño superficial es {2}
action.calculate.retained.size.title=Tamaño Retenido de ''{0}''
action.calculate.retained.size.waiting.message=Calculando tamaño retenido…
action.do.not.stop.if.called.from.text=No detener si es llamado desde\: {0}
action.do.not.stop.in.class.text=No detener en la clase\: {0}
action.failed=La acción falló
action.hide.text=Ocultar
action.interrupt.thread.text=Interrumpir
action.resume.thread.text.resume=Reanudar
action.show.objects.text=Mostrar {0} Objetos…
action.stop.only.if.called.from.text=Detener solo si es llamado desde\: {0}
action.stop.only.in.class.text=Detener solo en la clase\: {0}
action.stop.only.in.current.object.text=Detener solo en el objeto actual
action.watch.method.return.value.description=Habilita la observación del valor de retorno del último método ejecutado
action.watches.method.return.value.enable=Mostrar Valores de Retorno de Métodos
action.watches.method.return.value.unavailable.reason=Función no soportada por la VM objetivo
add.exception.breakpoint.classchooser.title=Ingresar Clase de Excepción
add.field.breakpoint.dialog.classchooser.title=Elegir Clase del Campo
add.field.breakpoint.dialog.field.chooser.title={0,choice, 0\#La Clase No Tiene Campos|1\#Seleccionar Campo}
add.field.breakpoint.dialog.title=Agregar punto de inspección de Campo
add.instance.filter.dialog.error.numeric.value.expected=El ID de instancia debe ser un valor numérico de tipo 'long'
add.instance.filter.dialog.prompt=Ingrese ID de instancia\:
add.instance.filter.dialog.title=Agregar Filtro de Instancia
add.method.breakpoint=Agregar Breakpoint de Método
add.stepping.filter=Agregar Filtro de Step
array.filter.node.clear.link=\ limpiar
async.stacktraces.configurable.display.name=Stack Traces Asíncronos
breakpoint.any.exception.display.name=Cualquier excepción
breakpoint.properties.panel.option.caller.filter=Filtros de invocado&r\:
breakpoint.properties.panel.option.catch.class.filters=Filtros de clase catch\:
breakpoint.properties.panel.option.class.filters=Filtros de c&lase\:
breakpoint.properties.panel.option.instance.filters=Filtros de &instancia\:
breakpoint.properties.panel.option.pass.count=Contador de &pases\:
breakpoint.property.name.class.filters=Filtros de clase\:
breakpoint.property.name.instance.filters=Filtros de instancia\:
breakpoint.property.name.pass.count=Contador de pases\:
breakpoint.variant.text.line=Línea
breakpoint.variant.text.line.and.lambda=Línea y {0,choice,1\#Lambda|2\#Lambdas}
breakpoint.variant.text.line.and.lambda.uknown.count=Línea y Lambda(s)
button.add=Agregar
button.copy=Copiar
button.debugger.settings=Configuración del Debugger…
button.drop.anyway=No Ejecutar
button.execute.finally=Ejecutar Bloques Finally
button.perform.reload.classes=&Recargar Clases
button.skip.reload.classes=&Omitir Recarga de Clases
call.tracer=Trazador de Llamadas
caller.filters.dialog.title=Filtros de Invocador
cancel.emulation=Cancelar emulación
capture.node.settings.link=\ configuración
checkbox.start.tracing=iniciar
checkbox.stop.tracing=detener
checkbox.tracing=Tracing
checkbox.tracking.filters=filtros
class.filters.dialog.exclusion.filters.group=Excluir
class.filters.dialog.inclusion.filters.group=Incluir
class.filters.dialog.title=Filtros de Clase
class.pattern.not.specified=Patrón de clase no especificado
collection.history=Historial de colección
collection.history.tab.title=Historial de {0}
collection.watchpoint.description=Watchpoint de colección
collection.watchpoints.tab.title=Watchpoints de Colección Java
column.name.hits=Hits
column.name.instances=Instancias
column.name.retained.size=Tamaño Retenido
column.name.shallow.size=Tamaño Superficial
column.name.time.ms=Tiempo (ms)
command.name.surround.with.runtime.cast=Envolver Con Cast en Runtime
condition=Condición\:
debugger.actions.group.title=Acciones del Debugger
debugger.attach.group.name.java=Java
debugger.attach.group.name.java.read.only=Java Solo Lectura
debugger.attach.password.for.sudo=Ingrese su contraseña para conectar con privilegios su\: 
debugger.collection.visualizer.title=Presentación de Colección
debugger.collection.visualizer.title.0=Presentación de Colección\: {0}
debugger.data.views.configurable.show.title=Mostrar
debugger.jdi.bootstrap.error={0}. Verifique su instalación de JDK.
debugger.memory.agent.loading.error=No se pudo cargar el agente de memoria en la VM
debugger.memory.agent.timeout.error=Tiempo de cálculo agotado (el heap es demasiado grande y el agente de memoria no puede ejecutar esta operación en un tiempo razonable, es preferible capturar el heap dump)
default.package.name=<Default>
dialog.title.exception.to.throw=Excepción a Lanzar
dialog.title.return.value=Valor de Retorno
drop.frame.error.no.information=La información sobre el frame no está disponible
editor.notification.alternative.source=Fuente alternativa disponible para la clase {0}
enable.tracking.for.new.instances=Habilitar seguimiento para nuevas instancias
error.absent.exception.breakpoint.class.name=No hay nombre de clase para el breakpoint de excepción
error.array.renderer.configurable.end.index.less.than.start=El índice final es menor que el índice inicial
error.array.renderer.configurable.start.index.less.than.zero=El índice inicial es menor que 0
error.breakpoint.file.not.found=Archivo ''{0}'' no encontrado; los breakpoints para este archivo serán ignorados
error.cannot.create.expression.from.code.fragment=No se puede crear expresión desde fragmento de código.
error.cannot.load.breakpoint.file=No se puede cargar el archivo ''{0}''; los breakpoints para este archivo serán ignorados
error.cannot.open.debugger.port=No se puede abrir el puerto del debugger
error.class.circularity.error=Error de circularidad de clase\: {0}
error.class.def.not.found=Definición de clase no encontrada\: {0}
error.class.format.error=Error de formato de clase\: {0}
error.class.not.loaded=Clase no cargada\: {0}
error.compound.renderer.configurable.fqn.generic=No se permite el tipo genérico
error.context.has.changed=El contexto ha cambiado, la operación no es posible
error.context.not.available=El contexto no está disponible
error.corrupt.debug.info=La información de debug podría estar corrupta\: {0}
error.debug.connector.not.found=No se encontró el conector requerido ''{0}''. Verifique su instalación de JDK.
error.debugger.already.listening=El debugger ya está escuchando
error.early.return=Error al realizar retorno anticipado\: {0}
error.evaluating.breakpoint.condition.or.action=Problema al procesar evento de VM\:\nBreakpoint\: ''{0}''\nError\: {1}\n¿Desea detenerse en el breakpoint?
error.exception.while.connecting=Error al conectar con el proceso remoto.\nOcurrió una excepción\: {0}\nMensaje de excepción\: {1}
error.exception.while.reloading=Excepción al recargar clases\: {0}\: {1}
error.executing.finally=Error al ejecutar bloques finally\: {0}
error.failed.evaluating.breakpoint.condition=Fallo al evaluar la condición del punto de interrución\n''{0}''\nRazón\: {1}
error.field.breakpoint.class.name.not.specified=No se puede añadir punto de inspección\: no se especificó nombre de clase
error.field.breakpoint.class.sources.not.found=No se puede crear un punto de inspección de campo para ''{0}.{1}''.\nNo hay fuentes para la clase ''{2}''
error.field.breakpoint.field.name.not.specified=No se puede añadir punto de inspección\: no se especificó nombre de campo
error.field.breakpoint.field.not.found=No se puede crear un punto de inspección de campo para ''{0}.{1}''.\nCampo ''{2}'' no encontrado
error.field.not.found.in.class=No existe el campo {0} en {1}
error.inconsistent.debug.info=Información de debug inconsistente
error.internal=Error interno
error.invalid.argument={0,choice, 1\#Argumento inválido|2\#Argumentos inválidos}
error.invalid.breakpoint.method.not.found=Método no encontrado en la clase {0}
error.invalid.breakpoint.missing.field.in.class=No se puede encontrar el campo ''{0}'' en la clase ''{1}''
error.invalid.breakpoint.no.executable.code=No se encontró código ejecutable en la línea {0} de la clase {1}
error.invalid.breakpoint.no.line.info=La información de números de línea no está disponible en la clase {0}
error.invalid.breakpoint.source.changed=El archivo fuente ha cambiado o el archivo fuente encontrado no corresponde al archivo del breakpoint
error.invalid.breakpoint.source.not.found=La clase {0}, encontrada en el classpath del proyecto, no tiene archivos fuente asociados
error.invalid.field.name=Nombre de campo inválido ''{0}''
error.invalid.local.variable.name=Nombre de variable local inválido ''{0}''
error.invalid.stackframe=Excepción interna - stackframe inválido
error.invalid.type.name=Nombre de tipo inválido ''{0}''
error.io.error=Error de I/O
error.jdk.not.specified=JDK no especificado
error.native.method.exception=Ninguno de los frames hasta e incluyendo el frame pueden ser nativos
error.no.debug.attach.port=Puerto de conexión no especificado
error.no.debug.listen.port=Puerto de escucha no especificado
error.no.debug.process=No hay proceso de debug
error.no.pid=Pid no especificado
error.no.shmem.address=Dirección de memoria compartida no especificada
error.operation.canceled=Operación cancelada
error.operation.not.supported.by.vm=Operación no soportada por la VM\: {0}
error.pop.bottom.stackframe=No se puede hacer pop del frame inferior
error.pop.stackframe=Ocurrió un error al hacer pop del frame de pila\: {0}
error.running.to.cursor.no.executable.code=No hay código ejecutable en {0}\:{1}
error.text.invalid.port=Puerto no especificado
error.throw.exception=Error al lanzar excepción\: {0}
error.unable.to.create.sapidattachingconnector=No se puede crear SAPIDAttachingConnector
error.unable.to.evaluate.capture.expression=No se puede evaluar la expresión de clave de captura\: {0}
error.unable.to.evaluate.children.expression=No se puede evaluar la expresión del renderer hijo
error.unable.to.evaluate.expression=No se puede evaluar la expresión
error.unable.to.evaluate.insert.expression=No se puede evaluar la expresión de clave de inserción\: {0}
error.unknown.host=No se puede conectar al proceso remoto. Host desconocido
error.unknown.host.with.address=No se puede conectar al proceso remoto. Host desconocido ({0})
error.unsupported.class.version=Versión de clase no soportada\: {0}
error.verification.error=Error de verificación\: {0}
error.vm.disconnected=VM desconectada. La máquina virtual destino cerró la conexión
evaluation.error.anonymous.class.evaluation.not.supported=No se admite la evaluación de clases anónimas
evaluation.error.array.collected=El array ha sido recolectado
evaluation.error.array.dimention.numeric.value.expected=Se esperaba un valor numérico como dimensión del array
evaluation.error.array.reference.expected=Se esperaba referencia de array
evaluation.error.array.type.expected=Se esperaba tipo array
evaluation.error.boolean.condition.expected=Se esperaba un valor 'boolean' en la condición
evaluation.error.boolean.expected=Se esperaba valor boolean
evaluation.error.boolean.value.expected.in.condition=Se esperaba un valor 'boolean' en la condición
evaluation.error.cannot.cast.boolean=No se puede convertir valor boolean a ''{0}''
evaluation.error.cannot.cast.char=No se puede convertir valor char a ''{0}''
evaluation.error.cannot.cast.null=No se puede convertir null a ''{0}''
evaluation.error.cannot.cast.numeric=No se puede convertir valor numérico a ''{0}''
evaluation.error.cannot.cast.object=No se puede convertir ''{0}'' a ''{1}''
evaluation.error.cannot.evaluate.array.initializer=No se puede evaluar el inicializador del array
evaluation.error.cannot.evaluate.class.type=No se puede evaluar el tipo de clase
evaluation.error.cannot.evaluate.qualifier=No se puede evaluar el calificador ''{0}''
evaluation.error.cannot.evaluate.tostring=No se puede evaluar {0}.toString()
evaluation.error.cannot.find.source=No se puede encontrar la clase fuente para {0}
evaluation.error.cannot.find.stackframe.source=No se puede encontrar la clase fuente para el frame de pila actual
evaluation.error.cannot.initialize.array=No se puede inicializar el array
evaluation.error.cannot.resolve.constructor=No se puede resolver el constructor ''{0}''
evaluation.error.cannot.resolve.field.class=No se puede resolver la clase que contiene el campo ''{0}''
evaluation.error.cannot.set.primitive.to.null=No se puede establecer un tipo primitivo a null
evaluation.error.cannot.sources.for.field.class=No se pueden encontrar las fuentes para la clase que contiene el campo ''{0}''
evaluation.error.class.not.loaded=La clase ''{0}'' no está cargada
evaluation.error.class.or.array.expected=Se esperaba clase o tipo array al evaluar el campo ''{0}''
evaluation.error.debug.info.unavailable=Información de debug no disponible
evaluation.error.during.indexing=La evaluación no es posible durante la indexación
evaluation.error.empty.code.fragment=Se esperaba un fragmento de código
evaluation.error.evaluating.field=Error al evaluar el campo\: ''{0}''
evaluation.error.evaluating.method=Error al evaluar el método\: ''{0}''
evaluation.error.identifier.expected=Se esperaba un identificador en lugar de ''{0}''
evaluation.error.incompatible.array.initializer.type=El tipo del inicializador no es compatible con el tipo de componente del array
evaluation.error.incompatible.types=Tipos incompatibles para la operación ''{0}''
evaluation.error.incompatible.variable.initializer.type=El inicializador para ''{0}'' tiene un tipo incompatible
evaluation.error.inconsistent.debug.info=La información de depuración es inconsistente
evaluation.error.integer.expected=Se esperaba un valor entero
evaluation.error.invalid.array.dimension.expression=Expresión inválida para dimensión de array\: {0}
evaluation.error.invalid.array.size=Tamaño de array inválido
evaluation.error.invalid.expression=Expresión inválida\: {0}
evaluation.error.invalid.index.expression=Expresión de índice inválida
evaluation.error.invalid.this.expression=No se puede sustituir ''{0}'' en ''{1}'' como ''this''
evaluation.error.invalid.type.name=Nombre de tipo inválido\: ''{0}''
evaluation.error.lambda.evaluation.not.supported=La evaluación de lambdas no está soportada
evaluation.error.lebeled.loops.not.found=No hay sentencias de bucle etiquetadas con ''{0}''
evaluation.error.local.variable.declarations.not.supported=Las declaraciones de variables locales no están soportadas aquí.
evaluation.error.local.variable.missing=No se encuentra la variable local ''{0}''
evaluation.error.local.variable.missing.from.class.closure=Variable local ''{0}'' no encontrada en el closure de la clase
evaluation.error.method.exception=El método lanzó la excepción ''{0}''.
evaluation.error.method.reference.evaluation.not.supported=La evaluación de referencias a métodos no está soportada
evaluation.error.multi.dimensional.arrays.creation.not.supported=La creación de arrays multidimensionales no está soportada
evaluation.error.nested.evaluation=La evaluación no está soportada durante la evaluación de otro método
evaluation.error.no.instance.field=No existe tal campo de instancia\: ''{0}''
evaluation.error.no.instance.method=No existe tal método de instancia\: ''{0}''
evaluation.error.no.stackframe=No se puede evaluar\: frame de pila no disponible
evaluation.error.no.static.field=No existe tal campo static\: ''{0}''
evaluation.error.no.static.method=No existe tal método static\: ''{0}''
evaluation.error.not.lvalue=La parte izquierda de la asignación no es un valor
evaluation.error.not.rvalue=La parte derecha de la asignación no es un valor
evaluation.error.numeric.expected=Se esperaba un valor numérico
evaluation.error.object.collected=El objeto ha sido recolectado
evaluation.error.object.is.being.initialized=El objeto está siendo inicializado
evaluation.error.object.reference.expected=Se esperaba una referencia a objeto
evaluation.error.operation.not.supported=La operación ''{0}'' no está soportada
evaluation.error.process.exited=No se puede evaluar\: el proceso ha terminado
evaluation.error.signature.polymorphic.call.evaluation.not.supported=La evaluación de llamadas polimórficas de firma no está soportada
evaluation.error.sources.out.of.sync=El código fuente no corresponde al código en ejecución
evaluation.error.stack.frame.unavailable=Frame de pila no disponible
evaluation.error.statement.not.supported=La sentencia ''{0}'' no está soportada
evaluation.error.surrounded.expression.null=La expresión envolvente es null
evaluation.error.this.not.avalilable='this' no está disponible
evaluation.error.thread.collected=El thread ha sido recolectado
evaluation.error.thread.not.at.breakpoint=No se pueden evaluar métodos después de la acción Pausar
evaluation.error.thread.resumed=El thread ha sido reanudado
evaluation.error.type.mismatch=Los tipos no coinciden
evaluation.error.unknown.expression.operand=Operando de expresión desconocido\: {0}
evaluation.error.unknown.expression.type=Tipo de expresión desconocido\: {0}
evaluation.error.unknown.method.return.type=No se puede resolver el tipo de retorno del método\: {0}
evaluation.error.unknown.type=No se puede resolver el tipo\: {0}
evaluation.error.unsupported.declaration=Declaración inválida\: {0} Solo se soportan declaraciones de variables locales.
evaluation.error.unsupported.expression.type=Tipo de expresión no soportado
evaluation.error.variable.already.declared=La variable ''{0}'' ya está declarada
evaluation.error.variable.not.declared=La variable ''{0}'' no está declarada
exception.breakpoint.console.message=Excepción ''{0}'' ocurrió en {1}({2})
exception.breakpoint.console.message.location.info={0}\:{1,number,\#}
exception.breakpoint.console.message.location.info.absent=Sin Información de Depuración
exception.breakpoint.console.message.with.thread.info=Excepción ''{0}'' ocurrió en el thread ''{1}'' en {2}({3})
exception.breakpoint.description=Breakpoint de excepción
exception.breakpoints.tab.title=Breakpoints de Excepción Java
export.failed=Exportación Fallida
export.selected.capture.points.to.file=Exportar Puntos de Captura Seleccionados a Archivo…
field.watchpoint.description=Watchpoint de campo
field.watchpoint.property.name.access=Observar acceso\:
field.watchpoint.property.name.modification=Observar modificación\:
field.watchpoints.tab.title=Watchpoints de Campo Java
filters=Filtros…
filters.not.configured=No hay filtros configurados
frame.panel.async.stacktrace=Stack trace asíncrono
frame.panel.frames.not.available=Frames no disponibles para thread no suspendido
frame.panel.thread.finished=El thread ha terminado su ejecución
hotswap.dialog.hang.warning=La JVM está actualmente suspendida.\nRecargar clases con agentes JVM de terceros activos puede causar que la JVM se bloquee.
hotswap.dialog.reload.action.text=Recargar
hotswap.dialog.run.prompt=Algunas clases han sido modificadas. ¿Recargar las clases modificadas ahora?
hotswap.dialog.title=Recargar Clases Modificadas
hotswap.dialog.title.with.session=Recargar Clases Modificadas para {0}
if.the.value.is.referenced.by.a.constant.field=Si el valor es referenciado por un campo constante de una clase abstracta,\nIDEA podría adicionalmente marcar todos los valores referenciados desde esta clase con los nombres de los campos que los referencian.
import.capture.points=Importar Puntos de Captura
instance.filters.dialog.title=Filtros de Instancia
instances.window.show.history=InstancesWindow.ShowHistory
internal.debugger.error=Error interno. Ver logs para más detalles
internal.error.locations.of.line=Error interno al cargar información de depuración desde ''{0}''. Los breakpoints no estarán disponibles en esta clase.
invoke.completion.once.more=Invocar completado una vez más para ver variantes de tipo en tiempo de ejecución
label.add.field.breakpoint.dialog.field.name=Nombre del campo\:
label.add.field.breakpoint.dialog.fq.name=Nombre completamente calificado de la clase\:
label.add.wildcard.breakpoint.dialog.class.pattern=Patrón de clase (&C)\:
label.add.wildcard.breakpoint.dialog.method.name=Nombre del método (&M)\:
label.array.renderer.configurable.end.index=Índice final (&D)\:
label.array.renderer.configurable.max.count1=Mostrar máximo (&M)
label.array.renderer.configurable.max.count2=elementos del array
label.array.renderer.configurable.start.index=Índice de inicio del array (&R)\:
label.arrays.could.not.be.tracked=Los arrays no pueden ser rastreados
label.base.renderer.configurable.all.overriding=Para todas las clases que sobreescriben el método 'toString()'
label.base.renderer.configurable.alternate.view=Habilitar vista alternativa para clases Collections (&E)
label.base.renderer.configurable.autoscroll=Desplazamiento automático a nuevas variables locales (&L)
label.base.renderer.configurable.classes.from.list=Para clases de la lista\:
label.base.renderer.configurable.dfa.assist=Predecir valores de condición y excepciones basados en análisis de flujo de datos
label.base.renderer.configurable.dfa.assist.gray.out=Atenuar bloques de código que se predicen como inalcanzables
label.base.renderer.configurable.enable.toString=Habilitar vista de objeto 'toString()' (&O)\:
label.base.renderer.configurable.hide.null.array.elements=Ocultar elementos null en arrays y colecciones (&N)
label.base.renderer.configurable.populate.throwable.stack=Autocompletar stack trace de objetos Throwable
label.base.renderer.configurable.show.declared.type=Tipo declarado (&T)
label.base.renderer.configurable.show.fq.names=Nombres completamente calificados (&Q)
label.base.renderer.configurable.show.hex.value=Mostrar valor hexadecimal para primitivos
label.base.renderer.configurable.show.object.id=ID de objeto (&I)
label.base.renderer.configurable.show.static.fields=Campos static (&S)
label.base.renderer.configurable.show.static.final.fields=Campos static final(&F)
label.base.renderer.configurable.show.strings.type=Mostrar tipo para strings
label.base.renderer.configurable.show.synthetic.fields=Campos sintéticos (&Y)
label.base.renderer.configurable.show.val.fields.as.locals=Campos $val como variables locales(&V)
label.capture.configurable.annotations.configure=Configurar Anotaciones…
label.capture.configurable.capture.variables=Capturar variables locales (puede ralentizar significativamente la ejecución)
label.capture.configurable.debugger.agent=Agente de instrumentación (requiere reiniciar el debugger)
label.capture.point.at=Punto de captura en {0}.{1}
label.collection.breakpoint.properties.save.history=Guardar historial de colección
label.compound.renderer.configurable.append.default.children=Agregar hijos predeterminados
label.compound.renderer.configurable.apply.to=Aplicar renderer a objetos del tipo (nombre completo)\:
label.compound.renderer.configurable.ondemand=Bajo demanda
label.compound.renderer.configurable.show.type=Mostrar tipo e id del objeto
label.compound.renderer.configurable.table.header.expression=Expresión
label.compound.renderer.configurable.table.header.name=Nombre
label.compound.renderer.configurable.table.header.ondemand=Bajo demanda
label.compound.renderer.configurable.test.can.expand=Probar si un nodo puede expandirse (opcional)\:
label.compound.renderer.configurable.use.default.renderer=Usar renderer predeterminado
label.compound.renderer.configurable.use.expression=Usar la siguiente expresión\:
label.compound.renderer.configurable.use.expression.list=Usar lista de expresiones\:
label.compound.renderer.configurable.when.expanding=Al expandir un nodo
label.compound.renderer.configurable.when.rendering=Al renderizar un nodo
label.debugger.general.configurable.always.debug=Iniciar configuraciones de ejecución con el agente de depuración
label.debugger.general.configurable.always.smart.step.into=Siempre hacer step into inteligente(&L)
label.debugger.general.configurable.enable.memory.agent=Adjuntar agente de memoria
label.debugger.general.configurable.enable.memory.agent.tooltip.text=El debugger de Java proporcionará información adicional sobre objetos en el heap
label.debugger.general.configurable.evaluate.finally.always=Siempre(&A)
label.debugger.general.configurable.evaluate.finally.ask=Preguntar(&K)
label.debugger.general.configurable.evaluate.finally.never=Nunca(&E)
label.debugger.general.configurable.evaluate.finally.on.pop=Evaluar bloques finally en pop frame y retorno anticipado\:
label.debugger.general.configurable.hide.stack.frames.using.step.filter=Ocultar frames de stack usando filtros de stepping(&F)
label.debugger.general.configurable.kill.immediately=Terminar el proceso de depuración inmediatamente
label.debugger.general.configurable.resume.only.current.thread=Reanudar solo el thread actual
label.debugger.general.configurable.show.alternative.source=Mostrar selector de fuente alternativa
label.debugger.general.configurable.skip.classLoaders=Saltar class loaders (&O)
label.debugger.general.configurable.skip.constructors=Saltar constructores (&C)
label.debugger.general.configurable.skip.simple.getters=Saltar getters simples (&G)
label.debugger.general.configurable.skip.synthetic.methods=Saltar métodos sintéticos (&P)
label.debugger.general.configurable.step.filters.list.header=No hacer step into en las clases (&I)
label.debugger.hotswap.configurable.always=Siempre(&A)
label.debugger.hotswap.configurable.ask=Preguntar (&K)
label.debugger.hotswap.configurable.compile.before.hotswap=Compilar proyecto antes de recargar clases
label.debugger.hotswap.configurable.enable.vm.hang.warning=Habilitar advertencia 'JVM se bloqueará'
label.debugger.hotswap.configurable.never=Nunca (&N)
label.debugger.hotswap.configurable.reload.classes=Recargar clases después de la compilación\:
label.debugger.hotswap.configurable.suggest.in.editor=Sugerir HotSwap en el editor cuando se modifique el código
label.debugger.hotswap.option.suggest.in.editor=Sugerir HotSwap en el Editor
label.debugger.launching.configurable.debugger.transport=Transporte\:
label.debugger.launching.configurable.shmem=Memoria compartida(&M)
label.debugger.launching.configurable.socket=&Socket
label.exception.breakpoint.properties.panel.caught.exception=Excepción capturada (&N)
label.exception.breakpoint.properties.panel.group.notifications=Notificaciones
label.exception.breakpoint.properties.panel.uncaught.exception=Excepción no capturada (&O)
label.field.breakpoint.properties.panel.field.access=Acceso a campo(&S)
label.field.breakpoint.properties.panel.field.modification=Modificación de campo(&M)
label.generic.debugger.parameters.patcher.configurable.port=Puerto\:
label.generic.debugger.parameters.patcher.configurable.shmem=Shared &memory
label.generic.debugger.parameters.patcher.configurable.shmem.address=Dirección de memoria compartida\:
label.generic.debugger.parameters.patcher.configurable.socket=Socket(&S)
label.generic.debugger.parameters.patcher.configurable.transport=Transporte\:
label.group.watch.events=Watch
label.instrumentation.tracker=Tracker de instrumentación\: {0}
label.method.breakpoint.properties.panel.emulated=Emulado (&U)
label.method.breakpoint.properties.panel.method.entry=Entrada de método (&Y)
label.method.breakpoint.properties.panel.method.exit=Salida de método (&X)
label.method.breakpoints.processing.classes=Procesando clases para breakpoints de método emulados
label.method.breakpoints.setting.breakpoints=Configurando breakpoints de método emulados
label.object.markup.dialog.mark.referenced=Marcar valores referenciados desde campos constantes(&M)
label.thread.group.node=Grupo de threads "{0}"@{1}
label.thread.group.node.group.collected=El grupo de threads "{0}" ha sido recolectado por el garbage collector
label.thread.node="{0}"@{1}\: {2}
label.thread.node.in.group="{0}"@{1} en grupo "{3}"\: {2}
label.thread.node.thread.collected=El thread ''{0}'' ha sido recolectado por el garbage collector
label.threads.view.configurable.current.thread.on.top=Mover thread actual al principio
label.threads.view.configurable.show.class.name=Mostrar nombre de clase
label.threads.view.configurable.show.line.number=Mostrar número de línea (&L)
label.threads.view.configurable.show.package=Mostrar nombre del paquete
label.threads.view.configurable.show.prams.types=Mostrar tipos de argumentos de método
label.threads.view.configurable.show.source.file.name=Mostrar nombre del archivo fuente
label.threads.view.configurable.show.stack.frames.for.synthetic.methods=Mostrar frames de stack para métodos sintéticos(&F)
label.threads.view.configurable.show.thread.groups=Mostrar grupos de threads (&G)
label.too.many.frames.rest.truncated=Demasiados frames, el resto ha sido truncado…
label.undefined=indefinido
label.unknown.value=<desconocido>
label.user.renderers.configurable.renderer.name=Nombre del renderer\:
line.breakpoint.description.basic.line=Breakpoint de línea
line.breakpoint.description.conditional.return=Breakpoint de retorno
line.breakpoint.description.lambda=Breakpoint de Lambda
line.breakpoint.display.name=Línea {0,number,\#}
line.breakpoint.display.name.with.class.or.method=Línea {0,number,\#} en {1}
line.breakpoint.display.name.with.column=Línea {0,number,\#} columna {1,number,\#}
line.breakpoint.display.name.with.column.and.class.or.method=Línea {0,number,\#} columna {1,number,\#} en {2}
line.breakpoints.tab.title=Breakpoints de Línea Java
memory.toolwindow.title=Memoria
memory.view.constructor.tracker.name=MemoryViewConstructorTracker\: {0}
message.breakpoint.skipped.during.evaluation=Se omitió el breakpoint en {0} porque ocurrió dentro de la evaluación del debugger
message.breakpoint.skipped.during.stepping.in.another.thread=Se omitió el breakpoint en {0} debido al stepping en otro thread
message.breakpoint.skipped.learn.more=Guía de solución de problemas
message.breakpoint.skipped.other.vm=Se omitió el breakpoint en {0} porque ocurrió fuera de la JVM actual
message.conditional.return.breakpoint.on.android=El breakpoint en retorno condicional aún no está soportado en Android, se estableció un breakpoint de línea regular.
message.node.all.array.elements.null=Todos los elementos en el rango ({0}, {1}) son null
message.node.all.elements.null=Todos los elementos son null
message.node.array.elements.more=+{0} más
message.node.class.has.no.fields=La clase no tiene campos
message.node.class.no.fields.to.display=No hay campos para mostrar
message.node.debug.info.not.available=Información de debug no disponible
message.node.elements.null.hidden=No se muestran elementos null
message.node.empty.array=Vacío
message.node.evaluate=… Evaluar
message.node.evaluation.not.possible=La VM destino no está pausada por solicitud de breakpoint. La evaluación de métodos no es posible en este modo
message.node.filtered=Filtrado por\:
message.node.local.variables.capture.disabled=Las variables locales no fueron capturadas, puede cambiarlo en\:
message.node.local.variables.debug.info.not.available=Información de debug de variables no disponible
message.node.local.variables.not.captured=Las variables locales no son capturadas para métodos sintéticos, bridge, etc.
message.node.navigate=… Navegar
message.node.object.collected=El objeto ha sido recolectado por el garbage collector durante la invocación del método
message.node.open=… Abrir
message.node.show.icon=… Mostrar icono
message.node.show.image=… Mostrar imagen
message.node.thread.has.no.frames=El thread no tiene frames
message.node.thread.running=El thread está en ejecución
message.node.toString=… toString()
message.other.threads.reached.breakpoints={0,choice,1\#Otro thread también alcanzó un breakpoint|2\#{0} otros threads también alcanzaron breakpoints}
message.remote.jre.version.mismatch=La versión del JRE destino ({0})\nno coincide con la versión del JDK del proyecto ({1}), \nse usarán las fuentes del JDK\: {2}
method.breakpoint.description=Breakpoint de método
method.breakpoint.property.name.emulated=Emulado\:
method.breakpoint.property.name.watch.entry=Observar entrada\:
method.breakpoint.property.name.watch.exit=Observar salida\:
method.breakpoints.slowness.warning=Los breakpoints de método pueden ralentizar dramáticamente la depuración
method.breakpoints.tab.title=Breakpoints de Método Java
method.name.not.specified=Nombre de método no especificado
notification.group.hotswap=HotSwap realizado
notification.method.has.not.been.called=El método <b>{0}()</b> no ha sido llamado
overhead.toolwindow.title=Overhead
paths.to.closest.gc.roots.for=Rutas a los GC Roots más cercanos para {0}
please.select.a.file.to.import=Por favor seleccione un archivo para importar.
process.attach.run.configuration.type.name=Adjuntar al proceso
progress.evaluating=Evaluando {0}
progress.hot.swap.title=HotSwap
progress.hotswap.reloading=Recargando clases…
progress.hotswap.scanning.classes=Escaneando clases para recargar…
progress.hotswap.scanning.path=Escaneando\: {0}
progress.suffix.filtering.has.been.interrupted=(El filtrado ha sido interrumpido)
progress.suffix.limit.has.been.reached=(Se ha alcanzado el límite)
progress.text.errors.count=Errores\: {0}
progress.text.shown.x.of.y=Mostrado\: {0} / {1}
renderer.name=Renderizador {0}
rule.name.group.by.class=Agrupar por clase
rule.name.group.by.package=Agrupar por package
select.stack.frame=Seleccionar frame de stack
settings.async.annotations.configuration=Configuración de Anotaciones Asíncronas
settings.async.execute=Ejecución Asíncrona
settings.async.schedule=Programación Asíncrona
settings.breakpoints.based=Basado en breakpoints\:
settings.capture.column.capture.class.name=Capturar nombre de clase
settings.capture.column.capture.key.expression=Capturar expresión clave
settings.capture.column.capture.method.name=Capturar nombre de método
settings.capture.column.insert.class.name=Insertar nombre de clase
settings.capture.column.insert.key.expression=Insertar expresión clave
settings.capture.column.insert.method.name=Insertar nombre de método
status.app.running=La aplicación está en ejecución
status.breakpoint.invalid=INVÁLIDO
status.breakpoint.reached.in.thread=Breakpoint alcanzado en el thread {0}
status.breakpoint.reached.in.thread.switch=<a href\="\#">Cambiar thread</a>
status.classes.not.all.versions.reloaded=Para {0} de {1} {1,choice, 1\#clase|2\#clases} no se recargaron todas las versiones
status.classes.reloaded={0,number} {0,choice, 0\#clases|1\#clase|2\#clases} recargadas
status.connect.failed=Error al establecer conexión con la VM destino, dirección\: {0}
status.connected=Conectado a la VM destino, dirección\: {0}
status.connecting=Conectando a la VM destino, dirección\: {0}
status.debug.stopped=Debug detenido
status.disconnected=Desconectado de la VM destino, dirección\: {0}
status.field.watchpoint.reached.access='{'{0}@{5}'}'.{1} será accedido en {2}({3}\:{4,number,\#})
status.field.watchpoint.reached.modification='{'{0}@{7}'}'.{1} será modificado en {4}({5}\:{6,number,\#}). Valor actual \= ''{2}''. Nuevo valor \= ''{3}''
status.generic.breakpoint.reached=Breakpoint alcanzado
status.hot.swap.completed.restart=Reiniciar sesión
status.hot.swap.completed.stop=Detener sesión
status.hot.swap.completed.with.errors=HotSwap falló
status.hot.swap.completed.with.warnings=HotSwap completado con advertencias
status.hotswap.loaded.classes.up.to.date=Las clases cargadas están actualizadas. Nada que recargar
status.hotswap.uptodate=Las clases cargadas están actualizadas. Nada que recargar.
status.invalid.breakpoint.out.of.class=El breakpoint no pertenece a ninguna clase
status.line.breakpoint.reached=Breakpoint alcanzado en {0}({1}\:{2,number,\#})
status.line.breakpoint.reached.full.trace=Breakpoint alcanzado
status.listening=Escuchando la conexión, dirección\: {0}
status.method.entry.breakpoint.reached=Método ''{0}'' ingresado en {1}({2}\:{3,number,\#})
status.method.exit.breakpoint.reached=Breakpoint de método alcanzado. El método ''{0}'' está por salir en {1}({2}\:{3,number,\#})
status.paused=Pausado
status.paused.in.another.thread=Pausado en otro thread
status.process.resumed=Proceso reanudado
status.process.started=Proceso iniciado
status.process.terminated=Proceso terminado
status.run.to.cursor=Ejecutar hasta el cursor
status.run.to.cursor.in=Ejecutar hasta el cursor en {0}
status.static.field.watchpoint.reached.access={0}.{1} será accedido en {2}({3}\:{4,number,\#})
status.static.field.watchpoint.reached.modification={0}.{1} será modificado en {4}({5}\:{6,number,\#}). Valor actual \= ''{2}''. Nuevo valor \= ''{3}''
status.step.into=Entrando
status.step.out=Saliendo
status.step.over=Pasando por encima
status.stepping.in=Entrando en {0}
status.stopped.at.cursor=Detenido en el cursor
status.text.no.stack.frame.for.this.instance=No hay stack frame para esta instancia
status.text.select.instance.to.see.stack.frame=Seleccione instancia para ver el stack frame
status.thread.blocked.by=El stepping en el thread {0} está bloqueado por el thread {1}
status.thread.blocked.by.resume=<a href\="\#">Reanudar {0}</a>
status.thread.monitor=MONITOR
status.thread.not.started=NO_INICIADO
status.thread.running=EJECUTANDO
status.thread.sleeping=DURMIENDO
status.thread.undefined=INDEFINIDO
status.thread.unknown=DESCONOCIDO
status.thread.wait=ESPERA
status.thread.zombie=ZOMBIE
status.waiting.attach=El debugger está esperando que la aplicación inicie
status.waiting.attach.address=dirección de debug\: {0}
status.waiting.evaluation.result=Esperando hasta que el último comando del debugger se complete
stepping.filter.real.thread.name=thread {0}
string.connection=''{0}'', transporte\: ''{1}''
string.file.line.position=Clase en {0}\:{1}
string.null.context=contexto null
surround.with.runtime.type.template=((RuntimeType)expr)
text.user.renderers.configurable.no.renderers=Sin renderers
thread.dump=Thread Dump
thread.dump.name=Dump {0}
thread.operation.interrupt.is.not.supported.by.vm=La operación de thread 'interrupt' no está soportada por la VM
threads.export.attribute.error.incompatible.state=Estado de thread incompatible\: thread no suspendido
threads.export.attribute.label.blocks.thread=bloquea {0}
threads.export.attribute.label.daemon=daemon
threads.export.attribute.label.locked=bloqueado {0}
threads.export.attribute.label.object-id=<0x{0}> (un {1})
threads.export.attribute.label.priority=prio\={0}
threads.export.attribute.label.tid=tid\=0x{0}
threads.export.attribute.label.waiting.for.thread=esperando que {0} libere el lock en {1}
threads.view.configurable.display.name=Personalizar vista de threads
title.compound.renderer.configurable.choose.renderer.reference.type=Tipo de referencia del renderer
title.customize.data.views=Personalizar vistas de datos
title.error.evaluating.breakpoint.action=Error en acción de breakpoint
title.error.evaluating.breakpoint.condition=Error en condición de breakpoint
title.evaluating=Evaluando…
title.jdk140.unstable=Advertencia de versión de VM
title.range.too.big=El rango es demasiado grande
title.set.value=Establecer valor
title.smart.step.popup=Método para hacer Step Into
tracing.class.filters=Filtros de clase para tracing
transport.name.shared.memory=memoria compartida
transport.name.socket=socket
user.renderers.configurable.button.description.copy=Copiar renderer seleccionado
user.renderers.configurable.display.name=Renderers de tipos Java
waiting.for.debugger.response=Esperando que el proceso finalice correctamente
warning.0=¡ADVERTENCIA\! {0}
warning.filtering.may.have.side.effects=Advertencia\: el filtrado puede tener efectos secundarios
warning.finally.block.detected=Bloques finally no vacíos detectados\:
warning.jdk140.unstable=La versión de la VM del debuggee es "1.4.0".\nLos bugs documentados en J2SDK 1.4.0 pueden causar un comportamiento inestable del debugger.\nRecomendamos usar J2SDK 1.4.0_01 o superior.
warning.range.too.big=El rango especificado es demasiado grande. {0} necesita demasiados recursos para realizar la operación solicitada. ¿Estás seguro de que deseas continuar?
warning.recalculate=El valor será recalculado
warning.source.code.not.match=El código fuente no coincide con el bytecode