0.already.contains.field.1={0} ya contiene el campo {1}
0.already.contains.inner.class.named.1={0} ya contiene la clase interna llamada {1}
0.already.has.parameter.named.1.use.this.name.anyway={0} ya tiene un parámetro llamado ''{1}'.' ¿Usar este nombre de todas formas?
0.contains.call.with.null.argument.for.parameter.1={0} contiene llamada con argumento nulo para el parámetro {1}
0.implements.1={0} implementa {1}.
0.is.1.and.will.not.be.accessible.from.2.in.the.target.class={0} es {1} y no será accesible desde {2}.
0.is.a.part.of.method.hierarchy.do.you.want.to.delete.multiple.parameters={0} forma parte de la jerarquía del método. ¿Desea eliminar varios parámetros?
0.is.a.part.of.method.hierarchy.do.you.want.to.delete.multiple.type.parameters={0} es parte de la jerarquía del método. ¿Desea eliminar múltiples parámetros de tipo?
0.is.an.interface.method.implementation.will.be.added.to.all.directly.implementing.classes={0}=0 es una interfaz.
0.is.an.interface.that.has.no.implementing.classes={0} es una interfaz que no tiene clases implementadoras
0.is.not.a.legal.java.identifier=''{0}'' no es un identificador Java válido
0.is.not.accessible.from.1.value.for.introduced.parameter.in.that.method.call.will.be.incorrect={0} no es accesible desde {1}. El valor del parámetro introducido en esa llamada al método será incorrecto.
0.is.not.initialized.in.declaration.such.fields.are.not.allowed.in.interfaces={0} no se inicializa en la declaración. Este tipo de campos no están permitidos en las interfaces.
0.is.not.static.it.cannot.be.moved.to.the.interface={0} no es estático. No puede ser movido a la interfaz
0.is.not.visible.to.members.of.1={0} no es visible para miembros de {1}
0.is.used.for.writing.in.1=Se utiliza {0} para escribir en {1}
0.refactoring.is.supported.only.for.final.fields=Sólo soporta {0} refactorización para campos finales
0.upcasts.an.instance.of.1.to.2={0} asciende una instancia de {1} a {2}
0.uses.1.of.an.instance.of.a.2={0} usa {1} de una instancia de un {2}
0.uses.1.which.needs.class.instance={0} usa {1}, que necesita una instancia de clase.
0.uses.a.package.local.1={0} usa en paquete-privado {1}
0.uses.non.static.1.which.is.not.passed.as.a.parameter={0} usa no estático {1} que no se pasa como parámetro
0.will.be.inaccessible.from.1={0} no será accesible desde {1}
0.will.become.inaccessible.from.1={0} será inaccesible desde {1}
0.will.hide.renamed.1={0} ocultará el renombrado {1}
0.will.no.longer.be.canonical.constructor=El constructor dejará de ser canónico
0.will.no.longer.be.record.component.accessor={0} dejará de ser {1} getter
0.will.no.longer.override.1={0} ya no anulará {1}
0.will.not.be.accessible.from.1.after.inlining={0} no será accesible desde {1} después de la incrustación
0.will.override.renamed.1={0} redefinirá {1} renombrado
a.package.local.class.0.will.no.longer.be.accessible.from.1=La clase de paquete local {0} ya no será accesible desde {1}
accept.signature.change=Aceptar modificación de firma
add.object.as.a.parameter.to.constructors.with.name=Agregar objeto como parámetro a constructores con nombre:
add.parameters.for.fields=Añadir parámetros para fields:
add.parameters.for.fields.to.constructors=Añadir parámetros de los campos a constructores:(&F)
all.candidate.variables.have.types.not.in.project=Todas las variables candidatas (parámetros del método y campos de clase contenedores) tienen tipos que no están en el proyecto
all.candidate.variables.have.unknown.types=Todas las variables candidatas (parametros del metodo y campos de la clase contenedora) tienen tipos desconocidos
all.invocations.and.remove.the.method=Integrar en línea todos los usos y eliminar el método (&A)
all.invocations.in.project=Integr&ar todos los usos en el proyecto
all.invocations.keep.the.method=Invocar todo, mantener el método(&E)
all.references.and.remove.super.class=En línea todas las referencias y elimina la superclase(&A)
all.references.and.remove.the.class=En línea todas las referencias y eliminar la clase(&A)
all.references.and.remove.the.field=Inlinear todas las referencias y eliminar el campo(&A)
all.references.keep.field=Hacer inline de todas las referencias y mantener el campo
all.these.directories.will.be.moved.and.all.references.to.0.will.be.changed=Todos estos directorios se moverán, y todas las referencias a {0} se cambiarán.
analyze.and.replace.usages=Analizar y reemplazar usos
analyze.module.conflicts=Analizar conflictos de módulos...
annotate.field.as.nonnls.checkbox=Anotar field como @NonNls(&F)
anonymous.class.description=clase anónima derivada de {0}
anonymous.class.text=Clase anónima
anonymous.to.inner.enum.constant.cannot.refactor.message=La constante de enumeración no se puede convertir a clase interna
anonymousToInner.class.name.label.text=Nombre de la clase:
anonymousToInner.make.class.static.checkbox.text=Convertir clase a estática(&S)
anonymousToInner.no.inner.class.name=Debe especificar un nombre de clase
anonymousToInner.parameters.panel.border.title=Parámetros de Constructor
anonymousToInner.refactoring.name=Convertir anónimo a interno
auto.rename.module.dialog.description=Renombrar los módulos Java con los siguientes nombres a:
auto.rename.module.dialog.title=Renombrar Módulos Java
auto.rename.module.entity=Módulo Java
automatic.overload.renamer.entity.name=Sobrecarga
automatic.parameter.renamer.entity.name=Parámetro
boolean.method.result=Resultado del método booleano
can.t.restore.context.for.method.extraction=No se puede restaurar el contexto para la extracción del método
cannot.find.or.create.destination.directory=No se encuentra o no se puede crear el directorio de destino
cannot.introduce.field.in.interface=No se permiten campos no constantes en una interfaz.
cannot.move=No se puede mover
cannot.move.inner.class.0.into.itself=No se puede mover la clase interior {0} a sí misma
cannot.move.package.into.itself=No se puede mover el paquete a sí mismo
caret.position.warning.message=El cursor debe estar ubicado en el tipo de campo, variable, método o parámetro del método a refactorizar
change.method.signature.action.name=Cambiar firma del método
change.signature.default.value.missing.warning.message=Falta el valor predeterminado. Las llamadas al método contendrán espacios en blanco en lugar del nuevo valor de parámetro.
change.signature.use.any.checkbox=Usar cualquier Var(&U)
changeClassSignature.Type.parameter.can.not.be.primitive=El parámetro de tipo no puede ser primitivo
changeClassSignature.already.contains.type.parameter=''{0}'' ya contiene el parámetro de tipo ''{1}''
changeClassSignature.bad.value=Valor {0} incorrecto: ''{1}'' para el parámetro ''{2}''
changeClassSignature.class.label.text=Cambiar firma de {0}
changeClassSignature.no.type.parameters=La clase no puede tener parámetros de tipo
changeClassSignature.parameters.panel.border.title=Parámetros
changeClassSignature.refactoring.name=Cambiar firma de clase
changeSignature.bound.value.column=Valor de Límite:
changeSignature.cannot.resolve.return.type=No se puede resolver el tipo de retorno ''{0}''.
changeSignature.contract.converter.can.not.update.annotation=La anotación de @Contract no se puede actualizar automáticamente: {0}
changeSignature.contract.converter.definition.error=Error en la definición del contrato: {0}
changeSignature.contract.converter.external.annotations=La actualización automática de la anotación externa no es compatible
changeSignature.contract.converter.inherited.annotation=La anotación se hereda del método base
changeSignature.contract.converter.invalid.clause=Cláusula de contrato no válido ''{0}''
changeSignature.contract.converter.invalid.return.reference=Referencia no válida en el valor devuelto: {0}
changeSignature.contract.converter.mutation.contract=La anotación contiene un contrato de mutación
changeSignature.contract.converter.parameter.removed=El parámetro ''{0}'' fue eliminado, pero la cláusula de contrato ''{1}'' depende de él
changeSignature.contract.converter.return.parameter.removed=El parámetro ''{0}'' fue eliminado pero la cláusula del contrato ''{1}'' lo retorna
changeSignature.default.value.column=Valor por defecto:
changeSignature.empty.callee.method.text=El texto del método callee se mostrará aquí
changeSignature.empty.caller.method.text=El texto del método de llamada con la llamada al método llamado resaltada se mostraría aquí
changeSignature.exception.caller.chooser=Seleccionar métodos para propagar nuevas excepciones
changeSignature.exceptions.panel.border.title=Excepciones
changeSignature.exceptions.wont.propagate=No se realizará propagación recursiva de los cambios de excepción
changeSignature.no.return.type=No se ha especificado un tipo de retorno
changeSignature.no.type.for.exception=Especifica el tipo para la excepción
changeSignature.no.type.for.parameter=Especificar tipo {0} para parámetro ''{1}''
changeSignature.not.throwable.type=Tipo incorrecto ''{0}'' para excepción, debe extender java.lang.Throwable
changeSignature.processing.changes.title=Procesando cambios...
changeSignature.propagate.exceptions.title=Propagar excepciones...(&X)
changeSignature.use.any.var=Usar cualquier variable.
changeSignature.validating.title=Validando...
changeSignature.vararg.not.last=El parámetro vararg debe ser el último en la firma del método
changeSignature.wrong.return.type=Tipo de retorno erróneo: ''{0}''
changeSignature.wrong.type.for.exception=Tipo incorrecto: ''{0}'' para la excepción
changeSignature.wrong.type.for.parameter=Tipo incorrecto: ''{0}'' para el parámetro ''{1}''
checking.conflicts=Comprobando conflictos...
choose.the.ones.you.want.to.be.deleted=Selecciona los que deseas eliminar
class.0.already.exists=La clase {0} ya existe
class.0.is.not.accessible.from.target.1=La clase {0} no es accesible desde el objetivo {1}
class.0.not.found=No se encontró la clase {0}.
class.body.description=body class de {0}
class.description={1, choice, 0#|1#local }clase {0}
class.does.not.exist.in.the.project=La clase no existe en el proyecto. ¿Quieres crearla?
class.does.not.have.base.classes.or.interfaces=La clase {0} no tiene clase base o interfaces
class.does.not.have.implicit.default.constructor=La clase {0} no tiene un constructor implícito por defecto
class.has.been.successfully.created=Se ha creado la clase {0} correctamente
class.initializer.description={0, choice, 0#estático|1#instancia} inicializador
class.is.abstract={0} es abstracto.
class.is.anonymous.warning.message=No se puede realizar la refactorización, porque las clases anónimas no pueden tener subclases
class.is.final.warning.message=No se puede realizar la refactorización porque la clase es final
class.is.interface={0}=es una interfaz
class.is.never.used=La clase nunca se utiliza
class.name.prompt=Nombre de clase:(&N)
collect.overloads=Coleccionar sobrecargas...
comments.elements.header=Ocurrencias encontradas en comentarios, cadenas y no-archivos de código {0}
constructor.being.refactored.is.used.in.initializer.of.0=El constructor a refactorizar se utiliza en un inicializador de {0}. La fábrica no estática de la clase interna {1} no se puede utilizar en este contexto. Como resultado, el código no compilará.
constructor.description=constructor {0}
constructor.with.builder.new.setter.prefix.dialog.message=Nuevo prefijo de Setter:
constructor.with.builder.parameters.to.pass.to.the.builder.title=Parámetros a pasar al constructor
constructor.with.builder.rename.setters.prefix.action.name=Renombrar prefijo de Setters
convert.anonymous.or.local.to.inner.fix.name=Convertir clase anónima o local a interna
convert.anonymous.to.inner.action.name=Convertir anónimo a método interno...
convert.anonymous.to.inner.fix.name=Convertir anónimo a clase interna
convert.local.to.field.title=Convertir local en campo
convert.local.to.inner.action.name=Convertir local en interno...
convert.local.to.inner.fix.name=Convertir una clase local en una clase interna
convert.to.instance.method.title=Convertir a método de instancia
convert.to.record.accessor.more.accessible={0} es {1}. Convertir a un registro hará que el método de acceso implícito correspondiente {2}.
convert.to.record.ctor.more.accessible={0} es {1}. La conversión a un registro convertirá el constructor de registro canónico implícito correspondiente en {2}.
convert.to.record.title=Convertir a clase de registro
convertToInstanceMethod.all.reference.type.parameters.are.not.in.project=No se encontró ninguna clase objetivo para el método de instancia: todos los tipos de referencia no están en el proyecto.
convertToInstanceMethod.all.reference.type.parameters.have.unknown.types=No se encuentra la clase de destino para el método de instancia: se desconocen todos los tipos referenciados.
convertToInstanceMethod.method.is.not.static=No se puede realizar la refactorización\nEl método {0} no es estático 
convertToInstanceMethod.no.default.ctor=La clase que la contiene no tiene un constructor predeterminado.
convertToInstanceMethod.no.parameters.with.reference.type=No hay parámetros que tengan tipo de referencia.
copy.class.clone.0.1=Clonar {0} {1}
copy.class.copy.0.1=Copiar {0} {1}
copy.handler.clone.class=Clonar clase
copy.handler.copy.class=Copiar clase
copy.handler.copy.class.with.dialog=Copiar clase...
copy.handler.copy.classes.with.dialog=Copiar clases...
current.class=clase actual
dataflow.to.here.expand.progress=Expandiendo todos los nodos...{0}
dataflow.to.here.group.by.leaf.action.description=Determina si null puede fluir hacia esta expresión
dataflow.to.here.group.by.leaf.action.text=Agrupar por expresión hoja en null{0, choice, 1#|2#  (Análisis en curso)}
dataflow.to.here.variable.dereferenced.tooltip=Variable desreferenciada
declare.final=Declarar final
declare.generated.annotations=Generar anotaciones(&G)
declare.static.checkbox=Declarar estático(&S)
declare.static.pass.fields.checkbox=Declarar static (pasar campos como parámetros)
declare.var.type=Declarar tipo de var
declare.varargs.checkbox=Declarar varargs(&A)
default.visibility.border.title=Visibilidad por defecto
delete.variable.declaration=Borrar declaración de variable(&D)
destination.directory.does.not.correspond.to.any.package=El directorio de destino no corresponde a ningún paquete
destination.package=Paquete destino:(&P)
dialog.message.0.would.hide.which.1.used.by.moved.2={0} ocultaría {1} que es utilizado por el movido {2}.
dialog.message.caret.should.be.inside.method.or.constant=El cursor debe colocarse dentro de un método o constante
dialog.message.confirmation.to.process.only.implementation=Se ha encontrado una implementación del método abstracto:<br><br><b>{0}</b><br><br>¿Desea integrar esta implementación?
dialog.message.enum.constant.0.won.t.be.compilable.in.1={0} no será compilable si se mueve a {1}.
dialog.message.field.doesnt.have.initializer=El campo {0} no tiene inicializador
dialog.message.moving.directories.to=Moviendo directorios a ''{0}''
dialog.message.non.constant.will.not.be.compilable.in.interface=La no constante {0} se volverá no compilable si se mueve a una interfaz.
dialog.message.overriding.methods.with.weaken.visibility=¿Quieres reducir también la visibilidad de los métodos de anulación a ''{0}''?
dialog.message.replace.duplicates.works.with.constants.only=Reemplazar duplicados funciona solo con constantes
dialog.message.static.class.initializers.are.not.allowed.in.interfaces=Los inicializadores de clase estática no están permitidos en interfaces.
dialog.title.analyze.code.fragment.to.extract=Analizar fragmento de código para extraer...
dialog.title.confirm.move=Confirmar mover
dialog.title.move.directory.to.source.root=Mover directorio a raíz de origen
dialog.title.resolving.method.implementation=Resolviendo implementación del método
different.name.expected=Se esperaba un nombre diferente
directory.0.already.contains.1.named.2=El directorio {0}\nya contiene un {1} llamado ''{2}''
directory.0.already.contains.a.file.named.1=El directorio {0}\nya contiene un archivo llamado ''{1}'' 
do.not.replace=No remplazar(&N)
do.not.show.this.message.in.the.future=No volver a mostrar este mensaje(&D)
do.you.want.to.process.overriding.methods.with.covariant.return.type=¿Desea procesar métodos sobreescritos\ncon tipo de retorno covariante? 
edit.migration.entry.title=Editar regla de migración de clase/paquete
edit.migration.map.ok.button=Guardar
edit.migration.map.title.existing=Editar mapa de migración
edit.migration.map.title.new=Nuevo Mapa de Migración
element.will.no.longer.be.accessible={0} ya no será accesible desde {1}
encapsulate.fields..encapsulated.fields.visibility.border.title=Visibilidad de campos encapsulados
encapsulate.fields..package.local.radio=Paquete local
encapsulate.fields.accessors.visibility.border.title=Visibilidad accesores
encapsulate.fields.command.name=Encapsular campos en {0}
encapsulate.fields.encapsulate.border.title=Encapsular
encapsulate.fields.existed.accessor.hidden=Ya existe un {0} que sería ocultado por el acceso generado
encapsulate.fields.existed.accessor.hides.generated=Ya existe {0} que ocultará el descriptor de acceso generado para {1}
encapsulate.fields.expression.type.is.used=No es posible continuar con una expresión de postfijo o prefijo cuando su tipo de resultado es utilizado
encapsulate.fields.field.column.name=Campo
encapsulate.fields.fields.to.be.encapsulated=Campos a encapsular
encapsulate.fields.fields.to.encapsulate.border.title=Campos a encapsular
encapsulate.fields.get.access.checkbox=Obtener acceso(&G)
encapsulate.fields.getter.column.name=Getter
encapsulate.fields.getter.exists=Ya existe el método {0} que difiere del getter {1} por el tipo de retorno solamente
encapsulate.fields.no.target=No se ha encontrado nada para encapsular
encapsulate.fields.nothing.todo.warning.message=La clase no tiene campos que encapsular
encapsulate.fields.private.radio=Privado
encapsulate.fields.protected.radio=Proteg
encapsulate.fields.refactoring.cannot.be.applied.to.interface=La refactorización Encapsular campos no puede aplicarse a la interfaz
encapsulate.fields.set.access.checkbox=Establecer acceso(&S)
encapsulate.fields.setter.column.name=Setter
encapsulate.fields.setter.exists=Ya existe el método {0} que difiere del setter {1} solo en el tipo de retorno
encapsulate.fields.title=Encapsular campos
encapsulate.fields.use.accessors.even.when.field.is.accessible.checkbox=Utilizar accesos incluso cuando el campo es accesible
entity.name.accessor=Accesor
entity.name.constructor.parameter=Parámetro
entity.name.inheritor=Hijo
entity.name.test=Prueba
entity.name.variable=Variable
enum.constant.description=Constante de enumeración {0}
enum.description={1, choice, 0#|1#local }enum {0}
error.cannot.resolve=No se puede resolver {0}
error.incorrect.data=Datos incorrectos
error.not.supported.for.jsp={0} no está soportado para JSP
error.not.supported.for.local=Una clase que extiende una clase local no se puede convertir a una clase interna
error.not.supported.for.package.info={0} La refactorización no es compatible con package-info.java
error.wrong.caret.position.anonymous=El cursor debe estar posicionado dentro de la clase anónima o local para poder refactorizar
error.wrong.caret.position.constructor=El cursor debe estar colocado dentro del constructor a refactorizar
error.wrong.caret.position.local.or.expression.name=El caret debe estar posicionado en el nombre de la variable local o expresión para refactorizar
error.wrong.caret.position.method=El punto de inserción debe estar situado dentro del método a refactorizar
error.wrong.name.input=Nombre incorrecto: {0}
expand.method.reference.warning=El método es usado en una o más referencias de método. Continuar convertirá estas referencias en expresiones lambda.
expression.result=resultado de la expresión
extract.chained.constructor.checkbox=Extraer constructor encadenado(&C)
extract.delegate.as.enum.checkbox=Extraer como enumeración
extract.delegate.create.nested.checkbox=Crear clase anidada
extract.delegate.generate.accessors.checkbox=Generar accesores(&G)
extract.delegate.unable.create.warning.message=No es posible crear una clase con el nombre suministrado
extract.method.checkbox.annotate=Anotar
extract.method.checkbox.make.static=Convertir a estático
extract.method.checkbox.make.static.and.pass.fields=Haga estático y pase campos
extract.method.conflict.parameter=Parámetro conflictivo: {0}
extract.method.conflict.variable=La variable con nombre {0} ya está definida en el ámbito seleccionado
extract.method.control.flow.analysis.failed=El código contiene errores de sintaxis. No se puede realizar el análisis necesario.
extract.method.dialog.separator.parameters=Parámetros(&P)
extract.method.error.annotation.value=No es posible extraer método del valor de anotación
extract.method.error.class.not.found=El bloque seleccionado debe ser parte de la clase Java.
extract.method.error.class.outside.defined=La clase local se define fuera del bloque seleccionado.
extract.method.error.class.outside.used=La clase local se usa fuera del bloque seleccionado.
extract.method.error.exception=Se comportaría de forma diferente al lanzarse una excepción.
extract.method.error.local.class.defined.outside=No se puede extraer método porque el fragmento de código seleccionado utiliza clases locales definidas fuera del fragmento
extract.method.error.local.class.used.outside=No se puede extraer el método porque el fragmento de código seleccionado define clases locales utilizadas fuera del fragmento
extract.method.error.local.class.variable.used.outside=No se puede extraer el método porque el fragmento de código seleccionado define una variable de tipo de clase local utilizada fuera del fragmento
extract.method.error.make.static=No se pudo establecer como static
extract.method.error.many.exits=Hay múltiples puntos de salida.
extract.method.error.many.finals=Hay una asignación al campo final.
extract.method.error.many.outputs=Debe devolver varias variables.
extract.method.error.method.conflict=Ya existe un método con la misma firma
extract.method.error.prefix=No se puede extraer método.
extract.method.error.variable.in.expression=Hay una variable para retornar dentro de la expresión seleccionada.
extract.method.error.wrap.many.outputs=Existen varias variables de salida en el bloque de código seleccionado.
extract.method.error.wrap.many.outputs.class=un objeto único
extract.method.error.wrap.many.outputs.record=un nuevo registro
extract.method.gotit.navigation.header=¿Quieres cambiar la firma del método?
extract.method.gotit.navigation.message=Ir a la declaración del método para hacerlo:<br/>{0} el nombre del método o presiona {1}.
extract.method.gotit.signature.header=Cambiar la firma del método
extract.method.gotit.signature.message=<html><p style=''margin-bottom:3px;''>1. Editar la firma</p><p style=''margin-bottom:3px;''>2. Actualizar usos: haz clic en el ícono en el margen o presiona {0}</p><p><font color=gray>Para reordenar los parámetros, usa {1} o {2}.</font></p></html>
extract.method.link.label.more.options=Más opciones
extract.method.object=Extraer método en objeto
extract.method.object.anonymous.make.varargs.option=Hacer varargs
extract.method.object.class.name=Nombre de clase:(&C)
extract.method.object.create.anonymous.class=Crear Clase anónima(&A)
extract.method.object.create.inner.class=Crear clase interna(&I)
extract.method.object.inner.class.visibility=Visibilidad:
extract.method.object.inner.make.static.option=Hacer estático(&S)
extract.method.object.inner.make.varargs.option=Hacer varargs
extract.method.object.inner.visibility.package.local=local del paquete
extract.method.object.inner.visibility.private=privado
extract.method.object.inner.visibility.protected=protegido(&P)
extract.method.object.inner.visibility.public=publico
extract.method.object.method.name=Nombre del método:(&M)
extract.method.object.parameters=Parámetros
extract.method.object.signature.preview=Vista previa de firma
extract.method.object.suggestion=¿Quieres generar un objeto de método?
extract.method.preview.node.invalid.prefix=Prefijo inválido
extract.method.progress.replace.duplicates=Reemplazando duplicados
extract.method.progress.search.duplicates=Buscando duplicados
extract.parameters.to.replace.duplicates=Extraer parámetros para reemplazar duplicados
extract.subclass.command=Extraer subclase
extractSuper.rename.original.class.to=Renombrar clase original a:(&R)
extractSuperInterface.javadoc=Javadoc
factory.method.name.label=Nombre del método factoría:
failed.to.re.run.refactoring=Fallo al reintentar refactorización
field.0.is.already.defined.in.the.1=El campo {0} ya está definido en {1}
field.0.is.never.used=El campo {0} nunca se usa
field.0.is.not.accessible=El campo {0} no es accesible desde {1}
field.0.will.hide.field.1.of.the.base.class=El campo {0} ocultará el campo {1} de la clase base {2}
field.0.won.t.be.initialized.already.in.class.initializer=El campo ''{0}'' no será inicializado dentro del inicializador de clase
field.declaration.radio=Declaración de campo(&D)
field.description=campo {0}
field.name=Nombre de campo:(&F)
fields.to.be.refactored.should.belong.to.the.same.class=Los campos que se han de refactorizar deben pertenecer a la misma clase
functional.interface.broken=La expresión funcional demanda que la interfaz funcional tenga exactamente un método
generate.getter.for.delegated.component=Generar getter para componente delegado(&G)
generate.module.descriptors.analysing.message=Analizando Dependencias
generate.module.descriptors.build.required.message=No se pueden generar los descriptores de módulo porque el proyecto aún no ha sido compilado
generate.module.descriptors.collecting.message=Recolectando dependencias
generate.module.descriptors.command.title=Generar descriptores module-info
generate.module.descriptors.io.exceptions.message=Problema al leer los archivos del módulo {0}
generate.module.descriptors.no.suitable.modules.message=No se han encontrado módulos que puedan contener module-info
generate.module.descriptors.preparing.message=Preparando código
generate.module.descriptors.rebuild.message=El proyecto necesita ser construido para una mejor exactitud del cálculo de dependencias.
generate.module.descriptors.scanning.message=Escaneando salida del compilador
generate.module.descriptors.title=Generar Descriptores de Módulos
getter.and.setter.methods.found.for.the.field.0=Se han hallado métodos getter y setter para el campo {0}. ¿Desea {1} también?
getter.method.found.for.the.field.0=Método getter encontrado para el campo {0}. ¿{1} también el getter?
idea.has.not.found.any.code.that.can.be.replaced.with.method.call={0} no ha encontrado ninguna clase duplicada
ignore.button=Ignorar
implicit.last.parameter.warning=El último parámetro implícito no debe ser eliminado
infer.class.type.args.warning=Es imposible inferir los argumentos de tipo de clase. Al continuar, se crearía {0} en bruto
information.title=Información
initializer.for.variable.cannot.be.a.constant.initializer=El inicializador para la variable {0} no puede ser un inicializador constante.
inline.action.name=En línea
inline.anonymous.conflict.progress=Buscando herederos de la clase "{0}"...
inline.class.elements.header=Clase a intercalar
inline.conflicts.progress=Comprobando si es posible la inmediatez...
inline.constant.field.not.supported.for.enum.constants={0} no está permitido en constantes de enumeración
inline.element.unknown.header=Elemento desconocido
inline.field.action.name=Incrustar campo...
inline.field.command=Campo Inline {0}
inline.field.elements.header=Campo a colocar en línea
inline.field.field.name.label=Campo {0}
inline.field.field.occurrences=El campo {0} tiene {1} {1, choice, 1#aparición|2#apariciones}
inline.field.initializer.is.not.accessible=El inicializador de campo hace referencia a {0} que no es accesible en {1}
inline.field.title=Campo en línea
inline.field.used.in.javadoc=Campo en línea usado en javadoc
inline.field.used.in.reflection=Campo alineado usado mediante reflexión
inline.local.unable.try.catch.warning.message=No se puede incrustar fuera de la sentencia try/catch
inline.local.used.as.resource.cannot.refactor.message=La variable se utiliza como referencia a un recurso
inline.local.variable.declared.outside.cannot.refactor.message=Variable declarada fuera de un bloque de código
inline.method.calls.not.accessible.in=Llamadas de método en línea {0} que no serán accedidas en {1}
inline.method.calls.not.accessible.on.qualifier=Llamadas a métodos en línea {0} que no serán accesibles en el calificador {1}
inline.method.checking.tail.calls.progress=Comprobando usos de llamada final
inline.method.elements.header=Método a incrustar
inline.method.method.label=Método {0}
inline.method.method.occurrences=El método {0} tiene {1} {1, choice, 1#ocurrencia|2#ocurrencias}
inline.method.multiline.method.in.ctor.call=En línea no se puede aplicar a métodos con varias líneas en la llamada al constructor
inline.method.multiline.method.in.loop.condition=El Inline no se puede aplicar a un método de varias líneas en la condición del bucle
inline.method.object.action.name=Objetar en línea
inline.method.object.suggestion.message=¿Quieres incrustar en línea el objeto y la llamada subsiguiente?
inline.method.qualifier.usage.side.effect=El método en línea se usa en la referencia de método con efectos secundarios en el calificador
inline.method.used.in.javadoc=Método incluido usado en javadoc
inline.method.used.in.reflection=Método en línea utilizado reflexivamente
inline.object.command.name=Incrustar objeto
inline.parameter.action.name=Parámetro en línea...
inline.parameter.cannot.find.initializer.warning.message=No se encuentra inicializador de constante para el parámetro
inline.parameter.confirmation=¿Inline del parámetro ''{0}'' con inicializador ''{1}''?
inline.parameter.dependency.unavailable.in.parameter.method=El inicializador del parámetro depende de {0}, que no es accesible dentro del método del parámetro
inline.parameter.dependency.unavailable.in.static.method=El inicializador del parámetro depende de {0} que no está disponible en el método estático
inline.parameter.depends.on.caller.parameter=Inicializador del parámetro depende del parámetro del llamador
inline.parameter.depends.on.non.static=El inicializador del parámetro depende de un miembro no estático de otra clase
inline.parameter.depends.on.non.static.class=El parámetro inicializador depende de una clase no estática que no está disponible en un método estático
inline.parameter.depends.on.this.inside.static.method=El inicializador del parámetro depende de esto, que no está disponible dentro del método estático
inline.parameter.depends.on.unavailable.element.inside.method=El inicializador de parámetro depende de {0} que no está disponible dentro del método y no puede estar en línea
inline.parameter.depends.on.unavailable.value=El inicializador del parámetro depende de un valor que no está disponible dentro del método
inline.parameter.error.hierarchy=El parámetro inline no es compatible cuando el método es parte de la jerarquía de herencia
inline.parameter.error.non.project.method=La línea no se admite para métodos fuera del proyecto
inline.parameter.error.varargs=Inline para parámetros varargs no soportado
inline.parameter.initializer.depends.on.inaccessible.value=El inicializador de parámetro depende de un valor que no está disponible dentro del método y no se puede alinear
inline.parameter.method.usages.progress=Buscando usos de método
inline.parameter.no.usages.warning.message=El método no tiene usos
inline.parameter.not.accessible.warning.message=El inicializador de la constante no es accesible en el cuerpo del método
inline.parameter.refactoring=Inlinear parámetro
inline.parameter.replace.with.local.checkbox=Reemplazar por variable local(&E)
inline.parameter.write.usages.warning.message=No se admite la escritura de parámetros en línea con usos de escritura
inline.pattern.variable.title=Variable de patrón inline
inline.popup.highlight=Resaltar {0} escritura{0, choice, 1#, 2#s} en conflicto
inline.popup.ignore.conflicts=Ignorar escrituras y continuar
inline.super.class=Súper clase en línea
inline.super.class.action.name=Incrustar superclase...
inline.super.class.label=Clase {0}
inline.super.ctor.can.be.replaced=El constructor {0} puede ser reemplazado por cualquiera de {1}
inline.super.doc.panel.title=Javadoc para miembros incrustados
inline.super.expr.can.be.replaced={0} puede ser remplazado por cualquiera de {1}
inline.super.no.anonymous.class=No se puede insertar en línea en una clase anónima.
inline.super.no.ctor=No se encontró un constructor que coincida con super
inline.super.no.inheritors.warning.message=No se puede hacer la clase en línea sin herederos
inline.super.no.inner.class=No se puede alinear dentro de la clase interna. Mueva ''{0}'' hacia arriba
inline.super.no.return.in.super.ctor=No se soporta refactorización cuando el flujo de ejecución del super constructor es interrumpido por una sentencia return
inline.super.no.substitution=No se encuentra una sustitución consistente para {0}. Se esperaba ''{1}'' pero se encontró ''{2}''.
inline.super.non.project.class.warning.message=No se puede incrustar una clase que no pertenezca al proyecto
inline.super.static.import.can.be.replaced=La importación estática puede ser reemplazada por cualquiera de {0}
inline.super.target.instead.of.super.class=Se pasa una instancia de tipo objetivo a un lugar donde se espera una superclase.
inline.super.type.element.can.be.replaced={0} puede ser reemplazado con cualquiera de {1}
inline.super.type.params.differ=Los parámetros de tipo no coinciden en {0}. Se esperaba {1} pero se encontró {2}
inline.super.unknown.type=Tipo desconocido
inline.superclass.foreign.language.conflict.message=No se puede insertar en línea en {0}
inline.to.anonymous.border.title=En línea
inline.to.anonymous.command.name=Inlinear clase {0}
inline.to.anonymous.name.label=Clase {0}
inline.to.anonymous.no.abstract=Las clases abstractas no pueden ser inlineadas
inline.to.anonymous.no.ctor.calls=No se puede armonizar la clase debido a una llamada a su constructor dentro del cuerpo
inline.to.anonymous.no.get.class.calls=El resultado de la invocación de getClass() será cambiado
inline.to.anonymous.no.method.calls=No se puede hacer inline la clase porque hay una llamada al miembro en el cuerpo
inline.to.anonymous.no.multiple.interfaces=Las clases que implementan múltiples interfaces no se pueden insertar en línea
inline.to.anonymous.no.superclass.and.interface=Clases que tengan una superclase e implementen una interfaz no pueden ser inlineadas
inline.to.anonymous.refactoring=Inlinear a clase anónima
inline.vars.elements.header=Variable para convertir en línea
inline.warning.variables.used.in.initializer.are.updated=Inline inseguro: variables usadas en inicializador son actualizadas
inlined.method.implements.method.from.0=Método insertado implementa método desde {0}
inlined.method.overrides.method.from.0=El método en línea sobrescribe al método de {0}
inlined.method.will.be.transformed.to.single.return.form=Método en línea será transformado a forma de retorno único
inner.class.0.is.already.defined.in.class.1=La clase interna {0} ya está definida en la clase {1}.
inner.class.0.is.not.static=La clase interna {0} no es estática.\nLa refactorización {1} solo se admite para miembros estáticos.
inner.class.exists=Ya se ha definido una clase interna llamada ''{0}''\nen la clase ''{1}'' 
inner.class.name=Nombre de la clase anidada:(&I)
instance.initializer.description=inicializador de instancia de {0}
instances.casted.to.java.lang.object=Instancias lanzadas a java.lang.Object
instances.of.0.upcasted.to.1.were.found=Se encontraron instancias de {0} convertidas a {1}. Si continúa, se mostrarán en una pestaña Buscar por separado.
instances.upcasted.to.java.lang.object.found=Instancias convertidas a java.lang.Object encontradas
instances.upcasted.to.object=Instancias upcast a Objeto
interface.0.does.not.have.inheritors=La interfaz {0} no tiene herederos
interface.description={1, choice, 0#|1#local }interfaz {0}
interface.does.not.have.base.interfaces=La interfaz {0} no tiene interfaces base
interface.has.been.successfully.created=Se ha creado la interfaz {0}
introduce.constant.enum.cb=Extraer como enum constante
introduce.constant.field.of.type=Constante (campo final estático) de type:
introduce.constant.introduce.to.class=Extraer a clase (nombre completo):
introduce.constant.move.to.another.class.checkbox=Mover a otra clase(&M)
introduce.field.field.of.type=Campo de tipo type:
introduce.field.static.field.of.type=Campo estático del tipo:
introduce.functional.variable.pass.fields.checkbox=Pasar campos como parámetros(&F)
introduce.local.variable.to.reassign.title=Selecciona la variable a reasignar
introduce.parameter.command=Extrayendo parámetro a {0}
introduce.parameter.convert.lambda=Convertir a expresión lambda
introduce.parameter.duplicates.progress=Buscando duplicados del método...
introduce.parameter.elements.header=Introducción de parámetro en un método
introduce.parameter.object.create.inner.class=Crear clase interna(&I)
introduce.parameter.object.create.new.class=Crear nueva clase(&C)
introduce.parameter.object.error.class.does.not.exist=''{0}'' no existe
introduce.parameter.object.error.created.class.wont.be.accessible=La clase creada no será accesible
introduce.parameter.object.error.existing.class.misses.compatible.constructor=No hay constructores compatibles en la clase existente
introduce.parameter.object.error.file.already.exits=El Archivo ya existe: {0}
introduce.parameter.object.error.inner.class.already.exist=La clase interna con nombre ''{0}'' ya existe
introduce.parameter.object.error.invalid.inner.class.name=''{0}'' es un nombre de clase interna inválido
introduce.parameter.object.error.invalid.parameter.class.name=''{0}'' es un nombre de clase de parámetro no válido
introduce.parameter.object.error.invalid.parameter.class.package.name=''{0}'' es un nombre de paquete de clase de parámetro no válido
introduce.parameter.object.error.invalid.qualified.parameter.class.name=''{0}'' es nombre de clase de parámetros calificados no válidos
introduce.parameter.object.error.no.field.associated.found=No se encontró ningún campo asociado con {0}
introduce.parameter.object.escalate.visibility.option=Promover visibilidad(&E)
introduce.parameter.object.existing.class.name=Nombre(&N)
introduce.parameter.object.generate.accessors.option=Generar accesores(&G)
introduce.parameter.object.inner.class.name=Nombre(&N)
introduce.parameter.object.new.class.name=Nombre(&N)
introduce.parameter.object.new.class.package.name=Nombre del paquete(&P)
introduce.parameter.object.use.existing.class=Usar clase existente(&U)
introduce.parameter.super.method.checkbox=Refactorizar método uper
introduce.variable.message.cannot.extract.in.implicit.class=No se puede extraer en una clase declarada implícitamente
introduce.variable.message.cannot.extract.variable.in.interface=No se puede extraer una variable en una interfaz.
introduce.variable.message.change.semantics.warning=Extraer la expresión seleccionada cambia la semántica de la expresión circundante.
introduce.variable.message.expression.refers.to.pattern.variable.declared.outside=La expresión se refiere a la variable de patrón ''{0}'' declarada externamente
introduce.variable.no.matching.occurrences=No hay coincidencias
introduced.variable.will.conflict.with.0=La variable introducida entrará en conflicto con {0}
introducing.variable.may.break.code.logic=Introducir variable podría alterar la lógica del código
invalid.expression.context=Contexto de expresión no válido.
invalid.package.name=Nombre de paquete no válido: {0}
invalid.target.package.name.specified=Nombre del paquete de destino especificado no válido
invert.boolean.foreach=El inicializador de parámetro de Foreach no se puede invertir
invert.boolean.wrong.type=El tipo de retorno del método o el tipo de la variable a refactorizar debe ser booleano
invocations.to.be.inlined=Invocaciones a insertar en línea {0}
is.modified.in.loop.body={0} está modificado en el cuerpo del ciclo
java.safe.delete.caller.text=El texto del método con el método receptor resaltado se mostraría aquí
java.safe.delete.empty.callee.text=El texto callee se mostrará aquí
javadoc.for.abstracts=JavaDoc para abstractos
keep.original.signature=Mantener firma original
lambda.to.reference.side.effect.warning.message=Hay posibles efectos secundarios en el calificador de referencia de método.
local.variable.description=variable local {0}
local.will.be.hidden.renamed.description=El campo renombrado ocultará {0}
localToInner.refactoring.name=Convertir clase local a clase anidada
locate.caret.inside.a.method=Localizar el cursor dentro de un método
locate.duplicates.action.name=Buscar duplicados
make.0.static=Convertir {0} en estático
make.method.static.title=Convertir en método estático
make.static.command=Establecer {0} como estático
make.static.description.label=Hacer el {0} {1} estático
make.static.elements.header={0} -> estático
make.static.method.references.progress=Buscar referencias del método
make.static.methods.to.propagate.dialog.title=Seleccionar métodos para propagar el static
members.to.form.interface.title=Miembros para formar la interfaz
members.to.form.superclass.title=Miembros para formar superclase
method.0.is.overridden.by.1=Método {0} está sobreescrito por {1}
method.0.will.hide.method.of.the.base.class=El método {0} ocultará el método de la clase base {1}
method.0.will.implement.method.of.the.base.class=El método {0} implementará un método de la clase base {1}
method.0.will.override.a.method.of.the.base.class=El método {0} sobrescribirá \nun método de la clase base {1} 
method.call.would.be.linked.to.0.after.rename=La llamada al método estaría vinculada al "{0}" después de cambiar el nombre
method.column=Método
method.description=método {0}
method.does.not.have.a.body=El método {0} no tiene un cuerpo
method.duplicates.found.message={0, choice, 1#1 fragmento de código|2#{0,number} fragmentos de código} encontrado{pl, plural, =1{} other{s}}
method.has.an.empty.body=El método {0} tiene un cuerpo vacío.
method.is.not.a.constructor=Método no es un constructor
method.reference.will.be.converted.to.lambda.expression.warning=La referencia a método se convertirá en una expresión lambda
method.with.the.same.erasure=método con el mismo borrado
migration.class=Clase
migration.dialog.alert.delete=Eliminar
migration.dialog.alert.name=Eliminar mapa de migración
migration.dialog.alert.text=¿Eliminar migración ''{0}''?
migration.dialog.link.delete=Eliminar
migration.dialog.link.duplicate=Duplicar y editar...
migration.dialog.link.edit=Editar...
migration.dialog.ok.button.text=Ejecutar
migration.dialog.scope.label=Alcance:
migration.dialog.scope.whole.project=Proyecto entero
migration.dialog.title=Migración de paquetes y clases
migration.edit.copy.existing=Copiar uno existente
migration.edit.duplicated.migration.name={0} copia
migration.edit.empty.name=Un nombre de migración no puede estar vacío.
migration.edit.empty.table=La tabla de migración no puede estar vacía.
migration.edit.existing.name=Ya existe una migración con el mismo nombre.
migration.entry.class=Clase
migration.entry.new.name=Nuevo nombre:
migration.entry.old.name=Nombre antiguo:
migration.entry.package=Paquete
migration.map.description.label=Descripción del mapa:
migration.map.name.prompt=Nombre del mapa:
migration.new.name.column.header=Nuevo nombre
migration.no.usages.found.in.the.project=No se encontraron usos en el proyecto
migration.old.name.column.header=Nombre antiguo
migration.package=Paquete
migration.package.with.subpackages=Paquetes con subpaquetes
migration.title=Migración
migration.type.column.header=Tipo
move.class=Mover Clase...
move.class.or.package.build.directories=Construyendo el listado de directorios
move.class.refactoring.cannot.be.applied.to.anonymous.classes=La refactorización de Move Class no se puede aplicar a las clases anónimas
move.class.to.inner.command.name=Mover {0, choice, 1#clase|2#clases} {1} a {2}
move.class.to.inner.find.target.class.progress=Buscando clase objetivo...
move.class.to.inner.move.to.self.error=No se permite mover una clase a sí misma
move.class.to.inner.nonstatic.error=No está permitido mover una clase a una clase interna no estática
move.class.to.new.file.or.make.inner.class.preview=Mueve la clase ''{0}'' a un nuevo archivo en el paquete de tu elección o conviértela en una clase interna de una ya existente.
move.classes=Mover clases...
move.classes.and.packages=Mover clases y paquetes...
move.classes.command=Moviendo {0} al paquete {1}
move.classes.destination.make.inner=Convertir en clase interna(&M)
move.classes.destination.package.prompt=A paquete:
move.classes.destination.to.package=Al paquete(&G)
move.classes.invalid.package.name.warning.message=Nombre de paquete inválido
move.classes.or.packages.different.modules.exports.conflict=Mover {0} del módulo {1} al módulo {2} puede ocultar su acceso
move.classes.or.packages.new.module.exports.conflict=Cambiar las sentencias export/opens del paquete {0} otorga acceso a otros tipos y sus miembros en el mismo paquete
move.classes.or.packages.title=Mover
move.classes.or.packages.unused.exports.action.name=Eliminar exportaciones/aperturas no usadas
move.classes.or.packages.unused.exports.command.name=Eliminando exportaciones/aperturas no usadas
move.classes.or.packages.unused.exports.notification.title=Se encontraron exportaciones/aperturas no utilizadas<br>\nen el módulo {0,choice, 1#descriptor|2#descriptors} 
move.enum.constant.cb=Mover como constantes enumeradas, si es posible(&E)
move.files.regrouping.command.name=Reagrupando...
move.files.to.new.directory.prompt=A directorio:
move.inner.class.action.name=Mover clase interna...
move.inner.class.command=Moviendo clase interna {0}
move.inner.class.to.another.class=Mover clase interna {0} a otra clase(&M)
move.inner.class.to.be.moved=Clase que se va a mover
move.inner.class.to.upper.level=Mover clase interna {0} a nivel superior(&I)
move.inner.class.to.upper.level.action.name=Mover clase interna a nivel superior...
move.inner.class.to.upper.level.or.another.class.preview=Mover clase interna ''{0}'' al nivel superior de un paquete de su elección u otra clase.
move.inner.class.to.upper.level.preview=Mover la clase interna ''{0}'' al nivel superior del paquete que elijas.
move.instance.method.delegate.title=Mover método de instancia...
move.instance.method.elements.header=Mover método de instancia
move.instance.method.handler.make.method.static=¿Desea hacer que el método ''{0}'' sea estático y luego moverlo?
move.label.text=Mover:
move.member.write.access.in.interface.conflict={0} es escrito, pero una interfaz solo puede contener constantes.
move.members.action.name=Mover Miembros...
move.method.enter.a.valid.name.for.parameter=Por favor, introduce un nombre válido para el parámetro
move.method.is.not.supported.for.0=No se admite el traslado del método de instancia para {0}
move.method.is.not.supported.for.constructors=Mover método no es compatible con constructores
move.method.is.not.supported.for.generic.classes=El método de movimiento no es compatible con clases genéricas
move.method.is.not.supported.for.non.project.methods=No se admite el cambio de método para métodos que no son del proyecto
move.method.this.parameter.label=Selecciona un nombre para el parametro ''{0}.this''
move.methods.panel.title=Métodos para mover a la clase extraída(&M)
move.methods.used.in.extracted.block.only=Mover métodos usados sólo en el bloque extraído
move.nonstatic.class.from.jsp.not.supported=No se admiten trasladados de clases no estáticas desde páginas JSP
move.package.or.directory=Mover Paquete o Directorio...
move.package.refactoring.cannot.be.applied.to.default.package=La refactorización de cambio de paquete no se puede aplicar al paquete por defecto
move.packages.or.directories=Mover paquetes o directorios...
move.single.class.or.package.name.label=Mover {0} {1}
move.specified.classes=Mover clases especificadas
move.specified.packages=Mover paquetes especificados
move.to.inner.duplicate.inner.class=La clase {0} ya contiene una clase interna llamada {1}
moving.local.classes.is.not.supported=Mover clases locales no está soportado
no.class.name.specified=Nombre de clase no especificado
no.exact.method.duplicates.were.found=<html><b>Se encontraron {0,choice, 0#No|1#Un|2#{0}} métodos exactos {0,choice, 0#duplicados|1#duplicado|2#duplicados}</b>, aunque los métodos cambiados como se muestran a continuación tienen {1} más {1,choice, 1#duplicado|2#duplicados} </html>
no.initializer.present.for.the.field=No se presentó un inicializador para el campo
no.parameter.name.specified=Nombre del parámetro no especificado
no.usages.can.be.replaced=No se pueden reemplazar los usos de {0} \ncon los usos de {1} 
occurrences.to.be.migrated=Instancias a migrar {0}
ok.button=Aceptar
only.fields.variables.of.methods.of.valid.type.can.be.considered=Solo se pueden considerar campos, variables, parámetros de métodos o métodos de tipo válido.
package.description=package {0}
package.does.not.exist=El paquete {0} no existe.
package.does.not.exist.preview=El paquete {0} no existe.
package.name.prompt=Nombre de paquete:
parameter.description=parámetro {0}
parameter.initializer.contains.0.but.not.all.calls.to.method.are.in.its.class=El inicializador de parámetros contiene {0}, pero no todas las llamadas al método están en su clase
parameter.name.prompt=Nombre del parámetro:(&M)
parameter.of.type=Parámetro de type:
parameter.type.table.column.title=Tipo
parameter.used.in.method.body.warning={0} se usa en el cuerpo del método
pass.outer.class.instance.as.parameter=Pasar instancia de clase externa como parámetro(&U)
pattern.variable.description=Variable de patrón {0}
please.enter.a.valid.target.package.name=Por favor introduzca un nombre de paquete destino válido
popup.title.choose.class.to.introduce.constant=Elegir clase para introducir constante
popup.title.choose.class.to.introduce.field=Elige la clase para introducir el campo
press.the.do.migrate.button=Presione el botón "Ejecutar migración" en la parte inferior del panel de resultados de búsqueda para migrar usando el mapa de migración "{0}"\n 
preview.usages.to.be.changed=Previsualizar los usos a modificar(&P)
process.duplicates.change.signature.promt=Para reemplazar todas las apariciones se cambiará la signatura del método. ¿Procedemos?
process.duplicates.title=Proceso de Duplicados
process.methods.duplicates.title=Procesar Método {2} Duplicado ({0} de {1})
processing.progress.text=Procesando {0}
progress.title.collect.hierarchy=Recopilar jerarquía ''{0}''
project.files.have.been.changed=Los archivos del proyecto han sido modificados.
push.down.delete.warning.text={0}Empujar miembros hacia abajo hará que se eliminen. ¿Desea continuar?
push.down.enum.no.constants.warning.text=El enum {0} no tiene constantes al cual insertar.
push.down.no.inheritors.class.warning.text=La clase {0} no tiene herederos.
push.down.no.inheritors.final.class.warning.text=La clase final {0} no tiene herederos.
push.down.unrelated.defaults.conflict={0} heredará valores predeterminados no relacionados de {1} y {2}
push.up.abstract.accessibility.in.subclass.conflict={0} usa {1} que no será accesible desde la subclase.
push.up.abstract.accessible.from.the.subclass.conflict=No se puede hacer que {0} sea abstracto, ya que no será accesible desde la subclase.
push.up.super.class.signature.conflict={0} en la superclase chocaría con el método {2} de {1}
re.run.refactoring=Volver a ejecutar refactorización
record.component.used.in.method.body.warning=El componente de registro ''{0}'' está en uso
record.description={1, choice, 0#|1#local }registro {0}
refactor.base.method.choice=Refactor base {0, choice, 0#métodos|1#método}
refactor.only.current.method.choice=Refactor solo el método actual
refactoring.cannot.be.applied.no.sources.attached={0} refactorización no puede ser aplicada: no hay fuentes adjuntas
refactoring.cannot.be.applied.to.abstract.methods={0} No es posible aplicar la refactorización en métodos abstractos
refactoring.cannot.be.applied.to.inline.non.chaining.constructors={0} La refactorización no puede aplicarse para incorporar constructores de no encadenamiento
refactoring.cannot.be.applied.to.native.methods={0} La refactorización no se puede aplicar a métodos nativos
refactoring.cannot.be.applied.to.vararg.constructors={0} La refactorización no puede aplicarse a constructores vararg
refactoring.extract.method.dialog.duplicates.count={0,choice, 1#1|2#{0,number}} fragmento de código duplicado puede ser reemplazado por una llamada al método extraído
refactoring.extract.method.dialog.duplicates.pending=Buscando duplicados...
refactoring.extract.method.dialog.duplicates.progress=Buscando duplicados
refactoring.extract.method.inner.class.defined=La clase interna {0} ya está definida en la clase {1}.
refactoring.extract.method.preview.button.refactor=Ejecutar refactorización(&D)
refactoring.extract.method.preview.button.rerun=Reejecutar Refactorización(&E)
refactoring.extract.method.preview.failed=Error al extraer método
refactoring.extract.method.preview.group.duplicates=Fragmentos de código duplicados
refactoring.extract.method.preview.group.method=Método a extraer
refactoring.extract.method.preview.group.original=Fragmento de código original
refactoring.extract.method.preview.preparing=Preparando Diferencia
refactoring.extract.method.preview.updating=Actualizando diferencias
refactoring.extract.method.reference.to.change=Referencias a cambiar
refactoring.introduce.variable.enum.in.label.message=No se puede extraer ninguna constante de enumeración en la etiqueta de cambio
refactoring.is.not.supported.for.jsp.classes=La refactorización no está soportada para las clases JSP
refactoring.is.not.supported.in.the.current.context={0} La refactorización no está soportada en el contexto actual
references.in.code.to.elements.from.migration.map=Referencias en código a elementos del mapa de migración "{0}" {1}
references.to.0.to.be.replaced.with.references.to.1=Las referencias a ''{0}'' deben reemplazarse con referencias a ''{1}''{2}
remove.parameter.0.no.longer.used=Eliminar parámetro ''{0}'' que ya no se utiliza
removing.redundant.imports.progress.title=Eliminando imports redundantes
rename.accessors=Renombrar accesores(&A)
rename.accessors.title=Renombrar métodos get/set
rename.accessors.with.the.following.names.to=Renombrar accesores con los siguientes nombres a:
rename.constructor.parameters.title=Renombrar Parámetros del Constructor
rename.constructor.parameters.with.the.following.names.to=Renombra los parámetros con los siguientes nombres a:
rename.inheritors.with.the.following.names.to.title=Renombrar a los herederos con los siguientes nombres a:
rename.module.already.exists=Ya existe el módulo ''{0}'' en el proyecto
rename.module.directory.command=Renombrar el módulo y el directorio a ''{0}''
rename.module.directory.title=Cambiar el nombre al módulo y al directorio(&A)
rename.overloads=Renombrar sobrecargas(&O)
rename.overloads.dialog.title=Renombra sobrecargas
rename.overloads.to.dialog.description=Renombrar sobrecargas a:
rename.parameter.in.hierarchy.to.dialog.description=Renombra parámetro in the hierarchy a:
rename.parameters.dialog.title=Renombrar parámetros
rename.test.method=Renombrar método de prueba
rename.test.method.description=Cambiar el nombre de los métodos de prueba con los siguientes nombres a:
rename.test.method.entity.name=Método de prueba
rename.test.method.title=Renombrar Métodos de Prueba
rename.tests=Renombrar pruebas
rename.tests.title=Renombrar pruebas
rename.tests.with.the.following.names.to=Renombrar pruebas con los siguientes nombres a:
rename.variables=Cambiar nombre variables
rename.variables.title=Renombrar Variables
renamed.class.will.hide.0.in.1=La clase renombrada esconderá {0} en {1}
renaming.method.will.override.final.0=Renombrar método sobreescribirá final "{0}"
replace.all.and.extract=Reemplazar todas {0} ocurrencias y extraer como ''{1}'' operación
replace.all.fields=Reemplazar todos los campos(&R)
replace.all.occurrences.changes.semantics=Reemplazar todas las {0} coincidencias (¡modificará la semántica!)
replace.all.occurrences.of.expression.0.occurrences=Reemplazar Todas las coincidencias ({0})
replace.all.read.and.write=Reemplazar ocurrencias de lectura y escritura (¡cambiará la semántica!)
replace.as.separate.operation=Sacar como ''{0}'' operacion
replace.constructor.0.with.a.factory.method=Reemplazar constructor {0} con un método factory
replace.constructor.builder.create.new=Crear nuevo(&C)
replace.constructor.builder.default.value.table.title=Valor por defecto
replace.constructor.builder.error.builder.class.cannot.be.the.same=La clase {0} no puede ser su propia clase constructora.
replace.constructor.builder.error.caret.position=El cursor debe estar posicionado dentro de una clase cuyos constructores deben ser reemplazados con un constructor.
replace.constructor.builder.error.class.with.chosen.name.already.exist=Ya existe una clase con ese nombre
replace.constructor.builder.error.identifier.invalid=El identificador ''{0}'' no es válido
replace.constructor.builder.error.invalid.builder.class.name=''{0}'' es nombre de clase de constructor invalido
replace.constructor.builder.error.invalid.builder.package.name=''{0}'' es un nombre de paquete de constructor no válido
replace.constructor.builder.error.invalid.builder.qualified.class.name=''{0}'' es un nombre no válido de clase cualificada del constructor
replace.constructor.builder.error.invalid.field.name="{0}" no es un nombre de campo válido
replace.constructor.builder.error.invalid.setter.name=''{0}'' no es un nombre de setter válido
replace.constructor.builder.error.no.constructor.chain=Los constructores encontrados no se pueden reducir a una cadena simple
replace.constructor.builder.error.no.constructors=La clase actual no tiene constructores para reemplazar por builder
replace.constructor.builder.error.selected.class.was.not.found=La clase seleccionada no fue encontrada.
replace.constructor.builder.field.name.table.title=Nombre del Campo
replace.constructor.builder.optional.setter.table.title=Setter opcional
replace.constructor.builder.parameter.table.title=Parámetro
replace.constructor.builder.select.builder.class.chooser.title=Seleccionar Clase Builder
replace.constructor.builder.setter.name.table.title=Nombre del Setter
replace.constructor.builder.use.existing=Usar existente(&U)
replace.constructor.existing.builder.fqn=Nombre de la clase builder (completamente cualificado)(&B)
replace.constructor.factory.error.factory.method.already.exists=El método de fábrica {0} ya existe y será usado en lugar del creado recientemente.
replace.constructor.factory.error.invalid.factory.method.name=''{0}'' no es un nombre de método de fábrica válido
replace.constructor.new.builder.class.name=Nombre de la clase Builder(&N)
replace.constructor.new.builder.package=Paquete para nuevo constructor(&P)
replace.constructor.with.builder=Reemplazar constructor con Builder
replace.constructor.with.builder.text=Reemplazar el constructor con un generador
replace.constructor.with.factory.method=Reemplazar el constructor con el método factoría
replace.constructor.with.factory.method.title=Reemplazar constructor por método factory
replace.constructor.with.factory.target.fq.name=En (nombre completo):
replace.default.constructor.of.0.with.a.factory.method=Reemplazar constructor por defecto de {0} con método fabrica
replace.default.constructor.with.factory.method=Reemplazar constructor por defecto con método fábrica
replace.fields.inaccessible.in.usage.context=Reemplazar campos inaccesibles en el contexto de uso
replace.fields.used.in.expressions.with.their.getters=Reemplazar los campos usados en las expresiones por sus getters(&U)
replace.inheritance.from=Reemplazar con herencia por delegación desde:(&R)
replace.inheritance.with.delegation.command=Reemplazando herencia con delegación en {0}
replace.inheritance.with.delegation.delegate.members.title=Miembros de delegación
replace.inheritance.with.delegation.elements.header=Reemplazar herencia con delegación
replace.inheritance.with.delegation.invalid.field=''{0}'' es un nombre de campo no válido para la delegación
replace.inheritance.with.delegation.invalid.inner.class=''{0}'' no es un nombre de campo válido para la delegación
replace.inheritance.with.delegation.title=Reemplazar herencia con delegación
replace.inside.current.lambda=Crear variable dentro de la lambda actual
replace.instance.qualifiers.with.class.references=Reemplazar los calificadores de instancia con referentes de clase
replace.lambda.chain.detected=Detectada cadena lambda
replace.method.code.duplicates.title=Reemplazar Duplicados de Código
replace.method.duplicates.scope.chooser.message=Ámbito de análisis
replace.method.duplicates.scope.chooser.title=Especificar el ámbito {0}
replace.occurrences.inside.statement=Reemplazar {0} ocurrencias en{2, choice, 1#|2# externo} bloque ''{1}''
replace.this.code.fragment.and.change.signature=Se cambiará la firma del método a {0}
replace.this.code.fragment.and.make.method.static=(Se convertirá el método en static)
replace.this.code.fragment.and.make.method.static.visible=(El método va a ser estático y {0})
replace.this.code.fragment.and.make.method.visible=(El método se {0})
replace.with.method.call.does.not.work.for.constructors=Reemplazar por llamada de método no trabaja para constructores
replace.write.access.occurrences=Reemplazar ocurrencias con acceso de escritura(&L)
replacing.inheritance.with.delegation=Sustituyendo la herencia con delegación
safe.delete.parameter.usage.warning={0} tiene un uso en el lado de la llamada que no es seguro eliminar.
safe.delete.search.for.caller.method.usages.progress=Buscando usos de métodos del llamador...
safe.delete.select.members.to.propagate.dialog.title=Seleccionar miembros a propagar para eliminar de forma segura
safe.delete.select.methods.to.propagate.delete.parameters.dialog.title=Seleccionar métodos para propagar la eliminación de parámetros
select.source.root.chooser.title=Seleccionar raíz fuente
selected.block.contains.invocation.of.another.class.constructor=El bloque seleccionado contiene la invocación de otro constructor de clase
selected.block.contains.statement.outside.of.class=El bloque seleccionado contiene una declaración fuera de una clase
selected.block.should.represent.an.expression=El bloque seleccionado debe representar una expresión
selected.expression.cannot.be.a.constant.initializer=La expresión seleccionada no puede ser un inicializador constante
selected.expression.cannot.be.extracted=No es posible extraer la expresión seleccionada
selected.expression.has.void.type=La expresión seleccionada tiene tipo void.
selected.expression.introduces.pattern.variable=La expresión seleccionada introduce una variable de patrón ''{0}''
setter.method.found.for.the.field.0=Método setter encontrado para el campo {0}. ¿{1} también el setter?
side.effects.detected.title=Efectos Secundarios Detectados
source.folder.0.has.package.prefix.1=La carpeta de origen {0} tiene el prefijo de paquete ''{1}''\nNo se puede crear el paquete ''{2}'' allí. 
static.initializer.description=inicializador estático de {0}
suggest.signature.preview.after.title=Después
suggest.signature.preview.method.call.prefix=llamada a método:
suggest.signature.preview.title.before=Antes
superclass.cannot.be.accessed.in.subclass=La superclase no será accesible en la subclase
superclass.cannot.be.extracted.from.a.record=No se puede extraer la superclase de un registro
superclass.cannot.be.extracted.from.an.enum=La superclase no se puede extraer de un enum
synthetic.jsp.class.is.referenced.in.the.method=Clase jsp sintética referenciada en el método
target.0.is.not.accessible.from.1=El destino {0} no es accesible desde {1}
template.error.class.already.defined=Una clase llamada ''{0}'' ya está definida en el alcance
template.error.invalid.identifier.name=Nombre de identificador no válido
template.error.variable.already.defined=Ya se ha definido una variable con ese nombre
there.are.going.to.be.multiple.destination.files.with.the.same.name=Va a haber múltiples archivos de destino con el mismo nombre
there.are.multiple.exit.points.in.the.selected.code.fragment=Existen varios puntos de salida en el fragmento de código seleccionado
there.are.multiple.output.values.for.the.selected.code.fragment=Existen múltiples valores de salida para el fragmento de código seleccionado:
there.are.no.variables.that.have.reference.type=No hay parámetros de método ni campos de clase que contengan un tipo de referencia
there.are.unused.methods.that.override.methods.you.delete=Existen métodos sin uso que sobrescriben métodos que eliminas
there.is.already.a.0.in.1=Ya hay un {0} en {1}
there.is.already.a.0.it.will.conflict.with.an.introduced.parameter=Ya existe {0}. Conflicto con el parámetro introducido
there.is.already.a.0.it.will.conflict.with.the.renamed.1=Ya existe un(a) {0} con el mismo nombre
there.is.already.a.0.it.will.conflict.with.the.renamed.short=La variable ''{0}'' ya existe
there.is.already.type.parameter.in.0.with.name.1=Ya existe el parámetro de tipo en {0} con el nombre {1}
this.invocation.only.and.keep.the.method=Solo integrar en línea este uso y mantener el método (&K)
this.method=Este método
this.reference.only.and.keep.super.class=Sólo esta referencia en línea y mantener la superclase(&K)
this.reference.only.and.keep.the.class=Solo esta referencia inline y mantener la clase(&K)
this.reference.only.and.keep.the.field=Referenciar este solo y mantener el campo(&K)
title.rename.variables.with.the.following.names.to=Renombrar variables con los siguientes nombres a:
tooltip.cannot.inline.pattern.variable=No se puede poner en línea la variable de patrón
turn.refs.to.super.command=Reemplazar usos de {0} con {1}
turnRefsToSuper.change.usages.to=Cambiar usos de {0} a:(&C)
turnRefsToSuper.use.superclass.in.instanceof=Usar interfaz/superclase en instanceof(&U)
type.migration.action.name=Migración de tipo
type.migration.choose.scope.title=Elegir ámbito donde puede ocurrir el cambio de firma
type.migration.class.type.argument.label=Migrar argumento de tipo de clase {0} a
type.migration.conflicts.found=Se han encontrado conflictos de migración
type.migration.error.hint.title=Migración de tipo
type.migration.exclude.action.text=Excluir(&E)
type.migration.include.action.text=Incluir(&I)
type.migration.migrate.button.text=Migrar(&M)
type.migration.no.conflicts.found=No se encontraron conflictos de migración
type.migration.no.scope.warning.message=Ámbito no elegido
type.migration.reasons.to.migrate=Razones encontradas para migrar
type.migration.rerun.button.text=Volver a ejecutar la migración de tipos(&R)
type.migration.return.type.of.method.label=Migrar tipo de retorno {0} del método {1} a
type.migration.select.suggestion=Selecciona la raíz para encontrar razones para migrar
type.migration.type.of.field.label=Migrar tipo {0} del campo {1} a
type.migration.type.of.parameter.label=Migrar el tipo {0} del parámetro {1} a
type.migration.type.of.pattern.variable.label=Migrar el tipo {0} de la variable de patrón {1} a
type.migration.type.of.record.component.label=Migrar tipo {0} del componente de registro {1} a
type.migration.type.of.variable.label=Migrar el tipo {0} de la variable {1} a
type.of.the.selected.expression.cannot.be.determined=Tipo de expresión seleccionada no puede ser determinada
unable.to.start.type.migration=No se puede iniciar la migración del tipo
unknown.expression.type=Tipo de expresión desconocido.
unused.overriding.methods.title=Métodos anulados no usados
use.interface.where.possible.title=Utiliza Interfaz Siempre que sea Posible
use.super.references.prompt=En esta etapa {0} puede analizar usos de {1} y reemplazarlos con usos de {2} cuando sea posible.
use.variable.initializer.to.initialize.parameter=Usa el inicializador de variable initializer para inicializar el parámetro(&I)
variable.0.is.changed.before.last.access=La variable ''{0}'' cambió antes del último acceso a la variable ''{1}''.
variable.does.not.have.an.initializer=La variable {0} no tiene un inicializador.
variable.is.accessed.for.writing=La variable ''{0}'' es accedida para su escritura
variable.is.never.used.before.modification=La variable {0} nunca se usa antes de la modificación
variable.of.type=Variable de tipo type:
variable.type.unknown=Tipo de variable desconocido
would.you.like.to.replace.default.constructor.of.0.with.factory.method=¿Quieres reemplazar el constructor predeterminado de {0} con el método factory?
wrap.return.value.create.inner.class=Crear clase interna(&I)
wrap.return.value.create.new.class=Crear nueva clase(&C)
wrap.return.value.existing.class.name=Nombre
wrap.return.value.inner.class.name=Nombre de la clase interna(&M)
wrap.return.value.new.class.name=Nombre de nueva clase(&N)
wrap.return.value.new.class.package.name=Nombre del paquete(&P)
wrap.return.value.use.existing.class=Usar una clase existente(&U)
wrap.return.value.wrapper.field=Campo de envoltorio(&F)