DFAStrings.CppDFAArrayIndexOutOfBoundsDescription=Reporta expresiones de acceso a array o variable puntero donde el índice puede estar fuera de los límites del array o buffer asignado
DFAStrings.CppDFAArrayIndexOutOfBoundsTitle=Expresiones de acceso a array donde el índice puede estar fuera de límites
DFAStrings.CppDFAConstantConditionsDescription=Reporta condiciones que son siempre verdaderas o falsas y expresiones cuyo valor se prueba estáticamente que es constante
DFAStrings.CppDFAConstantConditionsTitle=Condiciones que son siempre verdaderas o falsas
DFAStrings.CppDFAConstantFunctionResultDescription=Reporta funciones donde el valor de retorno es siempre la misma constante
DFAStrings.CppDFAConstantFunctionResultTitle=Funciones cuyo valor de retorno es siempre la misma constante
DFAStrings.CppDFAConstantParameterDescription=Reporta parámetros de función que siempre tienen el mismo valor
DFAStrings.CppDFAConstantParameterTitle=Parámetros de función que siempre tienen el mismo valor
DFAStrings.CppDFADeletedPointerDescription=Reporta usos de punteros que refieren a memoria ya eliminada por el operador delete o la función free(void* ptr)
DFAStrings.CppDFADeletedPointerTitle=Usos de punteros que refieren a memoria eliminada
DFAStrings.CppDFAEndlessLoopDescription=Reporta sentencias 'for', 'while', 'do-while' y 'goto' que solo salen lanzando una excepción
DFAStrings.CppDFAEndlessLoopTitle=Sentencias de bucle infinito
DFAStrings.CppDFAInfiniteRecursionDescription=Reporta funciones que se llaman a sí mismas infinitamente a menos que se lance una excepción
DFAStrings.CppDFAInfiniteRecursionTitle=Funciones que se llaman a sí mismas infinitamente
DFAStrings.CppDFAInvalidatedMemoryDescription=Reporta referencias al contenido de contenedores invalidados
DFAStrings.CppDFAInvalidatedMemoryTitle=Referencias al contenido de contenedores invalidados
DFAStrings.CppDFALocalValueEscapesFunctionDescription=Reporta referencias a valores locales que escapan de la función a través de retornos, asignaciones a variables globales o campos
DFAStrings.CppDFALocalValueEscapesFunctionTitle=Referencias a valores locales que escapan de la función
DFAStrings.CppDFALocalValueEscapesScopeDescription=Reporta variables con referencias a variables locales que escapan de su ámbito
DFAStrings.CppDFALocalValueEscapesScopeTitle=Referencias a variables locales que escapan de su ámbito
DFAStrings.CppDFALoopConditionNotUpdatedDescription=Reporta condiciones de bucle que no se actualizan dentro del bucle
DFAStrings.CppDFALoopConditionNotUpdatedTitle=Condiciones de bucle que no se actualizan dentro del bucle
DFAStrings.CppDFAMemoryLeakDescription=Reporta asignaciones de memoria (usando 'new' o 'malloc()') que no fueron liberadas antes de volverse inaccesibles
DFAStrings.CppDFAMemoryLeakTitle=Asignaciones de memoria que no fueron liberadas
DFAStrings.CppDFANotInitializedFieldDescription=Reporta campos que pueden no haber sido inicializados antes de ser usados. La inicialización y el uso pueden ocurrir en diferentes funciones.
DFAStrings.CppDFANotInitializedFieldTitle=Campos que pueden no haber sido inicializados antes de su uso
DFAStrings.CppDFANullDereferenceDescription=Reporta desreferencias de punteros que pueden contener nullptr
DFAStrings.CppDFANullDereferenceTitle=Desreferencias de punteros que pueden contener nullptr
DFAStrings.CppDFATimeOverDescription=La inspección de flujo de datos ha alcanzado el límite de tiempo o memoria y no puede evaluarse ni en modo sensible al contexto ni en modo insensible al contexto
DFAStrings.CppDFATimeOverTitle=La inspección de flujo de datos se agotó
DFAStrings.CppDFAUnreachableCodeDescription=Reporta piezas de código que nunca se ejecutan en ningún flujo de control y pueden eliminarse de forma segura
DFAStrings.CppDFAUnreachableCodeTitle=Código inalcanzable
DFAStrings.CppDFAUnreachableFunctionCallDescription=Reporta funciones cuyas llamadas nunca se usan. Tales funciones tampoco se ejecutan nunca.
DFAStrings.CppDFAUnreachableFunctionCallTitle=Funciones cuyas llamadas nunca se usan
DFAStrings.CppDFAUnreadVariableDescription=Reporta variables locales que están declaradas pero nunca se acceden para lectura
DFAStrings.CppDFAUnreadVariableTitle=Variables locales que están declaradas pero nunca se acceden para lectura
DFAStrings.CppDFAUnusedValueDescription=Reporta valores de variables que nunca se usan después de ser asignados
DFAStrings.CppDFAUnusedValueTitle=Valores de variables que nunca se usan después de ser asignados
Strings.AClassDefinitionCanBeMarkedAsFinalSoItCannotBeInheritedFrom=La definición de clase puede marcarse como final para que no pueda ser heredada
Strings.AClassIsNeverUsed=Una clase nunca se usa
Strings.ACoroutineRelatedFunctionWhichIsRequiredByTheCStandardCannotBeResolved=No se puede resolver una función relacionada con coroutines requerida por el estándar C++20
Strings.ADeclarationDoesNotDeclareAnything=Una declaración no declara nada
Strings.ADeclarationSpecifierIsIgnoredWhenThereAreNoDeclarators=Se ignora un especificador de declaración cuando no hay declaradores
Strings.ADeclaratorIsNeverUsed=Un declarador nunca se usa
Strings.ADeclaratorIsOnlyAssignedButNeverAccessed=Un declarador solo es asignado pero nunca accedido
Strings.ADeclaratorIsUsedOnlyInUnevaluatedContext=Un declarador solo se usa en contexto no evaluado
Strings.AEnumeratorIsNeverUsed=Un enumerador nunca se usa
Strings.AFormatStringOfBoostFormatContainsALegacyPrintfLikeCodeTypeSpecifierIsNotTakenIntoAccount=Una cadena de formato de boost\:\:format contiene código heredado tipo printf; el especificador de tipo no se tiene en cuenta
Strings.AFormatStringOfBoostFormatContainsAnErroneousFormatCode=Una cadena de formato de boost\:\:format contiene una directiva de formato errónea
Strings.AFunctionDefinitionInAHeaderFileThatWillCauseMultipleDefinitionLinkageError=Una definición de función en un archivo de encabezado que provocará un error de vinculación por definición múltiple
Strings.AFunctionIsNotImplemented=Una función no está implementada
Strings.AFunctionOrALambdaWithNonVoidReturnTypeShouldReturnAValue=Una función o lambda con tipo de retorno no void debe retornar un valor
Strings.AFunctionOrALambdaWithNonVoidReturnTypeShouldReturnAValue8=Una función o lambda con tipo de retorno no void debe retornar un valor
Strings.ALambdaCaptureIsNeverUsed=Una captura lambda nunca se usa
Strings.ALocalDeclarationHidesAnotherLocalDeclaration=Una declaración local oculta otra declaración local
Strings.ALocalDeclarationInsideALambdaHidesAnUncapturedLocalDeclaration=Una declaración local dentro de un lambda oculta una declaración local no capturada
Strings.ALocalVariableMightNotBeInitialized=Una variable local podría no estar inicializada
Strings.ANonOverridingVirtualFunctionInAFinalOrSealedClassCannotBeOverriddenSoThevirtualSpecifierIsRedundant=Una función virtual que no sobrescribe en una clase final o sealed no puede ser sobrescrita, por lo que el especificador 'virtual' es redundante
Strings.ANumericTypeCanBeReplacedWithauto=Un tipo numérico puede reemplazarse con 'auto'
Strings.APolymorphicClassWithANonVirtualPublicDestructor=Una clase polimórfica con un destructor público no virtual
Strings.APrivateSpecialMemberFunctionShouldBeDefinedOrDeleted=Una función miembro especial private debe ser definida o eliminada
Strings.AStandardAlgorithmAcceptingRangeIteratorsIsUsedInsteadOfTheVariantAcceptingAnIteratorAndACount=Se usa un algoritmo estándar que acepta iteradores de rango en lugar de la variante que acepta un iterador y un contador
Strings.ATemplateParameterFromAnOuterScopeIsShadowedByADeclarationWithTheSameName=Un parámetro de template de un ámbito exterior está sombreado por una declaración con el mismo nombre
Strings.ATypeAliasIsNeverUsed=Un alias de tipo nunca se usa
Strings.ATypeTraitCanBeSimplifiedUsingATemplateAliasOrAVariableTemplate=Un type trait puede simplificarse usando un alias de template o una variable template
Strings.AVariableDefinitionInAHeaderFileThatWillCauseMultipleDefinitionLinkageError=Una definición de variable en un archivo de encabezado que provocará un error de vinculación por definición múltiple
Strings.AVirtualFunctionIsMarkedfinalAndDoesNotOverrideABaseFunction=Una función virtual está marcada como 'final' y no sobrescribe una función base
Strings.AbstractFinalClass=Clase abstract final
Strings.AccessSpecifierDoesNotAffectAnyDeclaration=El especificador de acceso no afecta a ninguna declaración
Strings.AccessSpecifierDoesNotChangeAccessibilityLevel=El especificador de acceso no cambia el nivel de accesibilidad
Strings.AddingCvQualifiersToReferencesHasNoEffect=Agregar calificadores cv a referencias no tiene efecto
Strings.AddingCvQualifiersToReferencesHasNoEffect9=Agregar calificadores cv a referencias no tiene efecto
Strings.AlgorithmAcceptingAnIteratorAndACountCanBeUsed=Se puede usar un algoritmo que acepte un iterador y un contador
Strings.AlgorithmAcceptingIteratorsIsUsedInsteadOfTheCorrespondingAlgorithmFromStdRanges=Se usa un algoritmo que acepta iteradores en lugar del algoritmo correspondiente de std\:\:ranges
Strings.AlgorithmOperatingOnRangesCanBeUsed=Se puede usar un algoritmo que opere sobre rangos
Strings.AnAbstractFinalClassIsMarkedAsfinalOrsealed=Una clase abstract final está marcada como 'final' o 'sealed'
Strings.AnAccessSpecifierDoesNotAffectAnyDeclarationAndIsRedundant=Un especificador de acceso no afecta a ninguna declaración y es redundante
Strings.AnAccessSpecifierDoesNotChangeAccessibilityLevelAndIsRedundant=Un especificador de acceso no cambia el nivel de accesibilidad y es redundante
Strings.AnArgumentOfBoostFormatShouldContainEitherPositionalNNOrSerialsArgumentsNotBoth=Un argumento de boost\:\:format debe contener argumentos posicionales (%N%, %|N$...|) o seriales (%|...|, %s), no ambos
Strings.AnIncompleteTypeIsUsedInsideATemplateDeclarationOrDefinition=Se usa un tipo incompleto dentro de una declaración o definición de template
Strings.AnObjectMemberMightNotBeInitialized=Un miembro de objeto podría no estar inicializado
Strings.AnOverrideFunctionRedefinesADefaultParameterArgumentPreviouslyDefinedInABaseFunction=Una función override redefine un argumento de parámetro por defecto previamente definido en una función base
Strings.AwaiterTypeIsNotAClass=El tipo awaiter no es una clase
Strings.BackslashAndNewlineAreSeparatedBySpace=La barra invertida y el salto de línea están separados por un espacio
Strings.BackslashIsNotALineContinuatorBecauseThereIsASpaceBetweenItAndTheEndOfTheLine=La barra invertida no es un continuador de línea porque hay un espacio entre ella y el final de la línea
Strings.BadFormatCodeForBoostFormat=Directiva de formato incorrecta en boost\:\:format
Strings.BinaryOperatorActsOnEqualOperands=El operador binario actúa sobre operandos iguales
Strings.BinaryOperatorActsOnEqualOperands40=El operador binario actúa sobre operandos iguales
Strings.BinaryOperatorActsOnIdenticalOperands=El operador binario actúa sobre operandos idénticos
Strings.BinaryOperatorActsOnIdenticalOperands39=El operador binario actúa sobre operandos idénticos
Strings.BindingRValueToLValueReferenceIsNonStandardMicrosoftCExtension=Vincular r-value a referencia l-value es una extensión no estándar de Microsoft C++
Strings.BindingRValueToLValueReferenceIsNonStandardMicrosoftCExtension2=Vincular r-value a referencia l-value es una extensión no estándar de Microsoft C++
Strings.BracesCanBeSafelyRemovedWithoutChangingCodeSemantics=Las llaves pueden eliminarse de forma segura sin cambiar la semántica del código
Strings.CStyleCastIsUsedInsteadOfACCast=Se usa un cast de estilo C en lugar de un cast de C++
Strings.CStyleCastIsUsedInsteadOfACCast1=Se usa un cast de estilo C en lugar de un cast de C++
Strings.CallOfDeletedCopyConstructorElidedDuringCopyInitializationThisIsNonStandardMicrosoftCExtension=Llamada al constructor de copia eliminado elidida durante la inicialización por copia. Esta es una extensión no estándar de Microsoft C++.
Strings.CallOfDeletedCopyConstructorElidedDuringCopyInitializationThisIsNonStandardMicrosoftCExtension5=Llamada al constructor de copia eliminado elidida durante la inicialización por copia. Esta es una extensión no estándar de Microsoft C++.
Strings.CallToAVirtualFunctionInsideAConstructorDestructorIsResolvedAtCompileTime=La llamada a una función virtual dentro de un constructor/destructor se resuelve en tiempo de compilación
Strings.CallToAVirtualFunctionInsideAConstructorDestructorWillResultInAPureVirtualFunctionCall=La llamada a una función virtual dentro de un constructor/destructor resultará en una llamada a función virtual pura
Strings.CallsToPureVirtualFunctionsInsideConstructorsAndDestructorsAreARuntimeError=Las llamadas a funciones virtuales puras dentro de constructores y destructores resultarán en errores en tiempo de ejecución
Strings.CannotResolveARequiredCoroutineFunction=No se puede resolver una función de corrutina requerida
Strings.CastIsRedundantAndCanBeDeleted=El cast es redundante y puede eliminarse
Strings.CastingFromNullptrToPointerTypeWithReinterpretCastIsNonStandardMicrosoftCExtension=Convertir de nullptr a tipo puntero con reinterpret_cast es una extensión no estándar de Microsoft C++
Strings.CastingFromNullptrToPointerTypeWithReinterpretCastIsNonStandardMicrosoftCExtension1=Convertir de nullptr a tipo puntero con reinterpret_cast es una extensión no estándar de Microsoft C++
Strings.ClassCanBeMadeFinal=La clase puede hacerse final
Strings.ClassConstructorDoesntInitializeAFieldExplicitlyOrImplicitly=El constructor de la clase no inicializa un campo explícita o implícitamente
Strings.ClassIsAbstractButNotExplicitlyDeclaredAsSuch=La clase es abstracta pero no está declarada explícitamente como tal
Strings.ClassIsNeverUsed=La clase nunca se usa
Strings.ClassMemberFunctionHidesANonVirtualFunctionFromABaseClass=La función miembro de clase oculta una función no virtual de una clase base
Strings.ClassMemberFunctionHidingANonVirtualFunctionFromABaseClass=Función miembro de clase que oculta una función no virtual de una clase base
Strings.ClassShouldHaveAUserDefinedConstructorBecauseOfAnUninitializedDataMember=La clase debería tener un constructor definido por el usuario debido a un miembro de datos no inicializado
Strings.ClassShouldHaveAUserDefinedConstructorBecauseOfAnUninitializedDataMember25=La clase debería tener un constructor definido por el usuario debido a un miembro de datos no inicializado
Strings.ComparisonOfUnsignedExpressionWith=Comparación de expresión sin signo con 0
Strings.ComparisonOfUnsignedExpressionWith41=Comparación de expresión sin signo con 0
Strings.CompileTimeConstantExpressionCanBeReplacedByEithertrueOrfalse=La expresión constante en tiempo de compilación puede reemplazarse por 'true' o 'false'
Strings.CompileTimeIntegralConstantExpressionOrNullptrIsConvertedToBoolAndCanBeReplacedBytrueOrfalse=La expresión constante integral en tiempo de compilación o nullptr se convierte a bool y puede reemplazarse por 'true' o 'false'
Strings.ConceptIsNeverUsed=El concepto nunca se usa
Strings.ConstQualificationOfParametersHasAnEffectOnlyInFunctionDefinitions=La calificación const de parámetros solo tiene efecto en definiciones de funciones
Strings.ConstQualifiedParameterInAFunctionDeclaration=Parámetro calificado con const en una declaración de función
Strings.ConstevalIfIsAlwaysConstantDescription=consteval if es siempre constante
Strings.ConstevalIfIsAlwaysConstantTitle=consteval if es siempre constante
Strings.ConstructorOfASmartPointerBoostStdSharedPtrUniquePtrIsUsedInsteadOfTheCorrespondingMakeSharedMakeUniqueMakeFunctionsAreExceptionSafeAndMoreEfficient=Se usa el constructor de un smart pointer (boost/std\:\:shared_ptr/unique_ptr) en lugar de las correspondientes make_shared/make_unique. Las funciones make son seguras contra excepciones y más eficientes.
Strings.ConstructorOfSmartPointerIsUsedInsteadOfItsMakeFunction=Se usa el constructor del smart pointer en lugar de su función make
Strings.CppConditionalExpressionCanBeSimplifiedDescription=La expresión condicional puede simplificarse
Strings.CppConditionalExpressionCanBeSimplifiedTitle=La expresión condicional puede simplificarse
Strings.CppEvaluationFailureDescription=La expresión o valor del declarador no se evaluó a una constante debido a un error durante los cálculos 'constexpr'.
Strings.CppEvaluationFailureTitle=Fallo de evaluación en tiempo de compilación
Strings.CppEvaluationInternalFailureTitle=[INTERNAL] Fallo de evaluación en tiempo de compilación
Strings.CppRedundantComplexityInComparison=La expresión puede simplificarse
Strings.CppRedundantConditionalExpressionDescription=Expresión condicional redundante
Strings.CppRedundantConditionalExpressionTitle=Expresión condicional redundante
Strings.CppRedundantDereferencingAndTakingAddressDescription=Desreferenciación y toma de dirección redundante
Strings.CppRedundantDereferencingAndTakingAddressTitle=Desreferenciación y toma de dirección redundante
Strings.DeclarationAndAssignmentCanBeJoined=La declaración y asignación pueden unirse
Strings.DeclarationDoesNotDeclareAnything=La declaración no declara nada
Strings.DeclarationOfANonOverridingVirtualFunctionInAFinalOrSealedClass=Declaración de una función virtual que no sobrescribe en una clase final o sealed
Strings.DeclarationOfAVariableAndAssignmentToItCanBeJoined=La declaración de una variable y su asignación pueden unirse
Strings.DeclarationSpecifierWithNoDeclarators=Especificador de declaración sin declaradores
Strings.DeclarationSpecifierlongCanNotBeCombinedWithfloat=El especificador de declaración 'long' no puede combinarse con 'float'
Strings.DeclaratorDisambiguatedAsAFunctionDeclaration=Declarador desambiguado como declaración de función
Strings.DeclaratorIsDisambiguatedAsAFunctionDeclarationMakeSureAVariableDefinitionIsNotIntendedInstead=El declarador se desambigua como declaración de función. Asegúrese de que no se pretende una definición de variable en su lugar.
Strings.DeclaratorIsNeverUsed=El declarador nunca se usa
Strings.DeclaratorIsOnlyAssignedButNeverAccessed=El declarador solo se asigna pero nunca se accede
Strings.DeclaratorIsUsedOnlyInUnevaluatedContext=El declarador solo se usa en contexto no evaluado
Strings.DefaultCaseIsNotHandledInASwitchStatement=El case por defecto no está manejado en la sentencia switch
Strings.DefaultCaseIsNotHandledInASwitchStatement20=El case por defecto no está manejado en la sentencia switch
Strings.DefaultInitializationOfAConstQualifiedObjectOfATypeWithoutAUserProvidedDefaultConstructor=Inicialización por defecto de un objeto calificado con const de un tipo sin constructor por defecto proporcionado por el usuario
Strings.DefaultInitializationOfAConstQualifiedObjectOfATypeWithoutAUserProvidedDefaultConstructor3=Inicialización por defecto de un objeto calificado con const de un tipo sin constructor por defecto proporcionado por el usuario
Strings.DefaultedSpecialMemberFunctionIsImplicitlyDeleted=La función miembro especial por defecto está implícitamente eliminada
Strings.DeletingAVoidPointer=Eliminando un puntero void
Strings.DeletingAVoidPointerIsUndefinedBehavior=Eliminar un puntero void es un comportamiento indefinido
Strings.DependentTemplateWithouttemplateKeyword=Template dependiente sin la palabra clave 'template'
Strings.DependentTemplateWithouttemplateKeyword24=Template dependiente sin la palabra clave 'template'
Strings.DependentTypeWithouttypenameKeyword=Tipo dependiente sin la palabra clave 'typename'
Strings.DependentTypeWithouttypenameKeyword23=Tipo dependiente sin la palabra clave 'typename'
Strings.DeprecatedregisterStorageClassSpecifier=Especificador de clase de almacenamiento 'register' obsoleto
Strings.DereferenceOperatorLimitIsExceeded=Se excede el límite del operador de desreferenciación
Strings.DereferenceOperatorLimitIsExceeded10=Se excede el límite del operador de desreferenciación
Strings.DetectsLeakProneResourceAcquisitionFreeingConstructs=Detecta construcciones propensas a fugas en la adquisición/liberación de recursos
Strings.DontIntroduceANamespaceDefinitionOnlyForClassSpecializationSpecializationCanBeDefinedUsingQualifiedClassName=No introduzca una definición de namespace solo para especialización de clase, la especialización puede definirse usando el nombre de clase calificado
Strings.DontIntroduceAVariableBeforeYouNeedToUseIt=No introduzca una variable antes de necesitar usarla
Strings.ElaboratedTypeSpecifierIsRedundantAndCanBeDeleted=El especificador de tipo elaborado es redundante y puede eliminarse
Strings.EmptyParameterListInLambdaDeclaratorCanBeDeleted=La lista de parámetros vacía en el declarador lambda puede eliminarse
Strings.EnforceBracesIndoWhileStatement=Forzar llaves en sentencia 'do-while'
Strings.EnforceBracesInforStatement=Forzar llaves en sentencia 'for'
Strings.EnforceBracesInifStatement=Forzar llaves en sentencia 'if'
Strings.EnforceBracesInwhileStatement=Forzar llaves en sentencia 'while'
Strings.EnforceFunctionDeclarationStyle=Forzar estilo de declaración de función
Strings.EnforceNestedNamespacesStyle=Forzar estilo de namespaces anidados
Strings.EnforceOverridingDestructorStyle=Forzar estilo de destructor que sobrescribe
Strings.EnforceOverridingFunctionStyle=Forzar estilo de función que sobrescribe
Strings.EnforceTheOrderOfCvQualifiers=Forzar el orden de calificadores cv
Strings.EnforceTheOrderOfCvQualifiers_Description=Forzar el orden de calificadores cv
Strings.EnforceThePlacementOfCvQualifiers=Forzar la ubicación de calificadores cv
Strings.EnforceThePlacementOfCvQualifiers_Description=Forzar la ubicación de calificadores cv
Strings.EnforceTheSyntaxUsedToDefineNestedNamespaces=Forzar la sintaxis usada para definir namespaces anidados
Strings.EnforceThevirtualAndoverrideSpecifiersOnOverridingDestructors=Forzar los especificadores 'virtual' y 'override' en destructores que sobrescriben
Strings.EnforceThevirtualAndoverrideSpecifiersOnOverridingFunctions=Forzar los especificadores 'virtual' y 'override' en funciones que sobrescriben
Strings.EnforceTypeAliasCodeStyle=Forzar estilo de código de alias de tipo
Strings.EnforceUsageOfTheTrailingReturnTypeOrTheRegularReturnTypeSyntax=Forzar uso de tipo de retorno trailing o sintaxis regular de tipo de retorno
Strings.EnforceUsageOfTypedefsOrTypeAliasesDependingOnTheSyntaxStyleSetting=Forzar uso de typedefs o alias de tipo según la configuración de estilo de sintaxis
Strings.EntityIsDeprecated=La entidad está obsoleta
Strings.EntityIsDeprecated37=La entidad está obsoleta
Strings.EnumeratorIsNeverUsed=El enumerador nunca se usa
Strings.ExplicitSpecializationInNonNamespaceScope=Especialización explícita en ámbito que no es namespace
Strings.ExplicitSpecializationsOfATemplateInNonNamespaceScope=Especializaciones explícitas de un template en ámbito que no es namespace
Strings.ExplicitlyDefaultedSpecialMemberFunctionIsImplicitlyDeleted=La función miembro especial explícitamente por defecto está implícitamente eliminada
Strings.ExpressionWhichEvaluatesToZeroIsUsedAsANullPointerConstant=Una expresión que se evalúa a cero se usa como constante de puntero nulo
Strings.ExpressionWhichEvaluatesToZeroIsUsedAsANullPointerConstant27=Una expresión que se evalúa a cero se usa como constante de puntero nulo
Strings.FinalFunctionInAFinalClass=Función final en una clase final
Strings.FinalNonOverridingVirtualFunction=Función virtual final que no sobrescribe
Strings.ForExampleWhenIteratingOnKeyValuePairsStdViewsKeysAllowsToIgnoreTheValues=Por ejemplo, al iterar sobre pares clave-valor, std\:\:views\:\:keys permite ignorar los valores.
Strings.ForLoopCanBeReplacedWithWhileLoop=El bucle for puede reemplazarse con un bucle while
Strings.ForLoopWithoutInitStatementAndUpdateExpressionIsEquivalentToWhileLoop=Un bucle for sin declaración de inicialización y expresión de actualización es equivalente a un bucle while
Strings.FormatStringContainsAPotentialError=La cadena de formato contiene un error potencial
Strings.FormatStringContainsAnInvalidPrintfFormatSpecifier=La cadena de formato contiene un especificador de formato printf inválido
Strings.ForwardEnumDeclarationWithoutUnderlyingTypeDescription=ISO C++ prohíbe las declaraciones adelantadas de enum sin tipo subyacente
Strings.ForwardEnumDeclarationWithoutUnderlyingTypeTitle=Declaración adelantada de enum sin tipo subyacente
Strings.FunctionIsNotImplemented=La función no está implementada
Strings.FunctionParameterIsNeverUsed=El parámetro de función nunca se usa
Strings.FunctionResultShouldBeUsedDescription=La función retorna un valor de un tipo que debe ser manejado en el punto de llamada
Strings.FunctionResultShouldBeUsedTitle=El resultado de la función debe ser usado
Strings.FunctionReturnsByConstValue=La función retorna por valor const
Strings.FunctionalStyleCastIsUsedInsteadOfACCast=Se usa un cast de estilo funcional en lugar de un cast de C++
Strings.FunctionalStyleCastIsUsedInsteadOfACCast2=Se usa un cast de estilo funcional en lugar de un cast de C++
Strings.GuardedHeaderHasAlreadyBeenIncluded=La cabecera protegida ya ha sido incluida
Strings.GuardedHeaderHasAlreadyBeenIncluded50=La cabecera protegida ya ha sido incluida
Strings.HidingAnUncapturedLocalDeclaration=Ocultando una declaración local no capturada
Strings.HidingLocalDeclaration=Ocultando declaración local
Strings.IfStatementWithConstantConditionCanBeReplacedByifConstexpr=La sentencia if con condición constante puede reemplazarse por 'if constexpr'
Strings.IfStatementWithConstantConditionCanBeReplacedByifConstexpr14=La sentencia if con condición constante puede reemplazarse por 'if constexpr'
Strings.IfStdIsConstantEvaluatedCanBeReplacedDescription='if' puede reemplazarse por 'if consteval'
Strings.IfStdIsConstantEvaluatedCanBeReplacedTitle='if' puede reemplazarse por 'if consteval'
Strings.ImplicitConversionToIncompatiblePointerType=Conversión implícita a tipo de puntero incompatible
Strings.ImplicitConversionToIncompatiblePointerType32=Conversión implícita a tipo de puntero incompatible
Strings.ImplicitConversionToLessQualifiedPointerType=Conversión implícita a tipo de puntero con pérdida de calificadores
Strings.ImplicitConversionToLessQualifiedPointerType33=Conversión implícita a tipo de puntero con pérdida de calificadores
Strings.ImplicitDefaultConstructorIsNotAvailable=El constructor por defecto implícito no está disponible
Strings.ImplicitDefaultConstructorIsNotAvailableBecauseABaseClassOrAClassMemberDoesNotHaveAnAccessibleDefaultConstructor=El constructor por defecto implícito no está disponible porque una clase base o un miembro de clase no tiene un constructor por defecto accesible
Strings.ImplicitIntegerToPointerConversion=Conversión implícita de entero a puntero
Strings.ImplicitIntegerToPointerConversion30=Conversión implícita de entero a puntero
Strings.ImplicitPointerToIntegerConversion=Conversión implícita de puntero a entero
Strings.ImplicitPointerToIntegerConversion31=Conversión implícita de puntero a entero
Strings.InHLSLoutParametersMustBeAssignedBeforeExitingTheFunction=En HLSL los parámetros 'out' deben ser asignados antes de salir de la función
Strings.IncludeGuardIsNotFoundAtTheBeginningOfAHeaderFile=No se encuentra include guard al inicio del archivo de cabecera
Strings.InconsistentNaming_Description=El nombre no coincide con el estilo de nomenclatura definido para este tipo de símbolo
Strings.InconsistentNaming_Text=Nomenclatura Inconsistente
Strings.IncorrectSpacing=Espaciado incorrecto
Strings.IncrementingExpressionOfTypeBool=Incrementando expresión de tipo bool
Strings.IncrementingExpressionOfTypeBoolIsDeprecatedInCAndRemovedInC=Incrementar expresión de tipo bool está obsoleto en C++11 y eliminado en C++17
Strings.InvalidPrintfFormatSpecifier=Especificador de formato printf inválido
Strings.KeyworddefaultIsUsedAsIdentifier=La palabra clave 'default' se usa como identificador
Strings.LambdaCanBeRewrittenToUseExplicitTemplateParameters=Lambda puede reescribirse para usar parámetros de plantilla explícitos
Strings.LambdaCanBeRewrittenToUseExplicitTemplateParameters19=Lambda puede reescribirse para usar parámetros de plantilla explícitos
Strings.LambdaCaptureIsNeverUsed=La captura lambda nunca se usa
Strings.LegacyFormatCodeForBoostFormat=Directiva de formato obsoleta en boost\:\:format
Strings.LocalVariableCanBeMadeConst=La variable local puede hacerse const
Strings.LocalVariableCanBeMadeConst8=La variable local puede hacerse const
Strings.LocalVariableIsNeverUsedButMayHaveSideEffectsInItsDestructor=La variable local nunca se usa, pero puede tener efectos secundarios en su destructor
Strings.LocalVariableIsNeverUsedButMayHaveSideEffectsInItsDestructor4=La variable local nunca se usa, pero puede tener efectos secundarios en su destructor
Strings.LocalVariableMightNotBeInitialized=La variable local podría no estar inicializada
Strings.LocalVariableUsedWithoutBeingInitialized=La variable local se usa sin estar inicializada
Strings.LocalVariableUsedWithoutBeingInitialized5=La variable local se usa sin estar inicializada
Strings.MayBeMissingKeywordthrow=Puede faltar la palabra clave 'throw'
Strings.MemberFunctionCanBeMadeConst=La función miembro puede hacerse const
Strings.MemberFunctionCanBeMadeConst6=La función miembro puede hacerse const
Strings.MemberFunctionCanBeMadeStatic=La función miembro puede hacerse static
Strings.MemberFunctionCanBeMadeStatic7=La función miembro puede hacerse static
Strings.MethodMustBePublicAndVirtualToImplementACCLIInterfaceMember=El método debe ser public y virtual para implementar un miembro de interfaz C++/CLI
Strings.MethodMustBePublicAndVirtualToImplementACCLIInterfaceMember29=El método debe ser public y virtual para implementar un miembro de interfaz C++/CLI
Strings.MismatchedClassTags=Etiquetas de clase no coincidentes
Strings.MissingFunctionParameterDescriptionInADocumentationComment=Falta descripción del parámetro de función en un comentario de documentación
Strings.MissingFunctionParameterDescriptionInADocumentationComment38=Falta descripción del parámetro de función en un comentario de documentación
Strings.MissingIncludeGuard=Falta include guard
Strings.MixedSerialAndPositionalArgumentsForBoostFormat=Argumentos posicionales y no posicionales en la misma llamada a boost\:\:format
Strings.MoreThanOneImplicitConversionAppliedDuringCopyInitializationThisIsNonStandardMicrosoftCExtension=Más de una conversión implícita aplicada durante la inicialización por copia. Esta es una extensión no estándar de Microsoft C++.
Strings.MoreThanOneImplicitConversionAppliedDuringCopyInitializationThisIsNonStandardMicrosoftCExtension4=Más de una conversión implícita aplicada durante la inicialización por copia. Esta es una extensión no estándar de Microsoft C++.
Strings.MultiCharacterLiteralDescription=Literal de carácter multi-carácter
Strings.MultiCharacterLiteralTitle=Literal de carácter multi-carácter
Strings.MultiCharacterWideLiteralDescription=Literal de carácter ancho multi-carácter
Strings.MultiCharacterWideLiteralTitle=Literal de carácter ancho multi-carácter
Strings.NamespaceDefinitionContainingSingleClassSpecialization=Definición de namespace que contiene una única especialización de clase
Strings.NoCorrespondingFileWithThePrecompiledHeaderPropertySetToCreateYcIsFound=No se encuentra archivo correspondiente con la propiedad 'Precompiled Header' establecida en 'Create' (/Yc)
Strings.NoReturnStatementInAFunctionOrALambdaReturningNonVoid=No hay sentencia return en una función o lambda que retorna non-void
Strings.NoReturnStatementInAFunctionOrALambdaWithNonVoidReturnType=No hay sentencia return en una función o lambda con tipo de retorno non-void
Strings.NoTypeSpecifierFoundInADeclarationDefaultsToint=No se encontró especificador de tipo en la declaración. Por defecto es 'int'.
Strings.NodiscardCannotBeAppliedToFunctionsWithoutAReturnValue=[[nodiscard]] no puede aplicarse a funciones sin valor de retorno
Strings.NonExplicitConversionOperator=Operador de conversión no explícito
Strings.NonExplicitConversionOperator5=Operador de conversión no explícito
Strings.NonExplicitConvertingConstructor=Constructor de conversión no explícito
Strings.NonExplicitConvertingConstructor4=Constructor de conversión no explícito
Strings.NonInlineFunctionDefinitionInAHeaderFile=Definición de función no inline en un archivo de cabecera
Strings.NonInlineVariableDefinitionInAHeaderFile=Definición de variable no inline en un archivo de cabecera
Strings.NonSafeResourceAcquisition=Adquisición de recursos no segura
Strings.NonStaticDataMemberIsUninitialized=Miembro de datos no estático sin inicializar
Strings.NonStaticDataMemberIsUninitialized26=Miembro de datos no estático sin inicializar
Strings.NonVirtualClassMemberFunctionHiddenInADerivedClass=Función miembro de clase no virtual oculta en una clase derivada
Strings.NonVirtualClassMemberFunctionIsHiddenInADerivedClass=Función miembro de clase no virtual está oculta en una clase derivada
Strings.NotAllControlPathsInsideAFunctionOrALambdaReturnAValue=No todos los caminos de control dentro de una función o lambda retornan un valor
Strings.NotAllControlPathsReturnAValue=No todos los caminos de control retornan un valor
Strings.NotEnoughArgumentsInACallToBoostFormat=No hay suficientes argumentos en la llamada a boost\:\:format
Strings.NotEnoughArgumentsInACallToBoostFormat36=No hay suficientes argumentos en la llamada a boost\:\:format
Strings.NotEnoughArgumentsInACallToPrintf=No hay suficientes argumentos en la llamada a printf
Strings.NotEnoughArgumentsInACallToPrintfSomeFormatCodesDoNotHaveAMatchingArgument=No hay suficientes argumentos en la llamada a printf. Algunas directivas de formato no tienen argumentos coincidentes.
Strings.NotInitializedStaticConstLocalVariableOfScalarTypeThisIsNonStandardMicrosoftCExtension=Variable local static const de tipo escalar no inicializada. Esta es una extensión no estándar de Microsoft C++.
Strings.NumericTypeCanBeReplacedWithAuto=El tipo numérico puede reemplazarse con auto
Strings.ObjectMemberMightNotBeInitialized=El miembro del objeto podría no estar inicializado
Strings.ObjectOfExceptionTypeIsCreatedButIsNotThrown=Se crea un objeto de tipo excepción, pero no se lanza
Strings.OrderOfIncludeDirectivesDoesNotMatchCodeStyleSettings=El orden de las directivas \#include no coincide con la configuración de estilo de código
Strings.OrderOfIncludeDirectivesDoesNotMatchCodeStyleSettings1=El orden de las directivas \#include no coincide con la configuración de estilo de código
Strings.OrderOfMemberInitializersDoesNotMatchTheInitializationOrder=El orden de los inicializadores de miembros no coincide con el orden de inicialización
Strings.OrderOfMemberInitializersDoesNotMatchTheInitializationOrder3=El orden de los inicializadores de miembros no coincide con el orden de inicialización
Strings.OverrideFunctionRedefinesADefaultParameterArgument=La función override redefine un argumento de parámetro por defecto
Strings.ParameterCanBeMadeConst=El parámetro puede hacerse const
Strings.ParameterCanBeMadeConst9=El parámetro puede hacerse const
Strings.ParameterCanBeMadePointerReferenceToConst=El parámetro puede hacerse puntero/referencia a const
Strings.ParameterCanBeMadePointerReferenceToConst11=El parámetro puede hacerse puntero/referencia a const
Strings.ParameterIsNeverUsed=El parámetro nunca se usa
Strings.ParameterNamesDifferInDifferentDeclarationsOfTheSameFunction=Los nombres de parámetros difieren en diferentes declaraciones de la misma función
Strings.ParameterNamesDoNotMatch=Los nombres de parámetros no coinciden
Strings.ParenthesesDontChangeOrderOfOperationsAndCanBeDeleted=Los paréntesis no cambian el orden de las operaciones y pueden eliminarse
Strings.PassValueParameterByConstReferenceDescription=El parámetro de un tipo costoso de copiar se pasa por valor, pero puede pasarse por referencia const.
Strings.PassValueParameterByConstReferenceTitle=Pasar parámetros por referencia const
Strings.PolymorphicClassWithNonVirtualPublicDestructor=Clase polimórfica con destructor público no virtual
Strings.PossiblyErroneousEmptyStatement=Posible sentencia vacía errónea
Strings.PossiblyErroneousEmptyStatementUsedInAControlStatement=Posible sentencia vacía errónea usada en una sentencia de control
Strings.PossiblyErroneousExpressionWithoutSideEffects=Posible expresión errónea sin efectos secundarios
Strings.PossiblyErroneousExpressionWithoutSideEffects21=Posible expresión errónea sin efectos secundarios
Strings.PossiblyErroneousIncompleteSwitchStatement=Posible sentencia switch incompleta errónea
Strings.PossiblyInvalidPrintfFormatSpecifier=Posible especificador de formato printf inválido
Strings.PossiblyUninitializedClassMember=Posible miembro de clase no inicializado
Strings.PossiblyUninitializedDependentBaseClass=Posible clase base dependiente no inicializada
Strings.PossiblyUnintendedIncompatibleReferenceTypeInRangeDeclaration=Posible tipo de referencia incompatible no intencionado en declaración de rango
Strings.PossiblyUnintendedObjectSlicing=Posible object slicing no intencionado
Strings.PossiblyUnintendedObjectSlicing28=Posible object slicing no intencionado
Strings.PossiblyUnusedIncludeDirective=Posible directiva \#include no utilizada
Strings.PossiblyUnusedIncludeDirective7=Posible directiva \#include no utilizada
Strings.PragmaEndRegionIsMissingAMatchingEndRegionDescription=A una directiva '\#pragma endregion' le falta una directiva '\#pragma region' correspondiente
Strings.PragmaEndRegionIsMissingAMatchingEndRegionTitle=Falta una directiva '\#pragma region' correspondiente
Strings.PragmaRegionIsMissingAMatchingEndRegionDescription=A una directiva '\#pragma region' le falta una directiva '\#pragma endregion' correspondiente
Strings.PragmaRegionIsMissingAMatchingEndRegionTitle=Falta una directiva '\#pragma endregion' correspondiente
Strings.PrecompiledHeaderIsNotFound=No se encuentra el encabezado precompilado
Strings.PrecompiledHeaderIsNotIncluded=No se incluye el encabezado precompilado
Strings.PrecompiledHeaderMustBeIncludedAtTheTopOfSourceFile=El encabezado precompilado debe incluirse al principio del archivo fuente
Strings.PrivateSpecialMemberFunctionIsNotImplemented=Función miembro especial privada no implementada
Strings.ProhibitsTheUseOfTabulationCharacterEverywhereInFile=Prohíbe el uso del carácter de tabulación en todo el archivo
Strings.QualifierIsRedundantAndCanBeDeleted=El calificador es redundante y puede eliminarse
Strings.RedeclarationOfATemplateParameterFromAnOuterScope=Redeclaración de un parámetro de plantilla desde un ámbito exterior
Strings.RedundantArgumentInConditionalExpression=Argumento redundante en expresión condicional
Strings.RedundantArgumentInConditionalExpression54=Argumento redundante en expresión condicional
Strings.RedundantBaseClassAccessSpecifier=Especificador de acceso de clase base redundante
Strings.RedundantBaseClassAccessSpecifier53=Especificador de acceso de clase base redundante
Strings.RedundantBaseClassInitializerDescription=Inicializador de clase base redundante en lista de inicializadores de miembros
Strings.RedundantBaseClassInitializerTitle=Inicializador de clase base redundante
Strings.RedundantCastExpression=Expresión de cast redundante
Strings.RedundantControlFlowJumpStatement=Sentencia de salto de flujo de control redundante
Strings.RedundantControlFlowJumpStatement47=Sentencia de salto de flujo de control redundante
Strings.RedundantElaboratedTypeSpecifier=Especificador de tipo elaborado redundante
Strings.RedundantEmptyDeclaration=Declaración vacía redundante
Strings.RedundantEmptyDeclaration49=Declaración vacía redundante
Strings.RedundantEmptyStatement=Sentencia vacía redundante
Strings.RedundantEmptyStatement48=Sentencia vacía redundante
Strings.RedundantExportKeywordMessage=La palabra clave 'export' es redundante porque existe una declaración export envolvente
Strings.RedundantMemberInitializerInConstructorInitializationList=Inicializador de miembro redundante en lista de inicialización del constructor
Strings.RedundantMemberInitializerInConstructorInitializationList56=Inicializador de miembro redundante en lista de inicialización del constructor
Strings.RedundantParameterListInLambdaDeclarator=Lista de parámetros redundante en declarador lambda
Strings.RedundantParentheses=Paréntesis redundantes
Strings.RedundantQualifier=Calificador redundante
Strings.RedundantStaticSpecifierOnThreadLocalLocalVariableDescription=Especificador 'static' redundante en variable local 'thread_local'
Strings.RedundantStaticSpecifierOnThreadLocalLocalVariableTitle=Especificador 'static' redundante en variable local 'thread_local'
Strings.RedundantTemplateArguments=Argumentos de plantilla redundantes
Strings.RedundantVoidArgumentList=Lista de argumentos void redundante
Strings.RedundantVoidArgumentList55=Lista de argumentos void redundante
Strings.RedundantWhitespaceCharactersAtTheEndOfALine=Caracteres de espacio en blanco redundantes al final de la línea
Strings.RedundantWhitespacesAtTheEndOfALine=Espacios en blanco redundantes al final de la línea
Strings.RedundantZeroInitializerInAggregateInitializationMessage=Inicializador cero redundante en inicialización agregada
Strings.RedundantconstSpecifier=Especificador 'const' redundante
Strings.RedundantelseKeyword=Palabra clave 'else' redundante
Strings.RedundantelseKeyword45=Palabra clave 'else' redundante
Strings.RedundantelseKeywordInsideCompoundStatement=Palabra clave 'else' redundante dentro de sentencia compuesta
Strings.RedundantelseKeywordInsideCompoundStatement46=Palabra clave 'else' redundante dentro de sentencia compuesta
Strings.RedundantfinalSpecifierOnAFunctionInAFinalClass=Especificador 'final' redundante en función de clase final
Strings.RedundantinlineSpecifier=Especificador 'inline' redundante
Strings.RedundantstaticSpecifierOnAMemberAllocationDeallocationFunction=Especificador 'static' redundante en función miembro de allocation/deallocation
Strings.RedundantstaticSpecifierOnAnAnonymousNamespaceMember=Especificador 'static' redundante en miembro de namespace anónimo
Strings.RedundantstaticSpecifierOnAnAnonymousNamespaceMember52=Especificador 'static' redundante en miembro de namespace anónimo
Strings.RedundanttemplateKeyword=Palabra clave 'template' redundante
Strings.RedundanttemplateKeyword43=Palabra clave 'template' redundante
Strings.RedundanttypenameKeyword=Palabra clave 'typename' redundante
Strings.RedundanttypenameKeyword42=Palabra clave 'typename' redundante
Strings.ReferenceClassMemberWithmutableSpecifier=Miembro de clase referencia con especificador 'mutable'
Strings.ReferenceClassMembersCannotHavemutableSpecifier=Los miembros de clase referencia no pueden tener especificador 'mutable'
Strings.ReinterpretCastIsUsedInsteadOfAStaticCast=Se usa reinterpret_cast en lugar de static_cast
Strings.ReinterpretCastIsUsedInsteadOfAStaticCast3=Se usa reinterpret_cast en lugar de static_cast
Strings.RemoveRedundantBraces=Eliminar llaves redundantes
Strings.ResultOfAPostfixOperatorIsDiscarded=Se descarta el resultado de un operador postfijo
Strings.ResultOfAPostfixOperatorIsDiscardedItMightBeMoreEfficientToUseAPrefixFormOfTheOperator=Se descarta el resultado de un operador postfijo. Podría ser más eficiente usar la forma prefija del operador.
Strings.ResultOfAssignmentIsUsedAsCondition=El resultado de una asignación se usa como condición
Strings.ResultOfNodiscardFunctionIsNotUsed=No se usa el resultado de una función nodiscard
Strings.ResultOfNodiscardFunctionIsNotUsed22=No se usa el resultado de una función nodiscard
Strings.ReturningFromAFunctionByConstValueIsUsuallyNotBeneficialConsiderReturningValuesAsNonConstToTakeAdvantageOfMoveSemantics=Retornar desde una función por valor const generalmente no es beneficioso. Considere retornar valores como non-const para aprovechar la semántica de movimiento.
Strings.SlashSymbolUsedInIncludeDirectiveDoesntMatchCodeStyleSettings=El símbolo de barra en la directiva \#include no coincide con la configuración de estilo de código
Strings.SlashSymbolUsedInIncludeDirectiveDoesntMatchCodeStyleSettings2=El símbolo de barra en la directiva \#include no coincide con la configuración de estilo de código
Strings.SomeObjectMembersMightNotBeInitialized=Algunos miembros del objeto podrían no estar inicializados
Strings.SpecialFunctionDoesntHaveAnyNoexceptSpecification=La función especial no tiene ninguna especificación noexcept
Strings.SpecialFunctionWithoutNoexceptSpecification=Función especial sin especificación noexcept
Strings.StaticAssertFailedDescription=static_assert falló
Strings.StaticAssertFailedTitle=static_assert falló
Strings.StaticDataMemberInAnAnonymousClassIsNotAllowedByTheCStandard=El estándar C++ no permite miembros de datos static en una clase anónima
Strings.StaticDataMembersAreNotAllowedInAnonymousClasses=No se permiten miembros de datos static en clases anónimas
Strings.StdIsConstantEvaluatedWillAlwaysEvaluateToConstantDescription='std\:\:is_constant_evaluated' siempre se evaluará como constante
Strings.StdIsConstantEvaluatedWillAlwaysEvaluateToConstantTitle='std\:\:is_constant_evaluated' siempre se evaluará como constante
Strings.StdSizeCanBeUsed=Se puede usar std\:\:size
Strings.StdSizeIsTypeSafeAlternativeToCIdiomForArraySizeCalculation=std\:\:size es una alternativa type-safe al idioma C para calcular el tamaño del array
Strings.StdViewsKeysValuesCanBeUsed=Se puede usar std\:\:views\:\:keys/values
Strings.StringLiteralToCharPointerConversion=Conversión de literal de cadena a puntero char
Strings.StringLiteralToCharPointerConversion34=Conversión de literal de cadena a puntero char
Strings.StructuredBindingCanBeUsed=Se puede usar structured binding
Strings.StructuredBindingCanBeUsed15=Se puede usar structured binding
Strings.StructuredBindingCanBeUsedInsteadOfTie=Se puede usar structured binding en lugar de tie(..)
Strings.SyntaxErrorInADoxygenComment=Error de sintaxis en comentario doxygen
Strings.SyntaxErrorInDoxygenComment=Error de sintaxis en comentario doxygen
Strings.TabsAreProhibited=Las tabulaciones están prohibidas
Strings.TagsOfTheDeclaredClassDoNotMatchPreviousDeclarations=Las etiquetas de la clase declarada no coinciden con las declaraciones anteriores
Strings.TakingAnAddressOfClassRValueIsNonStandardMicrosoftCExtension=Tomar la dirección de un r-value de clase es una extensión no estándar de Microsoft C++
Strings.TakingAnAddressOfClassRValueIsNonStandardMicrosoftCExtension3=Tomar la dirección de un r-value de clase es una extensión no estándar de Microsoft C++
Strings.TemplateArgumentsCanBeDeduced=Los argumentos de plantilla pueden ser deducidos
Strings.TemplateParameterIsNeverUsedDescription=Un parámetro de plantilla nunca se usa
Strings.TemplateParameterIsNeverUsedTitle=El parámetro de plantilla nunca se usa
Strings.TheAwaiterTypeMustBeAAClassAccordingToTheCStandard=El tipo awaiter debe ser una clase según el estándar C++20
Strings.TheClassIsAbstractButNotExplicitlyDeclaredAsSuch=La clase es abstract pero no está declarada explícitamente como tal
Strings.TheNodiscardAttributeCannotBeAppliedToFunctionsWithoutAReturnValue=El atributo [[nodiscard]] no puede aplicarse a funciones sin valor de retorno
Strings.TheSwitchStatementDoesntCoverTheWholeRangeOfTheEnumerationUsed=La sentencia switch no cubre todo el rango de la enumeración utilizada
Strings.TheconstSpecifierOnAVariableDefinitionIsRedundant=El especificador 'const' en la definición de variable es redundante
Strings.TheinlineSpecifierOnAFunctionDefinitionIsRedundant=El especificador 'inline' en la definición de función es redundante
Strings.TheoutParameterMustBeAssigned=Se debe asignar el parámetro 'out'
Strings.TheregisterStorageClassSpecifierIsDeprecatedInCAndRemovedInC=El especificador de clase de almacenamiento 'register' está obsoleto en C++11 y eliminado en C++17
Strings.ThestaticSpecifierIsOptionalForMemberAllocationDeallocationFunctions=El especificador 'static' es opcional para funciones miembro de asignación/liberación
Strings.ThrowExpressionCanBeReplacedWithARethrowExpression=La expresión throw puede reemplazarse con una expresión rethrow
Strings.ThrowExpressionCanBeReplacedWithARethrowExpression12=La expresión throw puede reemplazarse con una expresión rethrow
Strings.TooManyArgumentsInACallToBoostFormat=Demasiados argumentos en la llamada a boost\:\:format
Strings.TooManyArgumentsInACallToBoostFormatSomeOfTheArgumentsAreNotUsed=Demasiados argumentos en la llamada a boost\:\:format. Algunos argumentos no se utilizan.
Strings.TooManyArgumentsInACallToPrintf=Demasiados argumentos en la llamada a printf
Strings.TooManyArgumentsInACallToPrintfSomeOfTheArgumentsAreNotUsed=Demasiados argumentos en la llamada a printf. Algunos argumentos no se utilizan.
Strings.TypeAliasIsNeverUsed=El alias de tipo nunca se usa
Strings.TypeCanBeReplacedWithAuto=El tipo puede reemplazarse con auto
Strings.TypeCanBeReplacedWithauto4=El tipo puede reemplazarse con 'auto'
Strings.TypeSpecifierMissingDefaultsToInt=Falta el especificador de tipo, por defecto es int
Strings.TypeTraitCanBeSimplifiedUsingATemplateAliasOrAVariableTemplate=El type trait puede simplificarse usando un alias de plantilla o una plantilla de variable
Strings.UninitializedDependentBaseClass=Clase base dependiente no inicializada
Strings.UnionMemberOfReferenceType=Miembro de unión de tipo referencia
Strings.UnionsCannotContainNonStaticDataMembersOfReferenceTypes=Las uniones no pueden contener miembros de datos no static de tipos referencia
Strings.UnnamedNamespaceInAHeaderFile=Namespace sin nombre en archivo de cabecera
Strings.UnnamedNamespacesShouldNotBeUsedInHeaderFiles=No se deben usar namespaces sin nombre en archivos de cabecera
Strings.UnresolvedReferenceInADoxygenComment=Referencia no resuelta en comentario doxygen
Strings.UnresolvedReferenceInDoxygenComment=Referencia no resuelta en comentario doxygen
Strings.UseBracesToSeparatedoWhileStatementBody=Usar llaves para separar el cuerpo de la sentencia 'do-while'
Strings.UseBracesToSeparateforStatementBody=Usar llaves para separar el cuerpo de la sentencia 'for'
Strings.UseBracesToSeparateifStatementBody=Usar llaves para separar el cuerpo de la sentencia 'if'
Strings.UseBracesToSeparatewhileStatementBody=Usar llaves para separar el cuerpo de la sentencia 'while'
Strings.UseOfAnIncompleteTypeInsideATemplate=Uso de tipo incompleto dentro de una plantilla
Strings.UsePreferredBracesStyle=Usar estilo de llaves preferido
Strings.UsePreferredCvQualifiersStyle=Usar estilo preferido de calificadores cv
Strings.UsePreferredDeclarationStyle=Usar estilo preferido de declaración
Strings.UsePreferredIncludeDirectiveStyle=Usar estilo preferido de directiva include
Strings.UsePreferredInitializationStyle=Usar estilo preferido de inicialización
Strings.UsePreferredOverridingFunctionStyle=Usar estilo preferido de función override
Strings.UsePreferredautoStyle=Usar estilo preferido de 'auto'
Strings.UserDefinedLiteralSuffixesMustStartWithAnUnderscore=Los sufijos de literales definidos por el usuario deben comenzar con guion bajo
Strings.UserDefinedLiteralSuffixesMustStartWithAnUnderscoreTheSuffixesThatDoNotBeginWithAnUnderscoreAreReservedForTheLiteralOperatorsProvidedByTheStandardLibrary=Los sufijos de literales definidos por el usuario deben comenzar con guion bajo. Los sufijos que no comienzan con guion bajo están reservados para los operadores literales proporcionados por la biblioteca estándar.
Strings.UsingAnIncompatibleReferenceTypeInTheRangeDeclarationIsLikelyToCauseUnwantedObjectCopying=Usar un tipo de referencia incompatible en la declaración de rango probablemente cause copias de objetos no deseadas
Strings.VariableCanBeMadeConstexpr=La variable puede convertirse en constexpr
Strings.VariableCanBeMadeConstexpr10=La variable puede convertirse en constexpr
Strings.VariableCanBeMovedToInitStatement=La variable puede moverse a la sentencia init
Strings.VariableCanBeMovedToInnerScope=La variable puede moverse al ámbito interno
Strings.VolatileQualificationOfParametersHasAnEffectOnlyInFunctionDefinitions=La calificación volatile de parámetros solo tiene efecto en definiciones de función
Strings.VolatileQualifiedParameterInAFunctionDeclaration=Parámetro calificado como volatile en declaración de función
Strings.WarningDirectiveDescription=Directiva de preprocesador \#warning
Strings.WarningDirectiveTitle=Directiva \#warning
Strings.ZeroConstantCanBeReplacedWithNullptr=La constante cero puede reemplazarse con nullptr
Strings.ZeroConstantCanBeReplacedWithNullptr13=La constante cero puede reemplazarse con nullptr
Strings.ZeroInitializationCanBeUsedInsteadOfMemset=Se puede usar inicialización a cero en lugar de memset
Strings.ZeroInitializationCanBeUsedInsteadOfMemset16=Se puede usar inicialización a cero en lugar de memset
Strings.containsMemberFunctionCanBeUsed=Se puede usar la función miembro 'contains'
Strings.containsMemberFunctionCanBeUsed17=Se puede usar la función miembro 'contains'
Strings.defaultIsAKeywordInTheCStandardAndCannotBeUsedAsAnIdentifier='default' es una palabra clave en el estándar C++ y no puede usarse como identificador
Strings.longFloatsAreNotAllowedByTheCStandard=Los números flotantes 'long' no están permitidos por el estándar C++
Strings.stdErasestdEraseIfCanBeUsedInsteadOfTheRemoveEraseIdiom=Se puede usar 'std\:\:erase'/'std\:\:erase_if' en lugar del idioma remove-erase
Strings.stdErasestdEraseIfCanBeUsedInsteadOfTheRemoveEraseIdiom18=Se puede usar 'std\:\:erase'/'std\:\:erase_if' en lugar del idioma remove-erase