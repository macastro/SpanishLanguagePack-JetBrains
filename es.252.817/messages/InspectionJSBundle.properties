add.require.amd.module.fix=Agregar dependencia de módulo {0}
add.require.amd.module.group.name=Módulo Node.js
add.return.statement.fix.name=Añadir instrucción de retorno
anonymous.function.contains.multiple.loops.error.string=#ref contiene {0} loops #loc
anonymous.function.contains.multiple.return.points.error.string=#ref tiene {0} puntos de retorno #loc
anonymous.function.contains.too.many.negation.error.string=#ref contiene {0} negaciones #loc
anonymous.function.display.name=Función anónima
anonymous.function.error.string=Función anónima #loc
anonymous.function.has.inconsistent.return.points.error.string=#ref tiene puntos de retorno inconsistentes #loc
anonymous.function.has.too.many.parameters.error.string=La función anónima #ref tiene demasiados parámetros (cuenta de parámetros = {0}) #loc
anonymous.function.is.overly.complex.cyclomatic.complexity.error.string=#ref es excesivamente compleja (complejidad ciclomática = {0}) #loc
anonymous.function.is.overly.long.statement.error.string=#ref es excesivamente larga (cuenta de declaraciones = {0}) #loc
anonymous.function.is.overly.nested.error.string=#ref está anidado en exceso (profundidad de anidamiento: {0}, pero el máximo permitido es: {1}) #loc
assignment.replaceable.with.operator.assignment.display.name=La asignación podría sustituirse por la asignación del operador
assignment.replaceable.with.operator.assignment.error.string=#ref se puede simplificar a {0} #loc
assignment.to.for.loop.parameter.display.name=Asignación al parámetro del bucle 'for'
assignment.to.for.loop.parameter.error.string=Asignación al parámetro #ref del bucle for #loc
assignment.to.function.parameter.display.name=Asignación al parámetro de función
assignment.to.function.parameter.error.string=Asignación al parámetro de función '#ref' Nº#loc
break.statement.display.name='break' sentencia
break.statement.error.string=Sentencia '#ref' #loc
break.statement.with.label.display.name=sentencia 'break' con etiqueta
break.statement.with.label.error.string='etiqueta #ref' en la sentencia #loc
call.to.document.write.display.name=Llamada a 'document.write()'
caller.display.name=Uso de la propiedad 'caller'
caller.error.string=Uso de la propiedad '#ref' #loc
chained.equality.display.name=Igualdad encadenada
chained.equality.error.string=Comparación en cadena <code>#ref</code> #loc
chained.function.call.display.name=Llamada a función encadenada
chained.function.call.problem.descriptor=Llamada encadenada a la función '#ref' #loc
class.name.doesnt.match.regex.error.string=El nombre de la clase ''{0}'' no coincide con la expresión regular ''{1}'' #loc
class.name.is.too.long.error.string=El nombre de clase ''{0}'' es demasiado largo #loc
class.name.is.too.short.error.string=El nombre de la clase ''{0}'' es demasiado corto #loc
class.naming.convention.display.name=Convención de nomenclatura de clases
collapse.conditional.expression.fix=Contraer expresión condicional
collapse.if.statement.fix=Contraer declaración 'if'
comma.expression.display.name=Expresión de coma
comma.expression.error.string=Expresión de coma #loc
conditional.expression.display.name=Expresión condicional
conditional.expression.error.string=Expresión condicional #loc
conditional.expression.with.identical.branches.display.name=Expresión condicional con ramas idénticas
conditional.expression.with.identical.branches.error.string=Expresión condicional <code>#ref</code> con ramas idénticas #loc
confusing.floating.point.literal.change.quickfix=Cambiar a forma canónica
confusing.floating.point.literal.display.name=Literal de coma flotante confuso
confusing.floating.point.literal.problem.descriptor=Confuso literal de punto flotante <code>#ref</code> #loc
confusing.pluses.or.minuses.display.name=Secuencia confusa de '+' o '-'
confusing.pluses.or.minuses.error.string=La secuencia de '+' o '-' puede cambiar de significado si se elimina el espacio en blanco #loc
constant.conditional.expression.display.name=Expresión condicional constante
constant.conditional.expression.error.string=El <code>#ref</code> se puede simplificar <code>#loc</code>
constant.on.left.side.of.comparison.display.name=Constante en lado izquierdo de comparación
constant.on.left.side.of.comparison.error.string=#ref: constante en el lado izquierdo de la comparación #loc
constant.on.right.side.of.comparison.display.name=Constante en el lado derecho de la comparación
constant.on.right.side.of.comparison.error.string=#ref: Constante en el lado derecho de la comparación #loc
constructor.name.doesnt.match.regex.error.string=El nombre del constructor ''{0}'' no coincide con la expresión regular ''{1}'' #loc
constructor.name.is.too.long.error.string=El nombre del constructor ''{0}'' es demasiado largo #loc
constructor.name.is.too.short.error.string=El nombre del constructor ''{0}'' es demasiado corto #loc
continue.or.break.inside.finally.block.display.name='continuar' o 'romper' dentro del bloque 'final'
continue.or.break.inside.finally.block.error.string='#ref' dentro del bloque 'finally' #loc
continue.statement.display.name=declaración continue
continue.statement.error.string='continue' sentencia #loc
continue.statement.with.label.display.name=sentencia 'continue' con etiqueta
continue.statement.with.label.error.string=Sentencia '#ref' con etiqueta #loc
debugger.statement.display.name='sentencia 'debugger''
debugger.statement.error.string='ref' sentencia #loc
default.branch.not.last.case.in.switch.error.string=La rama <code>#ref</code> no es el último caso en 'switch' #loc
default.not.last.case.in.switch.display.name='default' no es el último caso en 'switch'
divide.by.zero.display.name=División por cero
division.by.zero.error.string=División por cero #loc
document.write.error.string=Llamada a '#ref()' #loc
duplicate.case.label.display.name=Etiqueta 'case' duplicada
duplicate.case.label.error.string=Etiqueta de case duplicada #ref #loc
duplicate.condition.error.string=Condición duplicada `#ref` #loc
duplicate.condition.in.if.statement.display.name=Duplicar condición en la sentencia 'if'
dynamically.generated.code.display.name=Ejecución de código generado dinámicamente
dynamically.generated.code.error.string=Función '#ref' indicativa de código generado dinámicamente #loc
empty.catch.block.display.name=Bloque 'catch' vacío
empty.catch.block.error.string=Bloque '#ref' vacío #loc
empty.finally.block.display.name=Bloque 'finally' vacío
empty.finally.block.error.string=Bloque 'finally' vacío #loc
empty.try.block.display.name=Bloque 'try' vacío
empty.try.block.error.string=Bloque vacío '#ref' #loc
exception.caught.locally.error.string=Referencia a la excepcion '#ref' atrapada localmente #loc
exception.used.for.local.control.flow.display.name=Excepción usada para el flujo de control local
expression.statement.is.not.assignment.or.call.error.string=La instrucción de expresión no es una asignación ni una llamada #loc
expression.statement.which.is.not.assignment.or.call.display.name=Sentencia de expresión que no es de asignación o llamada
fall.through.in.switch.statement.display.name=Fallthrough en declaración 'switch'
fall.through.in.switch.statement.error.string=Fallthrough en instrucción 'switch' #loc. Falta 'break' o 'return'
flip.comparison.fix=Invertir comparación
for.loop.not.use.loop.variable.display.name='for' bucle donde la actualización o condición no usa la variable del bucle
for.loop.not.use.loop.variable.problem.descriptor.both.condition.and.update=La instrucción <code>#ref</code> tiene una condición y una actualización que no utilizan la variable del bucle for #loc
for.loop.not.use.loop.variable.problem.descriptor.condition=La sentencia <code>#ref</code> tiene una condición que no usa la variable del bucle for #loc
for.loop.not.use.loop.variable.problem.descriptor.update=La declaración <code>#ref</code> contiene una actualización que no utiliza la variable de bucle for #loc
for.loop.replaceable.by.while.display.name='for' puede reemplazarse por un bucle 'while'
for.loop.replaceable.by.while.ignore.option=Ignorar bucles for 'infinitos' sin condiciones
for.loop.replaceable.by.while.problem.descriptor=El bucle <code>#ref</code> puede ser reemplazado por un bucle "while" #loc
for.loop.replaceable.by.while.replace.quickfix=Reemplazar por 'while'
function.complexity.limit.parameter=Límite de complejidad de la función:
function.contains.multiple.loops.error.string=La función ''#ref'' contiene {0} bucles #loc
function.contains.multiple.return.points.error.string=La función ''#ref'' tiene {0} puntos de retorno #loc
function.contains.too.many.negation.error.string=La función ''#ref'' contiene {0} negaciones #loc
function.has.inconsistent.return.points.error.string=la función '#ref' tiene puntos de retorno inconsistentes #loc
function.has.too.many.parameters.error.string=la función ''#ref'' tiene demasiados parámetros (cantidad de parámetros = {0}) #loc
function.is.overly.long.statement.error.string=La función ''#ref'' es demasiado larga (número de sentencias = {0}) #loc
function.is.overly.nested.error.string=La función ''#ref'' está demasiado anidada (la profundidad de anidamiento es {0}, pero el máximo permitido es {1}) #loc
function.name.doesnt.match.regex.error.string=El nombre de la función ''{0}'' no coincide con la expresión regular ''{1}''
function.name.is.too.long.error.string=El nombre de la función ''{0}'' es demasiado largo #loc
function.name.is.too.short.error.string=El nombre de la función ''{0}'' es demasiado corto #loc
function.naming.convention.display.name=Convención de nomenclatura de funciones
function.parameter.limit=Límite de parámetros de función:
function.parameter.naming.convention.display.name=Convención de nomenclatura de parámetros de función
function.ref.is.overly.complex.cyclomatic.complexity.error.string=La función ''#ref'' es demasiado compleja (ciclomática compleja = {0}) #loc
function.with.inconsistent.returns.display.name=Función con retornos inconsistentes
function.with.more.than.three.negations.display.name=Función con más de tres negaciones
function.with.multiple.loops.display.name=Función con múltiples ciclos
function.with.multiple.return.points.display.name=Función con múltiples puntos de retorno
function.with.too.many.parameters.display.name=Función con demasiados parámetros
group.path.javascript=JavaScript
if.statement.with.identical.branches.display.name='if' sentencia con ramas idénticas
if.statement.with.too.many.branches.display.name='if' con demasiadas ramas
if.statement.with.too.many.branches.error.string='''#ref''' tiene demasiadas ramas ({0}) #loc
include.anonymous.functions.parameter=Incluir funciones anónimas
include.statement.bodies.that.are.empty.code.blocks.parameter=Incluya cuerpos de declaraciones vacíos que son bloques de código
incompatible.mask.operation.display.name=Operación de máscara de bits incompatible
incompatible.mask.operation.problem.descriptor.always.false=<code>#ref</code> siempre es falso #loc
incompatible.mask.operation.problem.descriptor.always.true=<code>#ref</code> siempre es verdadera #loc
infinite.loop.error.string=La instrucción <code>#ref</code> no puede completarse sin arrojar una excepción #loc
infinite.loop.statement.display.name=Sentencia de bucle infinito
infinite.recursion.display.name=Recursión infinita
infinite.recursion.problem.descriptor=La función <code>#ref</code> tiene una recursión infinita, y solo puede terminar arrojando una excepción #loc
inner.html.error.string=Uso de la propiedad '#ref' #loc
invert.condition.fix=Invertir condición
invert.if.condition.fix=Invertir condición 'if'
javascript.dom.issues.group.name=Problemas DOM
js.inspection.group.path=JavaScript y TypeScript
js.inspection.switch.group.name=Problemas con la instrucción Switch
labeled.statement.display.name=Sentencia etiquetada
local.variable.naming.convention.display.name=Convenio de asignación de nombres de variables locales
loop.statement.that.doesn.t.loop.display.name=Sentencia de bucle que no realiza bucles
loop.statement.that.doesnt.loop.error.string=La instrucción <code>#ref</code> no cicla #loc
magic.number.display.name=Número mágico
magic.number.problem.descriptor=Número mágico '#ref' #loc
maximum.number.of.branches.parameter=Máximo número de ramas:
maximum.number.of.terms.parameter=Número máximo de términos:
maximum.statements.per.function=Máximo número de sentencias por función:
missing.return.statement.error.string=Falta la sentencia return
negated.conditional.expression.display.name=Expresión condicional negada
negated.conditional.expression.error.string=Expresión condicional negada #loc
negated.if.statement.display.name=Sentencia 'if' negada
negated.ref.statement.error.string=Instrucción '#ref' negada #loc
nested.anonymous.function.error.string=Función anónima anidada #ref #loc
nested.assignment.display.name=Asignación anidada
nested.assignment.error.string=Asignación anidada <code>#ref</code> #loc
nested.conditional.expression.display.name=Expresión condicional anidada
nested.conditional.expression.error.string=Expresión condicional anidada #loc
nested.function.call.display.name=Llamada a función anidada
nested.function.call.problem.descriptor=Llamada anidada a la función '#ref' #loc
nested.function.display.name=Función anidada
nested.function.error.string=Función anidada '#ref' #loc
nested.switch.statement.display.name=Declaración 'switch' anidada
nested.switch.statement.error.string=Instrucción '#ref' anidada #loc
nesting.depth.limit=Límite de profundidad de anidación:
non.block.body.error.string=La declaración <code>#ref</code> tiene un cuerpo no de tipo bloque #loc
non.block.branch.error.string=La declaración <code>#ref</code> tiene una rama no bloque #loc
non.block.statement.body.display.name=Cuerpo de declaración sin llaves
octal.integer.display.name=Entero octal
overly.complex.arithmetic.expression.display.name=Expresión aritmética demasiado compleja
overly.complex.arithmetic.expression.error.string=Expresión aritmética demasiado compleja #loc
overly.complex.boolean.expression.display.name=Expresión booleana demasiado compleja
overly.complex.boolean.expression.error.string=Expresión booleana demasiado compleja #loc
overly.complex.function.display.name=Función compleja
overly.long.function.display.name=Función muy larga
overly.nested.function.display.name=Función con anidación excesiva
parameter.name.doesnt.match.regex.error.string=El nombre de parámetro ''#ref'' no coincide con la expresión regular ''{0}'' #loc
parameter.name.is.too.long.error.string=El nombre del parámetro '#ref' es muy largo #loc
parameter.name.is.too.short.error.string=El nombre del parámetro '#ref' es demasiado corto #loc
platform.detection.display.name=Detección de la plataforma incorrecta
platform.detection.error.string='#ref' posiblemente está siendo usado para detección de plataforma #loc
pointless.arithmetic.error.message=#ref se puede reemplazar con {0} #loc
pointless.arithmetic.expression.display.name=Expresión aritmética sin sentido
pointless.bitwise.expression.display.name=La expresión bit a bit puede simplificarse
pointless.bitwise.expression.ignore.option=Ignorar constante nombrada al determinar expresiones inútiles
pointless.bitwise.expression.problem.descriptor=''{1}'' se puede reemplazar con ''{0}'' #loc
pointless.bitwise.expression.simplify.quickfix=Simplificar
pointless.boolean.error.string=Puede simplificarse a {0} #loc
pointless.boolean.expression.display.name=Expresión o sentencia booleanas sin sentido
pointless.statement.error.string={0} sentencia puede ser simplificada #loc
redundant.conditional.expression.display.name=Expresión condicional redundante
redundant.if.statement.display.name=Sentencia 'if' redundante
redundant.local.variable.display.name=Variable local redundante
redundant.local.variable.ignore.option=Ignorar variables que retornan o arrojan inmediatamente
redundant.local.variable.quickfix=Inlinear variable
ref.statement.with.identical.branches.error.string=sentencia <code>#ref</code> con ramas idénticas #loc
remove.label.fix=Eliminar etiqueta
remove.unnecessary.continue.fix=Eliminar continue innecesario
remove.unnecessary.return.fix=Eliminar return innecesario
rename.fix=Renombrar
replace.redundant.await.family.name=Sustituir await redundante
replace.with.operator.assign.fix=Reemplazar = por {0}=
reserved.word.used.as.name.display.name=Palabra reservada usada como nombre
reserved.word.used.as.name.error.string=Palabra reservada '#ref' utilizada como nombre
result.of.assignment.expression.used.error.string=Resultado de la expresión de asignación utilizado #loc
result.of.assignment.used.displayName=Resultado de la asignación usado
result.of.increment.or.decrement.expression.used.error.string=Se usó el resultado de una expresión de incremento o decremento #loc
result.of.increment.or.decrement.used.display.name=Resultado del incremento o decremento usado
result.of.object.allocation.ignored.display.name=Resultado de la asignación del objeto ignorado
result.of.object.allocation.ignored.error.string=El resultado de <code>new #ref()</code> se ignoró #loc
return.inside.finally.block.display.name='return' dentro del bloque 'finally'
return.inside.finally.block.error.string='#ref' dentro del bloque 'finally' #loc
reuse.of.local.variable.display.name=Reutilización de variable local
reuse.of.local.variable.problem.descriptor=Reutilización de la variable local <code>#ref</code> #loc
set.return.type.to.void.fix.name=Establecer tipo de valor de retorno a vacio
shift.operation.by.inappropriate.constant.display.name=Operación de desplazamiento por una constante posiblemente errónea
shift.operation.by.inappropriate.constant.problem.descriptor.negative=Operación de desplazamiento <code>#ref</code> por valor constante negativo #loc
shift.operation.by.inappropriate.constant.problem.descriptor.too.large=Operación de desplazamiento <code>#ref</code> por un valor constante demasiado grande #loc
shift.out.of.range.family.name=Corregir valor de desplazamiento
silly.assignment.display.name=Asignación circular de variable
silly.assignment.error.string=La variable se autoasigna #loc
simplify.fix=Simplificar
statement.has.empty.body.error.string=La sentencia <code>#ref</code> tiene un cuerpo vacío #loc
statement.has.empty.branch.error.string=La sentencia <code>#ref</code> tiene una rama vacía #loc
statement.label.error.string=Etiqueta de la declaración '#ref' #loc
statement.simplify.quickfix=Simplificar expresión
statement.with.empty.body.display.name=Sentencia con cuerpo vacío
string.literal.breaks.html.display.name=Literal de cadena que rompe el análisis de HTML
string.literal.breaks.html.error.string=Literal de cadena #ref puede romper los analizadores HTML #loc
tail.recursion.display.name=Recursión de cola
tail.recursion.problem.descriptor=Recursión de cola #loc
terminate.statement.fix=Finalizar declaración
text.label.in.switch.statement.display.name=Etiqueta de texto en el enunciado 'switch'
text.label.in.switch.statement.error.string=Etiqueta de texto <code>#ref:</code> en la sentencia 'switch' #loc
this.expression.references.global.object.error.string=Expresión '#ref' de nivel superior #loc
this.expression.which.references.the.global.object.display.name='this' expresión que hace referencia al objeto global
throw.inside.finally.block.display.name='lanzamiento' dentro de un bloque 'finalmente'
throw.inside.finally.block.error.string='#ref' dentro de un bloque 'finally' #loc
trivial.conditional.error.string=''{0}'' se puede simplificar a ''{1}'' #loc
trivial.if.error.string=La instrucción <code>#ref</code> se puede simplificar #loc
typeof.using.incorrect.case.display.name='typeof' comparado con valor no estándar
typeof.using.incorrect.case.error=comparación de typeof con valor no estándar
typeof.using.incorrect.convert=convertir a {0}
typeof.using.incorrect.family.name=Convertir al valor estándar
unnecessary.block.statement.display.name=Sentencia de bloque innecesaria
unnecessary.block.statement.error.string=Declaración de bloque innecesaria #loc
unnecessary.continue.error.string=<code>#ref</code> es innecesario ya que es la última declaración en un bucle #loc
unnecessary.continue.statement.display.name=Instrucción 'continue' innecesaria
unnecessary.label.display.name=Etiqueta innecesaria
unnecessary.label.error.string=Etiqueta innecesaria <code>#ref</code> #loc
unnecessary.label.on.break.error.string=Sentencia <code>#ref</code> con etiqueta innecesaria #loc
unnecessary.label.on.break.statement.display.name=Etiqueta innecesaria en el enunciado 'break'
unnecessary.label.on.continue.error.string=Instrucción <code>#ref</code> con una etiqueta #loc innecesaria
unnecessary.label.on.continue.statement.display.name=Etiqueta innecesaria en la declaración 'continue'
unnecessary.local.variable.problem.descriptor=La variable local {0} es redundante
unnecessary.return.error.string=<code>#ref</code> es innecesario como última sentencia en una función sin valor de retorno #loc
unnecessary.return.statement.display.name=Sentencia 'return' innecesaria
unreachable.code.display.name=Código inalcanzable
unreachable.code.error.string=Código inalcanzable #loc
unterminated.statement.display.name=Sentencia sin terminar
unterminated.statement.error.string=Declaración no finalizada #loc
unterminated.statement.ignore.atend.of.block=Permitir ausencia de punto y coma al final del bloque
unterminated.statement.possibly.unterminated.statement.error=Sentencia posiblemente no terminada #loc
unused.catch.parameter.display.name=Parámetro 'catch' sin usar
unused.catch.parameter.ignore.catch.option=Ignorar bloques catch que contienen comentarios
unused.catch.parameter.problem.descriptor=Parámetro catch sin utilizar <code>#ref</code> #loc
use.of.innerhtml.property.display.name=Uso de propiedad 'innerHTML'
variable.name.doesnt.match.regex.error.string=El nombre de variable ''#ref'' no coincide con la expresión regular ''{0}'' #loc
variable.name.is.too.long.error.string=La variable '#ref' tiene un nombre demasiado largo #loc
variable.name.is.too.short.error.string=El nombre de la variable '#ref' es demasiado corto #loc
void.expression.display.name='void' expression
void.expression.error.string='#ref' expresión #loc
with.expression.error.string='#ref' instrucción #loc
with.statement.display.name=sentencia 'with'
wrap.statement.body.fix=Ajustar cuerpo de instrucción
xhtml.incompatabilities.error.string='ref' puede producir resultados inconsistentes para documentos XHTML #loc
xhtml.incompatibilities.display.name=Usos incompatibles de XHTML