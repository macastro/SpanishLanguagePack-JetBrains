add.require.amd.module.fix=Agregar dependencia del módulo {0}
add.require.amd.module.group.name=Node.js
add.return.statement.fix.name=Agregar sentencia return
anonymous.function.contains.multiple.loops.error.string=\#ref contiene {0} bucles \#loc
anonymous.function.contains.multiple.return.points.error.string=\#ref tiene {0} puntos de retorno \#loc
anonymous.function.contains.too.many.negation.error.string=\#ref contiene {0} negaciones \#loc
anonymous.function.display.name=Función anónima
anonymous.function.error.string=Función anónima \#loc
anonymous.function.has.inconsistent.return.points.error.string=\#ref tiene puntos de retorno inconsistentes \#loc
anonymous.function.has.too.many.parameters.error.string=\#ref tiene demasiados parámetros (cantidad de parámetros \= {0}) \#loc
anonymous.function.is.overly.complex.cyclomatic.complexity.error.string=\#ref es demasiado compleja (complejidad ciclomática \= {0}) \#loc
anonymous.function.is.overly.long.statement.error.string=\#ref es demasiado larga (cantidad de sentencias \= {0}) \#loc
anonymous.function.is.overly.nested.error.string=\#ref está demasiado anidada (profundidad de anidamiento es {0}, pero el máximo permitido es {1}) \#loc
assignment.replaceable.with.operator.assignment.display.name=La asignación podría reemplazarse con asignación de operador
assignment.replaceable.with.operator.assignment.error.string=\#ref podría simplificarse a {0} \#loc
assignment.to.for.loop.parameter.display.name=Asignación a parámetro de bucle 'for'
assignment.to.for.loop.parameter.error.string=Asignación a parámetro de bucle for \#ref \#loc
assignment.to.function.parameter.display.name=Asignación a parámetro de función
assignment.to.function.parameter.error.string=Asignación a parámetro de función '\#ref' \#loc
break.statement.display.name=Sentencia 'break'
break.statement.error.string=Sentencia '\#ref' \#loc
break.statement.with.label.display.name=Sentencia 'break' con etiqueta
break.statement.with.label.error.string=Sentencia '\#ref' con etiqueta \#loc
call.to.document.write.display.name=Llamada a 'document.write()'
caller.display.name=Uso de la propiedad 'caller'
caller.error.string=Uso de la propiedad '\#ref' \#loc
chained.equality.display.name=Igualdad encadenada
chained.equality.error.string=Comparación de igualdad encadenada <code>\#ref</code> \#loc
chained.function.call.display.name=Llamada a función encadenada
chained.function.call.problem.descriptor=Llamada encadenada a función '\#ref' \#loc
class.name.doesnt.match.regex.error.string=El nombre de clase ''{0}'' no coincide con la expresión regular ''{1}'' \#loc
class.name.is.too.long.error.string=El nombre de clase ''{0}'' es demasiado largo \#loc
class.name.is.too.short.error.string=El nombre de clase ''{0}'' es demasiado corto \#loc
class.naming.convention.display.name=Convención de nombres de clase
collapse.conditional.expression.fix=Contraer expresión condicional
collapse.if.statement.fix=Contraer sentencia 'if'
comma.expression.display.name=Expresión con coma
comma.expression.error.string=Expresión con coma \#loc
conditional.expression.display.name=Expresión condicional
conditional.expression.error.string=Expresión condicional \#loc
conditional.expression.with.identical.branches.display.name=Expresión condicional con ramas idénticas
conditional.expression.with.identical.branches.error.string=Expresión condicional <code>\#ref</code> con ramas idénticas \#loc
confusing.floating.point.literal.change.quickfix=Cambiar a forma canónica
confusing.floating.point.literal.display.name=Literal de punto flotante confuso
confusing.floating.point.literal.problem.descriptor=Literal de punto flotante confuso <code>\#ref</code> \#loc
confusing.pluses.or.minuses.display.name=Secuencia confusa de '+' o '-'
confusing.pluses.or.minuses.error.string=La secuencia de '+' o '-' puede cambiar de significado si se eliminan los espacios en blanco \#loc
constant.conditional.expression.display.name=Expresión condicional constante
constant.conditional.expression.error.string=<code>\#ref</code> puede simplificarse \#loc
constant.on.left.side.of.comparison.display.name=Constante en el lado izquierdo de la comparación
constant.on.left.side.of.comparison.error.string=\#ref\: constante en el lado izquierdo de la comparación \#loc
constant.on.right.side.of.comparison.display.name=Constante en el lado derecho de la comparación
constant.on.right.side.of.comparison.error.string=\#ref\: constante en el lado derecho de la comparación \#loc
constructor.name.doesnt.match.regex.error.string=El nombre del constructor ''{0}'' no coincide con la expresión regular ''{1}'' \#loc
constructor.name.is.too.long.error.string=El nombre del constructor ''{0}'' es demasiado largo \#loc
constructor.name.is.too.short.error.string=El nombre del constructor ''{0}'' es demasiado corto \#loc
continue.or.break.inside.finally.block.display.name='continue' o 'break' dentro del bloque 'finally'
continue.or.break.inside.finally.block.error.string='\#ref' dentro del bloque 'finally' \#loc
continue.statement.display.name=Sentencia 'continue'
continue.statement.error.string=Sentencia '\#ref' \#loc
continue.statement.with.label.display.name=Sentencia 'continue' con etiqueta
continue.statement.with.label.error.string=Sentencia '\#ref' con etiqueta \#loc
debugger.statement.display.name=Sentencia 'debugger'
debugger.statement.error.string=Sentencia '\#ref' \#loc
default.branch.not.last.case.in.switch.error.string=Rama <code>\#ref</code> no es el último case en 'switch' \#loc
default.not.last.case.in.switch.display.name='default' no es el último case en 'switch'
divide.by.zero.display.name=División por cero
division.by.zero.error.string=División por cero \#loc
document.write.error.string=Llamada a '\#ref()' \#loc
duplicate.case.label.display.name=Etiqueta 'case' duplicada
duplicate.case.label.error.string=Etiqueta case duplicada \#ref \#loc
duplicate.condition.error.string=Condición duplicada <code>\#ref</code> \#loc
duplicate.condition.in.if.statement.display.name=Condición duplicada en sentencia 'if'
dynamically.generated.code.display.name=Ejecución de código generado dinámicamente
dynamically.generated.code.error.string=Función '\#ref' indicativa de código generado dinámicamente \#loc
empty.catch.block.display.name=Bloque 'catch' vacío
empty.catch.block.error.string=Bloque '\#ref' vacío \#loc
empty.finally.block.display.name=Bloque 'finally' vacío
empty.finally.block.error.string=Bloque 'finally' vacío \#loc
empty.try.block.display.name=Bloque 'try' vacío
empty.try.block.error.string=Bloque '\#ref' vacío \#loc
exception.caught.locally.error.string='\#ref' de excepción capturada localmente \#loc
exception.used.for.local.control.flow.display.name=Excepción usada para control de flujo local
expression.statement.is.not.assignment.or.call.error.string=La sentencia de expresión no es una asignación ni una llamada \#loc
expression.statement.which.is.not.assignment.or.call.display.name=Sentencia de expresión que no es asignación ni llamada
fall.through.in.switch.statement.display.name=Fallthrough en sentencia 'switch'
fall.through.in.switch.statement.error.string=Fallthrough en sentencia 'switch' \#loc. Falta 'break' o 'return'
flip.comparison.fix=Invertir comparación
for.loop.not.use.loop.variable.display.name=Bucle 'for' donde la actualización o condición no usa la variable de bucle
for.loop.not.use.loop.variable.problem.descriptor.both.condition.and.update=La sentencia <code>\#ref</code> tiene una condición y actualización que no usan la variable del bucle for \#loc
for.loop.not.use.loop.variable.problem.descriptor.condition=La sentencia <code>\#ref</code> tiene una condición que no usa la variable del bucle for \#loc
for.loop.not.use.loop.variable.problem.descriptor.update=La sentencia <code>\#ref</code> tiene una actualización que no usa la variable del bucle for \#loc
for.loop.replaceable.by.while.display.name=El bucle 'for' puede reemplazarse por un bucle 'while'
for.loop.replaceable.by.while.ignore.option=Ignorar bucles for 'infinitos' sin condiciones
for.loop.replaceable.by.while.problem.descriptor=El bucle <code>\#ref</code> puede reemplazarse por un bucle 'while' \#loc
for.loop.replaceable.by.while.replace.quickfix=Reemplazar con 'while'
function.complexity.limit.parameter=Límite de complejidad de función\:
function.contains.multiple.loops.error.string=La función ''\#ref'' contiene {0} bucles \#loc
function.contains.multiple.return.points.error.string=la función ''\#ref'' tiene {0} puntos de retorno \#loc
function.contains.too.many.negation.error.string=la función ''\#ref'' contiene {0} negaciones \#loc
function.has.inconsistent.return.points.error.string=La función '\#ref' tiene puntos de retorno inconsistentes \#loc
function.has.too.many.parameters.error.string=La función ''\#ref'' tiene demasiados parámetros (cantidad de parámetros \= {0}) \#loc
function.is.overly.long.statement.error.string=La función ''\#ref'' es demasiado larga (cantidad de sentencias \= {0}) \#loc
function.is.overly.nested.error.string=La función ''\#ref'' está excesivamente anidada (profundidad de anidamiento es {0}, pero el máximo permitido es {1}) \#loc
function.name.doesnt.match.regex.error.string=El nombre de función ''{0}'' no coincide con la expresión regular ''{1}'' \#loc
function.name.is.too.long.error.string=El nombre de función ''{0}'' es demasiado largo \#loc
function.name.is.too.short.error.string=El nombre de función ''{0}'' es demasiado corto \#loc
function.naming.convention.display.name=Convención de nomenclatura de funciones
function.parameter.limit=Límite de parámetros de función\:
function.parameter.naming.convention.display.name=Convención de nomenclatura de parámetros de función
function.ref.is.overly.complex.cyclomatic.complexity.error.string=La función ''\#ref'' es demasiado compleja (complejidad ciclomática \= {0}) \#loc
function.with.inconsistent.returns.display.name=Función con retornos inconsistentes
function.with.more.than.three.negations.display.name=Función con más de tres negaciones
function.with.multiple.loops.display.name=Función con múltiples bucles
function.with.multiple.return.points.display.name=Función con múltiples puntos de retorno
function.with.too.many.parameters.display.name=Función con demasiados parámetros
group.path.javascript=JavaScript
if.statement.with.identical.branches.display.name=Sentencia 'if' con ramas idénticas
if.statement.with.too.many.branches.display.name=Sentencia 'if' con demasiadas ramas
if.statement.with.too.many.branches.error.string=''\#ref'' tiene demasiadas ramas ({0}) \#loc
include.anonymous.functions.parameter=Incluir funciones anónimas
include.statement.bodies.that.are.empty.code.blocks.parameter=Incluir cuerpos de sentencia que son bloques de código vacíos
incompatible.mask.operation.display.name=Operación de máscara de bits incompatible
incompatible.mask.operation.problem.descriptor.always.false=<code>\#ref</code> es siempre false \#loc
incompatible.mask.operation.problem.descriptor.always.true=<code>\#ref</code> es siempre true \#loc
infinite.loop.error.string=La sentencia <code>\#ref</code> no puede completarse sin lanzar una excepción \#loc
infinite.loop.statement.display.name=Sentencia de bucle infinito
infinite.recursion.display.name=Recursión infinita
infinite.recursion.problem.descriptor=La función <code>\#ref</code> recurre infinitamente y solo puede terminar lanzando una excepción \#loc
inner.html.error.string=Uso de la propiedad '\#ref' \#loc
invert.condition.fix=Invertir condición
invert.if.condition.fix=Invertir condición 'if'
javascript.dom.issues.group.name=Problemas del DOM
js.inspection.group.path=JavaScript y TypeScript
js.inspection.switch.group.name=Problemas de sentencia switch
labeled.statement.display.name=Sentencia etiquetada
local.variable.naming.convention.display.name=Convención de nomenclatura de variables locales
loop.statement.that.doesn.t.loop.display.name=Sentencia de bucle que no itera
loop.statement.that.doesnt.loop.error.string=La sentencia <code>\#ref</code> no itera \#loc
magic.number.display.name=Número mágico
magic.number.problem.descriptor=Número mágico '\#ref' \#loc
maximum.number.of.branches.parameter=Número máximo de ramas\:
maximum.number.of.terms.parameter=Número máximo de términos\:
maximum.statements.per.function=Máximo de sentencias por función\:
missing.return.statement.error.string=Falta sentencia return \#loc
negated.conditional.expression.display.name=Expresión condicional negada
negated.conditional.expression.error.string=Expresión condicional negada \#loc
negated.if.statement.display.name=Sentencia 'if' negada
negated.ref.statement.error.string=Sentencia '\#ref' negada \#loc
nested.anonymous.function.error.string=\#ref anidada \#loc
nested.assignment.display.name=Asignación anidada
nested.assignment.error.string=Asignación anidada <code>\#ref</code> \#loc
nested.conditional.expression.display.name=Expresión condicional anidada
nested.conditional.expression.error.string=Expresión condicional anidada \#loc
nested.function.call.display.name=Llamada a función anidada
nested.function.call.problem.descriptor=Llamada anidada a la función '\#ref' \#loc
nested.function.display.name=Función anidada
nested.function.error.string=Función anidada '\#ref' \#loc
nested.switch.statement.display.name=Sentencia 'switch' anidada
nested.switch.statement.error.string=Sentencia '\#ref' anidada \#loc
nesting.depth.limit=Límite de profundidad de anidamiento\:
non.block.body.error.string=La sentencia <code>\#ref</code> tiene un cuerpo sin bloque \#loc
non.block.branch.error.string=La sentencia <code>\#ref</code> tiene una rama sin bloque \#loc
non.block.statement.body.display.name=Cuerpo de sentencia sin llaves
octal.integer.display.name=Entero octal
overly.complex.arithmetic.expression.display.name=Expresión aritmética demasiado compleja
overly.complex.arithmetic.expression.error.string=Expresión aritmética demasiado compleja \#loc
overly.complex.boolean.expression.display.name=Expresión booleana demasiado compleja
overly.complex.boolean.expression.error.string=Expresión booleana demasiado compleja \#loc
overly.complex.function.display.name=Función demasiado compleja
overly.long.function.display.name=Función demasiado larga
overly.nested.function.display.name=Función excesivamente anidada
parameter.name.doesnt.match.regex.error.string=El nombre del parámetro ''\#ref'' no coincide con la expresión regular ''{0}'' \#loc
parameter.name.is.too.long.error.string=El nombre del parámetro '\#ref' es demasiado largo \#loc
parameter.name.is.too.short.error.string=El nombre del parámetro '\#ref' es demasiado corto \#loc
platform.detection.display.name=Detección de plataforma inexacta
platform.detection.error.string='\#ref' probablemente usado para detección de plataforma \#loc
pointless.arithmetic.error.message=\#ref puede ser reemplazado por {0} \#loc
pointless.arithmetic.expression.display.name=Expresión aritmética sin sentido
pointless.bitwise.expression.display.name=La expresión de bits puede simplificarse
pointless.bitwise.expression.ignore.option=Ignorar constante nombrada al determinar expresiones sin sentido
pointless.bitwise.expression.problem.descriptor=''{1}'' puede ser reemplazado por ''{0}'' \#loc
pointless.bitwise.expression.simplify.quickfix=Simplificar
pointless.boolean.error.string=Se puede simplificar a {0} \#loc
pointless.boolean.expression.display.name=Sentencia o expresión booleana sin sentido
pointless.statement.error.string=La sentencia {0} puede simplificarse \#loc
redundant.conditional.expression.display.name=Expresión condicional redundante
redundant.if.statement.display.name=Sentencia 'if' redundante
redundant.local.variable.display.name=Variable local redundante
redundant.local.variable.ignore.option=Ignorar variables inmediatamente retornadas o lanzadas
redundant.local.variable.quickfix=Inline variable
ref.statement.with.identical.branches.error.string=Sentencia <code>\#ref</code> con ramas idénticas \#loc
remove.label.fix=Eliminar etiqueta
remove.unnecessary.continue.fix=Eliminar continue innecesario
remove.unnecessary.return.fix=Eliminar return innecesario
rename.fix=Renombrar
replace.redundant.await.family.name=Reemplazar await redundante
replace.with.operator.assign.fix=Reemplazar \= con {0}\=
reserved.word.used.as.name.display.name=Palabra reservada usada como nombre
reserved.word.used.as.name.error.string=Palabra reservada '\#ref' usada como nombre
result.of.assignment.expression.used.error.string=Resultado de expresión de asignación utilizado \#loc
result.of.assignment.used.displayName=Resultado de asignación utilizado
result.of.increment.or.decrement.expression.used.error.string=Resultado de expresión de incremento o decremento utilizado \#loc
result.of.increment.or.decrement.used.display.name=Resultado de incremento o decremento utilizado
result.of.object.allocation.ignored.display.name=Resultado de asignación de objeto ignorado
result.of.object.allocation.ignored.error.string=El resultado de <code>new \#ref()</code> es ignorado \#loc
return.inside.finally.block.display.name='return' dentro de bloque 'finally'
return.inside.finally.block.error.string='\#ref' dentro de bloque 'finally' \#loc
reuse.of.local.variable.display.name=Reutilización de variable local
reuse.of.local.variable.problem.descriptor=Reutilización de variable local <code>\#ref</code> \#loc
set.return.type.to.void.fix.name=Establecer tipo de retorno a void
shift.operation.by.inappropriate.constant.display.name=Operación de desplazamiento con constante posiblemente incorrecta
shift.operation.by.inappropriate.constant.problem.descriptor.negative=Operación de desplazamiento <code>\#ref</code> con valor constante negativo \#loc
shift.operation.by.inappropriate.constant.problem.descriptor.too.large=Operación de desplazamiento <code>\#ref</code> con valor constante demasiado grande \#loc
shift.out.of.range.family.name=Corregir valor de desplazamiento
silly.assignment.display.name=Variable asignada a sí misma
silly.assignment.error.string=Variable asignada a sí misma \#loc
simplify.fix=Simplificar
statement.has.empty.body.error.string=Sentencia <code>\#ref</code> tiene cuerpo vacío \#loc
statement.has.empty.branch.error.string=Sentencia <code>\#ref</code> tiene rama vacía \#loc
statement.label.error.string=Etiqueta de sentencia '\#ref' \#loc
statement.simplify.quickfix=Simplificar sentencia
statement.with.empty.body.display.name=Sentencia con cuerpo vacío
string.literal.breaks.html.display.name=Literal de cadena que rompe el análisis HTML
string.literal.breaks.html.error.string=El literal de cadena \#ref puede romper los analizadores HTML \#loc
tail.recursion.display.name=Recursión de cola
tail.recursion.problem.descriptor=Recursión de cola \#loc
terminate.statement.fix=Terminar sentencia
text.label.in.switch.statement.display.name=Etiqueta de texto en sentencia 'switch'
text.label.in.switch.statement.error.string=Etiqueta de texto <code>\#ref\:</code> en sentencia 'switch' \#loc
this.expression.references.global.object.error.string=Expresión '\#ref' de nivel superior \#loc
this.expression.which.references.the.global.object.display.name=Expresión 'this' que referencia al objeto global
throw.inside.finally.block.display.name='throw' dentro de bloque 'finally'
throw.inside.finally.block.error.string='\#ref' dentro de bloque 'finally' \#loc
trivial.conditional.error.string=''{0}'' puede simplificarse a ''{1}'' \#loc
trivial.if.error.string=La sentencia <code>\#ref</code> puede simplificarse \#loc
typeof.using.incorrect.case.display.name=Comparación 'typeof' con valor no estándar
typeof.using.incorrect.case.error=typeof comparando con valor no estándar
typeof.using.incorrect.convert=Convertir a {0}
typeof.using.incorrect.family.name=Convertir a valor estándar
unnecessary.block.statement.display.name=Bloque de sentencia innecesario
unnecessary.block.statement.error.string=Bloque de sentencia innecesario \#loc
unnecessary.continue.error.string=<code>\#ref</code> es innecesario como última sentencia en un bucle \#loc
unnecessary.continue.statement.display.name=Sentencia 'continue' innecesaria
unnecessary.label.display.name=Etiqueta innecesaria
unnecessary.label.error.string=Etiqueta innecesaria <code>\#ref</code> \#loc
unnecessary.label.on.break.error.string=Sentencia <code>\#ref</code> con etiqueta innecesaria \#loc
unnecessary.label.on.break.statement.display.name=Etiqueta innecesaria en sentencia 'break'
unnecessary.label.on.continue.error.string=Sentencia <code>\#ref</code> con etiqueta innecesaria \#loc
unnecessary.label.on.continue.statement.display.name=Etiqueta innecesaria en sentencia 'continue'
unnecessary.local.variable.problem.descriptor=La variable local {0} es redundante
unnecessary.return.error.string=<code>\#ref</code> es innecesario como última sentencia en una función sin valor de retorno \#loc
unnecessary.return.statement.display.name=Sentencia 'return' innecesaria
unreachable.code.display.name=Código inalcanzable
unreachable.code.error.string=Código inalcanzable \#loc
unterminated.statement.display.name=Sentencia sin terminar
unterminated.statement.error.string=Sentencia sin terminar \#loc
unterminated.statement.ignore.atend.of.block=Permitir ausencia de punto y coma al final del bloque
unterminated.statement.possibly.unterminated.statement.error=Posible sentencia sin terminar \#loc
unused.catch.parameter.display.name=Parámetro 'catch' no utilizado
unused.catch.parameter.ignore.catch.option=Ignorar bloques catch que contengan comentarios
unused.catch.parameter.problem.descriptor=Parámetro catch no utilizado <code>\#ref</code> \#loc
use.of.innerhtml.property.display.name=Uso de propiedad 'innerHTML'
variable.name.doesnt.match.regex.error.string=El nombre de variable ''\#ref'' no coincide con la expresión regular ''{0}'' \#loc
variable.name.is.too.long.error.string=El nombre de variable '\#ref' es demasiado largo \#loc
variable.name.is.too.short.error.string=El nombre de variable '\#ref' es demasiado corto \#loc
void.expression.display.name=Expresión 'void'
void.expression.error.string=Expresión '\#ref' \#loc
with.expression.error.string=Sentencia '\#ref' \#loc
with.statement.display.name=Sentencia 'with'
wrap.statement.body.fix=Envolver cuerpo de la sentencia
xhtml.incompatabilities.error.string='\#ref' puede producir resultados inconsistentes para documentos XHTML \#loc
xhtml.incompatibilities.display.name=Usos incompatibles de XHTML