abstract.class.not.allowed=No se permite la clase abstracta
access.static.via.instance=Acceso a miembro static mediante referencia de instancia
accessible.name.change.modifier=Cambiar modificador
action.GotoSuperClass.MainMenu.text=Superclase o interfaz(_U)
action.GotoSuperClass.description=Navegar a la declaración de una clase que la clase actual extiende o implementa
action.GotoSuperClass.text=Ir a superclase o interfaz(_U)
action.analyzing.cyclic.dependencies.in.scope=Dependencias cíclicas de {0}
action.create.new.class=Nueva clase Java
action.create.new.class.description=Crear nueva clase Java
action.create.new.module-info.description=Crear nuevo module-info.java
action.create.new.module-info.title=module-info.java
action.create.new.package-info.description=Crear nuevo package-info.java
action.create.new.package-info.title=package-info.java
action.cyclic.dependency.title=Análisis de dependencias cíclicas
action.description.copy.whole.thread.dump.to.clipboard=Copiar todo el thread dump al portapapeles
action.description.group.by.scope=Agrupar por tipo de scope (producción, test, librerías)
action.description.group.threads.with.identical.stacktraces=Agrupar threads con stacktraces idénticos
action.description.infer.nullity.annotations=Inferir anotaciones de nulidad
action.description.mark.directory.as.a.0.for.generated.files=Marcar directorio como {0} para archivos generados
action.description.mark.directory.as.an.ordinary.0=Marcar directorio como {0} ordinario
action.description.show.only.threads.containing.a.specific.string=Mostrar solo threads que contengan una cadena específica
action.dfa.from.stacktrace.text=Encontrar por qué ''{0}'' podría ser {1}
action.expand.static.import.text=Expandir static import
action.find.similar.stack.call.diverged=Los números de línea probablemente divergieron. Intente encontrar la ubicación actual dentro de ''{0}.{1}()''
action.find.similar.stack.call.location.not.found=No hay ubicación similar dentro de ''{0}.{1}()''
action.find.similar.stack.call.methods=Métodos similares a ''{0}.{1}()''
action.find.similar.stack.call.methods.not.found=No hay métodos similares a ''{0}.{1}()''
action.find.similar.stack.call.similar.calls=Posibles ubicaciones dentro de ''{0}.{1}()''
action.go.to.functional.implementation.text=Buscar implementaciones de interfaz funcional
action.go.to.implementation.text=Ir a implementación(es)
action.go.to.overriding.methods.text=Ir a métodos sobreescritos
action.go.to.subclass.text=Ir a subclase(s)
action.go.to.super.method.text=Ir a método super
action.group.by.package=Package
action.group.by.scope.type=Agrupar por tipo de scope
action.implement.method=Implementar método
action.implement.methods=Implementar métodos
action.override.method=Sobreescribir método
action.override.methods=Sobreescribir métodos
action.sort.by.percent.classes.which.overrides.method.description=Ordenar por porcentaje de subclases que sobreescriben el método
action.sort.by.percent.classes.which.overrides.method.text=Ordenar por porcentaje de subclases que sobreescriben el método
action.text.0.on.parameter.1={0} en parámetro ''{1}''
action.text.choose.class.in.0=elegir clase en {0}…
action.text.copy.to.clipboard=Copiar al portapapeles
action.text.edit.template=Editar plantilla
action.text.enter.class.name=ingresar nombre de clase…
action.text.generated.root.0={0} generado
action.text.merge.identical.stacktraces=Combinar stacktraces idénticos
action.text.show.methods.to.implement=Mostrar métodos a implementar
action.text.unmark.generated.0=Desmarcar {0} generado
action.title.infer.nullity.annotations=Inferir anotaciones de nulidad
add.methods.dialog.or=\ o
add.to.permits.list=Agregar ''{0}'' a la lista permits de la clase sealed ''{1}''
add.to.permits.list.family.name=Agregar clase a la lista permits
adds.ext.library.preview=Agrega la librería ''{0}'' al módulo ''{1}''
adds.ext.library.preview.import=Agrega la librería ''{0}'' a las dependencias del módulo ''{1}'' e importa ''{2}''
adds.library.preview=Agrega {0, choice, 1\#librería ''{1}''|2\#una de {2}} a las dependencias del módulo ''{3}'' e importa ''{4}'' no resuelto
adds.library.preview.no.import=Agrega {0, choice, 1\#librería ''{1}''|2\#una de {2}} a las dependencias del módulo ''{3}''
adds.module.dependencies.preview=Agrega {0, choice, 1\#módulo ''{1}''|2\#uno de {2}} a las dependencias del módulo ''{3}'' e importa las clases no resueltas
advanced.setting.code.vision.java.minimal.usages=Code Vision\: Mínimo de usos requeridos para mostrar hints incrustados
advanced.setting.compiler.automake.allow.when.app.running=Permitir que auto-make inicie incluso si la aplicación desarrollada está en ejecución
advanced.setting.compiler.automake.allow.when.app.running.description=El make iniciado automáticamente puede eventualmente eliminar algunas clases requeridas por la aplicación
advanced.setting.compiler.lower.process.priority=Ejecutar compilación con prioridad más baja
advanced.setting.compiler.lower.process.priority.description=Ejecutar proceso JPS externo con prioridad IDLE en Windows y nivel nice 10 en Linux/macOS
advanced.setting.compiler.unified.ic.implementation=Habilitar implementación unificada de compilación incremental Java/Kotlin
advanced.setting.compiler.unified.ic.implementation.description=El proceso JPS externo usará nueva implementación de compilación incremental que puede manejar bytecode producido por Java y Kotlin
advanced.setting.java.completion.qualifier.as.argument=Habilitar autocompletado para métodos static que usan qualifier como primer argumento
advanced.setting.java.sdkmanrc.watcher=Comenzar a escuchar cambios en archivos de configuración ('.sdkmanrc', '.tool-versions', …) al abrir el proyecto
advanced.setting.java.show.irrelevant.templates.in.source.roots=Mostrar plantillas de nuevo archivo irrelevantes en source roots de Java
advanced.settings.group.compiler=Compilador
advanced.settings.group.java=Java
align.types.in.multi.catch=Alinear tipos en multi-catch
annotate.intention.chooser.title=Elegir anotación para agregar
annotation.types.cannot.be.inlined=Los tipos de anotación no pueden ser inlined
arch.checker.notification.content=El JDK ''{0}'' ({1}) no coincide con la arquitectura del sistema ({2})
arch.checker.notification.project.structure=Configurar JDK
arch.checker.notification.title=El JDK seleccionado puede causar builds lentas
assignment.array.element.to.itself.problem.descriptor=El elemento del array se asigna a sí mismo
assignment.to.declared.variable.problem.descriptor=La variable ''{0}'' se inicializa con auto-asignación
assignment.to.itself.problem.descriptor=La variable ''{0}'' se asigna a sí misma
base.package.parameter.wizard.label=Package base(&P)\:
base.package.project.wizard.error.x.not.valid.package={0} no es un nombre de package válido
bean.property=Propiedad Bean
boolean.method.is.always.inverted.display.name=El método booleano siempre está invertido
boolean.method.is.always.inverted.problem.descriptor=Las llamadas al método booleano '\#ref()' siempre están invertidas
button.add=Agregar…
button.add.blank=Agregar en blanco
button.add.class=Agregar clase…
button.add.dependency=Agregar dependencia
button.add.package=Agregar package…
button.add.pattern=Agregar patrón…
button.annotations=Anotaciones…
button.base.method=Método base(&B)
button.code.patterns=Patrones de código…
button.current.method=Método actual(&C)
button.text.settings=Configuración…
button.to.another.directory=A directorio(&D)
button.to.another.source.root=A source root(&S)
caller.chooser.referenced.code.title=Código referenciado
cast.expression=Insertar expresión de casting
cast.to.0=Convertir a ''{0}''
change.color.command.text=Cambiar color
change.signature.from.usage.short.name=<html> Cambiar firma de {0}({1})</html>
change.uid.action.name=Cambiar aleatoriamente el inicializador 'serialVersionUID'
checkbox.after.description=Después de la descripción
checkbox.after.parameter.descriptions=Después de las descripciones de parámetros
checkbox.after.return.tag=Después de la etiqueta return
checkbox.align.parameter.descriptions=Alinear descripciones de parámetros
checkbox.align.thrown.exception.descriptions=Alinear descripciones de excepciones lanzadas
checkbox.annotate.local.variables=Anotar variables locales
checkbox.check.for.jdk.updates=Buscar actualizaciones del JDK
checkbox.collapse.annotations=Anotaciones
checkbox.collapse.anonymous.classes=Clases anónimas
checkbox.collapse.closures="Closures" (clases anónimas que implementan un método, antes de Java 8)
checkbox.collapse.end.of.line.comments=Secuencia de comentarios al final de línea
checkbox.collapse.generic.constructor.parameters=<html>Parámetros genéricos de constructor y método</html>
checkbox.collapse.i18n.messages=Cadenas I18n
checkbox.collapse.inferred.type=Reemplazar 'var' con tipo inferido
checkbox.collapse.inner.classes=Clases internas
checkbox.collapse.multiline.comments=Comentarios multilínea
checkbox.collapse.one.line.methods=<html>Métodos de una línea<html>
checkbox.collapse.simple.property.accessors=<html>Accesores de propiedades simples</html>
checkbox.collapse.suppress.warnings=<html>@SuppressWarnings</html>
checkbox.declare.var.type=Usar 'var' para declaración de variables locales
checkbox.deprecated.members=Miembros deprecados
checkbox.do.not.indent.top.level.class.members=No indentar miembros de clase de nivel superior
checkbox.do.not.wrap.after.single.annotation=No envolver después de una única anotación
checkbox.do.not.wrap.one.line.comments=No envolver comentarios de una línea
checkbox.don.t.warn.in.case.of.multiline.lambda=No advertir si el parámetro de 'List.replaceAll()' es lambda multilínea
checkbox.enable.javadoc.formatting=Habilitar formato JavaDoc
checkbox.enable.leading.asterisks=Habilitar asteriscos iniciales
checkbox.generate.p.on.empty.lines=Generar "<p>" en líneas vacías
checkbox.html.report.inaccessible.symbols=<html>Reportar símbolos inaccesibles<br>(la herramienta javadoc puede no crear hipervínculos)
checkbox.ignore.chains=Ignorar métodos encadenables
checkbox.ignore.fields.used.in.multiple.methods=Ignorar campos usados en múltiples métodos
checkbox.insert.imports.for.inner.classes=Insertar imports para clases internas
checkbox.iterate.unknown.stream.sources.via.stream.iterator=Iterar fuentes Stream desconocidas vía Stream.iterator()
checkbox.keep.empty.lines=Mantener líneas vacías
checkbox.keep.empty.param.tags=Mantener etiquetas @param vacías
checkbox.keep.empty.return.tags=Mantener etiquetas @return vacías
checkbox.keep.empty.throws.tags=Mantener etiquetas @throws vacías
checkbox.keep.invalid.tags=Mantener etiquetas inválidas
checkbox.make.generated.local.variables.final=Hacer final las variables locales generadas
checkbox.make.generated.parameters.final=Hacer final los parámetros generados
checkbox.param.description.on.new.line=Descripciones de parámetros en nueva línea
checkbox.param.indent.on.continuation=Indentar líneas de continuación
checkbox.prefer.longer.names=Preferir nombres más largos
checkbox.preserve.line.feeds=Preservar saltos de línea
checkbox.spaces.around.annotation.eq=Alrededor de '\=' en par de valores de anotación
checkbox.spaces.before.colon.in.foreach=Antes de los dos puntos en foreach
checkbox.spaces.before.deconstruction.list=Lista de deconstrucción
checkbox.spaces.inside.block.braces.when.body.is.present=Dentro de llaves de bloque cuando hay cuerpo
checkbox.spaces.inside.one.line.enum=Dentro de llaves de enum de una línea
checkbox.spaces.record.header=Encabezado de record
checkbox.spaces.within.deconstruction.list=Lista de deconstrucción
checkbox.suggest.conversion.to.map.computeifabsent=Sugerir conversión a Map.computeIfAbsent
checkbox.suggest.conversion.to.map.getordefault=Sugerir conversión a Map.getOrDefault
checkbox.suggest.conversion.to.map.merge=Sugerir conversión a Map.merge
checkbox.suggest.conversion.to.map.putifabsent=Sugerir conversión a Map.putIfAbsent
checkbox.suggest.conversion.to.map.replaceall=Sugerir conversión a Map.replaceAll
checkbox.suggest.replacement.even.if.lambda.may.have.side.effects=Sugerir reemplazo incluso si lambda puede tener efectos secundarios
checkbox.suppress.with.suppresswarnings=Suprimir con @SuppressWarnings
checkbox.treat.get.k.null.the.same.as.containskey.k.may.change.semantics=Tratar 'get(k) \!\= null' igual que 'containsKey(k)' (puede cambiar la semántica)
checkbox.use.fully.qualified.class.names=Usar nombres de clase completamente calificados
checkbox.use.single.class.import=Usar import de clase única
checkbox.use.throws.rather.than.exception=Usar @throws en lugar de @exception
checkbox.warn.if.only.foreach.replacement.is.available=Advertir si solo está disponible el reemplazo 'forEach'
checkbox.warn.if.the.loop.is.trivial=Advertir si el bucle es trivial
checkbox.wrap.at.right.margin=Envolver en el margen derecho
choose.class=Elegir Clase
choose.super.class.popup.title=Elegir superclase
chooser.text.choose.where.to.save.0=Elegir dónde guardar ''{0}''
chooser.title.select.path.to.save.jar=Seleccionar Ruta para Guardar Jar
class.can.be.record.conversion.make.member.more.accessible=Si los miembros se vuelven más accesibles\:
class.can.be.record.conversion.strategy.convert.silently=Convertir silenciosamente
class.can.be.record.conversion.strategy.do.not.convert=No sugerir conversión
class.can.be.record.conversion.strategy.show.members=Mostrar vista de conflictos
class.can.be.record.display.name=La clase puede ser una clase record
class.can.be.record.quick.fix=Convertir a clase record
class.can.be.record.suggest.renaming.accessors=Sugerir renombrar métodos accesores
class.can.be.record.suppress.conversion.if.annotated=Suprimir conversión si la clase está anotada con\:
class.can.be.record.suppress.conversion.if.annotated.fix.name=Suprimir conversión a record si está anotada con ''{0}''
class.cannot.be.inlined.because.a.call.to.its.constructor.is.unresolved=No se puede hacer inline la clase porque una llamada a su constructor no está resuelta
class.cannot.be.inlined.because.an.interface.implemented.by.it.cannot.be.resolved=No se puede hacer inline la clase porque no se puede resolver una interfaz que implementa
class.cannot.be.inlined.because.it.has.static.fields.with.non.constant.initializers=No se puede hacer inline la clase porque tiene campos static con inicializadores no constantes
class.cannot.be.inlined.because.it.has.static.initializers=No se puede hacer inline la clase porque tiene inicializadores static
class.cannot.be.inlined.because.it.has.static.inner.classes=No se puede hacer inline la clase porque tiene clases internas static
class.cannot.be.inlined.because.it.has.static.methods=No se puede hacer inline la clase porque tiene métodos static
class.cannot.be.inlined.because.it.has.static.non.final.fields=No se puede hacer inline la clase porque tiene campos static no final
class.cannot.be.inlined.because.it.has.usages.of.fields.not.inherited.from.its.superclass=No se puede hacer inline la clase porque tiene usos de campos no heredados de su superclase
class.cannot.be.inlined.because.it.has.usages.of.its.class.literal=No se puede hacer inline la clase porque tiene usos de su literal de clase
class.cannot.be.inlined.because.it.has.usages.of.its.inner.classes=No se puede hacer inline la clase porque tiene usos de sus clases internas
class.cannot.be.inlined.because.it.is.used.as.a.this.qualifier=No se puede hacer inline la clase porque se usa como calificador 'this'
class.cannot.be.inlined.because.it.is.used.in.a.catch.clause=No se puede hacer inline la clase porque se usa en una cláusula 'catch'
class.cannot.be.inlined.because.it.is.used.in.a.throws.clause=No se puede hacer inline la clase porque se usa en una cláusula 'throws'
class.cannot.be.inlined.because.its.constructor.contains.return.statements=No se puede hacer inline la clase porque su constructor contiene sentencias 'return'
class.cannot.be.inlined.because.its.superclass.cannot.be.resolved=No se puede hacer inline la clase porque no se puede resolver su superclase
class.cannot.be.inlined.because.there.are.usages.of.its.methods.not.inherited.from.its.superclass.or.interface=No se puede hacer inline la clase porque hay usos de sus métodos no heredados de su superclase o interfaz
class.decorator.or.has.default.constructor=''{0}'' debe tener constructor por defecto o implementar el patrón ''Decorator''
class.filter.editor.add.dialog.title=Nuevo Filtro
class.filter.editor.choose.class.title=Elegir Clase
class.filter.editor.table.model.column.name.isActive=Está Activo
class.filter.editor.table.model.column.name.pattern=Patrón
class.has.no.default.constructor=''{0}'' no tiene constructor por defecto
class.is.not.a.subclass=''{0}'' no es asignable a ''{1}''
class.is.not.concrete=''{0}'' no es una clase concreta
class.is.not.public=''{0}'' no es pública
class.not.found.error.message=Clase ''{0}'' no encontrada
class.patterns.error.class.pattern.0.must.be.a.valid.java.qualifier=El patrón debe ser un nombre calificado java válido, solo se aceptan '*' como comodines
class.patterns.error.method.pattern.0.must.be.a.valid.java.identifier=El patrón de método ''{0}'' debe ser un identificador java válido, solo se aceptan ''*'' como comodines
class.patterns.panel.add.class=Añadir Clase
class.patterns.separator.mark.code.as.entry.point.if.qualified.name.matches=Marcar Código como Punto de Entrada si el Nombre Calificado Coincide
code.style.generation.override.method.signature=Firma del Método Sobrescrito
code.style.generation.repeat.synchronized.modifier=Repetir modificador synchronized(&S)
code.style.generation.replace.null.check=Reemplazar comprobación null con Objects\:\:nonNull u Objects\:\:isNull
code.style.generation.settings.error.not.valid.identifier.part.in.prefix=No es una parte válida de identificador java en el prefijo ''{0}''
code.style.generation.settings.error.not.valid.identifier.part.in.suffix=No es una parte válida de identificador java en el sufijo ''{0}''
code.style.generation.use.class.isInstance=Usar Class\:\:isInstance y Class\:\:cast cuando sea posible
code.style.generation.use.integer.sum=Usar Integer\:\:sum, etc. cuando sea posible
code.style.settings.angle.spacing.brackets=Corchetes angulares
code.style.settings.spacing.after.closing.angle.bracket=Después del corchete angular de cierre
code.style.settings.spacing.around.type.bounds=Alrededor de límites de tipo
code.vision.implementations.hint={0, choice, 1\#1 implementación|2\#{0,number} implementaciones}
code.vision.inheritors.hint={0, choice, 1\#1 heredero|2\#{0,number} herederos}
code.vision.overrides.hint={0, choice, 1\#1 sobrescritura|2\#{0,number} sobrescrituras}
column.name.class.entry.point=Clase
column.name.method.entry.point=Método
column.name.with.subclasses.entry.point=Con Subclases
combobox.paste.insert.imports=Insertar imports al pegar(&I)\:
command.create.class.from.template=Crear Clase Desde Plantilla
command.create.new.subdirectory=Crear Nuevo Subdirectorio
command.name.delegate.detected.change=Delegar
command.name.generate.tostring=Generar toString()
command.name.insert.block.statement=Insertar Bloque de Sentencia
command.name.replace.type=Reemplazar Tipo
command.name.updating.package.statement=Actualizando sentencia package
comment.the.class.will.be.created.in.the.package.0=La clase será creada en el paquete ''{0}''
compiler.options=Opciones del compilador
completion.class.name.hint.2=Presione {0} nuevamente para ignorar dependencias de módulos al buscar
completion.generate.via.wizard=(generar mediante asistente)
completion.inner.scope=interno
completion.inner.scope.tail.text=\ (desde bloque {0})
completion.no.suggestions.of.type=No hay sugerencias del tipo {0}
completion.override.implement.methods=Sobrescribir/Implementar métodos…
completion.provider.method.declaration.type=declaración del método provider()
completion.smart.aslist.hint=Presione {0} nuevamente para buscar arrays de {1}
completion.smart.chain.hint=Presione {0} nuevamente para buscar a través de llamadas encadenadas de métodos
completion.smart.hint=Presione {0} para mostrar solo variantes adecuadas por tipo
completion.smart.toar.hint=Presione {0} nuevamente para buscar colecciones de {1}
completion.smart.type.generate.anonymous.body=generar cuerpo anónimo
completion.unknown.type=Tipo desconocido {0}
configurable.EqualsHashCodeTemplatesPanel.display.name=Plantillas
configurable.GenerateToStringConfigurable.display.name=Configuración
configurable.TemplatesPanel.display.name=Plantillas
configure.annotations.option=Configurar Anotaciones…
conflict.message.method.will.override.method.base.class=El {0} renombrado sobrescribirá el método de la {1} base
convert.compareto.expression.to.equals.call=Convertir expresión 'compareTo()' a llamada 'equals()'
convert.compareto.expression.to.equals.call.may.change.semantics=Convertir expresión 'compareTo()' a llamada 'equals()' (puede cambiar la semántica)
convert.number.binary=binario
convert.number.decimal=decimal
convert.number.hex=hexadecimal
convert.number.octal=octal
convert.number.plain.format=formato plano
convert.number.scientific.format=formato científico
copy.abstract.method.intention.name=Usar implementación existente de ''{0}''
copy.abstract.method.no.existing.implementations.found=No se encontraron implementaciones existentes
copy.abstract.method.popup.title=Elegir implementación para copiar
copy.abstract.method.title=Usar Implementación de Método Abstracto
copy.paste.reference.notification=<html>Se {0, choice, 1\#ha|2\#han} añadido {0} {0, choice, 1\#import|2\#imports}<p><span><a href\=''show''>Revisar Imports Añadidos...</a></span></html>
create.class.mapping.dialog.title=Elegir Clase {0}
cyclic.dependencies.progress.text=Construyendo grafo de dependencias
cyclic.dependencies.scope.dialog.module.button={0} módulo ''{1}'' (&M)
cyclic.dependencies.scope.dialog.project.button={0} todo el proyecto(&P)
cyclic.dependencies.scope.dialog.title=Especificar Ámbito de {0}
cyclic.dependencies.scope.include.test.sources.option=Incluir código de pruebas(&T)
cyclic.dependencies.tree.cycle.node.text=ciclo
cyclic.dependencies.usage.view.initial.text=Seleccione un paquete para analizar desde el árbol izquierdo
cyclic.dependencies.usage.view.root.node.text=Usos del paquete ''{0}'' en el paquete ''{1}''
dataflow.from.here=Flujo de Datos desde Aquí
dataflow.to.here=Flujo de Datos hacia Aquí
deannotate.intention.action.family.name=Eliminar anotación
deannotate.intention.action.several.text=Eliminar anotación…
deannotate.intention.action.text=Eliminar anotación {0}
deannotate.intention.chooser.title=Elegir Anotación para Eliminar
default.package.presentable.name=<default>
default.param.value.warning={0} ya existe
delete.assignment.completely=Eliminar asignación completamente
delete.initializer.completely=Eliminar inicializador completamente
dependant.sdk.unsatisfied.dependency.message=Primero necesita configurar un SDK de Java
dependencies.libraries.node.text=Bibliotecas
dependencies.tree.node.default.package.abbreviation=<paquete por defecto>
destination.combo.source.root.not.expected.conflict=Se seleccionó raíz de fuentes mientras se esperaba raíz de pruebas
destination.combo.test.root.not.expected.conflict=Se seleccionó raíz de pruebas mientras se esperaba raíz de fuentes
dfa.constraint.0.not.null={0} (no-nulo)
dfa.constraint.not.null=no-nulo
dfa.constraint.null.or.0=null o {0}
dialog.create.class.destination.package.label=Paquete destino\:
dialog.create.class.label=Crear {0}\:
dialog.create.class.name=Crear {0} {1}
dialog.create.class.package.chooser.title=Elegir Paquete Destino
dialog.edit.template.checkbox.smart.type.completion=Autocompletado por tipo coincidente(&O)
dialog.edit.template.checkbox.use.static.import=Usar import estático si es posible(&I)
dialog.import.on.paste.title=Seleccionar clases a importar
dialog.import.on.paste.title2=Seleccionar elementos a importar
dialog.import.on.paste.title3=Seleccionar import a eliminar
dialog.message.0.update.existing.class={0}. ¿Actualizar la clase existente?
dialog.message.class.not.found=No se encontró la clase de plantilla ''{0}''
dialog.message.create.test.in.the.same.source.root=¿Crear test en la misma raíz de código fuente?
dialog.message.infer.nullity.annotations.requires.the.project.language.level=La inferencia de anotaciones de nulidad requiere que el nivel de lenguaje del proyecto sea 1.5 o superior.
dialog.message.jetbrains.annotations.library.is.missing=Falta la biblioteca de anotaciones de JetBrains.\nSin la biblioteca, IntelliJ IDEA no puede ejecutar el análisis. ¿Desea añadirla?
dialog.message.modules.dont.refer.to.existing.annotations.library={0, choice, 0\#El módulo|2\#Los módulos} {1} {0, choice, 0\#no hace|2\#no hacen} referencia a la biblioteca existente ''{2}'' con anotaciones de nulidad de IntelliJ IDEA. ¿Desea añadir {0, choice, 0\#la dependencia|2\#las dependencias} ahora?
dialog.message.no.places.found.to.infer.nullable.notnull=No se encontraron lugares para inferir @Nullable/@NotNull
dialog.message.parameter.has.write.usages.inline.not.supported=El parámetro tiene usos de escritura. No se admite el inline
dialog.message.template.not.applicable=La plantilla no es aplicable
dialog.message.template.not.found=Plantilla no encontrada
dialog.paste.on.import.text=<html>El fragmento de código que ha pegado usa clases que no son accesibles mediante imports en el nuevo contexto.<br/>Seleccione las clases que desea importar al nuevo archivo.</html>
dialog.paste.on.import.text2=<html>El fragmento de código que ha pegado usa elementos que no son accesibles mediante imports en el nuevo contexto.<br/>Seleccione los elementos que desea importar al nuevo archivo.</html>
dialog.paste.on.import.text3=<html>El fragmento de código que ha pegado ha introducido nuevos imports en el contexto actual.<br/>Seleccione los imports que desea eliminar.</html>
dialog.title.check.configuration=Verificar configuración…
dialog.title.check.functional.interface.candidates=Verificar candidatos de interfaz funcional…
dialog.title.choose.0.parameters=Elegir parámetros {0}
dialog.title.choose.annotation=Elegir anotación {0}
dialog.title.choose.class=Elegir clase
dialog.title.choose.logger=Elegir logger
dialog.title.configure.annotations=Configurar anotaciones
dialog.title.configure.code.patterns=Configurar patrones de código
dialog.title.copy.template=Copiar plantilla
dialog.title.create.class.in.package=Crear clase en paquete
dialog.title.create.missing.tests=Crear tests faltantes
dialog.title.create.new.template=Crear nueva plantilla
dialog.title.edit.method.contract=Editar contrato de método
dialog.title.edit.range=Editar rango de ''{0}''
dialog.title.infer.nullity=Inferir nulidad
dialog.title.infer.nullity.results=Resultados de inferencia de nulidad
dialog.title.move.directory=Mover directorio
dialog.title.no.test.roots.found=No se encontraron raíces de test
dialog.title.process.duplicates=Procesar duplicados
dialog.title.super.method.found=Método super encontrado
dialog.title.testdatapath.file.generate=Generar archivos desde clase a @TestDataPath
dialog.title.testdatapath.method.generate=Generar métodos desde @TestDataPath
disable.report.inaccessible.symbols.fix=No reportar símbolos inaccesibles
do.not.import.inner.classes.for=Excluir clases internas por nombre corto\:
do.not.import.inner.classes.no.classes=No hay clases internas definidas
edit.contract.dialog.checkbox.impure.method=El método puede producir efectos &secundarios
edit.contract.dialog.hint=<html>Por favor especifique el texto del contrato<p>Ejemplo\: <code>_, null -> false</code><br><small>Ver descripción de la acción de intención para más detalles</small></html>
edit.contract.dialog.mutates.hint=Especifique elementos separados por comas que pueden ser mutados<p>Ejemplo\: <code>this,param1</code><p>Dejar vacío para efectos secundarios no especificados.
edit.range.dialog.message=Dejar vacío si no hay restricciones
edit.range.error.invalid.value=Valor inválido
edit.range.should.not.be.greater.than.to=No debe ser mayor que 'to'
edit.range.should.not.be.less.than.from=No debe ser menor que 'from'
edit.range.value.should.be.bigger.than=No debe ser mayor que {0}
edit.range.value.should.be.less.than=No debe ser menor que {0}
editbox.blank.lines.field.in.interface=Antes del campo en interfaz
editbox.blank.lines.field.with.annotations=Antes del campo con anotaciones\:
editbox.blank.lines.field.without.annotations=Antes del campo sin anotaciones\:
editbox.blanklines.around.initializer=Alrededor del inicializador\:
editbox.class.count.to.use.import.with.star=Número de clases para usar import con '*'\:
editbox.names.count.to.use.static.import.with.star=Número de nombres para usar import estático con '*'\:
empty.title=Vacío
encapsulate.fields.dialog.javadoc.title=Javadoc
enum.constant.ordinal=Ordinal de constante enum\: 
enum.not.allowed=Enum no permitido
enums.cannot.be.inlined=Los enums no pueden ser inlined
environment.key.description.project.jdk=Ruta absoluta al JDK del proyecto
environment.key.description.project.jdk.name=Nombre visible en el IDE del JDK del proyecto.
error.attempt.to.generate.constructor.for.anonymous.class=No se puede añadir constructor a una clase anónima
error.attempt.to.generate.constructor.for.implicit.class=No se puede añadir constructor a una clase declarada implícitamente
error.hint.no.expression.found=No se encontró expresión
error.message.ide.does.not.support.starting.processes.using.old.java=El IDE no admite iniciar procesos Java usando Java {0}, la versión mínima soportada es 1.7. Cambie la configuración de ejecución para usar una versión más reciente de Java.
error.package.already.contains.package-info=Ya existe ''package-info.java'' para el paquete ''{0}''
error.package.already.contains.package.html=El paquete ''{0}'' ya tiene un archivo ''package.html''. ¿Crear ''package-info.java'' de todos modos?
error.package.html.found.title=Se encontró 'package.html'
error.text.this.is.not.a.valid.java.class.name=Este no es un nombre de clase Java válido
exclude.0.from.auto.import=Excluir ''{0}'' del auto-import
exclude.0.from.completion=Excluir ''{0}'' del autocompletado
exclude.accessors=&Excluir accessors
exclude.from.completion.group=Excluir de auto-import y autocompletado\:
exclude.from.imports.no.exclusions=Añadir una clase, paquete o miembro
exclude.from.imports.no.exclusions.2=para excluir de auto-import y autocompletado
exclude.import.wildcard.comment=Use el comodín * para excluir todos los miembros de una clase o paquete específico
exclude.table.mask=Clase, paquete o miembro
exclude.table.scope.column=Ámbito
export.to.html.generate.hyperlinks.checkbox=Generar &hipervínculos a clases
external.annotation.prompt=Prompt de anotación externa
external.annotations.external.option=Añadir &externamente
external.annotations.in.code.option=Añadir en &código
external.annotations.open.file=Abrir archivo de anotaciones
external.annotations.problem.parse.error=Archivo\: {0}<br>Problema\: {1}
external.annotations.problem.title=No se pueden leer las anotaciones externas
external.annotations.root.chooser.description=Las anotaciones externas se guardarán en la carpeta apropiada
external.annotations.root.chooser.title=Seleccionar raíz de anotaciones externas para {0}
external.annotations.roots=Raíces de anotaciones
external.annotations.suggestion.message=<html><body>Si no desea anotaciones en su código puede usar almacenamiento externo.<br>Para configurar anotaciones externas especifique el directorio raíz donde se colocarán los archivos con anotaciones</body></html>
extract.interface.command.name=Extraer interfaz
extract.superclass.command.name=Extraer superclase
extracted.class.should.have.unique.name=La clase extraída debe tener un nombre único. El nombre ''{0}'' ya está en uso por una de las clases internas
filetype.spi.description=Interfaz de proveedor de servicios
find.field.accessors.prompt=¿Buscar accessors del campo ''{0}''?
find.field.accessors.title=Accessors de campo encontrados
find.jar.hint.text.no.libraries.found.for.fqn=No se encontraron bibliotecas para ''{0}''
find.options.include.accessors.base.checkbox=Buscar métodos base de accessors(&E)
find.options.include.accessors.base.checkbox.comment=Usar métodos de jerarquía de nivel superior como objetivos de búsqueda por defecto
find.options.include.accessors.checkbox=Buscar accessors(&A)
find.options.include.overloaded.methods.checkbox=Métodos sobrecargados(&V)
find.options.search.overriding.methods.checkbox=Buscar en métodos que sobrescriben(&O)
find.what.derived.classes.checkbox=Clases derivadas(&D)
find.what.derived.interfaces.checkbox=Interfaces derivadas(&D)
find.what.fields.usages.checkbox=Usos de campos(&F)
find.what.implementing.classes.checkbox=Clases que implementan(&I)
find.what.implementing.methods.checkbox=Métodos que implementan(&I)
find.what.implicit.to.string.checkbox=Llamadas implícitas(&M)
find.what.methods.usages.checkbox=Usos de métodos(&M)
find.what.overriding.methods.checkbox=Métodos que sobrescriben(&R)
find.what.search.for.base.methods.checkbox=Buscar usos de métodos base(&E)
find.what.search.for.base.methods.checkbox.comment=Usar métodos de jerarquía de nivel superior como objetivos de búsqueda por defecto
find.what.usages.checkbox=Usos(&U)
find.what.usages.of.classes.and.interfaces=Usos de clases e interfaces(&C)
fix.move.to.source.root=Mover a raíz de fuentes
generate.button.title=Generar
generate.constructor.already.exists=El constructor ya existe
generate.constructor.fields.chooser.title=Elegir campos para inicializar por constructor
generate.constructor.super.constructor.chooser.title=Elegir constructor de superclase
generate.delegate.target.chooser.title=Seleccionar objetivo para generar delegados
generate.equals.and.hashcode.already.defined.title=Generar equals() y hashCode()
generate.equals.and.hashcode.already.defined.warning=Los métodos ''boolean equals(Object)'' y ''int hashCode()'' ya están definidos\npara la clase {0}. ¿Desea eliminarlos y continuar?
generate.equals.and.hashcode.already.defined.warning.anonymous=Los métodos 'boolean equals(Object)' y 'int hashCode()' ya están definidos\npara esta clase anónima. ¿Desea eliminarlos y continuar?
generate.equals.hashcode.accept.sublcasses=Aceptar subclases como parámetro para el método equals()(&S)
generate.equals.hashcode.accept.sublcasses.explanation=<html><body>Aunque generalmente no cumple con el contrato de Object.equals(),<br>aceptar subclases puede ser necesario para que el método generado funcione<br>correctamente con frameworks que generan subclases Proxy, como Hibernate.</body></html>
generate.equals.hashcode.comparison.table=<html><table><tr><th><th>instanceof<th>getClass()<tr><td>Permite que instancias de subclases sean iguales a instancias de la superclase<td align\=center>sí<td align\=center>no<tr><td>Permite que instancias de diferentes subclases sean iguales entre sí<td align\=center>sí<td align\=center>no<tr><td>Sobrescribir el método equals() generado no rompe su contrato<td align\=center>no<td align\=center>sí<tr><td>Evita comprobación extra de null<td align\=center>sí<td align\=center>no<tr><td>Cumple\\&nbsp;el\\&nbsp;principio\\&nbsp;de\\&nbsp;sustitución\\&nbsp;de\\&nbsp;Liskov<td align\=center>sí<td align\=center>no</table></html>
generate.equals.hashcode.equals.fields.chooser.title=Elegir campos para incluir en equals()(&F)
generate.equals.hashcode.getclass.type.comparison=Expresión de comparación get&Class()
generate.equals.hashcode.hashcode.fields.chooser.title=Elegir campos para incluir en hashCode()(&F)
generate.equals.hashcode.instanceof.type.comparison=Expresión instanceof(&I)
generate.equals.hashcode.internal.error=Error interno
generate.equals.hashcode.non.null.fields.chooser.title=Seleccionar todos los campos no nulos(&F)
generate.equals.hashcode.template=Plantilla(&T)\:
generate.equals.hashcode.type.comparison.label=Para la comparación de tipos de clase en el método equals() generar\:
generate.equals.hashcode.use.getters=Usar getters cuando estén disponibles(&G)
generate.equals.hashcode.warning.hashcode.for.arrays.is.not.supported=hashCode() no es compatible con arrays
generate.equals.hashcode.wizard.title=Generar equals() y hashCode()
generate.equals.no.fields.for.generation=No se encontraron campos para incluir en equals/hashCode
generate.equals.template.title=Plantilla Equals\:
generate.equals.warning.equals.for.nested.arrays.not.supported=equals() no es compatible con arrays anidados
generate.equals.warning.generated.equals.could.be.incorrect=El equals() generado para Object[] puede ser incorrecto
generate.equals.wizard.title=Generar equals()
generate.file.extension.text=Introducir extensión de archivo\: .php, .java, .kt, .cpp ....
generate.file.extension.validation.error=La extensión de archivo ''{0}'' no es válida. Debe comenzar con ''.'', no puede contener espacios ni estar vacía
generate.getter.and.setter.error.no.fields=No se encontraron campos para generar getters/setters
generate.getter.and.setter.error.no.fields.without.getters.and.setters=No se encontraron campos sin getter/setter
generate.getter.and.setter.error.setters.for.read.only.not.generated=No se generaron setters para campos de solo lectura
generate.getter.error.no.fields=No se encontraron campos para generar getters
generate.getter.error.no.fields.without.getters=No se encontraron campos sin getter
generate.getter.fields.chooser.title=Seleccionar campos para generar Getters
generate.getter.setter.generate.all.annotations=Copiar todas las anotaciones(&A)
generate.getter.setter.generate.all.annotations.tooltip=Copiar todas las anotaciones aplicables de los campos. De lo contrario, solo se copiarán las anotaciones de nulabilidad
generate.getter.setter.header.visibility.hint.=La visibilidad se aplica según Archivo | Configuración | Editor | Estilo de código | Java | Generación de código
generate.getter.setter.title=Seleccionar campos para generar Getters y Setters
generate.getter.template=Plantilla de Getter(&G)\:
generate.hashcode.template.title=Plantilla de HashCode\:
generate.hashcode.wizard.title=Generar hashCode()
generate.logger.no.place.found.dialog.message=No se encontraron lugares para insertar el logger
generate.logger.no.place.found.dialog.title=No se encontraron lugares
generate.logger.specify.place.popup.title=Elegir lugar
generate.members.implement.command=implementar
generate.members.nothing.to.insert=No se encontró nada para insertar
generate.method.nofiles.warn=No se encontraron métodos de prueba en la clase {0}
generate.method.nosuites.warn=No se encontraron suites de prueba en @TestDataPath("{0}")
generate.missed.tests.action.error.no.tests.found=No se encontraron pruebas.
generate.missed.tests.action.failed.to.detect.framework=No se pudo detectar el framework de pruebas para {0}
generate.quickfix.files=Crear escenarios QF (con sufijo '.after')
generate.record.constructor.title=Generar constructor de Records
generate.select.default.modifier.text=Seleccionar modificador
generate.setter.fields.chooser.title=Seleccionar campos para generar Setters
generate.setter.template=Plantilla de Setter(&S)\:
generate.setters.no.fields=No se encontraron campos para generar setters
generate.setters.no.fields.without.setters=No se encontraron campos sin setter
generate.test.support.method.error.cannot.generate.method=No se puede generar el método\: {0}
generate.test.support.method.error.method.already.exists=El método {0} ya existe
generate.test.support.method.error.no.template.found.for.framework=No se encontró plantilla para {0}\:{1}
generate.tostring.already.exist.border=Cuando el método ya existe
generate.tostring.available.implicit.variables.label=Variables implícitas disponibles\:<br/>{0}
generate.tostring.exclude..transient=Excluir campos transient
generate.tostring.exclude.by.field.name=Excluir campos por nombre (exp reg)
generate.tostring.exclude.by.field.type=Excluir campos por nombre de tipo (exp reg)
generate.tostring.exclude.by.name=Excluir métodos por nombre (exp reg)
generate.tostring.exclude.by.return.type=Excluir métodos por nombre de tipo de retorno (exp reg)
generate.tostring.exclude.constant.fields=Excluir campos constantes
generate.tostring.exclude.enum.fields=Excluir campos enum
generate.tostring.exclude.logger=Excluir campos logger (Log4j, JDK Logging, Jakarta Commons Logging)
generate.tostring.exclude.static.fields=Excluir campos static
generate.tostring.fully.qualified.class.name=Usar nombre de clase completamente calificado en toString() generado ($classname)
generate.tostring.getters.in.generated.code=Usar getters en toString() generado cuando estén disponibles ($methods)
generate.tostring.handle.exception.error.message=Se produjo una excepción irrecuperable al realizar la acción - ver el log de IDEA para detalles (el stack trace debería estar en idea.log)\:\n{0}
generate.tostring.handle.exception.plugin.warning.message=Se produjo una PluginException al realizar la acción - ver el log de IDEA para detalles (el stack trace debería estar en idea.log)\:\n{0}
generate.tostring.handle.exception.velocity.error.message=Error de Velocity al generar código - ver el log de IDEA para más detalles (el stack trace debería estar en idea.log)\:\n{0}
generate.tostring.insert.border=¿Dónde insertar?
generate.tostring.method.already.exists.dialog.me=ssage\=Reemplazar método {0} existente
generate.tostring.method.already.exists.dialog.title=El método ya existe
generate.tostring.move.to.generated.checkbox=Mover cursor al método generado
generate.tostring.settings=Configuración
generate.tostring.sort.ascending=Ascendente
generate.tostring.sort.checkbox=Ordenar elementos
generate.tostring.sort.descending=Descendente
generate.tostring.sort.super=Miembros de superclase primero
generate.tostring.tab.title=Ajustes de generación de toString()
generate.tostring.template.label=Plantilla(&T)\:
generate.tostring.title=Generar toString()
generate.type.use.before.type=Colocar anotaciones generadas con target TYPE_USE entre los modificadores y el tipo
generate.type.use.before.type.description=<html>Las anotaciones con target TYPE_USE se colocarán después de cualquier modificador y directamente<br>antes del tipo. Cuando está desactivado, se colocarán antes de cualquier modificador.</html>
goto.super.class.chooser.title=Elegir superclase o interfaz
group.javadoc.alignment=Alineación
group.javadoc.blank.lines=Líneas en blanco
group.javadoc.invalid.tags=Etiquetas inválidas
group.javadoc.other=Otros
gutter.implemented.method=Método implementado
gutter.implementing.method=Método que implementa
gutter.overridden.method=Método sobrescrito
gutter.overriding.method=Método que sobrescribe
gutter.service=Servicio
gutter.sibling.inherited.method=Método heredado del mismo nivel
header.method.to.be.converted=Método a convertir
hide.out.of.cyclic.packages.action.description=Ocultar paquetes sin dependencias cíclicas
hide.out.of.cyclic.packages.action.text=Ocultar paquetes sin dependencias cíclicas
highlight.exceptions.thrown.chooser.title=Elegir clases de excepción para resaltar
highlight.imported.classes.chooser.title=Elegir clases importadas para resaltar
highlight.imported.members.chooser.title=Elegir miembros importados para resaltar
highlight.overridden.classes.chooser.title=Elegir clases para resaltar métodos sobrescritos
highlight.suppressed.warnings.choose.inspections=Elegir inspecciones para resaltar problemas suprimidos
highlight.throws.class.name=Resaltar Throws {0}
highlight.throws.popup.throwing.places=Lugares que lanzan {0}
highlight.throws.popup.usages=Usos de {0}
hint.text.added.imports=, se añadieron {0} {1, choice, 0\#importación|1\#importaciones}
hint.text.not.valid.java.identifier=No es un identificador Java válido
hint.text.occurrences.were.inlined={0} ocurrencias fueron inlined
hint.text.press.to.go.through.inlined.occurrences=Presione {0} para recorrer {1} ocurrencias inlined
hint.text.rearranged.imports=Importaciones reordenadas
hint.text.removed.imports=Se eliminaron {0} {1, choice, 0\#importación|1\#importaciones}
hint.text.tostring.method.could.not.be.created.from.template=No se pudo crear el método ''toString()'' desde la plantilla ''{0}''
hint.text.tostring.template.invalid=La plantilla toString() ''{0}'' no es válida
icon.preview=Vista previa del icono
ignore.imports.and.formatting=Ignorar imports y formato
illegal.name.validation.info=Nombre ilegal\: {0}
implement.abstract.method.potential.implementations.with.weaker.access=Se encontraron implementaciones potenciales con privilegios de acceso más débiles\: {0}
implement.method.no.methods.to.implement=No se encontraron métodos para implementar
import.layout.panel.all.other.imports=todas las demás importaciones
import.layout.panel.blank.line.entry=<línea en blanco>
import.layout.panel.down.button=Abajo
import.layout.panel.up.button=Arriba
import.layout.static.imports.separately=Organizar imports estáticos por separado
import.statically=Importar estáticamente
include.accessors=Incluir Accessors(&I)
increase.language.level.preview.description=El nivel de lenguaje para el módulo ''{0}'' será cambiado a ''{1}''
infer.nullity.progress=Post-procesando resultados…
inlay.MethodChainsInlayProvider.description=Tipos de retorno de métodos en cadenas de llamadas.
inlay.annotation.hints.external.annotations=Anotaciones que se almacenan fuera del código fuente.<br>Estas anotaciones son útiles cuando necesitas una anotación, pero no es posible añadirla al código fuente (por ejemplo, al trabajar con código de biblioteca).<br><br><a href\='https\://www.jetbrains.com/help/idea/external-annotations.html'>Documentación</a>
inlay.annotation.hints.inferred.annotations=Anotaciones que IntelliJ IDEA genera al escanear bibliotecas y código del proyecto. Estas anotaciones ayudan a entender los contratos de código y mejoran las capacidades del análisis estático. Incluyen\: <br> @Contract <br> @Nullable <br> @NotNull <br> @Unmodifiable <br>@UnmodifiableView <br><br><a href\='https\://www.jetbrains.com/help/idea/inferring-nullity.html\#inferred-annotations'>Documentación</a>
inlay.parameters.java.build.like.method=Métodos que devuelven una instancia de la clase sobre la que operan, por ejemplo, llamadas en cadenas StringBuilder u operaciones intermedias en Java 8 Stream API.
inlay.parameters.java.clear.expression.type=Llamadas a métodos que usan una expresión compleja como argumento, por ejemplo, el operador ternario o una sentencia switch de Java 13.
inlay.parameters.java.enums=Declaraciones de constantes enum que usan un constructor parametrizado.
inlay.parameters.java.method.name.contains.parameter.name=Métodos que toman un único argumento cuando el argumento esperado es claro desde el nombre del método, como en métodos accessors.
inlay.parameters.java.multiple.params.same.type=Llamadas a métodos con más de un argumento no literal del mismo tipo.
inlay.parameters.java.new.expr=Llamadas a constructores parametrizados.
inlay.parameters.java.simple.sequentially.numbered=Métodos que toman múltiples parámetros, cuyos nombres consisten en una letra seguida de un número.
insert.override.annotation=Insertar anotación @Override(&O)
inspection.anonymous.2.method.ref.display.name=El tipo anónimo puede reemplazarse con referencia a método
inspection.assert.quickfix=Assert ''{0}''
inspection.auto.add.module.requirements.quickfix=Completar dependencias de módulos
inspection.bulk.file.attributes.read.description=Se puede usar llamada bulk 'Files.readAttributes()'
inspection.bulk.file.attributes.read.message=Múltiples llamadas a atributos de archivo pueden reemplazarse con una única llamada 'Files.readAttributes()'
inspection.call.message=Llamada redundante a ''{0}()''
inspection.capturing.cleaner=Runnable pasado a Cleaner.register() captura referencia ''{0}''
inspection.capturing.cleaner.description=Cleaner captura referencia de objeto
inspection.cast.can.be.removed.narrowing.variable.type.fix.family.name=Cambiar tipo de variable y eliminar cast
inspection.cast.can.be.removed.narrowing.variable.type.fix.name=Cambiar tipo de ''{0}'' a ''{1}'' y eliminar cast
inspection.cast.can.be.removed.narrowing.variable.type.message=El cast puede eliminarse cambiando el tipo de ''{0}'' a ''{1}''
inspection.cast.can.be.removed.narrowing.variable.type.name=Tipo de variable demasiado débil lleva a cast innecesario
inspection.charset.object.can.be.used.display.name=Se puede usar objeto 'Charset' estándar
inspection.charset.object.can.be.used.fix.family.name=Usar constante Charset
inspection.charset.object.can.be.used.message=Se puede usar {0} en su lugar
inspection.collection.add.all.can.be.replaced.with.constructor.display.name=Llamada redundante a 'Collection.addAll()'
inspection.collection.factories.fix.family.name=Reemplazar con llamada a factory de colección
inspection.collection.factories.fix.name=Reemplazar con llamada ''{0}.{1}()''
inspection.collection.factories.message=Puede reemplazarse con llamada ''{0}.{1}()''
inspection.collection.factories.option.ignore.non.constant=Solo reportar cuando el contenido es constante
inspection.collection.factories.option.suggest.ofentries=Sugerir 'Map.ofEntries()'
inspection.collection.used.as.vararg.display.name=Iterable usado como vararg
inspection.collection.used.as.vararg.message=Iterable pasado como vararg\: probablemente se pretendía un array
inspection.comparator.combinators.display.name=Se puede usar combinador 'Comparator'
inspection.comparator.result.comparison.display.name=Uso sospechoso del método compare
inspection.comparator.result.comparison.fix.family.name=Corregir comparación de resultado del comparador
inspection.comparator.result.comparison.problem.display.name=Comparación del resultado del método compare con constante específica
inspection.condition.covered.by.further.condition.display.name=La condición está cubierta por otra condición posterior
inspection.conditional.break.in.infinite.loop=Mover condición al bucle
inspection.conditional.break.in.infinite.loop.allow.condition.fusion=Permitir fusión con condición de bucle existente
inspection.conditional.break.in.infinite.loop.description=Break condicional dentro del bucle
inspection.conditional.break.in.infinite.loop.no.conversion.with.do.while=No sugerir reemplazar con 'do while'
inspection.conditional.break.in.infinite.loop.suggest.conversion.when.if.is.single.stmt.in.loop=Sugerir conversión cuando 'if' es única sentencia en el bucle
inspection.conditional.can.be.optional.display.name=La condicional puede reemplazarse con Optional
inspection.convert.2.method.ref.display.name=Lambda puede reemplazarse con referencia a método
inspection.convert.2.streamapi.display.name=El bucle puede colapsarse con Stream API
inspection.convert.to.local.quickfix=Convertir a local
inspection.data.flow.constant.values.display.name=Valores constantes
inspection.data.flow.display.name=Problemas de nulabilidad y flujo de datos
inspection.data.flow.filter.notnull.quickfix=Insertar paso 'filter(Objects\:\:nonNull)'
inspection.data.flow.ignore.assert.statements=Ignorar declaraciones assert
inspection.data.flow.nullable.quickfix.option=Sugerir anotación @Nullable para métodos/campos/parámetros donde se usan valores nulables
inspection.data.flow.optional.of.nullable.misuse.display.name=Uso de Optional.ofNullable con argumento null o no-null
inspection.data.flow.report.not.null.required.parameter.with.null.literal.argument.usages=Reportar parámetro requerido no-null con usos de argumento literal null
inspection.data.flow.report.nullable.methods.that.always.return.a.non.null.value=Reportar métodos nulables que siempre devuelven un valor no-null
inspection.data.flow.report.problems.that.happen.only.on.some.code.paths=Reportar problemas que ocurren solo en algunas rutas de código
inspection.data.flow.treat.non.annotated.members.and.parameters.as.nullable=Tratar miembros y parámetros no anotados como @Nullable
inspection.data.flow.true.asserts.option=No reportar aserciones con condición estáticamente probada como siempre verdadera
inspection.data.flow.unreachable.code.display.name=Código inalcanzable
inspection.data.flow.unreachable.code.option.ignore.trivial.description=No reportar declaraciones inalcanzables como <code>return 0</code>, <code>break</code>, etc., ya que podrían ser necesarias para satisfacer las reglas de control de flujo de Java.
inspection.data.flow.unreachable.code.option.ignore.trivial.name=Ignorar declaraciones de salida triviales
inspection.data.flow.unreachable.code.option.respect.suppression.description=Intentar evitar reportar código inalcanzable si es causado por una condición constante, donde se suprime la advertencia correspondiente.
inspection.data.flow.unreachable.code.option.respect.suppression.name=Respetar las supresiones de la inspección 'Constant value'
inspection.data.flow.use.computeifpresent.quickfix=Reemplazar 'compute' con 'computeIfPresent'
inspection.dead.code.option.applet=Applets
inspection.dead.code.option.external=Clases con usos en archivos no-Java
inspection.dead.code.option.main=<html><code>void main(String args[])</code> métodos</html>
inspection.dead.code.option.servlet=Servlets
inspection.default.annotation.param=Valor de parámetro de anotación predeterminado
inspection.duplicate.branches.in.switch.default.message=La rama en 'switch' es un duplicado de la rama predeterminada
inspection.duplicate.branches.in.switch.delete.fix.family.name=Eliminar ramas 'switch' redundantes
inspection.duplicate.branches.in.switch.delete.fix.name=Eliminar rama 'switch' redundante
inspection.duplicate.branches.in.switch.display.name=Ramas duplicadas en 'switch'
inspection.duplicate.branches.in.switch.merge.fix.family.name=Fusionar ramas duplicadas en 'switch'
inspection.duplicate.branches.in.switch.merge.fix.name=Fusionar con ''{0}''
inspection.duplicate.branches.in.switch.merge.with.default.fix.name=Fusionar con la rama 'switch' predeterminada
inspection.duplicate.branches.in.switch.message=Rama duplicada en 'switch'
inspection.duplicate.expressions.complexity.threshold=Umbral de complejidad de expresión
inspection.duplicate.expressions.display.name=Múltiples ocurrencias de la misma expresión
inspection.duplicate.expressions.introduce.variable.fix.family.name=Introducir variable
inspection.duplicate.expressions.introduce.variable.fix.name=Introducir variable para ''{0}''
inspection.duplicate.expressions.message=Múltiples ocurrencias de <code>\#ref</code> \#loc
inspection.duplicate.expressions.replace.other.occurrences.fix.family.name=Reemplazar con variable otras ocurrencias de expresión
inspection.duplicate.expressions.replace.other.occurrences.fix.name=Reemplazar con ''{0}'' otras ocurrencias de ''{1}''
inspection.duplicate.expressions.reuse.variable.fix.family.name=Reutilizar variable
inspection.duplicate.expressions.reuse.variable.fix.name=Reutilizar variable ''{0}'' para ''{1}''
inspection.empty.module.info.file=Archivo 'module-info.java' vacío
inspection.endless.stream.description=Operación no cortocircuito consume stream infinito
inspection.equals.hashcode.display.name='equals()' y 'hashCode()' no emparejados
inspection.equals.hashcode.generate.equals.quickfix=Generar 'equals()'
inspection.equals.hashcode.generate.equals.quickfix.preview=Abre un diálogo para configurar la generación de 'equals()'.
inspection.equals.hashcode.generate.hashcode.quickfix=Generar 'hashCode()'
inspection.equals.hashcode.generate.hashcode.quickfix.preview=Abre un diálogo para configurar la generación de 'hashCode()'.
inspection.excessive.lambda.fix.family.name=Reemplazar lambda con constante
inspection.excessive.lambda.fix.name=Usar método ''{0}'' sin lambda
inspection.excessive.lambda.message=Uso excesivo de lambda
inspection.excessive.lambda.usage.display.name=Uso excesivo de lambda
inspection.excessive.range.check.display.name=Comprobación excesiva de rango
inspection.explicit.argument.can.be.lambda.display.name=El argumento explícito puede ser lambda
inspection.explicit.argument.can.be.lambda.fix.family.name=Reemplazar argumento explícito con función
inspection.explicit.argument.can.be.lambda.fix.name=Usar método ''{0}'' con argumento funcional
inspection.explicit.argument.can.be.lambda.message=El argumento explícito puede convertirse a lambda
inspection.explicit.array.filling.description=Puede reemplazarse con una única llamada al método ''Arrays.{0}()''
inspection.explicit.array.filling.display.name=Llenado explícito de array
inspection.explicit.array.filling.fix.family.name=Reemplazar bucle con llamada al método ''Arrays.{0}()''
inspection.explicit.array.filling.no.suggestion.for.set.all=No sugerir usar 'Arrays.setAll()'
inspection.explicit.array.filling.redundant.loop.description=Inicialización redundante de un array recién creado
inspection.explicit.array.filling.suggest.set.all=Sugerir 'Arrays.setAll()'
inspection.explicit.to.implicit.class.migration.fix.name=Convertir en clase declarada implícitamente
inspection.explicit.to.implicit.class.migration.name=La declaración explícita de clase puede convertirse en clase declarada implícitamente
inspection.export.results.callees=Cadena de llamadas
inspection.export.results.implicit.constructor=constructor implícito de
inspection.export.results.overrides.library.methods=Sobrescribe métodos de biblioteca
inspection.export.results.package=paquete
inspection.export.results.type.references=Lo siguiente usa este tipo
inspection.field.can.be.local.display.name=El campo puede ser local
inspection.field.can.be.local.problem.descriptor=El campo puede convertirse a variable local
inspection.field.can.be.local.quickfix.constructor=Convertir campo a variable local en constructor
inspection.field.can.be.local.quickfix.initializer=Convertir campo a variable local en sección inicializadora
inspection.field.can.be.local.quickfix.one.method=Convertir campo a variable local en método ''{0}''
inspection.fill.permits.list.display.name=Faltan subclases del mismo archivo en la cláusula permits de una clase sealed
inspection.fill.permits.list.fix.name=Agregar subclases faltantes a la cláusula permits
inspection.fill.permits.list.no.missing.inheritors=La clase sealed no tiene herederos faltantes
inspection.fold.expression.fix.family.name=Plegar expresión
inspection.fold.expression.into.stream.display.name=La expresión puede plegarse en cadena Stream
inspection.fold.expression.into.stream.fix.name=Plegar expresión en cadena Stream
inspection.fold.expression.into.string.display.name=La expresión puede plegarse en 'String.join'
inspection.fold.expression.into.string.fix.name=Plegar expresión en 'String.join'
inspection.forward.compatibility.name=Compatibilidad hacia adelante
inspection.frequently.used.inheritor.inspection.display.name=La clase puede extender una clase base comúnmente usada
inspection.functional.expression.can.be.folded.display.name=La expresión funcional puede plegarse
inspection.fuse.stream.operations.display.name=Los pasos subsiguientes pueden fusionarse en cadena Stream API
inspection.fuse.stream.operations.fix.family.name=Fusionar más declaraciones en la cadena Stream API
inspection.fuse.stream.operations.fix.name=Fusionar {0} en la cadena Stream API
inspection.fuse.stream.operations.message=El stream puede extenderse reemplazando {0}
inspection.fuse.stream.operations.option.strict.mode=No sugerir colectores 'toList()' o 'toSet()'
inspection.handle.signature.change.type.fix.name=Cambiar tipo a ''{0}''
inspection.handle.signature.field.cannot.resolve=No se puede resolver el campo ''{0}''
inspection.handle.signature.field.not.static=El campo ''{0}'' no es static
inspection.handle.signature.field.static=El campo ''{0}'' es static
inspection.handle.signature.field.type=El tipo del campo ''{0}'' es ''{1}''
inspection.handle.signature.method.abstract=El método ''{0}'' es abstract en ''{1}''
inspection.handle.signature.method.not.static=El método ''{0}'' no es static
inspection.handle.signature.method.static=El método ''{0}'' es static
inspection.handle.signature.name=Discrepancia de tipo MethodHandle/VarHandle
inspection.handle.signature.not.subclass=La clase llamante ''{0}'' debe ser una subclase de ''{1}''
inspection.handle.signature.use.constructor.fix.family.name=Usar una de las sobrecargas del constructor
inspection.handle.signature.use.constructor.fix.name=Usar constructor ''{0}''
inspection.handle.signature.use.method.fix.family.name=Usar una de las sobrecargas del método
inspection.handle.signature.use.method.fix.name=Usar método ''{0}''
inspection.idempotent.loop.body=Cuerpo de bucle idempotente
inspection.illegal.character=Carácter ilegal
inspection.implicit.to.explicit.class.backward.migration.fix.name=Convertir clase declarada implícitamente en clase regular
inspection.implicit.to.explicit.class.backward.migration.name=La clase declarada implícitamente puede reemplazarse con una clase ordinaria
inspection.inconsistent.text.block.indent.message=La indentación del bloque de texto consiste en tabulaciones y espacios
inspection.inconsistent.text.block.indent.name=Indentación de espacios en blanco inconsistente en bloque de texto
inspection.inconsistent.text.block.indent.spaces.to.tabs.many.to.one.fix=Reemplazar espacios con tabulaciones ({0} espacios \= 1 tabulación)
inspection.inconsistent.text.block.indent.spaces.to.tabs.one.to.one.fix=Reemplazar espacios con tabulaciones (1 espacio \= 1 tabulación)
inspection.inconsistent.text.block.indent.tabs.to.spaces.one.to.many.fix=Reemplazar tabulaciones con espacios (1 tabulación \= {0} espacios)
inspection.inconsistent.text.block.indent.tabs.to.spaces.one.to.one.fix=Reemplazar tabulaciones con espacios (1 tabulación \= 1 espacio)
inspection.input.stream.constructor.message='InputStream' puede construirse usando 'Files.newInputStream()'
inspection.insert.literal.underscores.display.name=Literal numérico ilegible
inspection.insert.literal.underscores.family.name=Insertar guiones bajos en literal numérico
inspection.io.stream.constructor.description='InputStream' y 'OutputStream' pueden construirse usando métodos de 'Files'
inspection.java.8.collection.remove.if.display.name=El bucle puede reemplazarse con 'Collection.removeIf()'
inspection.java.8.list.replace.all.display.name=El bucle puede reemplazarse con 'List.replaceAll()'
inspection.java.8.map.api.display.name=Operaciones 'Map' simplificables
inspection.java.9.collection.factory.display.name=La creación de colección inmutable puede reemplazarse con llamada a factory de colección
inspection.javadoc.blank.lines.display.name=La línea en blanco debe reemplazarse con <p> para romper líneas
inspection.javadoc.blank.lines.fix.family.name=Reemplazar líneas en blanco con <p>
inspection.javadoc.blank.lines.fix.name=Insertar <p>
inspection.javadoc.blank.lines.message=La línea en blanco será ignorada
inspection.javadoc.label.text=Etiquetas Javadoc adicionales\:
inspection.javadoc.link.as.plain.text.display.name=Enlace especificado como texto plano
inspection.javadoc.link.as.plain.text.message=Enlace especificado como texto plano
inspection.javadoc.lint.display.name=Problemas HTML en Javadoc (DocLint)
inspection.javadoc.method.problem.missing.param.tag=Falta la etiqueta requerida <code>@param</code> para el parámetro {0}
inspection.javadoc.method.problem.missing.tag.description=Falta la descripción de la etiqueta {0}
inspection.javadoc.option.ignore.deprecated=Ignorar elementos marcados como @deprecated
inspection.javadoc.option.ignore.period=Ignorar problemas de punto
inspection.javadoc.option.ignore.self.ref=Ignorar Javadoc que apunta a sí mismo
inspection.javadoc.option.ignore.simple=Ignorar accesores de propiedades simples
inspection.javadoc.option.ignore.throws=Ignorar etiqueta 'throws' duplicada
inspection.javadoc.option.tab.title=Clase
inspection.javadoc.option.tab.title.field=Campo
inspection.javadoc.option.tab.title.inner.class=Clase interna
inspection.javadoc.option.tab.title.method=Método
inspection.javadoc.option.tab.title.module=Módulo
inspection.javadoc.option.tab.title.package=Paquete
inspection.javadoc.problem.add.param.tag=Agregar etiqueta @param para el parámetro ''{0}''
inspection.javadoc.problem.add.param.tag.family=Agregar etiqueta @param faltante de Javadoc
inspection.javadoc.problem.add.tag=Agregar etiqueta @{0} {1}
inspection.javadoc.problem.add.tag.family=Agregar etiqueta Javadoc faltante
inspection.javadoc.problem.cannot.resolve=No se puede resolver el símbolo {0}
inspection.javadoc.problem.descriptor=Falta el Javadoc requerido
inspection.javadoc.problem.descriptor1=Falta el punto en la documentación. El punto es usado por la herramienta Javadoc para generar el comentario de la página de resumen
inspection.javadoc.problem.disallowed.tag=La etiqueta {0} no está permitida aquí
inspection.javadoc.problem.duplicate.param=Etiqueta @param duplicada para el parámetro ''{0}''
inspection.javadoc.problem.duplicate.tag=Etiqueta @{0} duplicada
inspection.javadoc.problem.duplicate.throws=Etiqueta @throws o @exception duplicada para la excepción ''{0}''
inspection.javadoc.problem.inaccessible=El símbolo {0} es inaccesible desde aquí
inspection.javadoc.problem.missing.tag=Falta la etiqueta requerida {0}
inspection.javadoc.problem.missing.tag.description=Falta {0} después de la etiqueta @{1}
inspection.javadoc.problem.name.expected=Se esperaba un nombre
inspection.javadoc.problem.pointing.to.itself=Javadoc apuntando a sí mismo
inspection.javadoc.problem.see.tag.expecting.ref=Se espera una referencia de clase/método, texto entre comillas o enlace HTML después de la etiqueta @see
inspection.javadoc.problem.snippet.tag.is.not.available=La etiqueta '@snippet' no está disponible en este nivel de lenguaje
inspection.javadoc.problem.wrong.tag=Etiqueta incorrecta {0}
inspection.javadoc.ref.display.name=La declaración tiene problemas en las referencias Javadoc
inspection.javadocDeclaration.display.name=Problemas en declaración de Javadoc
inspection.join.declaration.and.assignment.display.name=La asignación puede unirse con la declaración
inspection.join.declaration.and.assignment.fix.family.name=Unir declaración y asignación
inspection.join.declaration.and.assignment.fix.title=Unir Declaración y Asignación
inspection.join.declaration.and.assignment.message=La asignación puede unirse con la declaración de ''{0}''
inspection.labeled.switch.rule.redundant.code.block.display.name=La regla switch etiquetada tiene un bloque de código redundante
inspection.labeled.switch.rule.redundant.code.block.message=El bloque de código de la regla etiquetada es redundante
inspection.labeled.switch.rule.redundant.code.fix.name=Desenvolver bloque de código de regla etiquetada
inspection.lambda.can.be.method.call.display.name=Lambda puede reemplazarse con llamada a método
inspection.lambda.to.method.call.fix.family.name=Reemplazar expresión lambda con llamada a método
inspection.lambda.to.method.call.fix.name=Reemplazar expresión lambda con ''{0}''
inspection.magic.constant.display.name=Constante mágica
inspection.magic.constants.should.be.one.of.values=Debería ser uno de\: {0}{1,choice,0\#|1\# o su combinación}
inspection.manual.min.max.calculation.description=Puede reemplazarse con llamada a ''Math.{0}()''
inspection.manual.min.max.calculation.disable.for.non.integral=Deshabilitar para float y double
inspection.manual.min.max.calculation.display.name=Cálculo manual de min/max
inspection.map.foreach.display.name=Se puede usar Map.forEach()
inspection.map.foreach.option.no.loops=No reportar bucles
inspection.mapping.before.count.family.name=Llamada de mapping antes de count()
inspection.mapping.before.count.message=La llamada ''{0}()'' no cambia el conteo final y podría ser optimizada.
inspection.meaningless.record.annotation.description=Anotación de registro sin sentido
inspection.meaningless.record.annotation.message.method=La anotación no tiene efecto\: su objetivo es METHOD pero el accessor correspondiente está declarado explícitamente
inspection.meaningless.record.annotation.message.method.and.parameter=La anotación no tiene efecto\: sus objetivos son METHOD y PARAMETER pero tanto el accessor como el constructor canónico están declarados explícitamente
inspection.meaningless.record.annotation.message.parameter=La anotación no tiene efecto\: su objetivo es PARAMETER pero el constructor canónico está declarado explícitamente
inspection.message.anonymous.ref.loc.can.be.replaced.with.method.reference=El \#ref \#loc anónimo puede reemplazarse con referencia a método
inspection.message.can.be.replaced.with.0.constructor=Puede reemplazarse con el constructor ''{0}''
inspection.message.can.be.replaced.with.files.readstring=Puede reemplazarse con 'Files.readString()'
inspection.message.can.be.replaced.with.files.writestring=Puede reemplazarse con 'Files.writeString()'
inspection.message.can.be.replaced.with.optional.of.nullable=Puede reemplazarse con Optional.ofNullable()
inspection.message.can.be.replaced.with.single.expression.in.functional.style=Puede reemplazarse con una expresión única en estilo funcional
inspection.message.can.be.replaced.with.string.repeat=Puede reemplazarse con 'String.repeat()'
inspection.message.external.snippet.differs.from.inline.snippet=El snippet externo difiere del snippet inline
inspection.message.filter.is.present.chain.can.be.replaced.with.anymatch=La cadena ''filter().{0}().isPresent()'' puede reemplazarse con ''anyMatch()''
inspection.message.full.description=Descripción completa
inspection.message.lambda.parameter.type.is.redundant=El tipo del parámetro lambda es redundante
inspection.message.pattern.variables.can.be.replaced.with.cast=Usando 'instanceof' con patrones
inspection.message.pattern.variables.can.be.replaced.with.cast.family.name=Reemplazar sin patrones
inspection.message.pattern.variables.can.be.replaced.with.cast.fix.name=Reemplazar ''{0}'' con conversiones
inspection.message.pattern.variables.can.be.replaced.with.cast.preserve.option=Intentar preservar variables no usadas de patrones durante la corrección rápida
inspection.message.pseudo.functional.style.code=Código de estilo pseudo funcional
inspection.message.record.can.be.converted.to.class=El record puede convertirse a clase
inspection.message.redundant.default.parameter.value.assignment=Asignación redundante de valor por defecto al parámetro
inspection.message.replace.optional.with.if.statements=Reemplazar Optional con sentencias if
inspection.message.snippet.file.not.found=No se encuentra el archivo de snippet ''{0}''
inspection.message.snippet.region.not.found=No se encuentra la región
inspection.missingJavadoc.display.name=Falta Javadoc
inspection.missingJavadoc.label.minimalVisibility=Visibilidad mínima\:
inspection.missingJavadoc.label.requiredTags=Etiquetas requeridas\:
inspection.move.field.assignment.to.initializer.display.name=La asignación de campo puede moverse al inicializador
inspection.no.jdk.error.message=El JDK no está configurado correctamente para este proyecto. No se puede proceder con la inspección.
inspection.no.modules.error.message=Este proyecto no contiene módulos. No se puede proceder con la inspección.
inspection.notnull.field.not.initialized.display.name=Campo @NotNull no inicializado
inspection.notnull.field.not.initialized.message=Los campos {0} deben ser inicializados
inspection.notnull.field.not.initialized.option.implicit=Ignorar campos que podrían inicializarse implícitamente
inspection.notnull.field.not.initialized.option.implicit.description=Cuando está marcado, no se reportarán los campos que se sabe que se inicializan implícitamente (por ejemplo, mediante inyección de dependencias)
inspection.notnull.field.not.initialized.option.setup=Ignorar campos inicializados en el método setUp()
inspection.notnull.field.not.initialized.option.setup.description=Cuando está marcado, no se reportarán los campos en clases de prueba que se inicializan en métodos de configuración (por ejemplo, anotados con <code>@Before</code> o <code>@BeforeEach</code>).
inspection.null.value.for.optional.assigned.ignore.fix.name=No advertir al comparar Optional con null
inspection.null.value.for.optional.assigned.message=El valor Optional se compara con null
inspection.null.value.for.optional.context.assignment=asignación
inspection.null.value.for.optional.context.declaration=declaración
inspection.null.value.for.optional.context.lambda=expresión lambda
inspection.null.value.for.optional.context.parameter=parámetro
inspection.null.value.for.optional.context.return=sentencia return
inspection.null.value.for.optional.fix.family.name=Reemplazar con método Optional vacío
inspection.null.value.for.optional.message=Se usa null para el tipo ''Optional'' en {0}
inspection.null.value.for.optional.option.comparisons=Reportar comparación de Optional con null
inspection.nullable.problems.display.name=Problemas con @NotNull/@Nullable
inspection.nullable.problems.ignore.external.notnull=Ignorar @NotNull externo(&I)
inspection.nullable.problems.method.overrides.notnull.option=Reportar parámetros @NotNull que sobreescriben @Nullable y viceversa(&P)
inspection.nullable.problems.method.overrides.option=Reportar parámetros o métodos no anotados que sobreescriben @NotNull(&A)
inspection.nullable.problems.not.annotated.getters.for.annotated.fields=Reportar parámetros setter o getters no anotados de campos anotados(&S)
inspection.nullable.problems.notnull.overrides.option=Reportar parámetros @NotNull que sobreescriben no anotados(&P)
inspection.nullable.problems.notnull.parameters.with.null.literal.option=Reportar parámetros @NotNull con usos de argumentos literal null
inspection.obvious.null.check.display.name=Se llama al método de comprobación null con argumento obviamente no null
inspection.optional.assigned.to.null.display.name=Valor null para tipo Optional
inspection.optional.get.without.is.present.display.name=Optional.get() se llama sin comprobación isPresent()
inspection.optional.get.without.is.present.message=<code>{0}.\#ref()</code> sin comprobación ''isPresent()''
inspection.optional.get.without.is.present.method.reference.message=<code>\#ref</code> sin comprobación 'isPresent()'
inspection.optional.is.present.display.name=Uso no funcional de 'Optional.isPresent()'
inspection.optional.to.if.display.name='Optional' puede ser reemplazado con secuencia de sentencias 'if'
inspection.output.stream.constructor.message='OutputStream' puede construirse usando 'Files.newOutputStream()'
inspection.overflowing.loop.index.inspection.description=El bucle se ejecuta cero o billones de veces
inspection.overflowing.loop.index.inspection.name=El bucle se ejecuta cero o billones de veces
inspection.overwritten.key.array.message=Elemento de array sobrescrito
inspection.overwritten.key.display.name=Elemento sobrescrito de Map, Set o array
inspection.overwritten.key.map.message=Clave Map duplicada
inspection.overwritten.key.set.message=Elemento Set duplicado
inspection.parameter.can.be.local.display.name=El valor pasado como parámetro nunca se lee
inspection.parameter.can.be.local.problem.descriptor=El parámetro puede convertirse a variable local
inspection.preview.feature=Advertencia de función preliminar
inspection.preview.feature.0.is.preview.api.message={0} es una API preliminar y podría eliminarse en una versión futura
inspection.quickfix.assert.family=Assert
inspection.raw.use.of.parameterized.type.problem.descriptor=Uso raw de clase parametrizada <code>\#ref</code> \#loc
inspection.read.write.string.can.be.used.display.name=Se puede usar 'Files.readString()' o 'Files.writeString()'
inspection.redundant.array.creation.display.name=Creación redundante de array
inspection.redundant.array.creation.for.varargs.call.descriptor=Creación redundante de array para llamar a método varargs
inspection.redundant.array.creation.quickfix=Eliminar creación explícita de array
inspection.redundant.explicit.close=Redundante 'close()'
inspection.redundant.file.creation.description=<code>\#ref</code> es redundante \#loc
inspection.redundant.file.creation.display.name=Creación redundante de instancia 'File'
inspection.redundant.file.creation.quickfix=Reemplazar con nombre de archivo
inspection.redundant.lambda.parameter.type.display.name=Tipos de parámetros lambda redundantes
inspection.redundant.null.check.always.fail.message=La comprobación de null siempre fallará\: {0} nunca es null
inspection.redundant.null.check.fix.family.name=Eliminar comprobación redundante de null
inspection.redundant.null.check.fix.notnull.family.name=Eliminar erróneo '\!\= null'
inspection.redundant.null.check.message=Comprobación redundante de null\: {0} nunca es null
inspection.redundant.operation.on.empty.array.message=El array <code>\#ref</code> siempre está vacío
inspection.redundant.operation.on.empty.collection.message=La colección <code>\#ref</code> siempre está vacía
inspection.redundant.operation.on.empty.container.display.name=Operación redundante en contenedor vacío
inspection.redundant.operation.on.empty.map.message=El Map <code>\#ref</code> siempre está vacío
inspection.redundant.record.constructor.can.be.compact.message=El constructor canónico puede convertirse a forma compacta
inspection.redundant.record.constructor.canonical.message=Constructor canónico redundante
inspection.redundant.record.constructor.compact.message=Constructor compacto redundante
inspection.redundant.record.constructor.description=Constructor de record redundante
inspection.redundant.record.constructor.fix.family.name=Convertir constructor canónico a forma compacta
inspection.redundant.record.constructor.statement.message=Asignación de campo redundante en constructor compacto
inspection.redundant.stream.optional.call.display.name=Paso redundante en cadena de llamadas 'Stream' o 'Optional'
inspection.redundant.stream.optional.call.explanation.at.most.one=el stream contiene como máximo un elemento
inspection.redundant.stream.optional.call.explanation.distinct=hay una llamada 'distinct()' previa en la cadena
inspection.redundant.stream.optional.call.explanation.distinct.set=los elementos serán distintos de todas formas cuando se recolecten en un Set
inspection.redundant.stream.optional.call.explanation.filter=el predicado es siempre 'true'
inspection.redundant.stream.optional.call.explanation.map.flatMap=la llamada 'map()' anterior puede reemplazar el paso 'flatMap()'
inspection.redundant.stream.optional.call.explanation.parallel=existe una llamada posterior ''{0}()'' que sobrescribe esta llamada
inspection.redundant.stream.optional.call.explanation.parallel.single=el stream creado de un solo elemento no será paralelizado
inspection.redundant.stream.optional.call.explanation.parallel.source=el stream fue creado vía 'parallelStream()', así que ya es paralelo
inspection.redundant.stream.optional.call.explanation.sequential.source=el stream fue creado vía 'stream()', así que ya es secuencial
inspection.redundant.stream.optional.call.explanation.sorted=la operación posterior ''{0}()'' no depende del orden de clasificación
inspection.redundant.stream.optional.call.explanation.sorted.parallel=la operación posterior ''{0}()'' no depende del orden de clasificación para streams paralelos
inspection.redundant.stream.optional.call.explanation.sorted.twice=hay una llamada 'sorted()' posterior en la cadena
inspection.redundant.stream.optional.call.explanation.unordered=hay una llamada 'unordered()' previa en la cadena
inspection.redundant.stream.optional.call.fix.bind.name=Fusionar el paso ''{0}()'' con el paso anterior ''{1}()''
inspection.redundant.stream.optional.call.fix.collect.to.ordered.family.name=Recolectar a 'LinkedHashSet'
inspection.redundant.stream.optional.call.fix.family.name=Eliminar llamada redundante de cadena
inspection.redundant.stream.optional.call.fix.name=Eliminar llamada ''{0}()''
inspection.redundant.stream.optional.call.fix.replace.terminal=Reemplazar la operación terminal
inspection.redundant.stream.optional.call.fix.replace.terminal.text=Reemplazar la operación terminal con ''{0}()''
inspection.redundant.stream.optional.call.message.with.explanation=Llamada redundante ''{0}()''\: {1}
inspection.redundant.stream.optional.call.option.streamboxing=Reportar boxing redundante en Stream.map()
inspection.redundant.unmodifiable.call.description=Uso redundante de wrappers de colección inmutable
inspection.redundant.unmodifiable.call.display.name=Uso redundante del wrapper ''{0}''
inspection.redundant.unmodifiable.call.unwrap.argument.quickfix=Desenvolver argumento
inspection.reflect.handle.invocation.argument.not.array=El argumento no es un tipo array
inspection.reflect.handle.invocation.argument.not.exact=El tipo de argumento debe ser exactamente ''{0}''
inspection.reflect.handle.invocation.primitive.argument.null=El argumento de tipo ''{0}'' no puede ser ''null''
inspection.reflect.handle.invocation.receiver.incompatible=El tipo del receptor de llamada es incompatible\: se espera ''{0}''
inspection.reflect.handle.invocation.receiver.null=El receptor de llamada es 'null'
inspection.reflect.handle.invocation.result.not.assignable=Debe convertirse a ''{0}'' o su superclase
inspection.reflect.handle.invocation.result.not.exact=Debe convertirse a ''{0}''
inspection.reflect.handle.invocation.result.null=El valor retornado siempre es 'null'
inspection.reflect.handle.invocation.result.void=El tipo de retorno es 'void'
inspection.reflection.invocation.argument.count=Se {0,choice,0\#esperan 0 argumentos|1\#espera 1 argumento|1<esperan {0} argumentos}
inspection.reflection.invocation.argument.not.assignable=El argumento no es asignable a ''{0}''
inspection.reflection.invocation.array.not.assignable=Los {0,choice,1\#elementos del array tienen|1<elementos del array tienen} {0,choice,1\#tipo incompatible|1<tipos incompatibles}
inspection.reflection.invocation.item.count=Se espera {0,choice,0\#un array vacío|1\#un array de un elemento|1<un array de {0} elementos}
inspection.reflection.invocation.item.not.assignable=El elemento del array no es asignable a ''{0}''
inspection.reflection.invocation.name=Discrepancia en argumentos de invocación reflexiva
inspection.reflection.member.access.cannot.resolve.constructor.arguments=No se puede resolver el constructor con los tipos de argumentos especificados
inspection.reflection.member.access.cannot.resolve.field=No se puede resolver el campo ''{0}''
inspection.reflection.member.access.cannot.resolve.method=No se puede resolver el método ''{0}''
inspection.reflection.member.access.cannot.resolve.method.arguments=No se puede resolver el método ''{0}'' con los tipos de argumentos especificados
inspection.reflection.member.access.check.exists=Verificar que el campo/método existe en clases no finales
inspection.reflection.member.access.check.exists.exclude.chooser=Clase a excluir
inspection.reflection.member.access.check.exists.exclude.label=Excluir clases\:
inspection.reflection.member.access.constructor.not.public=El constructor no es público
inspection.reflection.member.access.field.not.in.class=El campo ''{0}'' no está declarado en la clase ''{1}''
inspection.reflection.member.access.field.not.public=El campo ''{0}'' no es público
inspection.reflection.member.access.fix.family.name=Usar método de reflexión apropiado
inspection.reflection.member.access.method.not.in.class=El método ''{0}'' no está declarado en la clase ''{1}''
inspection.reflection.member.access.method.not.public=El método ''{0}'' no es público
inspection.reflection.member.access.name=Acceso reflexivo a miembro de clase inexistente o no visible
inspection.reflection.visibility.name=Problemas de acceso reflexivo entre módulos
inspection.remove.literal.underscores.display.name=Guiones bajos en literal numérico
inspection.remove.literal.underscores.family.name=Eliminar guiones bajos del literal numérico
inspection.replace.inefficient.stream.count.display.name=Cadenas de llamadas Stream API ineficientes que terminan con count()
inspection.replace.javadoc.display.name=Comentario reemplazable con Javadoc
inspection.replace.methodref.ternary.quickfix=Reemplazar con lambda de comprobación null
inspection.replace.ternary.quickfix=Reemplazar con ''{0} \!\= null ?\:''
inspection.replace.with.bulk.file.attributes.read.fix.family.name=Reemplazar con llamada bulk a 'Files.readAttributes()'
inspection.replace.with.bulk.fix.family.name=Reemplazar con llamada a método bulk
inspection.replace.with.bulk.fix.name=Reemplazar iteración con llamada bulk ''{0}()''
inspection.replace.with.bulk.message=La iteración puede reemplazarse con llamada bulk ''{0}()''
inspection.replace.with.bulk.wrap.arrays=Usar 'Arrays.asList()' para envolver arrays
inspection.replace.with.enhanced.switch.statement.fix.name=Reemplazar con sentencia 'switch' mejorada
inspection.replace.with.javadoc=Reemplazar con comentario Javadoc
inspection.replace.with.javadoc.comment=El comentario puede convertirse a Javadoc
inspection.replace.with.old.style.switch.statement.fix.name=Reemplazar con sentencia 'switch' de estilo antiguo
inspection.replace.with.regular.string.literal.fix=Reemplazar con literal de cadena regular
inspection.replace.with.string.concatenation.fix=Reemplazar con concatenación de cadenas
inspection.replace.with.string.template.fix=Reemplazar con plantilla de cadena
inspection.replace.with.switch.expression.fix.family.name=Migrar a switch mejorado
inspection.replace.with.switch.expression.fix.name=Reemplazar con expresión 'switch'
inspection.replace.with.text.block.fix=Reemplazar con bloque de texto
inspection.replace.with.trivial.lambda.fix.family.name=Reemplazar con lambda trivial
inspection.replace.with.trivial.lambda.fix.name=Reemplazar con lambda que retorna ''{0}''
inspection.require.non.null=Reemplazar comprobación null con llamada estática Objects/Stream
inspection.require.non.null.description=La comprobación null puede reemplazarse con llamada a método
inspection.require.non.null.message=La {0, choice, 1\#sentencia ''if''|2\#expresión condicional} puede reemplazarse con llamada a ''{1}()''
inspection.require.non.null.no.warning.replacement.bigger=No advertir si el reemplazo es más largo que el original
inspection.require.non.null.quickfix=Reemplazar {0, choice, 1\#sentencia ''if''|2\#expresión condicional} con llamada a ''{1}()''
inspection.return.separated.from.computation.descriptor=Return separado del cálculo del valor de ''{0}''
inspection.return.separated.from.computation.family.quickfix=Mover 'return' más cerca del cálculo del resultado
inspection.return.separated.from.computation.name='return' separado del cálculo del resultado
inspection.return.separated.from.computation.quickfix=Mover ''return'' más cerca del cálculo del valor de ''{0}''
inspection.same.parameter.display.name=El parámetro del método siempre tiene el mismo valor
inspection.same.parameter.fix.family.name=Inline parámetro como valor constante
inspection.same.parameter.fix.name=Inline valor ''{1}'' para parámetro ''{0}''
inspection.same.parameter.problem.descriptor=El valor del parámetro <code>\#ref</code> siempre es ''{0}''
inspection.simplifiable.comparator.comparing.message=Llamada innecesaria a ''{0}()''
inspection.simplifiable.comparator.display.name=El método Comparator puede simplificarse
inspection.simplifiable.comparator.entry.comparator.message=Se puede usar ''{0}'' en su lugar
inspection.simplifiable.comparator.fix.comparing.family.name=Eliminar llamada redundante
inspection.simplifiable.comparator.fix.entry.comparator.family.name=Usar comparador 'Map.Entry' predefinido
inspection.simplifiable.comparator.fix.remove.name=Eliminar llamada a ''{0}()''
inspection.simplifiable.comparator.fix.replace.name=Eliminar llamada a ''{0}()'' y usar ''{1}()''
inspection.simplifiable.comparator.fix.reversed.family.name=Simplificar método comparator reemplazando 'max' con 'min'
inspection.simplifiable.comparator.fix.reversed.name=Reemplazar con ''{0}'' simplificando el comparator
inspection.simplifiable.comparator.reversed.message=El método comparator puede simplificarse si la llamada a ''{0}()'' se reemplaza con ''{1}()''
inspection.simplify.collector.display.name=Collector simplificable
inspection.simplify.collector.fix.family.name=Simplificar collector en cascada
inspection.simplify.collector.fix.name=Usar collector ''Collectors.{0}()''
inspection.simplify.collector.message=Puede simplificarse usando el collector ''{0}()''
inspection.simplify.for.each.extract.intermediate.operations=Extraer operaciones intermedias
inspection.simplify.foreach.display.name=Llamada forEach() simplificable
inspection.simplify.optional.call.chains.display.name=La cadena de llamadas Optional puede simplificarse
inspection.simplify.stream.api.call.chains.display.name=La cadena de llamadas Stream API puede simplificarse
inspection.slow.abstract.set.remove.all.description=La llamada a 'set.removeAll(list)' puede funcionar lentamente
inspection.slow.abstract.set.remove.all.fix.family.name=Usar 'Set.remove' en lugar de 'Set.removeAll'
inspection.slow.list.contains.all.description=La llamada a 'list.containsAll(collection)' puede tener bajo rendimiento
inspection.slow.list.contains.all.fix.family.name=Envolver en constructor 'HashSet'
inspection.slow.list.contains.all.fix.name=Envolver ''{0}'' en constructor ''HashSet''
inspection.sorted.collection.with.non.comparable.keys.display.name=Colección ordenada con elementos no comparables
inspection.sorted.collection.with.non.comparable.keys.message=Construcción de colección ordenada con elementos no comparables
inspection.sorted.collection.with.non.comparable.keys.option.type.parameters=No reportar parámetros de tipo no comparables
inspection.static.pseudo.functional.style.method.display.name=La llamada pseudo-funcional de Guava puede convertirse a llamada Stream API
inspection.stream.api.migration.can.be.replaced.with.call=Puede reemplazarse con llamada a ''{0}''
inspection.stream.to.loop.display.name=La cadena de llamadas Stream API puede reemplazarse con un bucle
inspection.string.repeat.can.be.used.display.name=Se puede usar String.repeat()
inspection.string.template.migration.concatenation.message=La concatenación puede reemplazarse con template de cadena
inspection.string.template.migration.name=Se puede usar template de cadena
inspection.string.template.migration.string.message=La cadena puede reemplazarse con template
inspection.string.template.reverse.migration.name=El template de cadena puede ser una cadena concatenada
inspection.string.template.reverse.migration.string.message=El template de cadena puede reemplazarse con concatenación de cadenas
inspection.surround.if.family=Envolver con if
inspection.surround.if.quickfix=Envolver con ''if ({0}{1})''
inspection.suspicious.list.remove.display.name='List.remove()' sospechoso en bucle
inspection.suspicious.return.byte.input.stream.convert.to.unsigned=Convertir a byte sin signo
inspection.suspicious.return.byte.input.stream.name=Valor de byte sospechoso devuelto desde 'InputStream.read()'
inspection.suspicious.ternary.in.varargs.description=El operador ternario en la llamada varargs contiene ramas de array y no array
inspection.suspicious.ternary.in.varargs.display.name=Operador ternario sospechoso en llamada a método varargs
inspection.suspicious.ternary.in.varargs.quickfix=Envolver en inicializador de array
inspection.switch.expression.backward.expression.migration.inspection.name=La expresión 'switch' puede reemplazarse con una sentencia 'switch' de estilo antiguo
inspection.switch.expression.backward.migration.inspection.name='switch' mejorado
inspection.switch.expression.backward.statement.migration.inspection.name=La sentencia 'switch' puede reemplazarse con una sentencia 'switch' de estilo antiguo
inspection.switch.expression.migration.expression.max.statements=Número máximo de sentencias en una rama para convertir a expresión switch
inspection.switch.expression.migration.inspection.name=La sentencia puede reemplazarse con 'switch' mejorado
inspection.switch.expression.migration.inspection.switch.description=La sentencia Switch puede reemplazarse con 'switch' mejorado
inspection.switch.expression.migration.option.expression.max.statements=No reportar switches que tengan más de {0} {0, choice, 1\#sentencia|2\#sentencias} en una sola rama
inspection.switch.expression.migration.warn.only.on.expression=Mostrar advertencia solo si es posible la conversión a expresión
inspection.switch.labeled.rule.can.be.code.block.display.name=La regla switch etiquetada puede tener bloque de código
inspection.switch.labeled.rule.can.be.code.block.expression.message=La expresión de resultado de la regla etiquetada puede envolverse con bloque de código
inspection.switch.labeled.rule.can.be.code.block.fix.expression.name=Envolver expresión de resultado de regla etiquetada con bloque de código
inspection.switch.labeled.rule.can.be.code.block.fix.statement.name=Envolver sentencia de regla etiquetada con bloque de código
inspection.switch.labeled.rule.can.be.code.block.statement.message=La sentencia de regla etiquetada puede envolverse con bloque de código
inspection.text.block.backward.migration.message=El bloque de texto puede convertirse a literal de cadena regular
inspection.text.block.backward.migration.name=El bloque de texto puede reemplazarse con literal de cadena regular
inspection.text.block.migration.concatenation.message=La concatenación puede reemplazarse con bloque de texto
inspection.text.block.migration.name=Se puede usar bloque de texto
inspection.text.block.migration.string.message=La cadena puede reemplazarse con bloque de texto
inspection.text.block.migration.suggest.literal.replacement=Reportar literales de cadena individuales
inspection.trailing.whitespaces.in.text.block.message=Caracteres de espacio en blanco finales dentro del bloque de texto
inspection.trailing.whitespaces.in.text.block.name=Espacios en blanco finales en bloque de texto
inspection.trailing.whitespaces.in.text.block.remove.whitespaces=Eliminar caracteres de espacio en blanco finales
inspection.trailing.whitespaces.in.text.block.replaces.whitespaces.with.escapes=Escapar caracteres de espacio en blanco finales
inspection.trivial.functional.expression.usage.display.name=Uso trivial de expresión funcional
inspection.unchecked.warning.display.name=Advertencia no verificada
inspection.undeclared.service.usage.message=El uso del servicio ''{0}'' no está declarado en module-info
inspection.undeclared.service.usage.name=Uso de servicio no declarado en 'module-info'
inspection.unresolved.module.dependencies.problem.descriptor=Dependencias de módulo no resueltas
inspection.unused.assignment.display.name=Asignación no utilizada
inspection.unused.assignment.option=Reportar expresiones prefix que pueden reemplazarse con una expresión binaria
inspection.unused.assignment.option1=Reportar expresiones postfix donde el valor modificado no se usa
inspection.unused.assignment.option2=Reportar inicializadores redundantes
inspection.unused.assignment.option3=Reportar variables de patrón cuyos valores nunca se usan
inspection.unused.assignment.option4=Reportar parámetros de iteración cuyos valores nunca se usan
inspection.unused.assignment.problem.descriptor1=La variable <code>\#ref</code> \#loc nunca se usa
inspection.unused.assignment.problem.descriptor2=El inicializador <code>\#ref</code> \#loc de la variable <code>{0}</code> es redundante
inspection.unused.assignment.problem.descriptor3=El valor <code>{0}</code> asignado a <code>\#ref</code> \#loc nunca se usa
inspection.unused.assignment.problem.descriptor4=El valor modificado en <code>\#ref</code> \#loc nunca se usa
inspection.unused.assignment.problem.descriptor5=El valor de la variable de patrón <code>\#ref</code> \#loc nunca se usa
inspection.unused.assignment.problem.descriptor6=El valor del parámetro de iteración foreach <code>\#ref</code> \#loc nunca se usa
inspection.unused.assignment.remove.assignment.quickfix=Eliminar asignación redundante
inspection.unused.assignment.remove.assignment.quickfix.title=Eliminar Asignación Redundante
inspection.unused.assignment.remove.initializer.quickfix=Eliminar inicializador redundante
inspection.unused.assignment.remove.initializer.quickfix.title=Eliminar Inicializador Redundante
inspection.unused.display.name=Declaración no utilizada
inspection.unused.parameter.composer=El parámetro <code>\#ref</code> no se usa en ninguna implementación
inspection.unused.parameter.composer1=El parámetro <code>\#ref</code> no se usa en este método ni en ninguno de sus métodos de sobrescritura
inspection.unused.parameter.delete.family=Eliminar de forma segura parámetro(s) no usado(s)
inspection.unused.parameter.delete.quickfix=Eliminar de forma segura el parámetro no usado ''{0}''
inspection.unused.parameter.problem.descriptor=El parámetro <code>\#ref</code> no se usa
inspection.unused.return.value.display.name=El método puede ser 'void'
inspection.unused.return.value.make.void.quickfix=Hacer el método void
inspection.unused.return.value.problem.descriptor=El valor de retorno del método nunca se usa
inspection.unused.symbol.check.accessors=Getters/setters
inspection.unused.symbol.check.classes=Clases\:
inspection.unused.symbol.check.fields=Campos\:
inspection.unused.symbol.check.inner.classes=Clases internas\:
inspection.unused.symbol.check.localvars=Variables locales
inspection.unused.symbol.check.methods=Métodos\:
inspection.unused.symbol.check.parameters=Parámetros en\:
inspection.unused.symbol.check.parameters.excluding.hierarchy=Excluyendo jerarquía
inspection.use.bulk.operation.display.name=Se puede usar operación masiva en lugar de iteración
inspection.value.based.warnings=Advertencias basadas en valor
inspection.value.based.warnings.synchronization=Intento de sincronización en una instancia de una clase basada en valor
inspection.variable.assigned.to.itself.display.name=La variable está asignada a sí misma
inspection.wrapper.type.may.be.primitive.display.name=El tipo wrapper puede ser primitivo
inspection.wrapper.type.may.be.primitive.fix.name=Convertir tipo wrapper a primitivo
inspection.wrapper.type.may.be.primitive.name=El tipo puede ser primitivo
intention.add.explicit.type.arguments.family=Agregar argumentos de tipo explícitos
intention.add.on.demand.static.import.family=Agregar static import bajo demanda
intention.add.on.demand.static.import.text=Agregar static import bajo demanda para ''{0}''
intention.add.single.member.import.text=Agregar import para ''{0}''
intention.add.single.member.static.import.family=Agregar static import de miembro único
intention.add.single.member.static.import.text=Agregar static import para ''{0}''
intention.assign.field.from.parameter.family=Asignar parámetro a campo
intention.assign.field.from.parameter.text=Asignar parámetro al campo ''{0}''
intention.bind.fields.from.parameters.family=Vincular parámetros a campos
intention.bind.fields.from.parameters.text=Vincular {0} parámetros a campos
intention.break.string.on.line.breaks.text=Romper cadena en '\\n'
intention.category.annotations=Java/Anotaciones
intention.category.collections=Java/Colecciones
intention.category.comments=Java/Comentarios
intention.category.concurrency=Java/Concurrencia
intention.category.conditional.operator=Java/Condiciones
intention.category.control.flow=Java/Flujo de control
intention.category.declaration=Java/Declaración
intention.category.expressions=Java/Expresiones
intention.category.i18n=Java/Internacionalización
intention.category.imports=Java/Imports
intention.category.junit=Java/JUnit
intention.category.other=Java/Otros
intention.category.refactorings=Java/Refactorizaciones
intention.category.streams=Java/Streams
intention.category.strings=Java/Strings
intention.category.try.statements=Java/Sentencias try
intention.compose.function.family=Reemplazar llamada de función anidada con composición
intention.compose.function.text=Reemplazar llamada de función anidada con llamada andThen
intention.convert.color.representation.family=Convertir representación de Color
intention.convert.color.representation.text=Convertir a ''new Color{0}''
intention.convert.compact.constructor.to.canonical=Convertir constructor compacto a canónico
intention.convert.to.single.return.command.text=Transformar Cuerpo a Forma de Punto de Salida Único
intention.convert.to.single.return.name=Transformar cuerpo a forma de punto de salida único
intention.convert.to.single.return.progress.title=Transformar cuerpo a forma de punto de salida único
intention.create.annotation.method.from.usage=Crear método @interface ''{0}()''
intention.create.field.from.parameter.family=Crear campo para parámetro
intention.create.field.from.parameter.text=Crear campo para parámetro ''{0}''
intention.create.switch.statement=Crear sentencia switch
intention.create.test.dialog.choose.super.class=Elegir Superclase
intention.create.test.dialog.class.name=Nombre de clase\:
intention.create.test.dialog.fix.library=Corregir
intention.create.test.dialog.generate=Generar\:
intention.create.test.dialog.java=Java
intention.create.test.dialog.library.not.found=Biblioteca {0} no encontrada en el módulo
intention.create.test.dialog.select.methods=Generar métodos de prueba para(&M)\:
intention.create.test.dialog.setUp=set&Up/@Before
intention.create.test.dialog.show.inherited=Mostrar métodos heredados(&I)
intention.create.test.dialog.super.class=Superclase\:
intention.create.test.dialog.tearDown=tear&Down/@After
intention.create.test.dialog.testing.library=Biblioteca de pruebas(&L)\:
intention.encapsulate.field.text=Encapsular campo
intention.error.cannot.create.class.message=No se puede crear la clase ''{0}''
intention.error.cannot.create.class.title=Error al crear la clase
intention.error.make.sealed.class.different.modules=Algunos herederos están en módulos diferentes
intention.error.make.sealed.class.different.packages=El módulo no tiene nombre y algunos herederos están en un paquete diferente
intention.error.make.sealed.class.has.anonymous.or.local.inheritors=Algunos de los herederos son anónimos o locales
intention.error.make.sealed.class.inheritors.not.in.java.file=Algunos herederos no están en archivos java
intention.error.make.sealed.class.interface.has.no.inheritors=La interfaz no tiene herederos
intention.error.make.sealed.class.is.used.in.functional.expression=La clase se usa en expresión funcional
intention.extract.if.condition.family=Extraer condición 'if'
intention.extract.if.condition.text=Extraer if ({0})
intention.extract.map.step.family=Extraer a método de mapeo separado
intention.extract.map.step.text=Extraer variable ''{0}'' a operación ''{1}''
intention.extract.method.text=Extraer método
intention.extract.set.from.comparison.chain.family=Extraer Set de cadena de comparación
intention.extract.set.from.comparison.chain.popup.title=Extraer Set de Cadena de Comparación
intention.extract.set.from.comparison.chain.replace.all=Reemplazar todas las ocurrencias
intention.extract.set.from.comparison.chain.replace.only.this=Reemplazar solo esta ocurrencia
intention.family.add.javadoc=Agregar Javadoc
intention.family.copy.abstract.method.implementation=Copiar implementación de método abstract
intention.family.create.a.class.in.package=Crear una clase en el paquete
intention.family.edit.method.contract=Editar contrato de método
intention.family.edit.range=Editar rango
intention.family.expand.static.import=Expandir static import
intention.family.fix.bounded.wildcards=Corregir comodines acotados
intention.family.make.external.annotations.explicit=Hacer explícitas las anotaciones externas
intention.family.make.inferred.annotations.explicit=Hacer explícitas las anotaciones inferidas
intention.family.move.it=Moverlo
intention.family.name.add.main.method=Agregar método 'main'
intention.family.name.box.primitive.in.conditional.branch=Encapsular valor primitivo en rama condicional
intention.family.name.convert.record.to.class=Convertir record a clase
intention.family.name.delete.possible.side.effects=Eliminar posibles efectos secundarios
intention.family.name.delete.private.method=Eliminar método private
intention.family.name.dismiss=Descartar
intention.family.name.extract.possible.side.effects=Extraer posibles efectos secundarios
intention.family.name.ignore.project=No mostrar de nuevo en este proyecto
intention.family.name.make.sealed=Sellar clase
intention.family.name.move.class.to.test.root=Mover clase a raíz de prueba
intention.family.name.rename.to.ignored=Renombrar a ignorado
intention.family.name.set.explicit.variable.type=Establecer tipo de variable explícito
intention.family.name.synchronize.inline.snippet=Sincronizar fragmento inline
intention.family.name.upgrade.jdk=Actualizar JDK
intention.family.put.arguments.on.one.line=Poner argumentos en una línea
intention.family.put.arguments.on.separate.lines=Poner argumentos en líneas separadas
intention.family.put.parameters.on.one.line=Poner parámetros en una línea
intention.family.put.parameters.on.separate.lines=Poner parámetros en líneas separadas
intention.family.put.record.components.on.one.line=Poner componentes de record en una línea
intention.family.put.record.components.on.separate.lines=Poner componentes de record en líneas separadas
intention.family.replace.optional.ispresent.condition.with.functional.style.expression=Reemplazar condición de presencia Optional con expresión de estilo funcional
intention.family.sort.content=Ordenar contenido
intention.family.swap.if.statements=Intercambiar sentencias 'if'
intention.family.unimplement.interface.class=Desimplementar Interfaz/Clase
intention.family.variable.access.from.inner.class=Mover a objeto anónimo
intention.implement.abstract.class.default.text=Implementar Clase Abstracta
intention.implement.abstract.class.family=Implementar clase abstracta o interfaz
intention.implement.abstract.method.command.name=Implementar método
intention.implement.abstract.method.error.no.classes.message=No se encontraron clases donde este método pueda ser implementado
intention.implement.abstract.method.error.no.classes.title=No Se Encontraron Clases
intention.implement.abstract.method.family=Implementar método abstract
intention.implement.abstract.method.searching.for.descendants.progress=Buscando Descendientes…
intention.implement.abstract.method.text=Implementar método ''{0}''
intention.inline.map.family=Inlinear método de mapeo de stream
intention.inline.map.inline.text=Inlinear cuerpo de ''{0}()'' en la siguiente llamada ''{1}()''
intention.inline.map.merge.text=Combinar llamada ''{0}()'' y llamada ''{1}()''
intention.introduce.variable.text=Introducir variable local
intention.invert.if.condition=Invertir condición 'if'
intention.make.final.fixer.if=Hacer ''{0}'' efectivamente final moviendo inicializador a la sentencia ''if''
intention.make.final.fixer.stream=Hacer ''{0}'' efectivamente final usando API de stream
intention.merge.filter.family=Fusionar filtros
intention.merge.filter.text=Fusionar cadena de filtros
intention.move.field.assignment.to.declaration=Mover asignación a la declaración del campo
intention.move.initializer.to.constructor=Mover inicializador al constructor
intention.move.initializer.to.set.up=Mover inicializador al método setUp
intention.name.collapse.into.loop=Contraer en bucle
intention.name.copy.to.final.temp.variable=Copiar ''{0}'' a variable temporal {1, choice, 0\#|1\#efectivamente }final
intention.name.delete.method=Eliminar método ''{0}()''
intention.name.delete.method.only=… y nada más
intention.name.delete.method.title=Eliminar Método ''{0}()''
intention.name.delete.method.with.callees=… junto con otros métodos private usados solo allí
intention.name.extract.method.to.new.interface=Extraer método ''{0}'' a nueva interfaz
intention.name.iterate.over=Iterar sobre {0}
intention.name.make.variable.final=Hacer {1, choice, 0\#''{0}''|1\#variables} final
intention.name.move.class.to.test.root=Mover ''{0}'' a la raíz de pruebas
intention.name.move.into.if.branches=Mover hacia arriba en las ramas de la sentencia 'if'
intention.name.pull.method.up=Subir método ''{0}''
intention.name.pull.method.up.and.make.it.abstract.conditionally=Subir método ''{0}'' a ''{1}''{2, choice, 0\# y hacerlo abstracto|1\#}
intention.name.pull.method.up.make.it.abstract=Subir método ''{0}'' y hacerlo abstracto
intention.name.set.variable.type=Establecer tipo de variable a ''{0}''
intention.name.transform.variables.into.final.one.element.array=Transformar {1, choice, 0\#''{0}''|1\#variables} en array final de un elemento
intention.name.upgrade.jdk.to=Actualizar JDK a {0}+
intention.override.method.text=Sobrescribir método ''{0}''
intention.replace.concatenation.with.formatted.output.family=Reemplazar concatenación con salida formateada
intention.replace.concatenation.with.formatted.output.text=Reemplazar '+' con 'java.text.MessageFormat.format()'
intention.sequenced.collection.can.be.used.display.name=Se puede usar método SequencedCollection
intention.sequenced.collection.can.be.used.fix.name=Reemplazar con llamada a método SequencedCollection
intention.split.declaration.assignment.text=Dividir en declaración y asignación
intention.split.declaration.family=Dividir declaración
intention.split.filter.family=Dividir filtro
intention.split.filter.text=Dividir en cadena de filtros
intention.split.if.family=Dividir 'if'
intention.split.if.text=Dividir en 2 sentencias 'if'
intention.split.switch.branch.with.several.case.values.copy.text=Copiar rama 'switch'
intention.split.switch.branch.with.several.case.values.family=Dividir rama switch con varios valores case en ramas 'switch' individuales
intention.split.switch.branch.with.several.case.values.split.text=Dividir valores de rama 'switch'
intention.surround.resource.with.ARM.block=Envolver con bloque try-with-resources
intention.surround.with.ARM.block.template=try-with-resources
intention.text.add.method.contract.to.0=Agregar contrato de método a ''{0}()''…
intention.text.add.range.to.0=Agregar rango a ''{0}''…
intention.text.annotate.externally=Anotar externamente
intention.text.collapse.repeating.annotations=Contraer anotaciones repetidas
intention.text.create.a.class.in.0=Crear una clase en ''{0}''
intention.text.create.a.class.in.package.preview=Abre un diálogo para crear una clase en el paquete ''{0}''
intention.text.edit.method.contract.of.0=Editar contrato de método de ''{0}()''…
intention.text.edit.range.of.0=Editar rango de ''{0}''…
intention.text.fix.method.0.parameters.with.bounded.wildcards=Corregir parámetros del método ''{0}'' con comodines acotados
intention.text.generate.missing.test.methods=Generar métodos de prueba faltantes
intention.text.implements.list.remove.others=Eliminar otras referencias ''{0}''
intention.text.replace.all.delete.import=Reemplazar todo y eliminar el import
intention.text.replace.implements.with.static.import=Reemplazar implements con static import
intention.text.replace.static.import.with.qualified.access.to.0=Reemplazar static import con acceso calificado a {0}
intention.text.replace.this.occurrence.keep.import=Reemplazar esta ocurrencia y mantener el import
intention.text.unimplement.0=Desimplementar {0}
intention.unroll.loop.family=Desenrollar bucle
intention.unwrap.else.branch=Desenvolver rama 'else'
intention.unwrap.else.branch.changes.semantics=Desenvolver rama 'else' (cambia la semántica)
intention.use.single.member.static.import.text=Usar static import para ''{0}''
intention.wrap.with.unmodifiable=Envolver con colección o mapa inmutable
intention.wrap.with.unmodifiable.list=Envolver con lista inmutable
intention.wrap.with.unmodifiable.map=Envolver con mapa inmutable
intention.wrap.with.unmodifiable.set=Envolver con conjunto inmutable
interface.not.allowed=No se permite la interfaz
interfaces.cannot.be.inlined=Las interfaces no pueden ser inlineadas
introduce.functional.variable.accessibility.conflict=La variable {0} no es efectivamente final y no será accesible dentro de la expresión funcional
introduce.functional.variable.interface.chooser.title=Elegir Interfaz Funcional Aplicable\: {0} -> {1}
introduce.functional.variable.nothing.found.message=No se encontraron interfaces funcionales aplicables
introduce.parameter.advertisement.text=Presione {0} para delegar mediante método sobrecargado o {1} para mostrar más opciones
introduce.parameter.inlay.title.delegate=Delegar
introduce.parameter.inlay.tooltip.delegate=Delegar mediante método sobrecargado
introduce.parameter.object.no.accessor.conflict.message=Se requiere {0, choice, 0\#Getter|1\#Setter} para el campo ''{1}''
introduce.variable.change.semantics.warning=Extraer la expresión seleccionada cambiaría la semántica de toda la expresión.
introduce.variable.change.type.adv=Presione {0} para cambiar el tipo
introduce.variable.reassign.adv=Presione {0} para reasignar variable existente
invalid.extracted.class.name=''{0}'' es un nombre de clase extraída inválido
invert.quickfix.preview=Abre un diálogo para invertir el booleano seleccionado y elegir su nuevo nombre.
java.completion.tag={0, choice, 1\#Etiqueta\:|2\#Etiquetas\:}
java.configurable.logger.identifier.long=El identificador es demasiado largo
java.configurable.logger.not.found=No se encontró el logger dentro del proyecto
java.configurable.logger.unspecified=No especificado
java.implicit.types.lambda.inlay.provider.name=Tipos de parámetros lambda
java.implicit.types.local.inlay.provider.name=Tipos implícitos
java.line.markers=Marcadores de línea Java
java.method.chains.inlay.provider.name=Cadenas de métodos
java.platform.module.system.name=Sistema de Módulos de la Plataforma Java
java.preview.features.accept.notification.link=Aceptar
java.preview.features.alert.title=Alerta de Función Experimental
java.preview.features.legal.notice=Debe aceptar los términos del aviso legal de la especificación beta de Java para habilitar el soporte de "{0}".<br/><br/><b>La implementación de un borrador preliminar de especificación desarrollado bajo el Java Community Process (JCP) está disponible solo para pruebas y evaluación y no es compatible con ninguna especificación del JCP.</b>{1}
java.preview.features.notification.title=Funciones de vista previa de Java
java.preview.features.unsupported=El nivel de lenguaje Java <b>{0} (Vista previa)</b> usado en este proyecto ya no está soportado. El análisis de código para las funciones de vista previa puede funcionar incorrectamente.<br>Se recomienda encarecidamente migrar a una versión más nueva de Java o dejar de usar funciones de vista previa.
java.preview.features.unsupported.title=Funciones de vista previa de Java no soportadas
java.preview.features.warning=Las versiones más nuevas del IDE pueden descontinuar el soporte para las funciones de vista previa de Java. Cuando Java {0} sea lanzado, el soporte para el nivel de lenguaje {1} (Vista previa) puede ser eliminado.
java.preview.level={0} (Vista previa)
java.terms.exception=excepción
java.terms.instance.initializer=inicializador de instancia
java.terms.of.annotation.type={0} del tipo de anotación {1}
java.terms.of.anonymous.class={0} de clase anónima
java.terms.of.class={0} de la clase {1}
java.terms.of.enum={0} del enum {1}
java.terms.of.interface={0} de la interfaz {1}
java.terms.region=región
java.terms.static.initializer=inicializador static
java.terms.type.parameter=parámetro de tipo
java.terms.variable.of.method={0}/{1}
javadoc.apiNote=Nota de API\:
javadoc.author=Autor\:
javadoc.candidates.not.found=<html>No se encontraron candidatos para la llamada al método <b>{0}</b>.</html>
javadoc.constructor.candidates=<html>Los candidatos para nuevo <b>{0}</b>() son\:<br>{1}</html>
javadoc.deprecated=Obsoleto
javadoc.description.copied.from.class=De la clase\:
javadoc.description.copied.from.field=Del campo\:
javadoc.description.copied.from.interface=De la interfaz\:
javadoc.description.inferred.annotation.hint=i
javadoc.documentation.url.checked=Se {0, choice, 1\#verificó la siguiente URL|2\#verificaron las siguientes URLs} de documentación\:
javadoc.edit.api.docs.paths=Editar rutas de documentación API
javadoc.gen.error.module.source.path.is.not.evaluated=IDEA no puede generar Javadoc ya que no se puede evaluar module-source-path
javadoc.gen.error.modules.without.module.info=IDEA no puede generar Javadoc ya que los módulos {0} no contienen archivo module-info.java
javadoc.generate.arguments=Argumentos de línea de comandos\:
javadoc.generate.exited=\n"javadoc" finalizó con código de salida $EXIT_CODE$
javadoc.generate.heap.size=Tamaño &máximo del heap\:
javadoc.generate.include.jdk.library.sources.in.sourcepath.option=Incluir fuentes de JDK y bibliotecas en -sourcepath
javadoc.generate.link.to.jdk.documentation.option=Enlazar a documentación JDK (usar opción -link)
javadoc.generate.locale=&Locale\:
javadoc.generate.no.classes.in.selected.packages.error=El alcance seleccionado no contiene clases Java
javadoc.generate.no.javadoc.tool=No se puede generar JavaDoc - no se encontró la herramienta javadoc en {0} o {1}. Por favor especifique un Java SDK válido en Configuración | Estructura del Proyecto.
javadoc.generate.no.jdk=No se puede generar JavaDoc - no hay Java SDK configurado para el proyecto. Por favor especifique un Java SDK en Configuración | Estructura del Proyecto.
javadoc.generate.ok=Generar
javadoc.generate.open.in.browser=Abrir documentación &generada en el navegador
javadoc.generate.options.hierarchy=Generar árbol de jerarquía
javadoc.generate.options.index=Generar índice
javadoc.generate.options.index.per.letter=Índice separado por letra
javadoc.generate.options.navigator=Generar barra de navegación
javadoc.generate.options.separator=Opciones de JavaDoc
javadoc.generate.output.directory=&Directorio de salida\:
javadoc.generate.output.directory.browse=Explorar directorio de salida
javadoc.generate.scope.row=Nivel de visibilidad\:
javadoc.generate.sources.progress=Buscando fuentes para generar Javadoc
javadoc.generate.tag.list.deprecated=Lista de obsoletos
javadoc.generate.temp.file.does.not.exist=El archivo temporal no existe o no se puede abrir
javadoc.generate.temp.file.error=No se puede crear el archivo temporal
javadoc.generate.title=Generar JavaDoc
javadoc.generate.validation.error=Especifique el directorio de salida.
javadoc.implNote=Nota de<br>implementación\:
javadoc.implSpec=Requisitos de<br>implementación\:
javadoc.method.in.class={0} en la clase {1}
javadoc.method.in.interface={0} en la interfaz {1}
javadoc.method.overrides=Sobrescribe\:
javadoc.method.specified.by=Especificado por\:
javadoc.option.automatically.insert.closing.tag.javadoc=Insertar automáticamente etiqueta de cierre en JavaDoc
javadoc.option.javadoc.title=JavaDoc
javadoc.see.also=Ver también\:
javadoc.settings.title=Javadoc
javadoc.since=Desde\:
javadoc.snippet.error.both.substring.and.regex=@{0}\: se debe especificar regex o substring, pero no ambos
javadoc.snippet.error.duplicate.attribute=@{0}\: atributo duplicado\: ''{1}''
javadoc.snippet.error.malformed.regular.expression=@{0}\: expresión regular mal formada\: {1}
javadoc.snippet.error.malformed.replacement=@{0}\: reemplazo de expresión regular mal formado ''{1}''\: {2}
javadoc.snippet.error.markup.tag.expected=Se esperaba etiqueta o atributo de marcado
javadoc.snippet.error.missing.required.attribute=@{0}\: falta el atributo ''{1}''
javadoc.snippet.error.regex.too.complex=@{0}\: expresión regular demasiado compleja ''{1}''
javadoc.snippet.error.unknown.enum.value=@{0}\: {1} desconocido ''{2}''; solo se soportan {3}
javadoc.snippet.error.unsupported.attribute=@{0}\: atributo no soportado\: ''{1}''
javadoc.snippet.not.found=Snippet no encontrado\: {0}
javadoc.snippet.region.not.found=Región no encontrada\: {0}
javadoc.type.parameters=Parámetros de tipo\:
javadoc.version=Versión\:
jrt.node.short=[JRT]
jvm.logging.configurable.display.name=Logging JVM
jvm.logging.configurable.id=jvm.logging
jvm.logging.configurable.java.group.display.name=Java
label.add.math.max.0.count.to.avoid.possible.semantics.change=Agregar Math.max(0, count) para evitar posible cambio semántico
label.canonical.constructor=Constructor canónico
label.class.filter.editor.add.dialog.filter.pattern=Ingrese el patrón de filtro\:
label.class.pattern.syntax.explanation=Deje el método en blanco para representar constructores\nCualquier * coincidirá con uno o más caracteres en el nombre calificado (incluyendo puntos)
label.compact.constructor=Constructor compacto
label.configurable.logger.generation.variable.name=Nombre de variable\:
label.configurable.logger.type=Logger\:
label.contract=&Contrato\:
label.enter.fully.qualified.class.name=Ingrese el nombre completo de la clase
label.entry.points=Puntos de entrada\:
label.forbid.api.usages=Prohibir uso de API más nueva que
label.forbid.api.usages.project=(según configuración del proyecto)
label.from.inclusive=&Desde (inclusive)\:
label.ignore.complicated.fix=Ignorar cuando no se pueda proporcionar una solución rápida
label.ignored.exceptions=Excepciones ignoradas\:
label.implementation=Implementación\:
label.implements.method.of_class_or_interface.name=implementa método de {0, choice, 0\#interfaz|1\#clase} ''{1}''.
label.implements.method.of_interfaces=implementa métodos de las siguientes clases/interfaces\:
label.jvm.class.name=Nombre de clase JVM
label.jvm.field.name=Nombre de campo JVM
label.jvm.method.name=Nombre de método JVM
label.maximal.reported.method.visibility=Visibilidad máxima del método\:
label.method=Método ''{0}''
label.minimal.reported.method.usage.count=Conteo mínimo de uso del método para reportar parámetro\:
label.mutates=&Muta\:
label.name.prefix=Prefijo del nombre\:
label.name.suffix=Sufijo del nombre\:
label.naming.field=Campo\:
label.naming.local.variable=Variable local\:
label.naming.parameter=Parámetro\:
label.naming.static.field=Campo static\:
label.naming.subclass=Subclase\:
label.naming.test.class=Clase de prueba\:
label.new.template.name=Nuevo nombre de plantilla\:
label.overrides.method.of_class_or_interface.name=sobrescribe método de {0, choice, 0\#interfaz|1\#clase} ''{1}''.
label.show.import.popup.for=Mostrar tooltip de auto-importación para\:
label.to.inclusive=&Hasta (inclusive)\:
label.unused.declaration.reachable.from.tests.option=Cuando los puntos de entrada están en fuentes de prueba, marcar los llamados como\:
lambda.tree.node.presentation=Lambda
leave.in.same.source.root.item=Dejar en la misma raíz de fuentes
library.classes.cannot.be.inlined=Las clases de biblioteca no pueden ser inlined
line.marker.recursive.call=Llamada recursiva
line.marker.type.external.annotations=Anotaciones externas
line.marker.type.inferred.contract.annotations=Anotaciones de contrato inferidas
line.marker.type.inferred.nullability.annotations=Anotaciones de nulabilidad inferidas
link.configurable.logger.generator.display.name=<a href\='link'>Configuración</a>
link.configure.classes.excluded.from.completion=Configurar clases excluidas del autocompletado
list.item.configuration=[configuración] {0}
list.item.suite=[suite] {0}
listbox.import.package=Package
listbox.import.static=Static
listbox.import.with.subpackages=Con Subpackages
live.template.context.consumer.function=Función consumer
live.template.context.declaration=Declaración
live.template.context.else=Posición 'else'
live.template.context.expression=Expression
live.template.context.statement=Statement
loading.additional.annotations=Cargando anotaciones adicionales…
macro.array.variable=arrayVariable()
macro.class.name=Nombre de clase
macro.classpath.entry=Entrada en el classpath al que pertenece el elemento
macro.component.type.of.array=componentTypeOf(Array)
macro.descendant.classes.enum=descendantClassesEnum(String)
macro.expression.type=expressionType(Expression)
macro.file.fully.qualified.package=Package completo del archivo
macro.file.package=Package del archivo
macro.guess.element.type.of.container=guessElementType(Container)
macro.iterable.component.type=iterableComponentType(ArrayOrIterable)
macro.iterable.variable=iterableVariable()
macro.javadoc.output.directory=Directorio de salida JavaDoc
macro.project.classpath=Classpath del proyecto
macro.variable.of.type=variableOfType(Type)
megabytes.unit=MB
methods.to.implement.chooser.title=Seleccionar métodos a implementar
methods.to.override.chooser.title=Seleccionar métodos a sobrescribir
methods.to.override.generate.javadoc=Generar JavaDoc faltante
methods.to.override.implement.chooser.title=Seleccionar métodos a sobrescribir/implementar
module.not.in.requirements=El módulo ''{0}'' no tiene el módulo ''{1}'' en los requerimientos
module.package.not.exported=El módulo ''{0}'' no exporta el package ''{1}'' al módulo ''{2}''
module.package.not.open=El módulo ''{0}'' no abre el package ''{1}'' al módulo ''{2}''
module.type.java.description=Los módulos Java se utilizan para desarrollar aplicaciones de escritorio y web <b>basadas en JVM</b>, incluyendo aplicaciones que usan <b>Java EE</b> y otros frameworks de desarrollo empresarial.
module.type.java.name=Módulo Java
move.class.import.from.default.package.conflict={0} no será accesible desde el package por defecto
move.classes.destination.class.not.found.message=No se encontró la clase de destino
move.classes.invalid.destination.package.name.message=''{0}'' es un nombre de package de destino inválido
move.inner.select.target.package.title=Seleccionar Package Destino
move.member.enum.conflict=El tipo enum no será aplicable en el contexto actual
move.member.final.initializer.conflict=El inicializador de {0} final se dejará atrás.
multiple.usages.of.static.import.found=Se encontraron múltiples usos del Static Import
navigate.to.duplicate.fix=Navegar al duplicado
new.line.when.body.is.presented=Nueva línea cuando hay cuerpo presente
no.jre.description=<sin JRE>
no.methods.overriding.0.are.found=No se encontraron métodos que sobrescriban {0, choice, 0\#|1\#"{1}"|2\#estas clases}
no.patterns=No hay patrones de clase configurados
node.call.hierarchy.unknown.jsp=jsp desconocido
node.hierarchy.java.lang.object=Todas las clases derivan de java.lang.Object
non.code.annotations.explanation.external.and.inferred.available=Anotaciones externas e <i>inferidas</i> disponibles.
non.code.annotations.explanation.external.available=Anotaciones externas disponibles.
non.code.annotations.explanation.full.signature=Firma completa\:
non.code.annotations.explanation.inferred.available=Anotaciones <i>inferidas</i> disponibles.
notification.content.added.annotations=Se {0, choice, 1\#agregó|2\#agregaron} {0} {0, choice, 1\#anotación|2\#anotaciones}
notification.content.change.jdk=Cambiar JDK
notification.content.was.set.up=El JDK ''{0}'' fue configurado para el proyecto
notification.group.arch.checker=Las arquitecturas de JDK y sistema son diferentes
notification.group.jdk.resolve.problems=Error al resolver JDK
notification.group.jshell=Ocurrió un problema con JShell
notification.group.language.level=El nivel de lenguaje Java de vista previa requiere aceptar la licencia
notification.group.legacy.library=La biblioteca legacy depende de la instalación del IDE
notification.group.preview.features=El nivel de lenguaje Java de vista previa puede ser discontinuado
notification.group.redundant.exports=Se pueden eliminar exports/opens redundantes
notification.group.repository=Archivos JAR sincronizados con el repositorio
notification.group.setup.external.annotations=Error al cargar anotaciones externas
notification.group.setup.jdk=JDK configurado
notification.group.source.searcher=Error al buscar fuentes para archivo JAR
notification.group.testintegration=Error al generar pruebas para @TestDataPath
notification.navigation.to.overriding.classes=La navegación a clases que sobrescriben no es posible durante la actualización del índice
notification.navigation.to.overriding.methods=La navegación a métodos que sobrescriben no es posible durante la actualización del índice
notification.text.full.thread.dump.was.successfully.copied.to.clipboard=El volcado completo de threads se copió exitosamente al portapapeles
null.check.surrounder.description=if (expr \!\= null) {…}
nullable.notnull.annotation.used.label=Anotación usada para generación de código\:
nullable.notnull.annotations.panel.title=Anotaciones {0}\:
nullable.notnull.annotations.runtime.instrumentation.tooltip=Agregar aserciones en tiempo de ejecución para métodos y parámetros anotados como notnull
nullable.notnull.configuration.dialog.title=Configuración Nullable/NotNull
nullable.stuff.inspection.navigate.null.argument.usages.fix.family.name=Navegar a usos de argumentos 'null'
nullable.stuff.inspection.navigate.null.argument.usages.fix.family.preview=Muestra una lista de usos donde 'null' se pasa como argumento.
nullable.stuff.inspection.navigate.null.argument.usages.view.name=Usos del argumento ''null'' para el parámetro {0}
offline.inspections.jdk.not.found=No se encontró {0}
offline.inspections.library.urls.were.not.resolved=Las raíces {0} de la biblioteca ''{1}'' del módulo ''{2}'' no fueron resueltas
offline.inspections.library.was.not.resolved=Por favor configure la biblioteca ''{0}'' que se usa en el módulo ''{1}''
offline.inspections.no.source.roots=No se detectaron raíces de fuentes para el módulo ''{0}''
open.settings.dialog.for.module.preview.text=Abrir diálogo de configuración para el módulo ''{0}''
options.java.attribute.descriptor.abstract.class=Clases e Interfaces//Clase abstracta
options.java.attribute.descriptor.abstract.method=Métodos//Método abstract
options.java.attribute.descriptor.annotation.attribute.name=Anotaciones//Nombre del atributo de anotación
options.java.attribute.descriptor.annotation.name=Anotaciones//Nombre de anotación
options.java.attribute.descriptor.anonymous.class=Clases e Interfaces//Clase anónima
options.java.attribute.descriptor.class=Clases e Interfaces//Clase
options.java.attribute.descriptor.constructor.call=Métodos//Llamada al constructor
options.java.attribute.descriptor.constructor.declaration=Métodos//Declaración del constructor
options.java.attribute.descriptor.enum=Clases e Interfaces//Enum
options.java.attribute.descriptor.implicit.anonymous.parameter=Parámetros//Parámetro implícito de clase anónima
options.java.attribute.descriptor.inherited.method=Métodos//Método heredado
options.java.attribute.descriptor.instance.field=Campos de Clase//Campo de instancia
options.java.attribute.descriptor.instance.final.field=Campos de Clase//Campo final de instancia
options.java.attribute.descriptor.interface=Clases e Interfaces//Interface
options.java.attribute.descriptor.javadoc.comment=Comentarios//JavaDoc//Texto
options.java.attribute.descriptor.javadoc.markup=Comentarios//JavaDoc//Markup
options.java.attribute.descriptor.javadoc.tag=Comentarios//JavaDoc//Tag
options.java.attribute.descriptor.javadoc.tag.value=Comentarios//JavaDoc//Valor del tag
options.java.attribute.descriptor.lambda.parameter=Parámetros//Parámetro lambda
options.java.attribute.descriptor.method.call=Métodos//Llamada al método
options.java.attribute.descriptor.method.declaration=Métodos//Declaración del método
options.java.attribute.descriptor.method.imported.call=Métodos//Llamada a método static importado
options.java.attribute.descriptor.package.private=Visibilidad//Package-private
options.java.attribute.descriptor.private=Visibilidad//Private
options.java.attribute.descriptor.protected=Visibilidad//Protected
options.java.attribute.descriptor.public=Visibilidad//Public
options.java.attribute.descriptor.reassigned.local.variable=Variables//Variable local reasignada
options.java.attribute.descriptor.reassigned.parameter=Parámetros//Parámetro reasignado
options.java.attribute.descriptor.static.field=Campos de Clase//Campo static
options.java.attribute.descriptor.static.final.field=Campos de Clase//Constante (campo static final)
options.java.attribute.descriptor.static.final.imported.field=Campos de Clase//Constante (campo static final importado)
options.java.attribute.descriptor.static.imported.field=Campos de Clase//Campo static importado
options.java.attribute.descriptor.static.method=Métodos//Método static
options.java.attribute.descriptor.type.parameter=Parámetros//Parámetro de tipo
options.java.display.name=Java
override.implement.broken.file.template.message=Por favor corrija la plantilla "Cuerpo del Método Sobreescrito/Implementado"
override.implement.broken.file.template.title=Error en Plantilla de Archivo
override.methods.error.no.methods=No se encontraron métodos para sobreescribir
package.chooser.modal.progress.title=Buscando paquetes…
package.classes=Clases del paquete\:
package.dependencies.production.node.text=Clases de Producción
package.dependencies.test.node.text=Clases de Test
package.pattern.provider.hint.label=Use <b>*.txt</b> para coincidir con todos los archivos 'txt' en el proyecto, <b>file\:path_in_project//*</b> para coincidir recursivamente con todos los archivos en un directorio, <b>src\:foo..*</b> para coincidir recursivamente con todas las clases en un paquete.
packaging.jlink.artifact.name=JLink
packaging.jlink.artifact.title=Imagen de tiempo de ejecución (JLink)
packaging.jlink.compression.first.level=Compartición de strings
packaging.jlink.compression.level=Nivel de compresión
packaging.jlink.compression.second.level=Zip
packaging.jlink.compression.zero.level=Sin compresión
packaging.jlink.verbose.tracing=Habilitar trazado detallado
paste.class.command.name=Pegar Clase ''{0}''
please.report.a.bug=Por favor reporte un error
popup.content.tests.were.not.found.in.module=No se encontraron tests en el módulo ''{0}''.\n
popup.content.tests.were.not.found.in.module.search.in.dependencies=Buscar en las dependencias del módulo en su lugar
popup.content.tests.were.not.found.in.module.use.instead=Use {0, choice, 0\#módulo {1} |1\#uno de\n{2}\n}en su lugar
popup.title.choose.framework=Elegir Framework
popup.title.choose.target.class=Elegir Clase Destino
popup.title.choose.test=Elegir Test
popup.title.debug.recent.tests=Depurar Tests Recientes
popup.title.remove.unused.variable=Eliminar Variable No Utilizada
popup.title.select.a.jar.file=Seleccionar archivo JAR
popup.title.select.qualified.name=Seleccionar Nombre Calificado
popup.title.select.target.code.block=Seleccionar Bloque de Código Destino
postfix.template.condition.array.name=array
postfix.template.condition.boolean.name=boolean
postfix.template.condition.non.void.name=no void
postfix.template.condition.not.primitive.type.name=tipo no primitivo
postfix.template.condition.number.name=número
postfix.template.condition.void.name=void
postfix.template.editor.choose.class.title=Elegir Clase
postfix.template.language.level.title=Nivel mínimo de lenguaje\:
postfix.template.provider.name=Java
presentable.text.anonymous.class=Clase anónima
presentable.text.code.display=Código
presentable.text.code.from.context=Código de {0}
presentable.text.invalid.element.name=INVÁLIDO
press.0.to.see.inheritors.of.1=Presione {0} para ver los herederos de {1}
press.0.to.see.non.imported.classes=Presione {0} para ver las clases no importadas
pressing.0.twice.without.a.class.qualifier=Presionar {0} dos veces sin un calificador de clase mostrará todos los métodos static accesibles
progress.creating.class=Creando clase {0}
progress.title.calculate.applicable.types=Calcular tipos aplicables…
progress.title.check.applicability=Verificar aplicabilidad…
progress.title.checking.if.class.exists=Verificar si existe la clase destino ''{0}''
progress.title.collect.method.overriders=Recolectar sobreescrituras de método…
progress.title.detect.overridden.methods=Verificar métodos sobreescritos
progress.title.detecting.jdk=Detectando JDK
progress.title.download.library.descriptor=Descargar Descriptor de Biblioteca
progress.title.find.references.in.implement.extends.lists=Buscar Referencias en Listas Implement/Extends…
progress.title.finding.cause=Buscando causa
progress.title.looking.for.jdk=Buscando JDK…
progress.title.looking.for.libraries=Buscando Bibliotecas
progress.title.optimize.imports=Optimizar Imports…
progress.title.preprocess.usages=Preprocesar Usos
progress.title.restore.references=Restaurando referencias
progress.title.search.for.overriding.methods=Buscar métodos que sobreescriben…
progress.title.searching.for.sub.classes=Buscando Subclases
project.problems.fix.description=Problemas encontrados relacionados con ''{0}''
project.problems.fix.text=Mostrar problemas relacionados
project.problems.hint.text={0} {0, choice, 0\#problema|2\#problemas} relacionados
project.problems.title=Problemas relacionados
project.problems.window.title=Problemas relacionados con {0}
prompt.choose.base.class.of.the.hierarchy=Elegir clase base de la jerarquía para buscar
prompt.create.non.existing.package=El paquete {0} no existe.\n¿Desea crearlo?
prompt.delete.class={0,choice,1\#clase|2\#clases}
prompt.delete.field={0,choice,1\#campo|2\#campos}
prompt.delete.interface={0,choice,1\#interfaz|2\#interfaces}
prompt.delete.method={0,choice,1\#método|2\#métodos}
prompt.delete.package={0,choice,1\#paquete|2\#paquetes}
prompt.delete.type.parameter={0,choice,1\#parámetro de tipo|2\#parámetros de tipo}
prompt.do.you.want.to.action_verb.the.method.from_class=¿Desea {1} el {0,choice,1\#método|2\#métodos} base en su lugar?
psi.error.incorrect.class.template.message=No se puede crear {0} - plantilla {1} incorrecta.
psi.search.overriding.progress=Buscando métodos que sobrescriben…
pull.members.up.fix.name=Subir miembros
pull.up.accessible.conflict={0} no será accesible
pull.up.accessible.conflict.1={0} no será accesible desde {1}
pull.up.concrete.inherit.abstract.method.conflict=La clase concreta {0} heredará un nuevo método abstracto
pull.up.members.usage.view.description.code.references.node=Clase a la que subir miembros "{0}"
pull.up.members.usage.view.description.processed.elements.node=Subir miembros desde la clase {0}
push.down.anonymous.conflict=No se puede empujar implements a clase anónima
push.down.missed.implementation.conflict={0} no abstracto perderá la implementación de {1}
push.down.static.nonstatic.conflict=No se puede empujar {0} static a {1} no static
push.down.super.method.call.changed.conflict=La llamada al método super se resolverá a otro método
push.method.down.command.name=Empujar método hacia abajo…
qualify.static.access.command.name=Calificar acceso static
qualify.static.call.fix.text=Calificar llamada static
qualify.static.constant.access=Calificar acceso a constante static
quickfix.add.variable.family.name=Inicializar variable
quickfix.add.variable.text=Inicializar variable ''{0}''
quickfix.family.avoid.mutation.using.stream.api=Evitar mutación usando Stream API
quickfix.family.change.javadoc.to=Cambiar a…
quickfix.family.find.cause=Encontrar causa
quickfix.family.remove.javadoc.tag=Eliminar tag
quickfix.family.remove.redundant.parameter=Eliminar parámetro redundante
quickfix.family.remove.redundant.parameter.types=Eliminar tipos de parámetros redundantes
quickfix.family.replace.cast.type=Reemplazar tipo de cast
quickfix.family.replace.inefficient.stream.count=Reemplazar Stream.count() ineficiente
quickfix.family.replace.optional.chain.with.if.statements=Reemplazar cadena Optional con sentencias if
quickfix.family.replace.stream.api.chain.with.loop=Reemplazar cadena Stream API con bucle
quickfix.family.replace.with.java.stream.api.pipeline=Reemplazar con pipeline de Java Stream API
quickfix.family.replace.with.magic.constant=Reemplazar con constante mágica
quickfix.family.replace.with.method.reference=Reemplazar con referencia a método
quickfix.family.replace.with.optional.of.nullable.chain=Reemplazar con cadena Optional.ofNullable()
quickfix.family.replace.with.stream.api.equivalent=Reemplazar con equivalente Stream API
quickfix.family.simplify.foreach.lambda=Simplificar lambda forEach
quickfix.family.simplify.stream.call.chain=Simplificar cadena de llamadas stream
quickfix.family.use.flatmap=Usar 'flatMap'
quickfix.family.wrap.with.mutable.collection=Envolver con colección mutable
quickfix.find.cause.description=Intenta resaltar elementos de código que resultaron en esta advertencia y explicar exactamente cómo contribuyen.
quickfix.name.find.jar.on.web=Buscar JAR en la web
quickfix.text.0.may.not.work.before.jdk.11.0.2={0} (puede no funcionar antes de JDK 11.0.2)
quickfix.text.avoid.mutation.using.stream.api.0.operation=Evitar mutación usando operación Stream API ''{0}()''
quickfix.text.remove.javadoc.0=Eliminar tag ''@{0}''
quickfix.text.remove.javadoc.0.1=Eliminar @{0} {1}
quickfix.text.remove.not.null.annotation=Eliminar anotación not-null
quickfix.text.replace.0.stream.with.1.2=Reemplazar {0}.stream() con {1}.{2}()
quickfix.text.replace.collect.0.with.1.2=Reemplazar ''collect({0}())'' con ''{1}''{2}
quickfix.text.replace.filter.0.is.present.with.any.match=Reemplazar ''filter().{0}().isPresent()'' con ''anyMatch()''
quickfix.text.replace.stream.0.with.1.2=Reemplazar ''stream().{0}()'' con ''{1}()''{2}
quickfix.text.replace.url.with.link=Reemplazar URL con enlace
quickfix.text.suffix.may.change.semantics=\ (puede cambiar la semántica)
quickfix.text.wrap.0.with.1=Envolver ''{0}'' con ''{1}''
radio.button.subclass.of.0=Subclase de ''{0}''
radio.button.unused.declaration.unused.option=no usado
radio.button.unused.declaration.used.option=usado
radio.button.with.provider.method=Con método 'provider()'
radio.use.fully.qualified.class.names.in.javadoc=Usar nombres de clase completamente calificados en JavaDoc\:
radio.use.fully.qualified.class.names.in.javadoc.always=Siempre
radio.use.fully.qualified.class.names.in.javadoc.if.not.imported=Si no está importado
radio.use.fully.qualified.class.names.in.javadoc.never=Nunca, usar nombre corto y agregar import
raw.use.of.parameterized.type.ignore.new.objects.option=Ignorar construcción de nuevos objetos
raw.use.of.parameterized.type.ignore.overridden.parameter.option=Ignorar tipos de parámetros de métodos sobrescritos
raw.use.of.parameterized.type.ignore.quickfix.not.available.option=Ignorar cuando la corrección rápida automática no está disponible
raw.use.of.parameterized.type.ignore.type.casts.option=Ignorar type casts
raw.use.of.parameterized.type.ignore.uncompilable.option=Ignorar donde un parámetro de tipo no compilaría
raw.variable.type.can.be.generic.cast.quickfix=Cambiar tipo de cast a {0}
raw.variable.type.can.be.generic.cast.quickfix.family=Parametrizar tipo de cast
raw.variable.type.can.be.generic.family.quickfix=Agregar parámetros genéricos al tipo
raw.variable.type.can.be.generic.quickfix=Cambiar tipo de {0} a {1}
records.cannot.be.inlined=Las clases record no pueden ser inlined
refactoring.method.reference.to.lambda.conflict=La referencia a método se convertirá a lambda
remove.var.keyword.text=Eliminar 'var'
rename.package.class.already.exist.conflict=Ya existe una clase con el nombre calificado ''{0}''
rename.package.command.name=Renombrar paquete
rename.package.ignored.name.warning=Intentando crear un paquete con nombre ignorado, el resultado no será visible
rename.package.invalid.name.error=No es un nombre de paquete válido
rename.super.base.chooser.popup.title={0} {1, choice, 0\#implementa|1\#sobrescribe} método de {2}
rename.super.methods.chooser.popup.title={0} tiene métodos super
replace.implements.with.static.import.field.usages.progress=Buscar usos de campos constantes…
scheduled.thread.pool.executor.with.zero.core.threads.description='ScheduledThreadPoolExecutor' no debería tener cero threads principales
scheduled.thread.pool.executor.with.zero.core.threads.display.name='ScheduledThreadPoolExecutor' con cero threads principales
scope.hierarchy=Jerarquía de {0}
sdk.cannot.create=No se puede crear SDK
sdk.configured=''{0}'' está configurado como JDK del proyecto.
sdk.configured.external.config.title=JDK está configurado ({0})
sdk.java.no.classes=No se pueden encontrar las clases JDK en ''{0}''
section.title.inspection.suspicious.names.ignore.methods=Ignorar métodos\:
separator.annotations.to.copy=Anotaciones a copiar
separator.mark.as.entry.point.if.annotated.by=Marcar como punto de entrada si está anotado por\:
separator.mark.field.as.implicitly.written.if.annotated.by=Marcar campo como implícitamente escrito si está anotado por\:
set.language.level=Establecer nivel de lenguaje
set.language.level.to.0=Establecer nivel de lenguaje a {0}
settings.completion.ml.java.display.name=Java
settings.inlay.java.annotations=Anotaciones
settings.inlay.java.builder.like.methods=Métodos tipo Builder
settings.inlay.java.complex.expressions.binary.functional.array.access.and.other=Expresiones complejas como argumentos
settings.inlay.java.enum.constants=Constantes enum
settings.inlay.java.external.annotations=Anotaciones externas
settings.inlay.java.implicit.types.lambda=Tipos lambda
settings.inlay.java.implicit.types.lambda.description=Mostrar sugerencias integradas para tipos de parámetros lambda
settings.inlay.java.implicit.types.local=Tipos implícitos
settings.inlay.java.implicit.types.local.description=Variables locales declaradas con la palabra clave var cuando el tipo inferido puede no estar claro desde la parte derecha de la asignación, por ejemplo, al usar un método factory.
settings.inlay.java.inferred.annotations=Anotaciones inferidas
settings.inlay.java.inheritors=Herederos
settings.inlay.java.insert.annotation=Insertar anotación
settings.inlay.java.methods.with.same.named.numbered.parameters=Métodos con parámetros numerados del mismo nombre
settings.inlay.java.new.expressions=Expresiones 'new'
settings.inlay.java.non.literals.in.case.of.multiple.parameters.with.the.same.type=No literales en caso de múltiples parámetros del mismo tipo
settings.inlay.java.parameters.with.names.that.are.contained.in.the.method.name=Parámetros con nombres contenidos en el nombre del método
settings.inlay.java.show.hints.for=Mostrar sugerencias para\:
settings.inlay.java.show.parameter.hints.for=Mostrar sugerencias de parámetros para\:
settings.inlay.java.show.parameter.hints.when.expression.type.is.clear.description=Inicializadores de array, switch, condicionales, referencias, instanceof, asignaciones, llamadas, calificados, cast de tipos, expresiones de acceso a objetos de clase.
settings.inlay.java.turn.off.external.annotations=Desactivar anotaciones externas
settings.inlay.java.turn.off.inferred.annotations=Desactivar anotaciones inferidas
settings.inlay.java.usages=Usos
show.import.popup.for.classes=&Clases(&C)
show.import.popup.for.static.methods.and.fields=Métodos y campos &static(&S)
show.siblings.choose.super.class.title=Elegir superclase o interfaz
show.siblings.find.usages.class.title=Superclases/interfaces
show.siblings.find.usages.method.title=Métodos super
side.effects.expression.presentation=expresión ''{0}''
side.effects.pattern.message=<html>\n<body>\nSe encontraron posibles efectos secundarios en {0}<br>\nPuede\:\n<br>\n-\\&nbsp;<b>Eliminar</b> los usos de variables junto con todas las expresiones involucradas, o<br>\n-\\&nbsp;<b>Transformar</b> las expresiones asignadas a variables en declaraciones por sí mismas.<br>\n<div style\="padding-left\: 0.6cm;">\n  Es decir,<br>\n  <table border\="0">\n    <tr>\n      <td><code>{1};</code></td>\n    </tr>\n  </table>\n  se convierte en\: <br>\n  <table border\="0">\n    <tr>\n      <td><code>{2};</code></td>\n    </tr>\n  </table>\n</div>\n</body>\n</html>
simplify.optional.chain.inspection.fix.description.optional.chain.can.be.eliminated=La cadena Optional puede eliminarse
simplify.optional.chain.inspection.fix.description.replace.with.value.of.description=La cadena Optional puede reemplazarse con 'String.valueOf()'
simplify.optional.chain.inspection.fix.description.replace.with.value.of.name=Reemplazar con 'String.valueOf()'
simplify.optional.chain.inspection.fix.name.remove.redundant.optional.chain=Eliminar cadena Optional redundante
simplify.optional.chain.inspection.map.or.else.description=La cadena Optional puede simplificarse
simplify.optional.chain.inspection.optional.rewrapping.description=Reenvolvimiento Optional innecesario
simplify.optional.chain.inspection.optional.rewrapping.name=Desenvolver
simplify.optional.chain.inspection.or.else.non.null.fix.description=La comprobación null puede eliminarse con 'ifPresent'
simplify.optional.chain.inspection.or.else.non.null.fix.name=Reemplazar comprobación null con ifPresent()
simplify.optional.chain.inspection.or.else.return.fix.description=La comprobación null puede eliminarse
simplify.optional.chain.inspection.or.else.return.fix.name=Reemplazar comprobación null con {0}({1})
simplify.optional.chain.inspection.remove.redundant.steps.from.optional.chain=Eliminar pasos redundantes de la cadena optional
simplify.optional.chain.inspection.to.x=Simplificar cadena optional a ''{0}''
simplify.stream.collection.creation.fix.name=Reemplazar con constructor ''{0}''
simplify.stream.inspection.iterate.take.while.fix.message=Puede ser reemplazado con 'iterate()' de tres argumentos
simplify.stream.inspection.iterate.take.while.fix.name=Reemplazar con 'iterate()' de tres argumentos
simplify.stream.inspection.message.can.be.replaced=''{0}'' puede ser reemplazado por ''{1}''
simplify.stream.inspection.message.can.be.replaced.may.change.semantics=''{0}'' puede ser reemplazado por ''{1}'' (puede cambiar la semántica)
simplify.stream.match.negation.fix.name=Reemplazar {0} con {1}(...)
simplify.stream.remove.boolean.identity.fix.message=Puede fusionarse con la llamada 'map()' anterior
simplify.stream.remove.boolean.identity.fix.name=Fusionar con llamada 'map()' anterior
simplify.stream.replace.support.with.collection.fix.message=Puede ser reemplazado con llamada ''{0}.{1}()''
simplify.stream.replace.support.with.collection.fix.name=Reemplazar con llamada ''{0}.{1}()''
simplify.stream.replace.with.element.iteration.fix.message=Puede ser reemplazado con iteración de elementos
simplify.stream.simple.stream.of.fix.name.use.stream.element.explicitly=Usar elemento Stream explícitamente
simplify.stream.simple.stream.of.message=Stream de un solo elemento innecesario
simplify.stream.swap.filter.and.map.fix.message='filter()' y 'map()' pueden intercambiarse
simplify.stream.swap.filter.and.map.fix.name=Intercambiar 'filter()' y 'map()'
slice.filter.parse.error.enum.constant.not.found=Constante enum no encontrada\: {0}
slice.filter.parse.error.expression.must.evaluate.to.constant=La expresión debe evaluarse a una constante\: {0}
slice.filter.parse.error.incorrect.constant.expected.number=Constante incorrecta (se esperaba un número)\: {0}
slice.filter.parse.error.incorrect.constant.type=Tipo de constante incorrecto (requerido\: {0})
slice.filter.parse.error.incorrect.expression=Expresión incorrecta\: {0}
slice.filter.parse.error.not.null.filter.not.applicable.for.primitive.type=El filtro ''\!null'' no es aplicable para el tipo primitivo {0}
slice.filter.parse.error.null.filter.not.applicable.for.primitive.type=El filtro ''null'' no es aplicable para el tipo primitivo {0}
slice.usage.message.assertion.violated=(¡aserción violada\!)
slice.usage.message.in.file.stopped.here=(en el archivo {0} - detenido aquí)
slice.usage.message.location=en {0}
slice.usage.message.tracking.container.contents=(Rastreando contenido del contenedor ''{0}{1}'')
sort.threads.by.name=Ordenar hilos por nombre
sort.threads.by.type=Ordenar hilos por tipo
special.annotations.annotations.list=Anotaciones especiales adicionales\:
special.annotations.annotations.preview=Agrega ''@{0}'' a una lista de anotaciones que serán ignoradas por esta inspección
special.annotations.list.add.annotation.class=Agregar clase de anotación
special.annotations.list.annotation.class=Clase de anotación
special.annotations.list.annotation.pattern=Agregar patrón de anotaciones
special.annotations.list.annotation.pattern.message=Agregar patrón de anotaciones
special.annotations.list.remove.pattern=Eliminar
spi.extension.error.message=La extensión registrada debe implementar {0}
spi.no.provider.error.message=No se encontró el proveedor de servicio "{0}"
status.bar.overridden.methods.highlighted.message={0} {0, choice, 1\#método|2\#métodos} sobrescritos encontrados (presione {1} nuevamente para quitar el resaltado, Escape para quitar todo el resaltado)
stream.to.loop.inspection.message.replace.foreach.call.with.loop=Reemplazar llamada 'forEach()' con bucle
stream.to.loop.inspection.message.replace.stream.api.chain.with.loop=Reemplazar cadena de Stream API con bucle
surround.with.cast=Envolver con Cast
surround.with.dowhile.template=do / while
surround.with.for.template=for
surround.with.ifelse.expression.template=if (expr) {...} else {...}
surround.with.not.instanceof.template=\!(expr instanceof Type)
surround.with.runnable.template=Runnable
surround.with.synchronized.template=synchronized
surround.with.try.catch.finally.template=try / catch / finally
surround.with.try.catch.incorrect.template.message=Plantilla de archivo inválida para el cuerpo catch
surround.with.try.catch.template=try / catch
switch.stmt.template.description=switch (expr) {…}
tab.title.entry.points=Puntos de entrada
tab.title.infer.nullity.preview=Vista previa de inferencia de nulabilidad
tab.title.members.to.report=Miembros a reportar
tab.title.slices.grouped.by.nullness=\ (Agrupado por nulabilidad)
table.cell.constructors=constructores
target.code.block.presentable.text=Bloque contenedor
title.cannot.create.class=No se puede crear la clase
title.code.vision=Code Vision
title.code.vision.inlay.hints=Code Vision
title.import.layout=Diseño de importación
title.javadoc=JavaDoc
title.naming=Nomenclatura
title.naming.final.modifier=Declaración de variable
title.naming.functional.expressions=Cuerpo Lambda
title.naming.variable=Variable
title.package.not.found=Paquete no encontrado
title.packages=Paquetes
title.packages.to.use.import.with=Paquetes para usar import con '*'\:
title.related.problems.inlay.hints=Problemas relacionados
to.import.a.method.statically.press.0=Para importar un método estáticamente, presione {0}
todo.index.not.available=N/D
tooltip.anonymous=Anónimo
tooltip.has.several.functional.implementations=Tiene varias implementaciones funcionales
tooltip.implements.method=Implementa método
tooltip.implements.method.in=Implementa método en
tooltip.incorrect.file.template=Plantilla de archivo ''{0}'' incorrecta
tooltip.is.functionally.implemented.in=Está implementado funcionalmente en
tooltip.is.implemented.by=Está implementado por
tooltip.is.implemented.by.several.subclasses=Está implementado por varias subclases
tooltip.is.implemented.in=Está implementado en
tooltip.is.implemented.in.several.subclasses=Está implementado en varias subclases
tooltip.is.overridden.by.several.subclasses=Está sobrescrito por varias subclases
tooltip.is.overridden.in=Está sobrescrito en
tooltip.is.overridden.in.several.subclasses=Está sobrescrito en varias subclases
tooltip.is.subclassed.by=Es subclase de
tooltip.overrides.method=Sobrescribe método
tooltip.overrides.method.in=Sobrescribe método en
tooltip.reassigned.local.variable=Variable local reasignada
tooltip.reassigned.parameter=Parámetro reasignado
tooltip.recursive.call=Llamada recursiva
tooltip.variable.used=La variable ''{0}'' está en uso
tooltip.via.subclass=vía subclase
type.information.constraints=Restricciones
type.information.local.object=objeto local
type.information.locality=Localidad
type.information.mutability=Mutabilidad
type.information.not.equal.to=No igual a
type.information.nullability=Nulabilidad
type.information.range=Rango
type.information.type=Tipo
type.information.value=Valor
type.migration.cannot.convert.message=No se puede convertir el tipo de expresión <b>{0}</b>{3, choice, 0\#|1\# desde '<'b'>'{1}'<'/b'>'} a <b>{2}</b>
type.migration.cannot.convert.tooltip=No se puede convertir el tipo de expresión de {0} a {1}
type.migration.cannot.convert.vararg.message=No se puede convertir la llamada <b>{0}</b> de vararg a no-vararg
type.migration.cannot.convert.vararg.tooltip=No se puede convertir la llamada de vararg a no-vararg
type.migration.command.name=TypeMigration
type.migration.dialog.message.disjunction.type.not.applicable=Solo un parámetro de bloque catch puede migrarse a un tipo union
type.migration.dialog.message.invalid.type=''{0}'' no es un tipo válido
type.migration.dialog.message.vararg.type.not.applicable=Solo el último parámetro de un método puede migrarse a un tipo vararg
type.migration.dialog.message.void.not.applicable=Solo los tipos de retorno de métodos pueden migrarse a 'void'
type.migration.getter.rename.suggestion.always.migrate.method.names=Siempre migrar nombres de métodos
type.migration.getter.rename.suggestion.never.migrate.method.names=Nunca migrar nombres de métodos
type.migration.getter.rename.suggestion.text=¿Renombrar getter de ''{0}'' a ''{1}'' ya que el tipo de retorno se migró a ''{2}''?
type.migration.multi.root.toolwindow.title=Migrar tipo de {0}
type.migration.processed.elements.header=Raíz para migración de tipo
type.migration.replaced.notification=Reemplazado por {0}
type.migration.single.root.toolwindow.title=Migrar tipo de {0} de ''{1}'' a ''{2}''
type.parameters.cannot.be.inlined=Los parámetros de tipo no pueden ser inlined
unchecked.warning.inspection.message.unchecked.generics.array.creation.for.varargs.parameter=Creación de array genérico sin comprobar para parámetro varargs
unchecked.warning.inspection.reason.expr.has.raw.type.so.result.erased=. Razón\: ''{0}'' tiene tipo raw, por lo que el resultado de {1} se ha borrado
unchecked.warning.inspection.settings.ignore.unchecked.assignment=Ignorar asignación sin comprobar
unchecked.warning.inspection.settings.ignore.unchecked.call.as.member.of.raw.type=Ignorar llamada sin comprobar como miembro de tipo raw
unchecked.warning.inspection.settings.ignore.unchecked.cast=Ignorar cast sin comprobar
unchecked.warning.inspection.settings.ignore.unchecked.generics.array.creation.for.vararg.parameter=Ignorar creación de array genérico sin comprobar para parámetro vararg
unchecked.warning.inspection.settings.ignore.unchecked.overriding=Ignorar sobrescritura sin comprobar
unknown.library=Biblioteca desconocida
unscramble.detect.analyze.threaddump.from.clipboard.item=Detectar y analizar automáticamente los thread dumps copiados al portapapeles fuera de IntelliJ IDEA
unscramble.log.path.label=Archivo de log\: (&L)
unscramble.no.unscrambler.item=<No hay descodificador instalado>
unscramble.normalize.button=Normalizar (&N)
unscramble.stacktrace.caption=Coloque aquí un stack trace o un thread dump completo\:
unscramble.unscrambled.deadlock.tab=<Deadlock>
unscramble.unscrambled.stacktrace.tab=<Stacktrace>
unscramble.unscrambled.threaddump.tab=<Threads>
unscramble.unscrambler.combobox=Descodificador(&S)\:
unscramble.use.unscrambler.checkbox=Descodificar stack trace(&U)
unwrap.anonymous=Desenvolver 'anonymous...'
unwrap.array.initializer=Desenvolver inicializador de array
unwrap.conditional=Desenvolver 'f ? a \: b'
unwrap.lambda=Desenvolver 'lambda...'
unwrap.switch.expression=Desenvolver expresión 'switch'
unwrap.switch.statement=Desenvolver sentencia 'switch'
unwrap.synchronized=Desenvolver 'synchronized...'
update.external.annotations=Actualizar anotaciones externas
usage.target.exception=Excepción
usage.target.package.in.directory={0} (en {1})
usages.telescope={0,choice, 0\#ningún uso|1\#1 uso|2\#{0,number} usos}
use.external.annotations=Usar anotaciones externas (&E)
validator.text.class.not.found=Clase no encontrada
validator.text.no.annotation=Debe ser una anotación
validator.text.not.valid.class.name=No es un nombre de clase válido
validator.text.wrong.superclass=Superclase incorrecta
vm.option.description.category=Categoría\:
vm.option.description.default.value=Valor predeterminado\:
vm.option.description.description=Descripción\:
vm.option.description.diagnostic=Diagnóstico
vm.option.description.experimental=Experimental
vm.option.description.option=Opción\:
vm.option.description.product=Producto
vm.option.description.requires=\ (requiere {0})
vm.option.description.standard=Estándar
vm.option.description.type=Tipo\:
warning.java.file.outside.source.root=El archivo Java está ubicado fuera de la raíz de fuentes del módulo, por lo que no será compilado
where.do.you.want.to.move.directory.prompt={0}\n\n¿Desea mover el directorio a otra raíz de fuentes u otro directorio?
wrap.return.value.anonymous.class.presentation=Anónimo {0}
wrap.return.value.created.class.not.accessible.conflict=La clase creada no será accesible en el lugar de la llamada
wrap.return.value.existing.class.does.not.have.appropriate.constructor.conflict=La clase existente no tiene un constructor apropiado
wrap.return.value.existing.class.does.not.have.getter.conflict=La clase existente no tiene getter para el campo seleccionado
wrapping.annotation.enums=Anotaciones de campos enum
wrapping.annotation.parameters=Parámetros de anotación
wrapping.deconstruction.patterns=Patrones de desestructuración
wrapping.multi.catch.types=Tipos en multi-catch
wrapping.record.components=Componentes de record
wrapping.semicolon.after.call.chain=Mover ';' a nueva línea
wrapping.switch.statement.or.expression=Sentencia/expresión 'switch'
wrapping.text.blocks=Bloques de texto
wrong.package.statement=Declaración de package incorrecta