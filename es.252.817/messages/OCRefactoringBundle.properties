0.was.not.initialized={0} no fue inicializado
button.cancel=Cancelar(&C)
button.extract=Extraer
button.inline=En línea(&I)
button.inline.all.usages.file=Incrustar {0, choice, 0#todos los usos en el archivo|1#}(&A)
button.inline.current.usage=Incrustar uso actual(&U)
button.rename=Renombrar(&R)
button.rename.all=Renombrar todos los usos(&R)
button.rename.code=Renombrar sólo usos de código
button.view.usages=Ver usos(&S)
can.t.extract.type.of.0.definition=No se puede extraer el tipo de definición de {0}
can.t.inline.definition=No se puede alinear la definición {0}
can.t.introduce.parameter.to.a.function.with.default.parameter.values=No se puede introducir un parámetro a una función con valores de parámetro predeterminados
can.t.refactor.the.compound.initializer=No es posible refactorizar el inicializador compuesto
cannot.determine.type.of.the.selected.expression=No se puede determinar el tipo de la expresión seleccionada
cannot.find.the.method.function=No se puede encontrar el método/función
cannot.inline.constructor.expression=No se puede ejecutar en línea la expresión del constructor
cannot.inline.function.reference.in.non.call.expression=No se puede insertar la función en una expresión que no sea una llamada
cannot.inline.function.type=No se puede incluir en línea el tipo de función
cannot.inline.method.reference.in.property.attribute=No se puede insertar la referencia de método en un atributo de propiedad
cannot.inline.method.reference.in.selector.expression=No se puede poner en línea la referencia del método en la expresión '@selector'
cannot.inline.method.reference.in.xml.file=No se puede alinear la referencia del método en un archivo XML
cannot.inline.recursive=No se puede incrustar la llamada {0} recursiva
cannot.inline.the.macro.inside.another.macro.definition=No se puede insertar en línea la macro dentro de otra definición de macro
cannot.inline.usage.in.swift.code=No se puede poner en línea el uso en el código Swift
cannot.inline.usages.inside.the.macro.substitutions=No se puede en línea los usos dentro del sustituto macro
cannot.perform.refactoring.selected.expression.has.void.type=No se puede realizar la refactorización porque la expresión seleccionada tiene un tipo void.
declaration.must.have.one.declarator.to.introduce.the.type=La declaración debe tener un declarador para introducir el tipo
dialog.message.accessed.for.address={0} se accede para obtener la dirección
dialog.message.accessed.for.writing={0} es accedido para escritura
dialog.message.can.t.copy.to.itself=No se puede copiar ''{0}'' a sí mismo
dialog.message.can.t.move.to.itself=No se puede mover ''{0}'' a sí mismo
dialog.message.can.t.refactor.with.variable.arguments=No se puede refactorizar un {0} con argumentos variables
dialog.message.cannot.extract.there.are.multiple.exit.points.in.selected.code.fragment=No se puede extraer un {0}.\nEl fragmento de código seleccionado tiene múltiples puntos de salida. 
dialog.message.cannot.find.method.function=No se puede encontrar el método/función
dialog.message.cannot.inline.blocks=No se pueden alinear los bloques
dialog.message.cannot.inline.methods.with.return.statements.interrupting.execution.flow=No se pueden integrar métodos con sentencias return que interrumpen el flujo de ejecución
dialog.message.cannot.inline.parameters.blocks=No se pueden alinear en línea los parámetros de los bloques
dialog.message.cannot.inline.parameters.lambdas=No se pueden popular los parámetros de las lambdas
dialog.message.cannot.inline.protocol.method=No se puede incluir en línea un método de protocolo
dialog.message.cannot.inline.with.empty.body=Es imposible incrustar {0} con cuerpo vacío
dialog.message.cant.refactor.operators=No se pueden refactorizar funciones de operador C++
dialog.message.containing.class.invalid=La clase contenedora "{0}" es inválida
dialog.message.containing.class.outside.project=La clase contenedora "{0}" está fuera del proyecto
dialog.message.directory.already.exists.at=El directorio ya existe en ''{0}''
dialog.message.do.you.want.to.proceed.refactoring=¿Proceder con la refactorización?
dialog.message.do.you.want.to.refactor.base.s=¿Quieres refactorizar la base {0}?
dialog.message.elements.to=elementos a {0}
dialog.message.file.already.exists=El archivo ya existe
dialog.message.file.already.exists.at=El archivo ya existe en ''{0}''
dialog.message.interface.was.not.implemented=La interfaz {0} no ha sido implementada
dialog.message.lambdas.cant.extract.dependent.types=No se pueden extraer las expresiones con tipos dependientes al parámetro lambda
dialog.message.lambdas.cant.extract.functional.type=No se pueden extraer expresiones de tipo funcional al parámetro lambda
dialog.message.lambdas.cant.extract.initializer.list=No se puede extraer la lista de inicializadores al parámetro lambda
dialog.message.lambdas.not.supported=Las lambdas no son compatibles con el estandar de lenguaje actual
dialog.message.must.have.initializer={0} debe tener un inicializador
dialog.message.name.invalid=El nombre de {0} no es válido
dialog.message.no.inheritors.are.selected=No se seleccionó ningún heredero
dialog.message.no.selector.parts.for={0} No existen partes de selector para {0}
dialog.message.overrides.in.choice.which.out.project={0} sobreescribe {1} en {2}{3, choice, 0# que está fuera del proyecto|1#}.
dialog.message.paramer.default.value.invalid=''{0}'' no es una expresión
dialog.message.parameter.name.invalid=El nombre del parámetro ''{0}'' no es válido
dialog.message.return.type.invalid=El tipo de retorno de {0} no es válido
dialog.message.selected.statements.should.be.inside.function.choice.or.method=Las sentencias seleccionadas deben estar dentro de una función{0, choice, 0# o método|1#}
dialog.message.selector.part.invalid=Parte del selector ''{0}'' no es válido
dialog.message.several.call.sites.with.different.parameter.initializers=Existen varios sitios de llamada con diferentes inicializadores de parámetro
dialog.message.there.are.no.calls.in.project=No hay llamadas a {0} en el proyecto
dialog.message.there.are.no.usages=No hay usos de {0}
dialog.message.variable.must.be.const=La variable "{0}" debe ser una constante
dialog.title.choose.containing.class=Seleccionar clase contenedora
dialog.title.extract.block.parameter=Extraer parámetro de bloque
dialog.title.extract.function=Extraer función
dialog.title.extract.lambda.parameter=Extraer parámetro lambda
dialog.title.extract.method=Extraer método
dialog.title.inline=En línea {0}
element.has.inheritor={0} tiene heredero {1, choice, 0#métodos|1#funciones}
element.inherits.method={0} hereda un método de {1}
element.is.accessed.for.writing={0} es accedido para escritura
element.is.written.in.the.block={0} está escrito en el bloque
escalate.visibility.current.visibility.column=Visibilidad actual
escalate.visibility.member.column=Miembro
escalate.visibility.required.visibility.column=Visibilidad requerida
extract.dialog.button.extract=Extraer
extract.invalid.name.for.class.type.error=El nombre de la clase {0} no es válido
file.0.already.exists.in.the.project=El archivo ''{0}'' ya existe en el proyecto
label.declaration.place=Lugar de declaración:
message.never.used={0} nunca se usa
namespace.qualifier.should.be.resolved.to.the.class=El cualificador de espacio de nombres debe resolverse a la clase
progress.title.inplace.rename.appending.additional.elements=Adición de elementos adicionales
progress.title.inplace.rename.preparing=Preparando el cambio de nombre
property.inplace.introducer.label.semantics=Semántica
push.down.inheritor.column=Herencia
question.inline.usage=Uso {0} en línea{1, choice, 0#|1#} de {2}?
refactoring.change.signature.target.symbols.panel=Destinos:
refactoring.extract.category.title=Extraer Categoría
refactoring.extract.subclass.title=Extraer subclase
refactoring.extract.super.protocol.title=Extraer superprotocolo
refactoring.introduce.block.expression.represent.error=El bloque seleccionado no representa {0}
refactoring.introduce.constant.auto.declaration=Declarar auto
refactoring.introduce.constant.constexpr.declaration=Declarar constexpr(&C)
refactoring.introduce.constant.name=Introducir Constante
refactoring.introduce.constant.static.declaration=Declarar constante estática(&S)
refactoring.introduce.define.name=Introducir Define
refactoring.introduce.expressions.choose.dialog.title=Expresiones
refactoring.introduce.instance.variable.name=Introducir Variable de Instancia
refactoring.introduce.ivar.name=Introducir Ivar
refactoring.introduce.parameter.name=Introducir Parámetro
refactoring.introduce.property.name=Introducir propiedad
refactoring.introduce.put.to.header=Colocar en header
refactoring.introduce.typedef.name=Introducir Typedef
refactoring.introduce.variable.name=Introducir variable
refactoring.introducer.declare.auto=Declarar auto
refactoring.introducer.declare.const=Declarar const(&C)
refactoring.ivar.inplace.introducer.declare.interface=Declarar en la interfaz(&I)
refactoring.ivar.inplace.introducer.generate.property=Generar propiedad(&P)
refactoring.move.cant.find.symbol=No se puede encontrar el símbolo de la clase seleccionada
refactoring.move.caret.position=El cursor tiene que estar dentro de una clase
refactoring.move.escalate.visibility.declare.in.interface=declarar en la interfaz
refactoring.move.file.has.no.members=El archivo "{0}" no tiene miembros a mover
refactoring.move.members.error.class.name.invalid=El nombre de la clase no es válido
refactoring.move.members.error.no.target.class.selected=No se seleccionó una clase objetivo
refactoring.move.members.error.not.in.project.sources={0} no está ubicado dentro de los orígenes del proyecto
refactoring.move.members.error.the.same.source.and.target=La clase fuente y la de destino deben ser diferentes
refactoring.move.members.message.target.does.not.exist=La clase de destino "{0}" todavía no existe.
refactoring.move.members.ok.button.text=Mover
refactoring.move.namespace.has.no.members=El Namespace "{0}" no tiene miembros para mover
refactoring.move.no.members.are.selected.error=No hay miembros seleccionados
refactoring.move.pull.up.ok.button.text=Subir(&U)
refactoring.move.push.down.ok.button.text=Empujar(&U)
refactoring.parameter.introducer.refactor.super.method=Refactorización super {0}(&S)
refactoring.property.introducer.generate.instance.variable=Generar variable de instancia(&I)
refactoring.property.introducer.generate.synthesize=Generar @synthesize
refactoring.property.introducer.make.readonly=Hacer readonly
refactoring.property.introducer.put.to.private.category=Poner en categoría privada
refactoring.rename=Renombrar {0}(&R)
refactoring.rename.0.already.exists.in.1={0} ya existe en {1}
refactoring.rename.0.already.exists.in.the.scope={0} ya existe en el ámbito
refactoring.rename.associated.file=Renombrar archivo asociado
refactoring.rename.class.aliases=Renombrar los alias de clase(&R)
refactoring.rename.command.name=Cambiar nombre
refactoring.symbol.has.no.members.to.move={0} no tiene miembros para mover
rename.multiple.macro.usages.message={0} tiene múltiples usos con diferentes mapeos para "{1}". El renombrado puede romper el código. ¿Desea continuar?
rename.non.code.usages.message={0} {0, choice, 1#uso se|2#usos se} encontraron en comentarios y archivos no de código.\n¿Desea renombrar {0, choice, 1#lo|2#los}? 
rename.reference.command.name=Renombrar referencia
rename.reference.invalid.dialog.button.yes=Continuar editando
rename.reference.invalid.dialog.title=Identificador inválido
selected.expression.cannot.be.a.constant.initializer=La expresión seleccionada no puede ser un inicializador constante
selected.expression.should.be.inside.a.block.statement=La expresión seleccionada debe estar dentro de una sentencia de bloque
selected.expression.should.be.inside.a.function.or.method=La expresión seleccionada debe estar dentro de una función o método
selected.expression.should.be.inside.an.instance.method=La expresión seleccionada debe estar dentro de un método de instancia
selected.expression.should.be.inside.an.instance.method1=La expresión seleccionada debe estar dentro de un metodo de instancia
several.definitions.of.0=Existen varias definiciones de {0}
text.parameter.initializer.not.available.in=El inicializador del parámetro no está disponible en {0}: {1}.
the.address.of.is.taken=La dirección de {0} está ocupada
the.type.is.empty=El tipo está vacío
there.are.several.definitions.of=Existen varias definiciones de {0}
there.are.usages.in.other.blocks=Hay usos en otros bloques
top.level.namespace.placeholder=Espacio de nombres de nivel superior
trying.to.rename.0.to.existing.file.name.1=Intentando renombre {0} a nombre de archivo existente {1}