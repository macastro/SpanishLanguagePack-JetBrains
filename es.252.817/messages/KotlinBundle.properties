0.1.be.lifted.out.of.2=''{0}'' puede extraerse de ''{1}''
0.1.could.be.private={0} ''{1}'' podría ser private
0.1.is.never.used={0} ''{1}'' nunca se usa
0.already.exists={0} ya existe
0.always.returns.non.null.type=''{0}'' siempre retorna tipo no nulo
0.call.could.be.simplified.to.1=La llamada {0} podría simplificarse a {1}
0.call.should.be.replaced.with.array.literal=La llamada ''{0}'' debería reemplazarse con literal de array [...]
0.from.1={0} de {1}
0.has.detected.1.code.fragments.in.2.that.can.be.replaced.with.3={0} ha detectado {1} {1,choice,1\#fragmento|2\#fragmentos} de código en {2} que pueden reemplazarse con {3}. ¿Desea revisar y reemplazar{1,choice,1\#lo|2\#los}?
0.has.empty.body=''{0}'' tiene cuerpo vacío
0.in.1.will.require.class.instance=''{0}'' en {1} requerirá instancia de clase
0.interface.1=Interfaz {0} ''{1}''
0.is.always.non.null.type=''{0}'' es siempre tipo no nulo
0.is.expected.to.be.used.since.kotlin.1.3=Se espera que ''{0}'' se use desde Kotlin 1.3
0.is.missing.documentation={0} carece de documentación
0.is.overridden.by.declaration.s.in.a.subclass={0} está sobrescrito por declaración(es) en una subclase
0.may.break.code={0} (puede romper el código)
0.on.a.readonly.1.creates.a.new.1.under.the.hood=''{0}'' en un {1} de solo lectura crea un nuevo {1} internamente
0.references.type.parameters.of.the.containing.class={0} referencia parámetros de tipo de la clase contenedora
0.should.return.unit={0} debería retornar Unit
0.try.1.with.2.fails.and.3.verifications={0} [Intentar {1} con {2} fallos y {3} verificaciones]
0.will.become.invisible.after.extraction={0} se volverá invisible después de la extracción
0.will.no.longer.be.accessible.after.extraction={0} ya no será accesible después de la extracción
a.constructor.call.is.not.yet.supported=Aún no se admite una llamada al constructor
a.field.without.an.initializer.is.not.yet.supported=Aún no se admite un campo sin inicializador
accessing.non.final.property.0.in.constructor=Accediendo a propiedad no final {0} en el constructor
action.CacheResetOnProcessCanceledToggleAction.text=Reiniciar caché en ProcessCanceledException
action.CheckComponentsUsageSearchAction.text=Verificar búsqueda de uso de funciones de componentes
action.ConfigureKotlinInProject.text=Configurar Kotlin en proyecto
action.ConvertJavaToKotlin.text=Convertir archivo Java a archivo Kotlin
action.CopyAsDiagnosticTest.text=Copiar archivo actual como prueba de diagnóstico
action.CopyKotlinProjectInformation.text=Copiar resumen del proyecto Kotlin al portapapeles
action.DecompileKotlinToJava.text=Decompilar Kotlin a Java
action.DumbModeTremble.text=Modo silencioso de vibración
action.ExtractFunction.text=Extraer función(_F)…
action.ExtractFunctionToScope.text=Extraer función al scope(_S)…
action.FindImplicitNothingAction.text=Buscar llamadas implícitas a Nothing
action.GotoSuperClass.MainMenu.text=Superclase(_U)
action.GotoSuperClass.text=Ir a superclase(_U)
action.GotoSuperInterface.MainMenu.text=Interfaz super(_U)
action.GotoSuperInterface.text=Ir a interfaz super(_U)
action.GotoSuperProperty.MainMenu.text=Propiedad super(_U)
action.GotoSuperProperty.description=Navegar a la declaración de una propiedad que la propiedad actual sobrescribe o implementa
action.GotoSuperProperty.text=Ir a propiedad super(_U)
action.HighlightingBenchmarkAction.text=Benchmark de resaltado
action.InspectBreakpointApplicability.text=Inspeccionar aplicabilidad de breakpoint
action.IntroduceProperty.text=Introducir propiedad(_P)…
action.IntroduceTypeAlias.text=Introducir alias de tipo(_A)…
action.IntroduceTypeParameter.text=Introducir parámetro de tipo(_Y)…
action.Kotlin.ClearScratch.description=Limpiar scratch Kotlin
action.Kotlin.ClearScratch.text=Limpiar scratch Kotlin
action.Kotlin.Gradle.ShowDslLogs.text=Mostrar logs DSL Kotlin Gradle
action.Kotlin.NewFile.description=Crea una nueva clase o archivo Kotlin
action.Kotlin.NewFile.text=Clase/Archivo Kotlin
action.Kotlin.NewScript.description=Crea un nuevo script o worksheet Kotlin
action.Kotlin.NewScript.text=Script Kotlin
action.Kotlin.RunScratch.description=Ejecutar scratch Kotlin
action.Kotlin.RunScratch.text=Ejecutar scratch Kotlin
action.Kotlin.StopScratch.description=Detener ejecución de scratch
action.Kotlin.StopScratch.text=Detener ejecución de scratch
action.Kotlin.XDebugger.CoroutinesDump.text=Obtener dump de corrutinas
action.Kotlin.XDebugger.ToggleKotlinVariableView.text=Mostrar solo variables Kotlin
action.KotlinCodeMigration.text=Ejecutar migraciones de código
action.KotlinCodeMigrationToggle.text=Habilitar detección de migraciones
action.KotlinConfigurePlugin.text=Configurar plugin Kotlin
action.KotlinConsoleREPL.text=Kotlin REPL (Experimental)
action.KotlinFormattingSettingsStatusAction.text=Información de configuración del formateador
action.KotlinGenerateDataMethod.text=Función de parámetros
action.KotlinGenerateEqualsAndHashCode.text=equals() y hashCode()
action.KotlinGenerateMavenCompileExecutionAction.text=Ejecución de compile Kotlin
action.KotlinGenerateMavenPluginAction.text=Plugin Kotlin
action.KotlinGenerateMavenTestCompileExecutionAction.text=Ejecución de test-compile Kotlin
action.KotlinGenerateSecondaryConstructor.text=Constructor secundario
action.KotlinGenerateSetUpMethod.text=Función SetUp
action.KotlinGenerateTearDownMethod.text=Función TearDown
action.KotlinGenerateTestMethod.text=Función de prueba
action.KotlinGenerateToString.text=toString()
action.KotlinShellExecute.description=Ejecutar código Kotlin en consola
action.KotlinShellExecute.text=Ejecutar código Kotlin
action.KotlinThrowException.text=Eliminar error del plugin Kotlin
action.LibraryToSourceDependencySupportToggleAction.text=Alternar soporte de dependencia de biblioteca a fuente
action.LocalCompletionBenchmarkAction.text=Escenario local
action.PrintOutNotPropertyMatches.text=Buscar candidatos que no son propiedades
action.ShowKotlinBytecode.text=Mostrar bytecode Kotlin
action.StoredExceptionsThrowToggleAction.text=Lanzar PCE en caché
action.TestMoveRefactiringAction.text=Probar refactorización de movimiento en proyecto abierto
action.TopLevelCompletionBenchmarkAction.text=Escenario de nivel superior
action.add.import.chooser.title=Import
action.generate.equals.choose.equals=Elegir propiedades a incluir en 'equals()'
action.generate.equals.choose.hashcode=Elegir propiedades a incluir en 'hashCode()'
action.generate.functions.already.defined=Las funciones {0} ya están definidas para la clase {1}. ¿Desea eliminarlas y continuar?
action.generate.secondary.constructor.choose.properties=Elegir propiedades a inicializar por el constructor
action.generate.secondary.constructor.error.already.exists=El constructor ya existe
action.generate.super.type=Especificar tipo super explícitamente
action.generate.test.support.choose.framework=Elegir framework
action.generate.test.support.choose.test.name=Elegir nombre de prueba\:
action.generate.test.support.edit.template=Editar plantilla
action.generate.test.support.error.cant.convert.java.template=No se pudo convertir la plantilla Java a Kotlin
action.generate.test.support.error.cant.generate.method=No se puede generar el método\: {0}
action.generate.test.support.error.no.template.found=No se encontró plantilla para {0}\: {1}
action.generate.tostring.choose.implementation=Elegir implementación\:
action.generate.tostring.choose.implementation.mnemonic=i
action.generate.tostring.generate.super.call=Generar llamada a super.toString()
action.generate.tostring.generate.super.call.mnemonic=s
action.generate.tostring.name=Generar 'toString()'
action.generate.tostring.template.multiple=Múltiples plantillas con concatenación
action.generate.tostring.template.multiple.with.super=Múltiples plantillas con concatenación y llamada super
action.generate.tostring.template.single=Plantilla única
action.generate.tostring.template.single.with.super=Plantilla única con llamada super
action.hints.settings.text=Configuración de sugerencias…
action.j2k.correction.errors.multiple=''{0}'' y otros {1} archivos Java contienen errores de sintaxis, el resultado de la conversión puede ser incorrecto
action.j2k.correction.errors.single=''{0}'' contiene errores de sintaxis, el resultado de la conversión puede ser incorrecto
action.j2k.correction.investigate=Investigar errores
action.j2k.correction.proceed=Continuar con la conversión
action.j2k.correction.required=Parte del código en el resto de su proyecto puede requerir correcciones después de realizar esta conversión. ¿Desea encontrar y corregir ese código también?
action.j2k.error.cant.find.document=no se pudo encontrar el documento para ''{0}''
action.j2k.error.cant.save.result=Error al guardar el resultado de la conversión\: {0}
action.j2k.error.nothing.to.convert=Nada para convertir\:<br>No se encontraron archivos Java editables
action.j2k.error.read.only=el archivo ''{0}'' es de solo lectura
action.j2k.name=Convertir Java a Kotlin
action.j2k.task.name=Convertir archivos de Java a Kotlin
action.move.method=Mover método…
action.new.file.dialog.annotation.title=Anotación
action.new.file.dialog.class.title=Clase
action.new.file.dialog.data.class.title=Data class
action.new.file.dialog.enum.title=Enum class
action.new.file.dialog.file.title=Archivo
action.new.file.dialog.interface.title=Interface
action.new.file.dialog.object.title=Object
action.new.file.dialog.sealed.class.title=Sealed class
action.new.file.dialog.sealed.interface.title=Sealed interface
action.new.file.dialog.title=Nueva Clase/Archivo Kotlin
action.new.file.error.empty.name=El nombre no puede estar vacío
action.new.file.error.empty.name.part=El nombre no puede tener partes vacías
action.new.script.dialog.title=Nuevo archivo Kotlin
action.new.script.name=Script Kotlin
action.text.append=Anexar
action.text.cancel=Cancelar
action.text.install=Instalar
action.text.overwrite=Sobrescribir
action.usage.update.command=Actualización de uso
add.0.constructor.to.1=Agregar constructor {0} a ''{1}''
add.0.library=Agregar biblioteca ''{0}''
add.0.to.argument=Agregar ''{0} \='' al argumento
add.an.opt.in.requirement.marker.compiler.argument=Agregar un argumento de compilador de marcador de requisito opt-in
add.braces=Agregar llaves
add.braces.to.0.statement=Agregar llaves a la sentencia ''{0}''
add.braces.to.all.branches=Agregar llaves a todas las ramas
add.braces.to.if.all.statements=Agregar llaves a todas las sentencias 'if'
add.braces.to.when.all.entries=Agregar llaves a todas las entradas 'when'
add.braces.to.when.entry=Agregar llaves a la entrada 'when'
add.call.or.unwrap.type.fix.text=Agregar ''.{0}()'' al resultado de la función (¡rompe los puntos de uso\!)
add.call.or.unwrap.type.fix.text1=Desenvolver tipo de retorno ''{0}'' (¡rompe los puntos de uso\!)
add.constructor.keyword=Agregar palabra clave 'constructor'
add.constructor.parameters.from.0.1=Agregar parámetros de constructor desde {0}{1}
add.constructor.parameters.from.superclass=Agregar parámetros de constructor desde la superclase
add.documentation.fix.text=Agregar documentación
add.empty.argument.list=Agregar lista de argumentos vacía
add.empty.brackets.after.primary.constructor=Agregar paréntesis vacíos después del constructor primario
add.explicit.parameter.to.outer.lambda.fix.text=Agregar nombre de parámetro explícito al lambda exterior
add.explicit.type.arguments=Agregar argumentos de tipo explícitos
add.external.keyword=Agregar palabra clave external
add.full.qualifier=Agregar calificador completo
add.fun.modifier.to.0=Agregar modificador ''fun'' a ''{0}''
add.import.for.0=Agregar import para ''{0}''
add.import.for.member=Agregar import para miembro
add.indices.to.for.loop=Agregar índices al bucle 'for'
add.initializer=Agregar inicializador
add.interpolation.prefix=Agregar prefijo de interpolación
add.jvminline.annotation=Agregar anotación '@JvmInline'
add.jvmoverloads.annotation=Agregar anotación '@JvmOverloads'
add.jvmoverloads.annotation.to.0=Agregar anotación ''@JvmOverloads'' a {0}
add.jvmstatic.annotation=Agregar anotación '@JvmStatic'
add.kotlin.coroutines=Agregar biblioteca de corrutinas Kotlin
add.kotlin.coroutines.description=Agregar biblioteca de corrutinas Kotlin
add.labeled.return.to.last.expression.in.a.lambda=Agregar return etiquetado a la última expresión en un lambda
add.method=Agregar método
add.method.0.to.1=Agregar método ''{0}'' a ''{1}''
add.missing.class.keyword=Agregar palabra clave 'class' faltante
add.missing.component=Agregar componente de desestructuración faltante
add.modifier=Agregar modificador
add.name.to.argument=Agregar nombre al argumento
add.names.in.comment.to.call.arguments=Agregar nombres en comentario a los argumentos de llamada
add.names.to.call.arguments=Agregar nombres a los argumentos de llamada
add.names.to.this.argument.and.following.arguments=Agregar nombres a este argumento y todos los siguientes
add.operator.modifier=Agregar modificador 'operator'
add.remaining.branches=Agregar ramas restantes
add.replacewith.argument.to.specify.replacement.pattern=Agregar argumento 'replaceWith' para especificar el patrón de reemplazo
add.return.at.0=Agregar ''return@{0}''
add.return.expression=Agregar expresión 'return'
add.source.retention=Agregar retención SOURCE
add.throws.annotation=Agregar anotación '@Throws'
add.underscores=Agregar guiones bajos
add.use.site.target=Agregar target de sitio de uso
add.val.to.parameter.0=Agregar ''val'' al parámetro ''{0}''
add.val.var.to.parameter.0=Agregar ''val'' o ''var'' al parámetro ''{0}''
add.val.var.to.primary.constructor.parameter=Agregar 'val' o 'var' a un parámetro del constructor primario
add.variance.fix.family.name=Agregar varianza
add.variance.fix.text=Agregar varianza ''{0}''
advanced.setting.kotlin.mpp.experimental=Habilitar características IDE experimentales de Multiplatform
advanced.setting.kotlin.mpp.experimental.description=Requiere reinicio del IDE
all.expected.and.actual.classes.must.be.sealed.classes=Todas las clases expected y actual deben ser clases sealed.\n
all.inheritors.must.be.nested.objects.of.the.class.itself.and.may.not.inherit.from.other.classes.or.interfaces=Todos los herederos deben ser objetos anidados de la propia clase y no pueden heredar de otras clases o interfaces.\n
ambiguous.coroutinecontext.due.to.coroutinescope.receiver.of.suspend.function=coroutineContext ambiguo debido al receptor CoroutineScope de función suspend
ambiguous.non.local.break.or.continue=''{0}'' no local ambiguo (''{1}'' vs ''{2}''). Use etiquetas aclaratorias o añada el contrato ''callsInPlace''.
ambiguous.non.local.break.or.continue.display.name='break' o 'continue' no local ambiguo
analyzed.0.classes.no.difference.found=Analizadas {0} clases. No se encontraron diferencias.
analyzing.functions=Analizando funciones…
analyzing.members=Analizando miembros…
and.delete.initializer=\ y eliminar inicializador
apply.also.to.internal.members=Aplicar también a miembros internal
apply.also.to.private.members=Aplicar también a miembros private
apply.in.the.project.0=Aplicar en el proyecto\: {0}
apply.only.to.public.or.protected.members=Aplicar solo a miembros public o protected
applying.0=Aplicando ''{0}''
array.property.in.data.class.it.s.recommended.to.override.equals.hashcode=Propiedad de tipo 'Array' en una clase 'data'\: se recomienda sobreescribir 'equals()' y 'hashCode()'
assert.should.be.replaced.with.operator=assert debería reemplazarse con operador
assign.backing.field.fix.text=Asignar campo de respaldo
base.property.0=propiedad base {0}
block.body=cuerpo de bloque
boolean.literal.argument.without.parameter.name=Argumento literal booleano sin nombre de parámetro
boolean.property.in.external.interface.should.be.nullable=La propiedad booleana en interfaz external debería ser nullable
breadcrumbs.tooltip.indexing=Indexando…
button.add.package=Añadir Package
button.rename.base=Renombrar Base
button.rename.current=Renombrar Actual
button.text.move.nested.class.0.to.another.class=Mover clase anidada {0} a otra clase(&M)
button.text.move.nested.class.0.to.upper.level=Mover clase anidada {0} al nivel superior(&N)
call.chain.length.to.transform=Longitud de la cadena de llamadas a transformar\:
call.chain.on.collection.could.be.converted.into.sequence.to.improve.performance=La cadena de llamadas en una colección podría convertirse a 'Sequence' para mejorar el rendimiento
call.chain.on.collection.type.may.be.simplified=La cadena de llamadas en un tipo de colección puede simplificarse
call.is.replaceable.with.another.scope.function=La llamada puede reemplazarse con otra función de ámbito
call.of.inline.function.with.nullable.extension.receiver.can.cause.npe.in.kotlin.1.2=La llamada a 'inline fun' con receptor nullable puede causar 'NPE' hasta Kotlin 1.2
call.of.java.mutator.0.on.immutable.kotlin.collection.1=Llamada al mutador Java ''{0}'' en colección Kotlin inmutable ''{1}''
call.on.collection.type.may.be.reduced=La llamada en tipo de colección puede reducirse
call.on.not.null.type.may.be.reduced=La llamada en tipo no-null puede reducirse
call.replaceable.with.binary.operator=La llamada puede reemplazarse con un operador binario
call.with.arguments.will.be.skipped.0=Se omitirá la llamada con argumentos\: {0}
callable.reference.fix.family.name=Añadir ''{0}'' explícito
callable.reference.transformation.is.not.supported.0=La transformación de referencia invocable no está soportada\: {0}
calling.non.final.function.0.in.constructor=Llamando a función no final {0} en constructor
calls.with.explicit.extension.receiver.won.t.be.processed.0=No se procesarán las llamadas con receptor de extensión explícito\: {0}
can.be.converted.to.to=La iniciación explícita de 'Pair' puede reemplazarse con una llamada infija 'to()'
can.be.joined.with.assignment=Se puede unir con asignación
can.convert.argument.to.set=El argumento puede convertirse a 'Set' para mejorar el rendimiento
can.t.finish.while.indexing.is.in.progress=No se puede finalizar mientras la indexación está en progreso
can.t.modify.0=No se puede modificar {0}
can.t.replace.foreign.reference.with.call.expression.0=No se puede reemplazar referencia externa con expresión de llamada\: {0}
can.t.replace.non.kotlin.reference.with.call.expression.0=No se puede reemplazar referencia no-Kotlin con expresión de llamada\: {0}
cannot.extract.super.call=No se puede extraer super-call
cannot.get.or.create.results.file=No se puede obtener o crear archivo de resultados
cannot.get.project.root.directory=No se puede obtener el directorio raíz del proyecto
cannot.infer.type.for.this.declaration=No se puede inferir el tipo para esta declaración
cannot.inline.property.with.accessor.s.and.backing.field=No se puede hacer inline de una propiedad con accessor(es) y campo de respaldo
cannot.introduce.parameter.of.0.type=No se puede introducir un parámetro de tipo ''{0}''
cannot.refactor.expression.has.unit.type=No se puede introducir una expresión de tipo unit
cannot.refactor.no.container=No se puede refactorizar en este lugar
cannot.refactor.no.expression=No se puede realizar la refactorización sin una expresión
cannot.refactor.no.type=No se puede realizar la refactorización sin un tipo
cannot.refactor.not.expression=No se puede encontrar una expresión para introducir
cannot.refactor.package.expression=No se puede introducir una referencia de package
cannot.refactor.syntax.errors=No se puede refactorizar debido a código erróneo
cannot.refactor.synthesized.function=No se puede refactorizar una función sintetizada
cascade.if.should.be.replaced.with.when=El 'if' en cascada debería reemplazarse con 'when'
cast.explicitly.fix.text=Convertir explícitamente
category.class=Kotlin/Basado en clases
category.comments=Kotlin/Comentarios, KDoc y Metadatos
category.declaration=Kotlin/Declaraciones
category.expressions=Kotlin/Expresiones
category.interesting=Kotlin/Interesante
category.operators=Kotlin/Operadores
change.all.usages.of.0.in.this.file.to.1=Cambiar todos los usos de ''{0}'' en este archivo a ''{1}''
change.all.usages.of.0.in.this.file.to.a.kotlin.class=Cambiar todos los usos de ''{0}'' en este archivo a una clase Kotlin
change.existent.retention.to.source=Cambiar retención existente a SOURCE
change.main.function.return.type.to.unit.fix.text=Añadir tipo de retorno Unit explícito
change.main.function.return.type.to.unit.fix.text2=Cambiar tipo de retorno a Unit
change.signature.conflict.text.kotlin.default.parameter.in.non.kotlin.files=El parámetro por defecto puede no estar soportado en otros lenguajes
change.signature.conflict.text.kotlin.default.value.in.non.kotlin.files=El valor por defecto de la llamada Kotlin puede generar código incorrecto en otros lenguajes
change.to.0=Cambiar a ''{0}''
change.to.constructor.invocation=Cambiar a invocación de constructor
change.to.correct.long.suffix.l=Cambiar al sufijo long correcto 'L'
change.to.correct.primitive.type=Cambiar al tipo primitivo correcto
change.to.kotlin.class=Cambiar a clase Kotlin
change.to.val=Cambiar a 'val'
change.to.var=Cambiar a 'var'
change.type.of.0.to.1=Cambiar tipo de {0} a ''{1}''
change.type.to.0=Cambiar tipo a ''{0}''
change.type.to.mutable.fix.text=Cambiar tipo a mutable
change.visibility=Cambiar visibilidad
change.visibility.modifier=Cambiar modificador de visibilidad
change.visibility.popup=Cambiar Visibilidad
checkbox.collapse.to.expression.body=Contraer a cuerpo de expresión
checkbox.text.declare.with.var=Declarar con var(&V)
checkbox.text.delete.empty.source.files=Eliminar archivos fuente vacíos(&D)
checkbox.text.extension.property=Propiedad de extensión(&X)\:
checkbox.text.introduce.default.value=Introducir valor por defecto(&D)
checkbox.text.open.moved.files.in.editor=Abrir miembro movido en el editor
checkbox.text.replace.all.occurrences.0=Reemplazar todas las ocurrencias ({0})(&R)
checkbox.text.search.references=Buscar referencias(&R)
checkbox.text.specify.type.explicitly=Especificar tipo explícitamente(&T)
checkbox.text.update.package.directive=Actualizar directiva de paquete (archivos Kotlin)
checking.data.class.0.of.1=Verificando clase de datos {0} de {1}…
checking.data.classes=Verificando clases de datos
choose.actual.members.title=Elegir miembros actuales
choose.an.appropriate.kotlin.class=Elegir una clase Kotlin apropiada
choose.class.container=Elegir contenedor de clase
choose.target.class.or.interface=Elegir clase o interfaz destino
class=Clase
class.0.already.contains.1=La clase ''{0}'' ya contiene {1}
class.name.prompt=Nombre de clase(&N)\:
class.should.be.external.interface=La clase debería ser una interfaz external
clipboard.content.copied.from.java.file.do.you.want.to.convert.it.to.kotlin.code=Contenido del portapapeles copiado de archivo Java. ¿Desea convertirlo a código Kotlin?
code.insight.workspace.settings.title=Kotlin
codestyle.layout.import.aliases.separately=Importar alias por separado
codestyle.name.kotlin=Kotlin
column.name.default.parameter=Parámetro predeterminado\:
column.name.receiver=Receptor\:
column.name.val.var=Val/Var
command.generate.test.support.generate.test.function=Generar función de prueba
command.move.declarations=Mover declaraciones
comment=Comentario
companion.object.already.contains.0=El objeto companion ya contiene {0}
compiling.project=Compilando proyecto…
condition.is.always.0=La condición siempre es ''{0}''
configuration.kotlin.code.style.group.name=Estilo de código oficial de Kotlin disponible
configuration.maven.group.name=Importación de proyecto Kotlin Maven
configuration.message.enter.fully.qualified.method.name=Ingrese un nombre de método completamente calificado\:
configuration.migration.group.name=Kotlin\: Migraciones a una versión más reciente disponibles
configuration.name.method=Método
configuration.status.text.installing=Instalando…
configuration.title.add.exclusion=Agregar exclusión
configuration.title.edit.exclusion=Editar exclusión
const.might.be.used.instead.of.jvmfield='const' podría usarse en lugar de '@JvmField'
const.property=Propiedad const
constructor=Constructor
constructor.has.non.null.self.reference.parameter=El constructor tiene un parámetro de autorreferencia no nulo
constructor.parameter.is.never.used.as.a.property=El parámetro del constructor nunca se usa como propiedad
context.default=Predeterminado
context.property.getter.or.setter=Propiedad con Getter/Setter explícito
convert.0.to.1=Convertir ''{0}'' a ''{1}''
convert.anonymous.function.to.lambda.expression=Convertir función anónima a expresión lambda
convert.argument.to.set.fix.text=Convertir argumento a 'Set'
convert.body.to.expression=Convertir cuerpo a expresión
convert.boolean.const.to.elvis=Convertir Boolean? \=\= const a elvis
convert.call.chain.into.sequence.fix.text=Convertir cadena de llamadas a 'Sequence'
convert.class.0.to.kotlin=Convertir clase ''{0}'' a Kotlin
convert.collection.constructor.to.function=Convertir constructor de Collection a función
convert.concatenation.to.build.string=Convertir concatenación a llamada 'buildString'
convert.concatenation.to.raw.string=Convertir concatenación a cadena raw
convert.concatenation.to.template=Convertir concatenación a plantilla
convert.concatenation.to.template.before.text=La concatenación de 'String' puede convertirse a plantilla
convert.expression.to.0=Convertir expresión a ''{0}''
convert.expression.to.0.by.inserting.1=Convertir expresión a ''{0}'' insertando ''.{1}''
convert.extension.function.type.to.regular.function.type=Convertir tipo de función de extensión a tipo de función regular
convert.extension.property.initializer.to.getter=Convertir inicializador de propiedad de extensión a getter
convert.from.class.to.kclass=Convertir 'KClass' a 'Class'
convert.function.to.property=Convertir función a propiedad
convert.function.type.parameter.to.receiver=Convertir parámetro de tipo función a receptor
convert.function.type.receiver.to.parameter=Convertir receptor de tipo función a parámetro
convert.lambda.expression.to.anonymous.function=Convertir expresión lambda a función anónima
convert.lambda.to.reference=Convertir lambda a referencia
convert.lambda.to.reference.before.text=Lambda puede convertirse a una referencia
convert.left.hand.side.to.0=Convertir lado izquierdo a ''{0}''
convert.member.to.extension=Convertir miembro a extensión
convert.na.n.equality.quick.fix.text=Reemplazar con 'isNaN()'
convert.object.literal.to.class=Convertir literal de objeto a clase
convert.object.literal.to.lambda=Convertir literal de objeto a lambda
convert.pair.constructor.to.to.fix.text=Reemplazar con infijo 'to'
convert.parameter.to.receiver=Convertir parámetro a receptor
convert.property.getter.to.initializer=Convertir getter de propiedad a inicializador
convert.property.initializer.to.getter=Convertir inicializador de propiedad a getter
convert.property.to.function=Convertir propiedad a función
convert.put.to.assignment=Convertir put a asignación
convert.receiver.to.parameter=Convertir receptor a parámetro
convert.reference.to.lambda=Convertir referencia a lambda
convert.reference.to.lambda.before.text=La referencia puede convertirse a lambda
convert.right.hand.side.to.0=Convertir lado derecho a ''{0}''
convert.scope.function.fix.family.name=Convertir a ''{0}''
convert.sealed.subclass.to.object.fix.family.name=Convertir subclase sealed a objeto
convert.string.template.to.build.string=Convertir a llamada 'buildString'
convert.string.to.character.literal=Convertir cadena a literal de carácter
convert.supertype.to.0=Convertir supertipo a ''{0}''
convert.template.to.concatenated.string=Convertir plantilla a cadena concatenada
convert.to.0=Convertir a {0}
convert.to.0.as.1=Convertir a ''{0} as {1}''
convert.to.0.unsafecast.1=Convertir a ''{0}.unsafeCast<{1}>()''
convert.to.a.range.check=Convertir a verificación de rango
convert.to.anonymous.function=Convertir a función anónima
convert.to.anonymous.object=Convertir a objeto anónimo
convert.to.array.parameter=Convertir a parámetro de array
convert.to.assignment.expression=Convierte la declaración de asignación a una expresión
convert.to.block.body=Convertir a cuerpo de bloque
convert.to.comparisons=Convertir a comparaciones
convert.to.concatenated.string.statement.analyzing.entry.type=Analizando tipo de entrada…
convert.to.data.object=Convertir a 'data object'
convert.to.enum.class=Convertir a clase enum
convert.to.expression.body.fix.text=Convertir a cuerpo de expresión
convert.to.indexed.function.call=Convertir a llamada de función indexada
convert.to.lambda=Convertir a lambda
convert.to.lambda.expression=Convertir a expresión lambda
convert.to.lateinit.var=Convertir a var lateinit
convert.to.lazy.property=Convertir a propiedad lazy
convert.to.multi.dollar.string=Convertir a string multi-dollar
convert.to.notnull.delegate=Convertir a delegado notNull
convert.to.nullable.type=Convertir a tipo nullable
convert.to.nullable.type.fix.text=Convertir a tipo nullable
convert.to.nullable.var=Convertir a var nullable
convert.to.object.declaration=Convertir a declaración de objeto
convert.to.ordinary.property=Convertir a propiedad ordinaria
convert.to.ordinary.string.literal=Convertir a literal de string ordinario
convert.to.primary.constructor=Convertir a constructor primario
convert.to.primary.constructor.before.text=El constructor secundario debe convertirse a primario
convert.to.raw.string.literal=Convertir a literal de string raw
convert.to.sealed.class=Convertir a sealed class
convert.to.secondary.constructor=Convertir a constructor secundario
convert.to.trim.indent=Convertir a llamada 'trimIndent()'
convert.to.trim.margin=Convertir a llamada 'trimMargin()'
convert.to.unicode.escape=Convertir a escape unicode
convert.to.unsafe.cast=Convertir a cast inseguro
convert.to.unsafecast.call=Convertir a llamada unsafeCast()
convert.to.vararg.parameter=Convertir a parámetro vararg
convert.too.long.character.literal.to.string=Convertir literal de carácter demasiado largo a string
convert.try.finally.to.use=Reemplazar 'try-finally' con 'use()'
convert.try.finally.to.use.before.text=try-finally puede reemplazarse con 'use()'
copy.concatenation.text.to.clipboard=Copiar texto de concatenación al portapapeles
copy.method.of.data.class.is.called.without.named.arguments=Los nombres de los parámetros deben especificarse explícitamente para la llamada al método 'copy()'
copy.paste.reference.notification=Se {0, choice, 1\#ha añadido|2\#han añadido} {0} {0, choice, 1\#import|2\#imports}<p><span><a href\=''show''>Revisar imports añadidos...</a></span>
copy.paste.resolve.pasted.references=Resolver referencias pegadas
copy.paste.restore.pasted.references=Restaurar referencias pegadas
copy.paste.restore.pasted.references.capitalized=Restaurar Referencias Pegadas
copy.paste.select.imports.to.remove.dialog=Seleccionar imports a eliminar
copy.paste.select.imports.to.remove.text=<html>El fragmento de código que ha pegado utiliza elementos que no son accesibles en el nuevo contexto. Se han añadido los imports necesarios.<br/>Seleccione cuáles de los imports añadidos desea eliminar del archivo.</html>
could.be.replaced.with.size=Podría reemplazarse con 'size'
could.be.replaced.with.unboxed.first=Podría reemplazarse con 'first' sin boxing
could.be.replaced.with.unboxed.last=Podría reemplazarse con 'last' sin boxing
create.0=Crear {0}
create.0.1=Crear {0} ''{1}''
create.0.in.1=Crear {0} en {1}
create.actual=Crear actual
create.actual.0.for.module.1.2=Crear actual {0} para el módulo {1} ({2})
create.actual.in.0=Crear actual en ''{0}''
create.expected.0.in.common.module.1=Crear expected {0} en el módulo común {1}
create.kotlin.file=Crear archivo Kotlin
create.kotlin.subclass=Crear subclase Kotlin
create.label=Crear etiqueta
create.label.0=Crear etiqueta {0}@
create.package.0=Crear paquete ''{0}''
create.parameter.0=Crear parámetro ''{0}''
create.property.0.as.constructor.parameter=Crear propiedad ''{0}'' como parámetro del constructor
create.subclass=Crear subclase
create.test=Crear test
dangerous.array.comparison=Comparación peligrosa de arrays
declaration.has.type.inferred.from.a.platform.call.which.can.lead.to.unchecked.nullability.issues=La declaración tiene un tipo inferido de una llamada de plataforma, lo que puede llevar a problemas de nullability no verificados. Especifique el tipo explícitamente como nullable o non-nullable.
declarations.are.used.outside.of.selected.code.fragment=Las siguientes declaraciones se utilizan fuera del fragmento de código seleccionado\:
declarations.will.move.out.of.scope=Las siguientes declaraciones no estarán disponibles fuera del cuerpo de la función extraída\:
deferred.result.is.never.used=El resultado 'Deferred' no se utiliza
delegating.to.var.property.does.not.take.its.changes.into.account=La delegación a una propiedad 'var' no tiene en cuenta sus cambios
delete.0=eliminar {0}
delete.equals.and.hash.code.fix.text=Eliminar equals()/hashCode()
delete.fix.family.name=Eliminar flecha
delete.redundant.extension.property=Eliminar propiedad de extensión redundante
delete.with.usage.search=eliminar (con búsqueda de uso)
demorgan.law=Ley de DeMorgan
deprecated.annotation.without.replacewith.argument=Anotación '@Deprecated' sin argumento 'replaceWith'
description.a.reference.to.extracted.type.parameter=una referencia al parámetro de tipo extraído
destination.not.found.for.package.0=No se encontró destino para el paquete ''{0}''
diagnostic.name.should.be.replaced.by.the.new.one=El nombre del diagnóstico debe reemplazarse por el nuevo
dialog.message.incorrect.target.path.directory.not.specified=Ruta de destino incorrecta. No se ha especificado el directorio.
dialog.message.none.elements.were.selected=No se seleccionaron elementos
dialog.progress.collect.members.to.generate=Recopilando miembros…
dialog.title.build.super.types.hierarchy=Construir jerarquía de supertipos para {0}
dialog.title.resolving.inheritable.status=Resolviendo estado heredable…
difference.found.for.data.class.0.found.1.2=Se encontró diferencia para la data class {0}. Se encontraron {1} uso(s) pero se esperaban {2}
do.you.want.to.delete.expected.declaration.together.with.all.related.actual.ones=¿Desea eliminar la declaración expected junto con todas las declaraciones actual relacionadas?
do.you.want.to.delete.this.parameter.in.expected.declaration.and.all.related.actual.ones=¿Desea eliminar este parámetro en la declaración expected y todas las declaraciones actual relacionadas?
do.you.want.to.make.new.extension.an.expected.declaration=¿Desea hacer que la nueva extensión sea una declaración expected?
doesn.t.match.regex.0=no coincide con la regex ''{0}''
don.t.show.this.dialog.next.time=&No mostrar este diálogo la próxima vez
double.negation.fix.text=Eliminar negaciones redundantes
editor.checkbox.title.auto.add.val.keyword.to.data.value.class.constructor.parameters=Añadir automáticamente la palabra clave 'val' a los parámetros del constructor de clases data/value
editor.checkbox.title.convert.pasted.java.code.to.kotlin=Convertir código Java pegado a Kotlin
editor.checkbox.title.don.t.show.java.to.kotlin.conversion.dialog.on.paste=No mostrar el diálogo de conversión de Java a Kotlin al pegar
editor.title.kotlin=Kotlin
enter.package.fqname=Introducir FqName del paquete
enum.entry=Entrada de enum
equality.check.0.be.used.instead.of.elvis.for.nullable.boolean.check=Se debe usar la comprobación de igualdad {0} en lugar de elvis para la comprobación de booleano nullable
equality.check.with.nan.should.be.replaced.with.isnan=La comprobación de igualdad con NaN debe reemplazarse por 'isNaN()'
equals.between.objects.of.inconvertible.types='equals()' entre objetos de tipos no convertibles
equals.hashcode.in.object.declaration='equals()'/'hashCode()' en declaración de objeto
equals.should.take.any.as.its.argument='equals' debe tomar 'Any?' como su argumento
equals.text=Generar 'equals()'
error.cant.refactor.vararg.functions=No se puede refactorizar la función con argumentos variables
error.context.getter.or.setter=Este contexto es solo para propiedades con getter/setter explícito. (establecer tipo de archivo como Kotlin)
error.expected.an.expression=Se esperaba una expresión
error.expected.catch.or.finally=Se esperaba 'catch' o 'finally'
error.hint.cannot.modify.0.declaration.from.1.file=No se puede modificar la declaración ''{0}'' del archivo ''{1}''
error.hint.library.declarations.cannot.be.changed=Las declaraciones de biblioteca no se pueden modificar
error.hint.text.cannot.inline.0.from.a.decompiled.file=No se puede hacer inline ''{0}'' desde un archivo decompilado
error.param.can.t.be.null.at.index.0.in.1=El parámetro no puede ser null en el índice {0} en {1}.
error.text.can.t.change.signature.of.method=No se puede cambiar la firma del método {0}
error.text.can.t.copy.class.to.the.containing.file=No se puede copiar la clase al archivo contenedor
error.text.can.t.generate.0.1=No se puede generar {0}\: {1}
error.text.can.t.introduce.constant.for.this.expression=No se puede introducir constante para esta expresión
error.text.can.t.introduce.constant.for.this.expression.because.not.constant=No se puede introducir constante para una expresión no constante
error.text.can.t.introduce.lambda.parameter.for.this.expression=No se puede introducir parámetro lambda para esta expresión
error.text.can.t.introduce.property.for.this.expression=No se puede introducir propiedad para esta expresión
error.text.different.name.expected=Se esperaba un nombre diferente
error.text.expression.has.no.type=La expresión no tiene tipo
error.text.extraction.from.expect.class.is.not.yet.supported=La extracción desde una clase expect aún no está soportada
error.text.extraction.from.non.jvm.class.is.not.yet.supported=La extracción desde una clase no JVM aún no está soportada
error.text.inline.function.is.not.supported.for.functions.with.multiple.return.statements=La función inline no está soportada para funciones con múltiples sentencias return.
error.text.inline.function.is.not.supported.for.functions.with.return.statements.not.at.the.end.of.the.body=La función inline no está soportada para funciones con sentencias return que no están al final del cuerpo.
error.text.interface.cannot.be.extracted.from.an.annotation.class=No se puede extraer una interfaz desde una clase de anotación
error.text.introduce.parameter.is.not.available.for.default.value="Introducir parámetro" no está disponible para valor por defecto
error.text.introduce.parameter.is.not.available.inside.of.annotation.entries="Introducir parámetro" no está disponible dentro de entradas de anotación
error.text.invalid.name=Nombre inválido
error.text.invalid.parameter.name=Nombre de parámetro inválido
error.text.invalid.parameter.type=Tipo de parámetro inválido
error.text.invalid.receiver.type=Tipo de receptor inválido
error.text.invalid.return.type=Tipo de retorno inválido
error.text.no.type.to.refactor=No hay tipo para refactorizar
error.text.refactoring.is.not.applicable.in.the.current.context=La refactorización no es aplicable en el contexto actual
error.text.superclass.cannot.be.extracted.from.an.annotation.class=No se puede extraer una superclase desde una clase de anotación
error.text.type.reference.is.expected=Se esperaba una referencia de tipo
error.types.in.generated.function=No se puede generar función con tipo de retorno erróneo
error.wrong.caret.position.function.or.constructor.name=El cursor debe estar posicionado en el nombre de la función o constructor a refactorizar.
evaluate.compile.time.expression=Evaluar expresión en tiempo de compilación
excluded.methods=Métodos excluidos\:
existing.backing.field.is.not.assigned.by.the.setter=El campo de respaldo existente no está asignado por el setter
expand.boolean.expression.to.if.else=Expandir expresión booleana a 'if else'
experimental.coroutines.usages.are.obsolete.since.1.3=Los usos experimentales de corrutinas están obsoletos desde 1.3
explicit.0.call=Llamada explícita a ''{0}''
explicit.this.expression.fix.family.name=Eliminar ''{0}'' redundante
explicitly.given.type.is.redundant.here=El tipo dado explícitamente es redundante aquí
expression=Expresión
external.interface.contains.non.nullable.property.name=La interfaz external contiene propiedad booleana no nullable
external.interface.contains.val.property.name=La interfaz external contiene propiedad val
extract.function=Extraer Función
extract.new.parameter.name.receiver=<receptor>
failed.to.create.a.wrapper.for.inlining.to.kotlin=Error al crear un wrapper para inline a Kotlin
family.name.update.usages.on.declarations.cut.paste=Actualizar usos al cortar/pegar declaraciones
file.entity=Archivo
file.lines=Líneas de archivo
files.to.visit=Archivos a visitar
find.declaration.constructor.usages.checkbox=Usos de &constructor
find.declaration.derived.classes.checkbox=Clases &derivadas
find.declaration.derived.interfaces.checkbox=&Interfaces derivadas
find.declaration.functions.usages.checkbox=Usos de &funciones
find.declaration.implementing.methods.checkbox=Funciones de &implementación
find.declaration.implementing.properties.checkbox=Propiedades de &implementación
find.declaration.include.overloaded.methods.checkbox=Incluir funciones y extensiones sobre&cargadas
find.declaration.overriding.methods.checkbox=Funciones de sob&reescritura
find.declaration.overriding.properties.checkbox=Propiedades de sob&reescritura
find.declaration.properties.usages.checkbox=Usos de &propiedades
find.declaration.property.readers.checkbox=Lectores
find.declaration.property.writers.checkbox=Escritores
find.usages.checkbox.name.expected.classes=Clases expect
find.usages.checkbox.name.expected.functions=Funciones expect
find.usages.checkbox.name.expected.properties=Propiedades expect
find.usages.checkbox.text.fast.data.class.component.search=Búsqueda rápida de componentes de data class
find.usages.class=clase
find.usages.class.name.anonymous=Anónimo
find.usages.companion.object=objeto companion
find.usages.constructor=constructor
find.usages.facade.class=clase facade
find.usages.for.property={0} para propiedad
find.usages.function=función
find.usages.getter=getter
find.usages.import.alias=alias de importación
find.usages.interface=interfaz
find.usages.label=etiqueta
find.usages.lambda=lambda
find.usages.object=objeto
find.usages.parameter=parámetro
find.usages.prepare.dialog.progress=Preparar Diálogo
find.usages.progress.text.declaration.superMethods=Resolviendo super métodos…
find.usages.property=propiedad
find.usages.property.accessor=acceso de propiedad
find.usages.setter=setter
find.usages.text.find.usages.for.data.class.components.and.destruction.declarations=<p>Buscar usos para componentes de data class y declaraciones de desestructuración<br/>puede ser <a href\="{0}">deshabilitado una vez</a> o <a href\="{1}">deshabilitado para un proyecto</a>.</p>
find.usages.tool.tip.text.disable.search.for.data.class.components.and.destruction.declarations.project.wide.setting=Deshabilitar búsqueda de componentes de data class y declaraciones de desestructuración. (Configuración a nivel de proyecto)
find.usages.type.alias=alias de tipo
find.usages.type.callable.reference=Referencia invocable
find.usages.type.class.object=Clase/objeto anidado
find.usages.type.companion.object=Objeto companion
find.usages.type.constructor.delegation.reference=Referencia de delegación de constructor
find.usages.type.delegate=Delegado
find.usages.type.extension.receiver.type=Tipo de receptor de extensión
find.usages.type.function.call=Llamada a función
find.usages.type.function.return.type=Tipos de retorno de función
find.usages.type.implicit.get='get' implícito
find.usages.type.implicit.invoke='invoke' implícito
find.usages.type.implicit.iteration=Iteración implícita
find.usages.type.implicit.set='set' implícito
find.usages.type.is=Tipo objetivo de operación 'is'
find.usages.type.named.argument=Argumento nombrado
find.usages.type.nonLocal.property.type=Tipo de propiedad de clase/objeto
find.usages.type.packageDirective=Directiva de paquete
find.usages.type.packageMemberAccess=Acceso a miembro de paquete
find.usages.type.parameter=parámetro de tipo
find.usages.type.property.delegation=Delegación de propiedad
find.usages.type.receiver=Receptor
find.usages.type.super.type.qualifier=Calificador de supertipo
find.usages.type.superType=Supertipo
find.usages.type.type.alias=Alias de tipo
find.usages.type.type.constraint=Restricción de tipo
find.usages.type.value.parameter.type=Tipo de parámetro
find.usages.variable=variable
fix.add.annotation.family=Agregar anotación
fix.add.annotation.target=Agregar objetivo de anotación
fix.add.annotation.text.constructor=Agregar anotación ''@{0}'' al constructor
fix.add.annotation.text.containing.class=Agregar anotación ''@{0}'' a la clase contenedora ''{1}''
fix.add.annotation.text.containing.file=Agregar anotación ''@{0}'' al archivo contenedor ''{1}''
fix.add.annotation.text.declaration=Agregar anotación ''@{0}'' a ''{1}''
fix.add.annotation.text.self=Agregar anotación ''@{0}''
fix.add.annotation.with.arguments.text.copy=Copiar anotación ''@{0}'' de ''{1}'' a ''{2}''
fix.add.argument.name.family=Agregar nombre al argumento
fix.add.argument.name.step.choose.parameter.title=Elegir nombre de parámetro
fix.add.argument.name.text=Agregar nombre al argumento\: ''{0}''
fix.add.argument.name.text.generic=Agregar nombre al argumento…
fix.add.array.of.type.family=Agregar wrapper 'arrayOf'
fix.add.array.of.type.text=Agregar wrapper {0}
fix.add.constructor.parameter=Agregar parámetro de constructor ''{0}''
fix.add.default.constructor=Agregar constructor por defecto a la clase 'expect'
fix.add.else.branch.when=Agregar rama else
fix.add.eq.eq.true=Agregar '\=\= true'
fix.add.exception.to.throws=Agregar ''{0}''
fix.add.explicit.import=Agregar import explícito
fix.add.function.body=Agregar cuerpo de función
fix.add.function.parameters.add.parameter.constructor=Agregar {0,number,ordinal} {1,choice,1\#parámetro|2\#parámetros} al constructor ''{2}''
fix.add.function.parameters.add.parameter.function=Agregar {0,number,ordinal} {1,choice,1\#parámetro|2\#parámetros} a la función ''{2}''
fix.add.function.parameters.add.parameter.generic.constructor=Agregar {0,choice,1\#parámetro|2\#parámetros} al constructor ''{1}''
fix.add.function.parameters.add.parameter.generic.function=Agregar {0,choice,1\#parámetro|2\#parámetros} a la función ''{1}''
fix.add.function.parameters.change.signature.constructor=Cambiar la firma del constructor ''{0}''
fix.add.function.parameters.change.signature.function=Cambiar la firma de la función ''{0}''
fix.add.generic.upperbound.family=Agregar límite superior genérico
fix.add.generic.upperbound.text=Agregar ''{0}'' como límite superior para {1}
fix.add.is.to.when=Agregar ''is'' antes de ''{0}''
fix.add.loop.label.text=Agregar ''{0}'' a {1}
fix.add.loop.label.text.generic=Agregar etiqueta al bucle
fix.add.member.supertype.add.to=Agregar ''{0}'' a ''{1}''
fix.add.member.supertype.choose.type=Elegir tipo
fix.add.member.supertype.family=Agregar {0} al supertipo
fix.add.member.supertype.progress=Agregar {0} al tipo
fix.add.member.supertype.text=Agregar {0} al supertipo…
fix.add.modifier.family=Agregar modificador
fix.add.modifier.inline.function.family=Agregar 'inline' a la función
fix.add.modifier.inline.function.text=Agregar ''inline'' a la función ''{0}''
fix.add.modifier.inline.parameter.family=Agregar ''{0}'' al parámetro
fix.add.modifier.inline.parameter.text=Agregar ''{0}'' al parámetro ''{1}''
fix.add.modifier.text=Hacer {0} ''{1}''
fix.add.modifier.text.generic=Agregar modificador ''{0}''
fix.add.new.line.after.annotations=Agregar nueva línea después de las anotaciones
fix.add.remaining.branches=Agregar ramas restantes
fix.add.remaining.branches.with.star.import=Agregar ramas restantes con import *
fix.add.return.before.expression=Agregar 'return' antes de la expresión
fix.add.return.before.lambda.expression=Agregar 'run' antes de la expresión lambda
fix.add.return.last.expression=Agregar 'return' a la última expresión
fix.add.semicolon.lambda.expression=Terminar la llamada anterior con punto y coma
fix.add.spread.operator.after.sam=Agregar operador spread antes de pasar un array como 'vararg'
fix.add.star.projection.family=Agregar proyecciones star
fix.add.star.projection.text=Agregar ''{0}''
fix.add.suspend.modifier.function=Hacer {0} suspend
fix.add.suspend.modifier.function.generic=Hacer suspend la función contenedora
fix.add.suspend.modifier.receiver=Hacer tipo {0} suspend
fix.add.suspend.modifier.receiver.generic=Hacer suspend el tipo receptor
fix.add.tostring.call.family=Agregar llamada 'toString()'
fix.add.tostring.call.text=Agregar llamada 'toString()'
fix.add.tostring.call.text.safe=Agregar llamada segura '?.toString()'
fix.add.type.annotation.family=Agregar anotación de tipo
fix.add.type.annotation.text=Agregar tipo ''{0}'' al parámetro ''{1}''
fix.assign.to.property=Asignar a propiedad
fix.cast.expression.family=Convertir expresión
fix.cast.expression.text=Convertir expresión ''{0}'' a ''{1}''
fix.change.accessor.family=Cambiar tipo de accessor
fix.change.accessor.getter=Cambiar tipo de getter a {0}
fix.change.accessor.setter.parameter=Cambiar tipo de parámetro del setter a {0}
fix.change.jvm.name=Cambiar nombre JVM
fix.change.mutability.change.to.val=Cambiar ''{0}'' a val
fix.change.object.to.class=Cambiar 'object' a 'class'
fix.change.package.family=Cambiar el paquete del archivo para que coincida con el directorio
fix.change.package.text=Cambiar el paquete del archivo a {0}
fix.change.progress.analyzing.class.hierarchy=Analizando jerarquía de clases…
fix.change.progress.looking.inheritors=Buscando herederos de la clase {0}…
fix.change.return.type.command.function=Cambiar tipo del parámetro ''{0}'' de la función ''{1}'' a ''{2}''
fix.change.return.type.command.primary.constructor=Cambiar tipo del parámetro ''{0}'' del constructor primario de la clase ''{1}'' a ''{2}''
fix.change.return.type.family=Cambiar tipo
fix.change.return.type.lambda=Cambiar tipo de retorno de expresión lambda a {0}
fix.change.return.type.presentation.accessed=accedido {0}
fix.change.return.type.presentation.base=base {0}
fix.change.return.type.presentation.called=llamado {0}
fix.change.return.type.presentation.called.function=función llamada
fix.change.return.type.presentation.enclosing=contenedor {0}
fix.change.return.type.presentation.enclosing.function=función contenedora
fix.change.return.type.presentation.function=función {0}
fix.change.return.type.presentation.property=propiedad {0}
fix.change.return.type.remove.explicit.return.type=Eliminar tipo de retorno especificado explícitamente
fix.change.return.type.remove.explicit.return.type.of=Eliminar tipo de retorno especificado explícitamente de {0}
fix.change.return.type.return.type.text=Cambiar tipo de retorno a ''{0}''
fix.change.return.type.return.type.text.of=Cambiar tipo de retorno de {0} a ''{1}''
fix.change.return.type.text.function=Cambiar tipo del parámetro ''{0}'' de la función ''{1}'' a ''{2}''
fix.change.return.type.text.primary.constructor=Cambiar tipo del parámetro ''{0}'' del constructor primario de la clase ''{1}'' a ''{2}''
fix.change.return.type.type.text=Cambiar tipo a ''{0}''
fix.change.return.type.type.text.of=Cambiar tipo de {0} a ''{1}''
fix.change.signature.error=<error>
fix.change.signature.family=Cambiar firma de función/constructor
fix.change.signature.function.family=Cambiar firma de función
fix.change.signature.function.popup.title=Elegir firma
fix.change.signature.function.text=Cambiar firma de función a ''{0}''
fix.change.signature.function.text.generic=Cambiar firma de función…
fix.change.signature.lambda=Cambiar la firma de la expresión lambda
fix.change.signature.lambda.command=Cambiar la firma de la expresión Lambda
fix.change.signature.prepare=Preparar…
fix.change.signature.remove.parameter=Eliminar parámetro ''{0}''
fix.change.signature.remove.parameter.command=Eliminar parámetro ''{0}''
fix.change.signature.unavailable=<no disponible>
fix.change.signature.unnamed.parameter=parámetro
fix.change.suspend.hierarchy.add=Agregar modificador 'suspend' a todas las funciones en la jerarquía
fix.change.suspend.hierarchy.remove=Eliminar modificador 'suspend' de todas las funciones en la jerarquía
fix.change.to.function.invocation=Cambiar a invocación de función
fix.change.to.labeled.return.family=Cambiar a return con etiqueta
fix.change.to.labeled.return.text=Cambiar a ''{0}''
fix.change.to.mutable.type.family=Cambiar tipo a mutable
fix.change.to.mutable.type.text=Cambiar tipo a {0}
fix.change.to.property.access.family.change=Cambiar a acceso de propiedad
fix.change.to.property.access.family.remove=Eliminar invocación
fix.change.to.star.projection.family=Cambiar a proyección estrella
fix.change.to.star.projection.text=Cambiar argumentos de tipo a {0}
fix.change.to.use.spread.operator.family=Cambiar para usar operador spread
fix.change.to.use.spread.operator.text=Cambiar ''{0}'' a ''{1}''
fix.change.type.argument=Cambiar argumento de tipo a {0}
fix.change.type.family=Cambiar tipo
fix.change.type.text=Cambiar tipo de ''{0}'' a ''{1}''
fix.convert.to.is.array.of.call=Convertir a llamada 'isArrayOf'
fix.copy.mismatched.annotation.to.actual.declaration.may.change.semantics=Copiar anotación no coincidente ''{0}'' de ''expect'' a declaración ''actual'' (puede cambiar la semántica)
fix.create.declaration.error=No se puede generar {0}\: {1}
fix.create.declaration.error.inaccessible.type=Tipo inaccesible
fix.create.declaration.error.some.types.inaccessible=Algunos tipos son inaccesibles\:
fix.create.expect.actual=Crear declaración expect / actual
fix.create.from.usage.dialog.title=Crear desde uso
fix.create.from.usage.family=Crear desde uso
fix.create.from.usage.local.variable=Crear variable local ''{0}''
fix.create.from.usage.property=Crear propiedad ''{0}''
fix.create.missing.actual.declarations=Agregar declaraciones actual faltantes
fix.create.missing.actual.declarations.title=Agregar declaraciones actual faltantes
fix.create.missing.actual.members=Agregar miembros actual faltantes
fix.import=Importar
fix.import.exclude=Excluir ''{0}'' de auto-importación
fix.import.kind.0.name.1.2=Importar {0} ''{1}''{2,choice,0\#|1\# y {2} más}
fix.import.kind.0.name.1.and.name.2=Importar {0} ''{1}'', ''{2}''
fix.import.kind.component.functions=Funciones componente
fix.import.kind.delegate.accessors=Accesores delegados
fix.import.question=¿Importar {0}?
fix.insert.delegation.call=Insertar llamada ''{0}()''
fix.introduce.non.null.assertion=Agregar llamada con aserción non-null ({0}\!\!)
fix.make.data.class=Convertir ''{0}'' en data class
fix.make.field.public=Hacer el campo ''{0}'' public
fix.make.type.parameter.reified=Hacer {0} reified y {1} inline
fix.make.upperbound.not.nullable.any.text=Agregar ''Any'' como límite superior para {0} para hacerlo non-nullable
fix.make.upperbound.not.nullable.family=Hacer parámetro de tipo genérico non-nullable
fix.make.upperbound.not.nullable.remove.nullability.text=Cambiar el límite superior de {0} a ''{1}'' para hacer {0} non-nullable
fix.move.file.to.package.dir.name.text=raíz de fuentes
fix.move.file.to.package.family=Mover archivo al directorio correspondiente del paquete
fix.move.file.to.package.text=Mover archivo a {0}
fix.move.to.sealed.family=Mover miembro de jerarquía al paquete/módulo de su padre sealed
fix.move.to.sealed.text=Mover {0} al paquete/módulo de {1}
fix.move.typealias.to.top.level=Mover typealias al nivel superior
fix.opt_in.annotation.family=Anotar uso de función opt-in
fix.opt_in.migrate.experimental.annotation.remove=Eliminar anotación '@Experimental' obsoleta
fix.opt_in.migrate.experimental.annotation.replace=Reemplazar anotación '@Experimental' obsoleta con '@RequiresOptIn'
fix.opt_in.move.requirement.from.getter.to.property=Mover requerimiento opt-in ''{0}'' del getter a la propiedad
fix.opt_in.move.requirement.from.value.parameter.to.property=Mover requerimiento opt-in ''{0}'' del parámetro de valor a la propiedad
fix.opt_in.remove.all.forbidden.targets=Eliminar objetivos de anotación opt-in prohibidos
fix.opt_in.remove.forbidden.retention=Eliminar retención de anotación opt-in prohibida
fix.opt_in.text.propagate.constructor=Propagar requerimiento opt-in de ''{0}'' al constructor
fix.opt_in.text.propagate.containing.class=Propagar requerimiento opt-in de ''{0}'' a la clase contenedora ''{1}''
fix.opt_in.text.propagate.containing.object=Propagar requerimiento opt-in de ''{0}'' al objeto contenedor ''{1}''
fix.opt_in.text.propagate.declaration=Propagar requerimiento opt-in de ''{0}'' a ''{1}''
fix.opt_in.text.use.constructor=Opt in para ''{0}'' en el constructor
fix.opt_in.text.use.containing.anonymous.object=Opt in para ''{0}'' en el objeto contenedor
fix.opt_in.text.use.containing.class=Opt in para ''{0}'' en la clase contenedora ''{1}''
fix.opt_in.text.use.containing.file=Opt in para ''{0}'' en el archivo contenedor ''{1}''
fix.opt_in.text.use.containing.object=Opt in para ''{0}'' en el objeto contenedor ''{1}''
fix.opt_in.text.use.declaration=Opt in para ''{0}'' en ''{1}''
fix.opt_in.text.use.module=Opt in para ''{0}'' en el módulo ''{1}''
fix.opt_in.text.use.statement=Opt in para ''{0}'' en la declaración
fix.potentially.broken.inheritance.message=Este cambio podría romper los herederos.\n¿Desea continuar?
fix.potentially.broken.inheritance.title=Herencia potencialmente rota
fix.remove.annotation.text=Eliminar anotación
fix.remove.argument.text=Eliminar argumento
fix.remove.mismatched.annotation.from.expect.declaration.may.change.semantics=Eliminar anotación no coincidente ''{0}'' de la declaración ''expect'' (puede cambiar la semántica)
fix.remove.non.null.assertion=Eliminar aserción non-null innecesaria (\!\!)
fix.remove.redundant.star.text=Eliminar * redundante
fix.replace.annotation.family=Reemplazar anotación
fix.replace.annotation.text=Reemplazar anotación con ''@{0}''
fix.replace.mismatched.annotation.args.on.actual.declaration.may.change.semantics=Reemplazar argumentos de anotación no coincidente ''{0}'' en declaración ''actual'' (puede cambiar la semántica)
fix.replace.mismatched.annotation.args.on.expect.declaration.may.change.semantics=Reemplazar argumentos de anotación no coincidente ''{0}'' en declaración ''expect'' (puede cambiar la semántica)
fix.replace.with.assign.function.call=Reemplazar con llamada ''{0}''
fix.replace.with.declaring.java.class=Reemplazar con 'declaringJavaClass'
fix.text=Eliminar punto y coma redundante
fix.unused.receiver.parameter.remove=Eliminar parámetro receptor redundante
fix.use.fully.qualified.call=Usar llamada completamente calificada
fix.with.asdynamic=Corregir con 'asDynamic'
flatten.when.expression=Aplanar expresión 'when'
flip.0=Invertir ''{0}''
flip.binary.expression=Invertir expresión binaria
flip.equals=Invertir 'equals'
floating.point.literal.precision.inspection=El literal de punto flotante no puede representarse con la precisión requerida
floating.point.literal.precision.inspection.display.name=El literal de punto flotante excede la precisión disponible
foldable.if.then=if-then plegable
following.expression.won.t.be.processed.since.refactoring.can.t.preserve.its.semantics.0=La siguiente expresión no será procesada ya que la refactorización no puede preservar su semántica\: {0}
following.problems.are.found=Se encontraron los siguientes problemas\:\n
for.0=para ''{0}''
for.api.stability.it.s.recommended.to.specify.explicitly.declaration.types=Para la estabilidad de la API, se recomienda especificar explícitamente los tipos de declaración
for.api.stability.it.s.recommended.to.specify.explicitly.public.protected.declaration.types=Para la estabilidad de la API, se recomienda especificar explícitamente los tipos de declaración public y protected
for.loop.over.indices.could.be.replaced.with.loop.over.elements=El bucle for sobre índices podría reemplazarse con un bucle sobre elementos
formatter.button.text.use.import.with=Usar import con '*'
formatter.button.text.use.import.with.when.at.least=Usar import con '*' cuando al menos
formatter.button.text.use.single.name.import=Usar import de nombre único
formatter.checkbox.text.insert.imports.for.nested.classes=Insertar imports para clases anidadas
formatter.checkbox.text.use.trailing.comma=Usar coma final
formatter.settings.title=Configuración del Formateador Kotlin
formatter.text.names.used=\ nombres usados
formatter.text.use.defaults.from=Usar valores predeterminados de\:
formatter.title.after.colon.before.declaration.type=Después de dos puntos, antes del tipo de declaración
formatter.title.after.colon.in.new.type.definition=Después de dos puntos en nueva definición de tipo
formatter.title.align.when.branches.in.columns=Alinear ramas 'when' en columnas
formatter.title.around.arrow.in=Alrededor de la flecha en cláusula "when"
formatter.title.around.arrow.in.function.types=Alrededor de la flecha en tipos de función
formatter.title.around.when.branches.with=Alrededor de ramas 'when' con {}
formatter.title.before.colon.after.declaration.name=Antes de dos puntos, después del nombre de declaración
formatter.title.before.colon.in.new.type.definition=Antes de dos puntos en nueva definición de tipo
formatter.title.before.declaration.with.comment.or.annotation=Antes de declaración con comentario o anotación
formatter.title.before.lambda.arrow=Antes de flecha lambda
formatter.title.chained.function.calls=Llamadas a funciones encadenadas
formatter.title.elvis.expressions=Expresiones Elvis
formatter.title.elvis.operator=Operador Elvis (?\:)
formatter.title.expression.body.functions=Funciones de cuerpo de expresión
formatter.title.function.annotations=Anotaciones de función
formatter.title.function.call.arguments=Argumentos de llamada a función
formatter.title.function.declaration.parameters=Parámetros de declaración de función
formatter.title.function.parentheses=Paréntesis de función
formatter.title.in.simple.one.line.methods=En métodos simples de una línea
formatter.title.indent.before.arrow.on.new.line=Indentar antes de '->' en nueva línea
formatter.title.java.statics.and.enum.members=Miembros Static y Enum de Java
formatter.title.line.break.after.multiline.when.entry=Nueva línea después de entrada multilínea
formatter.title.load.save=Cargar/Guardar
formatter.title.other=Otros
formatter.title.property.annotations=Anotaciones de propiedad
formatter.title.put.left.brace.on.new.line=Poner llave izquierda en nueva línea
formatter.title.range.operator=Operadores de rango (.., ..<)
formatter.title.top.level.symbols=Símbolos de nivel superior
formatter.title.trailing.comma=Coma final
formatter.title.use.continuation.indent=Usar indentación de continuación
formatter.title.use.continuation.indent.in.conditions=Usar indentación de continuación en condiciones
formatter.title.when.parentheses=Paréntesis de 'when'
formatter.title.when.statements=Sentencias 'when'
function=Función
function.0=función ''{0}''
function.0.returning.1.without.the.corresponding=Función ''{0}'' que devuelve ''{1}'' sin la función correspondiente ''{2}'' que devuelve ''{3}''
function.01=Función "{0}"
function.name.is.invalid=El nombre de la función no es válido
function.returning.0.with.a.name.that.does.not.end.with.1=Función que devuelve {0} con un nombre que no termina en {1}
function.should.have.operator.modifier=La función debe tener el modificador 'operator'
generate.equals.and.hashcode.fix.text=Generar equals() y hashCode()
generate.identity.equals.fix.family.name=Generar equals y hashCode por identidad
goto.related.provider.in.module.0=(en el módulo {0})
goto.super.chooser.class.title=Elegir Superclase o Interfaz
goto.super.chooser.function.title=Elegir función Super
goto.super.chooser.property.title=Elegir propiedad Super
group.InternalKotlin.text=Acciones Internas de Kotlin
group.KotlinCompletionBenchmarkGroup.text=Benchmark de Completado
group.KotlinInternalGroup.text=Kotlin
group.KotlinRefactoringTesting.text=Pruebas de Refactorización Kotlin
group.KotlinToolsGroup.text=Kotlin
group.advanced.settings.kotlin=Kotlin
group.names.code.migration=Migración de código
group.names.coroutine=Inspecciones de corrutinas
group.names.gradle=Gradle
group.names.java.interop.issues=Problemas de interoperabilidad con Java
group.names.kotlin=Kotlin
group.names.logging=Logging
group.names.maven=Maven
group.names.migration=Migración
group.names.naming.conventions=Convenciones de nomenclatura
group.names.other.problems=Otros problemas
group.names.probable.bugs=Bugs probables
group.names.redundant.constructs=Construcciones redundantes
group.names.style.issues=Problemas de estilo
group.path.kotlin.migration=Kotlin,Migración
hash.code.text=Generar 'hashCode()'
hierarchy.legend.member.defined.in.superclass=El miembro no está definido en la clase pero sí en la superclase
hierarchy.legend.member.is.defined.in.class=El miembro está definido en la clase
hierarchy.legend.member.should.be.defined=El miembro debe definirse ya que la clase no es abstract
hierarchy.text.anonymous=[anónimo]
hierarchy.text.in=\ en {0}
highlight.usages.of.receiver=Resaltar usos del receptor
highlighter.action.text.go.to.actual.declarations=Ir a Declaraciones Actuales
highlighter.action.text.go.to.expected.declaration=Ir a Declaración Esperada
highlighter.action.text.go.to.implementations=Ir a Implementaciones
highlighter.action.text.go.to.overridden.methods=Ir a métodos sobrescritos
highlighter.action.text.go.to.overridden.properties=Ir a propiedades sobrescritas
highlighter.action.text.go.to.subclasses=Ir a subclases
highlighter.action.text.go.to.super.method=Ir a super método
highlighter.action.text.go.to.super.property=Ir a super propiedad
highlighter.descriptor.text.android.extensions.property=Propiedades y Variables//Propiedades sintéticas de extensiones Android
highlighter.descriptor.text.annotation=Anotación//Nombre de anotación
highlighter.descriptor.text.annotation.attribute.name=Anotación//Nombre de atributo de anotación
highlighter.descriptor.text.arrow=Llaves y Operadores//Flecha
highlighter.descriptor.text.builtin.annotation=Palabras clave//Modificador
highlighter.descriptor.text.builtin.keyword=Palabras clave//Palabra clave
highlighter.descriptor.text.builtin.keyword.val=Palabras clave//'val'
highlighter.descriptor.text.builtin.keyword.var=Palabras clave//'var'
highlighter.descriptor.text.captured.variable=Propiedades y Variables//Variables y valores capturados en un closure
highlighter.descriptor.text.closure.braces=Llaves y Operadores//Llaves y flecha de expresión lambda
highlighter.descriptor.text.colon=Llaves y Operadores//Dos puntos
highlighter.descriptor.text.constructor.call=Funciones//Llamada al constructor
highlighter.descriptor.text.double.colon=Llaves y Operadores//Doble dos puntos
highlighter.descriptor.text.dynamic.fun.call=Funciones//Llamada a función dinámica
highlighter.descriptor.text.dynamic.property=Propiedades y Variables//Propiedad dinámica
highlighter.descriptor.text.enum=Clases e Interfaces//Enum
highlighter.descriptor.text.enumEntry=Clases e Interfaces//Entrada de enum
highlighter.descriptor.text.exclexcl=Llaves y Operadores//Aserción non-null
highlighter.descriptor.text.extension.fun.call=Funciones//Llamada a función de extensión
highlighter.descriptor.text.extension.property=Propiedades y Variables//Propiedad de extensión
highlighter.descriptor.text.field=Propiedades y Variables//Variable de campo de respaldo
highlighter.descriptor.text.fun=Funciones//Declaración de función
highlighter.descriptor.text.fun.call=Funciones//Llamada a función
highlighter.descriptor.text.instance.property=Propiedades y Variables//Propiedad de instancia
highlighter.descriptor.text.instance.property.custom.property.declaration=Propiedades y Variables//Propiedad de instancia con declaraciones de propiedad personalizadas
highlighter.descriptor.text.it=Parámetros//Parámetro por defecto de expresión lambda
highlighter.descriptor.text.kdoc.comment=Comentarios//KDoc//Comentario KDoc
highlighter.descriptor.text.kdoc.tag=Comentarios//KDoc//Etiqueta KDoc
highlighter.descriptor.text.kdoc.value=Comentarios//KDoc//Enlace en etiqueta KDoc
highlighter.descriptor.text.label=Etiqueta
highlighter.descriptor.text.local.variable=Propiedades y Variables//Variable o valor local
highlighter.descriptor.text.named.argument=Argumento nombrado
highlighter.descriptor.text.object=Clases e Interfaces//Objeto
highlighter.descriptor.text.package.fun.call=Funciones//Llamada a función a nivel de paquete
highlighter.descriptor.text.package.property=Propiedades y Variables//Propiedad a nivel de paquete
highlighter.descriptor.text.package.property.custom.property.declaration=Propiedades y Variables//Propiedad a nivel de paquete con declaraciones de propiedad personalizadas
highlighter.descriptor.text.quest=Llaves y Operadores//Marcador de nullability de tipo
highlighter.descriptor.text.safe.access=Llaves y Operadores//Punto de acceso seguro
highlighter.descriptor.text.smart.cast=Smart-casts//Valor de smart-cast
highlighter.descriptor.text.smart.cast.receiver=Smart-casts//Receptor implícito de smart-cast
highlighter.descriptor.text.smart.constant=Smart-casts//Constante smart
highlighter.descriptor.text.string.escape=String//Escape en string y llaves de plantilla
highlighter.descriptor.text.suspend.fun.call=Funciones//Llamada a función suspend
highlighter.descriptor.text.synthetic.extension.property=Propiedades y Variables//Propiedad de extensión sintética
highlighter.descriptor.text.typeAlias=Clases e Interfaces//Alias de tipo
highlighter.descriptor.text.var=Propiedades y Variables//Var (variable mutable, parámetro o propiedad)
highlighter.descriptor.text.variable.as.function.call=Propiedades y Variables//Variable como llamada a función
highlighter.descriptor.text.variable.as.function.like.call=Propiedades y Variables//Variable como llamada tipo función
highlighter.message.suspend.function.call=Llamada a función suspend
highlighter.message.suspending.iteration=Iteración suspendida
highlighter.name.dsl=Dsl//
highlighter.name.dsl.markers=Marcadores DSL
highlighter.name.expect.actual.line.markers=Marcadores de línea Kotlin 'expect'//'actual'
highlighter.name.implemented.declaration=Declaración implementada
highlighter.name.implementing.declaration=Declaración que implementa
highlighter.name.kotlin.line.markers=Marcadores de línea Kotlin
highlighter.name.multiplatform.actual.declaration=Declaración actual multiplataforma
highlighter.name.multiplatform.expect.declaration=Declaración expect multiplataforma
highlighter.name.overridden.declaration=Declaración sobrescrita
highlighter.name.overriding.declaration=Declaración que sobrescribe
highlighter.name.style=Estilo {0}
highlighter.notification.text.navigation.to.overriding.classes.is.not.possible.during.index.update=La navegación a clases que sobrescriben no es posible durante la actualización del índice
highlighter.prefix.text.has.actuals.in=Tiene actuals en {0} {1, choice, 0\#módulo|1\#módulos}
highlighter.text.click.for.navigate=Haga clic en {0} para navegar
highlighter.text.has.functional.implementations=Tiene implementaciones funcionales
highlighter.text.implements=Implementa
highlighter.text.in={0} en ''{1}''
highlighter.text.or.press=\ o presione {0}
highlighter.text.overrides=Sobrescribe
highlighter.title.overriding.declarations.of=Declaraciones que sobrescriben {0}
highlighter.title.searching.for.overriding.declarations=Buscando declaraciones que sobrescriben
highlighter.title.searching.for.overriding.methods=Buscando métodos que sobrescriben
highlighter.tool.tip.has.expect.declaration.in=Tiene expects en {0} {1, choice, 0\#módulo|1\#módulos}
highlighter.tool.tip.marker.annotation.for.dsl=Anotación marcadora para DSL
highlighter.tool.tip.text.function=función
highlighter.tool.tip.text.property=propiedad
highlighter.tool.tip.text.recursive.call=Llamada recursiva
hint.text.no.expression.found=No se encontró expresión
hints.codevision.implementations.format={0, choice, 1\#1 Implementación|2\#{0,number} Implementaciones}
hints.codevision.implementations.too_many.format={0,number}+ Implementaciones
hints.codevision.inheritors.format={0, choice, 1\#1 Heredero|2\#{0,number} Herederos}
hints.codevision.inheritors.to_many.format={0,number}+ Herederos
hints.codevision.overrides.format={0, choice, 1\#1 Sobrescritura|2\#{0,number} Sobrescrituras}
hints.codevision.overrides.to_many.format={0,number}+ Sobrescrituras
hints.codevision.settings=Configuración…
hints.codevision.usages.format={0, choice, 1\#1 Uso|2\#{0,number} Usos}
hints.codevision.usages.too_many.format={0,number}+ Usos
hints.ranges.greaterOrEqual=≥
hints.ranges.less=<
hints.ranges.lessOrEqual=≤
hints.settings.common.items=Mostrar sugerencias para\:
hints.settings.dont.show.lambda.receivers.parameters=No mostrar sugerencias de receptor implícito y parámetros
hints.settings.dont.show.lambda.return=No mostrar sugerencias de expresiones de retorno
hints.settings.dont.show.ranges=No mostrar sugerencias de rangos
hints.settings.dont.show.suspending=No mostrar sugerencias de llamadas suspendidas
hints.settings.dont.show.types.parameter=No mostrar sugerencias de tipo de parámetro de función
hints.settings.dont.show.types.property=No mostrar sugerencias de tipo de propiedad
hints.settings.dont.show.types.return=No mostrar sugerencias de tipo de retorno de función
hints.settings.dont.show.types.variable=No mostrar sugerencias de tipo de variable local
hints.settings.excluded.parameters=Nombres de parámetros excluidos
hints.settings.lambda.receivers.parameters=Receptores y parámetros implícitos
hints.settings.lambda.return=Expresiones de retorno
hints.settings.lambdas=Lambdas
hints.settings.parameters=Parámetros
hints.settings.ranges=Rangos
hints.settings.show.lambda.receivers.parameters=Mostrar sugerencias de receptor y parámetro implícitos
hints.settings.show.lambda.return=Mostrar sugerencias de expresión de retorno
hints.settings.show.ranges=Mostrar sugerencias de rango
hints.settings.show.suspending=Mostrar sugerencias de llamada suspendida
hints.settings.show.types.parameter=Mostrar sugerencias de tipo de parámetro de función
hints.settings.show.types.property=Mostrar sugerencias de tipo de propiedad
hints.settings.show.types.return=Mostrar sugerencias de tipo de retorno de función
hints.settings.show.types.variable=Mostrar sugerencias de tipo de variable local
hints.settings.suspending=Llamadas suspendidas
hints.settings.types=Tipos
hints.settings.types.parameter=Tipos de parámetros de función
hints.settings.types.property=Tipos de propiedades
hints.settings.types.return=Tipos de retorno de función
hints.settings.types.variable=Tipos de variables locales
hints.settings.values.ranges=Rangos
hints.title.argument.name.enabled=Nombre de argumento
hints.title.codevision=Code Vision
hints.title.dont.show.argument.name.enabled=No mostrar sugerencias de nombre de argumento
hints.title.show.argument.name.enabled=Mostrar sugerencias de nombre de argumento
hints.types=Sugerencias de tipo
if.null.return.break.foldable.to=If-Null return/break/... plegable a '?\:'
if.then.foldable.to=If-Then plegable a '?\:'
implement.abstract.class=Implementar clase abstract
implement.abstract.function=Implementar función abstract
implement.abstract.member=Implementar miembro abstract
implement.abstract.property=Implementar propiedad abstract
implement.as.constructor.parameter=Implementar como parámetro de constructor
implement.interface=Implementar interfaz
implement.sealed.class=Implementar clase sealed
implicit.nothing.s=Nothing's implícitos
implicit.parameter.it.of.enclosing.lambda.is.shadowed=El parámetro implícito 'it' del lambda envolvente está sombreado
implicit.unsafe.cast.from.dynamic.to.0=Cast implícito (inseguro) de dynamic a {0}
import.members.from.0=Importar miembros de ''{0}''
import.members.with=Importar miembros con '*'
import.optimizer.notification.text.unused.imports.not.found=No se encontraron imports sin usar
import.optimizer.progress.indicator.text.collect.imports.for=Recopilar imports para {0}
import.optimizer.text.import={0, choice, 0\#import|2\#imports}
import.optimizer.text.non.zero=Eliminados {0} {1}{2, choice, 0\#|1\#, agregados {2} {3}}
import.optimizer.text.zero=Imports reordenados
import.order.button.text.add.package=Agregar Paquete
import.order.button.text.down=Abajo
import.order.button.text.remove=Eliminar
import.order.button.text.up=Arriba
import.progress.text.resolve.imports=Buscar todos los imports…
import.text.all.alias.imports=todos los imports alias
import.text.all.other.imports=todos los otros imports
import.text.import=import
in.class.0=\ en la clase ''{0}''
inaccessible.declaration=Declaración inaccesible
incomplete.destructuring.declaration.text=Declaración de desestructuración incompleta
incomplete.destructuring.fix.family.name=Agregar variables faltantes a la declaración de desestructuración
indent.raw.string=Indentar string raw
index.is.not.used.in.the.loop.body=El índice no se usa en el cuerpo del bucle
infix.call.may.be.dot.call=La llamada infix puede ser llamada con punto
inheritance.of.kotlin.sealed={0,choice,0\#La interfaz|1\#La clase} Java no puede ser parte de una jerarquía sealed de Kotlin
initialize.with.constructor.parameter=Inicializar con parámetro de constructor
initialize.with.constructor.parameter.analyzing.existing.variables=Analizando variables existentes…
inlay.kotlin.call.chains.hints=Mostrar sugerencias integradas para cadenas de llamadas
inlay.kotlin.lambdas.hints=Mostrar sugerencias integradas para lambdas
inlay.kotlin.lambdas.hints.hints.lambda.receivers.parameters=Mostrar sugerencias integradas para receptores y parámetros implícitos
inlay.kotlin.lambdas.hints.hints.lambda.return=Mostrar sugerencias integradas para expresiones de retorno
inlay.kotlin.parameters.hints=Muestra nombres de parámetros en los sitios de llamada a funciones.
inlay.kotlin.parameters.hints.excluded=Mostrar nombres de parámetros excluidos
inlay.kotlin.references.types.hints=Mostrar sugerencias integradas para tipos
inlay.kotlin.references.types.hints.hints.type.function.parameter=Mostrar sugerencias integradas para tipos de parámetros de función
inlay.kotlin.references.types.hints.hints.type.function.return=Mostrar sugerencias integradas para tipos de retorno de función
inlay.kotlin.references.types.hints.hints.type.property=Mostrar sugerencias integradas para tipos de propiedades
inlay.kotlin.references.types.hints.hints.type.variable=Mostrar sugerencias integradas para tipos de variables locales
inlay.kotlin.values.hints=Mostrar sugerencias integradas para valores
inlay.kotlin.values.hints.kotlin.values.ranges=Mostrar sugerencias integradas para rangos
inline.type.parameter=Inline parámetro de tipo
inline.variable=Inline variable
inline.when.argument=Inline argumento 'when'
insert.curly.braces.around.variable=Insertar llaves alrededor de la variable
insert.explicit.delegation.call=Insertar llamada de delegación explícita
insert.number.conversion=Insertar conversión de número
inspection.add.conversion.call.display.name=Se requiere conversión explícita desde `Int` desde 1.9
inspection.add.kotlin.coroutines.display.name=Agregar biblioteca Kotlin Coroutines
inspection.add.operator.modifier.display.name=La función debe tener el modificador 'operator'
inspection.add.variance.modifier.display.name=El parámetro de tipo puede tener varianza 'in' o 'out'
inspection.ambiguous.expression.when.branch.migration.display.name=Expresiones lógicas ambiguas en ramas 'when' desde 1.7
inspection.array.in.data.class.display.name=Propiedad array en data class
inspection.boolean.literal.argument.display.name=Argumento literal booleano sin nombre de parámetro
inspection.can.be.parameter.display.name=El parámetro del constructor nunca se usa como propiedad
inspection.can.be.primary.constructor.property.display.name=La propiedad está explícitamente asignada al parámetro del constructor
inspection.can.be.val.display.name=La 'var' local nunca se modifica y puede declararse como 'val'
inspection.can.convert.to.multi.dollar.string.display.name=Se puede usar interpolación multi-dólar en literales de string (disponible desde 2.1)
inspection.can.convert.to.multi.dollar.string.problem.description=Un prefijo de interpolación puede simplificar el string
inspection.can.sealed.subclass.be.object.display.name=Subclase sealed sin estado y equals no sobrescrito
inspection.can.unescape.dollar.literal.inspection.display.name=Caracteres dólar escapados redundantes en literales de string
inspection.can.unescape.dollar.literal.inspection.problem.description=Los caracteres dólar escapados en la cadena pueden simplificarse
inspection.cascade.if.display.name=El 'if' en cascada puede reemplazarse por 'when'
inspection.class.name.display.name=Convención de nombres de clases
inspection.complex.redundant.let.display.name=Llamada 'let' redundante basada en argumentos
inspection.conflicting.extension.property.display.name=Propiedad de extensión en conflicto con sintética
inspection.const.property.name.display.name=Convención de nombres de propiedades const
inspection.constant.condition.if.display.name=La condición de la expresión 'if' es constante
inspection.control.flow.with.empty.body.display.name=Control de flujo con cuerpo vacío
inspection.convert.argument.to.set.display.name=El argumento podría convertirse a 'Set' para mejorar el rendimiento
inspection.convert.call.chain.into.sequence.display.name=La cadena de llamadas en colección podría convertirse a 'Sequence' para mejorar el rendimiento
inspection.convert.lambda.to.reference.display.name=Puede reemplazarse por referencia a función
inspection.convert.na.n.equality.display.name=Convertir comprobación de igualdad con 'NaN' a llamada 'isNaN'
inspection.convert.object.to.data.object.display.name=Convertir 'object' a 'data object'
inspection.convert.pair.constructor.to.to.function.display.name=Convertir constructor Pair a función 'to'
inspection.convert.reference.to.lambda.display.name=Puede reemplazarse por lambda
inspection.convert.secondary.constructor.to.primary.display.name=Convertir a constructor primario
inspection.convert.to.string.template.display.name=Concatenación de cadenas que puede convertirse a plantilla de cadena
inspection.convert.try.finally.to.use.call.display.name=Convertir try / finally a llamada use()
inspection.convert.two.comparisons.to.range.check.display.name=Dos comparaciones deberían convertirse a una comprobación de rango
inspection.copy.without.named.arguments.display.name=El método 'copy' de data class se llama sin argumentos nombrados
inspection.data.class.private.constructor.display.name=Constructor private de data class expuesto a través del método 'copy'
inspection.deferred.is.result.display.name=Función que retorna Deferred directamente
inspection.deferred.result.unused.display.name=Resultado '@Deferred' no utilizado
inspection.delegation.to.var.property.display.name=Delegando a propiedad 'var'
inspection.deprecated.callable.add.replace.with.display.name=Anotación @Deprecated sin argumento 'replaceWith'
inspection.deprecated.enum.declaring.class.property=Propiedad 'Enum.declaringClass' deprecada
inspection.deprecated.gradle.dependency.display.name=Se usa biblioteca deprecada en Gradle
inspection.deprecated.inline.class.text=Clase inline deprecada
inspection.deprecated.inline.classes.migration.display.name=Las clases inline están deprecadas desde 1.5
inspection.deprecated.maven.dependency.display.name=Se usa biblioteca deprecada en Maven
inspection.destructure.display.name=Usar declaración de desestructuración
inspection.destructuring.wrong.name.display.name=Variable en declaración de desestructuración usa nombre de propiedad incorrecta de data class
inspection.different.kotlin.gradle.version.display.name=Las versiones de plugins Kotlin Gradle e IDE son diferentes
inspection.different.kotlin.maven.version.display.name=Las versiones de plugins Maven e IDE son diferentes
inspection.different.maven.stdlib.version.display.name=Las versiones de biblioteca y plugin maven son diferentes
inspection.different.stdlib.gradle.version.display.name=Las versiones de biblioteca Kotlin y plugin Gradle son diferentes
inspection.do.not.propagate.method.deprecation.through.overrides=No propagar la deprecación del método a través de sobreescrituras desde 1.9
inspection.empty.range.display.name=El rango con inicio mayor que endInclusive está vacío
inspection.enum.entry.name.display.name=Convención de nombres de entradas enum
inspection.enum.values.method.soft.deprecate.in.java.display.name=Se recomienda reemplazar 'Enum.values()' por 'Enum.getEntries()' desde Kotlin 1.9
inspection.enum.values.method.soft.deprecate.migration.display.name=Se recomienda reemplazar 'Enum.values()' por 'Enum.entries' desde 1.9
inspection.equals.or.hash.code.display.name='equals()' y 'hashCode()' no emparejados
inspection.explicit.this.display.name='this' explícito redundante
inspection.fake.jvm.field.constant.display.name=Propiedad Kotlin no const usada como constante Java
inspection.filter.is.instance.call.with.class.literal.argument.display.name=Llamada 'filterIsInstance' con argumento literal de clase
inspection.filter.is.instance.call.with.class.literal.argument.quick.fix.text=Reemplazar argumento literal de clase con parámetro de tipo reificado
inspection.fold.initializer.and.if.to.elvis.display.name=If-Null return/break/... plegable a '?\:'
inspection.for.each.parameter.not.used.display.name=Los elementos iterados no se usan en forEach
inspection.from.closed.range.migration.display.name=Paso MIN_VALUE en fromClosedRange() desde 1.3
inspection.function.name.display.name=Convención de nombres de funciones
inspection.function.with.lambda.expression.body.display.name=Función con '\= { ... }' y tipo de retorno inferido
inspection.gradle.kotlinx.coroutines.deprecation.display.name=Se usa dependencia kotlinx.coroutines incompatible con Kotlin 1.3+ en Gradle
inspection.has.platform.type.display.name=Función o propiedad tiene tipo de plataforma
inspection.if.then.to.elvis.display.name=If-Then plegable a '?\:'
inspection.if.then.to.safe.access.display.name=If-Then plegable a '?.'
inspection.implicit.nullable.nothing.type.display.name=Tipo 'Nothing?' implícito
inspection.implicit.this.action.name=Agregar 'this' explícito
inspection.implicit.this.display.name='this' implícito
inspection.incomplete.destructuring.declaration.display.name=Declaración de desestructuración incompleta
inspection.inconsistent.comment.for.java.parameter.display.name=Comentario inconsistente para parámetro Java
inspection.introduce.when.subject.display.name='when' que puede simplificarse introduciendo un argumento
inspection.java.collections.static.method.display.name=La llamada al método estático de Java Collections puede reemplazarse con Kotlin stdlib
inspection.java.collections.static.method.on.immutable.list.display.name=Llamada a método mutador Java en colección Kotlin inmutable
inspection.java.io.serializable.object.must.have.read.resolve.display.name=El objeto Serializable debe implementar 'readResolve'
inspection.java.io.serializable.object.must.have.read.resolve.quick.fix.name=Implementar 'readResolve'
inspection.java.io.serializable.object.must.have.read.resolve.warning=El objeto Serializable debe implementar 'readResolve'
inspection.java.map.for.each.display.name=La llamada al método Map.forEach de Java debería reemplazarse por forEach de Kotlin
inspection.join.declaration.and.assignment.display.name=Unir declaración y asignación
inspection.join.declaration.and.assignment.option.report.with.complex.initialization.of.member.properties=Reportar con inicialización compleja de propiedades miembro
inspection.k.doc.missing.documentation.display.name=Faltan comentarios KDoc para declaraciones públicas
inspection.k.doc.unresolved.reference.display.name=Referencia no resuelta en KDoc
inspection.kotlin.catch.may.ignore.exception.display.name=El bloque 'catch' puede ignorar la excepción
inspection.kotlin.constant.conditions.display.name=Condiciones constantes
inspection.kotlin.covariant.equals.display.name='equals()' covariante
inspection.kotlin.deprecation.display.name=Uso de sintaxis redundante o deprecada o símbolos deprecados
inspection.kotlin.double.negation.action.name=Eliminar doble negación redundante
inspection.kotlin.double.negation.display.name=Doble negación redundante
inspection.kotlin.equals.between.inconvertible.types.display.name='equals()' entre objetos de tipos no convertibles
inspection.kotlin.internal.in.java.display.name=Uso de declaraciones internas de Kotlin desde Java
inspection.kotlin.invalid.bundle.or.property.display.name=Clave de propiedad inválida
inspection.kotlin.jvm.annotation.in.java.description=La anotación Kotlin JVM ''{0}'' no tiene efecto en Java
inspection.kotlin.jvm.annotation.in.java.display.name=Anotación Kotlin JVM en Java
inspection.kotlin.maven.plugin.phase.display.name=Plugin Kotlin Maven mal configurado
inspection.kotlin.options.to.compiler.options.display.name=Uso del DSL 'kotlinOptions' deprecado
inspection.kotlin.redundant.override.display.name=Método de sobreescritura redundante
inspection.kotlin.redundant.suppression.display.name=Supresión de diagnóstico redundante
inspection.kotlin.sealed.in.java.display.name=Herencia de interfaz/clase sealed de Kotlin desde Java
inspection.kotlin.test.j.unit.display.name=kotlin-test-junit podría usarse
inspection.kotlin.throwable.not.thrown.display.name=Throwable no lanzado
inspection.kotlin.unused.import.display.name=Directiva import no utilizada
inspection.kotlin.unused.variable.display.name=Variable no utilizada
inspection.lateinit.var.overrides.lateinit.var.display.name=Propiedad 'lateinit var' sobrescribe propiedad 'lateinit var'
inspection.leaking.this.display.name='this' con fuga en constructor
inspection.lift.return.or.assignment.display.name=El return o asignación puede extraerse
inspection.lift.return.or.assignment.option.only.single.statement=Reportar solo si cada rama es una única instrucción
inspection.local.variable.name.display.name=Convención de nombres de variables locales
inspection.logger.initialized.with.foreign.class.display.name=Logger inicializado con clase externa
inspection.logger.placeholder.count.matches.argument.count.display.name=El número de marcadores no coincide con el número de argumentos en la llamada de logging
inspection.loop.to.call.chain.display.name=El bucle puede reemplazarse por operaciones stdlib
inspection.main.function.return.unit.display.name=La función main debe retornar 'Unit'
inspection.map.get.with.not.null.assertion.operator.display.name='map.get()' con operador de aserción no-null (\!\!)
inspection.maven.coroutines.deprecation.display.name=Se usa una dependencia kotlinx.coroutines incompatible con Kotlin 1.3+ en Maven
inspection.may.be.constant.display.name=Podría ser 'const'
inspection.member.visibility.can.be.private.display.name=El miembro de clase puede tener visibilidad 'private'
inspection.message.cast.will.always.fail=El cast siempre fallará
inspection.message.condition.always.false=La condición ''{0}'' es siempre false
inspection.message.condition.always.false.when.reached=La condición ''{0}'' es siempre false cuando se alcanza
inspection.message.condition.always.true=La condición ''{0}'' es siempre true
inspection.message.condition.always.true.when.reached=La condición ''{0}'' es siempre true cuando se alcanza
inspection.message.empty.catch.block=Bloque catch vacío
inspection.message.for.never.visited=El rango 'for' siempre está vacío
inspection.message.inconsistent.parameter.name.for.0=Nombre de parámetro inconsistente para ''{0}''
inspection.message.index.out.of.bounds=El índice siempre está fuera de límites
inspection.message.nonnull.cast.will.always.fail=La operación siempre fallará ya que el operando es siempre null
inspection.message.object.with.manual.tostring.can.be.converted.to.data.object='object' con 'toString' manual puede convertirse a 'data object'
inspection.message.sealed.object.can.be.converted.to.data.object=Sub-objeto 'sealed' puede convertirse a 'data object'
inspection.message.value.always.false=El valor de ''{0}'' es siempre false
inspection.message.value.always.null=El valor de ''{0}'' es siempre null
inspection.message.value.always.true=El valor de ''{0}'' es siempre true
inspection.message.value.always.zero=El valor de ''{0}'' es siempre cero
inspection.message.when.condition.always.false=La rama 'when' nunca es alcanzable
inspection.migrate.diagnostic.suppression.display.name=El nombre del diagnóstico debe ser reemplazado
inspection.move.lambda.outside.parentheses.display.name=Argumento lambda dentro de paréntesis
inspection.move.suspicious.callable.reference.into.parentheses.display.name=Referencia callable sospechosa usada como resultado lambda
inspection.move.variable.declaration.into.when.display.name=La declaración de variable podría moverse dentro de 'when'
inspection.nested.lambda.shadowed.implicit.parameter.display.name=Lambda anidado tiene parámetro implícito sombreado
inspection.no.actual.for.expect.display.name=No hay actual para la declaración expect
inspection.non.exhaustive.when.statement.migration.display.name=Las sentencias 'when' no exhaustivas serán prohibidas desde 1.7
inspection.null.checks.to.safe.call.display.name=Las comprobaciones null pueden reemplazarse por llamadas seguras
inspection.nullable.boolean.elvis.action.name=Usar comprobación de igualdad en lugar de elvis para comprobación de booleano nullable
inspection.nullable.boolean.elvis.display.name=Se puede usar comprobación de igualdad en lugar de elvis para comprobación de booleano nullable
inspection.object.literal.to.lambda.display.name=El literal de objeto puede convertirse a lambda
inspection.object.private.property.name.display.name=Convención de nombres de propiedades private de object
inspection.object.property.name.display.name=Convención de nombres de propiedades object
inspection.obsolete.experimental.coroutines.display.name=Los usos experimentales de coroutines están deprecados desde 1.3
inspection.obsolete.kotlin.js.packages.display.name=Los paquetes 'kotlin.browser' y 'kotlin.dom' están deprecados desde 1.4
inspection.optional.expectation.display.name=La anotación esperada opcional no tiene anotación real
inspection.package.directory.mismatch.display.name=El nombre del paquete no coincide con el directorio contenedor
inspection.package.name.display.name=Convención de nombres de paquetes
inspection.platform.extension.receiver.of.inline.display.name='inline fun' con receptor nullable hasta Kotlin 1.2
inspection.private.property.name.display.name=Convención de nombres de propiedades private
inspection.progression.resolution.change.migration.display.name=Cambio en la resolución de progresión desde 1.9
inspection.prohibit.jvm.overloads.on.constructors.of.annotation.classes.migration.display.name=La anotación '@JvmOverloads' no puede usarse en constructores de clases de anotación desde 1.4
inspection.prohibit.repeated.use.site.target.annotations.migration.display.name=Anotación repetida que no está marcada como '@Repeatable'
inspection.prohibit.type.parameters.for.local.variables.migration.display.name=Variable local con parámetros de tipo
inspection.prohibit.use.site.target.annotations.on.super.types.migration.display.name=Objetivos de anotaciones sin sentido en superclase
inspection.property.name.display.name=Convención de nombres de propiedades
inspection.protected.in.final.display.name=La visibilidad 'protected' es efectivamente 'private' en una clase final
inspection.public.api.implicit.type.display.name=Declaración de API pública con tipo de retorno implícito
inspection.recursive.equals.call.display.name=Llamada recursiva a equals
inspection.recursive.property.accessor.display.name=Acceso recursivo a propiedad
inspection.redundant.anonymous.function.description=Creación redundante de función anónima
inspection.redundant.assequence.call=Llamada redundante a 'asSequence'
inspection.redundant.async.display.name=Llamada redundante a 'async'
inspection.redundant.companion.reference.display.name=Referencia redundante a 'Companion'
inspection.redundant.else.in.if.display.name='else' redundante en 'if'
inspection.redundant.elvis.return.null.descriptor=Redundante '?\: return null'
inspection.redundant.elvis.return.null.display.name=Redundante '?\: return null'
inspection.redundant.empty.initializer.block.display.name=Bloque inicializador vacío redundante
inspection.redundant.enum.constructor.invocation.display.name=Invocación redundante del constructor enum
inspection.redundant.explicit.type.display.name=Tipo explícito obvio
inspection.redundant.getter.display.name=Getter de propiedad redundante
inspection.redundant.if.display.name=Sentencia 'if' redundante
inspection.redundant.inner.class.modifier.descriptor=Modificador 'inner' redundante
inspection.redundant.inner.class.modifier.display.name=Modificador 'inner' redundante
inspection.redundant.label.migration.display.name=Etiqueta redundante
inspection.redundant.label.text=Etiqueta redundante
inspection.redundant.labeled.return.on.last.expression.in.lambda.display.name=Return etiquetado redundante en la última expresión de un lambda
inspection.redundant.lambda.arrow.display.name=Flecha lambda redundante
inspection.redundant.lambda.description=Creación redundante de lambda
inspection.redundant.lambda.or.anonymous.function.display.name=Creación redundante de lambda o función anónima
inspection.redundant.lambda.or.anonymous.function.fix=Inline el cuerpo
inspection.redundant.modality.modifier.display.name=Modificador de modalidad redundante
inspection.redundant.not.null.extension.receiver.of.inline.display.name=El receptor de extensión 'inline fun' puede ser explícitamente nullable hasta Kotlin 1.2
inspection.redundant.nullable.return.type.display.name=Tipo de retorno nullable redundante
inspection.redundant.object.type.check.display.name=Comprobación de tipo 'is' no idiomática para un objeto
inspection.redundant.require.not.null.call.display.name=Llamada redundante a 'requireNotNull' o 'checkNotNull'
inspection.redundant.return.label.display.name=Etiqueta 'return' redundante
inspection.redundant.run.catching.display.name=Llamada redundante a 'runCatching'
inspection.redundant.sam.constructor.display.name=Constructor SAM redundante
inspection.redundant.semicolon.display.name=Punto y coma redundante
inspection.redundant.setter.display.name=Setter de propiedad redundante
inspection.redundant.suspend.modifier.display.name=Modificador 'suspend' redundante
inspection.redundant.unit.expression.display.name='Unit' redundante
inspection.redundant.unit.return.type.action.name=Eliminar tipo de retorno 'Unit' redundante
inspection.redundant.unit.return.type.display.name=Tipo de retorno 'Unit' redundante
inspection.redundant.value.argument.annotation=El argumento de valor coincide con el valor por defecto del parámetro ''{0}''
inspection.redundant.value.argument.display.name=Argumento de valor redundante
inspection.redundant.visibility.modifier.display.name=Modificador de visibilidad redundante
inspection.redundant.with.display.name=Llamada redundante a 'with'
inspection.remove.curly.braces.from.template.display.name=Llaves redundantes en template de string
inspection.remove.empty.class.body.display.name=Reemplazar cuerpo de clase vacío
inspection.remove.empty.parentheses.from.annotation.entry.display.name=Eliminar paréntesis innecesarios
inspection.remove.empty.parentheses.from.lambda.call.action.name=Eliminar paréntesis innecesarios de llamada a función con lambda
inspection.remove.empty.parentheses.from.lambda.call.display.name=Paréntesis innecesarios en llamada a función con lambda
inspection.remove.empty.primary.constructor.display.name=Constructor primario vacío redundante
inspection.remove.empty.secondary.constructor.body.display.name=Cuerpo de constructor redundante
inspection.remove.explicit.super.qualifier.display.name=Calificación de supertipo innecesaria
inspection.remove.explicit.type.arguments.display.name=Argumento de tipo innecesario
inspection.remove.for.loop.indices.display.name=Índice de bucle no utilizado
inspection.remove.redundant.backticks.display.name=Backticks redundantes
inspection.remove.redundant.calls.of.conversion.methods.display.name=Llamada redundante de método de conversión
inspection.remove.redundant.qualifier.name.display.name=Nombre calificador redundante
inspection.remove.redundant.spread.operator.display.name=Operador spread redundante
inspection.remove.setter.parameter.type.display.name=Tipo de parámetro setter redundante
inspection.remove.single.expression.string.template.display.name=Template string redundante
inspection.remove.to.string.in.string.template.display.name=Llamada redundante a 'toString()' en template string
inspection.replace.array.equality.op.with.arrays.equals.display.name=Comparación de arrays mediante '\=\=' y '\!\='
inspection.replace.array.of.with.literal.display.name=La llamada 'arrayOf' puede reemplazarse con literal de array [...]
inspection.replace.assert.boolean.with.assert.equality.display.name=La aserción booleana podría reemplazarse con aserción de igualdad
inspection.replace.associate.function.display.name='associate' puede reemplazarse con 'associateBy' o 'associateWith'
inspection.replace.call.with.binary.operator.display.name=Puede reemplazarse con operador binario
inspection.replace.collection.count.with.size.display.name=El count de colección puede convertirse a size
inspection.replace.get.or.set.display.name=Llamada explícita a 'get' o 'set'
inspection.replace.guard.clause.with.function.call.display.name=La cláusula guard puede reemplazarse con una llamada a función de Kotlin
inspection.replace.isempty.with.ifempty.display.name=La condición 'if' puede reemplazarse con llamada lambda
inspection.replace.java.static.method.with.kotlin.analog.display.name=Los métodos Java deberían reemplazarse con su análogo en Kotlin
inspection.replace.manual.range.with.indices.calls.display.name=El rango puede convertirse a índices o iteración
inspection.replace.mapIndexed.with.list.generator.display.name=Reemplazar 'mapIndexed' con generador de List
inspection.replace.negated.is.empty.with.is.not.empty.display.name=La llamada negada puede simplificarse
inspection.replace.not.null.assertion.with.elvis.return.display.name=La aserción not-null puede reemplazarse con 'return'
inspection.replace.put.with.assignment.display.name='map.put()' puede convertirse a asignación
inspection.replace.range.start.end.inclusive.with.first.last.display.name=Las propiedades boxed deberían reemplazarse con unboxed
inspection.replace.range.to.with.rangeUntil.display.name='rangeTo' o la llamada '..' debería reemplazarse con '..<'
inspection.replace.range.to.with.until.display.name='rangeTo' o la llamada '..' debería reemplazarse con 'until'
inspection.replace.readline.with.readln.display.name='readLine' puede reemplazarse con 'readln' o 'readlnOrNull'
inspection.replace.size.check.with.is.not.empty.display.name=La comprobación de tamaño puede reemplazarse con 'isNotEmpty()'
inspection.replace.size.zero.check.with.is.empty.display.name=La comprobación de tamaño cero puede reemplazarse con 'isEmpty()'
inspection.replace.string.format.with.literal.display.name=La llamada 'String.format' puede reemplazarse con templates string
inspection.replace.substring.with.drop.last.display.name=La llamada 'substring' debería reemplazarse con llamada 'dropLast'
inspection.replace.substring.with.indexing.operation.display.name=La llamada 'substring' debería reemplazarse con operador de indexación
inspection.replace.substring.with.substring.after.display.name=La llamada 'substring' debería reemplazarse con 'substringAfter'
inspection.replace.substring.with.substring.before.display.name=La llamada 'substring' debería reemplazarse con 'substringBefore'
inspection.replace.substring.with.take.display.name=La llamada 'substring' debería reemplazarse con llamada 'take'
inspection.replace.to.string.with.string.template.display.name=La llamada a 'toString' podría reemplazarse con template string
inspection.replace.to.with.infix.form.display.name=La llamada 'to' debería reemplazarse con forma infix
inspection.replace.until.with.rangeUntil.operator.display.name=Reemplazar 'until' con operador '..<'
inspection.replace.with.enum.map.display.name='HashMap' puede reemplazarse con 'EnumMap'
inspection.replace.with.ignore.case.equals.display.name=Debería reemplazarse con 'equals(..., ignoreCase \= true)'
inspection.replace.with.import.alias.display.name=El nombre completamente calificado puede reemplazarse con alias de importación existente
inspection.replace.with.operator.assignment.display.name=La asignación puede reemplazarse con asignación de operador
inspection.replace.with.string.builder.append.range.display.name=Llamada 'StringBuilder.append(CharArray, offset, len)' en la JVM
inspection.restrict.return.statement.target.migration.display.name=La etiqueta target no denota una función desde 1.4
inspection.runblocking.analysis.found.runblocking=--> runBlocking
inspection.runblocking.analysis.graphbuilding.progress=Procesando {0}
inspection.runblocking.presentation.descriptor=Analizando runBlocking\:
inspection.runblocking.presentation.display.name=RunBlocking en coroutine
inspection.runblocking.presentation.settings.exploration.option.all=Sí, incluyendo sobreescrituras
inspection.runblocking.presentation.settings.exploration.option.declaration=Sí, excluyendo sobreescrituras
inspection.runblocking.presentation.settings.exploration.option.strict=No
inspection.runblocking.presentation.settings.exploration.title=Explorar funciones con sobreescrituras
inspection.runblocking.presentation.text=Constructor RunBlocking llamado desde coroutine
inspection.safe.cast.with.return.display.name=El safe cast con 'return' debería reemplazarse con comprobación de tipo 'if'
inspection.scope.function.conversion.display.name=La función scope puede convertirse a otra
inspection.self.assignment.display.name=Asignación redundante
inspection.self.reference.constructor.parameter.display.name=El constructor nunca puede completarse
inspection.setter.backing.field.assignment.display.name=Campo backing existente sin asignación
inspection.simple.redundant.let.display.name=Llamada 'let' redundante basada en receptor
inspection.simplifiable.call.chain.display.name=La cadena de llamadas en tipo colección puede simplificarse
inspection.simplifiable.call.display.name=La llamada a función de biblioteca podría simplificarse
inspection.simplifiable.scope.function.display.name=La función scope con forEach anidado puede simplificarse
inspection.simplify.assert.not.null.display.name=La llamada 'assert' puede reemplazarse con '\!\!' o '?\:'
inspection.simplify.boolean.with.constants.display.name=La expresión booleana puede simplificarse
inspection.simplify.negated.binary.expression.display.name=La expresión booleana negada puede simplificarse
inspection.simplify.when.with.boolean.constant.condition.display.name='when' simplificable
inspection.sort.modifiers.display.name=Orden de modificadores no canónico
inspection.suspend.function.on.coroutine.scope.display.name=coroutineContext ambiguo debido al receptor CoroutineScope de la función suspend
inspection.suspicious.as.dynamic.display.name=Invocación sospechosa de miembro 'asDynamic'
inspection.suspicious.collection.reassignment.display.name=La asignación aumentada crea una nueva colección internamente
inspection.suspicious.equals.combination.display.name=Combinación sospechosa de \=\= y \=\=\=
inspection.suspicious.var.property.display.name=Propiedad 'var' sospechosa\: su setter no influye en el resultado del getter
inspection.test.function.name.display.name=Convención de nombres de función de test
inspection.this.class.does.not.have.a.constructor=Llamada a constructor prohibida
inspection.trailing.comma.add.line.break=Agregar salto de línea
inspection.trailing.comma.add.trailing.comma=Agregar coma final
inspection.trailing.comma.comma.loses.the.advantages.in.this.position=La coma pierde las ventajas en esta posición
inspection.trailing.comma.display.name=Recomendaciones de coma final
inspection.trailing.comma.fix.comma.position=Corregir posición de la coma
inspection.trailing.comma.missing.line.break=Falta salto de línea
inspection.trailing.comma.missing.trailing.comma=Falta coma final
inspection.trailing.comma.remove.trailing.comma=Eliminar coma final
inspection.trailing.comma.report.also.a.missing.comma=Reportar también una coma faltante o un salto de línea
inspection.trailing.comma.useless.trailing.comma=Coma final inútil
inspection.unlabeled.return.inside.lambda.display.name=Return sin etiqueta dentro de lambda
inspection.unnecessary.opt_in.annotation.display.name=Anotación '@OptIn' innecesaria
inspection.unnecessary.opt_in.redundant.annotation=La anotación opt-in es redundante\: no se usa ninguna API experimental coincidente
inspection.unnecessary.opt_in.redundant.marker=El marcador opt-in es redundante\: no se usa ninguna API experimental marcada con ''{0}''
inspection.unnecessary.opt_in.remove.annotation.fix.family.name=Eliminar anotación
inspection.unnecessary.opt_in.remove.marker.fix.family.name=Eliminar marcador opt-in
inspection.unnecessary.variable.display.name=Variable local innecesaria
inspection.unnecessary.variable.option.report.immediately.returned.variables=Reportar variables retornadas inmediatamente
inspection.unsafe.cast.from.dynamic.display.name=Cast implícito (inseguro) desde tipo dinámico
inspection.unused.equals.display.name=Expresión equals sin usar
inspection.unused.lambda.expression.body.display.name=Valor de retorno no usado de una función con cuerpo de expresión lambda
inspection.unused.main.parameter.display.name=El parámetro main no es necesario
inspection.unused.receiver.parameter=El parámetro receptor nunca se usa
inspection.unused.receiver.parameter.display.name=Parámetro receptor sin usar
inspection.unused.result.of.data.class.copy=Resultado sin usar de copia de data class
inspection.unused.symbol.display.name=Símbolo sin usar
inspection.unused.unary.operator.display.name=Operador unario sin usar
inspection.use.expression.body.display.name=La sintaxis de cuerpo de expresión es preferible aquí
inspection.use.property.access.syntax.display.name=Llamada de acceso que puede reemplazarse con sintaxis de acceso a propiedad
inspection.use.with.index.display.name=La variable de índice incrementada manualmente puede reemplazarse con 'withIndex()'
inspection.useless.call.on.collection.display.name=Llamada inútil en tipo de colección
inspection.useless.call.on.not.null.display.name=Llamada inútil en tipo no nulo
inspection.verbose.nullability.and.emptiness.call=Reemplazar verificaciones subsiguientes con llamada ''{0}()''
inspection.verbose.nullability.and.emptiness.display.name=Verificación detallada de nulabilidad y vacío
inspection.warning.on.main.unused.parameter.migration.display.name='args' sin usar en 'main' desde 1.4
inspection.when.with.only.else.action.name=Simplificar 'when' con solo una rama 'else'
inspection.when.with.only.else.display.name='when' solo tiene rama 'else' y puede simplificarse
inspection.wrap.unary.operator.display.name=Uso ambiguo de operador unario con constante numérica
intention.add.import.alias.group.name=Agregar alias de importación
intention.change.package.text=Cambiar paquete
intention.convert.lambda.line=Convertir a lambda de {0,choice,0\#una|1\#múltiples} líneas
intention.create.test.dialog.kotlin=Kotlin
intention.error.cannot.create.class.message=No se puede crear la clase ''{0}''
intention.error.cannot.create.class.title=Error al crear la clase
intention.extract.declarations.from.file.text=Extraer declaración del archivo actual
intention.extract.declarations.from.file.text.details=Extraer ''{0}'' {1, choice, 0\#|1\#y subclases }del archivo actual
intention.flow.on.dispatchers.io=Flow en 'Dispatchers.IO'
intention.implement.abstract.method.command.name=Implementar método
intention.implement.abstract.method.searching.for.descendants.progress=Buscando descendientes…
intention.name.specify.supertype=Especificar supertipo
intention.name.use.correct.parameter.name=Usar nombre correcto del parámetro
intention.switch.context.to.dispatchers.io=Cambiar al contexto 'Dispatchers.IO'
intention.trailing.comma.custom.text={0,choice,0\#Habilitar|1\#Deshabilitar} coma final por defecto en el formateador
intention.trailing.comma.text=Habilitar/deshabilitar coma final en el formateador
intention.wrap.in.with.context=Envolver llamada en 'withContext'
interface=Interfaz
interface.member.dependency.required.by.interfaces=requerido por {0,choice,1\#interfaz|2\#interfaces}
interface.should.be.external=La interfaz debe ser external
internal.toggle.throwing.cached.pce.title=Interno\: Alternar lanzamiento de PCE en caché
introduce.0.as.subject.0.when=Introducir ''{0}'' como sujeto de ''when''
introduce.anonymous.parameter.fix.family.name=Introducir parámetro anónimo
introduce.backing.property=Introducir propiedad de respaldo
introduce.constant=Introducir constante
introduce.import.alias=Introducir alias de importación
introduce.property=Introducir propiedad
introduce.type.parameter=Introducir parámetro de tipo
introduce.type.parameter.to.declaration=Introducir parámetro de tipo a la declaración
introduce.variable=Introducir variable
introduce.when.subject=Introducir sujeto 'when'
invert.if.condition=Invertir condición 'if'
it.s.prohibited.to.call.0.with.min.value.step.since.1.3=Está prohibido llamar a {0} con paso MIN_VALUE desde 1.3
iterate.over.0=Iterar sobre ''{0}''
iterate.over.collection=Iterar sobre colección
java.collections.static.method.call.should.be.replaced.with.kotlin.stdlib=La llamada al método static de Java Collections debe reemplazarse con Kotlin stdlib
java.map.foreach.method.call.should.be.replaced.with.kotlin.s.foreach=La llamada al método Map.forEach de Java debe reemplazarse con forEach de Kotlin
join.declaration.and.assignment=Unir declaración y asignación
join.with.initializer.fix.text=Unir con inicializador
junit.static.methods=Métodos static de JUnit
kdoc.comment.unresolved=Sin resolver
kdoc.section.title.author=Autores
kdoc.section.title.constructor=Constructor
kdoc.section.title.parameters=Parámetros
kdoc.section.title.properties=Propiedades
kdoc.section.title.receiver=Receptor
kdoc.section.title.returns=Retorna
kdoc.section.title.samples=Ejemplos
kdoc.section.title.see.also=Ver también
kdoc.section.title.since=Desde
kdoc.section.title.suppress=Suprimir
kdoc.section.title.throws=Lanza
kotlin.call.chains.hints=Kotlin\: Mostrar hints incrustados para cadenas de llamadas
kotlin.compiler.configurable=Compilador Kotlin
kotlin.dist.downloading.failed.group.name=Falló la descarga de Kotlin dist
kotlin.external.compiler.updates.notification.group.name=Actualizaciones disponibles del compilador externo de Kotlin
kotlin.jps.plugin.group.name=Plugin Kotlin JPS
kotlin.lambdas.hints=Kotlin\: Mostrar hints incrustados para lambdas
kotlin.lambdas.hints.hints.lambda.receivers.parameters=Kotlin\: Mostrar hints incrustados para receptores y parámetros implícitos
kotlin.lambdas.hints.hints.lambda.return=Kotlin\: Mostrar hints incrustados para expresiones de retorno
kotlin.references.types.hints=Kotlin\: Mostrar hints incrustados para tipos
kotlin.references.types.hints.hints.type.function.parameter=Kotlin\: Mostrar hints incrustados para tipos de parámetros de función
kotlin.references.types.hints.hints.type.function.return=Kotlin\: Mostrar hints incrustados para tipos de retorno de función
kotlin.references.types.hints.hints.type.property=Kotlin\: Mostrar hints incrustados para tipos de propiedades
kotlin.references.types.hints.hints.type.variable=Kotlin\: Mostrar hints incrustados para tipos de variables locales
kotlin.script.definitions.model.name.autoReloadScriptDependencies=Recarga automática
kotlin.script.definitions.model.name.autoReloadScriptDependencies.description=Habilite la recarga automática si desea cargar configuraciones de script automáticamente al cambiar el archivo
kotlin.script.definitions.model.name.is.enabled=Está habilitado
kotlin.script.definitions.model.name.name=Nombre
kotlin.script.definitions.model.name.pattern.extension=Patrón/Extensión
kotlin.script.definitions.title=Administrar definiciones de script\:
kotlin.script.in.beta.stage=Kotlin Scripting está ahora en fase Beta
kotlin.script.in.beta.stage.link=https\://kotlinlang.org/docs/components-stability.html\#stability-levels-explained
kotlin.script.in.project.sources=<html>Este script no debería estar dentro de la raíz de fuentes. Después de Kotlin 1.9 será ignorado durante la compilación del módulo.</html>
kotlin.script.in.project.sources.1.9=<html>Este script no debería estar dentro de la raíz de fuentes. Desde Kotlin 1.9 es ignorado durante la compilación del módulo.</html>
kotlin.script.in.project.sources.allow=Permitir…
kotlin.script.in.project.sources.hide=Ocultar
kotlin.script.in.project.sources.later=Decidir más tarde
kotlin.script.in.project.sources.link=https\://youtrack.jetbrains.com/issue/KT-52735
kotlin.script.in.project.sources.move=Mover a…
kotlin.script.lookup.definitions=Buscando definiciones de script Kotlin…
kotlin.script.sources.index=Indexar
kotlin.script.sources.not.yet.indexed=No se indexaron los archivos fuente para reducir el tiempo de inicio del proyecto
kotlin.script.warning.more.info=Más información
kotlin.scripting.configurable=Scripting Kotlin
kotlin.values.hints=Mostrar hints incrustados para valores
kotlin.values.hints.kotlin.values.ranges=Kotlin\: Mostrar hints incrustados para rangos
label.text.default.receiver.value=Valor predeterminado del receptor(&D)\:
label.text.destination=Destino(&D)\:
label.text.destination.directory=Directorio de &destino\:
label.text.file=&Archivo\:
label.text.file.name=&Nombre de archivo\:
label.text.introduce.as=&Introducir como\:
label.text.move.expect.actual.counterparts=&Mover contrapartes expect/actual
label.text.name=&Nombre\:
label.text.package=P&aquete\:
label.text.package.name=Nombre del paque&te\:
label.text.receiver.type=&Tipo receptor\:
label.text.source.sets=Source sets\:
label.text.target.file.name=Nombre del archivo destino\:
label.text.to.class=A clase\:
label.text.to.file=A archi&vo\:
label.text.to.object=A objeto\:
label.text.to.package=Al p&aquete\:
label.text.type=&Tipo\:
label.text.visibility=&Visibilidad\:
lambda.argument.0.be.moved.out=El argumento lambda {0,choice,0\#puede|1\#debe} moverse fuera de paréntesis
leaking.this.in.constructor.of.enum.class.0.with.overridable.members=Fuga de ''this'' en el constructor de la clase enum {0} (con miembros sobreescribibles)
leaking.this.in.constructor.of.non.final.class.0=Fuga de ''this'' en el constructor de la clase no final {0}
let.0.1=Permitir que {0} {1}
let.type.implement.interface=Permitir que el tipo implemente la interface
lift.assignment.out.fix.text.0=Extraer asignación de ''{0}''
lift.assignment.out.of.try.expression=Extraer asignación de la expresión 'try'
lift.function.call.out.of.if=Extraer llamada a función de 'if'
lift.function.call.out.of.when=Extraer llamada a función de 'when'
lift.return.out.fix.text.0=Extraer return de ''{0}''
lift.return.out.of.if.expression=Extraer return de la expresión 'if'
listbox.import.package=Paquete
listbox.import.with.subpackages=Con Subpaquetes
livetemplate.description.anonymous=Clase anónima
livetemplate.description.closure=Closure (función sin nombre)
livetemplate.description.exfun=Función de extensión
livetemplate.description.exval=Propiedad de extensión de solo lectura
livetemplate.description.exvar=Propiedad de extensión de lectura-escritura
livetemplate.description.fun0=Función sin parámetros
livetemplate.description.fun1=Función con un parámetro
livetemplate.description.fun2=Función con dos parámetros
livetemplate.description.ifn=Inserta expresión 'if null'
livetemplate.description.inn=Inserta expresión 'if not null'
livetemplate.description.interface=Interface
livetemplate.description.iter=Itera sobre elementos de iterable (bucle for-in)
livetemplate.description.main=función main()
livetemplate.description.maina=función main(args)
livetemplate.description.singleton=Singleton
livetemplate.description.soutp=Imprime los nombres y valores de los parámetros de la función en System.out
livetemplate.description.void=Función que no devuelve nada
local.variable=Variable local
logger.initialized.with.foreign.class=Logger inicializado con clase externa ''{0}''
looking.for.usages.and.conflicts=Buscando usos y conflictos…
looking.for.usages.in.java.files=Buscando usos en archivos Java…
loop.can.be.replaced.with.stdlib.operations=El bucle puede reemplazarse con operaciones stdlib
loop.parameter.0.is.unused=El parámetro de bucle ''{0}'' no se usa
loop.to.call.fix.family.name=Reemplazar con operaciones stdlib
loop.to.call.fix.family.name2=Reemplazar con operaciones stdlib usando 'asSequence()'
make.0=Hacer {0}
make.0.1=Hacer ''{0}'' {1}
make.0.1.explicitly=Hacer ''{0}'' {1} explícitamente
make.0.an.annotation.class=Convertir ''{0}'' en clase de anotación
make.0.explicitly=Hacer {0} explícitamente
make.0.in.1.open=Hacer ''{0}'' en {1} open
make.0.not.1=Hacer {0} no {1}
make.class.an.annotation.class=Convertir clase en clase de anotación
make.constructor.parameter.a.property.0=Convertir parámetro del constructor en propiedad{0}
make.member.static.quickfix=Hacer ''{0}'' static
make.not.nullable=Hacer no-nullable
make.open=Hacer 'open'
make.open.fix.text=Hacer la clase open
make.primary.constructor.0=Hacer constructor primario {0}
make.private.and.0.1=Hacer private y {0} ''{1}''
make.private.fix.text=Hacer private
make.type.parameter.reified.and.function.inline=Hacer el parámetro de tipo reified y la función inline
making.member.static=Haciendo miembro static…
map.get.with.not.null.assertion.operator='map.get()' con operador de aserción no-null '(\!\!)'
map.put.should.be.converted.to.assignment=map.put() debería convertirse a asignación
mark.as.deprecated.level.deprecationlevel.hidden=Marcar como '@Deprecated(..., level \= DeprecationLevel.HIDDEN)'
max.functions.to.visit=Máximo de funciones a visitar
maximum.count.of.applied.refactoring.before.validity.check=Conteo máximo de refactorización aplicada antes de la verificación
may.contain.only.letters.and.digits=solo puede contener letras y dígitos
may.contain.only.letters.digits.or.underscores=solo puede contener letras, dígitos o guiones bajos
member.info.abstract.0=abstract {0}
member.info.companion.0=companion {0}
merge.else.if=Combinar 'else if'
merge.if.s=Combinar 'if's
message.change.signature.is.not.applicable.to.dynamically.invoked.functions="Cambiar firma" no es aplicable a funciones invocadas dinámicamente
message.do.not.show.for.local.variables.in.future=No mostrar para variables locales en el futuro
message.text.property.receiver.type.cannot.be.resolved=No se puede resolver el tipo receptor de propiedad ''{0}''.\n¿Continuar?
message.text.property.type.cannot.be.resolved=No se puede resolver el tipo de propiedad ''{0}''.\n¿Continuar?
message.text.return.type.cannot.be.resolved=No se puede resolver el tipo de retorno ''{0}''.\n¿Continuar?
message.type.for.cannot.be.resolved=No se puede resolver el tipo ''{0}'' para {1}.\n¿Continuar?
methods.are.absent.in.coroutines.class.since.1.3=Los métodos están ausentes en la clase de coroutines desde 1.3
microservices.url.path.inlay.hints=Kotlin\: Mostrar hints incrustados para ruta URL
might.be.const=Podría ser 'const'
migrate.type.parameter.list.syntax=Migrar sintaxis de lista de parámetros de tipo
migrate.unsupported.yield.syntax=Migrar sintaxis yield no soportada
minimal.line.count=Conteo mínimo de líneas
missing.documentation=Falta documentación
modifiers.should.follow.annotations=Los modificadores deben seguir a las anotaciones
move.annotation.to.receiver.type=Mover anotación al tipo receptor
move.else.branch.to.the.end=Mover rama else al final
move.lambda.argument.into.parentheses=Mover argumento lambda dentro de paréntesis
move.lambda.argument.out.of.parentheses=Mover argumento lambda fuera de paréntesis
move.members.from=Mover miembros desde\:
move.out.of.companion.object=Mover fuera del objeto companion
move.refactoring.error.text.cannot.perform.refactoring.since.the.following.files.already.exist=No se puede realizar la refactorización ya que los siguientes archivos ya existen\:\n\n
move.refactoring.test=Prueba de refactorización de movimiento
move.refactoring.testing=Prueba de refactorización de movimiento
move.reference.into.parentheses=Mover referencia dentro de paréntesis
move.to.class.body=Mover al cuerpo de la clase
move.to.companion.object=Mover al objeto companion
move.to.companion.object.command=Mover al objeto companion
move.to.constructor=Mover al constructor
move.to.constructor.parameters=Mover a parámetros del constructor
move.to.top.level=Mover al nivel superior
move.type.parameter.constraint.to.where.clause=Mover restricción de parámetro de tipo a cláusula 'where'
move.unary.operator.to.previous.line.fix.text=Mover operador unario a la línea anterior
move.variable.declaration.into.when=Mover declaración de variable dentro de 'when'
moving.to.companion.object=Moviendo al objeto companion...
name=Nombre(&N)\:
name.extract.interface=Extraer interfaz
name.introduce.import.alias=Introducir alias de import
name.introduce.lambda.parameter=Introducir parámetro lambda
name.introduce.parameter1=Introducir parámetro
name.introduce.type.alias=Introducir alias de tipo
name.specify.supertype.command.title=Especificar supertipo
naming.convention.will.be.violated.after.rename=Las convenciones de nomenclatura se violarán después del renombrado
negated.operation.can.be.simplified=La operación negada puede simplificarse
nested.1.call.in.0.could.be.simplified.to.2=La llamada anidada ''{1}'' en ''{0}'' podría simplificarse a {2}
no.actual.for.expect.declaration=No hay actual para la declaración expect en el/los módulo(s)\: {0}
non.canonical.modifiers.order=Orden no canónico de modificadores
non.external.classifier.extending.state.or.props.name=Clasificador no external extendiendo State o Props
not.found.in.0.files=No encontrado en {0} archivo(s)
nothing.to.do=Nada que hacer
notification.navigation.to.overriding.classes=La navegación a clases que sobrescriben no es posible durante la actualización del índice
notification.text.kotlin.js.compiler.body=Use el nuevo compilador Kotlin/JS IR para reducir el tamaño del bundle de su aplicación y auto-generar definiciones TypeScript (d.ts).
notification.text.kotlin.js.compiler.learn.more=Más información
notification.text.kotlin.js.compiler.link=https\://kotl.in/jsirstable
notification.text.kotlin.js.compiler.title=¡Kotlin/JS IR es estable en versiones 1.8.0 y posteriores\!
null.checks.replaceable.with.safe.calls=Las comprobaciones de null pueden reemplazarse por llamadas seguras
null.checks.to.safe.call.check.fix.text=Reemplazar comprobaciones de null encadenadas por llamadas seguras
number.of.attempts.then.files.in.project.0=Número de intentos > que archivos en el proyecto, {0}
object.0=Objeto "{0}"
object.or.top.level.property=Objeto o propiedad de nivel superior
object.private.property=Propiedad private de objeto
object.should.be.external.interface=El objeto debería ser una interfaz external
obsolete.coroutine.usage.fix.family.name=Corregir uso de corrutinas experimentales
obsolete.coroutine.usage.in.whole.fix.family.name=Corregir usos de corrutinas experimentales en el proyecto
obsolete.kotlin.js.packages.usage.in.whole.fix.family.name=Corregir usos de paquetes 'kotlin.dom' y 'kotlin.browser' en el proyecto
obsolete.package.usage.fix.family.name=Corregir uso del paquete ''{0}''
one.line.return=retorno de una línea
open.moved.members.in.editor=Abrir miembros movidos en el editor
open.moved.method.in.editor=Abrir método movido en el editor
optimize.imports=Optimizar imports
optimize.imports.collect.unused.imports=Recopilando imports sin usar
optimize.imports.task.removing.redundant.imports=Eliminando imports redundantes
optionally.expected.annotation.has.no.actual.annotation.in.module.0.for.platform.1=La anotación esperada opcional no tiene anotación actual en el módulo {0} para la plataforma {1}
overridden.marker.implementation=Está implementado en\:
overridden.marker.implementations.choose.implementation.find.usages=Propiedades que sobrescriben de {0}
overridden.marker.implementations.choose.implementation.title=Elegir implementación de {0}
overridden.marker.implementations.multiple=Tiene implementaciones
overridden.marker.overrides=Está sobrescrito en\:
overridden.marker.overrides.choose.implementation.find.usages=Implementaciones super de {0}
overridden.marker.overrides.choose.implementation.title=Elegir implementación super de {0}
overridden.marker.overrides.multiple=Está sobrescrito en subclases
override.declaration.choose.to.delete=Elija los que desea eliminar.
override.declaration.delete.multiple.parameters={0} es parte de una jerarquía de métodos. ¿Desea eliminar múltiples parámetros?
override.declaration.member=Miembro
override.declaration.unused.overriding.methods.description=Hay miembros sin usar que sobrescriben métodos que está eliminando.
override.declaration.unused.overriding.methods.title=Miembros que sobrescriben sin usar
override.declaration.x.implements.y={0} implementa {1}.
override.declaration.x.in.y={0} en {1}
override.declaration.x.overrides.y.in.class.list={0} sobrescribe declaraciones en las siguientes clases/interfaces\: {1} ¿Desea {2} las declaraciones base?
package.0.already.contains.1=El paquete ''{0}'' ya contiene {1}
package.name=Nombre del paquete
package.usages.are.obsolete.since.1.4=Los usos del paquete ''{0}'' están obsoletos desde 1.4
parameter.0=Parámetro "{0}"
parameter.hints.old=Kotlin\: Mostrar sugerencias insertadas para parámetros
parameter.name.is.invalid=El nombre del parámetro ''{0}'' no es válido
parameter.name.prompt=Nombre del parámetro(&M)\:
parameter.type.is.invalid=El tipo de parámetro ''{0}'' no es válido
parameter.types.are.not.denotable=No se puede extraer el método ya que los siguientes tipos no son denotables en el ámbito objetivo\:
parameter.used.in.declaration.body.warning=''{0}'' se usa en el cuerpo de la declaración
parentheses.should.be.removed=Los paréntesis deben eliminarse
pass.outer.class.instance.as.parameter=Pasar instancia de clase externa como parámetro(&O)
perform.refactoring=Realizar refactorización...
placeholder.count.matches.argument.count.fewer.problem.descriptor=Se proporcionaron menos argumentos ({0}) que marcadores especificados ({1}) \#loc
placeholder.count.matches.argument.count.more.problem.descriptor=Se proporcionaron más argumentos ({0}) que marcadores especificados ({1}) \#loc
popup.title.choose.supertype=Elegir supertipo
popup.title.elements=Elementos
popup.title.expressions=Expresiones
popup.title.types=Tipos
predefined.configuration.all.methods.of.the.class=Todos los métodos de una clase
predefined.configuration.all.vars.of.the.class=Todas las vars de una clase
predefined.configuration.all.vars.of.the.object=Todas las vars de un objeto
predefined.configuration.also.match.vals=Coincidir tanto vars como vals
predefined.configuration.annotations=Anotaciones
predefined.configuration.anonymous.class=Clase anónima
predefined.configuration.array.access=Acceso a array
predefined.configuration.assert.not.null=Operadores de aserción no-null
predefined.configuration.assignments=Asignaciones
predefined.configuration.casts=Casteos
predefined.configuration.class.annotation=Clases anotadas
predefined.configuration.comments.containing.word=Comentarios que contienen una palabra dada
predefined.configuration.companion.object.method.calls=Llamadas a métodos desde companion object
predefined.configuration.do.while=Bucles do...while
predefined.configuration.elvis=Operadores Elvis
predefined.configuration.for=Bucles for
predefined.configuration.function.annotation=Funciones anotadas
predefined.configuration.function.explicit.inferred.type=Tipo explícito e inferido
predefined.configuration.function.signature=Firma de función
predefined.configuration.ifs=If's
predefined.configuration.instance=Instancias
predefined.configuration.kdoc.tag=Tags KDoc
predefined.configuration.lambda=Expresiones lambda
predefined.configuration.method.calls=Llamadas a métodos
predefined.configuration.object.companion.object=Object y companion object
predefined.configuration.properties.getter=Propiedades con getter explícito
predefined.configuration.safe.call.operator=Operadores de llamada segura
predefined.configuration.string.literals=Literales string
predefined.configuration.strings=Strings
predefined.configuration.strings.with.long.template=Strings que contienen una plantilla larga
predefined.configuration.trys=Try's
predefined.configuration.vars.of.given.type=Vars de tipo dado
predefined.configuration.when=Expresiones when
predefined.configuration.while=Bucles while
premature.end.of.template=Fin prematuro de plantilla
preparing.move.descriptor=Preparando descriptor de movimiento
presentation.text.for.receiver.in.container.paren=(para {0} en {1})
presentation.text.for.receiver.in.container.paren.no.brackets=para {0} en {1}
presentation.text.in.container={0} en {1}
presentation.text.in.container.paren=(en {0})
presentation.text.in.container.paren.no.brackets=en {0}
presentation.text.object.in.container=objeto en {0}
presentation.text.paren=({0})
presentation.text.paren.no.brackets={0}
print.should.be.replaced.with.logging.display.name=Llamada a 'print()' o 'println()'
private.data.class.constructor.is.exposed.via.the.generated.copy.method=El constructor primario private está expuesto a través del método 'copy()' generado de una clase 'data'.
private.property=Propiedad private
progress.finding.implicit.nothing.s=Buscando nothing implícitos
progress.looking.up.add.annotation.usage=Buscando uso de anotación…
progress.looking.up.sealed.subclass.usage=Buscando uso de subclase sealed…
progress.title.analyze.extraction.data=Analizar datos de extracción…
progress.title.calculate.occurrences=Calculando ocurrencias…
progress.title.calculating.type=Calculando tipo…
progress.title.check.for.conflicts=Comprobando conflictos…
progress.title.collect.hierarchy=Recopilar jerarquía de ''{0}''…
progress.title.collect.members.to.generate=Recopilando miembros…
progress.title.converting.to.if.then.else.expression=Convirtiendo a expresión if-then-else…
progress.title.introducing.value.for.condition=Introduciendo valor para condición…
progress.title.searching.for.expected.actual=Buscando expect/actual…
project.view.class.error.name=nombre no proporcionado
project.view.class.initializer=inicializador de clase
project.view.expression=expresión
property=Propiedad
property.0=Propiedad "{0}"
property.has.an.actual.declaration.in.the.class.constructor=La propiedad tiene una declaración actual en el constructor de la clase
property.in.external.interface.should.be.var=La propiedad en interfaz external debe ser var
property.is.explicitly.assigned.to.parameter.0.can=La propiedad está explícitamente asignada al parámetro {0}, por lo que puede declararse directamente en el constructor
property.overloaded.in.child.class.constructor=Propiedad sobrecargada en constructor de clase hija
protected.visibility.is.effectively.private.in.a.final.class=La visibilidad 'protected' es efectivamente 'private' en una clase final
provide.return.value=Proporcionar el valor de retorno
put.arguments.on.one.line=Poner argumentos en una línea
put.arguments.on.separate.lines=Poner argumentos en líneas separadas
put.calls.on.separate.lines=Poner llamadas en líneas separadas
put.expressions.on.separate.lines=Poner expresiones en líneas separadas
put.parameters.on.one.line=Poner parámetros en una línea
put.parameters.on.separate.lines=Poner parámetros en líneas separadas
quick.doc.no.documentation=No hay documentación disponible
quick.doc.section.deprecated=Obsoleto\:
quick.doc.section.java.declaration=Declaración Java\:
quick.doc.section.replace.with=Reemplazar con\:
quick.doc.text.enum.ordinal=Ordinal de constante enum\: {0}
quick.doc.text.lateinit='lateinit' permite inicializar una <a href\="https\://kotlinlang.org/docs/reference/properties.html\#late-initialized-properties-and-variables">propiedad no nula fuera del constructor</a>
quick.doc.text.tailrec='tailrec' marca una función como <a href\="https\://kotlinlang.org/docs/reference/functions.html\#tail-recursive-functions">tail-recursive</a> (permitiendo al compilador reemplazar la recursión con iteración)
quickFix.add.property.text=Agregar propiedad ''{0}{1}'' ''{2}'' a ''{3}''
quickfix.add.property.familyName=Agregar propiedad
quickfix.text.suffix.may.change.semantics=\ (puede cambiar la semántica)
random.seed=Semilla aleatoria
range.could.be.replaced.with.indices.call=El rango podría reemplazarse con llamada a '.indices'
recursive.equals.call=Llamada recursiva a equals
recursive.property.accessor=Accessor recursivo de propiedad
recursive.synthetic.property.accessor=Accessor sintético recursivo de propiedad
redundant.0=''@{0}'' redundante
redundant.0.call=Llamada ''{0}'' redundante
redundant.0.modifier=Modificador ''{0}'' redundante
redundant.async.call.may.be.reduced.to.0=La llamada redundante ''async'' puede reducirse a ''{0}''
redundant.companion.reference=Referencia Companion redundante
redundant.constructor.keyword=Palabra clave 'constructor' redundante
redundant.curly.braces.in.string.template=Llaves redundantes en plantilla de string
redundant.double.negation=Doble negación redundante
redundant.else='else' redundante
redundant.empty.class.body=Cuerpo de clase vacío redundante
redundant.empty.initializer.block=Bloque inicializador vacío redundante
redundant.enum.constructor.invocation=Invocación redundante del constructor enum
redundant.explicit.this=this explícito redundante
redundant.getter=Getter redundante
redundant.getter.body=Cuerpo de getter redundante
redundant.if.option.ignore.chained=Ignorar sentencias 'if' encadenadas
redundant.if.statement=Sentencia 'if' redundante
redundant.if.statement.analyzing.type=Analizando tipo de condición…
redundant.lambda.arrow=Flecha lambda redundante
redundant.let.call.could.be.removed=Se puede eliminar la llamada 'let' redundante
redundant.modality.modifier=Modificador de modalidad redundante
redundant.override.fix.text=Eliminar método de sobrescritura redundante
redundant.overriding.method=Método de sobrescritura redundante
redundant.qualifier.name=Nombre calificador redundante
redundant.qualifier.unnecessary.non.direct.parent.class.qualifier=Calificadores innecesarios de clases padre no directas
redundant.runcatching.call.may.be.reduced.to.0=La llamada redundante ''runCatching'' puede reducirse a ''{0}''
redundant.sam.constructor=Constructor SAM redundante
redundant.sam.constructors=Constructores SAM redundantes
redundant.semicolon=Punto y coma redundante
redundant.setter=Setter redundante
redundant.setter.body=Cuerpo del setter redundante
redundant.setter.parameter.type=Tipo de parámetro setter redundante
redundant.string.template=Plantilla de cadena redundante
redundant.suspend.modifier=Modificador 'suspend' redundante
redundant.tostring.call.in.string.template=Llamada 'toString()' redundante en plantilla de cadena
redundant.type.checks.for.object=Comprobaciones de tipo redundantes para objeto
redundant.unit='Unit' redundante
redundant.unit.return.type=Tipo de retorno 'Unit' redundante
redundant.visibility.modifier=Modificador de visibilidad redundante
refactoring.cannot.be.applied.no.sources.attached=La refactorización "{0}" no se puede aplicar\: no hay fuentes adjuntas
refactoring.cannot.be.applied.to.abstract.declaration=La refactorización {0} no se puede aplicar a una declaración abstract
refactoring.cannot.be.applied.to.anonymous.function.without.invocation=La refactorización {0} no se puede aplicar a una función anónima sin invocación
refactoring.cannot.be.applied.to.expect.declaration=La refactorización {0} no se puede aplicar a una declaración expect
refactoring.cannot.be.applied.to.lambda.expression.without.invocation=La refactorización {0} no se puede aplicar a una expresión lambda sin invocación
refactoring.extract.to.separate.file.text=Extraer a archivo separado
refactoring.move.non.kotlin.file=El destino debe ser un archivo Kotlin
refactoring.the.function.cannot.be.converted.to.anonymous.function=La función no se puede convertir a una función anónima
refactoring.the.function.not.found=No se encontró la función
refactoring.the.invocation.cannot.be.resolved=No se puede resolver la invocación
remove.0=Eliminar ''.{0}''
remove.0.from.parameter=Eliminar ''{0}'' del parámetro
remove.0.from.property=Eliminar {0} de la propiedad
remove.0.modifier=Eliminar modificador ''{0}''
remove.0.variance.from.1=Eliminar varianza ''{0}'' de ''{1}''
remove.all.argument.names=Eliminar todos los nombres de argumentos
remove.annotation.doesnt.have.any.effect=Eliminar anotación, ya que no tiene ningún efecto. Ver\: https\://youtrack.jetbrains.com/issue/KT-48141
remove.argument.name=Eliminar nombre del argumento
remove.as.dynamic.call.fix.text=Eliminar invocación 'asDynamic'
remove.assequence.call.fix.text=Eliminar llamada 'asSequence'
remove.braces=Eliminar llaves
remove.braces.fix.text=Eliminar llaves
remove.braces.from.0.statement=Eliminar llaves de la declaración ''{0}''
remove.braces.from.all.branches=Eliminar llaves de todas las ramas
remove.braces.from.if.all.statements=Eliminar llaves de todas las declaraciones 'if'
remove.braces.from.when.all.entries=Eliminar llaves de todas las entradas 'when'
remove.braces.from.when.entry=Eliminar llaves de la entrada 'when'
remove.branch=Eliminar rama
remove.condition=Eliminar condición
remove.conflicting.import.0=Eliminar importación en conflicto {0}
remove.constructor.call=Eliminar llamada al constructor
remove.conversion.from.kclass.to.class=Eliminar conversión de 'KClass' a 'Class'
remove.curly.braces=Eliminar llaves
remove.default.parameter.value=Eliminar valor predeterminado del parámetro
remove.deprecated.symbol.import=Eliminar importación de símbolo obsoleto
remove.element=Eliminar elemento
remove.else=Eliminar else en ''{0}''
remove.else.branch=Eliminar rama else
remove.empty.constructor.body=Eliminar cuerpo del constructor vacío
remove.empty.parentheses.from.annotation.entry.fix.text=Eliminar paréntesis innecesarios
remove.empty.primary.constructor=Eliminar constructor primario vacío
remove.enum.constructor.invocation.fix.text=Eliminar invocación del constructor enum
remove.explicit.lambda.parameter.types.may.break.code=Eliminar tipos de parámetros lambda explícitos (puede romper el código)
remove.explicit.supertype.qualification=Eliminar calificación explícita del supertipo
remove.explicit.type.arguments=Eliminar argumentos de tipo explícitos
remove.explicit.type.specification=Eliminar especificación de tipo explícita
remove.explicit.type.specification.from.0=Eliminar especificación de tipo explícita de ''{0}''
remove.expression=Eliminar ''{0}''
remove.expression.target=Eliminar objetivo de expresión
remove.extension.function.type.annotation=Eliminar anotación @ExtensionFunctionType inaplicable
remove.final.upper.bound=Eliminar límite superior final
remove.fix.text=Eliminar expresión
remove.from.annotation.argument=Eliminar @ del argumento de anotación
remove.function.body=Eliminar cuerpo de la función
remove.identifier.from.anonymous.function=Eliminar identificador de función anónima
remove.indices.in.for.loop=Eliminar índices en bucle 'for'
remove.initializer.block.fix.text=Eliminar bloque inicializador
remove.jvmfield.annotation=Eliminar anotación @JvmField
remove.jvmoverloads.annotation=Eliminar anotación @JvmOverloads
remove.labeled.return.from.last.expression.in.a.lambda=Eliminar return etiquetado de la última expresión en un lambda
remove.let.call=Eliminar llamada 'let'
remove.modifier=Eliminar modificador
remove.modifier.fix=Hacer que ''{0}'' no sea {1}
remove.modifier.fix.family=Hacer no {0}
remove.parameter.0=Eliminar parámetro ''{0}''
remove.parts.from.property=Eliminar partes de la propiedad
remove.redundant=Eliminar '?' redundante
remove.redundant.0.modifier=Eliminar modificador ''{0}'' redundante
remove.redundant.assignment=Eliminar asignación redundante
remove.redundant.backticks.quick.fix.text=Eliminar comillas invertidas redundantes
remove.redundant.call.fix.text=Eliminar llamada redundante
remove.redundant.calls.of.the.conversion.method=Eliminar llamadas redundantes del método de conversión
remove.redundant.companion.reference.fix.text=Eliminar referencia Companion redundante
remove.redundant.constructor.keyword.fix.text=Eliminar palabra clave 'constructor' redundante
remove.redundant.else.fix.text=Eliminar 'else' redundante
remove.redundant.elvis.return.null.text=Eliminar '?\: return null' redundante
remove.redundant.empty.class.body=Eliminar cuerpo de clase vacío redundante
remove.redundant.getter.body.fix.text=Eliminar cuerpo del getter redundante
remove.redundant.getter.fix.text=Eliminar getter redundante
remove.redundant.if.expression=Eliminar expresión 'if' redundante
remove.redundant.if.may.change.semantics.with.floating.point.types=Eliminar sentencia 'if' redundante (puede cambiar la semántica con tipos de punto flotante)
remove.redundant.if.text=Eliminar sentencia 'if' redundante
remove.redundant.initializer=Eliminar inicializador redundante
remove.redundant.label=Eliminar etiqueta redundante
remove.redundant.modality.modifier=Eliminar modificador de modalidad redundante
remove.redundant.qualifier.name.quick.fix.text=Eliminar nombre calificador redundante
remove.redundant.sam.constructor=Eliminar constructor SAM redundante
remove.redundant.sam.constructors=Eliminar constructores SAM redundantes
remove.redundant.setter.body.fix.text=Eliminar cuerpo de setter redundante
remove.redundant.setter.fix.text=Eliminar setter redundante
remove.redundant.spread.operator.quickfix.text=Eliminar operador spread redundante
remove.redundant.unit.fix.text=Eliminar 'Unit' redundante
remove.redundant.visibility.modifier=Eliminar modificador de visibilidad redundante
remove.redundant.with.fix.text=Eliminar llamada 'with' redundante
remove.require.not.null.call.fix.text=Eliminar llamada ''{0}''
remove.return.0=Eliminar return@{0}
remove.return.label.fix.family=Eliminar etiqueta redundante
remove.return.label.fix.text=Eliminar ''@{0}'' redundante
remove.self.assignment.fix.text=Eliminar auto-asignación
remove.single.expression.string.template=Eliminar plantilla de cadena de expresión única
remove.single.lambda.parameter.declaration=Eliminar declaración de parámetro lambda único
remove.star=Eliminar '*'
remove.supertype=Eliminar supertipo
remove.to.string.fix.text=Eliminar llamada 'toString()'
remove.token.from.function.declaration=Eliminar token '\=' de la declaración de función
remove.type.arguments=Eliminar argumentos de tipo
remove.type.parameters=Eliminar parámetros de tipo
remove.unary.operator.fix.text=Eliminar operador unario no utilizado
remove.underscores=Eliminar guiones bajos
remove.unnecessary.parentheses=Eliminar paréntesis innecesarios
remove.unnecessary.parentheses.from.function.call.with.lambda=Eliminar paréntesis innecesarios de llamada a función con lambda
remove.use.site.get.target=Eliminar 'get\:' para hacer efectiva la anotación. (cambia la semántica. Ver\: https\://youtrack.jetbrains.com/issue/KT-48141)
remove.useless=Eliminar '?' innecesario
remove.useless.cast=Eliminar cast innecesario
remove.useless.elvis.operator=Eliminar operador elvis innecesario
remove.useless.is.check=Eliminar comprobación is innecesaria
remove.val.or.var.from.parameter=Eliminar 'val' o 'var' del parámetro
remove.var.keyword.text=Eliminar 'var'
remove.variable=Eliminar variable
remove.variable.0=Eliminar variable ''{0}''
rename.base.0=Renombrar {0,choice,1\#función|2\#propiedad|3\#miembro|4\#método|11\#funciones|12\#propiedades|13\#miembros|14\#métodos} base
rename.class.to.0=Renombrar clase a {0}
rename.class.to.containing.file.name=Renombrar clase al nombre del archivo contenedor
rename.declaration.title.0.implements.1.2.of.3={0} {1,choice,1\#implementa|2\#sobrescribe} {2} de {3}
rename.file=Renombrar archivo
rename.file.0=Renombrar archivo a ''{0}''
rename.file.to.0.1=Renombrar archivo a {0}.{1}
rename.file.to.match.top.level.class.name=Renombrar archivo para coincidir con el nombre de la clase de nivel superior
rename.identifier.fix.text=Renombrar
rename.only.current.0=Renombrar solo {0,choice,1\#función|2\#propiedad} actual
rename.parameter.to.match.overridden.method=Renombrar parámetro para coincidir con el método sobrescrito
rename.searching.for.all.overrides=Buscando todas las sobrescrituras
rename.searching.for.super.declaration=Buscando la declaración super más profunda
rename.to.0=Renombrar a ''{0}''
rename.to.01=Renombrar a {0}
rename.to.fix.text=Renombrar a ''{0}''
rename.to.underscore=Renombrar a _
rename.useless.call.fix.text=Cambiar llamada a ''{0}''
reorder.parameters=Reordenar parámetros
reorder.parameters.command=Reordenar Parámetros
repair.actual.members=Reparar miembros actuales
replace.&&.with.||=Reemplazar '\\&\\&' con '||'
replace.0.call.with.indexing.operator=Reemplazar llamada ''{0}'' con operador de indexación
replace.0.name.with.spaces=Reemplazar nombre {0} con espacios
replace.0.with=Reemplazar ''{0}()'' con ''+\=''
replace.0.with.1=Reemplazar ''{0}'' con ''{1}''
replace.0.with.1.and.vice.versa=Reemplazar ''{0}'' con ''{1}'' y viceversa
replace.and.with.when.guard=Reemplazar '\\&\\&' con 'if'
replace.annotation=Reemplazar anotación
replace.annotation.with.0=Reemplazar anotación con {0}
replace.array.of.boxed.with.array.of.primitive=Reemplazar array de boxed con array de primitivas
replace.assert.boolean.with.assert.equality=Reemplazar aserción booleana con aserción de igualdad
replace.assert.with.operator=Reemplazar aserción con operador
replace.assignment.with.if.expression=Reemplazar asignación con expresión 'if'
replace.assignment.with.when.expression=Reemplazar asignación con expresión 'when'
replace.by.0=Reemplazar por ''{0}''
replace.by.reconstructed.type=Reemplazar por tipo reconstruido
replace.call.with.unary.operator=Reemplazar llamada con operador unario
replace.cast.with.call.to.to.0=Reemplazar cast con llamada a ''to{0}()''
replace.cast.with.primitive.conversion.method=Reemplazar cast con método de conversión primitiva
replace.collection.count.with.size.quick.fix.text=Reemplazar 'count' con 'size'
replace.contains.call.with.in.operator=Reemplazar llamada 'contains' con operador 'in'
replace.deprecated.symbol.usage=Reemplazar uso de símbolo obsoleto
replace.deprecated.symbol.usage.in.whole.project=Reemplazar uso de símbolo obsoleto en todo el proyecto
replace.diagnostic.name.fix.family.name=Reemplazar nombre de diagnóstico
replace.diagnostic.name.fix.text={0} con {1}
replace.elvis.expression.with.if.expression=Reemplazar expresión elvis con expresión 'if'
replace.explicit.lambda.parameter.with.it=Reemplazar parámetro lambda explícito con 'it'
replace.explicit.parameter.0.with.it=Reemplazar parámetro explícito ''{0}'' con ''it''
replace.expression.with.if.expression=Reemplazar expresión '\!\!' con expresión 'if'
replace.function.call.with.if=Reemplazar llamada a función con 'if'
replace.function.call.with.the.opposite=Reemplazar llamada a función con su opuesta
replace.function.call.with.when=Reemplazar llamada a función con 'when'
replace.get.or.set.call.with.indexing.operator=Reemplazar llamada get o set con operador de indexación
replace.guard.clause.with.kotlin.s.function.call=Reemplazar cláusula guard con llamada a función de Kotlin
replace.if.expression.with.elvis.expression=Reemplazar expresión 'if' con expresión elvis
replace.if.expression.with.return=Reemplazar expresión 'if' con return
replace.if.expression.with.safe.access.expression=Reemplazar expresión 'if' con expresión de acceso seguro
replace.if.expression.with.safe.cast.expression=Reemplazar expresión 'if' con expresión de cast seguro
replace.if.with.elvis.operator=Reemplazar 'if' con operador elvis
replace.if.with.when=Reemplazar 'if' con 'when'
replace.index.loop.with.collection.loop.quick.fix.text=Reemplazar con bucle sobre elementos
replace.infix.call.with.ordinary.call=Reemplazar llamada infix con llamada ordinaria
replace.int.range.end.inclusive.with.last.quick.fix.text=Reemplazar 'endInclusive' con 'last'
replace.int.range.start.with.first.quick.fix.text=Reemplazar 'start' con 'first'
replace.invalid.positioned.arguments.for.annotation=Reemplazar argumentos posicionales inválidos para anotación
replace.invoke.with.direct.call=Reemplazar 'invoke' con llamada directa
replace.it.with.explicit.parameter=Reemplazar 'it' con parámetro explícito
replace.jvmfield.with.const=Reemplazar '@JvmField' con 'const'
replace.kotlin.options.with.compiler.options=Reemplazar 'kotlinOptions' con 'compilerOptions'
replace.manual.range.with.indices.call.quick.fix.text=Reemplazar con indices
replace.modifier=Reemplazar modificador
replace.negated.0.operation.with.1=Reemplazar operación ''{0}'' negada con ''{1}''
replace.negated.0.operation.with.1.may.change.semantics.with.floating.point.types=Reemplazar operación ''{0}'' negada con ''{1}'' (puede cambiar la semántica con tipos de punto flotante)
replace.negated.0.with.1=Reemplazar ''{0}'' negado con ''{1}''
replace.overloaded.operator.with.function.call=Reemplazar operador sobrecargado con llamada a función
replace.property.initializer.with.if.expression=Reemplazar inicializador de propiedad con expresión 'if'
replace.property.initializer.with.when.expression=Reemplazar inicializador de propiedad con expresión 'when'
replace.return.with.if.expression=Reemplazar return con expresión 'if'
replace.return.with.when.expression=Reemplazar return con expresión 'when'
replace.safe.access.expression.with.if.expression=Reemplazar expresión de acceso seguro con expresión 'if'
replace.scope.function.with.safe.call=Reemplazar función de alcance con llamada segura (?.)
replace.size.check.with.0=Reemplazar comprobación de tamaño con ''{0}''
replace.size.check.with.isnotempty=Reemplazar comprobación de tamaño con 'isNotEmpty'
replace.size.zero.check.with.isempty=Reemplazar comprobación de tamaño cero con 'isEmpty'
replace.substring.call.with.droplast.call=Reemplazar llamada 'substring' con llamada 'dropLast'
replace.substring.call.with.indexing.operation.call=Reemplazar llamada 'substring' con llamada de operación de indexación
replace.substring.call.with.substringafter.call=Reemplazar llamada 'substring' con llamada 'substringAfter'
replace.substring.call.with.substringbefore.call=Reemplazar llamada 'substring' con llamada 'substringBefore'
replace.substring.call.with.take.call=Reemplazar llamada 'substring' con llamada 'take'
replace.to.with.infix.form.quickfix.text=Reemplazar 'to' con forma infix
replace.tostring.with.string.template=Reemplazar 'toString' con template de string
replace.total.order.equality.with.ieee.754.equality=Reemplazar igualdad de orden total con igualdad IEEE 754
replace.usages.of.0.in.whole.project=Reemplazar usos de ''{0}'' en todo el proyecto
replace.when.with.if=Reemplazar 'when' con 'if'
replace.with.0=Reemplazar con ''{0}''
replace.with.0.1.2=Reemplazar con {0}[{1}] ?\: {2}
replace.with.0.call=Reemplazar con llamada ''{0}()''
replace.with.0.operator=Reemplazar con operador ''{0}''
replace.with.a.for.loop=Reemplazar con bucle 'for'
replace.with.a.foreach.function.call=Reemplazar con llamada a función ''{0}''
replace.with.array.call=Reemplazar con llamada de array
replace.with.array.literal.fix.family.name=Reemplazar con [...]
replace.with.arrayof=Reemplazar con 'arrayOf'
replace.with.assignment.fix.text=Reemplazar con asignación (el original está vacío)
replace.with.binary.operator=Reemplazar con operador binario
replace.with.block.comment=Reemplazar con comentario de bloque
replace.with.contentequals=Reemplazar '\!\=' con 'contentEquals'
replace.with.contentequals2=Reemplazar '\=\=' con 'contentEquals'
replace.with.contentequals3=Reemplazar con 'contentEquals'
replace.with.dollar.literals=Reemplazar dólares escapados con literales
replace.with.dot.call=Reemplazar con llamada de punto
replace.with.elvis.error.fix.text=Reemplazar con '?\: error("")'
replace.with.elvis.return.fix.text=Reemplazar con ''?\: return{0}''
replace.with.end.of.line.comment=Reemplazar con comentario de fin de línea
replace.with.enum.map.fix.text=Reemplazar con 'EnumMap'
replace.with.equality.check.fix.text=Reemplazar con comprobación de igualdad
replace.with.equality.fix.text=Reemplazar ''{0}'' con ''{1}''
replace.with.error=Reemplazar con '?\: error(...)'
replace.with.explicit.type=Reemplazar '_' con tipo explícito
replace.with.field.fix.text=Reemplazar con 'field'
replace.with.filter.fix.text=Reemplazar con filter
replace.with.generated.publishedapi.bridge.call.0=Reemplazar con llamada puente @PublishedApi generada ''{0}''
replace.with.get.or.else.fix.text=Reemplazar con llamada 'getOrElse'
replace.with.get.value.call.fix.text=Reemplazar con llamada 'getValue'
replace.with.if.fix.text=Reemplazar con comprobación de tipo 'if'
replace.with.import.alias=Reemplazar con alias de importación
replace.with.in.when=Reemplazar ',' con '||' en when
replace.with.indexing.and.elvis.operator=Reemplazar con indexación y operador elvis
replace.with.infix.function.call=Reemplazar con llamada a función infix
replace.with.kotlin.analog.function.family.name=Reemplazar con análogo de Kotlin
replace.with.kotlin.analog.function.text=Reemplazar con función ''{0}''
replace.with.kotlin.s.foreach=Reemplazar con forEach de Kotlin
replace.with.kotlin.s.function.call=Reemplazar con llamada a función de Kotlin
replace.with.label.0.at=Reemplazar con etiqueta {0}@
replace.with.list.generator.fix.text=Reemplazar con generador de List
replace.with.operator.assignment=Reemplazar con asignación de operador
replace.with.ordinary.assignment=Reemplazar con asignación ordinaria
replace.with.parameter.name=Reemplazar '_' con nombre de parámetro
replace.with.publishedapi.bridge.call=Reemplazar con llamada puente @PublishedApi
replace.with.rangeUntil.quick.fix.text=Reemplazar con '..<'
replace.with.repeat.fix.family.name=Reemplazar con 'repeat()'
replace.with.return=Reemplazar '\!\!' con '?\: return'
replace.with.safe.call=Reemplazar con llamada segura (?.)
replace.with.safe.this.call=Reemplazar con llamada segura (this?.)
replace.with.std.lib.fix.text=Reemplazar con {0}.{1}
replace.with.stdlib.operations=Reemplazar con operaciones stdlib
replace.with.stdlib.operations.with.use.of.assequence=Reemplazar con operaciones stdlib usando 'asSequence()'
replace.with.string.literal.fix.family.name=Reemplazar con templates de string
replace.with.underscore=Reemplazar tipo explícito con '_'
replace.with.until.quick.fix.text=Reemplazar con 'until'
replace.with1=Reemplazar con '+\='
replace.||.with.&&=Reemplazar '||' con '\\&\\&'
replaceable.with.enummap=Puede reemplazarse con 'EnumMap'
replaceable.with.operator.assignment=Reemplazable con asignación de operador
report.also.for.a.variables.without.a.whitespace.around=Reportar también para variables sin espacios alrededor
report.also.on.call.with.single.boolean.literal.argument=Reportar también en llamada con un único argumento literal booleano
report.also.on.statement=Reportar también en statement
report.for.types.with.platform.arguments=Reportar para tipos con argumentos de plataforma
reports.only.function.calls.from.kotlinx.coroutines=Reportar solo llamadas a funciones de 'kotlinx.coroutines'
reset.files=Restablecer archivos…
resolve.pasted.references=resolver referencias pegadas
result.of.0.call.is.not.thrown=El resultado de la llamada ''{0}'' no se lanza
retargeting.usages.progress=Redirigiendo usos
rethrow.stored.pce.as.a.new.runtime.exception=Relanzar PCE almacenado como nueva excepción de runtime
return.type=Tipo de retorno(&R)\:
return.type.is.invalid=El tipo de retorno no es válido
return.when='return when'
revert.applied.imports.command=Revertir importaciones aplicadas
roots.description.text.update.source.roots.for.non.jvm.modules.in.kotlin.project=Actualizar raíces de origen para módulos no JVM en proyecto Kotlin
round.using.0=Redondear usando {0}()
safe.delete.constructor=Eliminar constructor de forma segura
saving.files=Guardando archivos…
scanning.files.0.fo.1.file.2.occurrences.found=Escaneando archivos\: {0} de {1} archivo. {2} ocurrencias encontradas
script.action.text.ignore=Ignorar
script.action.text.open.settings=Abrir Configuración
script.action.text.show.all=Mostrar todo
script.name.kotlin.scripting=Scripts de Kotlin
script.text.multiple.script.definitions.are.applicable.for.this.script=Múltiples definiciones de script son aplicables para este script. Se usa {0}
sealed.sub.class.has.no.state.and.no.overridden.equals=La subclase 'sealed' no tiene estado ni 'equals()' sobrescrito
search.for.not.property.candidates=Buscar candidatos que no son propiedades
search.for.text.occurrences=Buscar ocurrencias de texto(&T)
search.in.comments.and.strings=Buscar en comentarios y strings(&C)
searching.0=Buscando {0}…
searching.for.0=Buscando {0}
searching.for.imports.to.delete.title=Buscando importaciones para eliminar
searching.for.not.property.candidates=Buscando candidatos que no son propiedades
searching.for.overriding.methods=Buscando métodos que sobrescriben
searching.inheritors=Buscando herederos…
searching.usages.of.0.parameter=Buscando usos del parámetro ''{0}''
select.lambda.to.label=Seleccionar lambda para etiquetar
select.loop.statement.to.label=Seleccionar sentencia de bucle para etiquetar
select.target.code.block.file=Seleccionar bloque de código / archivo destino
select.target.file=Seleccionar archivo destino
selected.code.fragment.has.multiple.exit.points=El fragmento de código seleccionado tiene múltiples puntos de salida
selected.code.fragment.has.multiple.output.values=El fragmento de código seleccionado tiene más de 3 valores de salida\:
selected.code.fragment.has.output.values.and.exit.points=El fragmento de código seleccionado tiene valores de salida y puntos de salida alternativos
setter.of.0.will.become.invisible.after.extraction=El setter de {0} se volverá invisible después de la extracción
shortening.usages.progress=Acortando usos
should.be.replaced.with.if.type.check=Debe reemplazarse con comprobación de tipo 'if'
should.be.replaced.with.indexing=Debe reemplazarse con indexación
should.be.replaced.with.kotlin.function=Debe reemplazarse con función Kotlin
should.be.replaced.with.list.generator=Debe reemplazarse con generador de List
should.not.contain.lowercase.letter=no debe contener letras minúsculas
should.not.contain.underscores=no debe contener guiones bajos
should.not.contain.underscores.in.the.middle.or.the.end=no debe contener guiones bajos en el medio o al final
should.not.contain.underscores.with.camel.case=no debe contener guiones bajos cuando se usa camelCase
should.not.start.with.an.underscore=no debe comenzar con guion bajo
should.not.start.with.an.uppercase.letter=no debe comenzar con letra mayúscula
should.start.with.a.lowercase.letter=debe comenzar con letra minúscula
should.start.with.an.uppercase.letter=debe comenzar con letra mayúscula
signature.preview=Vista previa de firma
simplify.0.to.1=Simplificar ''{0}'' a ''{1}''
simplify.boolean.expression=Simplificar expresión booleana
simplify.call.chain.fix.text=Fusionar cadena de llamadas a ''{0}''
simplify.call.fix.text=Convertir llamada ''{0}'' a ''{1}''
simplify.comparison=Simplificar comparación
simplify.fix.text=Simplificar expresión
simplify.foldable.if.then=Simplificar if-then plegable
simplify.negated.operation=Simplificar operación negada
simplify.when.fix.text=Simplificar 'when'
since.kotlin.1.3.main.parameter.is.not.necessary=Desde Kotlin 1.3 el parámetro main no es necesario
slicer.text.in=en
slicer.text.tracking.enclosing.lambda=\ (Rastreando lambda envolvente)
slicer.text.tracking.lambda.argument=\ (Rastreando parámetro lambda)
slicer.text.tracking.lambda.calls=\ (Rastreando llamadas lambda)
slicer.text.tracking.lambda.receiver=\ (Rastreando receptor lambda)
slicer.title.dataflow.from.here=Flujo de datos desde aquí
slicer.title.dataflow.to.here=Flujo de datos hacia aquí
slicer.tool.tip.text.variable.dereferenced=Variable desreferenciada
some.types.are.not.accessible.from.0.1=Algunos tipos no son accesibles desde {0}\:\n{1}
sort.modifiers=Ordenar modificadores
specify.all.remaining.arguments.by.name=Especificar todos los argumentos restantes por nombre
specify.all.types.explicitly.in.destructuring.declaration=Especificar todos los tipos explícitamente en declaración de desestructuración
specify.explicit.lambda.signature=Especificar firma lambda explícita
specify.override.explicitly=Especificar override explícitamente
specify.override.for.0.explicitly=Especificar override para ''{0}'' explícitamente
specify.remaining.required.arguments.by.name=Especificar argumentos requeridos restantes por nombre
specify.return.type.explicitly=Especificar tipo de retorno explícitamente
specify.super.type=Especificar tipo superior ''{0}'' explícitamente
specify.type.explicitly=Especificar tipo explícitamente
split.if.into.two=Dividir 'if' en dos
split.property.declaration=Dividir declaración de propiedad
spring.secured.urls.inlay.hints=Kotlin\: Mostrar sugerencias integradas para URLs seguras de Spring
ssr.modifier.match.call.semantically=Coincidir llamada semánticamente
ssr.modifier.match.companion.object=Coincidir objeto companion
ssr.modifier.match.val=Coincidir val
ssr.modifier.match.var=Coincidir var
start.import.button.text.add=Agregar
start.import.button.text.remove=Eliminar
statement=Sentencia
status=(estado)
status.text.no.definitions=Sin definiciones
step.1.collecting.0.1.2=Paso 1\: Recopilando {0}\:{1}\:{2}
step.2.0.of.1=Paso 2\: {0} de {1}
step.3.0.of.1=Paso 3\: {0} de {1}
surround.with.0=Envolver con {0}(...)
surround.with.array.of=Envolver con arrayOf(...)
surround.with.lambda=Envolver con lambda
surround.with.null.check=Rodear con comprobación de null
surround.with.star.0=Rodear con *{0}(...)
suspicious.asdynamic.member.invocation=Invocación sospechosa de miembro 'asDynamic'
suspicious.callable.reference.as.the.only.lambda.element=Referencia callable sospechosa como único elemento lambda
suspicious.combination.of.and=Combinación sospechosa de \=\= y \=\=\=
suspicious.var.property.its.setter.does.not.influence.its.getter.result=Propiedad 'var' sospechosa\: su setter no influye en el resultado de su getter
test.function=Función de test
test.integration.button.text.cancel=Cancelar
test.integration.button.text.rewrite=Reescribir
test.integration.message.text.create.test.in.the.same.source.root=¿Crear test en la misma raíz de origen?
test.integration.message.text.kotlin.class=La clase Kotlin ''{0}'' ya existe. ¿Desea actualizarla?
test.integration.title.no.test.roots.found=No se encontraron raíces de test
test.result.log.file.will.be.placed.here=El archivo de registro de resultados de test se colocará aquí
text.0.1.must.be.moved.with.sealed.parent.class.and.all.its.subclasses={0} ''{1}'' debe moverse con la clase padre sealed y todas sus subclases
text.0.already.contains.1={0} ya contiene {1}
text.0.already.contains.nested.class.1={0} ya contiene una clase anidada llamada {1}
text.0.already.declared.in.1={0} ya está declarado en {1}
text.0.have.no.inheritors.warning={0} no tiene herederos\nBajar los miembros resultará en su eliminación. ¿Desea continuar?
text.0.in.1.will.override.corresponding.member.of.2.after.refactoring={0} en {1} sobrescribirá el miembro correspondiente de {2} después del refactoring
text.0.inherits.from.1.it.will.not.be.affected.by.refactoring={0} hereda de {1}.\nNo se verá afectado por el refactoring
text.0.is.invalid.destination.package=''{0}'' es un nombre de paquete de destino inválido
text.0.is.not.allowed.in.the.target.context=''{0}'' no está permitido en el contexto de destino
text.0.is.not.valid.package.name={0} no es un nombre de paquete válido
text.0.to.inline={0} para hacer inline
text.0.uses.1.which.is.not.accessible.from.2={0} usa {1}, que no es accesible desde {2}
text.0.uses.1.which.will.be.inaccessible.after.move={0} usa {1} que será inaccesible después de mover
text.0.uses.1.which.will.not.be.accessible.from.subclass={0} usa {1} que no será accesible desde la subclase.
text.0.uses.internal.1.which.will.be.inaccessible.after.move={0} usa internal {1} que será inaccesible después de mover
text.0.will.be.shadowed.by.1={0} será ocultado por {1}
text.0.will.clash.with.existing.1.in.2={0} después de renombrar entrará en conflicto con {1} existente en {2}
text.0.will.no.longer.be.accessible.after.signature.change={0} ya no será accesible después del cambio de firma
text.Assignment=Asignación
text.Function=Función
text.Name=Nombre
text.Package=Paquete
text.Property=Propiedad
text.Return=Retorno
text.abstract=abstracto
text.actual.moved.to.common.modules.target=La declaración actual ''{0}'' se moverá a un módulo común.
text.add.getter=Agregar getter
text.add.getter.and.setter=Agregar getter y setter
text.add.setter=Agregar setter
text.add.use.site.target.0=Agregar objetivo de sitio de uso ''{0}''
text.all.declarations.must.belong.to.the.same.directory.or.class=Todas las declaraciones deben pertenecer al mismo directorio o clase
text.annotation=anotación
text.annotation.class=clase de anotación
text.anonymous=[Anónimo]
text.anonymous.function=función anónima
text.at.least.one.file.must.be.selected=Debe seleccionar al menos un miembro
text.callee.text.would.be.shown.here=El texto del callee se mostraría aquí
text.caller.text.with.highlighted.callee.call.would.be.shown.here=El texto del caller\ncon la llamada al callee resaltada se mostraría aquí
text.can=puede
text.cannot.create.target.directory.0=No se puede crear el directorio de destino {0}
text.cannot.determine.source.directory=No se puede determinar el directorio de fuentes
text.cannot.find.package.corresponding.to.0=No se pudo encontrar el paquete correspondiente a {0}
text.cannot.find.target.package.name=No se puede encontrar el nombre del paquete de destino
text.cannot.inline.reference.from.0.to.1=No se puede hacer inline la referencia de {0} a {1}
text.cannot.move.expect.actual.declaration.to.file=No se pudo mover la declaración expect/actual al archivo
text.cannot.move.for.current.project=No se puede mover para el proyecto actual
text.cannot.move.inner.class.0.into.itself=No se puede mover la clase anidada {0} a sí misma
text.cannot.move.to.original.file=No se puede mover al archivo original
text.change.file.package.to.0=Cambiar el paquete del archivo a ''{0}''
text.choose.containing.file=Elegir archivo contenedor
text.class=clase
text.class.0={0,choice,1\#clase|2\#clases}
text.class.0.already.contains.member.1={0} ya contiene {1}
text.class.0.already.exists.in.package.1=La clase {0} ya existe en el paquete {1}
text.class.0.already.exists.in.the.target.scope=La clase {0} ya existe en el ámbito de destino
text.class.0.is.final={0} es final
text.constructor=constructor
text.convert._it_.to.explicit.lambda.parameter=Convertir 'it' a parámetro lambda explícito
text.create=Crear
text.create.destructuring.declaration=Crear declaración de desestructuración
text.create.single.variable=Crear variable única
text.declaration=declaración
text.declarations.clash.move.0.destination.1.declared.in.scope.2=Las siguientes declaraciones entrarían en conflicto\: mover {0} y destino {1} declarado en el ámbito {2}
text.default.value=\ // valor por defecto \= {0}
text.destination.class.should.be.kotlin.class=La clase de destino debe ser una clase Kotlin
text.do.you.want.to.rename.0.as.well=¿Desea renombrar también {0}()?
text.do.you.want.to.rename.base.property=¿Desea renombrar la propiedad base?
text.do.you.want.to.rename.base.property.from.0=¿Desea renombrar la propiedad base desde \n{0}
text.done=Hecho
text.duplicating.local.variable=Duplicando variable local ''{0}''
text.duplicating.parameter=Duplicando parámetro ''{0}''
text.duplicating.property=Duplicando propiedad ''{0}''
text.enum=enum
text.enum.class=clase enum
text.enum.constant=constante enum
text.expected.moved.to.platform.modules.target=La declaración expected ''{0}'' se moverá a un módulo de plataforma.
text.explicit.receiver.is.already.present.in.call.element.0=El receptor explícito ya está presente en el elemento de llamada\: {0}
text.extend=extender
text.extension=extensión
text.extension.function=función de extensión
text.extension.function.0={0,choice,1\#función|2\#funciones} de extensión
text.extension.property=propiedad de extensión
text.extension.property.0={0,choice,1\#propiedad|2\#propiedades} de extensión
text.extract.superclass=Extraer superclase
text.file.0.already.exists.in.1=El archivo {0} ya existe en {1}
text.file.name.cannot.be.empty=El nombre del archivo no puede estar vacío
text.first.definition.that.matches.script.pattern.extension.applied.starting.from.top=Se aplica la primera definición que coincida con el patrón/extensión del script, comenzando desde arriba
text.function=función
text.function.0={0,choice,1\#función|2\#funciones}
text.function.already.exists=La función ya existe\: ''{0}''
text.function.in.ticks.0=función ''{0}''
text.getter=getter
text.implement=implementar
text.implements=implementa
text.implicit.companion.object.will.be.inaccessible.0=El objeto companion implícito será inaccesible\: {0}
text.incorrect.target.path.directory.0.does.not.belong.to.current.project=Ruta de destino incorrecta. El directorio {0} no pertenece al proyecto actual.
text.indirect.outer.instances.will.not.be.extracted.0=Las instancias externas indirectas no serán extraídas\: {0}
text.initializer=inicializador
text.inline.0=Inline {0}
text.inline.all.references.and.verb.0.the.kind.1.occurrences.2=Inline todas las referencias y {0} el {1} {2}
text.inline.function.not.supported=La función inline aún no está soportada
text.inline.recursive.function.is.supported.only.on.references=La función recursiva inline solo está soportada en referencias
text.inline.this.reference.and.keep.the.0=Inline esta referencia y mantener el {0}
text.inlined.0.overrides.0.1=El {0} inline sobreescribe {0} {1}
text.inlining.0.1=Haciendo inline {0} {1}
text.inner.class.0.cannot.be.moved.to.interface={0} es una clase interna. No se puede mover a la interfaz
text.interface=interfaz
text.introduce.default.value=Intro&ducir valor por defecto
text.invalid.target.path.0=Ruta de destino inválida {0}
text.invalid.target.specified=Destino especificado inválido
text.keep=mantener
text.lambda.parameter=parámetro lambda
text.lambda.parameters=Parámetros &lambda\:
text.lambda.return.type=&Tipo de retorno lambda
text.lazy.property=propiedad lazy
text.local.property=propiedad
text.local.variable=variable local
text.looking.for.usages=Buscando usos
text.member=miembro
text.member.0.in.super.class.will.clash.with.existing.member.of.1={0} en la superclase entrará en conflicto con el miembro existente de {1}
text.member.extension.call.will.not.be.processed.0=La llamada de extensión del miembro no será procesada\: {0}
text.move.declaration.no.support.for.companion.objects=Mover declaración no está soportado para objetos companion
text.move.declaration.no.support.for.enums=Mover declaración no está soportado para entradas enum
text.move.declaration.no.support.for.multi.file=No está soportado mover declaraciones desde diferentes archivos
text.move.declaration.no.support.for.nested.declarations=Mover declaración no está soportado para declaraciones anidadas
text.move.declaration.proceed.move.without.mpp.counterparts.text=Esta refactorización moverá la declaración seleccionada sin sus contrapartes expect/actual que pueden causar errores de compilación.\n¿Desea continuar?
text.move.declaration.proceed.move.without.mpp.counterparts.title=No se puede realizar la refactorización. Las declaraciones MPP no están soportadas por esta refactorización.
text.move.declaration.supports.only.top.levels.and.nested.classes=Mover declaración solo está soportado para declaraciones de nivel superior y clases anidadas
text.move.declarations=Mover declaraciones
text.move.file.0=Mover {0}
text.move.file.no.support.for.file.target=Mover archivos no está soportado para destinos que no son directorios
text.move.method.is.not.supported.for.generic.classes=Mover método no está soportado para clases genéricas
text.move.method.is.not.supported.for.non.project.methods=Mover método no está soportado para métodos fuera del proyecto
text.move.method.is.not.supported.when.method.is.a.part.of.inheritance.hierarchy=Mover método no está soportado cuando el método es parte de una jerarquía de herencia
text.move.refactoring.not.available.during.indexing=La refactorización de mover no está disponible mientras la indexación está en progreso
text.moving.multiple.nested.classes.to.top.level.not.supported=No está soportado mover múltiples clases anidadas al nivel superior
text.name=nombre
text.nested.classes.to.upper.level=Clases anidadas al nivel superior
text.no.destination.object.specified=No se especificó objeto de destino
text.no.elements.to.move.are.selected=No hay elementos seleccionados para mover
text.no.files.to.move=No hay archivos para mover
text.no.name.provided.for.type.alias=No se proporcionó nombre para el alias de tipo
text.no.package.corresponds.to.directory=Ningún paquete corresponde a este directorio
text.non.kotlin.0.will.not.be.affected.by.refactoring=Los {0} no Kotlin no serán afectados por la refactorización
text.object=objeto
text.object.0={0,choice,1\#objeto|2\#objetos}
text.operator.0={0,choice,1\#operador|2\#operadores}
text.overload=Sobrecarga
text.overrides=sobreescribe
text.package.directive.dont.match.file.location=La directiva de paquete no coincide con la ubicación del archivo
text.parameter=Parámetro
text.parameter.0=parámetro ''{0}''
text.parameter.name=&Nombre del parámetro\:
text.parameter.reference.can.t.be.safely.replaced.with.0.since.1.is.ambiguous.in.this.context=La referencia del parámetro no puede reemplazarse de forma segura con {0} ya que {1} es ambiguo en este contexto
text.parameter.reference.can.t.be.safely.replaced.with.0.since.target.function.can.t.be.referenced.in.this.context=La referencia del parámetro no puede reemplazarse de forma segura con {0} ya que la función objetivo no puede ser referenciada en este contexto
text.parameter.type=&Tipo del parámetro\:
text.parameters=&Parámetros
text.part=parte
text.pattern=Patrón\:
text.primary=primario
text.primary.constructor=constructor primario
text.proceed.with.extraction=Continuar con la extracción de todos modos
text.process.duplicates=Procesar duplicados
text.processing.file.0=Procesando {0}
text.property=propiedad
text.property.0={0,choice,1\#propiedad|2\#propiedades}
text.property.in.ticks.0=propiedad ''{0}''
text.property.with.getter=propiedad con getter
text.property.with.initializer=propiedad con inicializador
text.pushed.member.will.not.be.available.in.0=El miembro enviado no estará disponible en ''{0}''
text.qualified.call.will.not.be.processed.0=La llamada calificada no será procesada\: {0}
text.receiver=receptor
text.receiver.can.t.be.safely.transformed.to.value.argument=El receptor no puede transformarse de forma segura en argumento de valor\: {0}
text.refactoring.can.t.be.performed.on.the.selected.code.element=La refactorización no puede realizarse en el elemento de código seleccionado
text.refactoring.is.not.applicable.to.this.code.fragment=La refactorización no es aplicable a este fragmento de código
text.reference.cannot.be.converted.to.a.lambda=La referencia no puede convertirse a lambda
text.references.in.code.to.0.1.and.its.declarations=Referencias en el código a {0} {1} y sus declaraciones
text.references.to.outer.classes.have.to.be.added.manually=Las referencias a clases externas deberán agregarse manualmente después de mover
text.remove=eliminar
text.remove.0.no.longer.used=Eliminar {0} que ya no se usa
text.remove.question=Eliminar '?'
text.rename.as.part.of.phrase=renombrar
text.rename.is.not.applicable.to.compiler.plugin.generated.declarations=Renombrar no es aplicable a declaraciones generadas por plugins del compilador
text.rename.is.not.applicable.to.secondary.constructors=Renombrar no es aplicable a constructores secundarios
text.rename.is.not.applicable.to.synthetic.declarations=Renombrar no es aplicable a declaración sintética
text.rename.not.applicable.to.backing.field.reference=Renombrar no es aplicable a referencia de campo de respaldo
text.rename.not.applicable.to.dynamically.invoked.methods=Renombrar no es aplicable a miembros invocados dinámicamente
text.rename.overloads.title=Renombrar sobrecargas
text.rename.parameters.title=Renombrar parámetros
text.return=return
text.sealed.broken.hierarchy.none.in.target=La jerarquía sealed de ''{0}'' se dividiría. Ninguno de sus miembros reside en el paquete ''{1}'' del módulo ''{2}''\: {3}.
text.sealed.broken.hierarchy.still.in.source=La jerarquía sealed de ''{0}'' se dividiría. El paquete ''{1}'' del módulo ''{2}'' aún contendría sus miembros\: {3}.
text.sealed.class.0.must.be.moved.with.all.its.subclasses=La clase sealed ''{0}'' debe moverse con todas sus subclases
text.secondary=secundario
text.secondary.constructor=constructor secundario
text.select.target.code.block=Seleccionar bloque de código destino
text.select.target.code.block.file=Seleccionar bloque de código / archivo destino
text.select.target.file=Seleccionar archivo destino
text.setter=setter
text.should=debería
text.there.is.already.a.parameter=Ya existe un parámetro ''{0}'' en {1}. Entrará en conflicto con el nuevo parámetro.
text.there.is.already.a.variable.0.in.1.it.will.conflict.with.the.new.parameter=Ya existe una variable ''{0}'' en {1}. Entrará en conflicto con el nuevo parámetro.
text.type=Tipo
text.type.alias=alias de tipo
text.type.alias.0={0,choice,1\#alias|2\#aliases} de tipo
text.type.alias.cannot.refer.to.types.which.aren.t.accessible.in.the.scope.where.it.s.defined=El alias de tipo no puede hacer referencia a tipos que no son accesibles en el ámbito donde está definido
text.type.alias.name.must.be.a.valid.identifier.0=El nombre del alias de tipo debe ser un identificador válido\: {0}
text.type.already.exists.in.the.target.scope=El tipo {0} ya existe en el ámbito destino
text.type.parameter={0, choice, 0\#parámetro|2\#parámetros} de tipo
text.type.parameter.names.must.be.distinct=Los nombres de parámetros de tipo deben ser distintos
text.type.parameters=&Parámetros de tipo
text.unexpected.element.type.0=Tipo de elemento inesperado\: {0}
text.update.usages.to.reflect.declaration.0.move=Actualizar usos para reflejar el movimiento de {0, choice, 0\#declaración|1\#declaraciones}
text.updating.usages.progress=Actualizando usos…
the.anonymous.object=el objeto anónimo
the.declaration.has.0.modifier=La declaración tiene el modificador ''{0}''
the.function.declaration.shouldn.t.have.a.default.implementation=La declaración de función no debería tener una implementación por defecto
there.are.possible.side.effects.found.in.expressions.assigned.to.the.variable.0=Se encontraron posibles efectos secundarios en las expresiones asignadas a la variable ''{0}''<br>Puede\:<br>-\\&nbsp;<b>Eliminar</b> la asignación completa, o<br>-\\&nbsp;<b>Transformar</b> el lado derecho de la asignación en su propia declaración.<br>
there.is.own.replacewith.on.0.that.is.used.through.this.alias.please.replace.usages.first=Hay un ''ReplaceWith'' propio en ''{0}'' que se usa a través de este alias. Por favor, reemplace los usos primero.
these.declarations.cannot.be.transformed=Estas declaraciones no se pueden transformar\:
this.call.is.useless.with=Esta llamada es inútil con ?.
this.property.conflicts.with.synthetic.extension.and.should.be.removed.or.renamed.to.avoid.breaking.code.by.future.changes.in.the.compiler=La propiedad entra en conflicto con una extensión sintética y debe eliminarse o renombrarse para evitar que las futuras versiones del compilador de Kotlin rompan el código
this.range.is.empty=Este rango está vacío.
this.range.is.empty.did.you.mean.to.use.0=Este rango está vacío. ¿Quiso usar ''{0}''?
this.type.probably.can.be.changed.to.nullable=Este tipo probablemente puede cambiarse a nullable
this.when.is.simplifiable=Este 'when' es simplificable
throwable.instance.0.is.not.thrown=La instancia Throwable ''{0}'' no se lanza
titile.not.found=No encontrado
title.choose.destination.object=Elegir objeto destino
title.choose.logger.factory.class=Elegir clase de fábrica del logger
title.choose.use.site.target=Elegir Use-Site Target
title.done=Hecho
title.error=Error
title.import.layout=Diseño de importación
title.inline.function=Función inline
title.inline.property=Propiedad inline
title.inline.type.alias=Alias de tipo inline
title.introduce.parameter.to.declaration=Introducir parámetro en la declaración
title.kdoc.for.abstracts=KDoc para Abstracts
title.lateinit.var.overrides.lateinit.var='lateinit var' sobrescribe super 'lateinit var'
title.logger.factory.class.name=Nombre de la clase de fábrica del logger
title.logger.factory.method.name=Nombre del método de fábrica del logger
title.move.method=Mover método
title.move.nested.classes.to.upper.level=Mover clases anidadas al nivel superior
title.packages.to.use.import.with=Paquetes para usar import con '*'
title.parameters=Parámetros
title.rename.file=Renombrar archivo
title.rename.file.to=Renombrar archivo a\:
title.rename.overloads.to=Renombrar sobrecargas a\:
title.rename.warning=Advertencia de renombrado
title.select.a.name.for.this.parameter=Seleccionar un nombre para el parámetro ''this@{0}''
title.select.target.code.block=Seleccionar bloque de código destino
title.success=Éxito
to.fully.qualified.name=A (nombre completamente calificado)\:
tooltip.implements.function=Implementa función en
tooltip.implements.property=Implementa propiedad en
tooltip.is.implemented.by=Es implementado por
tooltip.is.subclassed.by=Es subclase de
tooltip.overrides.function=Sobrescribe función en
tooltip.overrides.property=Sobrescribe propiedad en\:
top.level=Nivel superior
two.comparisons.should.be.converted.to.a.range.check=Dos comparaciones deberían convertirse en una comprobación de rango
type.0.1.is.not.accessible.from.target.module={0, choice, 0\#Tipo|2\#Tipos} {1} no es accesible desde el módulo destino
type.alias.0=Alias de tipo "{0}"
type.arguments.will.be.lost.after.conversion.0=Los argumentos de tipo se perderán después de la conversión\: {0}
type.parameter.0=Parámetro de tipo "{0}"
type.parameter.can.have.0.variance=El parámetro de tipo puede tener varianza ''{0}''
type.provider.anonymous.object=objeto anónimo
type.provider.no.expression.found=No se encontró expresión
type.provider.smart.cast.from=(smart cast desde {0})
type.provider.unknown.type=Tipo desconocido
unclear.precedence.of.binary.expression.inspection=La expresión debería usar paréntesis aclaratorios
unclear.precedence.of.binary.expression.inspection.display.name=Múltiples operadores con diferente precedencia
unclear.precedence.of.binary.expression.quickfix=Agregar paréntesis aclaratorios
unclear.precedence.of.binary.expression.report.even.obvious.cases.checkbox=Reportar incluso casos obvios
unknown.types.title=Tipos Desconocidos
unlabeled.return.inside.lambda=Return sin etiqueta dentro de lambda
unrecognized.reference.will.be.skipped.0=Se omitirá la referencia no reconocida\: {0}
unsupported.usage.0=Uso no soportado\: {0}
until.can.be.replaced.with.rangeUntil.operator='until' puede reemplazarse con el operador '..<'
unused.equals.expression=Expresión equals sin usar
unused.import.directive=Directiva import sin usar
unused.return.value.of.a.function.with.lambda.expression.body=Valor de retorno sin usar de una función con cuerpo de expresión lambda
unused.unary.operator=Operador unario sin usar
unwrap.else=Desenvolver else en ''{0}''
unwrap.expression=Desenvolver ''{0}''
unwrap.parameter=Desenvolver ''{0}'' arg ''{1}''
update.indices=Actualizar índices…
update.obsolete.label.syntax=Actualizar sintaxis obsoleta de etiqueta
usage.of.kotlin.internal.declaration.from.different.module=Uso de declaración interna de Kotlin desde un módulo diferente
usage.of.redundant.or.deprecated.syntax.or.deprecated.symbols=Uso de sintaxis redundante o obsoleta o símbolos obsoletos
usage.provider.text.property.of.0={0} de {1}
usage.provider.text.unnamed=<sin nombre>
usages.of.outer.class.instance.inside.of.property.0.won.t.be.processed=No se procesarán los usos de la instancia de clase externa dentro de la propiedad ''{0}''
use.destructuring.declaration=Usar declaración de desestructuración
use.expression.body.instead.of.0=Usar cuerpo de expresión en lugar de {0}
use.inherited.visibility=Usar visibilidad heredada
use.of.getter.method.instead.of.property.access.syntax=Uso de método getter en lugar de sintaxis de acceso a propiedad
use.of.non.const.kotlin.property.as.java.constant.is.incorrect.will.be.forbidden.in.1.4=El uso de una propiedad Kotlin no constante como constante Java es incorrecto. Será prohibido en 1.4
use.of.setter.method.instead.of.property.access.syntax=Uso de método setter en lugar de sintaxis de acceso a propiedad
use.property.access.syntax=Usar sintaxis de acceso a propiedad
use.property.access.syntax.option.report.non.trivial.accessors=Reportar accessors no triviales
use.withindex.instead.of.manual.index.increment=Usar withIndex() en lugar de incremento manual de índice
useless.call.on.collection.type=Llamada inútil en tipo de colección
useless.call.on.not.null.type=Llamada inútil en tipo no nulo
uses.of.should.be.replaced.with.logging=Los usos de <code>{0}</code> probablemente deberían reemplazarse con logging más robusto
variable.0.is.assigned.to.itself=La variable ''{0}'' está asignada a sí misma
variable.declaration.could.be.inlined=La declaración de variable podría ser inlined
variable.declaration.could.be.moved.into.when=La declaración de variable podría moverse dentro del 'when'
variable.is.never.modified.and.can.be.declared.immutable.using.val=La variable nunca se modifica, por lo que puede declararse usando 'val'
variable.is.same.as.0.and.should.be.inlined=La variable es igual a ''{0}'' y puede ser inlined
variable.name.0.matches.the.name.of.a.different.component=El nombre de variable ''{0}'' coincide con el nombre de un componente diferente
variable.used.only.in.following.return.and.should.be.inlined=Variable usada solo en el siguiente return y puede ser inlined
vcs.code.author=Kotlin\: Mostrar hints integrados con el autor del código
version={version}
visibility=&Visibilidad\:(&V)
when.has.only.else.branch.and.should.be.simplified='when' solo tiene rama 'else' y debería simplificarse
when.with.subject.should.be.used=Se debe usar 'when' con sujeto
wrap.argument.with.parentheses=Envolver argumento con paréntesis
wrap.element.with.0.call=Envolver elemento con llamada ''{0}()''
wrap.expression.in.parentheses=Envolver expresión en paréntesis
wrap.run.fix.text=Convertir a run { ... }
wrap.unary.operator.quickfix.text=Envolver operador unario y valor con ()
wrap.with=Envolver con []
wrap.with.array.literal=Envolver con literal de array
wrap.with.collection.literal.call=Envolver con llamada literal de colección
wrap.with.coroutine.scope.fix.family.name=Envolver con coroutineScope
wrap.with.coroutine.scope.fix.text=Envolver cuerpo de función con 'coroutineScope { ... }'
wrap.with.coroutine.scope.fix.text2=Envolver llamada con 'coroutineScope { ... }'
wrap.with.coroutine.scope.fix.text3=Eliminar receptor y envolver con 'coroutineScope { ... }'
wrap.with.let.call=Envolver con llamada '?.let { ... }'