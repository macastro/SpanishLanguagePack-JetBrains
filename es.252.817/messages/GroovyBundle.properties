0.expressions.on.trait.fields.properties.are.not.supported.in.traits=Las expresiones en los campos/propiedades de los rasgos no se admiten en los rasgos
0.is.deprecated=''{0}'' está en desuso
Cannot.perform.undo.operation=No se puede deshacer la operación
Constructor=Constructor
Equals=igual
Getter=Getter
Inner.methods.are.not.supported=no se admiten los métodos internos
Setter=Setter
Undo.disable=Deshacer desactivado
abstract.methods.must.not.have.body=Los métodos abstractos no deben tener cuerpo
abstract.visibility.presentation=abstracto
action.ConvertGroovyToJava.description=Convierte el archivo Groovy a Java
action.ConvertGroovyToJava.text=Convertir a Java
action.ConvertToCompileStatic.description=Convertir el archivo Groovy en @CompileStatic
action.ConvertToCompileStatic.text=@CompileStatic
action.DumpGroovyControlFlowAction.text=Descargar Control de Flujo Groovy
action.ExcludeFromStubGeneration.description=No generar stubs Java para este fichero Groovy a compilar
action.ExcludeFromStubGeneration.text=Excluir de la generación de stub
action.Gant.NewScript.description=Nuevo script Gant
action.Gant.NewScript.text=Nuevo Script Gant
action.Groovy.CheckResources.Make.description=Ejecutar el compilador incremental para todos los archivos Groovy en la raíz de los recursos, para verificar problemas de compilación
action.Groovy.CheckResources.Make.text=Construir recursos(_B)
action.Groovy.CheckResources.Rebuild.description=Ejecutar compilador para todos los archivos Groovy en la raíz de recursos, para comprobar problemas de compilación
action.Groovy.CheckResources.Rebuild.text=Reconstruir recursos(_R)
action.Groovy.Console.description=Iniciar consola Groovy
action.Groovy.Console.text=Consola Groovy
action.Groovy.NewClass.description=Crea nueva clase Groovy
action.Groovy.NewClass.text=Clase Groovy
action.Groovy.NewScript.description=Crea nuevo script de Groovy
action.Groovy.NewScript.text=Nuevo script Groovy
action.build.module.restart.description=Compilar módulo ''{0}'' y reiniciar
action.build.restart.text=Construir y reiniciar
action.collapse.all.description=Contraer todo
action.collapse.all.text=Contraer todo
action.convert.lambda.to.closure=Convertir lambda a clausura
action.expand.all.description=Expandir todo
action.expand.all.text=Expandir todo
action.org.jetbrains.plugins.groovy.actions.generate.accessors.GroovyGenerateGetterAction.description=Generar getter
action.org.jetbrains.plugins.groovy.actions.generate.accessors.GroovyGenerateGetterAction.text=Getter
action.org.jetbrains.plugins.groovy.actions.generate.accessors.GroovyGenerateGetterSetterAction.description=Generar getter
action.org.jetbrains.plugins.groovy.actions.generate.accessors.GroovyGenerateGetterSetterAction.text=getter y setter
action.org.jetbrains.plugins.groovy.actions.generate.accessors.GroovyGenerateSetterAction.description=Generar setter
action.org.jetbrains.plugins.groovy.actions.generate.accessors.GroovyGenerateSetterAction.text=Setter
action.org.jetbrains.plugins.groovy.actions.generate.constructors.GroovyGenerateConstructorAction.description=Generar constructor
action.org.jetbrains.plugins.groovy.actions.generate.constructors.GroovyGenerateConstructorAction.text=Constructor
action.org.jetbrains.plugins.groovy.actions.generate.equals.GroovyGenerateEqualsAction.description=Ahora la acción genera equals y hashCode
action.org.jetbrains.plugins.groovy.actions.generate.equals.GroovyGenerateEqualsAction.text=equals() y hashCode()
action.org.jetbrains.plugins.groovy.actions.generate.missing.GroovyGenerateMethodMissingAction.description=Acción generar propertyMissing()
action.org.jetbrains.plugins.groovy.actions.generate.missing.GroovyGenerateMethodMissingAction.text=methodMissing()
action.org.jetbrains.plugins.groovy.actions.generate.missing.GroovyGeneratePropertyMissingAction.description=Acción generar propertyMissing()
action.org.jetbrains.plugins.groovy.actions.generate.missing.GroovyGeneratePropertyMissingAction.text=propertyMissing()
action.org.jetbrains.plugins.groovy.actions.generate.tostring.GroovyGenerateToStringAction.description=Genera el método toString()
action.org.jetbrains.plugins.groovy.actions.generate.tostring.GroovyGenerateToStringAction.text=toString()
action.remove.dynamic.member.description=Eliminar miembro dinámico
action.remove.dynamic.member.text=Quitar
add.class.to.extends.family.name=Implementa
add.compilestatic=Agregar @CompileStatic
add.dynamic.element=Agregar elemento dinámico
add.dynamic.method=agregar método dinámico
add.dynamic.method.0=Agregar método dinámico ''{0}''
add.dynamic.property=agregar.propiedad.dinamica ''{0}''
add.method=agregar.método=Agregar un método ''{0}()'' a la clase ''{1}''
add.method.family=añadir.familia.metodo
add.modifier.sealed=Agregar modificador 'sealed'
add.parenthesis.to.lambda.parameter.list=añadir paréntesis a la lista de parámetro lambda
add.return.type=Agregar tipo de retorno
add.return.type.to.method.declaration=Agrega el tipo de retorno a la declaración del método
add.to.resources=Agregar a recursos
add.type.customizer.to.resources=Agregar personalizador de tipo a los recursos
ambiguous.code.block=Bloque de código ambiguo
annotation.collector.cannot.have.attributes=El tipo de anotación con anotación @AnnotationCollector no puede tener atributos
annotation.field.can.only.be.used.within.a.script=La anotación @Field solo se puede usar dentro de un script
annotation.field.can.only.be.used.within.a.script.body=La anotación @Field sólo puede ser utilizada dentro del cuerpo de un script
annotation.field.should.have.type.declaration=El campo en la anotación debe tener una declaración de tipo
annotation.type.cannot.be.inner=Tipo de anotación no puede ser interno
annotation.types.may.not.have.extends.clause=Los tipos de anotación no pueden tener una cláusula 'extends'
annotation.types.may.not.have.implements.clause=no se permite una cláusula 'implements' en tipos de anotación
anonymous.class=clase anónima
anonymous.class.cannot.have.abstract.method=Una clase anónima no puede tener un método abstracto
anonymous.class.derived.from.0=Clase anónima derivada de {0}
anonymous.classes.cannot.be.created.from.traits=clases anónimas no pueden ser creadas en rasgos
are.you.sure.to.delete.dynamic.property=¿Está seguro de que desea eliminar {0}?
are.you.sure.to.delete.elements=¿Seguro que quieres borrar {0} elementos ?
at.interface.0.does.not.contain.attribute=La interfaz @interface ''{0}'' no contiene el atributo ''{1}''
attribute.descriptor.abstract.class=clase abstracta
attribute.descriptor.annotation.attribute.name=Nombre del atributo de anotación
attribute.descriptor.annotation.name=Nombre de anotación
attribute.descriptor.annotations=Anotaciones
attribute.descriptor.anonymous.class=clase anónima
attribute.descriptor.bad.character=Carácter incorrecto
attribute.descriptor.block.comment=Comentario de bloque
attribute.descriptor.braces=corchetes
attribute.descriptor.braces.and.operators=Llaves y operadores
attribute.descriptor.brackets=corchetes
attribute.descriptor.class=clase
attribute.descriptor.classes.and.interfaces=Clases e interfaces
attribute.descriptor.closure.expression.braces.and.arrow=Llaves y flecha de expresión de cierre
attribute.descriptor.comments=Comentarios
attribute.descriptor.constructor.call=Llamada al constructor
attribute.descriptor.constructor.declaration=Declaración del constructor
attribute.descriptor.enum=enum
attribute.descriptor.fields=campos
attribute.descriptor.groovydoc=Groovydoc
attribute.descriptor.groovydoc.tag=etiqueta
attribute.descriptor.groovydoc.text=Texto
attribute.descriptor.gstring=GString
attribute.descriptor.instance.field=campo de instancia
attribute.descriptor.instance.method.call=Llamada de método de instancia
attribute.descriptor.instance.property.reference=Referencia de propiedad de instancia
attribute.descriptor.interface=interfaz
attribute.descriptor.invalid.string.escape=Escape de cadena inválido
attribute.descriptor.keyword=palabra clave
attribute.descriptor.label=etiqueta
attribute.descriptor.lambda.expression.braces.and.arrow=Llaves y flecha de la expresión lambda
attribute.descriptor.line.comment=Comentario de línea
attribute.descriptor.list.map.to.object.conversion=conversión de lista/mapa a objeto
attribute.descriptor.local.variable=Variable local
attribute.descriptor.map.key.named.argument=Clave de mapa/Argumento con nombre
attribute.descriptor.method.declaration=Declaración de método
attribute.descriptor.methods=métodos
attribute.descriptor.number=Número
attribute.descriptor.operator.sign=signo del operador
attribute.descriptor.parameter=parámetro
attribute.descriptor.parentheses=paréntesis
attribute.descriptor.reassigned.local.variable=Variable local reasignada
attribute.descriptor.reassigned.parameter=parámetro reasignado
attribute.descriptor.references=referencias
attribute.descriptor.static.field=campo estático
attribute.descriptor.static.method.call=Llamada a método estático
attribute.descriptor.static.property.reference=Referencia de propiedad estática
attribute.descriptor.string=cadena
attribute.descriptor.strings=cadenas
attribute.descriptor.trait=Característica
attribute.descriptor.type.parameter=Parámetro de tipo
attribute.descriptor.unresolved.reference=referencia no resuelta
attribute.descriptor.valid.string.escape=escape de cadena válida
attribute.descriptor.variables.and.parameters=Variables y parámetros
attribute.name.expected=Debe ser el nombre de un atributo
base.script.annotation.is.allowed.only.inside.scripts=La anotación @BaseScript solo se puede utilizar dentro de los scripts
break.outside.loop=Las sentencias break con una etiqueta con nombre solo se permiten dentro de un bucle
break.outside.loop.or.switch=La sentencia 'break' solo se puede usar dentro de un bucle o un 'switch' de estilo dos puntos
builder.annotation.not.support.super.for.simple.strategy=El atributo 'includeSuperProperties' de la anotación no es compatible con groovy.transform.builder.SimpleStrategy
call.can.throw.npe=La cadena de llamada puede mostrar NullPointerException
call.without.parentheses.are.supported.since.groovy.3=Las llamadas sin paréntesis son compatibles desde Groovy 3
cannot.access=Acceso a ''{0}'' excede sus derechos de acceso
cannot.apply.constructor=Constructor ''{0}'' en ''{1}'' no se puede aplicar a ''{2}''
cannot.apply.default.constructor=no se puede aplicar el constructor por defecto a la clase ''{0}''
cannot.apply.method.or.closure=''{0}'' no se puede aplicar a ''{1}''
cannot.apply.method1=''{1}'' de ''{0}'' no se puede aplicar a ''{2}''
cannot.assign=No se puede asignar ''{0}'' a ''{1}''
cannot.assign.a.value.to.final.field.0=No se puede asignar un valor al campo finals ''{0}''
cannot.assign.a.value.to.final.parameter.0=No se puede asignar un valor al parámetro final ''{0}''
cannot.assign.string.to.enum.0=No se puede asignar una cadena a la enumeración "{0}"
cannot.cast=no se puede castear ''{0}'' a ''{1}''
cannot.create.class=No se puede crear clase
cannot.create.class.error.text=No se puede crear la clase ''{0}'': {1}
cannot.create.class.error.title=Imposible crear clase
cannot.find.enum.constant.0.in.enum.1=no se puede encontrar la constante de enumeración "{0}" en la enumeración "{1}"
cannot.infer.argument.types=no se pueden inferir los tipos de argumentos
cannot.instantiate.abstract.class=no se puede instanciar la clase abstracta ''{0}''
cannot.instantiate.interface=No se puede instanciar interfaz ''{0}''
cannot.reference.non.static=no se puede referenciar un símbolo no estático ''{0}'' desde un contexto estático
cannot.resolve=no se puede resolver el símbolo ''{0}''
cannot.return.from.constructor=No se puede regresar desde el constructor
cannot.return.from.void.method=No se puede regresar desde un método vacío
cannot.return.type=No se puede devolver ''{0}'' desde el método que devuelve ''{1}''
catch.statement.parameter.type.should.be.a.subclass.of.throwable=el parámetro de la sentencia catch debería ser una subclase de Throwable
change.base.method.label=Cambiar método base
change.implements.and.extends.classes=Estandarizar lista de extends e implements
change.lvalue.type=cambiar variable ''{0}'' tipo a ''{1}''
change.modifier=Hacer que ''{0}'' sea {1}
change.modifier.family.name=Cambiar modificador
change.modifier.not=Establecer ''{0}'' no como {1}
change.signature.default.initializer.column=Columna de inicializador predeterminado
change.signature.type.column=Tipo
change.usages.label=Cambio de usos
checkbox.delegate.via.overloading.method=Delegar mediante método sobrecargado
checkbox.ignore.conditional.operators=Ignorar operadores condicionales
checkbox.ignore.double.checked.locking.on.volatile.fields=Ignorar el bloqueo de doble verificación sobre los campos volatile
checkbox.ignore.obscure.operators=Ignorar operadores oscuros
checkbox.inspect.anonymous.closures=Inspeccionar cierres anónimos
checkbox.inspect.gradle.files=Inspeccionar Gradle archivos
checkbox.only.warn.if.loop.empty=Advertencia solo si el bucle está vacío
checkbox.report.unmatched.null=informar de 'null' no coincidentes
class.definition.is.not.expected.here=La definición de clase no se espera aquí
class.is.not.annotation=''{0}'' no es una anotación
closure=clausura
closure.is.accessed.outside.of.groovy=La clausura <b>{0}</b> se accede desde fuera de Groovy
closure.is.too.complex.to.analyze=Cierre es demasiado complejo de analizar.\nNo se puede inferir el tipo de variable local.
closure.used.as.variable=La clausura se usó como variable, la refactorización puede alterar la semántica.
code.style.groovydoc.enable=Habilitar formato GroovyDoc
code.style.groovydoc.tab.name=Groovydoc
code.style.group.list.map.literals=Literales de lista o mapa
code.style.option.after.assert.separator=Separador después de 'assert'
code.style.option.align.multiline.named.arguments=Alinear argumentos nombrados multi-línea
code.style.option.align.when.multiple=Alinear cuando son múltiples
code.style.option.before.assert.separator=Separador antes de 'assert'
code.style.option.before.record.parameter.list=anteslistaparamregistro
code.style.option.closure.left.brace.in.method.calls=Llave de inicio en llamada de método
code.style.option.gstring.injection.braces=Llaves de inyección GString
code.style.option.import.annotations=Importar anotaciones
code.style.option.in.named.argument.after.colon=En argumento nombrado después de ':'
code.style.option.in.named.argument.before.colon=En argumento con nombre antes de ':'
code.style.option.list.maps.literals=Literales de mapa y lista
code.style.option.regexp.expression=Expresión regexp (==~, =~)
code.style.option.relational.operators=Operadores relacionales (<, >, <=, >=, <>)
code.style.option.simple.lambdas.closures.in.one.line=Lambda/cierre simple en una línea
code.style.option.tuple.assignment.expression=expresión de asignación de tupla
code.style.option.unary.operators=Operadores unarios (!, -, +, ++, --, *)
code.style.option.use.flying.geese.braces=Usar llaves en forma de V
code.style.option.wrap.after.dot=Ajustar después del punto
collection.literal.contains.named.argument.and.expression.items=El literal de colección contiene argumentos con nombre y elementos de expresión
command.name.add.dynamic.member=Agregar miembro dinámico
comments.count.as.content=Los comentarios cuentan como contenido
configurable.GantConfigurable.display.name=Gant
configurable.GroovyCompilerConfigurable.display.name=Groovy Compilador
configurable.greclipse.border.title=Opciones Groovy-Eclipse
configurable.greclipse.command.java.agent.class.workaround='-javaAgentClass' previene el uso de opciones de MV predefinidas
configurable.greclipse.command.line.params.label=Parámetros de línea de comandos:
configurable.greclipse.debug.checkbox=Generar información de depuración
configurable.greclipse.path.chooser.description=Seleccione la ruta a groovy-eclipse-batch-*.jar que corresponda con la versión de su distribución Groovy
configurable.greclipse.path.label=Ruta del jar de groovy-eclipse-batch:
configurable.greclipse.vm.options.comment=Sobrescribe las opciones de VM del proceso de compilación compartido y local del usuario, si se especifica
configurable.greclipse.vm.options.label=Opciones VM:
configurable.hotswap.checkbox=Habilitar agente de intercambio por motivos técnicos para el código Groovy
configurable.hotswap.checkbox.description=Puede producir problemas de serialización en la aplicación siendo depurada
configure.groovy.library=Configurar Groovy SDK...
constructor.cannot.have.static.modifier=El constructor no puede tener modificador estático
constructors.are.not.allowed.in.anonymous.class=Los constructores no están permitidos en clases anónimas
constructors.are.not.allowed.in.interface=Los constructores no están permitidos en la interfaz
constructors.cannot.have.return.type=Los constructores no pueden tener un tipo de elemento de valor devuelto
continue.outside.loop=La instrucción continue solo se permite dentro de un bucle
conversion.closure.not.allowed.in.non.groovy.files=La refactorización no está permitida para cierres con ocurrencias en archivos no Groovy:
conversion.method.not.allowed.in.non.groovy.files=La conversión no está permitida en archivos que no sean de Groovy en métodos que tengan coincidencias
convert.cannot.itself=La reestructuración no se puede aplicar al propio parámetro de mapa
convert.param.to.map.entry=Convertir parámetro a entrada de mapa
convert.parameter.to.map.entry.title=convertir la parámetro en una entrada de mapa
create.annotation.text=Crear anotación ''{0}''
create.class.family.name=Crear clase
create.class.text=Crear clase ''{0}''
create.directory.command=Crear directorio
create.enum=crear enumeración ''{0}''
create.field.from.usage=Crear Campo ''{0}''
create.field.from.usage.family.name=Crear campo desde el uso
create.instance.of.built-in.type=Crear instancia de tipo nativo
create.interface.text=Crear interfaz ''{0}''
create.method.from.usage=Crear método ''{0}''
create.method.from.usage.family.name=Crear método a partir del uso
create.parameter.from.usage=Crear parámetro formal ''{0}''
create.parameter.from.usage.family.name=Crear parámetro desde el uso
create.record.text=Crear registro ''{0}''
create.trait=Crear función ''{0}''
create.variable.from.usage=Crear variable ''{0}''
create.variable.from.usage.family.name=Crear variable desde el uso
cyclic.inheritance.involving.0=Herencia cíclica involucrando ''{0}''
debug.option=Habilitar &seguimiento de pila de depuración
declare.explicit.implementations.of.trait=declarar implementaciones explícitas de trait
declared.type.0.extends.1.which.is.circular.inheritance=El tipo declarado "{0}" se extiende a "{1}", que es una herencia circular
declared.type.0.have.to.extend.script=El tipo declarado ''{0}'' debe extender la clase ''groovy.lang.Script''
def.visibility.presentation=def
default.initializers.are.not.allowed.in.abstract.method=Los inicializadores por defecto no están permitidos en métodos abstractos
default.modifier.in.old.versions=Modificador 'default' disponible en Groovy 3.0 o versiones superiores
delegate.annotation.is.only.for.methods.without.arguments=Anotación @Delegate sólo aplica a métodos sin argumentos
destination.package=Paquete destino:
dialog.create.class.package.chooser.title=Seleccionar paquete de destino
dialog.message.gant.not.configured=Gant no configurado
dialog.title.no.jdk.specified.error=Sin JDK especifico
dialog.title.no.jdk.specified.prompt=¿Quieres crear un proyecto sin asignar el SDK?
dialog.title.no.jdk.specified.title=No se especificó ningún SDK de Groovy
dialog.title.refactoring.unavailable.in.current.scope=Refactorización no disponible en el ámbito actual
dialog.title.select.groovy.sdk=Selecciona SDK de Groovy
dialog.title.specify.groovy.sdk=Especificar directorio raíz del SDK de Groovy
dialog.title.validation.directory.you.specified.does.not.contain.groovy.sdk.do.you.want.to.create.project.with.this.configuration=El directorio especificado no contiene Groovy SDK. ¿Quieres crear un proyecto con esta configuración?
dialog.title.validation.invalid.sdk.specified.error=SDK de Groovy especificado no válido
dialog.title.validation.invalid.sdk.specified.title=SDK Groovy especificado inválido
dialog.title.validation.path.does.not.contain.groovy.sdk=La ruta no contiene el SDK de Groovy
dialog.title.validation.path.should.not.be.empty=La ruta no puede estar vacía
do.you.want.to.change.method.return.type=¿Quieres cambiar el tipo de retorno del método ''{0}''?
do.you.want.to.change.type.of.parameter.in.method=¿Desea cambiar el tipo del parámetro ''{0}'' en el método ''{1}''?
do.you.want.to.change.variable.type=¿Quieres modificar el tipo de ''{0}''?
doc.end.expected='*/' esperado
documentation.cannot.infer.type.label=No se puede inferir el tipo
documentation.gdk.label=GDK
documentation.inferred.type.label=Tipo inferido
duplicate.attribute=atributo duplicado
duplicate.class=La clase ''{0}'' ya existe en ''{1}''
duplicate.element.in.the.map=Elemento duplicado en el map ''{0}''
duplicate.inner.class=Clase interna duplicada: ''{0}''
duplicate.modifier=Modificador duplicado ''{0}''
duplicated.named.parameter=Parámetro con nombre duplicado '{0}'
duplicating.named.parameter=El parámetro con nombre ''{0}'' aparece duplicado: {1}
dynamic.dialog.class.label=Clase:(&C)
dynamic.dialog.static.checkbox=estático(&S)
dynamic.dialog.type.label=Tipo:(&T)
dynamic.element=elemento dinámico
dynamic.element.deletion=Borrado de elemento dinámico
dynamic.members.column.name.element=Elemento dinámico
dynamic.members.column.name.type=Tipo
dynamic.method.property.type=Tipo de Propiedad:(&T)
dynamic.method.return.type=Tipo de retorno:(&T)
dynamic.name=nombre
dynamic.properties.table.name=Argumentos de función
dynamic.property.deletion=Eliminación de propiedad dinámica
dynamic.tool.window.id=Ventana dinámica
dynamic.type=tipo
ellipsis.type.is.not.allowed.here=El tipo ellipsis no está permitido aquí
enums.may.not.have.extends.clause=Los enumerados no pueden tener cláusula 'extends'
equals.between.inconvertible.types.tooltip=<code>{0}</code> está entre objetos con tipos ''{1}'' y ''{2}'' inconvertibles
exception.0.has.already.been.caught=La excepción ''{0}'' ya fue capturada
expected.0.to.be.inline.constant=''Se esperaba que ''{0}'' fuera una constante en línea
expected.type.0=se esperaba ''{0}'', pero se encontró ''{1}''
explicit.constructors.are.not.allowed.in.immutable.class=Los constructores explícitos no están permitidos en clases inmutables
explicit.includes.and.excludes=Debes proporcionar solo 'includes' o 'excludes'
expression.expected=Expresión esperada
expression.type.no.expression=Expresión no encontrada
expression.type.unknown=<desconocido>
extract.closure.command.name=Extraer clausura
field.already.defined=El campo ''{0}'' ya está definido
field.already.exists=El campo <b>{0}</b> ya existe
field.is.used.in.argument.label=El campo <b>{0}</b> se utiliza en la etiqueta del argumento
field.should.be.immutable=campo ''{0}'' debe ser de tipo inmutable o debe declararse usando @ImmutableOptions
file.exists=El archivo ''{0}'' ya existe en el directorio ''{1}''
file.template.group.title.groovy=Groovy
filetype.dgm.description=Archivo descriptor de Groovy Extension Module
filetype.dgm.display.name=DGM
filetype.gdsl.description=Configuración de IntelliJ para Groovy DSL
filetype.gdsl.display.name=Groovy DSL
filetype.logback.description=Configuración DSL de Logback Groovy
filetype.logback.display.name=DSL Groovy de Logback
final.class.cannot.be.extended=No se puede extender la clase final
final.visibility.presentation=final
find.method.ro.closure.usages=Buscando usos de la closure exterior en los archivos del proyecto
find.method.ro.method.usages=Buscando usos del método envolvente en los archivos del proyecto
find.usages.method.0.of.class.1={0} de {1}
fix.class=Arreglar clase {0}
fix.package.name=Corregir nombre de paquete
framework.0.home.label={0} Inicio:
framework.0.library=librería {0}
framework.0.library.version.1=Biblioteca {0} versión {1}
framework.0.sdk.chooser.description=Seleccione directorio conteniendo la distribución {0}
framework.0.sdk.chooser.error.message=La distribución de {0} en la ruta especificada parece estar dañada. No es posible determinar la versión.
framework.0.sdk.chooser.error.title=Error al crear la biblioteca
framework.0.sdk.chooser.title=Título del selector de SDK
framework.gant=obj
gdsl.error.notification.title=Error en la ejecución del script DSL
gdsl.investigate.link.label=Clic aquí para realizar la encuesta
generate.equals.and.hashcode.already.defined.title=equals() y hashCode() ya definidos
generate.equals.and.hashcode.already.defined.warning=equals() y hashCode() ya están definidos
generate.equals.and.hashcode.already.defined.warning.anonymous=equals() y hashCode() ya están definidos
generate.equals.compare.arrays.comment=// Posiblemente incorrecto - utilizar Arrays.equals para comparar arreglos Object[]
generate.equals.compare.nested.arrays.comment=// Comparar arreglos anidados - Se mostrará valor de {0} aquí
generate.method.missing.already.defined.title=methodMissing() ya está definido
generate.method.missing.already.defined.warning=methodMissing() ya está definido
generate.property.missing.already.defined.title=La propiedad que faltaba () ya está definida
generate.property.missing.already.defined.warning=propertyMissing() ya está definida
generated.stub.exclude.link.label=Excluir de la generación de stubs
generated.stub.message=El stub fue generado para la clase Groovy con el propósito de realizar una compilación cruzada Groovy-Java
generated.stub.navigate.link.label=Navegar a Groovy clase
getter.0.clashes.with.getter.1=Se ha producido un conflicto: ''{0}'' con ''{1}''
getter.kind.gdk.method.0=Método GDK {0}
getter.kind.getter.0=método get {0}
getter.kind.method.0=Método {0}
ginq.code.style.group.ginq.clauses=Cláusulas GINQ
ginq.code.style.option.indent.having.clauses=Sangría en cláusula 'having'
ginq.code.style.option.indent.on.clauses=Identar cláusula 'on'
ginq.code.style.option.space.after.keyword=Colocar espacio después de las palabras clave
ginq.code.style.option.wrap.having.clauses=Clausula 'having' de intercalación
ginq.code.style.option.wrap.on.clauses=Plega cláusula 'on'
ginq.error.message.0.must.be.after.1=''{0}'' debe estar después de ''{1}''
ginq.error.message.0.must.be.before.1=''{0}'' debe estar antes que ''{1}''
ginq.error.message.boolean.condition.expected=Se espera una condición booleana
ginq.error.message.container.expected=Se esperaba GINQ, Iterable, Stream o array
ginq.error.message.expected.a.boolean.expression=Se esperaba una expresión booleana
ginq.error.message.expected.alias=Se esperaba un nombre de alias
ginq.error.message.expected.data.source=Se esperaba una fuente de datos
ginq.error.message.expected.in.operator=se esperaba '... in ...'
ginq.error.message.expected.one.or.two.arguments.for.limit=Se esperaban uno o dos argumentos para 'limit'
ginq.error.message.from.must.be.in.the.start.of.a.query='from' debe estar en el inicio de una consulta
ginq.error.message.groupby.expected.a.list.of.expressions=Se requiere una lista de expresiones
ginq.error.message.on.is.expected.after.join="on" es esperado después de la cláusula tipo 'join'
ginq.error.message.on.should.not.be.provided.after.crossjoin=en 'crossjoin' no debería aparecer 'on'
ginq.error.message.orderby.expected.a.list.of.ordering.fields=El esperado es una lista de campos de ordenación
ginq.error.message.query.should.end.with.select=La consulta debe finalizar con 'select'
ginq.error.message.query.should.start.from.from=La consulta debería comenzar con 'from'
ginq.error.message.unrecognized.query=Consulta no reconocida
gr.package.inspection.check.scripts=Inspección de scripts
grab.error.0.title=No se puede ejecutar @Grab: {0}
grab.error.ivy.missing.message=Lo sentimos, IDEA no puede @Grab dependencias sin Apache Ivy. Agrega Apache Ivy a tus dependencias de módulos y vuelve a ejecutar esta acción.
grab.error.ivy.missing.title=Ivy faltante
grab.family.name=Agarrar
grab.intention.name=Capturar artefacto
grab.jar.count=<b>{0}</b>: {1} {1, choice, 0#jar|1#jar|2#jar}
grab.progress.title=Procesando anotación @Grab
grab.result.title=Se añadió {0} dependencias {0, choice, 0#Grape JAR|1#JAR de Grape|2#JAR de Grape}
groovy.complex.argument.label.annotator.message=Los argumentos para etiquetas complejas que preceden a los dos puntos deben estar entre paréntesis
groovy.complex.argument.label.quick.fix.message=Rodear la expresión con paréntesis
groovy.consoles.type=Consolas Groovy
groovy.debug.caption=Groo
groovy.debug.disable.specific.methods=No entrar a métodos específicos de Groovy(&I)
groovy.does.not.support.constructor.type.arguments=Groovy no soporta argumentos de tipo constructor
groovy.file.0=Archivo Groovy ''{0}''
groovy.file.extension.is.not.mapped.to.groovy.file.type=Los archivos *.groovy se han mapeado a ''{0}''.\nPuedes mapearlos a Groovy desde **Configuración | Tipos de archivo**
groovy.library.is.not.configured.for.module=SDK de Groovy no configurado para el módulo ''{0}''
groovy.library.label=Biblioteca Groovy
groovy.term.annotation=anotación
groovy.term.binding=Variable de enlace de script
groovy.term.class=clase
groovy.term.closure=Clausuras
groovy.term.enum=Enumeración
groovy.term.expression=expresión
groovy.term.field=campo
groovy.term.interface=interfaz
groovy.term.label=Etiqueta
groovy.term.method=método
groovy.term.parameter=Parámetro
groovy.term.property=propiedad
groovy.term.record=record
groovy.term.trait=rasgo
groovy.term.type.parameter=parámetro de tipo
groovy.term.variable=Variable local
groovy.version.0=Groovy {0}
groovy.version.bundled.0=Groovy {0} incluido
group.Groovy.CheckResources.description=Ejecuta el compilador para archivos Groovy en la ruta de recursos, para comprobar problemas de compilación
group.Groovy.CheckResources.text=Recursos Groovy(_O)
header.extract.closure=Extracción del cierre
highlight.if.groovy.object.methods.overridden=Resalta referencias de clases que sobreescriben invokeMethod(), getProperty() o setProperty()
highlight.if.missing.methods.declared=Resaltar referencias de la clase que declara missingMethod() o missingProperty()
identifier.expected=Identificador esperado
identifier.or.block.expected=Se esperaba un identificador o un bloque de código
ignore.boolean.expressions=ignorar variables sin asignar en expresiones booleanas
ignore.when.catch.parameter.is.named.ignore.or.ignored=ignorar cuando el parámetro de catch se llama ignore o ignored
illegal.combination.of.modifiers=Combinación ilegal de modificadores
illegal.combination.of.modifiers.abstract.and.final=Combinación ilegal de modificadores: abstract y final
illegal.combination.of.modifiers.volatile.and.final=La combinación de modificadores "volatile" y "final" es ilegal
illegal.default.modifier=El modificador 'default' sólo está permitido en métodos de interfaz
illegal.default.modifier.fix=quitar modificador 'predeterminado'
illegal.escape.character.in.string.literal=carácter de escape ilegal en el literal de la cadena
illegal.method.name=El nombre del método contiene caracteres ilegales: {0}
illegal.nonsealed.modifier.fix=Eliminar el modificador 'non-sealed'
illegal.sealed.modifier.fix=Quitar el modificador 'sealed'
illegal.single.argument.lambda=La forma de un único argumento lambda solo se puede utilizar como parte derecha de una expresión de asignación o como argumento dentro de una llamada al método
illegal.type.void=Tipo ilegal: 'void'
immutable.options.property.not.exist=La propiedad ''{0}'' no existe
implement.class=Implementar {0}
import.statement.cannot.have.modifiers=La declaración de importación no puede tener modificadores
incorrect.number.of.values=Número incorrecto de valores. Debería ser: {0}, pero es: {1}
incorrect.variable.name=nombre de variable incorrecto
indexed.property.is.applicable.to.properties.only=@IndexedProperty solo aplica a propiedades
infer.method.parameters.types=Agrega tipos explícitos a los parámetros
infer.method.parameters.types.for.method.declaration=Infiere tipos explícitos para todos los parámetros en la declaración del método
initializer.cannot.be.0=El inicializador no puede ser {0}
initializer.cannot.have.annotations=Los inicializadores no pueden tener anotaciones
initializers.are.forbidden.with.defaults=Se prohíben los valores predeterminados cuando está deshabilitado 'defaults' en @TupleConstructor
initializers.are.not.allowed.in.interface=Los inicializadores no están permitidos en la interfaz
injection.should.not.contain.line.feeds=La inyección GString no debe contener salto de línea
inspection.annotations=anotaciones
inspection.assignments=Cuestiones de asignaciones
inspection.bugs=Posible error
inspection.confusing=Estructura de código que puede generar confusión
inspection.control.flow=Problemas de flujo de control
inspection.data.flow=Flujo de datos
inspection.display.name.access.to.inaccessible.element=Elemento inaccesible
inspection.display.name.access.to.static.field.locked.on.instance=El acceso al campo estático bloqueado en datos de instancia es nulo
inspection.display.name.annotation.references.unknown.identifier=@TupleConstructor, @MapConstructor
inspection.display.name.assignability.check=Asignación tipo incompatible
inspection.display.name.assignment.can.be.operator.assignment=La asignación puede ser una asignación de operador
inspection.display.name.assignment.to.for.loop.parameter=Asignación a parámetro de bucle 'for'
inspection.display.name.assignment.to.method.parameter=Asignación a parámetro de método
inspection.display.name.break=sentencia 'break'
inspection.display.name.busy.wait=Espera activa
inspection.display.name.change.to.method=La llamada al operador se puede reemplazar por una llamada al método
inspection.display.name.change.to.operator=La llamada al método puede reemplazarse con una llamada al operador
inspection.display.name.check.labeled.statement=Inspección est. etiquetada
inspection.display.name.clashing.getters=getters en conflicto
inspection.display.name.clashing.trait.methods=Métodos de características en conflicto
inspection.display.name.class.naming.convention=Convención de nomenclatura de clase
inspection.display.name.conditional=Condicional
inspection.display.name.conditional.can.be.conditional.call=La expresión ternaria se puede reemplazar por una llamada segura
inspection.display.name.conditional.can.be.elvis=La expresión condicional puede ser Elvis
inspection.display.name.conditional.with.identical.branches=Expresión ternaria con ramas idénticas
inspection.display.name.constant.conditional=Expresión de condición constante
inspection.display.name.constant.if.statement=Instrucción if con constante
inspection.display.name.constant.naming.convention=Convención de nombres de constante
inspection.display.name.constructor.named.arguments=argumentos con nombre de la llamada al constructor
inspection.display.name.continue=sentencia null
inspection.display.name.continue.or.break.from.finally.block='continue' o 'break' de un bloque 'finally'
inspection.display.name.delegates.to=Delegantes a
inspection.display.name.deprecated.api.usage=Uso de API descontinuadas
inspection.display.name.divide.by.zero=División por cero
inspection.display.name.double.checked.locking=Bloqueo de doble comprobación
inspection.display.name.double.negation=Doble negación
inspection.display.name.duplicate.switch.branch=Case duplicados en el switch
inspection.display.name.empty.catch.block=Bloque 'catch' vacío
inspection.display.name.empty.finally.block=Bloque 'finally' vacío
inspection.display.name.empty.statement.body=Sentencia con cuerpo vacío
inspection.display.name.empty.sync.block=Bloque 'synchronized' vacío
inspection.display.name.empty.try.block=Bloque 'try' vacío
inspection.display.name.equals.between.inconvertible.types=igual() entre objetos de tipo no convertible
inspection.display.name.fallthrough=Fallthrough en instrucción 'switch'
inspection.display.name.final.variable.access=Acceso a variable final
inspection.display.name.groovydoc.check=Referencia de GroovyDoc no resuelta
inspection.display.name.gstring.key=Clave de mapeo de GString
inspection.display.name.if.statement.with.identical.branches=If con ramas idénticas
inspection.display.name.if.statement.with.too.many.branches=If con demasiadas ramas
inspection.display.name.implicit.null.argument=argumento nulo implícito
inspection.display.name.in.argument.check=Comprobador de tipo de parámetro 'in' incompatible
inspection.display.name.incorrect.range.argument=Argumento de rango incorrecto
inspection.display.name.infinite.loop.statement=Instrucción de bucle infinito
inspection.display.name.infinite.recursion=Recursividad infinita
inspection.display.name.instance.method.naming.convention=Convención de nombres de método de instancia
inspection.display.name.instance.variable.naming.convention=Convención de nomenclatura de variables de instancia
inspection.display.name.java.style.properties.invocation=Acceso a las propiedades estilo Java
inspection.display.name.list.get.can.be.keyed.access=Llamada a List.get puede ser de acceso con clave
inspection.display.name.list.set.can.be.keyed.access=La llamada a List.set puede tener acceso con clave
inspection.display.name.local.variable.naming.convention=Convención de nomenclatura de variables locales
inspection.display.name.loop.statement.that.doesnt.loop=Sentencia de bucle que no realiza bucles
inspection.display.name.map.get.can.be.keyed.access=La llamada a Map.get puede ser un acceso por clave
inspection.display.name.map.put.can.be.keyed.access=La llamada de Map.put puede ser acceso con clave
inspection.display.name.method.may.be.static=El método puede ser 'static'
inspection.display.name.method.parameter.count=Método con número excesivo de parámetros
inspection.display.name.method.with.more.than.three.negations=Método con más de 3 negaciones
inspection.display.name.multiple.return.points.per.method=Método con varios puntos de retorno
inspection.display.name.negated.conditional=Expresión de condición negada
inspection.display.name.negated.if=Expresión if negada
inspection.display.name.nested.assignment=Asignación anidada
inspection.display.name.nested.conditional=expresión condicional anidada
inspection.display.name.nested.switch=Sentencia switch anidada
inspection.display.name.nested.synchronized.statement=Sentencia 'synchronized' anidada
inspection.display.name.new.instance.of.singleton=Nueva instancia de una clase anotada con @groovy.lang.Singleton
inspection.display.name.no.return=Falta instrucción return
inspection.display.name.non.extending.permitted.subclasses=Subclases permitidas no extensibles
inspection.display.name.non.short.circuit.boolean=Booleano no cortocircuito
inspection.display.name.notify.while.not.synchronized=Usar 'notify()' o 'notifyAll()' no sincronizado
inspection.display.name.octal.integer=Entero octal
inspection.display.name.overly.complex.arithmetic.expression=Expresión aritmética demasiado compleja
inspection.display.name.overly.complex.boolean.expression=Expresión booleana demasiado compleja
inspection.display.name.overly.complex.method=método demasiado complejo
inspection.display.name.overly.long.method=Método muy largo
inspection.display.name.overly.nested.method=método excesivamente anidado
inspection.display.name.package.mismatch=Paquete no coincide
inspection.display.name.parameter.naming.convention=Convención de nombres de parámetros de método
inspection.display.name.pointless.arithmetic=Expresión aritmética sin sentido
inspection.display.name.pointless.boolean=Expresión booleana sin sentido
inspection.display.name.pojo.without.compile.static=@POJO sin @CompileStatic
inspection.display.name.public.field.accessed.in.synchronized.context=Campo publico accedido en contexto sincronizado
inspection.display.name.reassigned.in.closure.local.var=Variable local reasignada en una clase anónima o en un cierre
inspection.display.name.result.of.assignment.used=Resultado de la asignación usado pero no
inspection.display.name.result.of.increment.or.decrement.used=Resultado de incremento o decremento utilizado
inspection.display.name.result.of.object.allocation.ignored=El resultado de la asignación del objeto se ignora
inspection.display.name.return.from.closure.can.be.implicit=La instrucción 'return' puede ser implícita
inspection.display.name.return.from.finally.block='return' dentro del bloque 'finally'
inspection.display.name.second.unsafe.call=Segunda llamada insegura
inspection.display.name.silly.assignment=Asignación inútil
inspection.display.name.singleton.constructor=Constructor @Singleton
inspection.display.name.static.method.naming.convention=convención de nomenclatura de método estático
inspection.display.name.static.variable.naming.convention=Convención de nombres de variables estáticas
inspection.display.name.string.style.violation=Infracción en el estilo de las cadenas
inspection.display.name.switch.exhaustiveness.check=Análisis de exhaustividad de la expresión Switch
inspection.display.name.switch.statement.with.no.default=Sentencia switch sin case predeterminado
inspection.display.name.synchronization.on.non.final.field=Sincronización en campo no final
inspection.display.name.synchronization.on.this=Sincronización en 'this'
inspection.display.name.synchronization.on.variable.initialized.with.literal=Sincronización en variable inicializada con literal
inspection.display.name.synchronized.method=Método sincronizado
inspection.display.name.system.run.finalizers.on.exit=Llamada a System.runFinalizersOnExit()
inspection.display.name.thread.stop.suspend.resume=Llamada a Thread.stop(), Thread.suspend() o Thread.resume()
inspection.display.name.throw.from.finally.block='throw' dentro del bloque 'finally'
inspection.display.name.trivial.conditional=Expresión condicional trivial
inspection.display.name.trivial.if=Sentencia 'if' redundante
inspection.display.name.type.customizer=Inspección de personalizador de tipo
inspection.display.name.unassigned.access=Variable no asignada
inspection.display.name.unchecked.assignment.of.member.of.raw.type=Asignación sin verificar de miembro de tipo sin formato
inspection.display.name.unconditional.wait=Llamada incondicional de "wait"
inspection.display.name.unnecessary.alias=Alias de importación innecesario
inspection.display.name.unnecessary.continue=Sentencia 'continue' innecesaria
inspection.display.name.unnecessary.def.modifier=Modificador 'def' innecesario
inspection.display.name.unnecessary.final.modifier=Modificador final innecesario
inspection.display.name.unnecessary.non.sealed.modifier=modificador no sellado innecesario
inspection.display.name.unnecessary.public.modifier=Modificador "public" innecesario
inspection.display.name.unnecessary.qualified.reference=referencia calificada no es necesaria
inspection.display.name.unnecessary.return=Retorno innecesario
inspection.display.name.unnecessary.sealed.modifier=Modificador `sealed` innecesario
inspection.display.name.unnecessary.semicolon=Punto y coma innecesario
inspection.display.name.unreachable.statement=Sentencia inalcanzable
inspection.display.name.unresolved.access=Acceso no resuelto
inspection.display.name.unresolved.labels.in.named.variant=@NamedVariant/@NamedParam/@NamedDelegate Etiqueta no resuelta
inspection.display.name.unsynchronized.method.overrides.synchronized.method=Método no sincronizado sobrescribe método sincronizado
inspection.display.name.untyped.access=Acceso sin tipo
inspection.display.name.unused.assignment=asignación no utilizada
inspection.display.name.unused.catch.parameter=Parámetro sin usar en 'catch'
inspection.display.name.unused.declaration=Declaración no utilizada
inspection.display.name.unused.inc.dec=Incremento o decremento sin usar
inspection.display.name.variable.can.be.final=La variable puede ser `final`
inspection.display.name.wait.call.not.in.loop=wait() no en bucle
inspection.display.name.wait.while.not.synchronized=Esperar mientras no esté sincronizado
inspection.display.name.while.loop.spins.on.field=El bucle while gira en el campo
inspection.error.handling=manejo de errores
inspection.gpath=Expresión XPath
inspection.message.0.not.allowed.for.record=El registro no permite ''{0}''
inspection.message.access.to.static.field.locked.on.instance.data=Acceso al campo estático <code>#ref</code> bloqueado en los datos de instancia #loc
inspection.message.annotation.non.sealed.cannot.be.applied.to.enum.class=La anotación '@NonSealed' no se puede aplicar a una clase enumerada
inspection.message.annotation.sealed.cannot.be.applied.to.enum.class=La anotación '@Sealed' no se puede aplicar a una clase enum
inspection.message.arrows.in.case.expressions.are.available.with.groovy.4.or.later=Las flechas en las expresiones case están disponibles en Groovy 4.0 o superior
inspection.message.assignment.replaceable.with.operator.assignment=<code>#ref</code> se puede simplificar a ''{0}'' #loc
inspection.message.assignment.to.for.loop.parameter=Asignación a parámetro de bucle for '#ref' #loc
inspection.message.assignment.to.method.parameter=Se asigna a '#ref' un parámetro del método #loc
inspection.message.both.open.ranges.are.available.in.groovy.4.or.later=Los rangos abiertos en ambos extremos están disponibles en Groovy 4.0 o posterior
inspection.message.call.to.ref.can.be.keyed.access=La llamada a '#ref' puede ser acceso con clave #loc
inspection.message.call.to.ref.outside.of.loop=La llamada a '#ref' está fuera del bucle #loc
inspection.message.call.to.ref.outside.of.synchronized.context=Llamada a '#ref' fuera del contexto sincronizado #loc
inspection.message.call.to.ref.outside.synchronized.context=La llamada a '#ref' se realiza fuera del contexto sincronizado #loc
inspection.message.call.to.system.ref=Llamada a "System.#ref" #loc
inspection.message.call.to.thread.ref=Llamada a 'Thread.#ref' #loc
inspection.message.call.to.thread.ref.in.a.loop=Puede que <code>Thread.#ref()</code> llamado en un bucle esté en espera activa #loc
inspection.message.cannot.determine.type.ref=No se puede determinar el tipo de '#ref'
inspection.message.cannot.resolve.method.call=No se puede resolver la llamada al método
inspection.message.case.or.default.branches.are.expected=Se espera que las ramas sean 'case' o 'default'
inspection.message.class.cannot.be.non.sealed.without.sealed.parent=La clase ''{0}'' no puede ser no sellada sin un padre sellado
inspection.message.class.has.no.explicit.or.implicit.subclasses=La clase ''{0}'' no tiene subclases explícitas o implícitas permitidas
inspection.message.code.ref.code.recurses.infinitely.can.only.complete.by.throwing.exception=El código de referencia <code>#ref</code> recurre infinitamente, solo se puede completar lanzando una excepción #loc
inspection.message.code.ref.code.statement.doesnt.loop=La sentencia <code>#ref</code> no itera #loc
inspection.message.compact.constructor.should.have.explicit.visibility.modifier=El constructor compacto debe tener un modificador de visibilidad explícito
inspection.message.conditional.expression=expresión condicional #loc
inspection.message.conditional.expression.can.be.call=La expresión condicional puede ser una llamada #loc
inspection.message.conditional.expression.can.be.elvis=La expresión condicional puede ser un operador Elvis #loc
inspection.message.conditional.expression.with.identical.branches=Expresión condicional con ramas idénticas
inspection.message.constant.name.ref.doesnt.match.regex=El nombre de la constante ''#ref'' no coincide con la expresión regular ''{0}'' #loc
inspection.message.constant.name.ref.too.long=El nombre de la constante '#ref' es demasiado largo
inspection.message.constant.name.ref.too.short=El nombre de la constante '#ref' es demasiado corto
inspection.message.couldnt.find.property.field.with.this.name=No se pudo encontrar la propiedad o el campo con este nombre
inspection.message.divide.by.zero=División por cero
inspection.message.double.checked.locking=Bloqueo de doble comprobación
inspection.message.double.negation.ref=Doble negación #ref #loc
inspection.message.dsl.descriptor.file.has.been.changed.and.isnt.currently.executed=El archivo descriptor DSL se ha modificado y actualmente no se está ejecutando
inspection.message.dsl.descriptor.file.has.been.disabled.due.to.processing.error=El archivo descriptor de DSL ha sido deshabilidato debido a un error de procesamiento
inspection.message.duplicate.switch.case.ref=case duplicado 'switch' = '#ref' #loc
inspection.message.empty.ref.block=bloque '#ref' vacío #loc
inspection.message.fallthrough.in.switch.statement=caso abierto en la instrucción 'switch' #loc
inspection.message.fraction.literals.without.leading.zero.are.available.in.groovy.or.later=Los literales de fracción sin cero inicial están disponibles en Groovy 4.0 o posterior
inspection.message.gstring.used.as.maps.key=GString usado como clave de mapa #loc
inspection.message.instance.method.name.ref.doesnt.match.regex=El nombre del método de instancia ''#ref'' no coincide con la regex ''{0}'' #loc
inspection.message.instance.method.name.ref.too.long=El nombre del método de instancia '#ref' es demasiado largo
inspection.message.instance.method.name.ref.too.short=El nombre del método de instancia '#ref' es demasiado corto.
inspection.message.instance.variable.name.ref.doesn.t.match.regex=El nombre de la variable de instancia ''#ref'' no coincide con la expresión regular ''{0}'' #loc
inspection.message.instance.variable.name.ref.too.long=El nombre de la variable de instancia '#ref' es demasiado largo
inspection.message.instance.variable.name.ref.too.short=El nombre de variable de instancia '#ref' es demasiado corto
inspection.message.interface.cannot.be.non.sealed.without.sealed.parent=La interfaz ''{0}'' no puede no estar sellada sin un padre sellado
inspection.message.interface.has.no.explicit.or.implicit.implementors=La interfaz ''{0}'' no tiene implementadores explícitos o implícitos
inspection.message.interpolated.string.should.be.dollar.slashy.quoted=Las cadenas interpoladas deben estar entrecomilladas con $/
inspection.message.interpolated.string.should.be.double.quoted=Las cadenas interpoladas deben estar entrecomilladas
inspection.message.interpolated.string.should.be.quoted.with.triple.double.quotes=La cadena interpolada debe estar entrecomillada con comillas triples dobles
inspection.message.interpolated.string.should.be.slashy.quoted=La cadena interpolada debería estar entre comillas tipo barra
inspection.message.invalid.permits.clause.must.be.sealed=Cláusula ''permits'' no válida: ''{0}'' debe estar ''sealed''
inspection.message.invalid.permits.clause.must.directly.extend=Cláusula ''permits'' no válida: ''{0}'' debe extender directamente ''{1}''
inspection.message.keyword.yield.available.with.groovy.4.or.later=La palabra clave 'yield' está disponible en Groovy 4.0 o posterior
inspection.message.label.name.ref.not.supported.by.0=El nombre de la etiqueta ''#ref'' no es soportado por {0}
inspection.message.left.open.ranges.are.available.in.groovy.4.or.later=rango abierto a la izquierda disponible en Groovy 4.0 o posterior
inspection.message.local.variable.name.ref.doesnt.match.regex=El nombre de la variable local ''#ref'' no coincide con la expresión regular ''{0}'' #loc
inspection.message.local.variable.name.ref.too.long=El nombre de variable local '#ref' es demasiado largo
inspection.message.local.variable.name.ref.too.short=Nombre de variable local '#ref' demasiado corto
inspection.message.method.called.with.implicit.null.argument=método llamado con argumento nulo implícito
inspection.message.method.parameter.name.ref.doesnt.match.regex=El nombre del parámetro del método '`#ref`' no coincide con la expresión regular '`{0}`' #loc
inspection.message.method.parameter.name.ref.too.long=El nombre del parámetro del método '#ref' es demasiado largo
inspection.message.method.parameter.name.ref.too.short=El nombre del parámetro del método '#ref' es muy corto
inspection.message.method.ref.contains.too.many.parameters.0.1=El método ''#ref'' contiene demasiados parámetros ({0}>{1})
inspection.message.method.ref.has.too.many.negations=El método ''#ref'' tiene demasiadas negaciones ({0} > 3)
inspection.message.method.ref.overly.complex.cyclomatic.complexity=El método ''#ref'' es demasiado complejo (complejidad ciclomática = {0}>{1})
inspection.message.method.ref.overly.nested.nesting.depth=Método ''#ref'' anidado excesivamente (profundidad = {0}>{1})
inspection.message.method.ref.too.long.statement.count=El método ''#ref'' es demasiado largo (número de sentencias = {0}>{1})
inspection.message.mixing.arrows.colons.not.allowed=No se permite mezclar flechas con dos puntos
inspection.message.modifier.non.sealed.cannot.be.applied.to.enum.class=El modificador 'non-sealed' no puede aplicarse a la clase enumeración
inspection.message.modifier.nonsealed.available.with.groovy.or.later=El modificador 'non-sealed' está disponible en Groovy 4.0 o posterior
inspection.message.modifier.sealed.available.with.groovy.or.later=El modificador 'sealed' está disponible con Groovy 4.0 o posterior
inspection.message.modifier.sealed.cannot.be.applied.to.enum.class=El modificador 'sealed' no se puede aplicar a una clase enum
inspection.message.multiline.string.should.be.dollar.slashy.quoted=Las cadenas multilíneas deben citarse con dólar y barra
inspection.message.multiline.string.should.be.quoted.with.triple.double.quotes=las cadenas de varias líneas deben ir entre comillas triples dobles
inspection.message.multiline.string.should.be.quoted.with.triple.quotes=Las cadenas de varias líneas deben entrecomillarse con triple comilla
inspection.message.multiline.string.should.be.slashy.quoted=Las cadenas de texto multilínea deben estar entrecomilladas con barras diagonales
inspection.message.multiple.expressions.in.case.section.are.available.with.groovy.4.or.later=Las expresiones múltiples en la sección case están disponibles con Groovy 4.0 o una versión posterior
inspection.message.negated.conditional.expression=condición negada
inspection.message.negated.if.condition.expression=Expresión de condición if negada #loc
inspection.message.nested.assignment=uso de resultado de expresión de asignación #loc
inspection.message.nested.assignment.expression=Expresión de asignación anidada #loc
inspection.message.nested.conditional.expression=Expresión condicional anidada
inspection.message.nested.ref.statement=Declaración '#ref' anidada #loc
inspection.message.non.private.field.accessed.in.synchronized.context=Se accede al campo no privado '#ref' en el contexto sincronizado #loc
inspection.message.non.short.circuit.boolean.expression=Expresión booleana no de cortocircuito #loc
inspection.message.not.allowed.in.sealed.hierarchy=No se puede generar ''{0}'' en jerarquía sellada
inspection.message.octal.integer.ref=Entero octal #ref #loc
inspection.message.only.one.final.sealed.non.sealed.should.be.applied.to.class=Sólo debe aplicarse uno de 'final', 'sealed', 'non-sealed', @Sealed o @NonSealed a la clase
inspection.message.overly.complex.arithmetic.expression=Expresión aritmética demasiado compleja #loc
inspection.message.overly.complex.boolean.expression=Expresión booleana excesivamente compleja #loc
inspection.message.package.name.mismatch=El nombre del paquete no coincide
inspection.message.package.name.mismatch.actual.0.expected.1=El nombre de paquete "{0}" no coincide con el esperado, "{1}"
inspection.message.permits.available.with.groovy.4.or.later='permits' está disponible a partir de Groovy 4.0
inspection.message.plain.string.should.be.dollar.slashy.quoted=Las cadenas planas deben ser citadas con $ /
inspection.message.plain.string.should.be.double.quoted=Las cadenas de texto sin formato deben estar delimitadas por comillas dobles
inspection.message.plain.string.should.be.quoted.with.triple.double.quotes=las cadenas de texto normales deben citarse con comillas triples dobles
inspection.message.plain.string.should.be.quoted.with.triple.quotes=Las cadenas simples deben estar entrecomilladas con ''''
inspection.message.plain.string.should.be.single.quoted=La cadena simple debería ir entre comillas simples
inspection.message.plain.string.should.be.slashy.quoted=Los strings normales deberian estar entrecomillados con barras
inspection.message.pojo.has.effect.only.with.compilestatic=@POJO solo tiene efecto con @CompileStatic
inspection.message.property.0.is.final=La propiedad ''{0}'' es final
inspection.message.property.0.is.ignored.by.map.constructor=La propiedad ''{0}'' es ignorada por @MapConstructor #loc
inspection.message.property.not.indexable.type.must.be.array.or.list.but.found.0=La propiedad no es indexable. El tipo debe ser lista o array, pero se encontró {0}
inspection.message.record.parameter.should.be.immutable=El parámetro de registro ''{0}'' debe tener un tipo inmutable o declararse como inmutable usando @ImmutableOptions
inspection.message.records.are.available.in.groovy.4.or.later=Registros están disponibles en Groovy 4.0.0-beta-2 o posterior
inspection.message.ref.can.be.simplified=La ref. se puede simplificar '#ref'
inspection.message.ref.has.0.return.points=<code>#ref</code> presenta {0} puntos de retorno #loc
inspection.message.ref.inside.finally.block='#ref' dentro del bloque 'finally' #loc
inspection.message.ref.is.unnecessary.as.last.statement.in.loop=ref es innecesario como última instrucción en un bucle
inspection.message.ref.is.unnecessary.as.last.statement.in.method.with.no.return.value=la referencia no es necesaria porque es la última sentencia de un método sin valor de retorno
inspection.message.ref.loop.spins.on.field=<code>#ref</code> el bucle gira en el campo #loc
inspection.message.ref.statement=#ref #loc
inspection.message.ref.statement.at.end.closure.can.be.made.implicit=Retorno explícito al final del cierre #loc
inspection.message.ref.statement.can.be.simplified=sentencia #ref puede ser simplificada #loc
inspection.message.ref.statement.cannot.complete.without.throwing.exception=La sentencia <code>#ref</code> no puede completarse sin lanzar una excepción #loc
inspection.message.ref.statement.has.empty.body='**#ref** la instrucción tiene un cuerpo vacío'
inspection.message.ref.statement.has.empty.branch=la sentencia '#ref' tiene un branch vacio
inspection.message.ref.statement.with.identical.branches=Statement '#ref' con ramas idénticas #loc
inspection.message.ref.statement.with.no.default.branch=Sentencia #ref sin rama por defecto #loc
inspection.message.ref.statement.with.too.many.branches=Sentencia ''#ref'' con demasiadas ramas ({0}) #loc
inspection.message.result.increment.or.decrement.expression.used=Uso de resultado de incremento o decremento #loc
inspection.message.result.of.new.ref.is.ignored=Se ignora el resultado de ''new #ref{0}'' #loc
inspection.message.silly.assignment=Asignación nula
inspection.message.static.interface.methods.must.be.qualified.in.groovy.4=Los métodos de interfaz 'static' deben estar calificados en Groovy 4
inspection.message.static.method.name.ref.doesnt.match.regex=El nombre del método estático ''#ref'' no coincide con la expresión regular ''{0}'' #loc
inspection.message.static.method.name.ref.too.long=El nombre '#ref' para el método estático es demasiado largo
inspection.message.static.method.name.ref.too.short=El nombre del método estático '#ref' es demasiado corto
inspection.message.static.variable.name.ref.doesnt.match.regex=El nombre de variable estática ''#ref'' no coincide con la expresión regular ''{0}'' #loc
inspection.message.static.variable.name.ref.too.long=El nombre de variable estática '#ref' es demasiado largo
inspection.message.static.variable.name.ref.too.short=La variable estática '#ref' tiene un nombre demasiado corto
inspection.message.string.escaping.could.be.minimized=El escape podría minimizarse
inspection.message.switch.expression.does.not.cover.all.possible.outcomes=la expresión switch no cubre todos los resultados posibles
inspection.message.switch.expressions.are.available.with.groovy.4.or.later=Las expresiones switch están disponibles con Groovy 4.0 o superior
inspection.message.switch.expressions.do.not.support.return=switch expresiones no soportan 'return'
inspection.message.synchronization.on.non.final.field.ref=Sincronización en el campo no final '#ref' #loc
inspection.message.synchronization.on.ref=Sincronización en '#ref' #loc
inspection.message.synchronization.on.variable.ref.which.was.initialized.with.literal=Sincronización en '#ref' que fue inicializada con el literal #loc
inspection.message.synchronized.method.ref=Método sincronizado '#ref' #loc
inspection.message.traits.0.contain.clashing.methods.with.signature.1=El trait {0} contiene métodos en conflicto con la firma {1}
inspection.message.trivial.conditional.expression=Expresión condicional trivial
inspection.message.type.argument.0.can.not.be.1=el argumento ''{0}'' no puede ser de tipo ''{1}''
inspection.message.unconditional.call.to.ref=Llamada incondicional a `#ref()` #loc
inspection.message.unreachable.statement=Declaración inalcanzable
inspection.message.unsynchronized.method.ref.overrides.synchronized.method=El método no sincronizado '#ref' sobreescribe un método sincronizado #loc
inspection.message.unused.catch.parameter.ref=Parámetro de captura '#ref' sin utilizar #loc
inspection.message.yield.or.throw.expected.in.case.section='yield' o 'throw' se espera en la sección case
inspection.method.metrics=Métricas de método
inspection.naming=Convención de nombres
inspection.other=Otro
inspection.redundancy=Redundancia de declaración
inspection.separator.disable.in.file.types=Habilitar en tipos de archivos:
inspection.style=Estilo
inspection.threading=Problemas de subprocesos
inspection.validity=Problema de validez
intention.category.closures=Groovy/Clausuras
intention.category.comments=Groovy/Comentarios
intention.category.control.flow=Groovy/Flujo de control
intention.category.conversions=Groovy/Conversiones de expresiones
intention.category.groovy=Groovy
intention.category.groovy.declaration=Groovy/Declaración
intention.category.groovy.other=Groovy/Otros
intention.category.groovy.style=Groovy/Estilo Groovy
intention.family.name.activate.dsl.descriptor=Activar descriptor DSL
intention.family.name.add.attributes.to.annotation=Añadir atributos a anotación
intention.family.name.add.cast=Añadir conversión
intention.family.name.add.class.to.clause=Añadir clase a la cláusula
intention.family.name.add.missing.case.branches=Agregar ramas case faltantes
intention.family.name.add.parameter.cast=Agregar casteo al parámetro
intention.family.name.change.variable.type=Cambiar tipo variable
intention.family.name.collapse.conditional.expressions=Contraer expresiones condicionales
intention.family.name.collapse.if.statement=Ocultar la instrucción "if"
intention.family.name.convert.conditional.expression.to.elvis=Convertir expresión condicional a elvis
intention.family.name.create.field=Crear campo
intention.family.name.fix.quotation=Corregir comillas
intention.family.name.fix.range.class=Clase de rango de corrección
intention.family.name.make.return.implicit=Establecer retorno a implícito
intention.family.name.remove.double.negation=Eliminar negación doble
intention.family.name.remove.unnecessary.continue=quitar continue innecesario
intention.family.name.remove.unnecessary.return=Eliminación del return innecesario
intention.family.name.rename=Renombrar
intention.family.name.replace.for.each.operator=Reemplazar el operador 'for-each'
intention.family.name.replace.keywords=reemplaza elementos
intention.family.name.replace.modifiers=Sustituir modificadores
intention.family.name.replace.something.with=Reemplazar ''{0}'' por ''{1}''
intention.family.name.replace.with.conditional.call=reemplazar por llamada condicional
intention.family.name.replace.with.keyed.access=Reemplazar con acceso indizado
intention.family.name.replace.with.short.circuit.expression=Reemplazar con expresión de corto circuito
intention.family.name.simplify=simplificar
intention.name.activate.back=Reactivar regreso
intention.name.add.required.attributes.to.map.constructor=Añadir atributos requeridos a '@MapConstructor'
intention.name.add.to.clause=Agregar ''{0}'' a la cláusula ''{1}'' de ''{2}''
intention.name.cast.operand.to.0=Convertir operando a {0}
intention.name.cast.to.0=Convertir a {0}
intention.name.change.quotes.to.triple.double.quotes=Cambiar las comillas a """
intention.name.change.quotes.to.triple.single.quotes=Cambiar comillas a '''
intention.name.convert.to.dollar.slashy.string=Convertir a cadena de dólar con barra diagonal
intention.name.convert.to.double.quoted.string=Convertir a cadena entre comillas dobles
intention.name.convert.to.single.quoted.string=Convertir a cadena con comillas simples
intention.name.convert.to.slashy.string=convertir a cadena con barras
intention.name.create.abstract.method.in.class=Crear método abstracto ''{0}'' en ''{1}''
intention.name.create.constant.field.in.class=Crear campo constante ''{0}'' en ''{1}''
intention.name.create.enum.constant.0=Crear constante de enumeración ''{0}''
intention.name.create.field.in.class=Crear campo ''{0}'' en ''{1}''
intention.name.create.method.in.class=Crear método ''{0}'' en ''{1}''
intention.name.insert.case.0=Insertar ''case {0}''
intention.name.insert.case.0.case.1=Insertar ''case {0}'' y ''case {1}''
intention.name.insert.default.branch=Insertar una rama 'default'
intention.name.insert.missing.branches=Insertar ramas faltantes
intention.name.make.compact.constructor.public=Convertir constructor compacto a 'public'
intention.name.remove.wrong.modifiers.for.record=Eliminar modificadores incorrectos para record
intention.name.replace=Reemplazar ''{0}'' por ''{1}''
intention.name.replace.eq.with.0.eq=Reemplazar ''='' por ''{0}=''
intention.name.replace.with.in=Reemplazar ':' por 'in'
intention.name.replace.with.qualified.expression=sustituir por expresión calificada
interface.cannot.have.modifier.final=interfaz no puede tener modificador 'final'
interface.members.are.not.allowed.to.be=Los miembros de la interfaz no pueden ser {0}
interface.must.have.no.static.method=La interfaz no debe tener métodos estáticos
introduce.constant.title=Introducir constante
introduce.parameter.delegate.via.overload=Delegado por sobrecarga de método(&L)
introduce.parameter.delegating.unavailable.tooltip=La delegación no está disponible en el contexto de cierre
introduce.parameter.do.not.replace.option.label=No reemplazar(&O)
introduce.parameter.explicit.return.statement.option.label=usar declaración de retorno explícita(&X)
introduce.parameter.replace.all.fields.option.label=Reemplazar todos los campos(&R)
introduce.parameter.replace.fields.border.title=Sustituir campos utilizados en la expresión por su Getter
introduce.parameter.replace.inaccessible.fields.option.label=Reemplazar campos inaccesibles en el contexto de uso(&I)
introduce.variable.change.type.advertisement=Presiona {0} para cambiar el tipo
introduce.variable.declare.final.label=Declarar final(&F)
introduce.variable.name.label=Nombre:(&N)
introduce.variable.replace.all.0.occurrences=Reemplazar todas las coincidencias ({0} coincidencias)(&A)
introduce.variable.replace.all.occurrences=Reemplazar todas las coincidencias(&A)
introduce.variable.type.label=Tipo:(&T)
invalid.lvalue=valor inválido
invalid.qualified.name=Este no es un nombre cualificado de Groovy válido
investigate.gdsl.error.family.name=Investigar error de procesamiento de descriptor DSL
investigate.gdsl.error.intention.name=Investigar detalle
invoke.completion.second.time.to.show.skipped.methods=Invocar completación por segunda vez para mostrar métodos omitidos
is.not.enclosing.class=''{0}'' no es una clase que encierra
java.style.for.each.statement.requires.a.type.declaration=La declaración for-each del estilo Java requiere una declaración de tipo
java.style.properties.invocation.intention.family.name=Cambiar invocaciones de accessor de Java a referencias de propiedad de Groovy
java.style.properties.invocation.intention.name=Cambiar a llamada de propiedad de estilo Groovy
java.style.property.access=Llamado de accesor de estilo Java
label.already.used=Etiqueta ''{0}'' ya está en uso
label.groovy.sdk=SDK de Groovy:
language.groovy=Groovy
leave.only.modifier.or.annotation.0=Dejar solo ''{0}''
listener.list.field.must.have.a.generic.collection.type=El campo de lista de listener debe tener un tipo de colección genérico
listener.list.field.with.generic.wildcards.not.supported=No se admiten campos @ListenerList con comodines genéricos
live.template.context.declaration=declaración
live.template.context.expression=expresión
live.template.context.statement=sentencia
local.var.0.is.reassigned=La variable local ''{0}'' fue reasignada
lock.field.0.must.be.static=El campo ''{0}'' bloqueado debe ser static
lock.field.0.must.not.be.static=El campo de bloqueo ''{0}'' no debe ser estático
lock.field.0.not.found=Campo de bloqueo ''{0}'' no se encontró
loss.of.precision=Puede haber una pérdida de precisión de ''{0}'' a ''{1}''
map.param.name=Nombre param. mapa:(&N)
map.parameter.dialog.create.new.checkbox=Crear nuevo parámetro para parámetro nombrado(&C)
map.parameter.dialog.explicit.type.checkbox=Especificar tipo explícitamente
method.0.cannot.have.weaker.access.privileges.1.than.2.in.3.4=el método ''{0}'' no puede tener privilegios de acceso más débiles ''{1}'' que ''{2}'' en ''{3}'' (''{4}'')
method.0.cannot.override.method.1.in.2.overridden.method.is.final=El método ''{0}'' no puede anular el método ''{1}'' de ''{2}''; el método anulado es final
method.0.is.too.complex.too.analyze=El método ''{0}'' es demasiado complejo para analizar.\nNo se pudieron inferir los tipos de variables locales.
method.call.is.ambiguous=Llamada al método es ambigua
method.does.not.override.super=El método no sobrescribe el método de la superclase
method.duplicate=Ya se ha definido el método con la firma {0} en la clase ''{1}''
method.has.incorrect.modifier.volatile=El método tiene un modificador incorrecto 'volatile'
method.is.not.implemented=El método ''{0}'' no está implementado
method.is.used.outside.of.groovy=El método se usa fuera de Groovy
method.may.be.static=El método puede ser estático
method.may.be.static.ignore.empty.method.option=Ignorar métodos vacíos
method.may.be.static.only.private.or.final.option=sólo privado o final
method.may.be.static.option.ignore.trait.methods=ignorar métodos de características
method.parameters.count.max.parameters.option=Parámetros máximos:
method.returns.max.returns.option=Restricción de puntos de retorno:
method.with.signature.already.exists=Ya existe un método con la firma {0}
method.with.type.parameters.should.have.return.type=El método con parámetros de tipo debe tener un tipo de retorno
missed.attributes=Atributos no encontrados: {0}
missing.required.named.parameter=Parámetro nombrado requerido ''{0}'' ausente
mixing.private.and.public.protected.methods.of.the.same.name=Mezcla de métodos privados y públicos / protegidos con el mismo nombre
modifier.0.not.allowed=No se permite el modificador ''{0}''
modifier.transient.not.allowed.here=El modificador 'transient' no está permitido aquí
modifier.volatile.not.allowed.here=el modificador 'volatile' no está permitido aquí
module.name.0.and.groovy.version.1={0} ({1})
module.with.groovy=Modulo simple con librería Groovy adjunta
move.class.0.from.method=mover ''{0}'' a la posición correcta
move.class.from.method.family.name=Reformateo rápido "Mover clase desde el nombre de la familia del metodo"
move.to.correct.dir=Mover al paquete ''{0}''
move.to.correct.dir.family.name=Mover el archivo al paquete correcto
multiple.assignments.without.list.expr=Asigaciones múltiples sin expresión de lista no soportadas en modo de comprobación de tipo estática
named.arguments.are.not.allowed.inside.index.operations=Los argumentos con nombre no están permitidos dentro de las operaciones de índice
native.methods.cannot.have.body=Los métodos nativos no pueden tener cuerpo
native.visibility.presentation=nativa
new.class.action.description=Crear nueva clase Groovy
new.class.action.text=Clase Groovy
new.class.dialog.title=Nuevo Groovy clase
new.class.list.item.annotation=Anotación
new.class.list.item.class=clase
new.class.list.item.enum=Enumeración
new.class.list.item.interface=interface
new.class.list.item.record=registro
new.class.list.item.trait=rasgo
new.gant.script.dialog.message=Ingrese el nombre para el nuevo script de Gant
new.gant.script.dialog.title=Nuevo script de Gant
new.instance.of.singleton=Nueva instancia de clase anotada con @groovy.lang.Singleton
new.project.wizard.groovy.creating.main.file=Creando archivo principal Groovy...
new.project.wizard.groovy.retrieving.has.failed=Falló la recuperación de la versión Groovy
new.script.action.description=Crear nuevo script Groovy
new.script.action.text=Script Groovy
new.script.dialog.title=Entrar nombre para nuevo script Groovy
new.script.list.item.script=Groovy script
new.script.list.item.script.dsl=GroovyDSL
newlines.here.are.available.since.groovy.3=Saltos de línea en listas de argumentos desde Groovy 3
no.applicable.signature.found=no hay una firma aplicable
no.class.expected.here=No se espera una clase aquí
no.class.in.file.template=no hay clase en el template del archivo
no.implements.clause.allowed.for.interface=Las interfaces no pueden tener cláusula de implementación
no.interface.expected.here=No se espera que aquí haya una interfaz
no.return.message=No todas las rutas de ejecución devuelven un valor
no.such.property=Propiedad ''{0}'' no existe
no.super.classes.found=No se encontraron superclases
no.super.method.found=No se encontró el método super
no.type.specified=tipo no especificado
non.sealed.visibility.presentation=no sellado
non.static.classes.not.allowed=Las clases no estáticas no están permitidas en las características
not.abstract.method.should.have.body=método no abstracto no debería tener cuerpo
not.allowed.modifier.in.for.in=El modificador ''{0}'' no está permitido aquí
notification.group.grape=Groovy @Grab anotación procesada
notification.group.groovy.dsl=Errores de Groovy DSL
only.abstract.class.can.have.abstract.method=Solo las clases abstractas pueden tener métodos abstractos
only.traits.expected.here=Solo características esperadas aquí
operator.call.is.ambiguous=La llamada al operador es ambigua
operator.is.not.supported.in=El operador ''{0}'' no es compatible en
optimize.all.imports=Optimizar instrucciones import sin utilizar
optimize.imports=Optimizar importaciones
optimize.imports.progress.title=Optimizar import en archivo Groovy...
other.scope=Otro alcance
overly.complex.method.complexity.limit.option=Límite de complejidad del método
overly.long.method.statements.limit.option=Número máximo de sentencias por método:
overly.nested.method.nesting.limit.option=Límite anidamiento método demasiado anidado:
overriding.methods.of.0=Métodos de sobreescritura de ''{0}''
package.definition.cannot.have.modifiers=La definición del paquete no puede tener modificadores
packageLocal.visibility.presentation=visibilidad por defecto
parameter.can.be.final.tooltip=El parámetro ''{0}'' puede ser final
parameter.cast.fix=Parámetro {0,number,ordinal} al tipo {1}
parameter.hint.number.of.arguments={0, choice, 0#|1#{0} argumento|2#{0} argumentos}
parameter.list.owner.chooser.title=Selector de introducción de parámetros
pointless.arithmetic.error.message=Operación aritmética redundante #loc
pointless.boolean.problem.descriptor=Operación booleana redundante #loc
pointless.boolean.quickfix=Simplificar
popup.content.navigation.to.overriding.classes.unavailable=La navegación a las clases anuladas no está disponible durante la actualización del índice
postfix.template.provider.name=Groovy
primitive.bound.types.are.not.allowed=Los tipos límite primitivos no están permitidos
primitive.type.parameters.are.not.allowed=Los parámetros de tipo primitivo no están permitidos
private.visibility.presentation=privada
property.missing=propiedadNula
property.name.expected=El nombre de la propiedad se espera como nulo
protected.visibility.presentation=protegido
public.visibility.presentation=público
pull.up.abstract.wont.be.accessible.from=No se puede hacer abstracta {0} porque no es accesible por las subclases.
pull.up.wont.be.accessible.from=La extracción no será accesible desde {1}
pull.up.wont.be.accessible.from.the.subclass={0} utiliza {1}, que no estará accesible desde la subclase.
qualified.0.is.allowed.only.in.nested.or.inner.classes=El {0} calificado solo se permite en clases anidadas o internas
recursive.constructor.invocation=Llamada recursiva al constructor
remove.0=remover ''{0}''
remove.catch.block=eliminar bloque catch
remove.exception=eliminar excepción
remove.modifier=nullar ''{0}''
remove.parameter.0=quitar parámetro ''{0}''
remove.unused.parameter=Eliminar parámetro no utilizado
rename.file.to.0=renombrar archivo a ''{0}''
repetitive.method.name.0=Nombre de método ''{0}'' repetitivo
replace.0.with.1=reemplazar ''{0}'' con binario ''{1}''
replace.all.occurrences.and.remove.variable.0=Reemplazar todas las coincidencias y quitar variable ''{0}''
replace.new.expression.with.instance.access=Reemplazar nueva expresión con acceso a instancia
replace.postfix.0.with.prefix.0=Reemplaza sufijo ''{0}'' con prefijo ''{0}''
replace.primitive.type.with.wrapper=Reemplazar tipo primitivo con envoltura
replace.qualified.name.with.import=reemplazar.nombre.cualificado.con.importar
replace.with.get.at=Reemplazar con la sentencia get en el índice
replace.with.list.literal=reemplazar con literal de lista
replace.with.method.fix=reemplazar con método ''{0}''
replace.with.method.message=Se puede remplazar con llamada a método ''{0}''
replace.with.operator.compareTo.equality.option=Reemplazar comparación 'compareTo' por igualdad (es decir, ==)
replace.with.operator.double.negation.option=Usar doble negación (por ejemplo !!)
replace.with.operator.fix=''{0}'' por operador
replace.with.operator.message=''Se puede reemplazar con el operador ''{0}''
replace.with.operator.parentheses=No sugerir reemplazo con operador si implica paréntesis adicionales
replace.with.wrapper=sustituir por ''{0}''
require.closure.as.attribute.value=Se espera un closure como valor del atributo
return.type.is.incompatible=El tipo de retorno de {0} en {1} es incompatible con {2} en {3}
rtype.cannot.contain.ltype=''{1}'' no contiene ''{0}''
run.configuration.module.chooser.label=Módulo:(&M)
run.configuration.module.classpath.checkbox=Añadir clase de ruta del módulo al corredor (&C)
run.configuration.script.path.label=Ruta del script
script.cannot.have.modifier.native=El script no puede tener modificador 'native'
script.generated.with.same.name=Se generó una clase sintetizada ''{0}'' para código de script con el mismo nombre
script.method.cannot.have.modifier.abstract=El método de secuencia de comandos no puede tener el modificador 'abstract'
script.runner.cant.find.script=No se pudo encontrar el script ''{0}''
script.runner.chooser.description=Indica la ruta del script
script.runner.chooser.title=Ruta del script
script.runner.class.cannot.be.executed=la clase no puede ser ejecutada
script.runner.class.does.not.exist=la clase no existe
script.runner.description=Clase o script Groovy
script.runner.display.name=Groovy
script.runner.file.is.not.groovy.file=El archivo de script no es un archivo Groovy
script.runner.module.not.specified.message=Módulo no especificado
script.runner.no.groovy.for.module=Groovy no configurado para el módulo ''{0}''
script.runner.unknown.script.type=Tipo de script desconocido ''{0}''
sealed.visibility.presentation=sellado
second.unsafe.call=Segunda llamada insegura
select.framework.0.home.title=Seleccionar {0} home
select.module.action.description=Selecciona el módulo que va a utilizar la ruta de clase
select.module.action.text=Seleccionar módulo...
select.module.popup.title=Utilizar la ruta de clase del módulo
selfType.class.does.not.inherit=@SelfType: La clase ''{0}'' no hereda de ''{1}''
separator.domain.of.inspection.usage=Dominio de uso
separator.preferable.string.kind=Tipo Preferible
settings.code.style.absolute=Absoluto
settings.code.style.indent.labels=Indentación de etiquetas
settings.code.style.indent.statements.after.label=Sangría para sentencias después de etiqueta
settings.code.style.label.indent.size=Tamaño de sangría de etiqueta
settings.code.style.label.indent.style=Estilo de sangría de etiqueta
settings.compiler.alternative=También puedes especificar el compilador Groovy-Eclipse en la <a>página del compilador Java</a>
settings.compiler.exclude.from.stub.generation=Excluir de la generación de stubs:
settings.compiler.invoke.dynamic.support=Invocar soporte dinámico (&D)
settings.compiler.path.to.configscript=Ruta al script de configuración(&C):
settings.compiler.select.path.to.groovy.compiler.configscript=Seleccionar ruta al configscript del compilador Groovy
settings.inlay.groovy.implicit.null.argument.provider.description=Si un método acepta un solo argumento, Groovy permite invocarlo sin argumento alguno. En este caso, Groovy pasa implícitamente un único 'null' como argumento.
settings.inlay.groovy.implicit.null.argument.provider.name=Argumento 'null' implícito
settings.inlay.groovy.lambda.parameter.provider.description=Mostrar tipos de parámetro en expresiones lambda:
settings.inlay.groovy.lambda.parameter.provider.name=Parámetro Lambda
settings.inlay.groovy.local.variable.implicit.types.description=Mostrar tipo de variable local declarada con 'def' o 'var' en el punto de declaración
settings.inlay.groovy.local.variable.implicit.types.name=Sugerencias de tipo de variable local
shows.parameter.names.at.function.call.sites=mostrar.nombres.parámetros.en.sitios.llamada.función
singleton.constructor.found=@Las clases Singleton no deben tener constructores
singleton.constructor.makeNonStrict=Hacer @Singleton no estricto
singleton.constructor.remove=Borrar constructor
spread.operator.is.not.available=El operador de propagación no está disponible
static.import.method.0.fix=Método de importación estático ''{0}''
static.import.method.fix=...importar método estático
static.visibility.presentation=estático
strictfp.visibility.presentation=strictfp
string.end.expected=Fin de cadena esperado
string.option.do.not.handle.specifically=No manejar específicamente
string.option.dollar.slashy.string=cadena dólar barra
string.option.double.quoted.string=cadena entre comillas dobles
string.option.single.quoted.string=cadena entre comillas simples
string.option.slashy.string=cadena nula
string.option.triple.double.quoted.string=Cadena entre comillas triples dobles
string.option.triple.quoted.string=cadena con triples comillas
string.sort.default=Por defecto
string.sort.multiline.string=cadena multilínea
string.sort.strings.with.escaping=cadenas con escape
string.sort.strings.with.interpolation=cadenas con interpolación
super.cannot.be.used.in.static.context='super' no puede usarse en un contexto estático
super.is.not.allowed.in.pre.with.call.super=super no está permitido en pre con llamada a super
surround.with.cast=((Tipo) expr)
surround.with.closure={ -> ... }.call()=rodear.con.cierre={ -> ... }.call()
surround.with.for=por
surround.with.if=si
surround.with.if.else=if / else
surround.with.if.else.expr=if (expr) / else
surround.with.if.expr=if (expr)
surround.with.parentheses=(expr)
surround.with.shouldFail=shouldFail () {...}
surround.with.try=try
surround.with.try.catch=try / catch
surround.with.try.catch.finally=try / catch / finally
surround.with.try.finally=try / finally
surround.with.while=mientras
surround.with.while.expr=while (expr)
surround.with.with=con () {...}
surround.with.with.expr=con (expr)
synchronized.not.allowed.on.abstract.method=El modificador synchronized no es válido en métodos abstractos
synchronized.visibility.presentation=sincronizado
target.0.does.not.exist=El objetivo ''{0}'' no existe
target.annotation.is.unused=@Target no usado
text.class.0.is.unused=la clase {0} no se utiliza
text.constructor.0.is.unused=El constructor {0} no se usa
text.method.0.is.unused=Método {0} sin usar
text.parameter.0.is.unused=El parámetro {0} no se utiliza
text.property.0.is.unused=La propiedad {0} de ''{1}'' se encuentra sin uso
the.usage.of.a.map.entry.expression.to.initialize.an.enum.is.currently.not.supported=Actualmente no se admite el uso de una expression de entrada de mapa para inicializar una enumeración
there.is.no.default.constructor.available.in.class.0=La clase ''{0}'' no tiene un constructor por defecto disponible
this.super.completion.advertisement=Presiona {0} dos veces sin un calificador de clase para mostrar todos los métodos estáticos accesibles
throws.clause.is.not.allowed.in.at.interface='throws' cláusula no permitida en '@interface'
top.level.class.may.not.have.private.modifier=Las clases de nivel superior no pueden tener el modificador 'private'
top.level.class.may.not.have.protected.modifier=La clase de nivel superior no puede tener un modificador 'protected'
trait.method.cannot.be.protected=No se puede proteger el método de la característica
transient.visibility.presentation=transitorio
try.catch.fix=Try-catch corrección
try.without.catch.finally='try' sin 'catch' ni 'finally'
tuple.cant.be.placed.in.class=No se permiten asignaciones múltiples para campos
tuple.declaration.should.end.with.def.modifier=La declaración de la tupla debería acabar con el modificador 'def'
type.argument.0.is.not.in.its.bound.should.extend.1=El parámetro de tipo ''{0}'' no está dentro de sus límites; debería extender ''{1}''
type.argument.list.is.not.allowed.here=Aquí no se permite un argumento de lista de tipos
type.customizer.is.not.marked.as.a.resource.file=El personalizador de tipo no está marcado como archivo de recurso
type.doesnt.contain.method=El tipo ''{0}'' no contiene el método ''{1}'' que permita iterar sobre su rango
type.doesnt.implement.comparable=El tipo ''{0}'' no implementa Comparable
type.parameters.are.unexpected=Los parámetros de tipo son inesperados
unassigned.access.tooltip=La variable ''{0}'' podría no haber sido asignada
undefined.label=Etiqueta nula ''{0}''
undefined.library.version=indefinido
unexpected.attribute.type.0=Tipo de atributo inesperado: ''{0}''
unnecessary.alias.description=Alias innecesario
unnecessary.alias.fix=Eliminar alias innecesarios
unnecessary.def.explicitly.typed.only=solo informar en declaraciones de tipo explícito
unnecessary.modifier.description=Modificador `{0}` innecesario
unnecessary.modifier.remove=Se quita el ''{0}'' innecesario
unnecessary.semicolon.description=Punto y coma innecesario
unnecessary.semicolon.fix=Eliminar punto y coma innecesario
unnecessary.type=Excepción ''{0}'' innecesaria. ''{1}'' ya está declarada
unresolved.type.status=tipo ''{0}'' no resuelto
unsupported.anonymous.class.0=Las clases anónimas no están soportadas en Groovy {0}
unsupported.array.initializers=Los inicializadores de matriz no son compatibles con la versión actual
unsupported.command.syntax.0=La sintaxis de la expresión del comando no se admite en Groovy {0}
unsupported.diamonds.0=El operador diamante no es compatible con Groovy {0}
unsupported.do.while.statement=La sentencia 'do while' no está soportada en la versión actual
unsupported.dollar.slashy.string.0=Las cadenas de dólar-barra no están soportadas en Groovy {0}
unsupported.elvis.assignment=Asignación Elvis no soportada en esta versión
unsupported.expression.list.in.for.update=list.in.for.update no soportado en la expresión
unsupported.inner.class.0=Las clases internas no están soportadas en Groovy {0}
unsupported.lambda=Las lambda no son compatibles con la versión actual
unsupported.multiline.slashy.string.0=Cadena multi-línea con barra de Groovy {0} no es compatible
unsupported.multiple.variables.in.for=Actualmente la versión no soporta múltiples variables en la inicialización de 'for'
unsupported.negated.in=La negación de "in" no es compatible en la versión actual
unsupported.negated.instanceof=el instanceof negado no es soportado
unsupported.resource.list='try' con recursos no se admite en la versión actual
unsupported.safe.index.access=Acceso de índice seguro no soportado
unsupported.traits.0=Los traits no son compatibles con Groovy {0}
unsupported.tuple.application.initializer=in null
unsupported.tuple.declaration.in.for=La declaración de tupla en la inicialización 'for' no es compatible en la versión actual
unsupported.type.annotations=Las anotaciones de tipos no son compatibles en la versión actual
unused.0=no usado ''{0}''
unused.assignment.tooltip=Asignación no utilizada
unused.default.parameter.fix=Remover inicializador de parámetro por defecto
unused.default.parameter.message=Parámetro predeterminado sin utilizar
unused.import=import no utilizado
unused.variable=variable no utilizada
variable.0.might.not.have.been.initialized=La variable ''{0}'' podría no haberse inicializado
variable.already.defined=La variable ''{0}'' ya está definida
variable.can.be.final.tooltip=La variable ''{0}'' puede ser final
variable.cannot.be=variable no puede ser nulo
volatile.visibility.presentation=volátil
wildcards.are.not.allowed.in.extends.list=Los comodines no están permitidos en extends list
write.access.to.closure.variable=Acceso de escritura al campo <b>{0}</b>
wrong.closure.first.parameter.type=El cierre ''{0}'' se usa con argumentos nombrados, pero su primer parámetro ''{1}'' no se ajusta al tipo de mapa.
wrong.method.first.parameter.type=El método ''{0}'' se usa con argumentos con nombre, pero su primer parámetro ''{1}'' no se ajusta al tipo Map.
wrong.number.of.type.arguments=Número de argumentos de tipo incorrecto: {0}; se requieren {1}