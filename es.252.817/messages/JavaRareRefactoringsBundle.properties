action.Generify.description=Convertir código para usar tipos genéricos
action.Generify.text=Convertir tipos raw a genéricos…
action.RemoveMiddleman.description=Inlinear métodos delegados al campo seleccionado
action.RemoveMiddleman.text=Eliminar intermediario(_M)…
action.ReplaceTempWithQuery.description=Convertir variable seleccionada en método
action.ReplaceTempWithQuery.text=Reemplazar temporal por consulta(_Q)…
action.WrapReturnValue.description=Envolver el valor de retorno del método especificado en un objeto
action.WrapReturnValue.text=Envolver valor de retorno del método(_P)…
cannot.replace.temp.with.query.in.interface=No se puede reemplazar temporal por consulta en una interfaz
constructor.returns.can.not.be.wrapped=No se pueden envolver valores de retorno de constructores
could.not.find.selected.wrapping.class=No se pudo encontrar la clase wrapper seleccionada
declaration.s.to.be.generified=Declaración(es) a generificar {0}
delegating.field=Campo delegado
dialog.message.inner.class.with.name.already.exist=Ya existe una clase interna con el nombre ''{0}''
dialog.message.invalid.inner.class.name=''{0}'' no es un nombre válido para clase interna
dialog.message.invalid.qualified.wrapper.class.name=''{0}'' no es un nombre calificado válido para clase wrapper
dialog.message.invalid.wrapper.class.name=''{0}'' no es un nombre válido para clase wrapper
dialog.message.invalid.wrapper.class.package.name=''{0}'' no es un nombre válido para paquete de clase wrapper
dialog.message.wrapper.field.not.found=Campo wrapper no encontrado
error.wrong.caret.position.local.name=El cursor debe estar en el nombre de la variable local a refactorizar
exposed.delegation.command.name=Delegación expuesta a {0}
field.selected.is.not.used.as.a.delegate=El campo seleccionado no se usa como delegado
generify.title=Convertir tipos raw a genéricos
method.selected.returns.void=El método seleccionado retorna 'void'
method.to.wrap.returns.from.label=Método del cual envolver los valores de retorno\:
method.whose.return.are.to.wrapped=Método cuyos valores de retorno serán envueltos
references.to.be.modified.usage.view=Referencias a modificar{0, choice, 0\#(no encontradas)|1\#{0} referencia|2\#{0} referencias}{1, choice, 0\#|1\# en {1} archivo|2\# en {1} archivos}
references.to.expose.usage.view=Referencias a exponer{0, choice, 0\#(no encontradas)|1\#{0} referencia|2\#{0} referencias}{1, choice, 0\#|1\# en {1} archivo|2\# en {1} archivos}
remove.middleman=Eliminar intermediario
remove.middleman.column.header=Eliminar
remove.middleman.deleted.hierarchy.conflict={0} será eliminado. La jerarquía se romperá
remove.middleman.field.header=Campo intermediario a eliminar\:
remove.middleman.methods.to.inline.title=Métodos a inlinear(&M)
remove.middleman.title=Eliminar intermediario
remove.middleman.tooltip.warning=La eliminación romperá la jerarquía de tipos
replace.temp.with.query.title=Reemplazar temporal por consulta
the.caret.should.be.positioned.at.the.name.of.the.field.to.be.refactored=El cursor debe estar en el nombre del campo a refactorizar
there.already.exists.a.class.with.the.selected.name=Ya existe una clase con el nombre seleccionado
type.cook.command=Generificar
type.cook.drop.obsolete.casts=Eliminar casteos obsoletos(&D)
type.cook.elements.header=Alcance de generificación
type.cook.generify.objects=Generificar objetos(&O)
type.cook.leave.object.parameterized.types.raw=Dejar tipos parametrizados de Object raw(&L)
type.cook.perform.exhaustive.search=Realizar búsqueda exhaustiva(&E)
type.cook.preserve.raw.arrays=Preservar arrays raw(&A)
type.cook.produce.wildcard.types=Producir tipos wildcard(&W)
type.cook.ratio.generified={0,choice,-1\#no calculado|0\#{0,number}/{1}}
type.cook.report=Elementos generificados\: {0}, casteos eliminados\: {1}
wrap.return.value=Envolver valor de retorno
wrap.return.value.title=Envolver valor de retorno
wrapped.return.command.name=Valor de retorno envuelto en {0} para {1}()