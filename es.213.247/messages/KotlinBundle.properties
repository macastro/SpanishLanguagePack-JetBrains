fix.insert.delegation.call=Insertar llamada '' {0}()''
fix.introduce.non.null.assertion=Agregar llamadas de aserción no nulas (\! \!).
fix.remove.non.null.assertion=Eliminar aserciones innecesarias no nulas (\! \!)
fix.add.annotation.target=Agregar destino de anotación
fix.add.const.modifier='' const '' agregar modificador
fix.add.constructor.parameter=Agregar parámetro de constructor ''{0}''.
fix.make.data.class=Hacer ''{0}'' una clase de datos.
fix.add.default.constructor='' esperar '' Agregar un constructor predeterminado a la clase.
fix.add.explicit.import=Agregar declaración de importación explícita.
fix.add.function.body=Agregar cuerpo de función.
fix.use.fully.qualified.call=Utilice llamadas totalmente calificadas
fix.add.is.to.when=Agregue '' es '' antes de ''{0}''.
fix.add.new.line.after.annotations=Agregar una nueva línea después de las anotaciones
fix.make.type.parameter.reified=Refinar {0} y en línea {1}.
fix.add.return.last.expression=Agregue '' return '' a la última expresión.
fix.add.return.before.expression=Agregar '' return '' antes de la expresión.
fix.add.return.before.lambda.expression=Agregar '' ejecutar '' antes de la expresión lambda.
fix.add.semicolon.lambda.expression=Terminar la llamada anterior con punto y coma.
fix.add.spread.operator.after.sam=Agregue el operador de propagación antes de la matriz cuando pase como '' vararg ''.
fix.add.else.branch.when=Agregar otra rama.
fix.replace.with.assign.function.call=Reemplazar con la llamada ''{0}''.
fix.assign.to.property=Asignar a propiedad.
fix.change.mutability.change.to.val=Cambiar ''{0}'' a val.
fix.change.type.argument=Cambiar tipo de argumento a {0}.
fix.change.to.function.invocation=Cambio a la invocación de función.
fix.change.to.mutable.type=Cambiar el tipo a {0}.
fix.change.to.property.access.family.remove=Eliminar llamada
fix.change.to.property.access.family.change=Cambiar al acceso a la propiedad
fix.change.to.labeled.return.family=Cambiar para devolver con etiqueta
fix.change.to.labeled.return.text=Cambiar a ''{0}''
fix.change.suspend.hierarchy.add=Agrega el modificador '' suspender '' a todas las funciones en la jerarquía.
fix.change.suspend.hierarchy.remove=Elimina el modificador '' suspender '' de todas las funciones de la jerarquía.
fix.change.progress.looking.inheritors=Buscando herederos de la clase {0}…
fix.change.progress.analyzing.class.hierarchy=Analizando la jerarquía de clases…
fix.change.return.type.family=Tipo de cambio
fix.change.return.type.text.primary.constructor=Cambiar parámetro ''{0}'' tipo de constructor primario de clase ''{1}'' a ''{2}''.
fix.change.return.type.text.function=Cambiar parámetro ''{0}'' tipo de función ''{1}'' a ''{2}''.
fix.change.return.type.lambda=Cambiar el tipo de retorno de la expresión lambda a {0}.
fix.change.return.type.remove.explicit.return.type=Eliminar un tipo de retorno especificado explícitamente.
fix.change.return.type.remove.explicit.return.type.of=Elimina el tipo de devolución especificado explícitamente de {0}.
fix.change.return.type.return.type.text=Cambiar el tipo de retorno a ''{0}''.
fix.change.return.type.return.type.text.of=Cambiar el tipo de retorno de {0} a ''{1}''
fix.change.return.type.type.text=Cambiar tipo a ''{0}''
fix.change.return.type.type.text.of=Cambiar el tipo de {0} a ''{1}''
fix.change.return.type.presentation.property=Propiedad {0}
fix.change.return.type.presentation.function=Función {0}
fix.change.return.type.presentation.enclosing.function=Función de cierre
fix.change.return.type.presentation.enclosing=Incluyendo {0}
fix.change.return.type.presentation.called.function=Función llamada
fix.change.return.type.presentation.accessed={0} accedido
fix.change.return.type.presentation.called=Llamado {0}
fix.change.return.type.presentation.base=base {0}
fix.cast.expression.family=Convertir expresión
fix.cast.expression.text=Transmitir expresión ''{0}'' a ''{1}''.
fix.change.accessor.family=Cambiar tipo de acceso
fix.change.accessor.getter=Cambia el tipo de captador a {0}
fix.change.accessor.setter.parameter=Cambiar el tipo de parámetro del setter a {0}
fix.create.from.usage.dialog.title=Crear desde la ubicación de uso
fix.add.remaining.branches=Agregar ramas restantes.
fix.add.remaining.branches.with.star.import=* Agregue las ramas restantes con declaraciones de importación.
fix.add.tostring.call.family=Agregar llamada '' toString() ''
fix.add.tostring.call.text=Agregar una llamada a '' toString() ''
fix.add.tostring.call.text.safe=Agregar llamada segura ''? .toString() ''.
fix.add.star.projection.family=Agregar proyección de estrella
fix.add.star.projection.text=Agregue ''{0}''.
fix.change.to.star.projection.family=Cambiar a proyección de estrellas
fix.change.to.star.projection.text=Cambiar tipo de argumento a {0}.
fix.change.to.use.spread.operator.family=Cambiar para usar el operador de propagación
fix.change.to.use.spread.operator.text={0}'' un ''{1}
fix.change.type.family=Tipo de cambio
fix.change.type.text=Tipo de cambio de ''{0}'' a ''{1}''.
fix.add.suspend.modifier.function=Suspender {0}
fix.add.suspend.modifier.function.generic=Pausar la función de inclusión
fix.add.suspend.modifier.receiver=Tipo de pausa {0}.
fix.add.suspend.modifier.receiver.generic=Pausar tipo de receptor.
fix.add.property.to.supertype.family=Agregar propiedad al supertipo
fix.add.property.to.supertype.text=Agregue ''{0}'' a ''{1}''.
fix.add.property.to.supertype.text.generic=Agregar propiedad al supertipo...
fix.add.property.to.supertype.progress=Agregar propiedad al tipo
fix.add.property.to.supertype.choose.type=Elija el tipo
fix.add.function.parameters.change.signature.constructor=Cambiar la firma del constructor ''{0}''
fix.add.function.parameters.change.signature.function=Cambiar la firma de la función ''{0}''
fix.add.function.parameters.add.parameter.constructor={0, número, ordinal} ésimo {1,choice,1\#parameter|2\#parameter} agregar al constructor ''{2}'' hacer.
fix.add.function.parameters.add.parameter.function={0, número, ordinal} ésimo {1,choice,1\#parameter|2\#parameter} agregar a la función ''{2}'' hacer.
fix.add.function.parameters.add.parameter.generic.constructor={0,choice,1\#parameters|2\#parameters} al constructor ''{1}''
fix.add.function.parameters.add.parameter.generic.function={0,choice,1\#parameter|2\#parameter} para funcionar ''{1}''
fix.change.signature.family=Cambiar la firma de la función/constructor
fix.change.signature.function.family=Cambiar la firma de la función
fix.change.signature.function.text=Cambiar la firma de la función a ''{0}''.
fix.change.signature.function.text.generic=Cambiar la firma de la función...
fix.change.signature.function.popup.title=Seleccionar firma
fix.change.signature.lambda=Cambiar la firma de la expresión lambda
fix.change.signature.remove.parameter=Eliminar parámetro ''{0}''.
fix.change.signature.unavailable=<no disponible>
fix.change.signature.error=<error>
fix.change.signature.unnamed.parameter=Parámetros
fix.change.object.to.class=Objeto '' a '' clase
fix.add.function.supertype.family=Agregar función al supertipo
fix.add.function.supertype.text=Agregar función al supertipo...
fix.add.function.supertype.progress=Agregar función para escribir
fix.add.function.supertype.choose.type=Elija el tipo
fix.add.function.supertype.add.to={0}'' un ''{1}
fix.add.generic.upperbound.text=Agregar ''{0}'' como límite superior de ''{1}''.
fix.add.generic.upperbound.family=Agregar límite principal genérico
fix.add.modifier.inline.parameter.family=Agregue ''{0}'' al parámetro.
fix.add.modifier.inline.parameter.text=Agregue ''{0}'' al parámetro ''{1}''.
fix.add.modifier.inline.function.family=Agregar '' en línea '' a la función
fix.add.modifier.inline.function.text=Agregar '' en línea '' a la función ''{0}''.
fix.add.array.of.type.text=Agregue el contenedor {0}.
fix.add.array.of.type.family='' arrayOf '' Agregar contenedor
fix.add.loop.label.text.generic=Agregar etiqueta al bucle.
fix.add.loop.label.text=Agregue ''{0}'' a {1}.
fix.add.modifier.family=Agregar modificador
fix.add.modifier.text=Hacer {0} ''{1}''
fix.add.modifier.text.generic=''{0}'' agregar modificador
fix.add.argument.name.family=Agregar nombre al argumento
fix.add.argument.name.text.generic=Agregar nombre al argumento...
fix.add.argument.name.text=Agregar nombre al argumento ''{0}''.
fix.change.feature.support.family=Activar/desactivar la compatibilidad con {0}
fix.change.feature.support.enabled={0} Habilita el soporte.
fix.change.feature.support.enabled.warning=Habilitar el soporte {0} (mostrar advertencia).
fix.change.feature.support.disabled=Desactivar el soporte de {0}.
fix.create.expect.actual=Cree una declaración wait/actual.
fix.create.missing.actual.members=Agregar miembros reales que faltan.
fix.create.declaration.error=No se pudo crear {0}. {1}
fix.create.declaration.error.inaccessible.type=Tipo inaccesible
fix.create.declaration.error.some.types.inaccessible=Tipos no accesibles\:
fix.add.annotation.family=Agregar anotación
fix.add.annotation.text.self=''@{0} '' agregar anotación
fix.add.annotation.text.declaration=@{0} '' Agregar anotación a ''{1}
fix.add.annotation.text.containing.class=@{0} '' Agregar anotación a la clase contenedora ''{1}
fix.import=Importar
fix.import.kind.delegate.accessors=Acceso delegado.
fix.import.kind.component.functions=Funciones de los componentes
fix.import.exclude=Excluir ''{0}'' de la importación automática.
fix.move.file.to.package.family=Mover el archivo al directorio donde coincide el paquete
fix.move.file.to.package.text=Mueva el archivo a {0}.
fix.change.package.family=Cambiar el paquete en el archivo para que coincida con el directorio
fix.change.package.text=Cambie el paquete en el archivo a {0}.
fix.move.to.sealed.family=Mover un miembro de la jerarquía al paquete/módulo del padre del miembro
fix.move.to.sealed.text=Mover {0} al paquete/módulo en {1}
action.add.import.chooser.title=Importar
goto.super.chooser.function.title=Seleccionar función principal
goto.super.chooser.property.title=Seleccionar propiedad principal
goto.super.chooser.class.title=Seleccione la clase o interfaz principal
inspection.unused.receiver.parameter=El parámetro del receptor no se utiliza en absoluto.
fix.unused.receiver.parameter.remove=Eliminar parámetros duplicados del receptor.
inspection.migration.title=Migración de código
inspection.migration.profile.name=Migración
fix.create.from.usage.family=Crear desde la ubicación de uso
fix.create.from.usage.local.variable=Crear variable local ''{0}''.
overridden.marker.implementations.multiple=Hay implementaciones.
overridden.marker.implementation=Implementado en <br/>
overridden.marker.overrides.multiple=Anulado en subclases.
overridden.marker.overrides=Anulado desde. <br/>
searching.for.overriding.methods=Buscar métodos de reemplazo
overridden.marker.implementations.choose.implementation.title=Selección de implementación de {0}
overridden.marker.implementations.choose.implementation.find.usages=Propiedad reemplazada de {0}
overridden.marker.overrides.choose.implementation.title=Elija la implementación principal de {0}
overridden.marker.overrides.choose.implementation.find.usages=Mayor implementación de {0}
remove.expression=Eliminar {0}
unwrap.expression=''{0}'' desenvolver
remove.else=''{0}'' para eliminar el else.
unwrap.else=Desenvolver más en ''{0}''.
override.declaration.x.in.y={0} de {1}
override.declaration.x.implements.y=Implementar {0} en {1} a {2} en {3}.
override.declaration.x.overrides.y.in.class.list={0} anula la declaración en la siguiente clase/interfaz, {1}. ¿Le gustaría {2} declaraciones predeterminadas?
override.declaration.unused.overriding.methods.title=Miembro superior obsoleto
override.declaration.unused.overriding.methods.description=Tiene un miembro obsoleto que reemplaza un método que acaba de eliminar
override.declaration.choose.to.delete=Elija un elemento para eliminar.
override.declaration.member=Miembro
override.declaration.delete.multiple.parameters={0} es parte de la jerarquía del método. ¿Está seguro de que desea eliminar varios parámetros?
hierarchy.legend.member.is.defined.in.class=Los miembros se definen en clases.
hierarchy.legend.member.defined.in.superclass=Los miembros se definen en la clase principal, no en la clase.
hierarchy.legend.member.should.be.defined=Como la clase no es abstracta, debe definir miembros.
intention.change.package.text=Cambiar paquete
intention.extract.declarations.from.file.text=Extraer declaración del archivo actual
intention.extract.declarations.from.file.text.details=''{0}'' {1,choice, 0#| en el archivo actual 1# y extraer subclases }
kotlin.compiler.option.generate.no.warnings=&Informar advertencias del compilador
kotlin.compiler.option.additional.command.line.parameters=P&arámetros de línea de comando adicionales\:
kotlin.compiler.jvm.option.panel.title=Kotlin una JVM
kotlin.compiler.js.option.panel.title=Kotlin y JavaScript
kotlin.compiler.js.option.generate.sourcemaps=&Generar mapas de origen
kotlin.compiler.js.option.output.prefix=Archivo &anteponer al código generado\:
kotlin.compiler.js.option.output.postfix=Archivo &Agregar al código generado\:
kotlin.compiler.js.option.output.copy.files=&Copiar archivos de tiempo de ejecución de la biblioteca
android.klint.inspections.group.name=Android Lint para Kotlin
scratch.run.button=Ejecutar archivo borrador
scratch.run.from.here.button=Ejecute scratch aquí
scratch.stop.button=Dejar de ejecutar scratch
scratch.clear.button=Borrar resultado
scratch.module.combobox=Usar classpath del módulo
scratch.is.repl.checkbox=Usar REPL
scratch.is.repl.checkbox.description=Ejecutar con Kotlin REPL. Ejecuta solo las nuevas expresiones agregadas al final del scratch.
scratch.is.interactive.checkbox=Modo interactivo
scratch.is.interactive.checkbox.description=Se ejecuta {0} segundos después de dejar de escribir.
scratch.make.before.run.checkbox=Crear módulo antes de ejecutar
scratch.make.before.run.checkbox.description=Cree el módulo {0} antes de ejecutar scratch. Solo se puede acceder al código compilado en este ámbito.
scratch.inlay.output.mode=Modo de salida de incrustación\n\nLa salida se muestra justo al lado de la expresión en el editor de código. Adecuado para salida corta de una sola línea.
scratch.side.panel.output.mode.description=Modo de salida del panel lateral
scratch.side.panel.output.mode=Modo de salida del panel lateral\n\nLa salida se muestra en un panel separado. Esto es útil si la salida es larga o de varias líneas.
scratch.inlay.output.mode.description=Modo de salida de incrustación
dialog.import.on.paste.title3=Seleccione la importación para eliminar
copy.paste.reference.notification=Se agregaron {0} {0, choice,1\#import statement|2\#import statement}. <p><span><a href\=''show''> Revise las declaraciones de importación agregadas....</ A ></span>
plugin.verifier.compatibility.issue.title=Problema de compatibilidad
plugin.verifier.compatibility.issue.message=La versión instalada del complemento de Kotlin ({0}) no es compatible con {1}.\nAlgunas funciones pueden estar dañadas.\n\nVuelva a instalar el complemento de Kotlin.
plugin.updater.notification.group=Actualizar complemento de Kotlin
plugin.updater.notification.title=Kotlin
plugin.updater.notification.message=Hay disponible una nueva versión {0} del complemento Kotlin. <b><a href\="\#"> Instalar</a></b>
plugin.updater.downloading=Descargar complemento
plugin.updater.not.installed=La actualización del complemento no está instalada. <a href\="\#"> Consulte el registro para obtener más detalles</a>
plugin.updater.not.installed.misc=La actualización del complemento no está instalada. {0} <a href\="\#"> Consulte el registro para obtener más detalles</a>
plugin.updater.error.check.failed=Error al comprobar la actualización del complemento de Kotlin
plugin.updater.error.unexpected.repository.response=Respuesta inesperada del repositorio de complementos
plugin.updater.error.cant.find.plugin.version=No se pudo encontrar la versión del complemento en la respuesta del repositorio.
plugin.updater.error.custom.repository=No se pudo verificar el repositorio de complementos personalizados {0}.
quick.doc.text.enum.ordinal=Enum constante ordinal\: {0}
quick.doc.text.tailrec='' tailrec '' hace que las funciones <a href\="https\://kotlinlang.org/docs/reference/functions.html\#tail-recursive-functions"> tail sean recursivas</ a> (permite al compilador convertir la recursividad en iteración).
quick.doc.text.lateinit='' lateinit '' es el <a href\="https\://kotlinlang.org/docs/reference/properties.html\#late-initialized-properties-and-variables"> constructor Permite la inicialización de propiedades externas no nulas</a>.
quick.doc.no.documentation=No hay documentación disponible.
quick.doc.section.deprecated=Funciones obsoletas\:
quick.doc.section.replace.with=Reemplazar con\:
quick.doc.section.java.declaration=Declaración de Java\:
action.j2k.name=Convertir Java a Kotlin
action.j2k.task.name=Convertir archivo de Java a Kotlin
action.j2k.correction.investigate=Investigar errores
action.j2k.correction.proceed=Conversión en curso
action.j2k.correction.required=Esta transformación puede requerir que corrija algo de código en el resto de su proyecto. ¿Le gustaría encontrar el código y arreglarlo juntos?
action.j2k.correction.errors.single=''{0}'' contiene un error de sintaxis, que puede dar como resultado resultados de conversión incorrectos.
action.j2k.correction.errors.multiple=''{0}'' y {1} otros archivos Java contienen errores de sintaxis, que pueden resultar en conversiones incorrectas.
action.j2k.error.cant.save.result=No se pudo guardar el resultado de la conversión {0}.
action.j2k.error.cant.find.document=No se encontró documentación para ''{0}''.
action.j2k.error.read.only=El archivo ''{0}'' es de solo lectura
action.j2k.errornothing.to.convert=Nada para convertir. <br> No se puede encontrar el archivo Java grabable.
formatter.settings.title=Configuración del formateador de Kotlin
action.generate.functions.already.defined=La función {0} ya está definida para la clase {1}. ¿Está seguro de que desea eliminar esa función y continuar?
action.generate.equals.choose.equals=Seleccionar propiedades para incluir en' 'equals ()'
action.generate.equals.choose.hashcode=Seleccionar propiedades para incluir en' 'hashCode ()'
action.generate.secondary.constructor.choose.properties=Seleccionar propiedades para inicializar con el constructor
action.generate.secondary.constructor.error.already.exists=El constructor ya existe.
action.generate.test.support.choose.framework=Elija un marco
action.generate.test.support.choose.test.name=Elija el nombre de la prueba\:
action.generate.test.support.edit.template=Editar plantilla
action.generate.test.support.error.no.template.found=No se pudo encontrar la plantilla para {0}. {1}
action.generate.test.support.error.cant.convert.java.template=No se pudo convertir la plantilla Java a Kotlin.
action.generate.test.support.error.cant.generate.method=No se pudo crear el método {0}.
action.generate.tostring.name=Crear toString()
action.generate.tostring.template.single=Plantilla única
action.generate.tostring.template.multiple=Varias plantillas con conexiones
action.generate.tostring.choose.implementation=Elija implementación\:
action.generate.tostring.generate.super.call=Generar llamada a super.toString()
action.new.file.text=Clase/Archivo Kotlin
action.new.file.description=Crear una nueva clase o archivo de Kotlin
action.new.file.dialog.title=Nuevas clases/archivo Kotlin
action.new.file.dialog.file.title=Archivo
action.new.file.dialog.class.title=Clase
action.new.file.dialog.data.class.title=Clase de datos
action.new.file.dialog.sealed.class.title=Clase sellada
action.new.file.dialog.annotation.title=Anotación
action.new.file.dialog.interface.title=Interfaz
action.new.file.dialog.sealed.interface.title=Interfaz sellada
action.new.file.dialog.enum.title=Clase Enum
action.new.file.dialog.object.title=Objeto
action.new.file.error.empty.name=Debe tener un nombre.
action.new.file.error.empty.name.part=El nombre no debe contener espacios en blanco.
action.new.script.name=Guión de Kotlin
action.new.script.description=Cree un nuevo script Kotlin.
action.new.script.dialog.title=Nuevo script de Kotlin
action.new.worksheet.name=Hoja de trabajo de Kotlin
action.new.worksheet.description=Cree una nueva hoja de trabajo de Kotlin
action.new.worksheet.dialog.title=Nueva hoja de trabajo de Kotlin
breadcrumbs.tooltip.indexing=Indexación…
copy.paste.resolve.references=Resolver referencias pegadas
type.provider.anonymous.object=Objeto anónimo
type.provider.unknown.type=Tipo desconocido
type.provider.smart.cast.from=(transmisión inteligente de {0})
type.provider.no.expression.found=Expresión no encontrada
optimize.imports.collect.unused.imports=Recopilar declaraciones de importación no utilizadas
optimize.imports.task.removing.redundant.imports=Eliminar declaraciones de importación duplicadas
kdoc.section.title.receiver=Receptor
kdoc.section.title.parameters=Parámetros
kdoc.section.title.returns=Devoluciones
kdoc.section.title.throws=Procesando
kdoc.section.title.author=Autor
kdoc.section.title.properties=Propiedades
kdoc.section.title.constructor=Constructor
kdoc.section.title.since=Hora de inicio
kdoc.section.title.suppress=Suprimir
kdoc.section.title.samples=Muestras
kdoc.section.title.see.also=Temas relacionados
kdoc.comment.unresolved=Sin resolver
livetemplate.description.main=Función main ()
livetemplate.description.soutp=Salida de los nombres y valores de los parámetros de la función a System.out.
livetemplate.description.iter=Iterar sobre un elemento iterable (bucle for-in).
livetemplate.description.ifn=Inserte la expresión '' if null ''.
livetemplate.description.inn=Inserte la expresión '' si no es nulo ''.
livetemplate.description.void=La función no devuelve nada
livetemplate.description.fun0=Función sin parámetros
livetemplate.description.fun1=Función con 1 parámetro
livetemplate.description.fun2=Función con 2 parámetros
livetemplate.description.interface=Interfaz
livetemplate.description.singleton=único
livetemplate.description.closure=Cierre (función sin nombre)
livetemplate.description.anonymous=Clase anónima
livetemplate.description.exfun=Función de extensión
livetemplate.description.exval=Propiedad extendida de solo lectura
livetemplate.description.exvar=Propiedades extendidas de lectura/escritura
hints.progress.calculating.parameter.info=Calculando la información de los parámetros
hints.settings.common.items=Mostrar sugerencias para\:
hints.settings.types=Tipos
hints.settings.types.property=Tipos de propiedad
hints.settings.types.variable=Tipos de variables locales
hints.settings.types.return=Tipo de retorno de función
hints.settings.types.parameter=Tipos de parámetros de función
hints.settings.lambdas=Lambdas
hints.settings.lambda.return=Expresión de retorno
hints.settings.lambda.receivers.parameters=Receptores y parámetros implícitos
hints.settings.suspending=Suspender llamadas
hints.title.argument.name.enabled=Nombre del argumento
presentation.text.paren=({0})
presentation.text.in.container.paren=(dentro de {0})
presentation.text.in.container={0} de {1}
presentation.text.for.receiver.in.container.paren=(objetivo {0} dentro de {1})
presentation.text.object.in.container={0} mi objeto
project.view.class.initializer=\ inicializador de clase
project.view.class.error.name=Nombre no proporcionado
copy.text.adding.imports=Añadiendo declaraciones de importación...
copy.text.clipboard.content.seems.to.be.java.code.do.you.want.to.convert.it.to.kotlin=El contenido del portapapeles parece ser código Java. ¿Le gustaría convertir a Kotlin?
copy.text.copied.kotlin.code=Código Kotlin copiado
copy.text.resolving.references=Resolviendo referencias...
copy.title.convert.code.from.java=Convertir código en Java
editor.checkbox.title.auto.add.val.keyword.to.data.inline.class.constructor.parameters=Agregar automáticamente la palabra clave val a los parámetros del constructor de clases en línea/datos
editor.checkbox.title.convert.pasted.java.code.to.kotlin=Convertir código Java pegado a Kotlin
editor.checkbox.title.don.t.show.java.to.kotlin.conversion.dialog.on.paste=No mostrar en el diálogo de conversión de Java a Kotlin al pegar
editor.title.kotlin=Kotlin
facet.checkbox.text.use.project.settings=Usar la configuración del proyecto
facet.column.name.options=Opciones
facet.column.name.plugin=Complementos
facet.error.text.at.least.one.target.platform.should.be.selected=Debe seleccionar una o más plataformas de destino.
facet.label.text.selected.target.platforms=Plataformas de destino seleccionadas\:
facet.label.text.target.platform=Plataforma de destino\:
facet.label.text.the.project.is.imported.from.external.build.system.and.could.not.be.edited=El proyecto se importó desde un sistema de compilación externo y no se puede editar.
facet.link.text.edit.project.settings=Editar la configuración del proyecto
facet.name.compiler.plugins=Complementos del compilador
facet.name.general=General
facet.text.following.arguments.are.redundant=Los siguientes argumentos son redundantes. {0}
facet.text.following.arguments.override.facet.settings=Los siguientes argumentos anulan la configuración de facetas. {0}
facet.text.following.options.are.not.correct=Las siguientes opciones son incorrectas.
facet.text.multiplatform=Multiplataforma
find.usages.progress.text.declaration.superMethods=Resolviendo el método principal...
formatter.button.text.use.import.with.when.at.least=Usar declaraciones de importación con '' * '' cuando
formatter.button.text.use.import.with=Usando una declaración de importación con '' * ''
formatter.button.text.use.single.name.import=Usar declaración de importación de nombre único
formatter.checkbox.text.insert.imports.for.nested.classes=Insertar declaraciones de importación para clases anidadas
formatter.checkbox.text.use.trailing.comma=Usar coma al final
formatter.text.names.used=\ Nombres utilizados
formatter.text.use.defaults.from=Usar valores predeterminados\:
formatter.title.after.colon.before.declaration.type=Después de dos puntos, antes del tipo de declaración
formatter.title.after.colon.in.new.type.definition=Después de dos puntos en la nueva definición de tipo
formatter.title.align.when.branches.in.columns=Alinear '' cuando '' se ramifica en columnas
formatter.title.around.arrow.in.function.types=Alrededor de flechas de tipos de funciones
formatter.title.around.arrow.in="when" alrededor de la flecha en la cláusula
formatter.title.around.when.branches.with=Alrededor de la rama '' cuando '' con {}
formatter.title.before.declaration.with.comment.or.annotation=Antes de la declaración anotada o anotada
formatter.title.before.colon.after.declaration.name=Antes de los dos puntos, después del nombre de la declaración
formatter.title.before.colon.in.new.type.definition=Antes de los dos puntos en la nueva definición de tipo
formatter.title.before.lambda.arrow=Antes de la flecha lambda
formatter.title.chained.function.calls=Llamar a funciones encadenadas
formatter.title.elvis.expressions=Expresiones de Elvis
formatter.title.expression.body.functions=Funciones del cuerpo de la expresión
formatter.title.function.annotations=Anotaciones de funciones
formatter.title.function.call.arguments=Argumentos de llamada a función
formatter.title.function.declaration.parameters=Parámetros de declaración de función
formatter.title.function.parentheses=Paréntesis de funciones
formatter.title.in.simple.one.line.methods=Un método simple de una línea
formatter.title.java.statics.and.enum.members=Miembros de enumeración y estática de Java
formatter.title.load.save=Cargar/Guardar
formatter.title.other=Otro
formatter.title.trailing.comma=Coma final
formatter.title.property.annotations=Anotaciones de propiedad
formatter.title.put.left.brace.on.new.line=Coloque la llave izquierda en la nueva línea
formatter.title.range.operator=Operador de rango (..)
formatter.title.top.level.symbols=Símbolos principales
formatter.title.use.continuation.indent.in.conditions=Utilice sangría continua en condiciones
formatter.title.use.continuation.indent=Usar sangría continua
formatter.title.when.parentheses=''cuándo'' paréntesis
formatter.title.when.statements=Sintaxis ''cuándo''
hierarchy.text.anonymous=[anónimo]
hierarchy.text.in=\{0} mi
highlighter.action.text.go.to.actual.declarations=Ir a la declaración real
highlighter.action.text.go.to.expected.declaration=Ir a la declaración esperada
highlighter.action.text.go.to.implementations=Ir a Implementación
highlighter.action.text.go.to.overridden.methods=Ir al método anulado
highlighter.action.text.go.to.overridden.properties=Ir a propiedad anulada
highlighter.action.text.go.to.subclasses=Ir a la subclase
highlighter.action.text.go.to.super.method=Ir al método principal
highlighter.action.text.go.to.super.property=Ir a la propiedad principal
highlighter.descriptor.text.android.extensions.property=Propiedades y variables //Propiedades de integración de extensiones de Android
highlighter.descriptor.text.annotation=Anotación//nombre de la anotación
highlighter.descriptor.text.annotation.attribute.name=Anotación//Nombre de propiedad de anotación
highlighter.descriptor.text.arrow=Paréntesis y operadores//flechas
highlighter.descriptor.text.builtin.annotation=Palabra clave//Controlador
highlighter.descriptor.text.builtin.keyword.val=Palabra clave//''val''
highlighter.descriptor.text.builtin.keyword.var=Palabra clave//''var''
highlighter.descriptor.text.builtin.keyword=Palabra clave//Palabra clave
highlighter.descriptor.text.captured.variable=Propiedades y Variables//Variables y valores capturados en cierres
highlighter.descriptor.text.closure.braces=Paréntesis y operadores//Paréntesis y flechas de expresión lambda
highlighter.descriptor.text.colon=Paréntesis y operadores//dos puntos
highlighter.descriptor.text.constructor.call=Función//Llamada al constructor
highlighter.descriptor.text.double.colon=Paréntesis y operadores//Doble colon
highlighter.descriptor.text.dynamic.fun.call=Función // Llamada de función dinámica
highlighter.descriptor.text.dynamic.property=Propiedades y variables//Propiedades dinámicas
highlighter.descriptor.text.enumEntry=Clases e interfaces//Elementos de enumeración
highlighter.descriptor.text.exclexcl=Paréntesis y operadores // Afirmación no nula
highlighter.descriptor.text.extension.fun.call=Función//Llamada de función extendida
highlighter.descriptor.text.extension.property=Propiedades y variables//Propiedades extendidas
highlighter.descriptor.text.field=Propiedades y variables//Variables de campo de respaldo
highlighter.descriptor.text.fun.call=Función//Llamada de función
highlighter.descriptor.text.fun=Función//Declaración de función
highlighter.descriptor.text.instance.property.custom.property.declaration=Propiedades y variables // Propiedades de instancia con declaraciones de propiedades personalizadas
highlighter.descriptor.text.instance.property=Propiedades y variables//Propiedades de instancia
highlighter.descriptor.text.it=Parámetros//Parámetros predeterminados de la expresión lambda
highlighter.descriptor.text.kdoc.comment=Comentarios//KDoc//Comentarios de KDoc
highlighter.descriptor.text.kdoc.tag=Comentarios//KDoc//Etiqueta KDoc
highlighter.descriptor.text.kdoc.value=Comentarios//KDoc//Enlaces dentro de etiquetas KDoc
highlighter.descriptor.text.label=Etiqueta
highlighter.descriptor.text.local.variable=Propiedades y variables//Variables o valores locales
highlighter.descriptor.text.named.argument=Argumento con nombre
highlighter.descriptor.text.object=Clases e Interfaces//Objetos
highlighter.descriptor.text.enum=Clases e interfaces//Enumeraciones
highlighter.descriptor.text.package.fun.call=Función // Llamada de función a nivel de paquete
highlighter.descriptor.text.package.property.custom.property.declaration=Propiedades y variables//Propiedades a nivel de paquete con declaraciones de propiedades personalizadas
highlighter.descriptor.text.package.property=Propiedades y variables//Propiedades a nivel de paquete
highlighter.descriptor.text.quest=Paréntesis y operadores//Tipo Marcador de posibilidad de valor nulo
highlighter.descriptor.text.safe.access=Paréntesis y operadores//Período de acceso seguro
highlighter.descriptor.text.smart.cast.receiver=Smart cast//receptor implícito de smart cast
highlighter.descriptor.text.smart.cast=Reparto inteligente//valor de reparto inteligente
highlighter.descriptor.text.smart.constant=Reparto inteligente//constante inteligente
highlighter.descriptor.text.string.escape=String// escapando dentro de paréntesis de cadena y plantilla
highlighter.descriptor.text.suspend.fun.call=Función//Pausar llamada a función
highlighter.descriptor.text.synthetic.extension.property=Propiedades y variables//Propiedades de extensión integradas
highlighter.descriptor.text.typeAlias=Clases e interfaces//Alias de tipo
highlighter.descriptor.text.var=Propiedades y variables//Var (variable variable, parámetro o propiedad)
highlighter.descriptor.text.variable.as.function.call=Propiedades y variables//Variables como llamadas a funciones
highlighter.descriptor.text.variable.as.function.like.call=Propiedades y variables // Variables como llamadas como funciones
highlighter.message.suspend.function.call=Pausar llamada a función
highlighter.message.suspending.iteration=Pausa Repetir
highlighter.name.dsl.markers=Marcador DSL
highlighter.name.dsl=dsl//
highlighter.name.implemented.declaration=Declaración implementada
highlighter.name.implementing.declaration=Implementación de la declaración
highlighter.name.kotlin.line.markers=Marcadores de línea de Kotlin
highlighter.name.multiplatform.actual.declaration=Manifiesto Real Multiplataforma
highlighter.name.multiplatform.expect.declaration=Declaración de expectativas multiplataforma
highlighter.name.overridden.declaration=Declaración redefinida
highlighter.name.overriding.declaration=Anular declaración
highlighter.name.style=Estilo
highlighter.notification.text.navigation.to.overriding.classes.is.not.possible.during.index.update=La navegación que anula una clase no es posible durante una actualización de índice.
highlighter.prefix.text.has.actuals.in=Real incluido
highlighter.text.click.for.navigate=Haga clic en {0} para navegar
highlighter.text.has.functional.implementations=Incluye implementación de funciones.
highlighter.text.implements=Avatar
highlighter.text.in=''{1}'' en mi {0}
highlighter.text.modules=\({0} módulo)
highlighter.text.or.press=Presione \ o {0}
highlighter.text.overrides=Reiniciar
highlighter.title.actuals.for=Real para {0}
highlighter.title.choose.actual.for=Selección real para {0}
highlighter.title.choose.expected.for=Seleccione los elementos necesarios para {0}
highlighter.title.expected.for=Expectativas para {0}
highlighter.title.overriding.declarations.of=Anular la declaración de {0}
highlighter.title.searching.for.overriding.declarations=Buscar declaraciones que anulen
highlighter.title.searching.for.overriding.methods=Buscar métodos primordiales
highlighter.tool.tip.has.declaration.in.common.module=Hay una declaración en el módulo común.
highlighter.tool.tip.marker.annotation.for.dsl=Anotaciones de marcador para DSL
highlighter.tool.tip.text.function=Función
highlighter.tool.tip.text.property=Propiedades
highlighter.tool.tip.text.recursive.call=Llamada recursiva
highlighter.tool.tip.text.run.test=Ejecutar prueba
import.optimizer.notification.text.unused.imports.not.found=No se puede encontrar una declaración de importación obsoleta.
import.optimizer.progress.indicator.text.collect.imports.for=Recopile declaraciones de importación para {0}.
import.optimizer.text.import={0,choice, 0\#importar declaración|2\#importar declaración}
import.optimizer.text.non.zero=Elimine {0} {1} {2,choice, 0\#|1\# y agregue {2} {3}}
import.optimizer.text.zero=Declaraciones de importación reordenadas
import.progress.text.resolve.imports=Encuentre todas las declaraciones de importación...
version.title.no.runtime.found=Tiempo de ejecución no encontrado
version.dialog.message.is.not.found.make.sure.plugin.is.properly.installed=No se pudo encontrar {0}. Asegúrese de que el complemento esté instalado correctamente.
version.message.is.deprecated.since.1.2.0.and.should.be.replaced.with={0} está obsoleto desde 1.2.0 y debe reemplazarse por {1}.
update.name.android.studio=Estudio Android
update.reason.text.exception.during.verification=Se produjo una excepción durante la verificación {0}.
update.reason.text.no.verified.versions.for.this.build=No hay versiones confirmadas para esta compilación.
update.reason.text.unable.to.connect.to.compatibility.verification.repository=No se puede conectar al repositorio de verificación de compatibilidad.
update.reason.text.unable.to.parse.compatibility.verification.metadata=No se pudieron analizar los metadatos de la verificación de compatibilidad.
update.reason.text.version.to.be.verified=Necesitas verificar la versión.
test.integration.button.text.cancel=Cancelar
test.integration.button.text.rewrite=Volver a escribir
test.integration.message.text.create.test.in.the.same.source.root=¿Le gustaría crear pruebas desde la misma raíz de origen?
test.integration.message.text.kotlin.class=La clase Kotlin ''{0}'' ya existe. ¿Te gustaría actualizar?
test.integration.title.no.test.roots.found=Raíz de prueba no encontrada
slicer.text.in=A mí
slicer.text.tracking.enclosing.lambda=\ (traza lambda adjunta)
slicer.text.tracking.lambda.calls=\ (rastreo de llamadas lambda)
slicer.text.tracking.lambda.argument=\ (seguimiento de parámetros lambda)
slicer.text.tracking.lambda.receiver=\ (traza del receptor lambda)
slicer.title.dataflow.from.here=Flujo de datos desde aquí
slicer.title.dataflow.to.here=Los datos fluyen aquí
slicer.tool.tip.text.variable.dereferenced=Variable desreferenciada
script.action.text.ignore=Ignorar
script.action.text.open.settings=Configuración abierta
script.action.text.show.all=Mostrar todo
script.name.kotlin.scripting=Secuencia de comandos Kotlin
script.progress.text.kotlin.scanning.dependencies.for.script.definitions=Kotlin\: Recuperando dependencias para la definición de script...
script.text.multiple.script.definitions.are.applicable.for.this.script=Se pueden aplicar varias definiciones de script a este script. Se utiliza {0}.
roots.description.text.update.source.roots.for.non.jvm.modules.in.kotlin.project=Actualice la raíz de origen para los módulos que no son JVM en su proyecto Kotlin.
reporter.button.text.ignore=Ignorar
reporter.button.text.update=Actualizar
reporter.message.text.you.re.running.kotlin.plugin.version=La versión del complemento Kotlin que se ejecuta actualmente es {0} y la última versión es {1}.
reporter.text.can.t.report.exception.from.patched.plugin=No se pueden informar excepciones del complemento de parche.
reporter.title.update.kotlin.plugin=Actualizar del complemento de Kotlin
configuration.action.text.ignore=Ignorar
configuration.action.text.update=Actualizar
configuration.description.always=Siempre
configuration.description.amd=AMD
configuration.description.commonjs=JS común
configuration.description.never=Nunca
configuration.description.plain.put.to.global.scope=General (implementado globalmente)
configuration.description.umd.detect.amd.or.commonjs.if.available.fallback.to.plain=UMD (detecta AMD o CommonJS si está disponible y vuelve a Common)
configuration.description.when.inlining.a.function.from.other.module.with.embedded.sources=Al insertar una función de otro módulo que ha incluido la fuente
configuration.error.text.shouldn.t.add.null.urls.to.custom.repositories=No debe agregar URL nulas a su repositorio personalizado.
configuration.feature.text.new.experimental.project.wizard=Asistente para nuevos proyectos experimentales
configuration.feature.text.new.java.to.kotlin.converter=Nuevo conversor de Java a Kotlin
configuration.message.enter.fully.qualified.method.name=Ingrese el nombre completo del método\:
configuration.message.text.a.new.version.is.available=Hay una nueva versión {0} disponible.
configuration.message.text.a.new.version.is.found=Se ha encontrado una nueva versión {0}, pero no se ha comprobado si hay {1}.
configuration.message.text.update.check.failed=La verificación de actualización falló. {0}
configuration.message.text.you.have.the.latest.version.of.the.plugin.installed=Está instalada la última versión del complemento.
configuration.message.verifier.disabled=(el verificador está deshabilitado)
configuration.migration.text.api.version=Versión de API\: {0} -> {1}
configuration.migration.text.detected.migration=Migración detectada\:
configuration.migration.text.language.version=Versión de idioma\: {0} -> {1}
configuration.migration.text.migrations.for.kotlin.code.are.available=Las migraciones están disponibles para el código Kotlin.
configuration.migration.text.run.migrations=Ejecutar migración
configuration.migration.text.standard.library=Biblioteca estándar\: {0} -> {1}
configuration.migration.title.kotlin.migration=Migración de Kotlin
configuration.name.kotlin.compiler=Compilador kotlin
configuration.name.kotlin=Kotlin
configuration.name.method=Método
configuration.status.text.installation.failed=Instalación fallida
configuration.status.text.installing=Instalación...
configuration.text.and=Y
configuration.text.other.s=Otros
configuration.text.patched.original={0}(Parche completo\! Antes de la aplicación\: {1})
configuration.text.the.compiler.bundled.to.kotlin.plugin=El compilador incluido con el complemento Kotlin ({0}) es más antiguo que el compilador externo utilizado para crear el módulo.
configuration.text.this.may.cause.different.set.of.errors.and.warnings.reported.in.ide.p=Esto puede dar lugar a un conjunto diferente de errores y advertencias informados en el IDE.
configuration.title.choose.output.directory=Seleccionar directorio de salida
configuration.title.early.access.preview.1.5.x=Versión de prueba de acceso anticipado 1.5.x
configuration.title.edit.exclusion=Editar excluir
configuration.title.kotlin.compiler.js.option.output.postfix.browse.title=Seleccionar archivos para agregar al código generado
configuration.title.kotlin.compiler.js.option.output.prefix.browse.title=Seleccione un archivo para agregar antes del código generado
configuration.title.outdated.bundled.kotlin.compiler=Compilador de paquetes Kotlin antiguo
configuration.title.stable=Estable
configuration.warning.text.following.modules.override.project.settings=Los siguientes módulos anulan la configuración del proyecto:
configuration.warning.text.modules.override.project.settings=El módulo {0} anula la configuración del proyecto.
configuration.warning.text.language.version.unsupported=La versión de idioma {0} ya no es compatible
configuration.warning.text.api.version.unsupported=La versión de API {0} ya no es compatible
configuration.kotlin.code.style=Estilo de código Kotlin
configuration.notification.update.code.style.to.official=¿Le gustaría actualizar la configuración de estilo de su código Kotlin a la configuración recomendada?
configuration.apply.new.code.style=Aplicar estilo de código
configuration.do.not.suggest.new.code.style=No volver a mostrar
configuration.is.resolve.module.per.source.set=Se detectó el modo de importación de Gradle existente
configuration.update.is.resolve.module.per.source.set=El IDE está actualmente configurado para generar un único módulo por proyecto Gradle. Este modo no es compatible con proyectos multiplataforma de Kotlin, que requieren un único módulo por conjunto de fuentes de Gradle.
configuration.apply.is.resolve.module.per.source.set=Edita y vuelve a importar tu proyecto
configuration.do.not.suggest.update.is.resolve.module.per.source.set=No volver a mostrar
0.1.is.never.used={0} ''{1}'' nunca se utiliza.
0.has.detected.1.code.fragments.in.2.that.can.be.replaced.with.3={0} detectó {1} código {1,choice,1\#piece|2\#piece} en {2} que puede reemplazarse por {3}. ¿Le gustaría revisar y cambiar {1,choice,1\#code snippet|2\#code snippet}?
0.usages.are.not.supported.by.the.inline.refactoring.they.won.t.be.processed=El uso {0} no se procesará porque no es compatible con la refactorización en línea.
0.will.become.invisible.after.extraction={0} se volverá invisible después de la extracción.
0.will.no.longer.be.accessible.after.extraction={0} quedará inaccesible después de la extracción.
action.text.append=Añadir
action.text.cancel=Cancelar
action.text.overwrite=Sobrescribir
button.text.move.nested.class.0.to.upper.level=Mover la clase anidada {0} a un nivel superior
button.text.move.nested.class.0.to.another.class=Mover la clase anidada {0} a otra clase
cannot.extract.method=No se encontró ninguna frase para extraer.
cannot.extract.super.call=No se puede extraer la llamada de los padres.
cannot.inline.property.with.accessor.s.and.backing.field=Las propiedades con descriptores de acceso y campos de respaldo no se pueden insertar en línea.
cannot.introduce.parameter.of.0.type=No se puede insertar un parámetro de tipo ''{0}''.
cannot.refactor.expression.has.unit.type=No se puede insertar una expresión de tipo unidad.
cannot.refactor.no.container=La refactorización no es posible aquí.
cannot.refactor.no.expression=La refactorización no se puede realizar sin expresiones.
cannot.refactor.no.type=La refactorización no se puede realizar sin tipos.
cannot.refactor.not.expression.to.extract=No se pudo encontrar la expresión a extraer.
cannot.refactor.not.expression=No se pudo encontrar la expresión a insertar.
cannot.refactor.package.expression=No se puede insertar la referencia del paquete.
cannot.refactor.syntax.errors=La refactorización no es posible debido a un código incorrecto.
cannot.refactor.synthesized.function=No se puede refactorizar la función de unión ''{0}''.
checkbox.text.declare.with.var=&Declarar con var
checkbox.text.delete.empty.source.files=&Eliminar archivos fuente vacíos
checkbox.text.extension.property=Propiedades e&xtendidas\:
checkbox.text.introduce.default.value=Insertar valor predeterminado
checkbox.text.open.moved.files.in.editor=Abrir miembro movido en el editor
checkbox.text.replace.all.occurrences.0=Reemplazar todos los usos ({0})
checkbox.text.search.references=&Recuperar referencia
checkbox.text.specify.type.explicitly=Especificar el tipo explícitamente
checkbox.text.update.package.directive=Actualizar directivas de paquetes (archivos Kotlin)
column.name.receiver=Receptor\:
column.name.default.parameter=Parámetros predeterminados:
column.name.val.var=Val/Var
declarations.are.used.outside.of.selected.code.fragment=La siguiente declaración se utiliza fuera del fragmento de código seleccionado:
declarations.will.move.out.of.scope=Las siguientes declaraciones no se pueden utilizar fuera del cuerpo de la función extraída:
description.a.reference.to.extracted.type.parameter=Referencia al parámetro de tipo extraído
error.cant.refactor.vararg.functions=Las funciones con argumentos variables no se pueden refactorizar.
error.hint.text.cannot.inline.0.from.a.decompiled.file=''{0}'' en el archivo descompilado no se puede insertar.
error.text.can.t.change.signature.of.method=La firma del método {0} no se puede cambiar.
error.text.can.t.copy.class.to.the.containing.file=Las clases no se pueden copiar en archivos de inclusión.
error.text.can.t.generate.0.1=No se pudo crear {0}. {Uno}
error.text.can.t.introduce.lambda.parameter.for.this.expression=No puede insertar un parámetro lambda para esta expresión.
error.text.can.t.introduce.property.for.this.expression=No se puede insertar una propiedad para esta expresión.
error.text.different.name.expected=Estoy esperando un nombre diferente.
error.text.expression.has.no.type=La expresión no tiene tipo.
error.text.extraction.from.expect.class.is.not.yet.supported=Aún no se admite la extracción de la clase esperada.
error.text.extraction.from.non.jvm.class.is.not.yet.supported=Aún no se admite la extracción de clases que no sean JVM.
error.text.inline.function.is.not.supported.for.functions.with.multiple.return.statements=La inserción de funciones no es compatible con funciones con múltiples declaraciones de devolución.
error.text.inline.function.is.not.supported.for.functions.with.return.statements.not.at.the.end.of.the.body=La inserción de funciones no es compatible con funciones que no tienen una declaración de retorno al final de su cuerpo.
error.text.interface.cannot.be.extracted.from.an.annotation.class=Las interfaces no se pueden extraer de clases anotadas
error.text.introduce.parameter.is.not.available.for.default.value=La inserción de parámetros no se puede utilizar para los valores predeterminados.
error.text.introduce.parameter.is.not.available.inside.of.annotation.entries=La inyección de parámetros no se puede utilizar dentro de un elemento de anotación
error.text.invalid.default.receiver.value=Valor de receptor predeterminado no válido
error.text.invalid.name=Nombre equivocado
error.text.invalid.parameter.name=Nombre de parámetro no válido
error.text.invalid.parameter.type=Tipo de parámetro no válido
error.text.invalid.receiver.type=Tipo de receptor no válido
error.text.invalid.return.type=Tipo de devolución no válido
error.text.no.type.to.refactor=No hay tipos para refactorizar.
error.text.refactoring.is.not.applicable.in.the.current.context=La refactorización no se puede aplicar en el contexto actual.
error.text.superclass.cannot.be.extracted.from.an.annotation.class=Las clases principales no se pueden extraer de las clases anotadas
error.text.type.reference.is.expected=Se requiere una referencia de tipo.
error.types.in.generated.function=No puede crear una función con un tipo de devolución no válido.
error.wrong.caret.position.function.or.constructor.name=El cursor debe estar en la posición del nombre de la función o del constructor que se va a refactorizar.
extract.function=Extracción de funciones
family.name.update.usages.on.declarations.cut.paste=Actualizar la ubicación de uso al cortar/pegar declaraciones
file.does.not.exist=El archivo {0} no existe.\n¿Le gustaría crearlo?
function.name.is.invalid=El nombre de la función es incorrecto.
introduce.parameter=Insertar parámetro
introduce.property=Insertar propiedad
introduce.type.parameter.to.declaration=Insertar parámetros de tipo en las declaraciones.
introduce.type.parameter=Insertar parámetro de tipo
introduce.variable=Insertar variable
label.text.default.receiver.value=Valor predeterminado del receptor (&D)\:
label.text.destination.directory=Directorio de destino\:
label.text.file.name=&Nombre del archivo\:
label.text.introduce.as=Insertar &yo\:
label.text.name=Nombre(&N)\:
label.text.package.name=&Nombre del paquete\:
label.text.receiver.type=Tipo de receptor (&T)\:
label.text.target.file.name=Nombre del archivo de destino\:
label.text.to.file=Archivo de destino &\:
label.text.to.package=Como &paquete\:
label.text.to.class=A clase\:
label.text.to.object=Al objeto\:
class.name.prompt=Nombre de clase (&N)\:
search.for.text.occurrences=&Buscar dónde se utiliza el texto
search.in.comments.and.strings=Buscar en comentarios y cadenas
parameter.name.prompt=Nombre del parámetro &M\:
pass.outer.class.instance.as.parameter=Pasar una instancia de una clase externa como parámetro
label.text.type=Escriba &T\:
label.text.move.expect.actual.counterparts=Mover correspondencia esperada/real
label.text.visibility=&Visibilidad\:
member.info.abstract.0=Resumen {0}
member.info.companion.0=Compañero {0}
message.change.signature.is.not.applicable.to.dynamically.invoked.functions=Los cambios de firma no se aplican a funciones llamadas dinámicamente.
error.hint.the.read.only.declaration.cannot.be.changed=Esta declaración de solo lectura no se puede cambiar
error.hint.cannot.modify.0.declaration.from.1.file=No se puede cambiar la declaración ''{0}'' en el archivo {1}''
message.do.not.show.for.local.variables.in.future=Posteriormente no se da ninguna indicación para las variables locales.
message.text.return.type.cannot.be.resolved=No se pudo resolver el tipo de devolución ''{0}''.\n¿Quieres continuar?
message.text.property.type.cannot.be.resolved=No se pudo resolver el tipo de propiedad ''{0}''.\n¿Quieres continuar?
message.text.property.receiver.type.cannot.be.resolved=El tipo de receptor de propiedad ''{0}'' no se pudo resolver.\n¿Quiere continuar?
message.text.type.alias.0.is.never.used=El alias de tipo ''{0}'' nunca se utiliza.
message.type.for.cannot.be.resolved=No se pudo resolver el tipo ''{0}'' de ''{1}''.\n¿Quieres continuar?
name.extract.interface=Extracción de interfaz
name.inline.type.alias=Alias de tipo en línea
name.introduce.import.alias=Insertar alias de declaraciones de importación
name.introduce.lambda.parameter=Insertar parámetros Lambda
name.introduce.parameter1=Insertar parámetro
name.introduce.type.alias=Insertar alias de tipo
naming.convention.will.be.violated.after.rename=Cambiar el nombre viola las reglas de nomenclatura.
non.kotlin.usage.0=Uso sin Kotlin\: {0}
parameter.name.is.invalid=El nombre del parámetro ''{0}'' no es válido
parameter.type.is.invalid=El tipo de parámetro ''{0}'' no es válido
parameter.types.are.not.denotable=El método no se puede extraer para los siguientes tipos porque no son visibles en el ámbito de destino:
refactoring.move.non.kotlin.file=El objetivo debe ser un archivo Kotlin.
return.type.is.invalid=El tipo de devolución no es válido.
searching.usages.of.0.parameter=Buscando el uso del parámetro ''{0}''
selected.code.fragment.has.multiple.exit.points=El fragmento de código seleccionado tiene múltiples puntos de salida.
selected.code.fragment.has.multiple.output.values=El fragmento de código seleccionado tiene tres o más salidas.
selected.code.fragment.has.output.values.and.exit.points=El fragmento de código seleccionado tiene salida y un punto de salida alternativo.
setter.of.0.will.become.invisible.after.extraction=El definidor de {0} se vuelve invisible después de la extracción.
text.0.already.contains.1={0} ya contiene {1}.
text.0.already.contains.nested.class.1=Una clase anidada con nombre {1} ya está contenida en {0}.
text.0.already.declared.in.1={0} ya está definido en {1}.
text.0.have.no.inheritors.warning={0} no tiene herederos.\nAl mover un miembro hacia abajo, se eliminará ese miembro. ¿Quieres continuar?
text.0.in.1.will.override.corresponding.member.of.2.after.refactoring={1} en {0} redefine un miembro en {2} después de la refactorización.
text.0.inherits.from.1.it.will.not.be.affected.by.refactoring={0} se hereda de {1}.\nNo se ve afectado por la refactorización.
text.0.is.invalid.destination.package=''{0}'' es un nombre de paquete de destino no válido.
text.0.is.not.allowed.in.the.target.context=''{0}'' no está permitido en la interfaz
text.0.is.not.valid.package.name={0} no es un nombre de paquete válido.
text.0.to.inline={0} a en línea
text.0.uses.1.which.is.not.accessible.from.2={0} utiliza {1} al que no puede acceder {2}.
text.0.uses.1.which.will.be.inaccessible.after.move={0} usa {1}, que quedará inaccesible después del traslado.
text.0.uses.1.which.will.not.be.accessible.from.subclass={0} usa {1}, lo que lo hace inaccesible para las subclases.
text.0.uses.internal.1.which.will.be.inaccessible.after.move={0} utiliza {1} interno al que quedará inaccesible después del traslado.
text.0.will.be.shadowed.by.1={0} está sombreado por {1}.
text.0.will.clash.with.existing.1.in.2=Cambiar el nombre hace que {0} entre en conflicto con el {1} existente en {2}.
text.0.will.no.longer.be.accessible.after.signature.change={0} quedará inaccesible después de cambiar su firma.
text.all.declarations.must.belong.to.the.same.directory.or.class=Todas las declaraciones deben pertenecer al mismo directorio o clase.
text.all=Cada
text.anonymous=[anónimo]
text.at.least.one.file.must.be.selected=Debes seleccionar al menos un miembro.
text.callee.text.would.be.shown.here=El texto del destinatario aparece aquí.
text.caller.text.with.highlighted.callee.call.would.be.shown.here=El texto de la persona que llama aparece aquí con la llamada de la persona que llama resaltada.
text.cannot.create.target.directory.0=No se puede crear el directorio de destino {0}.
text.cannot.determine.source.directory=El directorio de origen no se puede resolver.
text.cannot.find.package.corresponding.to.0=No se pudo encontrar el paquete correspondiente a {0}.
text.cannot.find.target.package.name=No se encontró el nombre del paquete de destino.
text.cannot.inline.0.1.usages=El uso de {0}/{1} no se puede incluir en línea.
text.cannot.move.for.current.project=No puedes moverte para el proyecto actual.
text.cannot.move.inner.class.0.into.itself=La clase anidada {0} no se puede mover dentro de sí misma.
text.cannot.move.to.original.file=No puedes ir al archivo original.
text.cannot.move.expect.actual.declaration.to.file=No se pudo trasladar la declaración esperada/real al archivo
text.change.file.package.to.0=Cambie el paquete del archivo a ''{0}''.
text.choose.containing.file=Seleccione los archivos incluidos.
text.class.0.already.contains.member.1={0} ya contiene {1}.
text.class.0.already.exists.in.package.1=El paquete {1} ya existe en la clase {0}.
text.class.0.already.exists.in.the.target.scope=La clase {0} ya existe en el ámbito de destino.
text.class.0.is.final={0} es definitivo.
text.constructor=Constructor
text.convert._it_.to.explicit.lambda.parameter=Convierta ''it'' en un parámetro lambda explícito.
text.create.destructuring.declaration=Genera una declaración desestructurante.
text.create.single.variable=Crea una única variable.
text.declaration=Declaración
text.declarations.clash.move.0.destination.1.declared.in.scope.2=Las siguientes declaraciones entran en conflicto: Mueva {0} y apunte a {1} declarado en el ámbito {2}.
text.default.value=\ // Valor predeterminado \={0}
text.destination.class.should.be.kotlin.class=La clase objetivo debe ser una clase Kotlin.
text.do.you.want.to.rename.0.as.well=¿También le gustaría cambiar el nombre de {0}()?
text.do.you.want.to.rename.base.property.from.0=¿Le gustaría cambiar el nombre de la propiedad predeterminada en {0}?
text.do.you.want.to.rename.base.property=¿Le gustaría cambiar el nombre de la propiedad predeterminada?
text.duplicating.local.variable=Variable local duplicada ''{0}''
text.duplicating.parameter=Parámetro duplicado ''{0}''
text.duplicating.property=Propiedad duplicada ''{0}''
change.signature.conflict.text.kotlin.default.value.in.non.kotlin.files=Los valores de llamada predeterminados de Kotlin pueden generar código incorrecto en otros idiomas
change.signature.conflict.text.kotlin.default.parameter.in.non.kotlin.files=Es posible que los parámetros predeterminados no sean compatibles con otros idiomas
text.explicit.receiver.is.already.present.in.call.element.0=Ya existe un receptor explícito en el elemento llamante. {0}
text.extract.superclass=Extracción de clase principal
text.file.0.already.exists.in.1=El archivo {0} ya existe en {1}.
text.file.name.cannot.be.empty=Es posible que el nombre del archivo no esté vacío.
text.function.already.exists=La función ya existe. ''{0}''
text.function.in.ticks.0=Función ''{0}''
text.function=Función
text.anonymous.function=Función anónima
text.implicit.companion.object.will.be.inaccessible.0=Los objetos complementarios implícitos se vuelven inaccesibles. {0}
text.incorrect.target.path.directory.0.does.not.belong.to.current.project=Ruta de destino no válida. El directorio {0} no pertenece al proyecto actual.
text.indirect.outer.instances.will.not.be.extracted.0=Las instancias externas indirectas no se extraen. {0}
text.inline.0.1.2={0} ¿Quieres insertar ''{1}''? {2}
text.inline.0={0} en línea
text.inline.all.references.and.verb.0.the.kind.1.occurrences.2=Inserte todas las referencias y reemplace {1} {2} con {0}
text.inline.recursive.function.is.supported.only.on.references=La incorporación de funciones recursivas solo se admite por referencia.
text.inline.this.reference.and.keep.the.0=Insertar esta referencia y mantener {0}
text.inlining.0.1={0} {1} en línea
text.inlined.0.overrides.0.1={0} en línea anula {0} {1}
text.inner.class.0.cannot.be.moved.to.intefrace={0} es una clase interna y no se puede mover a una interfaz.
text.introduce.default.value=&Insertar valor predeterminado
text.invalid.target.path.0=Ruta de destino no válida {0}
text.invalid.target.specified=Orientación incorrecta
text.keep=Mantener
text.lambda.parameter=Parámetro lambda
text.lambda.parameters=Parámetros lambda (&P)\:
text.lambda.return.type=Tipo de retorno lambda (&T)
text.lazy.property=Propiedades de retardo
text.local.property=Propiedades
text.local.variable=Variable local
text.looking.for.usages=Buscando ubicación de uso
text.member.0.in.super.class.will.clash.with.existing.member.of.1={0} en la clase principal entra en conflicto con un miembro existente en {1}.
text.member.extension.call.will.not.be.processed.0=Las llamadas de extensión de miembros no se procesan. {0}
text.move.declaration.no.support.for.companion.objects=No se admiten declaraciones en movimiento para objetos complementarios.
text.move.declaration.no.support.for.enums=No se admite el movimiento declarativo para elementos de enumeración.
text.move.declaration.supports.only.top.levels.and.nested.classes=Mover declaraciones solo se admite para declaraciones de nivel superior y clases anidadas.
text.move.declaration.proceed.move.without.mpp.counterparts.text=Esta refactorización puede causar errores de compilación porque mueve declaraciones seleccionadas sin sus contrapartes esperadas/reales.\n¿Quiere continuar?
text.move.declaration.proceed.move.without.mpp.counterparts.title=Las declaraciones MPP no son compatibles con esta refactorización
text.move.declarations=Movimiento de declaración
text.no.destination.object.specified=No se ha especificado ningún objeto de destino
text.move.method.is.not.supported.for.non.project.methods=El método de movimiento no es compatible con métodos que no son de proyecto.
text.move.method.is.not.supported.for.generic.classes=El método de movimiento no es compatible con clases genéricas.
text.move.method.is.not.supported.when.method.is.a.part.of.inheritance.hierarchy=El método de movimiento no es compatible si el método es parte de una jerarquía de herencia.
text.references.to.outer.classes.have.to.be.added.manually=Las referencias a clases externas deben agregarse manualmente después de moverse
text.move.file.0=Empresa de mudanzas {0}
text.move.refactoring.not.available.during.indexing=La refactorización de movimientos no está disponible mientras la indexación está en curso.
text.moving.multiple.nested.classes.to.top.level.not.supported=No se admite mover varias clases anidadas al nivel superior.
text.Name=Nombre
text.nested.classes.to.upper.level=De clases anidadas a niveles superiores
text.no.elements.to.move.are.selected=No se ha seleccionado ningún elemento para mover.
text.no.files.to.move=No se especifica ningún archivo para mover.
text.no.name.provided.for.type.alias=No se proporcionó ningún nombre para el alias de tipo.
text.no.package.corresponds.to.directory=No hay ningún paquete correspondiente en este directorio.
text.non.kotlin.0.will.not.be.affected.by.refactoring={0} que no sea Kotlin no se ve afectado por la refactorización.
text.overload=Sobrecarga
text.package.directive.dont.match.file.location=La directiva del paquete no coincide con la ubicación del archivo.
text.parameter.0=Parámetro ''{0}''
text.parameter.name=&Nombre del parámetro\:
text.parameter.reference.can.t.be.safely.replaced.with.0.since.1.is.ambiguous.in.this.context={1} es ambiguo en este contexto y la referencia del parámetro no se puede reemplazar de forma segura con {0}.
text.parameter.reference.can.t.be.safely.replaced.with.0.since.target.function.can.t.be.referenced.in.this.context=La referencia del parámetro no se puede reemplazar de forma segura con {0} porque no se puede hacer referencia a la función de destino en este contexto.
text.parameter.type=Tipo de parámetro (&T)\:
text.parameter=Parámetro
text.parameters=&Parámetro\:
text.proceed.with.extraction=Progreso de extracción
text.process.duplicates=Duplicación de procesos
text.processing.file.0=Procesando {0}
text.property.in.ticks.0=Propiedad ''{0}''
text.property.with.getter=Propiedades con captadores
text.property.with.initializer=Propiedades con inicializadores
text.property=Propiedades
text.pushed.member.will.not.be.available.in.0=El miembro enviado ya no estará disponible en ''{0}''.
text.qualified.call.will.not.be.processed.0=Las llamadas calificadas no se procesan. {0}
text.receiver.can.t.be.safely.transformed.to.value.argument=Un receptor no se puede convertir de forma segura en un argumento de valor. {0}
text.receiver=Receptor
text.refactoring.can.t.be.performed.on.the.selected.code.element=La refactorización no se puede realizar en el elemento de código seleccionado.
text.refactoring.is.not.applicable.to.this.code.fragment=No se aplica ninguna refactorización a este fragmento de código.
text.references.in.code.to.0.1.and.its.declarations={0} Referencias en código a {1} y sus declaraciones
text.remove.0.no.longer.used=Elimine {0} que ya no se utiliza.
text.remove.question=\ ''?'' eliminar
text.remove=Eliminar
text.rename.as.part.of.phrase=Rebautizar
text.rename.is.not.applicable.to.secondary.constructors=El cambio de nombre no afecta a los constructores secundarios.
text.rename.is.not.applicable.to.synthetic.declarations=Los cambios de nombre no aplican a las declaraciones de integración.
text.rename.not.applicable.to.backing.field.reference=Los cambios de nombre no afectan las referencias de los campos de respaldo.
text.rename.not.applicable.to.dynamically.invoked.methods=Los cambios de firma no se aplican a los miembros llamados dinámicamente.
text.rename.overloads.title=Cambiar nombre de sobrecarga
text.rename.parameters.in.hierarchy.to=Cambie el nombre del parámetro en la jerarquía a\:
text.rename.parameters.title=Cambiar nombre del parámetro
text.select.target.code.block.file=Seleccione el bloque/archivo de código de destino.
text.select.target.code.block=Seleccione el bloque de código de destino.
text.select.target.file=Seleccione el archivo de destino.
text.the.following=Próximo
text.there.is.already.a.parameter=El parámetro ''{0}'' ya existe en {1}, por lo que entrará en conflicto con el nuevo parámetro.
text.there.is.already.a.variable.0.in.1.it.will.conflict.with.the.new.parameter=La variable ''{0}'' ya existe en {1}, por lo que entrará en conflicto con el nuevo parámetro.
text.type.alias.cannot.refer.to.types.which.aren.t.accessible.in.the.scope.where.it.s.defined=Un alias de tipo no puede hacer referencia a un tipo al que no se puede acceder desde el ámbito en el que está definido.
text.type.alias.name.must.be.a.valid.identifier.0=El nombre del alias del tipo debe ser un identificador válido. {0}
text.type.alias=Escriba alias
text.type.already.exists.in.the.target.scope=El tipo {0} ya existe en el ámbito de destino.
text.type.parameter.names.must.be.distinct=Los nombres de los parámetros de tipo deben ser únicos.
text.type.parameters=Tipo y parámetro
text.type=Categoría
text.unexpected.element.type.0=Tipo de elemento inesperado\: {0}
text.update.usages.to.reflect.declaration.0.move=Actualice el uso para reflejar {0,choice, 0\#declaración|1\#declaración}.
text.updating.usages.progress=Actualizando ubicación de uso...
text.variable=Variable
text.cannot.inline.reference.from.0.to.1=No se puede insertar una referencia de {0} a {1}
title.inline.function=Función en línea
title.inline.property=Propiedades en línea
title.inline.type.alias=Alias de tipo incorporados
refactoring.cannot.be.applied.no.sources.attached=La refactorización {0} no se puede aplicar porque no hay fuentes vinculadas
refactoring.cannot.be.applied.to.abstract.declaration={0} la refactorización no se puede aplicar a declaraciones abstractas
refactoring.cannot.be.applied.to.expect.declaration={0} la refactorización no se puede aplicar a la declaración esperada
refactoring.cannot.be.applied.to.anonymous.function.without.invocation={0} la refactorización no se puede aplicar a funciones anónimas sin llamadas
refactoring.the.function.not.found=Función no encontrada
refactoring.the.function.cannot.be.converted.to.anonymous.function=Las funciones no se pueden convertir en funciones anónimas.
refactoring.the.invocation.cannot.be.resolved=La llamada no se puede resolver.
refactoring.cannot.be.applied.to.lambda.expression.without.invocation={0} la refactorización no se puede aplicar a expresiones lambda sin llamadas
text.reference.cannot.be.converted.to.a.lambda=La referencia no se puede convertir a lambda
title.introduce.parameter.to.declaration=Insertar parámetros en declaraciones.
title.move.nested.classes.to.upper.level=Pasar a un nivel superior en una clase anidada
title.move.method=Método de movimiento
title.choose.destination.object=Seleccionar objeto de destino
title.select.target.code.block=Seleccionar bloque de código de destino
unsupported.usage.0=Uso no admitido\: {0}
parameter.used.in.declaration.body.warning=''{0} se utiliza en el cuerpo de la declaración
do.you.want.to.delete.this.parameter.in.expected.declaration.and.all.related.actual.ones=¿Quiere eliminar este parámetro de la declaración esperada y de todas las declaraciones reales relacionadas?
do.you.want.to.delete.expected.declaration.together.with.all.related.actual.ones=¿Quiere eliminar la declaración esperada y todas las declaraciones reales relacionadas?
delete.with.usage.search=Eliminar (usando la búsqueda de ubicación)
destination.not.found.for.package.0=No se pudo encontrar el destino del paquete ''{0}''.
leave.in.same.source.root=Salir de la misma raíz fuente.
test.root.is.selected.while.the.source.root.is.expected=Lo que se espera es la raíz de origen, pero se selecciona la raíz de prueba.
source.root.is.selected.while.the.test.root.is.expected=Lo que se espera es la raíz de prueba, pero se selecciona la raíz de origen.
premature.end.of.template=La plantilla no está completada correctamente.
choose.target.class.or.interface=Seleccione la clase o interfaz de destino.
text.abstract=Abstracto
text.secondary.constructor=Constructor secundario
text.create=Producir
text.member=Miembro
text.extension=Expansión
text.object=Objeto
text.interface=Interfaz
text.enum.constant=Constantes de enumeración
text.enum=enumeración
text.annotation=Anotación
create.0.1=Crea {0} ''{1}''.
choose.class.container=Seleccione el contenedor de clase.
file.0.already.exists.but.does.not.correspond.to.kotlin.file=El archivo {0} ya existe, pero no es un archivo Kotlin.
create.file=Crear archivo
create.0=Crear {0}
create.package.0=Creando paquete ''{0}''.
text.type.parameter=Escriba {0,choice, 0\#parámetro|2\#parámetro}
create.0.in.1=Produzca {0} a partir de {1}.
searching.0=Buscando {0}....
create.property.0.as.constructor.parameter=Cree la propiedad ''{0}'' como parámetro del constructor.
create.parameter.0=Crear parámetro ''{0}''
add.property=Agregar propiedades.
text.add=Añadir ''
property.0.to.1=Propiedad ''{0}'' a ''{1}''
add.method=Agregar método
add.0.constructor.to.1=Agregue el constructor {0} a ''{1}''.
text.secondary=Asistente
text.primary=Básico
add.method.0.to.1=Agregue el método ''{0}'' a ''{1}''.
create.actual.0.for.module.1.2=Cree {0} real para el módulo {1} ({2}).
create.expected.0.in.common.module.1=Genera el {0} requerido a partir del módulo genérico {1}.
repair.actual.members=Modifica el miembro real.
these.declarations.cannot.be.transformed=Esta declaración no se puede convertir.
text.annotation.class=Clase de anotación
text.enum.class=Clase de enumeración
text.class=Clase
type.0.1.is.not.accessible.from.target.module={0,choice, 0\#type|2\#type} {1} no es accesible en el módulo de destino.
the.function.declaration.shouldn.t.have.a.default.implementation=La declaración de función no debe tener una implementación predeterminada.
some.types.are.not.accessible.from.0.1=Escriba inaccesible en {0}\:\n{1}
the.declaration.has.0.modifier=La declaración tiene el controlador ''{0}''
inaccessible.declaration=Declaración inaccesible
fix.with.asdynamic=Modifíquelo a ''asDynamic''.
migrate.type.parameter.list.syntax=Migrar la sintaxis de la lista de parámetros de tipo.
replace.deprecated.symbol.usage=Reemplaza símbolos obsoletos.
replace.with.0=Reemplazar con ''{0}''
there.is.own.replacewith.on.0.that.is.used.through.this.alias.please.replace.usages.first=''{0}'' usado a través de este alias tiene su propio ''ReplaceWith''. Primero, cambie la ubicación de uso.
replace.deprecated.symbol.usage.in.whole.project=Reemplaza el uso de un símbolo obsoleto en todo el proyecto.
applying.0=Aplicar ''{0}''
replace.usages.of.0.in.whole.project=Reemplaza el uso de ''{0}'' en todo el proyecto.
replace.with.publishedapi.bridge.call=Reemplace @PublishedApi con una llamada puente.
replace.with.generated.publishedapi.bridge.call.0=Reemplace la llamada puente @PublishedApi generada por ''{0}''.
convert.sealed.sub.class.to.object.fix.family.name=Convierte una subclase sellada en un objeto.
generate.identity.equals.fix.family.name=Generar iguales y hashCode por ID
and.delete.initializer=Eliminar \ e inicializador
change.to.val=Cambiar a valor.
change.to.var=Cambiar a var.
change.type.of.0.to.1=Cambie el tipo de {0} a ''{1}''.
change.type.to.0=Cambiar tipo a ''{0}''
base.property.0=Propiedades básicas {0}
make.0=Crear {0}.
make.0.1.explicitly=Convirtiendo explícitamente ''{0}'' en {1}.
make.0.explicitly=Haga {0} explícito.
use.inherited.visibility=Utilice visibilidad heredada.
replace.with.in.when=En cuándo, reemplace '','' por ''||''.
remove.0=Quitar ''.{0}''
remove.conversion.from.kclass.to.class=Elimine la conversión de ''KClass'' a ''Class''.
convert.to.0=Convertir a {0}.
convert.expression.to.0.by.inserting.1=Convierte la expresión a ''{0}'' insertando ''.{1}''.
convert.extension.property.initializer.to.getter=Convierte un inicializador de propiedad de extensión en un captador.
convert.supertype.to.0=Convierta el tipo principal a ''{0}''.
convert.extension.function.type.to.regular.function.type=Convierte un tipo de función extendida en un tipo de función normal.
convert.to.notnull.delegate=Se convierte en delegado no nulo.
convert.to.anonymous.object=Conviértelo en un objeto anónimo.
select.loop.statement.to.label=Seleccione la declaración de bucle que desea etiquetar.
select.lambda.to.label=Seleccione la lambda que desea etiquetar.
create.label=Crea una etiqueta.
create.label.0=Crea la etiqueta {0}@.
convert.member.to.extension=Convierte un miembro en una extensión.
replace.annotation=Cambiar la anotación
replace.annotation.with.0=Reemplace la anotación con {0}
add.initializer=Agregue un inicializador.
move.to.constructor.parameters=Vaya a los parámetros del constructor.
initialize.with.constructor.parameter=Inicializar con parámetros del constructor.
inline.type.parameter=Insertar el parámetro de tipo.
insert.explicit.delegation.call=Inserta una llamada de delegación explícita.
kotlin.add.required.module.fix.family.name=Agregue una directiva ''requiere'' a module-info.java.
the.anonymous.object=Objeto anónimo
text.implement=Avatar
text.extend=Expansión
let.0.1=Deje que {0} haga {1}.
let.type.implement.interface=Hace que el tipo implemente una interfaz.
0.interface.1=La interfaz ''{1}'' es {0}.
lift.assignment.out.of.try.expression=Eliminar la asignación de la expresión ''try''.
make.class.an.annotation.class=Convertir la clase en una clase de anotación
make.0.an.annotation.class=Crear clase anotada ''{0}''
make.constructor.parameter.a.property.0=Convierta el parámetro del constructor en la propiedad {0}.
in.class.0=\ dentro de la clase ''{0}''
add.0.to.module.1.compiler.arguments=Agregue ''{0}'' a los argumentos del compilador del módulo {1}.
add.an.opt.in.requirement.marker.compiler.argument=Agregue argumentos opcionales del compilador de marcadores de requisitos.
make.0.in.1.open=Abra ''{0}'' en {1}.
add.modifier=Agregar controlador
make.private.and.0.1=Privado y haga {0} ''{1}''.
text.overrides=Reiniciar
text.implements=Avatar
make.type.parameter.reified.and.function.inline=Materializar parámetros de tipo y funciones en línea.
change.all.usages.of.0.in.this.file.to.1=Cambie todas las apariciones de ''{0}'' en este archivo a ''{1}''.
change.all.usages.of.0.in.this.file.to.a.kotlin.class=Cambie todos los usos de ''{0}'' en este archivo a clases de Kotlin.
change.to.kotlin.class=Cambie a la clase Kotlin.
choose.an.appropriate.kotlin.class=Seleccione la clase de Kotlin adecuada.
add.empty.brackets.after.primary.constructor=Agregue corchetes vacíos después del constructor predeterminado.
add.constructor.keyword=Agregue la palabra clave ''constructor''.
move.annotation.to.receiver.type=Mover la anotación al tipo de receptor
move.type.parameter.constraint.to.where.clause=Mueva las restricciones de los parámetros de tipo a la cláusula ''dónde''.
move.else.branch.to.the.end=Mueve la rama else hasta el final.
insert.number.conversion=Inserte una conversión numérica.
convert.expression.to.0=Convierte la expresión a ''{0}''.
remove.from.annotation.argument=Eliminar @ de los argumentos de anotación
remove.default.parameter.value=Elimina los valores de parámetros predeterminados.
remove.final.upper.bound=Final Elimina el límite superior.
remove.function.body=Elimina el cuerpo de la función.
remove.redundant.0.modifier=Eliminar el controlador ''{0}'' duplicado.
make.0.not.1=Haga que {0} no sea {1}.
remove.0.modifier=Elimine el calificador ''{0}''.
remove.modifier=Quitar controlador
remove.identifier.from.anonymous.function=Elimina identificadores de funciones anónimas.
remove.constructor.call=Eliminar la llamada al constructor.
make.not.nullable=Hazlo no nulo.
remove.useless=Elimine los ''?'' innecesarios.
remove.redundant=Eliminar duplicado ''?''.
remove.0.from.property=Eliminar {0} de la propiedad.
remove.parts.from.property=Retire parte de la propiedad.
text.initializer=Iniciador
text.setter=Conjuntos
text.getter=Adquiridor
remove.element=Elimina un elemento.
for.0=Para ''{0}''
remove.conflicting.import.0=Elimine la declaración de importación conflictiva {0}.
remove.type.parameters=Elimine el parámetro de tipo.
remove.type.arguments=Eliminar argumento de tipo
remove.star=''*'' eliminar
remove.variable.0=Eliminar la variable ''{0}''.
remove.redundant.initializer=Eliminar inicializadores innecesarios
remove.redundant.label=Eliminar etiquetas duplicadas.
remove.single.lambda.parameter.declaration=Elimine la declaración de parámetro lambda único.
remove.supertype=Quitar tipo padre
remove.0.variance.from.1=Elimine la variación ''{0}'' de ''{1}''.
remove.parameter.0=Eliminar el parámetro ''{0}''.
remove.redundant.assignment=Eliminar asignaciones duplicadas
there.are.possible.side.effects.found.in.expressions.assigned.to.the.variable.0=Se ha detectado un posible efecto secundario en la expresión asignada a la variable ''{0}.<br>Para resolver el problema:<br>-\\&nbsp;<b>Elimine</b><br toda la asignación >. -\\&nbsp;Convierte la asignación del lado derecho a su propia sintaxis.</b><br>
remove.useless.cast=Retire los yesos innecesarios.
remove.useless.elvis.operator=Elimine los operadores de Elvis innecesarios.
remove.useless.is.check=Elimina controles innecesarios.
remove.val.var.from.parameter=Elimine ''val/var'' del parámetro.
remove.0.from.parameter=Elimine ''{0}'' del parámetro.
remove.else.branch=Retire la rama else.
remove.branch=Quitar rama
rename.identifier.fix.text=Rebautizar
rename.to.0=Cambiar el nombre a ''{0}''
rename.parameter.to.match.overridden.method=Cambie el nombre del parámetro para que coincida con el método anulado.
rename.to.underscore=Cambiar el nombre a _
replace.with.safe.this.call=Reemplácelo con una llamada segura (¿esta?).
replace.with.safe.call=Reemplácelo con una llamada segura (?.).
replace.scope.function.with.safe.call=Reemplace las funciones de alcance con llamadas seguras (?.).
replace.with.dot.call=Reemplácelo con una llamada de punto.
replace.with.safe.call1=Reemplácelo con una llamada segura (?.).
replace.invalid.positioned.arguments.for.annotation=Reemplazar argumentos fuera de lugar para anotaciones
replace.jvmfield.with.const=Reemplace ''@JvmField'' por ''const''.
replace.modifier=Cambiar controlador.
update.obsolete.label.syntax=Actualice la sintaxis de la etiqueta obsoleta.
replace.with.label.0.at=Reemplazar con {0}@.
replace.cast.with.call.to.to.0=Reemplace la conversión de tipo con una llamada a ''to{0}()''.
replace.cast.with.primitive.conversion.method=Reemplace la conversión de tipos con el método de conversión predeterminado.
replace.with.array.call=Reemplace con llamadas de matriz:
remove.expression.target=Elimina el objetivo de expresión.
change.existent.retention.to.source=Cambia un archivo existente a una fuente.
add.source.retention=Agregue un elemento de archivo de origen.
round.using.0=Utilice {0}() para redondear.
simplify.0.to.1=Simplifica {0} a ''{1}''.
simplify.comparison=Simplifica la comparación.
specify.override.for.0.explicitly=Especifica explícitamente una anulación para ''{0}''.
specify.override.explicitly=Especifica la anulación explícitamente.
specify.return.type.explicitly=Especifique explícitamente el tipo de devolución.
specify.type.explicitly=Especifique el tipo explícitamente.
add.constructor.parameters.from.0.1=Agregue los parámetros del constructor de {0}{1}.
change.to.constructor.invocation=Cambie a una llamada al constructor.
add.constructor.parameters.from.superclass=Agregue parámetros de constructor para la clase principal.
surround.with.star.0=Rodeado de *{0}(...).
surround.with.lambda=Rodéalo con lambda.
surround.with.null.check=Rodeado de cheques nulos.
convert.too.long.character.literal.to.string=Convierta literales de caracteres demasiado largos en cadenas.
replace.array.of.boxed.with.array.of.primitive=Reemplace la matriz de boxeo con la matriz predeterminada.
migrate.unsupported.yield.syntax=Migrar declaraciones de rendimiento no admitidas.
wrap.with=Envuélvalo con [].
wrap.with.array.literal=Envuélvalo en una matriz literal.
wrap.with.collection.literal.call=Envuélvalo en una llamada literal de colección.
wrap.element.with.0.call=Envuelva el elemento con una llamada a ''{0}()''.
replace.with.0.call=Reemplace con una llamada a ''{0}()''.
wrap.with.let.call=Envuélvalo con una llamada a ''?.let {... }''.
change.to.0=Cambie a ''{0}''.
change.to.correct.long.suffix.l=Cambie al sufijo largo correcto ''L''.
change.to.correct.primitive.type=Cambie al tipo predeterminado correcto.
0.from.1={0} de {1}
checking.data.classes=Comprobar clase de datos
checking.data.class.0.of.1=Comprobando la clase de datos {0}/{1}....
difference.found.for.data.class.0.found.1.2=No se encontraron diferencias para la clase de datos {0}. Se encontraron {1} usos, pero se necesitan {2}.
title.error=Error
analyzed.0.classes.no.difference.found=Se analizaron {0} clases, pero no se encontraron diferencias.
title.success=Correcto
can.t.finish.while.indexing.is.in.progress=No se puede completar mientras la indexación está en curso.
enable.tremble.dumb.mode=Habilitar el modo Temblar tonto
disable.tremble.dumb.mode=Desactivar el modo Temblar tonto
scanning.files.0.fo.1.file.2.occurrences.found=Comprobando archivos: {0}/{1} archivos. {2} usos encontrados.
implicit.nothing.s=Nada implícito
not.found.in.0.files=No encontrado en {0} archivos.
titile.not.found=Extraviado
search.for.not.property.candidates=Busque candidatos, no propiedades.
enter.package.fqname=Introduzca el nombre Fq del paquete.
searching.for.not.property.candidates=Búsqueda de candidatos no inmobiliarios
step.1.collecting.0.1.2=Paso 1\: Recoge {0}\:{1}\:{2}
step.2.0.of.1=Paso 2\: {1} de {0}
step.3.0.of.1=Paso 3\: {1} de {0}
title.done=Completo
delete.0={0} Eliminar
replace.if.expression.with.elvis.expression=Reemplace la expresión ''si'' con una expresión de Elvis.
report.also.on.statement=La sintaxis también informa.
if.then.foldable.to=Si-Entonces plegable con ''?\:''
replace.if.expression.with.safe.access.expression=Reemplace la expresión ''if'' con una expresión de acceso seguro.
remove.redundant.if.expression=Elimine las expresiones "if" redundantes.
replace.if.expression.with.safe.cast.expression=Reemplace la expresión ''if'' con una expresión de conversión segura.
simplify.foldable.if.then=Simplifica los si-entonces plegables.
foldable.if.then=Plegable si-entonces
introduce.when.subject=Inserte el objetivo ''cuándo''.
when.with.subject.should.be.used=Debes usar ''cuando'' con un objeto.
introduce.0.as.subject.0.when=Insertando ''{0}'' como destino de ''cuándo''.
convert.call.chain.into.sequence.fix.text=Convierta la cadena de llamadas a ''Secuencia''.
call.chain.length.to.transform=Longitud de la cadena de llamadas para convertir\:
call.chain.on.collection.could.be.converted.into.sequence.to.improve.performance=Para mejorar el rendimiento, puede convertir la cadena de llamadas de una colección en una "Secuencia".
rename.useless.call.fix.text=Cambie la llamada a ''{0}''.
call.chain.on.collection.type.may.be.simplified=Puede simplificar la cadena de llamadas para los tipos de cobranza.
0.call.could.be.simplified.to.1=La llamada {0} se puede simplificar a {1}.
simplify.call.fix.text=Convierta la llamada ''{0}'' a ''{1}''.
simplify.call.chain.fix.text=Fusione la cadena de llamadas en ''{0}''.
call.on.collection.type.may.be.reduced=Esto puede reducir las llamadas a tipos de cobranza.
useless.call.on.collection.type=Llamadas innecesarias a tipos de cobranza
this.call.is.useless.with=Esta llamada no es necesaria si usas ?.
useless.call.on.not.null.type=Llamada innecesaria a tipo no nulo
call.on.not.null.type.may.be.reduced=Esto puede reducir las llamadas a tipos no nulos.
replace.total.order.equality.with.ieee.754.equality=Reemplace la igualdad total del orden con la igualdad IEEE 754.
replace.with.binary.operator=Reemplace con operadores binarios.
call.replaceable.with.binary.operator=Llamadas que pueden ser reemplazadas por operadores binarios
replace.get.or.set.call.with.indexing.operator=Reemplace las llamadas de obtención o configuración con operadores de indexación.
should.be.replaced.with.indexing=Esto debería reemplazarse con indexación.
replace.0.call.with.indexing.operator=Reemplace la llamada a ''{0}'' con el operador de indexación.
function.returning.0.with.a.name.that.does.not.end.with.1=Función que devuelve {0} cuyo nombre no termina en {1}
add.call.or.unwrap.type.fix.text=Agregue ''.{0}()'' al resultado de la función (sitios de uso separados).
add.call.or.unwrap.type.fix.text1=Desenvuelva el tipo de devolución ''{0}'' (sitios de uso separados).
reports.only.function.calls.from.kotlinx.coroutines=Informa solo llamadas a funciones en kotlinx.coroutines.
deferred.result.is.never.used=Los resultados diferidos nunca se utilizan.
function.0.returning.1.without.the.corresponding=Una función que devuelve {3}'' Una función que devuelve ''{1}'' sin ''{2}'' ''{0}
redundant.async.call.may.be.reduced.to.0=Las llamadas ''asincrónicas'' redundantes se pueden reducir a ''{0}''.
redundant.runcatching.call.may.be.reduced.to.0=Las llamadas ''runCatching'' redundantes se pueden reducir a ''{0}''.
rename.to.fix.text=Cambiar el nombre a ''{0}''
wrap.with.coroutine.scope.fix.text=Envuelva el cuerpo de la función con ''coroutineScope {... }''.
wrap.with.coroutine.scope.fix.text2=Complete la llamada con ''coroutineScope {... }''.
wrap.with.coroutine.scope.fix.text3=Retire el receptor y envuélvalo con ''coroutineScope {... }''.
wrap.with.coroutine.scope.fix.family.name=Envolviendo con coroutineScope
ambiguous.coroutinecontext.due.to.coroutinescope.receiver.of.suspend.function=CoroutineContext oscurecido por el receptor CoroutineScope en función de suspensión
replace.with.kotlin.analog.function.family.name=Cambiar al análogo de Kotlin
should.be.replaced.with.kotlin.function=Debe convertirse a una función de Kotlin.
replace.with.kotlin.analog.function.text=Convertir a la función ''{0}''
add.documentation.fix.text=Añade un documento.
missing.documentation=Falta el documento.
0.is.missing.documentation=A {0} le falta un documento.
library.should.be.updated.to.be.compatible.with.kotlin.1.3=La biblioteca debe actualizarse para que sea compatible con Kotlin 1.3.
it.s.prohibited.to.call.0.with.min.value.step.since.1.3=A partir de la versión 1.3, está prohibido llamar a {0} con el paso MIN_VALUE.
obsolete.coroutine.usage.in.whole.fix.family.name=Modifique dónde se utilizan las rutinas experimentales en su proyecto
obsolete.kotlin.js.packages.usage.in.whole.fix.family.name=Corrija el uso de los paquetes ''kotlin.dom'' y ''kotlin.browser'' en su proyecto.
apply.in.the.project.0=Aplicar desde el proyecto\: {0}
obsolete.coroutine.usage.fix.family.name=Se corrigió la ubicación de uso de rutina experimental.
obsolete.package.usage.fix.family.name=Arreglar el uso del paquete ''{0}''
0.is.expected.to.be.used.since.kotlin.1.3=''{0}'' se utilizará a partir de Kotlin 1.3
methods.are.absent.in.coroutines.class.since.1.3=Los métodos desaparecen de las clases de rutina a partir de 1.3.
experimental.coroutines.usages.are.obsolete.since.1.3=Las ubicaciones de uso de rutinas experimentales están obsoletas a partir de 1.3.
package.usages.are.obsolete.since.1.4=El uso del paquete ''{0}'' está obsoleto a partir de 1.4
replace.substring.call.with.droplast.call=Reemplace la llamada ''subcadena'' con una llamada ''dropLast''.
replace.substring.call.with.indexing.operation.call=Reemplace la llamada ''subcadena'' con una llamada a la operación de índice.
replace.substring.call.with.substringbefore.call=Reemplace la llamada ''subcadena'' con una llamada ''subcadenaAntes''.
replace.substring.call.with.substringafter.call=Reemplace la llamada ''subcadena'' con una llamada ''subcadenaDespués''.
replace.substring.call.with.take.call=Reemplace la llamada ''subcadena'' con una llamada ''take''.
add.operator.modifier=Agregue el controlador ''operador''.
function.should.have.operator.modifier=La función debe tener un controlador ''operador''.
type.parameter.can.have.0.variance=El parámetro de tipo debe tener una variación de {0}.
add.variance.fix.text=Agregue la variación ''{0}''.
add.variance.fix.family.name=Agregar variación
generate.equals.and.hashcode.fix.text=Generar iguales() y hashCode()
array.property.in.data.class.it.s.recommended.to.override.equals.hashcode=Se recomienda anular las propiedades de la matriz \: equals()/hashCode() de la clase de datos.
report.also.on.call.with.single.boolean.literal.argument=También informa sobre llamadas con un único argumento literal booleano.
boolean.literal.argument.without.parameter.name=Argumento literal booleano sin nombre de parámetro
constructor.parameter.is.never.used.as.a.property=Los parámetros del constructor no se utilizan como propiedades.
property.is.explicitly.assigned.to.parameter.0.can=Puede declarar una propiedad directamente en el constructor asignándola explícitamente al parámetro {0}.
variable.is.never.modified.and.can.be.declared.immutable.using.val=Las variables no están calificadas y pueden declararse inmutables usando ''val''.
sealed.sub.class.has.no.state.and.no.overridden.equals=La subclase sellada no tiene ningún estado ni iguales anulados.
cascade.if.should.be.replaced.with.when=Cascada If debe reemplazarse por cuándo.
mark.as.deprecated.level.deprecationlevel.hidden=Marcado como @Deprecated(..., nivel \= DeprecationLevel.HIDDEN).
delete.redundant.extension.property=Eliminar propiedades extendidas duplicadas.
this.property.conflicts.with.synthetic.extension.and.should.be.removed.or.renamed.to.avoid.breaking.code.by.future.changes.in.the.compiler=Esta propiedad entra en conflicto con la extensión de integración, por lo que debe eliminarla o cambiarle el nombre para evitar que cambios futuros en el compilador rompan su código.
condition.is.always.0=La condición es siempre ''{0}''.
remove.fix.text=Eliminar una expresión.
simplify.fix.text=Simplificar expresiones
0.has.empty.body=El cuerpo de ''{0}'' está vacío.
convert.na.n.equality.quick.fix.text=Reemplazar con ''isNaN()'
equality.check.with.nan.should.be.replaced.with.isnan=La prueba de igualdad con NaN debe cambiarse a ''isNaN()''.
convert.pair.constructor.to.to.fix.text=Se convierte a ''a''.
can.be.converted.to.to=Se puede convertir a ''a''.
convert.to.a.range.check=Lo convierte en una verificación de rango.
two.comparisons.should.be.converted.to.a.range.check=Debe convertir los dos elementos de comparación en una verificación de rango.
copy.method.of.data.class.is.called.without.named.arguments=El método ''copia'' de la clase de datos se llama sin argumentos con nombre.
private.data.class.constructor.is.exposed.via.the.generated.copy.method=El constructor de la clase de datos privados se expone mediante el método ''copia'' generado.
remove.var.keyword.text=Eliminar var
delegating.to.var.property.does.not.take.its.changes.into.account=Delegar a una propiedad ''var'' no tiene en cuenta ese cambio.
add.replacewith.argument.to.specify.replacement.pattern=Agregue el argumento ''replaceWith'' para especificar el patrón de reemplazo.
deprecated.annotation.without.replacewith.argument=@Anotación obsoleta sin argumento ''replaceWith''
variable.name.0.matches.the.name.of.a.different.component=El nombre de la variable ''{0}'' coincide con el nombre de otro componente.
replace.with.down.to.fix.text=Reemplace con ''abajoA''.
equals.hashcode.in.object.declaration=Es igual a()/hashCode() en la declaración de objeto
hash.code.text=Crea ''hashCode()''
equals.text=Crea ''igual()''
delete.equals.and.hash.code.fix.text=Elimine iguales()/hashCode().
redundant.explicit.this=Duplicar explícito esto
explicit.this.expression.fix.family.name=Eliminar duplicado ''{0}''
use.of.non.const.kotlin.property.as.java.constant.is.incorrect.will.be.forbidden.in.1.4=El uso de propiedades de Kotlin no constantes como constantes de Java es incorrecto y estará prohibido en 1.4.
replace.if.with.elvis.operator=Reemplace ''si'' con el operador de Elvis.
if.null.return.break.foldable.to=If-Null return/break/... plegable con ''?\:''
loop.parameter.0.is.unused=El parámetro de bucle ''{0}'' está en desuso.
replace.with.repeat.fix.family.name=Reemplazar con ''repetir()''
introduce.anonymous.parameter.fix.family.name=Insertar parámetros anónimos
wrap.run.fix.text=Convertir para ejecutar {...}.
remove.braces.fix.text=Quitar los frenillos
function.with.and.inferred.return.type=Funciones con ''\={... }'' y tipos de retorno inferidos
report.for.types.with.platform.arguments=Informes sobre qué tipos de argumentos de plataforma existen.
apply.only.to.public.or.protected.members=Se aplica sólo a miembros públicos o protegidos.
declaration.has.type.inferred.from.a.platform.call.which.can.lead.to.unchecked.nullability.issues=La declaración tiene un tipo inferido de la llamada a la plataforma, lo que puede provocar problemas de nulidad no controlados. Especifica explícitamente el tipo como anulable o no anulable.
callable.reference.fix.family.name=Agregar ''{0}'' explícito
java.collections.static.method.call.should.be.replaced.with.kotlin.stdlib=Las llamadas a métodos estáticos de la colección Java deben reemplazarse con Kotlin stdlib.
replace.with.std.lib.fix.text=Reemplazar con {0}.{1}.
call.of.java.mutator.0.on.immutable.kotlin.collection.1=Invocación del modificador de Java ''{0}'' en la colección Kotlin inmutable ''{1}''
replace.with.kotlin.s.foreach=Reemplace con forEach de Kotlin.
java.map.foreach.method.call.should.be.replaced.with.kotlin.s.foreach=Debe reemplazar la llamada al método Java Map.forEach con forEach de Kotlin.
remove.deprecated.symbol.import=Elimine las declaraciones de importación para símbolos obsoletos.
usage.of.redundant.or.deprecated.syntax.or.deprecated.symbols=Dónde utilizar sintaxis redundante o obsoleta o símbolos obsoletos
equals.should.take.any.as.its.argument=''iguales'' deben tomar ''¿Alguno?'' como argumento.
double.negation.fix.text=Elimine los negativos duplicados.
redundant.double.negation=Doble negativo redundante
equals.between.objects.of.inconvertible.types=''es igual a()'' entre objetos de tipos no convertibles
usage.of.kotlin.internal.declaration.from.different.module=Dónde utilizar las declaraciones internas de Kotlin en otros módulos
inheritance.of.kotlin.sealed=Java {0,choice,0#interface|1#class} no puede ser parte de la jerarquía sellada de Kotlin
junit.static.methods=Métodos estáticos JUnit
redundant.override.fix.text=Elimine los métodos de anulación redundantes.
redundant.overriding.method=Método anulado duplicado
throwable.instance.0.is.not.thrown=La instancia arrojable ''{0}'' no se lanzará.
result.of.0.call.is.not.thrown=El resultado de la llamada ''{0}'' no se genera.
optimize.imports=Optimización de declaración import
unused.import.directive=Directiva de importación obsoleta
leaking.this.in.constructor.of.non.final.class.0=Filtrar ''esto'' en el constructor de la clase no final {0}
leaking.this.in.constructor.of.enum.class.0.with.overridable.members=Filtrar ''esto'' en el constructor de la clase de enumeración {0} (con miembros reemplazables)
accessing.non.final.property.0.in.constructor=Accediendo a la propiedad no final {0} en el constructor
calling.non.final.function.0.in.constructor=Llamar a la función no final {0} en el constructor
text.can=Puede
text.should=Debería
text.Assignment=Admisiones universitarias
text.Return=Devolver
text.return=Devolver
0.1.be.lifted.out.of.2=Elimine {0} de ''{2}''{1}.
lift.assignment.out.fix.text.0=Eliminar la asignación de ''{0}''.
lift.return.out.fix.text.0=Eliminar devolución de ''{0}''
change.main.function.return.type.to.unit.fix.text=Agregue un tipo de devolución de Unidad explícito.
change.main.function.return.type.to.unit.fix.text2=Cambie el tipo de devolución a Unidad.
0.should.return.unit={0} debe devolver la unidad.
junit.test=Pruebas unitarias
map.get.with.not.null.assertion.operator=Map.get() con operador de aserción no nulo (\!\!)
replace.with.get.or.else.fix.text=Reemplácelo con una llamada a ''getOrElse''.
replace.with.get.value.call.fix.text=Reemplace con una llamada ''getValue''.
replace.with.elvis.error.fix.text=Reemplácelo con ''?\: error("")''.
might.be.const=Puede ser "constante".
const.might.be.used.instead.of.jvmfield=Puede utilizar ''const'' en lugar de ''@JvmField''.
text.Function=Función
text.Property=Propiedades
0.1.could.be.private={0} ''{1}'' puede ser privado.
diagnostic.name.should.be.replaced.by.the.new.one=Debe cambiar el nombre del diagnóstico al nuevo nombre.
replace.diagnostic.name.fix.text={0} un {1}
replace.diagnostic.name.fix.family.name=Cambiar nombre de diagnóstico
lambda.argument.0.be.moved.out=Saque el argumento lambda {0} del paréntesis{0}.
move.lambda.argument.out.of.parentheses=Saque el argumento lambda del paréntesis.
suspicious.callable.reference.as.the.only.lambda.element=Referencia invocable sospechosa como único elemento lambda
inline.variable=Variables en línea
move.variable.declaration.into.when=Mueva la declaración de variable a ''cuándo''.
nothing.to.do=No hay nada que hacer.
variable.declaration.could.be.inlined=Puede incorporar declaraciones de variables.
variable.declaration.could.be.moved.into.when=Puede mover declaraciones de variables a ''cuándo''.
may.contain.only.letters.digits.or.underscores=Sólo puede contener letras, números o guiones bajos.
may.contain.only.letters.and.digits=Sólo puede contener letras y números.
should.not.contain.underscores.in.the.middle.or.the.end=No debe haber un guión bajo en el medio ni al final.
should.not.start.with.an.underscore=No debe comenzar con un guión bajo.
should.not.start.with.an.uppercase.letter=No debe comenzar con mayúscula.
should.not.contain.underscores=No debe haber ningún subrayado.
should.start.with.a.lowercase.letter=Debe comenzar con una letra minúscula.
should.start.with.an.uppercase.letter=Debe comenzar con mayúscula.
doesn.t.match.regex.0=No coincide con la expresión regular ''{0}''.
text.pattern=Patrón
package.name=Nombre del paquete
text.part=Trabajo de medio tiempo
text.name=Nombre
text.Package=Paquete
add.explicit.parameter.to.outer.lambda.fix.text=Agregue nombres de parámetros explícitos a la lambda externa.
implicit.parameter.it.of.enclosing.lambda.is.shadowed=El parámetro implícito "it" de la lambda adjunta está sombreado.
equality.cehck.0.be.used.instead.of.elvis.for.nullable.boolean.check=Utilice la comprobación de igualdad {0} en lugar de elvis para la comprobación booleana anulable{0}.
replace.with.equality.check.fix.text=Cambiar a prueba de igualdad.
null.checks.to.safe.call.check.fix.text=Reemplace las comprobaciones nulas encadenadas con llamadas seguras.
null.checks.replaceable.with.safe.calls=Verificación nula reemplazable con llamada segura
optionally.expected.annotation.has.no.actual.annotation.in.module.0.for.platform.1=Una anotación opcional requerida en el módulo {0} para la plataforma {1} no tiene una anotación real
make.open.fix.text=Abre la clase.
make.private.fix.text=Establecer en privado
protected.visibility.is.effectively.private.in.a.final.class=La visibilidad "protegida" es efectivamente "privada" en una clase final.
apply.also.to.private.members=También se aplica a miembros privados.
apply.also.to.internal.members=También se aplica a los miembros internos.
for.api.stability.it.s.recommended.to.specify.explicitly.declaration.types=Para la estabilidad de la API, recomendamos especificar explícitamente el tipo de declaración.
for.api.stability.it.s.recommended.to.specify.explicitly.public.protected.declaration.types=Para la estabilidad de la API, recomendamos especificar explícitamente los tipos de declaración pública y protegida.
recursive.equals.call=Llamada recursiva igual a
replace.with.field.fix.text=Reemplace con ''campo''.
recursive.synthetic.property.accessor=Accesor de propiedad unificado recursivo
recursive.property.accessor=Accesor de propiedad recursivo
remove.redundant.companion.reference.fix.text=Elimine las referencias complementarias duplicadas.
redundant.companion.reference=Referencia complementaria duplicada
remove.redundant.else.fix.text=Elimine el ''else'' redundante.
redundant.else=Duplicar ''más''
remove.initializer.block.fix.text=Retire el bloque inicializador.
redundant.empty.initializer.block=Duplicar bloque inicializador vacío
remove.enum.constructor.invocation.fix.text=Eliminar las llamadas al constructor de enumeraciones.
redundant.enum.constructor.invocation=Llamadas duplicadas al constructor de enumeraciones
explicitly.given.type.is.redundant.here=Los tipos especificados explícitamente son redundantes aquí.
remove.redundant.getter.fix.text=Eliminar captadores duplicados.
redundant.getter=Captador duplicado
remove.redundant.if.text=Elimine las declaraciones "si" redundantes.
redundant.if.statement=Declaraciones ''si'' duplicadas
delete.fix.family.name=Eliminación de flecha
redundant.lambda.arrow=Flechas lambda duplicadas
remove.let.call=Elimine la llamada "dejar".
redundant.let.call.could.be.removed=Se pueden eliminar las llamadas "let" redundantes.
redundant.modality.modifier=Controlador de modalidad redundante
this.type.probably.can.be.changed.to.nullable=Este tipo se puede cambiar para que admita valores NULL.
redundant.type.checks.for.object=Comprobación de tipos duplicados para objetos
replace.with.equality.fix.text=Reemplace ''{0}'' con ''{1}''
redundant.0.call=Llamada ''{0}'' duplicada
remove.require.not.null.call.fix.text=Eliminar llamada ''{0}''
remove.return.label.fix.text=Eliminar duplicado ''@{0}''.
remove.return.label.fix.family=Eliminar etiquetas duplicadas.
redundant.0=Duplicar ''@{0}''
remove.redundant.sam.constructors=Elimine los constructores SAM redundantes.
remove.redundant.sam.constructor=Elimine los constructores SAM redundantes.
redundant.sam.constructors=Constructor SAM duplicado
redundant.sam.constructor=Constructor SAM duplicado
fix.text=Elimine los puntos y comas redundantes.
redundant.semicolon=Punto y coma duplicado
remove.redundant.setter.fix.text=Elimina configuradores duplicados
redundant.setter=Configurador duplicado
redundant.suspend.modifier=Controlador ''suspendido'' duplicado
redundant.unit.return.type=Tipo de retorno ''Unidad'' duplicado
redundant.visibility.modifier=Controladores de visibilidad duplicados
remove.redundant.unit.fix.text=Eliminar ''Unidad'' duplicada.
redundant.unit=Duplicar ''Unidad''
remove.redundant.with.fix.text=Eliminar llamadas "con" redundantes.
redundant.with.call=Duplicar llamadas ''con''
reformat.quick.fix.family.name=Reformatear el archivo
apply.only.to.modified.files.for.projects.under.a.version.control=Se aplica solo a archivos modificados (archivos en proyectos que están en control de versiones).
file.is.not.properly.formatted=El archivo no tiene el formato correcto.
remove.jvmoverloads.annotation=Eliminar la anotación @JvmOverloads
report.also.for.a.variables.without.a.whitespace.around=También informa sobre variables sin espacios circundantes.
remove.curly.braces=Retire los tirantes.
redundant.curly.braces.in.string.template=Llaves duplicadas en plantilla de cadena
remove.empty.parentheses.from.annotation.entry.fix.text=Elimine los paréntesis innecesarios.
parentheses.should.be.removed=Debes eliminar los paréntesis.
remove.redundant.qualifier.name.quick.fix.text=Elimina nombres de calificadores duplicados
redundant.qualifier.name=Nombre calificador duplicado
remove.redundant.backticks.quick.fix.text=Elimine las comillas invertidas redundantes.
remove.redundant.spread.operator.quickfix.text=Elimine los operadores de propagación redundantes.
remove.to.string.fix.text=Elimine la llamada ''toString()''.
redundant.tostring.call.in.string.template=Llamada duplicada ''toString()'' dentro de la plantilla de cadena
redundant.setter.parameter.type=Tipos de parámetros de establecimiento duplicados
replace.with.contentequals=Reemplace ''\!\='' por ''contentEquals''.
replace.with.contentequals2=Reemplace ''\=\='' por ''contentEquals''.
replace.with.contentequals3=Reemplace con ''contentEquals''.
dangerous.array.comparison=Comparación de matrices peligrosas
replace.with.array.literal.fix.family.name=Cambiar a [...]
0.call.should.be.replaced.with.array.literal=La llamada a ''{0}'' debe reemplazarse con un literal de matriz [...].
replace.assert.boolean.with.assert.equality=Reemplace la afirmación booleana con la afirmación de igualdad.
replace.0.with.1=Reemplace ''{0}'' con ''{1}''
replace.collection.count.with.size.quick.fix.text=Reemplace ''recuento'' por ''tamaño''.
could.be.replaced.with.size=Puedes cambiarlo a "tamaño".
replace.with.kotlin.s.function.call=Reemplazar con llamada de función en Kotlin
replace.guard.clause.with.kotlin.s.function.call=Reemplace la cláusula de protección con una llamada de función en Kotlin
replace.index.loop.with.collection.loop.quick.fix.text=Reemplácelo con un bucle sobre los elementos.
replace.manual.range.with.indices.call.quick.fix.text=Reemplazar con índice.
range.could.be.replaced.with.indices.call=Puede cambiar el rango llamando a ''.indices''.
for.loop.over.indices.could.be.replaced.with.loop.over.elements=Puede reemplazar el bucle for sobre el índice con un bucle sobre los elementos.
replace.negated.0.with.1=Reemplaza ''{0}'' negado por ''{1}''.
replace.with.elvis.return.fix.text=Reemplazar con ''?\: return{0}''.
replace.with.return=Reemplace ''\!\!'' por ''?\: return''.
convert.put.to.assignment=Convierte la tarea asignada.
map.put.should.be.converted.to.assignment=Necesitamos convertir map.put() en una tarea.
replace.int.range.end.inclusive.with.last.quick.fix.text=Reemplace ''endInclusive'' por ''último''.
replace.int.range.start.with.first.quick.fix.text=Reemplace ''inicio'' por ''primero''.
could.be.replaced.with.unboxed.last=Puede cambiarlo a "último" sin empaquetar.
could.be.replaced.with.unboxed.first=Puedes cambiarlo a "primero" sin caja.
replace.with.until.quick.fix.text=Cámbielo a hasta.
replace.with.string.literal.fix.family.name=Reemplazar con plantilla de cadena
replace.tostring.with.string.template=Reemplace ''toString'' con una plantilla de cadena.
replace.to.with.infix.form.quickfix.text=Reemplace ''a'' con formato infijo.
replace.with.enum.map.fix.text=Reemplácelo con EnumMap.
replaceable.with.enummap=Puedes reemplazarlo con EnumMap.
replace.with.operator.assignment=Cambiar a asignación de operador.
replaceable.with.operator.assignment=Se puede cambiar mediante sustitución de operador.
replace.with.0.eq=Reemplace con ''{0}\=''.
replace.with.if.fix.text=Reemplace con verificación de tipo ''si''.
should.be.replaced.with.if.type.check=Debería reemplazarse con una verificación de tipo "si".
call.is.replaceable.with.another.scope.function=Puede reemplazar la llamada con otra función de ámbito.
convert.scope.function.fix.family.name=Convertir a ''{0}''
variable.0.is.assigned.to.itself=La variable ''{0}'' está autoasignada.
remove.self.assignment.fix.text=Eliminar autoasignación
convert.to.nullable.type.fix.text=Convertir a un tipo que acepta valores NULL.
constructor.has.non.null.self.reference.parameter=El constructor tiene un parámetro de autorreferencia no nulo.
assign.backing.field.fix.text=Sustituya el campo de respaldo.
existing.backing.field.is.not.assigned.by.the.setter=El campo de respaldo existente no está asignado como configurador
replace.with.error=Reemplazar con ''?\: error(...)''.
replace.assert.with.operator=Reemplace las afirmaciones con operadores.
assert.should.be.replaced.with.operator=Las afirmaciones deben ser reemplazadas por operadores.
simplify.negated.operation=Simplifica las operaciones negadas.
negated.operation.should.be.simplified=Es necesario simplificar las operaciones negadas.
replace.negated.0.operation.with.1=Reemplace la operación negada ''{0}'' por ''{1}''.
simplify.when.fix.text=Simplifique ''cuándo''.
this.when.is.simplifiable=Este "cuándo" se puede simplificar.
sort.modifiers=Alineación del controlador
non.canonical.modifiers.order=Orden de controlador no estándar
modifiers.should.follow.annotations=El controlador debe venir después de la anotación.
remove.as.dynamic.call.fix.text=Elimine la llamada ''asDynamic''.
suspicious.asdynamic.member.invocation=Llamada sospechosa al miembro ''asDynamic''
0.creates.new.1.under.the.hood=''{0}'' crea un nuevo {1} bajo el capó
replace.with.filter.fix.text=Cambiar para filtrar.
change.type.to.mutable.fix.text=Cambie el tipo a Variable.
replace.with.assignment.fix.text=Reemplazar con asignación (el original está vacío).
join.with.initializer.fix.text=Combinado con un inicializador.
suspicious.combination.of.and=Combinación sospechosa de \=\= y \=\=\=
unlabeled.return.inside.lambda=Retorno sin etiqueta dentro de lambda
suspicious.var.property.its.setter.does.not.influence.its.getter.result=Propiedad ''var'' sospechosa\: su definidor no afecta el resultado de su captador.
variable.used.only.in.following.return.and.should.be.inlined=La variable se usa solo en la próxima devolución y debe estar insertada.
variable.is.same.as.0.and.should.be.inlined=La variable debe ser igual a ''{0}'' y estar insertada.
implicit.unsafe.cast.from.dynamic.to.0=Transmisión implícita (insegura) de dinámica a {0}
cast.explicitly.fix.text=Transmitir explícitamente.
unused.equals.expression=Expresión igual a obsoleta
since.kotlin.1.3.main.parameter.is.not.necessary=A partir de Kotlin 1.3, el parámetro principal no es necesario.
remove.token.from.function.declaration=Elimine el token ''\='' de la declaración de función.
unused.return.value.of.a.function.with.lambda.expression.body=Valor de retorno no utilizado de la función con cuerpo de expresión lambda
safe.delete.constructor=Constructor de eliminación segura
remove.unary.operator.fix.text=Elimina los operadores unarios no utilizados.
unused.unary.operator=Operador unario obsoleto
one.line.return=Devolver una línea
return.when=Cuando regrese
block.body=Cuerpo del bloque
use.expression.body.instead.of.0=Utilice el cuerpo de la expresión en lugar de {0}.
convert.to.expression.body.fix.text=Convertir al cuerpo de expresión.
when.has.only.else.branch.and.should.be.simplified=Dado que "cuándo" sólo tiene una rama "else", necesitamos simplificarla.
wrap.unary.operator.quickfix.text=Envuelva operadores y valores unarios con ().
make.0.1=Hacer de ''{0}'' un {1}
replace.with.0.operator=Reemplazar con el operador ''{0}''
do.you.want.to.make.new.extension.an.expected.declaration=¿Le gustaría hacer de una nueva expansión una declaración de anticipación?
loop.to.call.fix.family.name=Operación de conversión a stdlib
loop.to.call.fix.family.name2=Reemplazar con operaciones stdlib usando ''asSequence()''
loop.can.be.replaced.with.stdlib.operations=Puede reemplazar bucles con operaciones stdlib
text.add.setter=Agregar configurador
text.add.getter=Agregar captador
text.add.getter.and.setter=Agregar captadores y definidores
text.add.use.site.target.0=Agregar objetivo de sitio de uso ''{0}''
add.use.site.target=Agregar destino del sitio de uso
add.full.qualifier=Agregar calificador completo
add.braces.to.0.statement=Agregue llaves a la declaración ''{0}''.
add.braces.to.when.entry=Añadir llaves a la entrada ''cuándo''
add.braces.to.all.branches=Agregue llaves a todas las ramas
add.braces.to.if.all.statements=Agregue llaves a todas las declaraciones 'si'
add.braces.to.when.all.entries=Agregue llaves a todos los elementos 'cuándo'
add.jvmoverloads.annotation.to.0=Agregue la anotación ''@JvmOverloads'' a {0}
text.primary.constructor=Constructor predeterminado
function.0=Función ''{0}''
looking.for.usages.in.java.files=Buscando usos en un archivo Java...
add.return.at.0=Añadir retorno@{0}
add.0.to.argument=Agregue ''{0} \='' al argumento
add.val.var.to.parameter.0=Agregue val/var al parámetro ''{0}''
add.val.to.parameter.0=Agregue ''val'' al parámetro ''{0}''
add.val.var.to.primary.constructor.parameter=Agregue val/var a los parámetros predeterminados del constructor
make.primary.constructor.0=Crear constructor predeterminado {0}
change.visibility.modifier=Cambiar controlador de visibilidad
0.may.break.code={0} (puede romper tu código)
convert.to.vararg.parameter=Convertir al parámetro vararg
replace.with=Cambie ''||'' a ''\\&\\&''
replace.with2=Reemplazar ''\\&\\&'' con ''||''
can.t.modify.0={0} no se puede modificar
0.already.exists={0} ya existe
type.arguments.will.be.lost.after.conversion.0=Los argumentos de tipo se pierden cuando se convierten. {0}
call.with.arguments.will.be.skipped.0=Saltar llamadas con argumentos. {0}
looking.for.usages.and.conflicts=Buscando ubicaciones de uso y conflictos...
following.expression.won.t.be.processed.since.refactoring.can.t.preserve.its.semantics.0=Las siguientes expresiones no se procesan porque su significado no se puede conservar durante la refactorización: {0}
callable.reference.transformation.is.not.supported.0=No se admite la conversión de referencias invocables. {0}
can.t.replace.non.kotlin.reference.with.call.expression.0=Las referencias que no son de Kotlin no se pueden reemplazar con expresiones de invocación. {0}
convert.0.to.1=Convertir ''{0}'' a ''{1}''
convert.lambda.to.reference=Convertir lambda a referencia
select.target.code.block.file=Seleccione el bloque/archivo de código de destino.
select.target.file=Seleccione el archivo de destino.
replace.expression.with.if.expression=Cambiando la expresión ''\!\!'' a la expresión ''if''
replace.elvis.expression.with.if.expression=Convirtiendo expresiones de Elvis en expresiones ''si''
flatten.when.expression=Aplanar expresiones ''cuándo''
replace.if.expression.with.return=Cambie la expresión ''si'' para regresar
lift.return.out.of.if.expression=Eliminar el retorno de la expresión ''if''
replace.if.with.when=Cambie ''si'' por ''cuándo''
replace.safe.access.expression.with.if.expression=Conversión de expresiones de acceso seguro a expresiones ''if''
replace.assignment.with.if.expression=Cambiar la asignación a la expresión ''si''
replace.assignment.with.when.expression=Cambiar la asignación a la expresión ''cuando''
replace.property.initializer.with.if.expression=Cambiando el inicializador de propiedad a la expresión ''if''
replace.property.initializer.with.when.expression=Cambiando el inicializador de propiedad a la expresión ''cuando''
replace.return.with.if.expression=Cambiar volver a la expresión ''si''
replace.return.with.when.expression=Cambiar volver a la expresión ''cuando''
replace.when.with.if=Cambie ''cuándo'' por ''si''
replace.call.with.unary.operator=Conversión de llamadas a operadores unarios
replace.contains.call.with.in.operator=Reemplace la llamada "contiene" con el operador "en"
replace.invoke.with.direct.call=Reemplace ''invocar'' con llamada directa
copy.concatenation.text.to.clipboard=Copie el texto de la conexión al portapapeles.
split.property.declaration=División de declaraciones de propiedad
replace.with.stdlib.operations.with.use.of.assequence=Reemplazar con operaciones stdlib usando ''asSequence()''
replace.with.stdlib.operations=Operación de conversión a stdlib
use.withindex.instead.of.manual.index.increment=Utilice withIndex() en lugar del incremento de índice manual
add.braces=Agregar llaves
add.indices.to.for.loop=Agregar índice al bucle ''for''
add.jvmoverloads.annotation=Agregar la anotación ''@JvmOverloads''
add.jvmstatic.annotation=Agregar la anotación ''@JvmStatic''
add.labeled.return.to.last.expression.in.a.lambda=Eliminar el retorno etiquetado de la última expresión dentro de lambda
add.missing.component=Agregar componentes faltantes
add.names.to.call.arguments=Agregar nombre al argumento de llamada
add.names.to.this.argument.and.following.arguments=Agregar nombre a este argumento y al siguiente argumento
add.name.to.argument=Agregar nombre al argumento
make.open=Crear abierto
add.throws.annotation=Agregar la anotación ''@Throws''
add.remaining.branches=Agrega las ramas restantes.
convert.anonymous.function.to.lambda.expression=Convertir función anónima a expresión lambda
convert.to.lambda.expression=Convertir a expresión lambda
put.arguments.on.separate.lines=Colocar argumentos en líneas separadas
put.parameters.on.separate.lines=Colocar parámetros en líneas separadas
demorgan.law=Ley de demorgan
replace.with.end.of.line.comment=Cambiar al comentario de final de línea
convert.collection.constructor.to.function=Convertir el constructor de la colección en función
convert.to.sealed.class=Convertir a clase sellada
replace.with.a.for.loop=Reemplazar con un bucle ''for''
convert.function.to.property=Convertir función en propiedad
convert.function.type.parameter.to.receiver=Convertir parámetro de tipo de función a receptor
convert.function.type.receiver.to.parameter=Convertir receptor de tipo de función a parámetro
convert.to.nullable.var=Convertir a var anulable
convert.to.ordinary.property=Convertir a propiedad regular
replace.with.block.comment=Convertir para bloquear comentario
convert.to.lateinit.var=Convertir a lateinit var
convert.object.literal.to.class=Convertir objeto literal a clase
convert.to.lazy.property=Convertir en propiedad perezosa
convert.parameter.to.receiver=Convertir parámetro a receptor
convert.to.secondary.constructor=Convertir a constructor auxiliar
convert.property.getter.to.initializer=Convertir captador de propiedad en inicializador
convert.property.initializer.to.getter=Convertir el inicializador de propiedad en captador
convert.property.to.function=Convertir propiedades en funciones
can.t.replace.foreign.reference.with.call.expression.0=No puede reemplazar una referencia externa con una expresión de llamada. {0}
unrecognized.reference.will.be.skipped.0=Se omiten las referencias no reconocidas. {0}
property.overloaded.in.child.class.constructor=Propiedades sobrecargadas en constructores de subclases
property.has.an.actual.declaration.in.the.class.constructor=La declaración real de la propiedad está en el constructor de la clase.
convert.to.comparisons=Convertir para comparar
convert.receiver.to.parameter=Convertir receptor a parámetro
convert.reference.to.lambda=Convertir referencia a lambda
following.problems.are.found=Se encontraron los siguientes problemas:\n
all.expected.and.actual.classes.must.be.sealed.classes=Todas las clases previstas y reales deben ser clases selladas.\n
all.inheritors.must.be.nested.objects.of.the.class.itself.and.may.not.inherit.from.other.classes.or.interfaces=Todos los herederos deben ser objetos anidados de la propia clase y no deben heredar de otras clases o interfaces.\n
searching.inheritors=Buscando heredero...
convert.to.enum.class=Convertir a clase de enumeración
convert.to.primary.constructor=Convertir al constructor predeterminado
rename.to.01=Cambiar nombre a {0}
replace.0.name.with.spaces=Cambiar el nombre de {0} al espacio
convert.to.block.body=Convertir a cuerpo de bloque
convert.template.to.concatenated.string=Convertir plantilla en cadena concatenada
replace.with.a.foreach.function.call=Reemplazar con llamada a función ''forEach''
convert.concatenation.to.raw.string=Convertir concatenación a cadena sin formato
convert.concatenation.to.template=Convertir una conexión en una plantilla
convert.try.finally.to.use=Convertir try-finally a .use()
convert.to.unsafe.cast=Conversión a transmisión insegura
convert.to.0.as.1=Convertir ''{1} a {0}''
convert.to.0.unsafecast.1=Convertir a ''{0}.unsafeCast<{1}>()''
convert.to.unsafecast.call=Convertir a llamada unsafeCast()
convert.to.array.parameter=Convertir a parámetro de matriz
convert.to.assignment.expression=Convertir asignación en expresión de asignación
create.kotlin.subclass=Creando subclases de Kotlin
use.destructuring.declaration=Usando declaraciones desestructurantes
implement.as.constructor.parameter=Implementado como parámetro del constructor.
implement.abstract.member=Implementación de miembros abstractos
import.members.from.0=Obtener miembros de ''{0}''
import.members.with=Obtener miembros con ''*''
add.import.for.0=Agregar declaración de importación de ''{0}''
add.import.for.member=Agregar declaración de importación de miembros
indent.raw.string=Sangría de cadena sin formato
replace.infix.call.with.ordinary.call=Convertir llamadas infijas en llamadas ordinarias
insert.curly.braces.around.variable=Insertar llaves alrededor de las variables
add.explicit.type.arguments=Agregar argumentos de tipo explícito
introduce.backing.property=Propiedad de respaldo
introduce.import.alias=Insertar alias de declaraciones de importación
invert.if.condition=Invierte la condición ''si''.
iterate.over.0=Repetir ''{0}''
iterate.over.collection=Repetir colección
join.declaration.and.assignment=Combinando declaración y cesión
can.be.joined.with.assignment=Se puede combinar con la tarea.
put.arguments.on.one.line=Coloque los argumentos en una línea.
put.parameters.on.one.line=Colocar parámetros en una línea.
convert.lambda.expression.to.anonymous.function=Convertir expresión lambda en función anónima
convert.to.anonymous.function=Convertir a función anónima
merge.else.if=Fusionar declaraciones ''else if''
merge.if.s=Fusionar declaraciones ''si''
move.lambda.argument.into.parentheses=Mover los argumentos lambda entre paréntesis
class.0.already.contains.1=La clase ''{0}'' ya contiene {1}
0.in.1.will.require.class.instance=''{0}'' en {1} requiere una instancia de clase
searching.for.0=Buscando {0}
move.out.of.companion.object=Mover fuera del objeto complementario
calls.with.explicit.extension.receiver.won.t.be.processed.0=Las llamadas con receptores extendidos explícitos no se procesan. {0}
usages.of.outer.class.instance.inside.of.property.0.won.t.be.processed=El uso de una instancia de clase externa dentro de la propiedad ''{0}'' no se procesa
companion.object.already.contains.0=El objeto complementario ya contiene {0}
0.references.type.parameters.of.the.containing.class={0} parámetro de tipo de referencia de la clase contenida
0.is.overridden.by.declaration.s.in.a.subclass={0} se redefine como una declaración en una subclase
move.to.companion.object=Ir dentro del objeto complementario
moving.to.companion.object=Moviéndose al objeto complementario...
move.to.top.level=Ir al nivel superior
package.0.already.contains.1=El paquete ''{0}'' ya contiene {1}
move.to.class.body=Ir al cuerpo de la clase
move.to.constructor=Ir al constructor
convert.boolean.const.to.elvis=¿Booleano? \=\= Convertir constante a elvis
convert.object.literal.to.lambda=Convertir objeto literal a lambda
convert.to.lambda=Convertir a lambda
replace.by.0=Reemplazar con ''{0}''
replace.by.reconstructed.type=Reemplazar con tipo recreado
remove.argument.name=Eliminar nombre del argumento
remove.braces.from.when.entry=Quitar llaves de la entrada ''cuándo''
remove.braces.from.0.statement=Elimine las llaves de la declaración ''{0}''.
remove.braces=Quitar los frenillos
remove.braces.from.all.branches=Quitar llaves de todas las ramas.
remove.braces.from.if.all.statements=Eliminar llaves de todas las declaraciones 'si'
remove.braces.from.when.all.entries=Quitar llaves de todos los elementos "cuándo"
remove.constructor.keyword=Eliminar palabra clave del constructor
redundant.empty.class.body=Cuerpo de clase vacío duplicado
remove.unnecessary.parentheses.from.function.call.with.lambda=Eliminar paréntesis innecesarios de llamadas a funciones con lambdas
remove.empty.primary.constructor=Eliminar el constructor predeterminado vacío
remove.empty.constructor.body=Eliminar el cuerpo del constructor vacío
remove.explicit.lambda.parameter.types.may.break.code=Eliminar tipos de parámetros lambda explícitos (puede romper el código)
remove.explicit.supertype.qualification=Eliminar la normalización de supertipo explícita
remove.explicit.type.arguments=Eliminar argumentos de tipo explícito
remove.explicit.type.specification=Eliminar especificación de tipo explícita
remove.explicit.type.specification.from.0=Eliminar la especificación de tipo explícita de ''{0}''
remove.indices.in.for.loop=Eliminar índice en bucle ''for''
index.is.not.used.in.the.loop.body=El índice no se utiliza en el cuerpo del bucle.
remove.return.0=Devolver@{0} eliminar
remove.labeled.return.from.last.expression.in.a.lambda=Eliminar el retorno etiquetado de la última expresión dentro de lambda
remove.redundant.calls.of.the.conversion.method=Eliminar llamadas duplicadas a métodos de conversión
remove.single.expression.string.template=Eliminar plantilla de cadena de expresión única
redundant.string.template=Plantilla de cadena duplicada
remove.unnecessary.parentheses=Elimine los paréntesis innecesarios.
rename.class.to.0=Cambiar el nombre de la clase a {0}
rename.class.to.containing.file.name=Cambiar el nombre de la clase al nombre del archivo incrustado
rename.file.to.0.1=Cambie el nombre del archivo a {0}.{1}
rename.file.to.match.top.level.class.name=Cambie el nombre del archivo para que coincida con el nombre de la clase de nivel superior
replace.0.with=Reemplace ''{0}()'' con ''+\=''
replace.with1=Reemplazar con ''+\=''
replace.explicit.parameter.0.with.it=Reemplace el parámetro explícito ''{0}'' con ''it''
replace.it.with.explicit.parameter=Reemplace ''eso'' con un parámetro explícito
replace.with.0.1.2={0}[{1}] ?\: Reemplazar con {2}
replace.with.indexing.and.elvis.operator=Reemplazar con operador de indexación y operador de Elvis
replace.size.check.with.isnotempty=Cambie la verificación de tamaño a ''isNotEmpty''
replace.size.zero.check.with.isempty=Reemplace la verificación de tamaño cero con ''isEmpty''
replace.with.parameter.name=Reemplace ''_'' con el nombre del parámetro
replace.with.ordinary.assignment=Convertir a tarea regular
simplify.boolean.expression=Simplificar expresiones booleanas
specify.explicit.lambda.signature=Especificación de firma lambda explícita
specify.all.types.explicitly.in.destructuring.declaration=Especifique explícitamente todos los tipos en declaraciones de desestructuración.
cannot.infer.type.for.this.declaration=No se puede inferir el tipo de esta declaración.
split.if.into.two=Dividir ''si'' en dos partes
flip.0=Invertir ''{0}''
flip.binary.expression=Invertir expresión binaria
flip.equals=Invertir ''equals''
replace.with.infix.function.call=Reemplazar con llamada de función infija
to.ordinary.string.literal=Como un literal de cadena simple
to.raw.string.literal=Como un literal de cadena sin formato
remove.underscores=Eliminar subrayado
add.underscores=Añadir subrayado
excluded.methods=Métodos excluidos
use.of.0.method.instead.of.property.access.syntax=Utilice el método {0} en lugar de la sintaxis de acceso a la propiedad
use.property.access.syntax=Usar la sintaxis de acceso a la propiedad
convert.to.object.declaration=Convertir a declaración de objeto
comment=Comentario
expression=Expresión
statement=Construcción
class=Clase
object.declaration=Declaración de objeto
top.level=Arriba
analyse.modules.with.different.platforms.together=Analizar módulos juntos en diferentes plataformas.
rethrow.stored.pce.as.a.new.runtime.exception=Volver a lanzar un PCE guardado como una nueva excepción de tiempo de ejecución
minimal.line.count=Número mínimo de líneas
files.to.visit=Archivo de referencia
random.seed=Semilla aleatoria
number.of.attempts.then.files.in.project.0=Número de intentos > Archivos en proyecto, {0}
text.done=Completo
file.lines=Línea de archivo
max.functions.to.visit=Función máxima a referencia
move.refactoring.testing=Mover pruebas de refactorización
compiling.project=Compilando proyecto...
saving.files=Guardando archivo...
perform.refactoring=Realizar refactorización...
update.indices=Actualización del índice...
reset.files=Restablecer archivo...
cannot.get.or.create.results.file=No se puede importar o generar el archivo de resultados
cannot.get.project.root.directory=No se puede obtener el directorio raíz del proyecto
0.try.1.with.2.fails.and.3.verifications={0} [{2} falló en {1} intentos, verificado {3} veces]
test.result.log.file.will.be.placed.here=Los archivos de registro de resultados de las pruebas se colocan aquí
maximum.count.of.applied.refactoring.before.validity.check=Número máximo de refactorizaciones aplicadas antes de la validación
move.refactoring.test=Mover pruebas de refactorización
resolve.pasted.references=Resolver referencias pegadas
create.kotlin.file=Crear archivo Kotlin
type.alias.0=Escriba el alias "{0}"
type.parameter.0=Escriba el parámetro "{0}"
parameter.0=Parámetro "{0}"
property.0=Propiedad "{0}"
function.01=Función "{0}"
object.0=Objeto "{0}"
interface=Interfaz
constructor=Constructor
implicit.nothing.type=Tipo implícito "¿Nada?"
move.suspicious.callable.reference.into.parentheses=Mueva las referencias invocables sospechosas entre paréntesis ''()''
local.variable=Variable local
const.property=Propiedad constante
private.property=Propiedades privadas
object.or.top.level.property=Objeto o propiedad de nivel superior
property=Propiedades
test.function=Función de prueba
function=Función
enum.entry=Elemento de enumeración
create.subclass=Crear subclase
implement.sealed.class=Implementación de clase sellada
implement.abstract.class=Implementación de clase abstracta
implement.interface=Implementación de interfaz
implement.abstract.function=Implementación de funciones abstractas
implement.abstract.property=Implementando propiedades abstractas
replace.explicit.lambda.parameter.with.it=Reemplazar un parámetro lambda explícito con ''it''
create.test=Crear pruebas
convert.class.0.to.kotlin=Convertir la clase ''{0}'' a Kotlin
destination.directory=&Directorio de destino
language.version=Versión del &lenguaje
add.prefix.to.paths.in.source.map=Agregue prefijo\: a la ruta en el mapa fuente:
api.version=Versión API
embed.source.code.into.source.map=Incluir código fuente en el mapa fuente\:
enable.incremental.compilation=Habilitar compilación incremental
keep.compiler.process.alive.between.invocations=El proceso del compilador persiste entre llamadas.
script.templates.classpath=Ruta de clase de plantilla de script\:
module.kind=&Tipo de módulo\:
script.template.classes=Clase de plantilla de script (&T)\:
target.jvm.version=Versión de JVM de destino
reload.script.dependencies.on.file.change=Recargar dependencias de script cuando los archivos cambian
additional.command.line.parameters=Parámetros de línea de comando adicionales
mnemonic.install=&Instalación
status=(situación)
build.number.internal.mode=Número de compilación (modo interno)\:
check.again=&Revisar otra vez
current.kotlin.plugin.version=Versión actual del complemento Kotlin\:
experimental.features=Característica experimental
action.text.install=Instalación
update.channel=&Actualización del canal\:
version={versión}
don.t.show.this.dialog.next.time=&No mostrar este cuadro de diálogo la próxima vez
clipboard.content.copied.from.java.file.do.you.want.to.convert.it.to.kotlin.code=El contenido del portapapeles se copió de un archivo Java. ¿Le gustaría convertir a código Kotlin?
name=Nombre(&N)\:
return.type=Tipo de devolución (&R)\:
visibility=&Visibilidad\:
title.parameters=Parámetro
signature.preview=Vista previa de firma
move.members.from=Mueva los siguientes miembros:
open.moved.members.in.editor=Abrir miembro movido en el editor
open.moved.method.in.editor=Abrir un método movido en el editor
to.fully.qualified.name=Destino (nombre completo)\:
enable.components.for.library.to.source.analysis.in.kotlin=Habilitación de componentes para el análisis de bibliotecas basados en archivos fuente del proyecto en Kotlin
incomplete.destructuring.declaration.text=Declaración de desestructuración incompleta
incomplete.destructuring.fix.family.name=Agregar variables faltantes a la declaración de desestructuración
category.class=Kotlin/basado en clases
category.comments=Kotlin/anotaciones, KDoc y metadatos
category.expressions=Kotlin/Expresiones
category.functions=Kotlin/funciones
category.interesting=Kotlin/Interés
category.operators=Kotlin/Operadores
context.default=Por defecto
context.property.getter.or.setter=Propiedades con captadores/definidores explícitos
error.context.getter.or.setter=Este contexto solo se aplica a propiedades con captadores/definidores explícitos. (Establezca el formato de archivo en Kotlin)
error.expected.an.expression=Se requiere expresión
error.expected.catch.or.finally=Requiere 'atrapar' o 'finalmente'
error.param.can.t.be.null.at.index.0.in.1=El parámetro no puede ser nulo en el índice {0} en {1}.
error.type.filter.node=Los elementos de coincidencia de Kotlin deben ser expresiones o declaraciones.
filter.match.only.vals=Coincide solo con val
filter.match.only.vars=Solo coincide con var
label.match.only.vals=Solo coincide con val
label.match.only.vars=Solo coincide con var
predefined.configuration.all.methods.of.the.class=Todos los métodos en la clase
predefined.configuration.all.vars.of.the.class=Todas las var/vals en clase
predefined.configuration.all.vars.of.the.object=Cualquier var/val en el objeto u objeto complementario
predefined.configuration.annotations=Anotación
predefined.configuration.anonymous.class=Clase anónima
predefined.configuration.array.access=Acceso a la matriz
predefined.configuration.assert.not.null=Operador de aserción no nulo
predefined.configuration.assignments=Admisiones universitarias
predefined.configuration.casts=Encasillar
predefined.configuration.class.annotation=Clase comentada
predefined.configuration.comments.containing.word=Comentarios que contienen palabras dadas
predefined.configuration.do.while=Hacer... mientras bucle
predefined.configuration.elvis=Operador de elvis
predefined.configuration.for=En bucle
predefined.configuration.function.annotation=Funciones anotadas
predefined.configuration.function.signature=Firma de función
predefined.configuration.ifs=Si
predefined.configuration.instance=Instancia
predefined.configuration.kdoc.tag=Etiqueta KDoc
predefined.configuration.lambda=Expresión lambda
predefined.configuration.method.calls=Llamada al método
predefined.configuration.properties.getter=Propiedades con captadores explícitos
predefined.configuration.safe.call.operator=Operador de llamada segura
predefined.configuration.string.literals=Literal de cadena
predefined.configuration.strings=Cadena
predefined.configuration.strings.with.long.template=Cadena con plantilla larga
predefined.configuration.trys=Intentar
predefined.configuration.vals.only=Solo val
predefined.configuration.vars.of.given.type=Var y val de tipo dado
predefined.configuration.vars.only=Solo var
predefined.configuration.when=Cuando la expresión
predefined.configuration.while=Mientras bucle
action.Kotlin.StopScratch.text=Detener la ejecución de Scratch
action.Kotlin.StopScratch.description=Detener la ejecución de Scratch
action.Kotlin.ClearScratch.text=Eliminación de arañazos de Kotlin
action.Kotlin.ClearScratch.description=Eliminación de arañazos de Kotlin
action.Kotlin.RunScratch.text=Ejecutando Kotlin Scratch
action.Kotlin.RunScratch.description=Ejecutando Kotlin Scratch
action.KotlinGenerateToString.text=Encadenar()
action.KotlinGenerateEqualsAndHashCode.text=Es igual a() y hashCode()
action.KotlinGenerateSecondaryConstructor.text=Constructor secundario
action.KotlinGenerateDataMethod.text=Función de parámetro
action.KotlinGenerateTearDownMethod.text=Función de desmontaje
action.KotlinGenerateSetUpMethod.text=Función de configuración
action.KotlinGenerateTestMethod.text=Función de prueba
action.KotlinShellExecute.text=Ejecutando código Kotlin
action.KotlinShellExecute.description=Ejecute el código Kotlin en la consola
action.IntroduceTypeAlias.text=_Alias de tipo…
action.IntroduceTypeParameter.text=Parámetro de _tipo…
action.ExtractFunctionToScope.text=Fun_ción al ámbito…
action.KotlinThrowException.text=Eliminar errores en los complementos de Kotlin
action.KotlinFormattingSettingsStatusAction.text=Acerca de la configuración de la herramienta de formato
action.CopyAsDiagnosticTest.text=Copiar el archivo actual como prueba de diagnóstico
action.MultiplatformCompositeAnalysisToggleAction.text=Conversión de análisis complejos
action.StoredExceptionsThrowToggleAction.text=Lanzamiento de PCE en caché
action.PrintOutNotPropertyMatches.text=Búsqueda de candidatos no inmobiliarios
action.FindImplicitNothingAction.text=Encuentra llamadas nada implícitas
action.CheckComponentsUsageSearchAction.text=Confirmar la búsqueda de ubicación de uso de la función del componente
action.CacheResetOnProcessCanceledToggleAction.text=Restablecer caché para ProcessCanceledException
action.HighlightingBenchmarkAction.text=Resaltado de puntos de referencia
action.LocalCompletionBenchmarkAction.text=Escenario local
action.TopLevelCompletionBenchmarkAction.text=Escenario superior
group.KotlinCompletionBenchmarkGroup.text=Finalización del punto de referencia
group.KotlinInternalGroup.text=Kotlin
action.TestMoveRefactiringAction.text=Probar Go Refactoring en un proyecto abierto
group.KotlinRefactoringTesting.text=Pruebas de refactorización de Kotlin
action.DumbModeTremble.text=Temblar modo tonto
group.InternalKotlin.text=Acciones dentro de Kotlin
action.IntroduceProperty.text=_Propiedad…
action.ExtractFunction.text=_Función…
action.KotlinCodeMigrationToggle.text=Habilitar la detección de migración(experimental)
action.KotlinCodeMigration.text=Ejecutar la migración de código
action.CopyKotlinProjectInformation.text=Copiar el esquema del proyecto de Kotlin al portapapeles
action.DecompileKotlinToJava.text=Descompilar Kotlin en Java
action.KotlinConfigureUpdates.text=Configurar las actualizaciones del complemento de Kotlin
action.KotlinConfigureUpdates.description=Configurar actualizaciones automáticas para complementos de Kotlin
group.KotlinToolsGroup.text=Kotlin
action.ConvertJavaToKotlin.text=Convierta archivos Java a archivos Kotlin
action.Kotlin.XDebugger.ToggleKotlinVariableView.text=Mostrar solo variables de Kotlin
action.InspectBreakpointApplicability.text=Comprobación de la aplicabilidad del punto de interrupción
action.Kotlin.XDebugger.CoroutinesDump.text=Obtener volcado de rutina
action.AddToProblemApiInspection.text=Informar como API incompatible.
action.ShowKotlinBytecode.text=Visualización del código de bytes de Kotlin
action.ConfigureKotlinJsInProject.text=Configure Kotlin (JavaScript) en el proyecto
action.ConfigureKotlinInProject.text=Configurar Kotlin en el proyecto
action.KotlinConsoleREPL.text=REPL de Kotlin
action.LibraryToSourceDependencySupportToggleAction.text=Cambiar la biblioteca al soporte de dependencia de origen
inspection.unused.unary.operator.display.name=Operador unario obsoleto
inspection.incomplete.destructuring.declaration.display.name=Declaración de desestructuración incompleta
inspection.replace.guard.clause.with.function.call.display.name=Reemplace la cláusula de protección con una llamada de función en Kotlin
inspection.lateinit.var.overrides.lateinit.var.display.name=La propiedad lateinit var anula la propiedad lateinit var
inspection.kotlin.equals.between.inconvertible.types.display.name=''es igual a()'' entre objetos de tipos no convertibles
inspection.redundant.empty.initializer.block.display.name=Duplicar bloque inicializador vacío
inspection.add.operator.modifier.display.name=La función debe tener un controlador ''operador''.
inspection.control.flow.with.empty.body.display.name=Control de flujo con cuerpo vacío.
inspection.replace.java.static.method.with.kotlin.analog.display.name=Conversión de métodos estáticos de Java a análogos de Kotlin
inspection.self.reference.constructor.parameter.display.name=El constructor tiene un parámetro de autorreferencia no nulo.
inspection.replace.not.null.assertion.with.elvis.return.display.name=Reemplace ''\!\!'' por ''?\: return''.
inspection.kotlin.covariant.equals.display.name=Covarianza ''es igual()''
inspection.replace.associate.function.display.name=Reemplace ''asociar'' con ''asociarPor'' o ''asociarCon''
inspection.java.map.for.each.display.name=Debe reemplazar la llamada al método Java Map.forEach con forEach de Kotlin.
inspection.kotlin.throwable.not.thrown.display.name=Arrojable no es arrojado
inspection.redundant.require.not.null.call.display.name=Llamadas duplicadas ''requireNotNull'' o ''checkNotNull''
inspection.replace.range.start.end.inclusive.with.first.last.display.name=Reemplace el rango ''inicio'' o ''endInclusive'' con ''primero'' o ''último''
inspection.redundant.enum.constructor.invocation.display.name=Llamadas duplicadas al constructor de enumeraciones
inspection.replace.negated.is.empty.with.is.not.empty.display.name=Reemplace ''isEmpty''/''isBlank'' negado por ''isNotEmpty''/''isNotBlank''
inspection.function.with.lambda.expression.body.display.name=Funciones con ''\={... }'' y tipos de retorno inferidos
inspection.suspend.function.on.coroutine.scope.display.name=CoroutineContext oscurecido por el receptor CoroutineScope en función de suspensión
inspection.boolean.literal.argument.display.name=Argumento literal booleano sin nombre de parámetro
inspection.suspicious.collection.reassignment.display.name=La asignación aumentada crea una nueva colección en el interior.
inspection.redundant.else.in.if.display.name=Duplicar ''else'' dentro de ''if''
inspection.deferred.is.result.display.name=Función que devuelve Diferido directamente
inspection.map.get.with.not.null.assertion.operator.display.name=''map.get()'' con operador de aserción no nulo (\!\!)
inspection.delegation.to.var.property.display.name=Delegar a la propiedad ''var''
inspection.unused.main.parameter.display.name=No se requieren parámetros clave
inspection.suspicious.var.property.display.name=Propiedad sospechosa ''var'': su colocador no afecta el resultado de su captador.
inspection.setter.backing.field.assignment.display.name=Un campo de respaldo existente no se asigna como definidor.
inspection.unlabeled.return.inside.lambda.display.name=Retorno sin etiqueta dentro de lambda
inspection.optional.expectation.display.name=La anotación requerida opcionalmente no tiene anotación real
inspection.remove.empty.parentheses.from.annotation.entry.display.name=Elimine los paréntesis innecesarios.
inspection.safe.cast.with.return.display.name=Los lanzamientos seguros con "retorno" deben reemplazarse con comprobaciones de tipo "si"
inspection.simplifiable.call.display.name=Las llamadas a funciones de biblioteca se pueden simplificar
inspection.redundant.run.catching.display.name=Llamada ''runCatching'' duplicada
inspection.direct.use.of.result.type.display.name=Función que devuelve resultado directamente
inspection.redundant.return.label.display.name=Etiqueta de ''devolución'' duplicada
inspection.replace.assert.boolean.with.assert.equality.display.name=Reemplace la afirmación booleana con la afirmación de igualdad.
inspection.suspicious.as.dynamic.display.name=Llamada sospechosa al miembro ''asDynamic''
inspection.convert.call.chain.into.sequence.display.name=Para mejorar el rendimiento, puede convertir la cadena de llamadas de una colección en una "Secuencia".
inspection.redundant.with.display.name=Duplicar llamadas ''con''
inspection.obsolete.experimental.coroutines.display.name=Las ubicaciones de uso de rutinas experimentales están obsoletas a partir de 1.3
inspection.obsolete.kotlin.js.packages.display.name=El paquete ''kotlin.browser'' min ''kotlin.dom'' está en desuso desde 1.4
inspection.warning.on.main.unused.parameter.migration.display.name=''args'' en ''main'' está en desuso desde 1.4
inspection.prohibit.repeated.use.site.target.annotations.migration.display.name=Las anotaciones repetibles sin ''@Repeatable'' no están permitidas desde la versión 1.4
inspection.prohibit.use.site.target.annotations.on.super.types.migration.display.name=Las anotaciones en superclases no tienen sentido a partir de 1.4.
inspection.redundant.label.migration.display.name=Etiquetas duplicadas desde 1.4
inspection.restrict.return.statement.target.migration.display.name=A partir de 1.4, las etiquetas de destino no indican funciones
inspection.prohibit.jvm.overloads.on.constructors.of.annotation.classes.migration.display.name=A partir de la versión 1.4, la anotación ''@JvmOverloads'' no se puede utilizar en el constructor de una clase anotada.
inspection.prohibit.type.parameters.for.local.variables.migration.display.name=Desde 1.4, las variables locales no pueden tener parámetros de tipo.
inspection.from.closed.range.migration.display.name=MIN_VALUE paso desdeClosedRange() desde 1.3
inspection.replace.to.string.with.string.template.display.name=Reemplace ''toString'' con una plantilla de cadena.
inspection.nested.lambda.shadowed.implicit.parameter.display.name=Lambda anidada tiene parámetros implícitos ocultos
inspection.for.each.parameter.not.used.display.name=Los elementos repetidos no se utilizan en forEach
inspection.replace.string.format.with.literal.display.name=Reemplazar con plantilla de cadena
inspection.deferred.result.unused.display.name=Los resultados diferidos nunca se utilizan.
inspection.redundant.async.display.name=Llamadas ''asincrónicas'' duplicadas
inspection.main.function.return.unit.display.name=La función de punto de entrada debe devolver la Unidad
inspection.move.variable.declaration.into.when.display.name=La declaración de variable se puede mover dentro de ''cuando''
inspection.move.lambda.outside.parentheses.display.name=Argumentos lambda entre paréntesis
inspection.can.sealed.sub.class.be.object.display.name=Subclase sellada sin estado y sin iguales anulados
inspection.public.api.implicit.type.display.name=La declaración de API pública tiene un tipo de retorno implícito.
inspection.redundant.companion.reference.display.name=Referencia complementaria duplicada
inspection.convert.pair.constructor.to.to.function.display.name=Convertir el constructor de pares en la función ''a''
inspection.redundant.not.null.extension.receiver.of.inline.display.name=Los receptores de extensión no nulos de funciones en línea se pueden convertir en anulables
inspection.platform.extension.receiver.of.inline.display.name=Llamada insegura de función en línea con receptor extendido anulable
inspection.scope.function.conversion.display.name=Las funciones de rango se pueden convertir en otras funciones.
inspection.redundant.object.type.check.display.name=Comprobación de tipos duplicados para objetos
inspection.fake.jvm.field.constant.display.name=Propiedades de Kotlin no constantes utilizadas como constantes de Java
inspection.may.be.constant.display.name=Puede ser "constante".
inspection.sort.modifiers.display.name=Orden de controlador no estándar
inspection.redundant.suspend.modifier.display.name=Controlador ''suspendido'' duplicado
inspection.replace.put.with.assignment.display.name=''map.put()'' se puede convertir en asignación
inspection.replace.to.with.infix.form.display.name=Convertir ''a'' a formato infijo
inspection.recursive.equals.call.display.name=Llamada recursiva igual a
inspection.java.collections.static.method.on.immutable.list.display.name=Llamada de modificador de Java en una colección Kotlin inmutable''
inspection.java.collections.static.method.display.name=Las llamadas a métodos estáticos de la colección Java se pueden reemplazar con Kotlin stdlib
inspection.simplify.when.with.boolean.constant.condition.display.name=''cuándo'' se puede simplificar
inspection.implicit.nullable.nothing.type.display.name=Tipo implícito "¿Nada?"
inspection.self.assignment.display.name=Autoasignación de variables
inspection.redundant.unit.expression.display.name=Duplicar ''Unidad''
inspection.implicit.this.display.name=Implícito "esto"
inspection.explicit.this.display.name=Duplicar explícito esto ''
inspection.migrate.diagnostic.suppression.display.name=Es necesario cambiar el nombre del diagnóstico.
inspection.redundant.setter.display.name=Establecedor de propiedades duplicadas
inspection.remove.redundant.qualifier.name.display.name=Elimine los nombres de calificadores duplicados.
inspection.remove.redundant.backticks.display.name=Elimine las comillas invertidas redundantes.
inspection.redundant.getter.display.name=Captador de propiedades duplicadas
inspection.suspicious.equals.combination.display.name=Combinación sospechosa de \=\= y \=\=\=
inspection.kotlin.redundant.override.display.name=Método anulado duplicado
inspection.package.name.display.name=Convención de nomenclatura de paquetes
inspection.local.variable.name.display.name=Convenciones de nomenclatura de variables locales
inspection.const.property.name.display.name=Convención de nomenclatura de propiedades constantes
inspection.private.property.name.display.name=Convención de nomenclatura de propiedad privada
inspection.object.property.name.display.name=Convención de nomenclatura de propiedades de objetos
inspection.property.name.display.name=Convención de nomenclatura de propiedades
inspection.test.function.name.display.name=Convención de nomenclatura de funciones de prueba
inspection.function.name.display.name=Convención de nomenclatura de funciones
inspection.enum.entry.name.display.name=Convenciones de nomenclatura de elementos de enumeración
inspection.class.name.display.name=Convención de nomenclatura de clases
inspection.redundant.lambda.arrow.display.name=Flechas lambda duplicadas
inspection.redundant.lambda.or.anonymous.function.display.name=Creación duplicada de lambdas o funciones anónimas.
inspection.redundant.lambda.description=Creando lambdas duplicadas
inspection.redundant.anonymous.function.description=Crear funciones anónimas duplicadas
inspection.redundant.lambda.or.anonymous.function.fix=En línea el texto
inspection.when.with.only.else.display.name=Simplifica porque ''cuando'' solo tiene una rama ''else''
inspection.kotlin.double.negation.display.name=Doble negativo redundante
inspection.unnecessary.variable.display.name=Variables locales innecesarias
inspection.constant.condition.if.display.name=La condición de la expresión ''si'' es una constante.
inspection.null.checks.to.safe.call.display.name=Verificación nula que se puede reemplazar con una llamada segura
inspection.cascade.if.display.name=Cascada si se puede cambiar a cuándo
inspection.lift.return.or.assignment.display.name=La devolución o cesión se puede eliminar
inspection.use.expression.body.display.name=Aquí se recomienda la sintaxis del cuerpo de la expresión:
inspection.simplifiable.call.chain.display.name=Puede simplificar las cadenas de llamadas para tipos de colección.
inspection.useless.call.on.collection.display.name=Llamadas innecesarias a tipos de cobranza
inspection.redundant.explicit.type.display.name=Los tipos especificados explícitamente son redundantes aquí.
inspection.useless.call.on.not.null.display.name=Llamada innecesaria a tipo no nulo
inspection.remove.redundant.spread.operator.display.name=Operador de extensión redundante
inspection.empty.range.display.name=Los rangos con inicio mayor que endInclusive quedan vacíos.
inspection.wrap.unary.operator.display.name=Usar operadores unarios ambiguos con constantes numéricas
inspection.nullable.boolean.elvis.display.name=Se puede utilizar la prueba de igualdad en lugar de Elvis para pruebas booleanas anulables
inspection.member.visibility.can.be.private.display.name=Los miembros de la clase pueden tener visibilidad "privada"
inspection.replace.range.to.with.until.display.name=Las llamadas ''rangeTo'' o ''..'' se pueden reemplazar con ''hasta''
inspection.recursive.property.accessor.display.name=Accesor de propiedad recursivo
inspection.replace.array.of.with.literal.display.name=Es posible reemplazar la llamada ''arrayOf'' con un literal de matriz [...]
inspection.copy.without.named.arguments.display.name=El método ''copia'' de la clase de datos se llama sin argumentos con nombre.
inspection.move.suspicious.callable.reference.into.parentheses.display.name=Referencia invocable sospechosa utilizada como resultado lambda
inspection.kotlin.internal.in.java.display.name=Dónde usar declaraciones dentro de Kotlin en Java
inspection.kotlin.sealed.in.java.display.name=Kotlin interfaz sellada/herencia de clases en Java
inspection.unused.lambda.expression.body.display.name=Valor de retorno no utilizado de la función con cuerpo de expresión lambda
inspection.destructuring.wrong.name.display.name=Una variable en una declaración de desestructuración utiliza el nombre de una propiedad de clase de datos incorrecta.
inspection.data.class.private.constructor.display.name=Constructor de clase de datos privados expuesto mediante el método ''copiar''
inspection.replace.with.enum.map.display.name=Reemplácelo con EnumMap.
inspection.unused.equals.display.name=Expresión igual a obsoleta
inspection.convert.na.n.equality.display.name=Convierta la comprobación de igualdad con ''NaN'' para llamar a ''isNaN''
inspection.convert.two.comparisons.to.range.check.display.name=Debe convertir los dos elementos de comparación en una verificación de rango.
inspection.convert.try.finally.to.use.call.display.name=Convierta la llamada try/finally a use()
inspection.join.declaration.and.assignment.display.name=Combinando declaración y cesión
inspection.remove.empty.secondary.constructor.body.display.name=Eliminar el cuerpo del constructor vacío
inspection.remove.empty.primary.constructor.display.name=Eliminar el constructor predeterminado vacío
inspection.remove.redundant.calls.of.conversion.methods.display.name=Eliminar llamadas duplicadas a métodos de conversión
inspection.remove.empty.class.body.display.name=Reemplazo de un cuerpo de clase vacío
inspection.replace.size.zero.check.with.is.empty.display.name=Reemplace la verificación de tamaño cero con ''isEmpty()''
inspection.replace.size.check.with.is.not.empty.display.name=Cambie la verificación de tamaño a ''isNotEmpty()''
inspection.convert.secondary.constructor.to.primary.display.name=Convertir al constructor predeterminado
inspection.complex.redundant.let.display.name=Llamada ''let'' basada en argumentos duplicados
inspection.simple.redundant.let.display.name=Llamadas "let" duplicadas basadas en el receptor
inspection.replace.array.equality.op.with.arrays.equals.display.name=Reemplace ''\=\='' con ''Arrays.equals''
inspection.remove.empty.parentheses.from.lambda.call.display.name=Eliminar paréntesis innecesarios de llamadas a funciones con lambdas
inspection.remove.to.string.in.string.template.display.name=Eliminar llamadas redundantes ''toString()'' dentro de plantillas de cadenas
inspection.remove.single.expression.string.template.display.name=Eliminar plantillas de cadenas duplicadas
inspection.replace.call.with.binary.operator.display.name=Se puede convertir a operadores binarios.
inspection.remove.setter.parameter.type.display.name=Tipos de parámetros de establecimiento duplicados
inspection.convert.reference.to.lambda.display.name=Se puede reemplazar con lambda.
inspection.convert.lambda.to.reference.display.name=Se puede reemplazar con referencia de función
inspection.can.be.primary.constructor.property.display.name=La propiedad se asigna explícitamente al parámetro del constructor.
inspection.has.platform.type.display.name=La función o propiedad tiene un tipo de plataforma.
inspection.leaking.this.display.name=''esta'' fuga en el constructor
inspection.redundant.if.display.name=Declaraciones ''si'' duplicadas
inspection.redundant.unit.return.type.display.name=Tipo de retorno ''Unidad'' duplicado
inspection.redundant.semicolon.display.name=Punto y coma duplicado
inspection.redundant.modality.modifier.display.name=Controlador de modalidad redundante
inspection.can.be.parameter.display.name=Los parámetros del constructor no se utilizan como propiedades.
inspection.replace.substring.with.substring.before.display.name=Reemplace la llamada ''subcadena'' con una llamada ''subcadenaAntes''.
inspection.replace.substring.with.substring.after.display.name=Reemplace la llamada ''subcadena'' con una llamada ''subcadenaDespués''.
inspection.replace.substring.with.indexing.operation.display.name=Reemplace la llamada ''subcadena'' con una llamada a la operación de índice.
inspection.replace.substring.with.take.display.name=Reemplace la llamada ''subcadena'' con una llamada ''take''.
inspection.replace.substring.with.drop.last.display.name=Reemplace la llamada ''subcadena'' con una llamada ''dropLast''.
inspection.add.variance.modifier.display.name=Los parámetros de tipo pueden tener distribución ''dentro'' o ''fuera''
inspection.protected.in.final.display.name=La visibilidad "protegida" es efectivamente "privada" en una clase final.
inspection.array.in.data.class.display.name=Propiedades de matriz en clases de datos
inspection.can.be.val.display.name=La ''var'' local no está calificada y puede declararse como ''val''
inspection.destructure.display.name=Usando declaraciones desestructurantes
inspection.redundant.visibility.modifier.display.name=Controladores de visibilidad duplicados
inspection.equals.or.hash.code.display.name=''equals()'' y ''hashCode()'' no son un par
inspection.conflicting.extension.property.display.name=La propiedad extendida entra en conflicto con la propiedad integrada
inspection.use.with.index.display.name=Las variables de índice incrementadas manualmente se pueden reemplazar usando ''withIndex()''
inspection.loop.to.call.chain.display.name=Los bucles se pueden reemplazar con operaciones stdlib
inspection.remove.for.loop.indices.display.name=Índice de bucle no utilizado
inspection.kotlin.deprecation.display.name=Dónde utilizar sintaxis redundante o obsoleta o símbolos obsoletos
inspection.package.directory.mismatch.display.name=El nombre del paquete no coincide con el directorio que lo contiene
inspection.k.doc.missing.documentation.display.name=Falta el comentario de KDoc en la declaración pública
inspection.k.doc.unresolved.reference.display.name=Referencias no resueltas dentro de KDoc
inspection.overriding.deprecated.member.display.name=Anulación de miembros obsoletos
inspection.unsafe.cast.from.dynamic.display.name=Conversión implícita (insegura) de tipo dinámico
inspection.redundant.sam.constructor.display.name=Constructor SAM duplicado
inspection.kotlin.unused.import.display.name=Directiva de importación obsoleta
inspection.unused.receiver.parameter.display.name=Parámetros del receptor obsoletos
inspection.unused.symbol.display.name=Símbolo no utilizado
inspection.use.property.access.syntax.display.name=Llamadas a accesores que pueden reemplazarse con declaraciones de acceso a propiedades
inspection.simplify.boolean.with.constants.display.name=Expresiones booleanas simplificables
inspection.remove.curly.braces.from.template.display.name=Llaves duplicadas en plantilla de cadena
inspection.introduce.when.subject.display.name=''cuándo'' se puede simplificar mediante la inserción de argumentos
inspection.replace.with.operator.assignment.display.name=Asignación que se puede cambiar mediante la asignación del operador
inspection.simplify.negated.binary.expression.display.name=Expresiones booleanas negadas que se pueden simplificar
inspection.remove.explicit.super.qualifier.display.name=Normalización de supertipo innecesaria
inspection.remove.explicit.type.arguments.display.name=Argumentos de tipo innecesarios
inspection.fold.initializer.and.if.to.elvis.display.name=If-Null return/break/... plegable con ''?\:''
inspection.if.then.to.safe.access.display.name=Si-Entonces eso se puede contraer en ''?''.
inspection.if.then.to.elvis.display.name=Si-Entonces plegable con ''?\:''
inspection.replace.manual.range.with.indices.calls.display.name=Convertir un rango manual para indexar o repetir colecciones
inspection.replace.get.or.set.display.name=Llamada explícita ''get'' o ''set''
inspection.convert.to.string.template.display.name=Concatenar cadenas que se pueden convertir en plantillas de cadenas
inspection.deprecated.callable.add.replace.with.display.name=@Anotación obsoleta sin argumento ''replaceWith''
inspection.replace.collection.count.with.size.display.name=Los agregados de la colección se pueden convertir al tamaño
inspection.reformat.display.name=El archivo no está formateado según la configuración del proyecto.
inspection.simplify.assert.not.null.display.name=Las llamadas ''assert'' se pueden reemplazar con ''\!\!'' o ''?\:''
inspection.object.literal.to.lambda.display.name=Los literales de objetos se pueden convertir en lambdas.
remove.redundant.elvis.return.null.text=¿Eliminar duplicado ''?\: devolver nulo''
inspection.redundant.elvis.return.null.descriptor=Duplicar ''?\: devolver nulo''
inspection.redundant.elvis.return.null.display.name=Duplicar ''?\: devolver nulo''
inspection.redundant.inner.class.modifier.descriptor=Controlador ''interno'' duplicado
inspection.redundant.inner.class.modifier.display.name=Controlador ''interno'' duplicado
fix.remove.annotation.text=Eliminar anotación
inspection.trailing.comma.display.name=Se recomienda coma al final
inspection.trailing.comma.report.also.a.missing.comma=Informe también las comas faltantes o los saltos de línea
inspection.trailing.comma.add.line.break=Agregar salto de línea
inspection.trailing.comma.missing.line.break=Falta salto de línea
inspection.trailing.comma.remove.trailing.comma=Elimine las comas finales.
inspection.trailing.comma.useless.trailing.comma=Coma final innecesaria
inspection.trailing.comma.add.trailing.comma=Agregar una coma al final
inspection.trailing.comma.missing.trailing.comma=Falta la coma final
inspection.trailing.comma.fix.comma.position=Corregir la posición de la coma
inspection.trailing.comma.comma.loses.the.advantages.in.this.position=En esta posición se pierde el beneficio de la coma.
inspection.redundant.label.text=Etiqueta duplicada
intention.convert.lambda.line=Convertir a lambda en {0,choice,0\#single|1\#multiple} líneas
intention.trailing.comma.custom.text=La herramienta de formato tiene por defecto la coma final en {0,choice,0\#enable|1\#disable}
intention.trailing.comma.text=Activar/desactivar comas finales en herramientas de formato
fix.remove.argument.text=Eliminar argumento
fix.remove.redundant.star.text=Eliminar duplicados *
refactoring.extract.to.separate.file.text=Extraer en archivo separado
progress.title.analyze.extraction.data=Extraer análisis de datos...
fix.move.file.to.package.dir.name.text=Raíz fuente
move.refactoring.error.text.cannot.perform.refactoring.since.the.following.files.already.exist=No se puede realizar la refactorización porque ya existe el siguiente archivo:\n\n
kotlin.script.definitions.title=Administrar definiciones de scripts
kotlin.script.definitions.model.name.autoReloadScriptDependencies.description=Habilite la recarga automática para cargar automáticamente la configuración del script cuando los archivos cambien.
kotlin.script.definitions.model.name.autoReloadScriptDependencies=Recarga automática
kotlin.script.definitions.model.name.is.enabled=Habilitado
kotlin.script.definitions.model.name.pattern.extension=Patrón/Extensión
kotlin.script.definitions.model.name.name=Nombre
codestyle.name.kotlin=Kotlin
add.missing.class.keyword=Agregar la palabra clave "clase" que falta
fix.move.typealias.to.top.level=Mover el alias de tipo al nivel superior
fix.change.jvm.name=Cambiar nombre de JVM
expand.boolean.expression.to.if.else=Expandir expresiones booleanas en declaraciones ''if else''
inspection.logger.initialized.with.foreign.class.display.name=El registrador se ha inicializado como una clase externa.
logger.initialized.with.foreign.class=Registrador inicializado con clase externa ''{0}''
inspection.redundant.assequence.call=Llamada duplicada ''asSequence''
remove.assequence.call.fix.text=Eliminar la llamada ''asSequence''
codestyle.layout.import.aliases.separately=Importar alias individualmente
button.add.package=Agregar paquete
listbox.import.package=Paquete
listbox.import.with.subpackages=Incluir subpaquetes
title.import.layout=Obtener diseño
title.packages.to.use.import.with=Paquetes que utilizan declaraciones de importación que contienen ''*''
redundant.qualifier.unnecessary.non.direct.parent.class.qualifier=Calificador de superclase indirecto innecesario
fix.add.exception.to.throws=Añadir ''{0}''
fix.add.eq.eq.true=Añadir ''\=\= verdadero''
inspection.replace.isempty.with.ifempty.display.name=Puede reemplazar la condición 'si' con una llamada lambda
inspection.replace.with.ignore.case.equals.display.name=Reemplazar con ''equals(..., ignoreCase \= true)''
inspection.redundant.nullable.return.type.display.name=Tipo de retorno anulable duplicado
0.always.returns.non.null.type=''{0}'' siempre devuelve un tipo no nulo
0.is.always.non.null.type=''{0}'' siempre es de tipo no nulo
inspection.simplifiable.scope.function.display.name=Puede simplificar las funciones de rango con forEach anidado
nested.1.call.in.0.could.be.simplified.to.2=Las llamadas anidadas ''{1}'' en ''{0}'' se pueden simplificar a {2}
evaluate.compile.time.expression=Evaluación de expresiones en tiempo de compilación
hints.title.codevision=Code Vision
hints.title.codevision.show.hints.for=Mostrar sugerencias para\:
hints.title.codevision.usages=Dónde utilizar
hints.title.codevision.inheritors=Implementación/Heredero/Anulación
hints.codevision.usages.format={0, choice,1\#1 referencia|2\#{0,number} referencia}
hints.codevision.usages.too_many.format={0,number} o más usos
hints.codevision.implementations.format={0,choice,1\#1 implementación|2\#{0,number} implementaciones}
hints.codevision.implementations.too_many.format={0,number} o más implementaciones
hints.codevision.inheritors.format={0,choice,1\#1 heredero|2\#{0,number} herederos}
hints.codevision.inheritors.to_many.format={0,number} o más herederos
hints.codevision.overrides.format={0,choice,1\#1 anulación|2\#{0,número} anulación}
hints.codevision.overrides.to_many.format={0,number} o más anulaciones
hints.codevision.settings=Configuración...
convert.string.template.to.build.string=Se convierte en una llamada a 'buildString'
convert.to.indexed.function.call=Convertir a llamada de función indexada
inspection.kotlin.invalid.bundle.or.property.display.name=Clave de propiedad no válida
inspection.type.parameter.find.view.by.id.display.name=Puede utilizar el parámetro de tipo para convertir el tipo a findViewById
inspection.illegal.identifier.display.name=Identificador de Android no válido
inspection.gradle.kotlinx.coroutines.deprecation.display.name=La dependencia incompatible de kotlinx.coroutines en Gradle se utiliza en Kotlin 1.3+
inspection.deprecated.gradle.dependency.display.name=Biblioteca obsoleta utilizada en Gradle
inspection.different.stdlib.gradle.version.display.name=Las versiones de la biblioteca Kotlin y del complemento Gradle son diferentes
inspection.different.kotlin.gradle.version.display.name=Las versiones de los complementos Kotlin Gradle e IDE son diferentes
action.Kotlin.Gradle.ShowDslLogs.text=Mostrar registros DSL de Kotlin Gradle
description.Kotlin.Gradle.ShowDslLogs.description=Mostrar registros DSL de Kotlin Gradle
inspection.incompatible.API.display.name=Uso de API incompatibles
inspection.maven.coroutines.deprecation.display.name=La dependencia de kotlinx.coroutines incompatible de Maven se usa en Kotlin 1.3+
inspection.deprecated.maven.dependency.display.name=Se utilizó una biblioteca obsoleta en Maven
inspection.different.kotlin.maven.version.display.name=Las versiones de los complementos Maven e IDE son diferentes
inspection.different.maven.stdlib.version.display.name=Las versiones del complemento Library y Maven son diferentes
inspection.kotlin.test.j.unit.display.name=Puedes usar kotlin-test-junit
inspection.kotlin.maven.plugin.phase.display.name=El complemento Kotlin Maven está configurado incorrectamente
action.KotlinGenerateMavenPluginAction.text=Complemento de Kotlin
action.KotlinGenerateMavenTestCompileExecutionAction.text=Ejecute la compilación de prueba de Kotlin
action.KotlinGenerateMavenCompileExecutionAction.text=Ejecutando la compilación de Kotlin
dialog.message.incorrect.target.path.directory.not.specified=Ruta de destino no válida. No se especificó ningún directorio.
dialog.message.none.elements.were.selected=No se ha seleccionado ningún elemento
a.field.without.an.initializer.is.not.yet.supported=Los campos sin inicializadores aún no son compatibles
a.constructor.call.is.not.yet.supported=Las llamadas al constructor aún no son compatibles
failed.to.create.a.wrapper.for.inlining.to.kotlin=No se pudo crear un contenedor para alinearlo con Kotlin
inspection.unused.result.of.data.class.copy=Resultado de copiar clases de datos no utilizadas
unclear.precedence.of.binary.expression.inspection.display.name=Múltiples operadores con diferente precedencia
unclear.precedence.of.binary.expression.inspection=Debe utilizar paréntesis para separar claramente las expresiones.
unclear.precedence.of.binary.expression.quickfix=Agregue paréntesis para mayor claridad
unclear.precedence.of.binary.expression.report.even.obvious.cases.checkbox=Informe de caso muy claro.
remove.redundant.empty.class.body=Eliminar cuerpos de clase vacíos innecesarios
inspection.kotlin.constant.conditions.display.name=Condición constante
inspection.message.condition.always.true=La condición siempre es verdadera
inspection.message.condition.always.false=La condición siempre es falsa
replace.function.call.with.the.opposite=Reemplazar una llamada de función con su llamada de función opuesta
replace.0.with.1.and.vice.versa=Intercambiar ''{0}'' y ''{1}''
convert.lambda.to.reference.before.text=Lambda se puede convertir a referencia
convert.reference.to.lambda.before.text=Puedes convertir una referencia a una lambda.
convert.to.primary.constructor.before.text=El constructor secundario debe convertirse en constructor primario.
convert.concatenation.to.template.before.text=Una concatenación de 'cadena' se puede convertir en una plantilla
convert.try.finally.to.use.before.text=Puedes reemplazar try-finally con 'use()'
inspection.message.when.condition.always.true=La rama 'cuándo' siempre está accesible
inspection.message.when.condition.always.false=Nunca se puede acceder a la sucursal 'cuándo'
convert.concatenation.to.build.string=Convertir la conexión a la llamada 'buildString'
floating.point.literal.precision.inspection.display.name=El literal de coma flotante excede la precisión disponible
floating.point.literal.precision.inspection=Los literales de coma flotante no se pueden representar con la precisión requerida
remove.redundant.call.fix.text=Eliminar llamadas duplicadas
inspection.message.cast.will.always.fail=La conversión de tipos siempre falla
inspection.message.value.always.zero=El valor siempre es 0
inspection.message.value.always.null=El valor siempre es nulo
inline.when.argument=Incluir el argumento 'cuándo'
inspection.message.index.out.of.bounds=El índice siempre está fuera de rango
text.sealed.broken.hierarchy.none.in.target=La jerarquía sellada de ''{0}'' está dividida. El paquete ''{1}'' en el módulo ''{2}'' no tiene miembros. {3}
text.sealed.broken.hierarchy.still.in.source=La jerarquía sellada de ''{0}'' está dividida. El paquete ''{1}'' en el módulo ''{2}'' todavía contiene miembros. {3}
interface.member.dependency.required.by.interfaces=Requerido para {0,choice,1#interface|2#interface}
text.0.1.must.be.moved.with.sealed.parent.class.and.all.its.subclasses={0} ''{1}'' debe moverse con su clase principal sellada y todas sus subclases.
text.sealed.class.0.must.be.moved.with.all.its.subclasses=La clase sellada ''{0}'' debe moverse con todas sus subclases.
configuration.title.early.access.preview.1.6.x=Vista previa de acceso anticipado 1.6.x
inspection.message.nonnull.cast.will.always.fail=La operación siempre falla porque el operando siempre es nulo.
inspection.message.for.never.visited=El alcance 'for' siempre está en blanco
inspection.replace.mapIndexed.with.list.generator.display.name=Convirtiendo 'mapIndexed' en un generador de listas
should.be.replaced.with.list.generator=Necesitas cambiarlo a un generador de listas.
replace.with.list.generator.fix.text=Convertir a generador de listas
call.of.inline.function.with.nullable.extension.receiver.can.cause.npe.in.kotlin.1.2=En Kotlin 1.2 y versiones anteriores, llamar a 'diversión en línea' con un receptor que acepta valores NULL puede resultar en 'NPE'
inspection.replace.with.import.alias.display.name=Puede reemplazar un nombre completo con un alias de importación existente
replace.with.import.alias=Reemplazar con alias de importación
group.names.gradle=Gradle
group.names.java.interop.issues=Problemas de interoperabilidad de Java
group.names.kotlin=Kotlin
group.names.logging=Grabación
group.names.naming.conventions=Reglas de creación de nombres
group.names.maven=experto
group.names.migration=Migración
group.names.other.problems=Otros asuntos
group.names.probable.bugs=Errores que puedes encontrar
group.names.redundant.constructs=sintaxis innecesaria
group.names.style.issues=Problemas de estilo
fix.change.return.type.command.primary.constructor=Cambie el tipo de parámetro ''{0}'' del constructor predeterminado de la clase ''{1}'' a ''{2}''
fix.change.return.type.command.function=Cambie el tipo de parámetro ''{0}'' de la función ''{1}'' a ''{2}''
fix.add.type.annotation.family=Agregar anotación de tipo
fix.add.type.annotation.text=Agregue el tipo ''{0}'' al parámetro ''{1}''.
fix.change.signature.lambda.command=Cambiar la firma de una expresión lambda
fix.change.signature.remove.parameter.command=Eliminar parámetro ''{0}''
fix.add.argument.name.step.choose.parameter.title=Seleccione el nombre del parámetro
fix.add.annotation.text.containing.file=Agregue la anotación ''@{0}'' que contenga el archivo ''{1}''
intention.wrap.in.with.context=Salto de línea con 'withContext'
intention.flow.on.dispatchers.io=\ Flujo 'Dispatchers.IO'
intention.switch.context.to.dispatchers.io=Cambiar al contexto 'Dispatchers.IO'
kotlin.compiler.lib=Lib
command.generate.test.support.generate.test.function=Crear función de prueba
parameter.hints.old=Kotlin: muestra sugerencias incrustadas para parámetros
kotlin.references.types.hints=Kotlin: muestra sugerencias incrustadas para tipos
kotlin.references.types.hints.hints.type.property=Kotlin: muestra sugerencias incrustadas para tipos de propiedades
kotlin.references.types.hints.hints.type.variable=Kotlin: muestra sugerencias incrustadas para tipos de variables locales
kotlin.references.types.hints.hints.type.function.return=Kotlin: muestra sugerencias incrustadas para el tipo de retorno de función
kotlin.references.types.hints.hints.type.function.parameter=Kotlin: muestra sugerencias incrustadas para tipos de parámetros de función
kotlin.lambdas.hints=Kotlin: Mostrar sugerencia de incrustación para lambda
kotlin.lambdas.hints.hints.lambda.return=Kotlin: muestra sugerencias incrustadas para expresiones de retorno
kotlin.lambdas.hints.hints.lambda.receivers.parameters=Kotlin: muestra sugerencias incrustadas para receptores y parámetros implícitos
kotlin.call.chains.hints=Kotlin: muestra sugerencias incrustadas para la cadena de llamadas
kotlin.ranges.hints=Kotlin: Mostrar sugerencia de incrustación para el rango
microservices.url.path.inlay.hints=Kotlin: Mostrar sugerencia incrustada para la ruta URL
vcs.code.author=Kotlin: muestra sugerencias incrustadas a los autores de código
hints.settings.ranges=Rango
hints.ranges.description=Sugerencias de incrustaciones de rango
hints.ranges.rangeTo.left=≤
hints.ranges.rangeTo.right=≤
hints.ranges.until.left=≤
hints.ranges.until.right=<
hints.ranges.downTo.left=≥
hints.ranges.downTo.right=≥
copy.text.convert.java.to.kotlin.title=Convertir Java a Kotlin
configuration.title.add.exclusion=Agregar exclusión
error.text.can.t.introduce.constant.for.this.expression.because.not.constant=No se puede insertar una constante para una expresión no constante
error.text.can.t.introduce.constant.for.this.expression=No se puede insertar una constante para esta expresión
introduce.constant=Insertar constante
title.kdoc.for.abstracts=KDoc sobre abstracción
command.move.declarations=Movimiento de declaración
title.select.a.name.for.this.parameter=''this@{0}'' Seleccione el nombre del parámetro
action.move.method=Ir al método...
title.rename.overloads.to=Cambiar nombre de sobrecarga:
title.rename.warning=Advertencia de cambio de nombre
unknown.types.title=Tipo desconocido
choose.actual.members.title=Seleccionar miembros reales
convert.from.class.to.kclass=Convertir 'KClass' en 'Clase'
remove.condition=Eliminar condición
progress.finding.implicit.nothing.s=No encontrar nada implícito
revert.applied.imports.command=Revertir importación aplicada
rename.only.current.0=Cambiar el nombre actual de {0,choice,1#function|2#property}
rename.base.0=Cambiar el nombre predeterminado {0,choice,1#función|2#propiedad|3#miembro|4#método|11#función|12#propiedad|13#miembro|14#método}
rename.declaration.title.0.implements.1.2.of.3={0} {1,choice,1#implementación|2#override} {2} de {3}
searching.for.imports.to.delete.title=Buscar importaciones para eliminar
this.range.is.empty.did.you.mean.to.use.0=Este rango está vacío. ¿Quieres utilizar ''{0}''?
title.lateinit.var.overrides.lateinit.var=lateinit var' anula el padre 'lateinit var
title.choose.use.site.target=Seleccione un sitio para usar
add.names.in.comment.to.call.arguments=Llame a argumentos agregando sus nombres en los comentarios.
move.to.companion.object.command=Ir al objeto complementario
title.toggle.composite.analysis.mode.for.multiplatform=Cambie modos de análisis complejos para multiplataformas
internal.toggle.throwing.cached.pce.title=Interno: Conversión de lanzamiento de PCE en caché
title.toggle.library.to.source.dependency.support=Cambiar bibliotecas al soporte de dependencia de origen
inspection.inconsistent.comment.for.java.parameter.display.name=Anotaciones inconsistentes para parámetros Java
action.usage.update.command=Actualizar dónde usar
title.logger.factory.method.name=Nombre del método de fábrica del registrador
title.logger.factory.class.name=Nombre de clase de fábrica del registrador
title.choose.logger.factory.class=Seleccione la clase de fábrica del registrador
replace.function.call.with.if=Reemplazo de llamadas a funciones con 'si'
lift.function.call.out.of.if=Eliminar llamada de función de 'si'
inspection.message.value.always.true=El valor siempre es cierto
inspection.message.value.always.false=El valor siempre es falso
inspection.message.condition.always.true.when.reached=Siempre es cierto cuando se cumple la condición
inspection.message.condition.always.false.when.reached=Cuando se alcanza la condición siempre es falsa.
inspection.convert.argument.to.set.display.name=Los argumentos se pueden convertir a 'Establecer' para un mejor rendimiento.
can.convert.argument.to.set=Los argumentos se pueden convertir a 'Establecer' para un mejor rendimiento.
convert.argument.to.set.fix.text=Convertir argumento a 'Establecer'
convert.to.unicode.escape=Convertir a escape Nicode
popup.title.expressions=Expresión
popup.title.types=Tipo
popup.title.elements=Elemento
action.hints.settings.text=Configuración de sugerencias...
start.import.button.text.add=Suma
start.import.button.text.remove=Eliminar
import.order.button.text.add.package=Agregar paquete
import.order.button.text.remove=Eliminar
import.order.button.text.up=Consuelo
import.order.button.text.down=Bajo
import.text.all.other.imports=Todas las demás declaraciones de importación
import.text.import=Importar
import.text.all.alias.imports=Obtener todos los alias
extract.new.parameter.name.receiver=<Receptor>
facets.editor.general.tab.label.depends.on.0=Base: {0}.
kotlin.compiler.configurable=Compilador kotlin
kotlin.language.configurable=Kotlin
kotlin.scripting.configurable=Secuencia de comandos Kotlin
intention.add.function.return.type.specify.type.explicitly=Especifique el tipo explícitamente.
hint.text.no.expression.found=Expresión no encontrada
dialog.title.getting.expression.type=Obteniendo tipo de expresión
progress.title.calculating.type=Tipo de cálculo...
intention.name.correct.parameter.name=Modificar el nombre del parámetro
inspection.message.inconsistent.parameter.name.for.0=Nombre de parámetro inconsistente para ''{0}''
inspection.kotlin.catch.may.ignore.exception.display.name=Los bloques 'catch' pueden ignorar excepciones
inspection.message.empty.catch.block=Bloque de captura vacío
inlay.kotlin.references.types.hints.hints.type.property=Por ejemplo, una declaración de propiedad cuyo tipo no aparece claramente en el lado derecho de la asignación cuando se obtiene de una secuencia o método de fábrica.
inlay.kotlin.references.types.hints.hints.type.variable=Por ejemplo, una declaración de variable local cuyo tipo no aparece claramente en el lado derecho de la asignación cuando se obtiene en una llamada a un método.
inlay.kotlin.references.types.hints.hints.type.function.return=Una función con un tipo de retorno inferido.
inlay.kotlin.references.types.hints.hints.type.function.parameter=Parámetro lambda cuyo tipo no se especifica explícitamente.
