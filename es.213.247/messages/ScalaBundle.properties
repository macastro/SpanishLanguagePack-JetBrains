title.problem.opening.web.page=Problemas al abrir páginas web
html.unable.to.launch.web.browser=<html><body>El navegador web no se puede iniciar, así que ábralo manualmente\:<br />{0} (<a href\="{0}">Copiar al portapapeles</a>)</body > </html>
edit.package.prefix=Editar prefijo de paquete...
make.implicit.conversion.explicit.action.text=Hacer explícitas las conversiones implícitas
make.implicit.conversion.explicit.action.description=Hacer explícitas las conversiones implícitas
title.choose.implicit.conversion.method=Seleccione el método de conversión implícita\:
press.alt.enter=Presione Alt+Entrar
make.explicit=Establecer explícitamente
make.explicit.and.import.method=Establecer explícitamente (método de importación)
new.packageobject.menu.action.text=Objeto de paquete
new.packageobject.menu.action.description=Crear un nuevo objeto de paquete Scala
newclass.menu.action.text=Clases de escala
newclass.menu.action.description=Crear una nueva clase de Scala
create.new.scala.class=Crear una nueva clase de Scala
this.is.not.a.valid.scala.qualified.name=No es un nombre válido y completo de Scala
no.expression.found=Expresión no encontrada
type.hint.table.title.type=Categoría
type.hint.table.title.dealiased=Alias eliminado
type.hint.table.title.widened=Expandido
type.hint.table.title.expected=Necesario
type.hint.table.title.without.implicits=Sin términos implícitos
unknown.type=<desconocido>
type.info.text=Clasificar información
type.info.description=Mostrar información de tipo
could.not.find.type.for.selection=Tipo de selección no encontrada
hint.label.non.singleton=Sin singleton
hint.label.simplified=Simplificado
hint.label.original=Original
hint.label.expected=Necesario
toggle.type.aware.highlighting.menu.action.text=Resaltar alterna usando información de tipo
toggle.type.aware.highlighting.menu.action.description=Alternar resaltado con reconocimiento de tipografía
implicit.argument.is.applicable=Se pueden aplicar argumentos implícitos.
implicit.is.diverged=Implícito se ha ramificado
can.t.infer.proper.types.for.type.parameters=No se puede inferir el tipo apropiado para el parámetro de tipo
can.t.find.implicit.argument.for.this.definition=No se encontró ningún argumento implícito para esta definición.
no.implicits.applicable.by.type=No hay elementos implícitos aplicables para cada tipo.
reason.prefix.applicable=Aplicable\:
reason.prefix.diverged=Ramificado\:
reason.prefix.cannot.infer.type=No se pudo inferir el tipo\:
reason.prefix.candidate=Candidato\:
problem.prefix.ambiguous=(ambiguo)
problem.prefix.not.found=(extraviado)
location.description.parameter.of.name=Parámetros de {0}
location.description.parameter.of.getclassnametext=Parámetros de {0}
location.description.anonymous.class=Clase anónima
location.description.containing.block=Bloque incluido
location.description.body.of.name=Cuerpo de {0}
show.implicit.arguments.action.text=Mostrar argumentos implícitos
show.implicit.arguments.action.description=Mostrar argumentos implícitos
no.implicit.arguments=Sin argumentos implícitos
title.expressions=Expresión
navigate=Para navegar
implicit.arguments.for.implicit.conversion=Argumentos implícitos para la conversión implícita\:
implicit.arguments=Argumentos implícitos\:
implicit.conversions.action.text=Mostrar conversión implícita
implicit.conversions.action.description=Indicación de conversión implícita
scala.collect.troubleshooting.information.short.action.text=(Scala) Reúna información breve sobre la resolución de problemas.
scala.collect.troubleshooting.information.short.action.description=Recopile complementos de Scala y versiones de IntelliJ IDEA y péguelos rápidamente en YouTrack
short.troubleshooting.summary.copied.to.your.clipboard.with.summary=Breve resumen de solución de problemas copiado al portapapeles\nEl tipo no coincide, encontrado\: {0}, requerido\: {1}
type.mismatch.expected.actual=Los tipos no coinciden, esperado\: {0}, real\: {1}
abstract.member.not.have.private.modifier=Los miembros abstractos no pueden tener modificadores privados
illegal.inheritance.from.sealed.kind=Herencia no válida de {0} ''{1}'' sellado
passed.as.by.name.parameter=Pasado como parámetro de nombre
function.must.define.type.explicitly=El método {0} tiene una declaración de devolución, por lo que se requiere un tipo de resultado
function.recursive.need.result.type=El método recursivo {0} requiere un tipo de resultado
family.name.remove.tailrec.annotation=Eliminar la anotación @tailrec
method.annotated.with.tailrec.is.neither.private.nor.final=Los métodos anotados con @tailrec no son privados ni finales (pueden anularse)
method.annotated.with.tailrec.contains.no.recursive.calls=El método anotado @tailrec no contiene una llamada recursiva
recursive.call.not.in.tail.position=La llamada recursiva no está en la posición final (dentro de un método anotado @tailrec)
member.needs.override.modifier={0} ''{1}'' requiere anular el controlador
member.overrides.nothing={0} ''{1}'' no anula nada
can.not.override.final={0} ''{1}'' no puede anular el miembro final
member.cannot.override.var=El método {0} no puede anular la variable mutable
member.cannot.override.val=El método {0} requiere un valor inmutable estable
var.cannot.override.val=La variable {0} no puede redefinir su valor inmutable
override.types.not.conforming=El tipo de anulación {0} no se ajusta al tipo base {1}
regular.method.overrides.extension=El método {0} es un método normal y no se puede anular como método de extensión.
extension.method.overrides.regular=El método {0} es un método de extensión y no se puede anular como método normal.
covariant.type.contravariant.position.of.method=El tipo covariante {0} aparece en la posición contravariante en el tipo {1} del método {2}
covariant.type.contravariant.position.of.value=El tipo covariante {0} aparece en la posición contravariante en el tipo {1} del valor {2}
covariant.type.invariant.position.of.method=El tipo covariante {0} aparece en la posición no covariante en el tipo {1} del método {2}
covariant.type.invariant.position.of.value=El tipo covariante {0} aparece en la posición no covariante en el tipo {1} del valor {2}
contravariant.type.covariant.position.of.method=El tipo covariante {0} aparece en la posición covariante en el tipo {1} del método {2}
contravariant.type.covariant.position.of.value=El tipo covariante {0} aparece en la posición covariante en el tipo {1} del valor {2}
contravariant.type.invariant.position.of.method=El tipo covariante {0} aparece en la posición no covariante en el tipo {1} del método {2}
contravariant.type.invariant.position.of.value=El tipo covariante {0} aparece en la posición no covariante en el tipo {1} del valor {2}
id.is.already.defined={0} ya está definido en el alcance
type.mismatch.message=El tipo no coincide. Requerido\: {0}, Encontrado\: {1}
type.mismatch.hints.action.text=Sugerencia de no coincidencia de tipos
type.mismatch.hints.action.description=Alternar sugerencia de discrepancia de tipo
family.name.create.apply.method=Crear método ''aplicar''
create.apply.method.in={0} Crear mi método ''aplicar''
error.message.title.create.entity.quickfix=Crear solución rápida de entidad
family.name.create.extractor.object=Crear objeto extractor
create.extractor.object.named=Crear objeto extractor ''{0}''
family.name.create.parameterless.method=Crear método sin parámetros
create.parameterless.method.named=Crear método sin parámetros ''{0}''
family.name.create.variable=Crear variable
create.variable.named=Crear variable ''{0}''
family.name.create.value=Crear valor
create.value.named=Crear valor ''{0}''
family.name.create.method=Crear método
create.method.named=Crear método ''{0}''.
family.name.create.object=Crear objeto
family.name.create.trait=Crear características
family.name.create.class=Crear clase
family.name.create.case.class=Crear clase de caso
create.object.named=Crear objeto ''{0}''
create.trait.named=Crear propiedad ''{0}''
create.class.named=Crear clase ''{0}''
create.case.class.named=Crear clase de caso ''{0}''
choose.level.popup.title=Selecciona el nivel
new.class.location.new.file=Archivo nuevo
new.class.location.top.level.in.this.file=Nivel superior de este archivo
new.class.location.inner.in.class=Dentro de {0}
new.class.location.local.scope=Alcance local
family.name.create.unapply.method=Crear método ''desaplicar''
create.unapply.method.in={0} Crear mi método ''desaplicar''
scala.meta.recompile=El metaprograma no está actualizado. Haga clic aquí para compilar
scala.meta.expandfailed=La expansión de la macro falló\: {0}
annotator.error.wrong.right.assignment.side=Asignación de derechos no válida
annotator.error.reassignment.to.val=Asignar nuevamente a val
illegal.assignment.target=Objetivo de sustitución no válido
expr.type.does.not.conform.expected.type=La expresión de tipo {0} no se ajusta al tipo esperado {1}
method.is.not.member=El método {0} no es miembro del tipo {1}
expected.type.boolean=El método {0} espera un tipo booleano como tipo de retorno
missing.char.value=Valor de carácter faltante
illegal.secondary.constructors.value.class=Los constructores secundarios no están permitidos en clases de valor.
value.class.can.have.only.one.parameter=Una clase de valor puede tener solo un parámetro
value.class.can.have.only.val.parameter=Una clase de valor solo puede tener un parámetro val no privado
type.parameter.value.class.may.not.be.specialized=Los parámetros de tipo de clases de valor no se pueden especializar
value.classes.cannot.have.nested.objects=Una clase de valor no puede tener clases, objetos o propiedades anidadas.
value.classes.cannot.redefine.equals.hashcode=Las clases de valor no pueden anular iguales y hashCode
value.classes.can.have.only.defs=No se permiten definiciones de campos en clases de valor
value.classes.may.not.be.member.of.another.class=Una clase de valor no puede ser miembro de otra clase.
constructor.invocation.expected=''esta'' expectativa
type.mismatch.default.args.expected.actual=Los tipos no coinciden en los argumentos predeterminados, esperado\: {0}, real\: {1}
annotator.error.class.type.required.but.found=Tipo de clase esperado pero ({0}) encontrado
annotator.error.constructor.has.malformed.definition=El tipo de definición del constructor no es válido
annotator.error.no.constructor.accessible=No hay constructores accesibles aquí.
annotator.error.cannot.resolve.overloaded.constructor=No se puede resolver el constructor sobrecargado `{0}`
annotator.error.unspecified.value.parameters=Parámetro de valor no especificado \: {0}
annotator.error.trait.has.no.constructor=La propiedad {0} es una propiedad y, por lo tanto, no acepta argumentos de constructor.
annotator.error.too.many.arguments.for.constructor=El constructor {0} tiene demasiados argumentos.
annotator.error.missing.argument.list.for.constructor=Falta lista de argumentos para el constructor {0}
annotator.error.expansion.for.non.repeated.parameter=Expansión de parámetros no repetitivos
annotator.error.positional.after.named.argument=Argumentos posicionales después de argumentos con nombre
annotator.error.parameter.specified.multiple.times=Parámetro especificado varias veces
annotator.error.cannot.apply.constructor=Constructor {0} no aplicable
annotator.error.enum.nonvariant.type.param,in.enum=No se puede determinar el argumento de tipo del padre {0} de la clase de enumeración. El parámetro de tipo {1} es invariante
annotator.error.enum.case.must.extend.parent=Un caso de enumeración debe extender la clase de enumeración correspondiente {0}
annotator.error.enum.two.type.parameter.clauses=Tanto los casos de enumeración como las clases de enumeración contienen parámetros de tipo y, por lo tanto, requieren una cláusula de extensión explícita.
semicolon.not.allowed.here=No se permiten punto y coma
remove.all.erroneous.semicolons.from.forexpression=Eliminar todos los puntos y comas no válidos en las expresiones
else.expected=Se requiere 'más'
for.pattern.bindings.require.scala3=La sintaxis ''case'' dentro del enlace del patrón ''for'' requiere Scala 3.0
enumerators.generator.val.keyword.found=Patrón esperado, pero se encontró ''val''
enumerators.binding.val.keyword.deprecated=La palabra clave ''val'' en los enumeradores está obsoleta
enumerators.binding.case.keyword.found=Patrón esperado pero "caso" encontrado
remove.case=Quitar ''caso''
family.name.remove.case.from.enumerator=Eliminar ''caso'' del enumerador
annotator.error.too.many.parameters=Demasiados parámetros
annotator.error.missing.parameter.type=Tipo de parámetro faltante
type.mismatch.expected=Los tipos no coinciden, esperado\: {0}, real\: {1}
repeated.param.non.method=No se permiten parámetros repetidos en las firmas de métodos. Utilice `Seq` en su lugar
import.expr.should.be.qualified=Las expresiones de importación deben estar normalizadas.
cannot.resolve.in.StringContext=El valor ''{0}'' no es miembro de StringContext
wrong.type.no.literal.types=Tipo no válido `{0}`; utilice Scala 2.13 o Typelevel Scala con el indicador del compilador `-Yliteral-types` para compatibilidad con tipos lineales
identifier.expected.but.0.found=Se requiere un identificador pero se encontró {0}.
macro.defs.must.have.explicit.return.type=Las definiciones de macro deben contener un tipo de retorno especificado explícitamente
annotator.error.unspecified.value.parameters.mkstring=Parámetro de valor no especificado \: {0}
annotator.error.cannot.resolve.overloaded.method=No se puede resolver el método sobrecargado
annotator.error.too.many.arguments=Demasiados argumentos
annotator.error.target.does.not.take.parameters={0} no toma parámetros
missing.argument.list.for.method.with.explicit.list=Al método {1} le falta la lista de argumentos {0}
missing.argument.list.for.method=Falta lista de argumentos para el método {0}
does.not.take.parameter.default.target=Solicitud
annotator.error.too.many.arguments.method=El método {0} tiene demasiados argumentos
annotator.error.name.has.malformed.definition=''{0}'' tiene una definición incorrecta
illegal.instantiation={0} ''{1}'' es abstracto y no se puede crear una instancia
octal.literals.removed=La sintaxis literal octal ha sido deshabilitada desde Scala 2.11
trailing.underscore.separator=No se permiten delimitadores de subrayado al final
illegal.underscore.separator=Necesitas Scala 2.13 para usar el delimitador de guión bajo
long.literal.is.out.of.range=El número entero está incluso fuera del rango para el tipo largo
integer.literal.is.out.of.range=El literal entero está fuera del rango para el tipo int
lowercase.long.marker=Marcador literal largo escrito en minúsculas
annotator.error.parameter.without.an.owner.name=Parámetro sin propietario\: {0}
annotator.error.missing.type.annotation.for.parameter=Falta anotación de tipo en el parámetro\: {0}
missing.parameter.type.name=Tipo de parámetro faltante\: {0}
topic.parameters.may.not.be.call.by.name=El parámetro {0} puede no ser llamada por nombre
unspecified.type.parameters=Parámetro de valor no especificado: {0}
too.many.type.arguments.for.typeparamowner=Hay demasiados argumentos de tipo para {0}. {1} necesario, {2} encontrado
type.arg.does.not.conform.to.upper.bound=El tipo {0} no respeta el límite superior {1} del parámetro de tipo {2}
type.arg.does.not.conform.to.lower.bound=El tipo {0} no respeta el límite inferior {1} del parámetro de tipo {2}
name.does.not.take.type.arguments={0} no acepta argumentos de tipo
expected.type.constructor=Se requiere el constructor de tipo {0}
type.constructor.does.not.conform=El constructor de tipo {0} no se ajusta a {1}
type.constructor.mismatch=El constructor de tipos no coincide.
annotator.error.repeated.parameter.must.be.last=*-el parámetro debe ser el último
annotator.error.repeated.or.default=*-la sección de parámetros parametrizados no puede contener argumentos predeterminados
pattern.on.refinement.unchecked=La coincidencia de patrones del tipo de mejora no está marcada
type.cannot.be.used.in.type.pattern=El tipo {0} no se puede utilizar en un patrón de tipo ni en una prueba isInstanceOf
scrutinee.incompatible.pattern.type=El escrutador no es compatible con el tipo de patrón, encontrado\: {0}, requerido\: {1}
pattern.type.incompatible.with.expected=El tipo de patrón no es compatible con el tipo esperado, encontrado\: {0}, requerido\: {1}
constructor.cannot.be.instantiated.to.expected.type=No se puede inicializar el constructor con el tipo esperado, encontrado\: {0}, requerido\: {1}
fruitless.type.test=Prueba de tipo sin resultado\: Los valores de tipo {0} no pueden ser simultáneamente {1}
erasure.warning=(todavía puede coincidir con ese borrador)
wrong.number.arguments.extractor=Número de argumentos no válidos en el extractor, encontrado\: {0}, esperado\: {1}
wrong.number.arguments.extractor.unapplySeq=Número de argumentos no válidos en el extractor, encontrados\: {0}, esperados\: {1} o más.
stable.identifier.required=Se esperaba un identificador estable, pero se encontró {0}
better.monadic.for.invalid.pattern=Los argumentos deben tener anotaciones tipográficas explícitas.
vararg.pattern.must.be.last.pattern=_* sólo se puede utilizar como último argumento
vararg.pattern.with.colon.requires.scala3=La sintaxis ''\:'' dentro de los patrones vararg requiere Scala 3.0
vararg.pattern.with.at.deprecated.since.scala3=La sintaxis ''@'' dentro del patrón vararg está obsoleta en Scala 3.0 y versiones posteriores.
vararg.short.pattern.with.at.deprecated.since.scala3=La sintaxis corta del patrón _* está obsoleta en Scala 3.0 y versiones posteriores.
family.name.replace.type.with.type.in.vararg.pattern=Reemplace ''{0}'' con ''{1}'' en el patrón vararg
family.name.replace.with.scala3.vararg.pattern=Reemplazo de la sintaxis ':' con el patrón vararg de Scala 3.0
replace.with.type=Reemplazar con ''{0}''
replace.with.scala3.wildcard.varargs=Reemplazar con ''_\: _*''
family.name.replace.old.varags.with.scala3.varargs.pattern=Cambie ''_*'' a ''_\: _*'' en el patrón vararg
poly.function.without.parameters=La función polimórfica {0} debe tener un parámetro de valor
cannot.resolve=El símbolo {0} no se puede resolver.
cannot.resolve.overloaded=El método sobrecargado ''{0}'' no se puede resolver
forward.reference.detected=Referencia directa incorrecta
cannot.resolve.apply.method=No se pudo resolver el método {0}.apply
cannot.resolve.unapply.method=No se puede resolver el método {0}.unaapply
annotator.error.missing.arguments.for.method=Falta argumento para el método {0}
symbol.is.inaccessible.from.this.place=No se puede acceder al símbolo {0} desde esta ubicación
return.expression.is.redundant=Devolviendo {0} del método con tipo de resultado Unidad
return.outside.method.definition=Declaración de retorno fuera de la definición del método
called.constructor.definition.must.precede=La definición del constructor llamado debe preceder a la llamada a la definición del constructor.
annotator.error.cannot.find.constructor.for.this.call=No se encontró ningún constructor para esta llamada.
type.takes.type.parameters=El tipo {0} toma un parámetro de tipo
string.literal.is.too.long=El tamaño literal de la cadena excede el límite del compilador
string.literal.invalid.escape.character=Carácter de escape no válido
string.literal.invalid.unicode.escape=Escape Unicode incorrecto
symbolliterals.are.deprecated=Los literales de símbolos están en desuso en Scala 2.13. Utilice Símbolo("{0}") en su lugar.
illegal.inheritance.self.type=Herencia no válida, el tipo propio {0} no se ajusta a {1}
mixin.required=''{3}'' Mi miembro ''{2}'' está marcado como ''abstracto'' y ''override'' pero no se puede encontrar ninguna implementación concreta en la clase base, por lo que {0} ''{ 1 }'' debe ser una mezcla
illegal.undefined.member=Los miembros declarados pero no definidos solo pueden tener clases
illegal.inheritance.from.final.kind=Herencia no válida del {0} ''{1}'' final
illegal.inheritance.from.value.class=Herencia no válida de la clase de valor ''{0}''
illegal.inheritance.extends.enum=Se prohíben las ampliaciones de enumeración.
illegal.inheritance.multiple={0} ''{1}'' heredado varias veces
illegal.mixin={0} ''{1}'' debe ser una propiedad combinable
member.implementation.required={0} ''{1}'' debe declararse abstracto o implementar el miembro abstracto ''{2}'' en ''{3}''
object.creation.impossible.since={0}, por lo tanto no se puede crear el objeto
member.is.not.defined=El miembro {0} de {1} no está definido
trait.parameter.require.scala3=El uso de parámetros de rasgos requiere Scala 3.0
lower.bound.conform.to.upper=El límite inferior no respeta el límite superior.
cannot.upcast.type.to.other.type=No se puede transmitir {0} a {1}
unbound.placeholder.parameter=Parámetros de marcador de posición independientes
local.variables.must.be.initialized=Las variables locales deben inicializarse.
default.init.prohibited.literal.types=Inicialización predeterminada prohibida en var de tipo literal
annotation.ascriptions.in.pattern.definitions.require.scala3=La atribución de anotaciones dentro de las definiciones de patrones requiere Scala 3.0
method.is.recursive=El método ''{0}'' es un método recursivo
method.is.tail.recursive=El método ''{0}'' es un método recursivo de cola
goto.super.member.chooser.title=Seleccionar miembro padre
goto.super.class.chooser.title=Seleccionar clase principal
goto.super.class.or.member.chooser.title=Seleccionar clase principal/miembro principal
companion.class=Clase
companion.object=Objeto
companion.trait=Característica
companion.enum=Enumeración
go.to.companion=Ir al compañero {0}
go.to.implementation=Ir a Implementación
go.to.super.method=Ir al miembro padre
gutter.companion=Compañero
gutter.implemented=Miembros implementados
gutter.implementing=Implementación de miembros en progreso
gutter.overridden=Miembro redefinido
gutter.overriding=Redefiniendo miembro
gutter.recursion=Tipo recursivo
gutter.sam=Implementación SAM
has.companion=Incluye acompañante {0}
multiple.overriding.tooltip=Múltiples miembros primordiales
multiple.overriden.tooltip=Varios miembros anulados
scala.line.markers=Marcador de línea escala
implements.member.prefix=Implementación de miembros
implements.member.from.prefix=Implementación de miembros en
implements.member.from.several.classes=Miembro de implementación en la clase {0}
overrides.member.from.prefix=Anular miembro en
overrides.member.from.several.classes=Anulando miembros en la clase {0}
overrides.type.prefix=Anulación de tipo
overrides.type.from.super.several.classes=Tipo de anulación para la clase {0}
navigation.title.super.members=Seleccione miembro padre de {0}
navigation.findUsages.title.super.members=Miembro padre de {0}
navigation.title.super.types=Seleccione el tipo de padre miembro de {0}
navigation.findUsages.title.super.types=Miembro supertipo de {0}
trait.has.implementations=Siguiente mezcla
trait.has.several.implementations=Mezclado en la clase {0}
class.has.subclasses=Criterios ampliados
class.has.several.subclasses={0} se extiende por subclase
has.implementations=Miembro contiene implementación
is.overridden.by=Miembro contiene anulación
navigation.title.inheritors.trait=<html><b>{0}</b> Seleccionar implementación ({1} clase encontrada)</html>
navigation.findUsages.title.inheritors.trait=Implementación de {0}
navigation.title.inheritors.class=<html><b>{0}</b> Seleccionar subclase ({1} clase encontrada)</html>
navigation.findUsages.title.inheritors.class=Subclase de {0}
navigation.title.implementing.member=<html>Seleccione el miembro de implementación de <b>{0}</b> (miembro {1} encontrado)</html>
navigation.findUsages.title.implementing.member=Miembro de implementación de {0}
navigation.title.overriding.member=<html>Seleccione anular miembro de <b>{0}</b> (miembro {1} encontrado)</html>
navigation.findUsages.title.overriding.member=Miembro primordial de {0}
type.mismatch.dot=El tipo no coincide.
lazy.modifier.is.not.allowed.here=El modificador ''lazy'' solo se permite para definiciones de valores
lazy.modifier.is.not.allowed.with.param=El modificador ''lazy'' no está permitido; utilice en su lugar el parámetro llamada por nombre
lazy.values.may.not.be.abstract=El valor perezoso no puede ser abstracto.
final.modifier.not.with.declarations=El modificador ''final'' no se puede utilizar con miembros incompletos
final.modifier.not.with.trait=Modificador ''final'' no permitido en el atributo
final.modifier.is.redundant.with.final.parents=El controlador ''final'' es redundante con un objeto o miembro de clase final
final.modifier.is.not.allowed.here=El controlador ''final'' no está permitido
access.modifier.is.not.allowed.here=El controlador ''{0}'' no está permitido
abstract.modifier.redundant.fot.traits=El modificador ''abstracto'' es redundante con el atributo.
abstract.modifier.is.not.allowed=El modificador ''abstracto'' sólo se permite en clases o definiciones que tienen un modificador ''anular''
abstract.override.modifier.is.not.allowed=El modificador ''anulación abstracta'' solo se permite en miembros de atributos
override.modifier.is.not.allowed.for.classes=El modificador ''override'' solo se permite en miembros de definición de tipo
override.modifier.is.not.allowed=El modificador ''override'' no está permitido
sealed.modifier.is.not.allowed.here=El controlador ''sellado'' no está permitido
illegal.modifiers.combination=Combinación de controlador no válida\: {0} y {1}
implicit.modifier.cannot.be.used.for.top.level.objects=El modificador ''implícito'' no se puede utilizar en objetos de nivel superior
implicit.class.must.have.a.primary.constructor.with.one.argument=Las clases implícitas deben tener un constructor predeterminado con exactamente un argumento en la primera lista de parámetros.
implicit.modifier.can.be.used.only.for=Los modificadores ''implícitos'' solo se pueden usar en valores, variables, métodos y clases.
tree.mismatch.tooltip=<html><body>{0}<table><tr><td>Obligatorio:</td>{0}</tr><tr><td>Encontrado:</td>{1}</tr> </tabla></body></html>
add.collection.breakout.argument=Agregue el argumento `collection.breakOut`
family.name.add.collection.breakout=Agregue `colección.breakOut`
add.element=Añadir {0}
add.return.type=Agregar tipo de devolución
family.name.change.type=Tipo de cambio
change.type.to=Cambiar tipo ''{0}'' a ''{1}''
convert.to.explicit.symbol=Convertir a símbolo ("{0}")
convert.to.explicit.symbol.family=Convertir a símbolo explícito
family.name.enable.type.mismatch.hints=Habilitar sugerencia de discrepancia de tipos
implement.methods.fix=Implementación del método
make.non.private.title=Hacer que una propiedad no sea privada
add.modifier.fix.without.name=Agregar controlador ''{0}''
remove.named.modifier.fix=Eliminar el controlador ''{0}''
make.protected.fix=Hacer una propiedad protegida
make.public.fix=Hacer pública una propiedad
numeric.literal.family=Literal numérico
convert.to.hex.fix=Convertir literal octal a hexadecimal
convert.to.long.fix=Convertir a literal largo
lowercase.long.marker.fix=Convertir marcador literal largo a mayúsculas
pull.method.to=A continuación, extraiga el método ''{0}''...
pull.value.to=Arrastre el valor ''{0}'' a...
pull.variable.to=A continuación, arrastre la variable ''{0}''...
report.highlighting.error.fix=Resaltar informe de errores...
wrap.in.option.name=Salto de línea de opción
wrap.in.option.hint=Opción(...) ¿Le gustaría ajustar mi expresión?
family.name.add.empty.parentheses=Agregar paréntesis vacíos
family.name.convert.to.object=Convertir a objeto
case.classes.without.parameter.list.not.allowed=No se permiten clases de casos sin lista de parámetros
case.classes.without.parameter.list.deprecated=Las clases de casos sin listas de parámetros están en desuso
no.implicit.arguments.of.type=No hay argumentos de tipo implícitos. {0}
annotator.error.bean.property.should.not.be.private=Las propiedades de Bean no deben ser privadas.
traits.cannot.have.type.parameters.with.context.bounds=Las propiedades no pueden tener parámetros de tipo con límites de contexto
traits.cannot.have.type.parameters.with.view.bounds=Las propiedades no pueden tener parámetros de tipo con límites de vista
import.with=Importar ''{0}''
import.implicit.conversion=Importar conversión...
import.implicit=Obtener elementos implícitos...
import.class.chooser.title=Clase para importar
import.package.chooser.title=Paquete para importar
import.something.chooser.title=Que traer
import.conversion.chooser.title=Conversión para importar
import.implicit.chooser.title=Elemento implícito para obtener
add.import.action=Agregar acción de importación
exclude.value.from.auto.import=Excluyendo ''{0}'' de la importación automática.
import.hint.text={0}? Alt+Enter {1}
import.multiple.choices=(selección múltiple...)
import.global.member=Consigue miembros globales
import.as=Importar como ''{0}''
import.with.prefix.ellipsis=Importar con prefijo...
import.with.prefix=Importar con prefijo
import.something=Importar...
import.class=Clase de importación
import.package=Paquete de importación
report.build.toolwindow.cancel=Cancelar compilación
report.build.toolwindow.running=Correr...
report.build.toolwindow.failed=Fallido
report.build.toolwindow.canceled=Cancelado
report.build.toolwindow.items=Artículo
report.build.task.canceled=El trabajo ha sido cancelado
report.build.running=Ejecutando compilación...
report.build.completed=Construcción completada
report.build.failed=Compilación fallida
report.failed.with.message=Fallido\: {0}
report.canceled=Cancelado
report.warning.with.message=Advertencia\: {0}
report.error.with.message=Error\: {0}
report.building=Edificio...
family.name.add.braces=Agregar llaves
add.braces.around.single.line.expression=Agregue llaves alrededor de expresiones de una sola línea
create.companion.object.for.class=Crea un objeto complementario para tu clase.
family.name.create.companion.object=Crear objeto complementario
family.name.remove.braces=Retire los tirantes.
family.name.comparing.length=Comparando longitud
family.name.filter.set.contains=El conjunto contiene filtrado
family.name.some.to.option=Algunos a la opción
family.name.convert.to.curly.braces=Convertir a llaves
intention.for.comprehension.convert.to.parentheses=Convertir a paréntesis
desugar.for.comprehension=Para desazucar anidado
family.name.convert.to.desugared.expression=Convertir a expresión desazucarada
family.name.convert.from.infix.expression=Conversión de expresión infija
family.name.convert.parameter.to.underscore.section=Convertir parámetros a secciones subrayadas
family.name.convert.to.infix.expression=Convertir a expresión infija
family.name.convert.underscore.section.to.parameter=Convertir secciones subrayadas en parámetros
family.name.make.implicit.conversion.explicit=Hacer explícitas las conversiones implícitas
family.name.remove.unnecessary.apply=Eliminar aplicaciones innecesarias
remove.unnecessary.parentheses=Elimine los paréntesis innecesarios.
family.name.replace.type.check.with.pattern.matching=Reemplazo de verificación de tipo con coincidencia de patrones
family.name.import.additional.identifiers=Obtener identificadores adicionales
import.additional.identifiers.from.qualifier=Obtenga identificadores adicionales de los calificados
family.name.import.all.members=Obtener todos los miembros
import.all.members.of.reference=Reúne a todos los miembros de {0}
family.name.import.member.with.stable.path=Importar miembros por ruta estable
import.stable.member={0} importar
convert.to.typed.pattern=Convertir a patrón escrito
family.name.expand.to.constructor.pattern=Extendiendo al patrón constructor
expand.to.new.pattern=Extensión\: {0}
intention.add.explicit.unit.type.annotation=Agregar anotación de tipo de unidad implícita
intention.type.annotation.function.add.text=Agregar anotación de tipo a la definición de función
family.name.adjust.types=Ajuste de tipo
family.name.use.prefix.type.syntax=Usar sintaxis de tipo de prefijo
family.name.convert.implicit.bounds=Conversión ligada implícita
convert.view.and.context.bounds.to.implicit.parameters=Conversión de límites de vista y contexto en parámetros implícitos
convert.java.to.scala.collection.hint=¿Convertir a la colección Scala usando asScala?
convert.java.to.scala.collection.name=Convertir a la colección Scala
convert.scala.to.java.collection.hint=¿Convertir a una colección Java usando asJava?
convert.scala.to.java.collection.name=Convertir a colección Java
family.name.use.infix.type.syntax=Usando sintaxis de tipo Infijo
make.type.more.specific.fun=Hacer que el tipo de devolución sea más específico
make.type.more.specific=Hacer que los tipos declarados sean más específicos
intention.type.annotation.regen.family=Regenerar anotaciones de tipo
intention.type.annotation.function.regenerate.text=Regenerar anotaciones de tipo para definiciones de funciones
intention.type.annotation.value.regenerate.text=Regenerar anotaciones de tipo para definiciones de valores
intention.type.annotation.variable.regenerate.text=Regenerar anotaciones de tipo para definiciones de variables
intention.type.annotation.toggle.family=Anotación de tipo de interruptor
intention.type.annotation.function.remove.text=Eliminar anotación de tipo de la definición de función
intention.type.annotation.value.add.text=Agregar anotación de tipo a la definición de valor
intention.type.annotation.value.remove.text=Eliminar anotación de tipo de la definición de valor
intention.type.annotation.variable.add.text=Agregar anotación de tipo a la definición de variable
intention.type.annotation.variable.remove.text=Eliminar anotación de tipo de la definición de variable
intention.type.annotation.pattern.add.text=Agregar anotación de tipo a la definición de patrón
intention.type.annotation.pattern.remove.text=Eliminar anotación de tipo de la definición de patrón
intention.type.annotation.parameter.add.text=Agregar anotación de tipo a los parámetros
intention.type.annotation.parameter.remove.text=Eliminar anotación de tipo de los parámetros
intention.type.annotation.underscore.add.text=Agregar anotación de tipo al parámetro de subrayado
intention.type.annotation.underscore.remove.text=Eliminar anotación de tipo del parámetro de guión bajo
remove.case.clause=Eliminar cláusula de caso
remove.finally=Eliminar finalmente bloquear
remove.catch=Quitar bloque de captura
unwrap.interpolated.string.injection=Insertar cadena interpolada Desenvolver
unwrap.case.clause=Desenvolver cláusulas del caso
unwrap.finally=Finalmente desenvolver la línea
unwrap.try.with.finally=Intentar/finalmente desenvolver
val.on.case.class.param.redundant=Los parámetros del constructor predeterminado de la clase Case y el controlador ''val'' están duplicados
remove.val=Quitar ''valor''
specify.type.of.exception=Especificar tipo de excepción
suspicicious.forward.reference.template.body=Referencias directas sospechosas dentro de una clase
remove.braces.from.import=Eliminar llaves de la declaración de importación
make.import.fully.qualified=Normalizar declaraciones de importación
delete.inlined.tag=Eliminar etiquetas en línea
replace.with.wiki.syntax=Conversión de etiquetas en línea a sintaxis wiki de ancho fijo
move.text.after.header.to.new.line=Mover texto a una nueva línea después de cerrar el encabezado
balance.header=Encabezado de saldo
replace.tag.with.esc.seq=Reemplazar etiquetas con secuencias de escape
delete.duplicating.param=Eliminar parámetros duplicados
delete.tag=Eliminar etiqueta
delete.unknown.tag=Eliminar etiquetas desconocidas
replace.tuple.type=Convertir TuplaN[A1, A1,..., AN] a (A1, A1,..., AN)
replace.fun.type=Cambie la función N[A1, A1,..., AN, R] a (A1, A1,..., AN) \=> R
new.on.case.class.instantiation.redundant=Quitar el controlador ''nuevo''
remove.return.keyword=Eliminar palabra clave de retorno
xml.no.opening.tag=Sin etiqueta de apertura
xml.no.closing.tag=Sin etiqueta de cierre
xml.delete.unmatched.tag=Eliminar etiquetas no coincidentes
xml.rename.opening.tag=Cambiar el nombre de la etiqueta de apertura
xml.rename.closing.tag=Cambiar el nombre de la etiqueta de cierre
compilation.charts.reset.zoom.action.text=Restablecer zoom vertical
compilation.charts.reset.zoom.action.description=Restablecer el zoom vertical para gráficos de compilación
compilation.charts.zoom.out.action.text=Alejar verticalmente
compilation.charts.zoom.out.action.description=Compilar gráfico para alejar verticalmente
compilation.charts.zoom.in.action.text=Zoom vertical
compilation.charts.zoom.in.action.description=Zoom vertical del gráfico de compilación.
compilation.charts.title=Cuadro
cannot.start.scala.compile.server=No se puede iniciar el servidor de compilación Scala
jdk.for.compiler.process.not.found=No se pudo encontrar el JDK para el proceso del compilador. {0}
required.file.not.found.paths=No se puede encontrar el archivo requerido. {0}
can.t.find.default.jdk=JDK predeterminado no encontrado
cant.find.jdk=JDK no encontrado. {0}
compile.server.terminated.unexpectedly.0.port.1.pid=El servidor de compilación finalizó inesperadamente<br>(puerto: {0}, pid: {1})
scala.compile.server.title=Servidor de compilación Scala
action.run=Ejecuta&r
start.compile.server=Iniciar servidor de compilación
action.stop=&Detener
shutdown.compile.server=Cerrar el servidor de compilación
action.configure=&Configurar...
configure.compile.server=Configuración del servidor de compilación
compile.server.stopped.due.to.inactivity=Servidor de compilación abortado debido a inactividad
shared.compile.output.paths.in.scala.modules=Ruta de salida de compilación compartida dentro de un módulo Scala
production.and.test.output.paths.are.shared.in=Las rutas de salida de producción y prueba se comparten en \: {0}
split.output.paths.automatically=División automática de la ruta de salida
cancel.compilation=Cancelar compilación
jvm.options=Opciones de máquina virtual (&O)\:
jvm.maximum.heap.size.mb=Tamaño máximo del montón, MB(&H)\:
jdk=JDK(&J)\:
minutes=Minuto
compile.server.jvm.command.line.parameters=Parámetros de la línea de comando JVM del servidor de compilación
compile.server.shutdown.if.idle.for=Detente cuando estés en estado de ídolo
compile.server.use.for.scala=Usar servidor de compilación
compile.server.parallelism=Eso
compile.server.parallel.compilation=Compilación paralela de módulos independientes, número máximo de subprocesos:
compile.server.new.project.restart=Para cambiar el directorio de trabajo del proceso, debe reiniciar el servidor cada vez que cambie un proyecto.
compile.server.use.project.home=&Iniciar proceso desde el directorio del proyecto
compile.server.description=JDK crea una instancia del servidor de compilación y devuelve ''{0}'' para \ntipo de SDK inesperado\: {1}
incompatible.plugin.detected=Se detectó un complemento incompatible
scala.3.support.is.experimental=La compatibilidad con Scala 3 está en desarrollo.<br>Pruebe la compilación nocturna. <a href\=''{0}''>Más información</a>
configure.updates=Configurar actualizaciones...
idea.is.outdated.please.update=IDEA no está actualizada con la rama {0} del complemento Scala.<br/>Para utilizar el complemento Scala más reciente, actualice IDEA a {1} o superior.
please.select.scala.plugin.update.channel=Seleccione un canal de actualización del complemento Scala:
channel.stable.releases=Lanzamiento estable
channel.early.access.program=Programa de acceso temprano
channel.nightly.builds=Construcción nocturna
scala.type.aware.highlighting.indicator=Indicador resaltado de reconocimiento de tipo Scala
type.aware.highlighting.title=Resalte el reconocimiento de tipo Scala
click.or.press.shortcut.to.change=(Haga clic o toque {0} para cambiar)
click.to.change=(Haga clic para cambiar)
enabled.word=Habilitado
disabled.word=Deshabilitado
downloading.url=Descargando {0}
title.searching.for.library.extensions=Búsqueda de extensiones de biblioteca
select.library.from.the.list.above=Seleccione una biblioteca de la lista anterior
idea.will.try.to.search.for.extra.support.for.particular.libraries=IDEA intentará encontrar soporte adicional para bibliotecas específicas en su proyecto.
title.failed.to.load.extension.jar=Falló la carga del JAR de extensión
no.known.extension.libraries=No se conocen bibliotecas de extensiones
known.extension.libraries=Bibliotecas de extensiones conocidas
extensions.in.selected.library=Ampliación dentro de la biblioteca seleccionada
enable.loading.external.extensions=Habilitar carga de extensión externa
how.to.add.custom.macro.support.help.link.title=Cómo agregar compatibilidad con macros Scala personalizadas
title.extensions.available=Extensiones disponibles
additional.support.has.been.found.popup=<p>Se ha encontrado soporte adicional para algunas bibliotecas.</p><p>¿Le gustaría habilitarlo? <a href\="Sí">Sí</a>/<a href\="No">No</a></p>
scala.language.console.placeholder.command.to.execute=Ejecutar <{0}>
scala.console.actions.scala.repl=Scala REPL
scalarepl.menu.action.text=Scala REPL...
scalarepl.menu.action.description=Ejecución de REPL de Scala
clean.scala.repl.content.menu.action.text=Eliminar contenido de Scala REPL
clean.scala.repl.content.menu.action.description=Eliminar contenido de Scala REPL
execute.scala.repl.statement.menu.action.text=Ejecutar sentencias REPL de Scala
execute.scala.repl.statement.menu.action.description=Ejecutar sentencias REPL de Scala
scalaconsole.new.line.in.repl=Nueva línea dentro de REPL
send.selection.to.scala.repl.menu.action.text=Envío de selecciones a Scala REPL
send.selection.to.scala.repl.menu.action.description=Envío de selecciones a Scala REPL
scala.console.config.display.name=Scala REPL
scala.console.config.scala.repl.run.configurations=Configurar la ejecución de Scala REPL
scala.console.config.module.is.not.specified=Módulo no especificado
scala.console.config.working.directory=Directorio de trabajo\:
scala.console.config.use.classpath.and.sdk.of.module=Utilice classpath y módulo SDK\:
scala.console.config.vm.options=Opciones de máquina virtual
scala.console.config.console.arguments=Argumento de consola
scala.console.config.test.run.config.choose.working.directory=Seleccionar directorio de trabajo
scala.console.configure.scala.sdk.classpath=Configurar la ruta de clase del SDK de Scala
subsystem.requires.jline=Se requiere {1} para ejecutar {0}\nEl proceso de depuración se ha desconectado.
line.breakpoints.tab.title=Puntos de interrupción de la línea Scala
breakpoint.location.constructor.of=Constructor de {0}
breakpoint.location.early.definitions.of=Definición inicial de {0}
breakpoint.location.line.in.containing.block=Líneas dentro de un bloque que contiene
breakpoint.location.line.in.function=Función {0} mi línea
breakpoint.location.line.in.containing.file=Líneas en el archivo de inclusión
evaluation.of.object.needs.compilation=La evaluación de un objeto requiere compilación
evaluation.of.class.needs.compilation=Evaluar una clase requiere compilación
evaluation.of.trait.needs.compilation=Se requiere compilación para evaluar propiedades.
evaluation.of.anonymous.class.needs.compilation=La evaluación de clases anónimas requiere compilación
evaluation.of.type.alias.needs.compilation=Se requiere compilación para evaluar alias de tipo
evaluation.of.function.definition.needs.compilation=Se requiere compilación para evaluar las definiciones de funciones.
evaluation.of.variable.declaration.needs.compilation=La evaluación de declaraciones de variables requiere compilación
evaluation.of.lazy.val.definition.needs.compilation=La evaluación de definiciones de val diferidas requiere compilación
evaluation.of.anonymous.function.needs.compilation=La evaluación de funciones anónimas requiere compilación
evaluation.of.for.expression.needs.compilation=La evaluación de la expresión for requiere compilación
evaluation.of.try.statement.needs.compilation=La evaluación de una declaración de prueba requiere compilación
evaluation.of.return.statement.needs.compilation=La evaluación de la declaración de devolución requiere compilación
evaluation.of.match.statement.needs.compilation=La evaluación de la declaración de coincidencia requiere compilación
evaluation.of.throw.statement.needs.compilation=La evaluación de declaraciones de lanzamiento requiere compilación
evaluation.of.xml.expression.needs.compilation=Se requiere compilación para evaluar expresiones xml
evaluation.of.interpolated.string.needs.compilation=La evaluación de cadenas interpoladas requiere compilación
cannot.find.by.name.parameter.with.such.name=No se pudo encontrar un parámetro por nombre con el siguiente nombre. {0}
evaluation.of.expression.is.not.supported=No se admite la evaluación de expresiones. {0}
evaluation.of.element.is.not.supported=No se admite la evaluación de elementos. {0}
cannot.evaluate.imported.reference=No se puede evaluar la referencia importada
cannot.evaluate.local.method=El método local no se puede evaluar
cannot.evaluate.parameter=El parámetro {0} no se puede evaluar
cannot.evaluate.method=El método {0} no se puede evaluar
cannot.evaluate.local.object=No se puede evaluar el objeto local {0}
cannot.evaluate.local.variable=La variable local {0} no se puede evaluar
wrong.number.of.arguments=Número de argumentos no válido para el método {0}
array.instance.is.not.found=No se puede evaluar el método {0}\: no se encontró la instancia de matriz
array.method.not.supported=Métodos de matriz no compatibles
cannot.find.implicit.parameters=Parámetro implícito para pasar no encontrado
implicit.parameters.from.dependent.objects=No se admiten parámetros implícitos en objetos dependientes.
implicit.conversions.from.dependent.objects=No se admite la conversión implícita de objetos dependientes
method.with.by-name.parameters=El método con parámetro de nombre no se puede evaluar
wrong.number.of.expressions=No se puede evaluar el argumento\: Número no válido de expresiones coincidentes
tupling.not.supported=No se admite la tuplación. Utilice expresiones de tupla.
not.used.from.for.statement=La variable {0} en la declaración for no se puede evaluar porque no se usa en el cuerpo.
cannot.find.pattern=Patrón en caso de que no se encuentre la cláusula
cannot.find.expression.of.match=Expresión de declaración de coincidencia no encontrada
invalid.case.clause=Cláusula de caso no válido
assignent.without.expression=La declaración de tarea sin expresión no se puede evaluar
unapply.without.arguments=No se puede extraer el valor de no aplicar sin argumentos
pattern.doesnot.resolves.to.unapply=La referencia de patrón {0} no se resuelve mediante unaapply o unaapplySeq
pattern.alternatives.cannot.bind.vars=La sustitución de patrones no puede vincular la variable
xml.patterns.not.supported=Los patrones XML no son compatibles
kind.of.patterns.not.supported=Este tipo de patrón no es compatible\: {0}
anon.classes.not.supported=No se admiten funciones anónimas
new.expression.without.class.reference=No se puede evaluar una nueva expresión sin referencia de clase
new.expression.without.constructor.call=No se puede evaluar la expresión sin llamar al constructor
new.expression.without.template.parents=No se puede evaluar la expresión sin la plantilla principal
could.not.resolve.constructor=El constructor no se pudo resolver
if.statement.without.condition=No se puede evaluar si la declaración sin condición
if.statement.without.if.branch=No se puede evaluar la declaración if sin la rama if
while.statement.without.condition=No se puede evaluar la declaración while sin condición
while.statement.without.body=No se puede evaluar la declaración while sin cuerpo
do.statement.without.condition=No se puede evaluar la declaración do sin condición
do.statement.without.body=No se puede evaluar la declaración do sin cuerpo
method.call.implicitly.converted.qualifier=No se puede evaluar la llamada al método con el calificador convertido implícitamente\: {0}
synchronized.statement.is.not.supported=La sintaxis sincronizada no es compatible
cannot.evaluate.synthetic.method=No se puede evaluar el método de integración. {0}
by.name.parameter.expected=Se requiere el parámetro de nombre
update.method.is.not.supported=El método de actualización no es compatible
variable.definition.needs.right.hand.side=Las definiciones de variables requieren un lado derecho. {0}
value.definition.needs.right.hand.side=La definición del valor requiere el lado derecho. {0}
could.not.compile=No se puede compilar\nError de compilación
cannot.perform.boxing.conversion.for.result=No se puede realizar la transformación de boxeo en {0}
could.not.compile.generated.class=No se puede compilar la clase generada
error.during.generated.code.invocation=Error al llamar al código generado\:\nError al generar el cargador de clases de evaluación\:\nError al definir la clase\:\nNo se puede encontrar el módulo para la compilación
could.not.evaluate.due.to.a.change.in.a.source.file=No se puede evaluar debido a cambios en los archivos fuente
could.not.compile.local.class.in.this.context=Las clases locales no se pueden compilar en este contexto.
condition.has.wrong.type=La condición tiene un tipo no válido
unknown.type.of.literal=Tipo literal desconocido
literal.has.null.value=El literal {0} tiene valor nulo
could.not.find.appropriate.constructor.for.name=No se encontró ningún constructor adecuado para {0}
cannot.invoke.abstract.interface.method.name=No se puede llamar al método de interfaz abstracta {0}
method.methodname.cannot.be.invoked.on.array=No se puede invocar el método {0} en una matriz
outer.this.not.available=No se puede usar `this` externo
friendly.collection.debug.start.index=Índice de inicio de colección
friendly.collection.debug.end.index=Índice de fin de colección
friendly.collection.display.enabled=Mostrar la colección Scala en el depurador
friendly.collection.do.not.display.streams=No expandir transmisiones y vistas
dont.show.runtime.refs=Suprimir las referencias en tiempo de ejecución en el depurador
show.variables.from.outer.scopes.in.variables.view=Mostrar variables del alcance externo en la vista Variables
scala.debug.caption=escala
scala.debug.disable.specific.methods=&No entre en clases específicas de Scala
scala.streams.as.collections=Scala Streams como colecciones
scala.runtime.references.renderer=Representador de referencia en tiempo de ejecución de Scala
scala.collection=Colección Scala
cannot.evaluate.expression=La expresión no se puede evaluar.
value.is.not.an.integer={0} no es un número entero
value.is.not.a.boolean={0} no es booleano
auto.import.insert.imports.on.paste=Insertar importación al pegar\:
auto.import.show.import.popup.for=Mostrar ventana emergente de declaración de importación\:
auto.import.add.unambiguous.imports.on.the.fly.for=Agregue inmediatamente una declaración de importación inequívoca en \:
auto.import.optimize.imports.on.the.fly=Optimización inmediata de las declaraciones de importación.
auto.import.show.popup.classes=Clase
auto.import.show.popup.methods=Miembro estático
auto.import.show.popup.conversions=Conversión implícita
auto.import.show.popup.implicits=Definición implícita
options.scala.display.name=escala
auto.import.find.more.options.in=Encuentra más opciones en
auto.import.code.style.link=Estilo de código
highlighting.compilation.progress=Resaltado\: {0}
highlighting.compilation=Resaltado de errores/advertencias
scala.project.settings.form.compiler.highlighting.scala2=Usando el compilador para resaltar errores en Scala
scala.project.settings.form.compiler.highlighting.scala3=Usando el compilador para resaltar errores en Scala
scala.project.settings.form.compiler.highlighting.tooltip=Utilice mensajes de error directamente del compilador en lugar del resaltador integrado. Esto da como resultado un resaltado de errores más preciso, pero puede parecer más lento e impedir la inspección y las soluciones rápidas.
open.compiler.index.reader=Lector de índice de compilador abierto
index.invalidation.callback=Devolución de llamada de invalidación de índice
bytecode.indices.target.sam.type=Tipo SAM
bytecode.indices.target.unapply.method=Aplicar/desaplicar métodos
bytecode.indices.target.for.comprehension.method=Método de comprensión
bytecode.indices.target.implicit.definition=Definición implícita
malformed.message.from.builder=El texto del mensaje del constructor tiene un formato incorrecto\: {0}
failed.to.parse.offline.compilation.analysis.files=Error al analizar el archivo de análisis de compilación sin conexión.
sbt.module.added=Se agregó el módulo SBT.
sbt.connection.failure=SBT Compilation Watcher\: Error de conexión.
failed.to.parse.compilation.info.file=No se pudo analizar el archivo de información de compilación {0}
error.while.reading.sbt.compilation.info=Se produjo un error al intentar leer el archivo de información de compilación de SBT.
bytecode.indices.indexing=Indexando archivos de clase...
title.initializing.compiler.indices.writer=Inicializando el indexador del compilador
title.closing.compiler.indices.writer=Cerrando el indexador del compilador
title.invalidating.compiler.indices=Invalidando el índice del compilador
bytecode.indices.progress.title=Indexando archivos de clase recompilados...
bytecode.indices.unavailable=La búsqueda de usos a través del índice de código de bytes no está disponible durante la compilación.
bytecode.indices.in.progress=Indexación en curso
bytecode.indices.find.usages=Encontrar uso
bytecode.indices.invalidated.title=Uso no validado
bytecode.indices.invalidated.message=Es posible que los cambios externos hayan invalidado algunos usos en los siguientes archivos\: {0}.
bytecode.indices.find.usages.with.title=Encuentre dónde usar ({0})
bytecode.indices.settings.navigate=Vaya a la configuración del índice de código de bytes
bytecode.indices.enable.indexing=Habilitar la indexación de códigos de bytes
bytecode.indices.enable=Activar
bytecode.indices.enable.and.restart=Reiniciar después de la activación
bytecode.indices.precompile=Precompilar los módulos dentro del alcance antes de buscar
bytecode.indices.bytecode=Código de bytes
bytecode.indices.settings=Configuración | Indexación de código de bytes
bytecode.indices.required=Esta búsqueda se basa en
bytecode.indices.outdated=, que no está actualizado.
bytecode.indices.incomplete=Si no compila, los resultados pueden estar incompletos.
bytecode.indices.must.be.enabled.1=La indexación de código de bytes debe estar habilitada para buscar usos de {0}.
bytecode.indices.must.be.enabled.2=¿Quiere habilitar la indexación de códigos de bytes (entra en vigor después del reinicio de IDEA)?
bytecode.indices=Índice de código de bytes
bytecode.indices.restart.title=Actualizar la configuración del índice de código de bytes
bytecode.indices.restart.message=¿Le gustaría reiniciar IDEA para permitir cambios en la configuración del índice de código de bytes?
bytecode.indices.shutdown.message=¿Quiere salir de IDEA para permitir cambios en la configuración del índice de código de bytes?
scala.compiler.indices.settings.enable.cb=&Indexar archivos .class
scala.compiler.indices.settings.invalidate.button=Eliminar e indexar índice
scala.compiler.indices.sbt.automatic=Automático (requiere tienda SBT)
scala.compiler.indices.sbt.manual=&Manual
apply.unapply.methods=Aplicar/desaplicar métodos
for.comprehension.methods=método para entender (mapa, withFilter, flatMap, foreach)
add.line.to.build.sbt=Agregue la siguiente línea a build.sbt\:
add.line.to.plugins.sbt=Agregue la siguiente línea a project/plugins.sbt\:
implicit.definitions=Definición implícita
port.number=Número de puerto\:
sam.types=Tipo SAM
sbt.compilation.listener=Configurar el detector de compilación SBT (para toda la aplicación)
use.indices.to.search=Utilice el índice para buscar uso\:
are.you.sure.you.want.to.delete.the.bytecode.indices=¿Está seguro de que desea eliminar el índice de código de bytes?
delete.bytecode.indices=Eliminar índice de código de bytes
find.usages.member.has.supers=El miembro {0} anula o implementa algunos miembros predeterminados.\nAdvertencia
find.what.members.usages.checkbox=&Dónde utilizar los miembros
find.what.implementing.type.definitions.checkbox=&Implementación de definición de tipo
find.what.companion.module.checkbox=&Dónde utilizar los módulos complementarios
find.what.new.instances.usages=&Solo creación de instancias
scala.mutable.collection=Colección de variables
scala.immutable.collection=Colección inmutable
java.collection=Colección Java
wrong.top.statment.declaration=Declaración de sintaxis superior no válida
to.import.method.statically.press.hotkey=Para importar el método estáticamente, presione {0}.
action.import.member=Obtener miembros
method.of.containingclass={0} de {1}
descritive.name.anonymous=Anónimo
usage.extractor=Extractor
usage.typed.pattern=Patrón mecanografiado
usage.typed.statement=Sintaxis escrita
usage.method.apply=Método "aplicar"
usage.this.reference=Mira esto
usage.access.modifier=Controlador de acceso
usage.package.clause=Cláusula del paquete
usage.function.expression=Expresión de función
usage.named.parameter=Parámetro con nombre
usage.interpolated.string.prefix=Prefijo de cadena interpolada
usage.parameter.in.pattern=Parámetros dentro del patrón.
usage.self.type=Propio tipo
usage.type.bound=Tipo enlazado
usage.type.alias=Escriba alias
usage.secondary.constructor=Constructor secundario
usage.implicit.conversion.parameter=Conversión implícita/parámetros
usage.unresolved.implicit.conversion.parameter=Conversiones/parámetros implícitos no resueltos
usage.sam.interface.implementation=Implementación de la interfaz SAM
scalafmt.suggester.detected.in.project=Configuración de Scalafmt detectada en este proyecto
scalafmt.suggester.use.scalafmt.formatter=Utilice la herramienta de formato Scalafmt
scalafmt.suggester.continue.using.intellij.formatter=Continuar usando las herramientas de formato IntelliJ
scalafmt.picked.new.config=Nueva configuración de estilo (v{0}) aplicada a Scalafmt
scalafmt.can.not.find.config.file=Archivo de configuración no encontrado. {0}
scalafmt.can.not.find.config.file.go.to.settings=Configuración...
scalafmt.can.not.find.config.file.create.new=Crea un nuevo archivo.
scalafmt.can.not.create.config.file=No se pudo crear el archivo de configuración
scalafmt.config.load.errors.failed.to.load.config=Error al cargar la configuración de Scalafmt
scalafmt.config.load.errors.file.not.found=Archivo no encontrado
scalafmt.config.load.errors.parse.error=Error de análisis\: {0}
scalafmt.config.load.errors.unknown.error=Error desconocido\: {0}
scalafmt.config.load.errors.cyclic.includes.detected=Incluye circular detectada
scalafmt.config.load.actions.open.config.file=Abrir archivo de configuración
scalafmt.download=Descargar
scalafmt.resolve.again=Resuelto de nuevo
scalafmt.progress.resolving.scalafmt.version=Resolviendo la versión de Scalafmt {0}
scalafmt.progress.downloading.scalafmt.version=Descargando la versión Scalafmt {0}
scalafmt.progress.resolving.scalafmt.version.cancel=Deja de resolver
scalafmt.progress.downloading.scalafmt.version.cancel=Descarga detenida
scalafmt.progress.version.was.downloaded=Se ha descargado la versión {0} de Scalafmt
scalafmt.resolve.errors.cant.resolve.scalafmt.version=No se pudo resolver la versión {0} de Scalafmt
scalafmt.resolve.errors.version.is.not.downloaded.yet=La versión de Scalafmt `{0}` no se ha descargado.<br>¿Le gustaría descargarla?
scalafmt.resolve.errors.download.is.in.progress=La descarga está en curso.
scalafmt.resolve.errors.downloading.error.occurred=Error al descargar
scalafmt.resolve.errors.classpath.is.corrupted=Classpath está corrupto
scalafmt.resolve.errors.unknown.error=Error desconocido
file.does.not.exist=No hay ningún archivo.
failed.to.resolve.scalafmt.version=No se pudo resolver la versión de Scalafmt ''{0}''
scalafmt.format.errors.scala.file.parse.error=Error de análisis de Scalafmt ({0})\:<br>{1}
scalafmt.format.errors.failed.to.find.correct.surrounding.code=Error de Scalafmt ({0})\:<br> No se pudo encontrar el código adjunto correcto para pasar a scalafmt, no se realiza ningún formateo
imports.panel.class.count.to.use.import.with=Número de clases que utilizan importar con ''_''\:
imports.panel.add.import.statement.in.closest.block=Agregar declaración de importación al bloque más cercano
imports.panel.add.fully.qualified.imports=Agregar declaraciones de importación completas
imports.panel.do.not.change.path.during.optimize.imports.for.local.imports=No cambie las rutas durante la optimización de la declaración de importación local
imports.panel.sort.imports.for.optimize.imports=Alinear declaraciones de importación (optimizar declaraciones de importación)\:
imports.panel.lexicographically=Alfabéticamente
imports.panel.scalastyle.consistent=Coincidencia de estilo escalable
imports.panel.force.scala2.in.source3=Obtenga sintaxis al usar -Xsource:3:
imports.panel.merge.imports.with.the.same.prefix.into.one.statement=Fusionar declaraciones de importación con el mismo prefijo en una sola declaración
imports.panel.use.the.shortest.path.when.trying.to.import.reference.with.already.imported.name=Utilice la ruta más corta al intentar importar referencias con nombres ya importados
imports.panel.classes.to.use.only.with.prefix=Clase a usar que contiene solo el prefijo
imports.panel.import.layout=Obtener diseño
imports.panel.imports.always.marked.as.used=Declaración de importación marcada como siempre utilizada
except.for.base.package=Excluido el paquete básico
imports.panel.title=Importar
imports.panel.add.pattern.to.use.appropriate.classes.only.with.prefix=Agregue un patrón que use clases que contengan solo el prefijo
imports.panel.use.references.with.prefix=Utilice referencias que contengan el prefijo\:
imports.panel.no.imports.with.prefix=Sin declaraciones de importación con prefijo
imports.panel.add.package.name=Agregar nombre del paquete
imports.panel.import.layout.manager=Administrador de diseño de importación
imports.panel.add.import.to.always.mark.it.as.used=Agregue una declaración de importación para marcar como siempre utilizada
imports.panel.always.mark.as.used=Marcar siempre como usado
imports.panel.honestly.mark.imports.as.unused=Marcar francamente las declaraciones de importación como obsoletas
imports.panel.base.package.help=Si el paquete base es <code>org.example.application</code>, la clase <code>org.example.application.NAME</code> debe importarse con <code>import NAME</code>
multi.line.string.panel.opening.quotes.on.new.line=Coloque una comilla de apertura (&O) en una nueva línea
multi.line.string.panel.place.closing.quotes.on.new.line.on.enter.press=Coloque comillas de cierre (&C) en una nueva línea al escribir Enter
multi.line.string.panel.align.dangling.closing.quotes=Asignar una comilla de cierre imaginaria (&A)
multi.line.string.panel.insert.margin.char.on.enter=Inserte un carácter de espacio (&I) en una nueva línea al escribir Enter
multi.line.string.panel.process.margin.on.copy.paste=&Eliminar/Insertar márgenes al copiar/pegar
multi.line.string.panel.margin.char.value=Carácter de margen\:
multi.line.string.panel.margin.char.indent=Caracteres de margen de sangría \:
multi.line.string.panel.title=Cadena de varias líneas
other.panel.enforce.functional.syntax.for.methods.with.unit.return.type=Forzar la sintaxis de la función para métodos con tipo de retorno Unidad
other.panel.reformat.on.compile=Reformatear en tiempo de compilación
other.panel.replace.with.unicode.symbol=Convertir ''\=>'' a símbolo Unicode
other.panel.replace.with.unicode.symbol1=Convertir ''->'' a símbolo Unicode
other.panel.replace.in.for.generator.with.unicode.symbol=Reemplace ''<-'' en el generador \"for\" con un símbolo Unicode.
other.panel.kind.projector.replace.lambda.with.unicode.symbol=Kind Proyector\: Convertir ''Lambda'' a símbolo Unicode
other.panel.alternate.indentation.for.constructor.args.and.parameter.declarations=Sangría alternativa para declaraciones de parámetros y argumentos del constructor\:
other.panel.spaces=Brecha
other.panel.implicit.value.class.prefix.suffix=Prefijo/sufijo de clase de valor implícito
other.panel.title=Otros
scala3.panel.use.indentation.based.syntax=Utiliza sintaxis basada en sangría
scala3.panel.title=Scala 3
wrapping.and.braces.panel.extends.do.not.align=No ordenado
wrapping.and.braces.panel.extends.on.first.token=Primera ficha
wrapping.and.braces.panel.extends.align.to.extends=Asignar a ''extiende''
scaladoc.panel.title=ScalaDoc
scaladoc.panel.enable.scaladoc.formatting=Habilitar el formato Scaladoc
scaladoc.panel.add.additional.space.for.leading.asterisk=Agregue espacio adicional al asterisco inicial
scaladoc.panel.groups.blank.lines=Linea en blanco
scaladoc.panel.groups.alignment=Adaptar
scaladoc.panel.groups.other=Otros
scalafmt.default=Por defecto
scalafmt.default.path=Valor por defecto\: {0}
scalafmt.settings.panel.show.warnings.when.formatting.invalid.code=Mostrar una advertencia al intentar formatear un código no válido
scalafmt.settings.panel.use.intellij.formatter.for.code.range.formatting=Utilice herramientas de formato IntelliJ para formatear rangos de códigos
scalafmt.settings.panel.use.intellij.formatter.for.code.range.formatting.warning.tooltip=El uso de Scalafmt para formatear rangos de códigos puede causar inconsistencias en el código.<br>Scalafmt solo debe usarse para formatear archivos completos que contengan código Scala.
scalafmt.settings.panel.reformat.on.file.save=Reformatear archivos al guardar
scalafmt.settings.panel.fallback.to.default.settings=Volver a la configuración predeterminada de IntelliJ
scalafmt.settings.panel.configuration.label=Composición
scalafmt.settings.panel.scalafmt.version.label=Versión escalafón
scalafmt.settings.panel.select.custom.scalafmt.configuration.file=Seleccione un archivo de configuración Scalafmt personalizado
scalafmt.settings.panel.no.config.found.under.path.using.default=Archivo de configuración no encontrado en la ruta especificada
scalafmt.settings.panel.errors.cant.resolve.version=No se pudo resolver la versión {0} de Scalafmt
scalafmt.settings.panel.errors.failed.to.parse.config=Error en la configuración del análisis\:<br> {0}
scalafmt.settings.panel.errors.cant.find.config.file=No se pudo encontrar el archivo de configuración de Scalafmt con la siguiente ruta:<br> {0}
spaces.panel.simple.one.line.block.braces=Tirantes de bloque simples de una línea
spaces.panel.import.braces=Conseguir frenillos
spaces.panel.self.type.braces=Aparatos ortopédicos de tipo propio
spaces.panel.before.context.bound.colon.rest=Antes del texto enlazado dos puntos (resto)
spaces.panel.before.context.bound.colon.leading.higher.kinded=Antes de los dos puntos vinculados al contexto (que van hacia arriba)
spaces.panel.before.context.bound.colon.leading=Antes (principal) de dos puntos vinculados al contexto
spaces.panel.before.opening.square.bracket=Antes del corchete de apertura
spaces.panel.keep.one.line.comments.on.same.line=Mantenga los comentarios de una sola línea en la misma línea
spaces.panel.newline.after.annotations=Nueva línea después de la anotación
spaces.panel.around.at.in.pattern.bindings=Patrón de encuadernación alrededor de mi ''@''
spaces.panel.inside.closure.braces=Dentro de los tirantes de cierre
spaces.panel.before.colon.after.declarations.name=Antes de los dos puntos, después del nombre de la declaración
spaces.panel.after.colon.before.declarations.type=Después de los dos puntos, antes del tipo de declaración
spaces.panel.method.call.left.brace=Llamada al método llave izquierda
spaces.panel.preserve.space.before.method.parentheses=Preservar espacio antes de los paréntesis del método
spaces.panel.infix.method.parentheses=Paréntesis del método inflix
spaces.panel.infix.operator.like.method.call.parentheses=Paréntesis de llamada al método de expresión del operador inflix
spaces.panel.infix.method.call.parentheses=Paréntesis de llamada al método inflix
spaces.panel.constructor.parameters.with.modifiers=Parámetros del constructor con controladores.
wrapping.and.braces.panel.groups.method.definition=Definición del método
wrapping.and.braces.panel.groups.anonymous.method.definition=Definición del método anónimo
wrapping.and.braces.panel.groups.class.definition=Definición de clase
wrapping.and.braces.panel.groups.xml.formatting=Formatear XML
wrapping.and.braces.panel.groups.tuple=Doble
wrapping.and.braces.panel.groups.type.arguments=Tipo argumento
wrapping.and.braces.panel.groups.type.parameters=Tipo de parámetro
wrapping.and.braces.panel.force.braces=Tirantes de fuerza
wrapping.and.braces.panel.force.try.braces=Forzar "probar" brackets
wrapping.and.braces.panel.force.case.branch.braces=Soportes Forzar ''estuche''
wrapping.and.braces.panel.force.finally.braces=Forzar tirantes "finalmente"
wrapping.and.braces.panel.align.tuple.elements=Ordenar elementos de tupla
wrapping.and.braces.panel.do.not.indent.tuples.closing.parenthesis=No aplicar sangría a los paréntesis de cierre de tuplas
wrapping.and.braces.panel.do.not.align.block.expression.parameters=Parámetros de expresión de bloque de desorden
wrapping.and.braces.panel.indent.braced.arguments=Sangrar argumentos entre llaves
wrapping.and.braces.panel.simple.one.line.lambdas.in.arg.list=Lambda simple de una línea dentro de la lista de argumentos
wrapping.and.braces.panel.keep.xml.formatting=Mantener el formato XML
wrapping.and.braces.panel.place.self.type.on.new.line=Coloque su propio tipo en una nueva línea
wrapping.and.braces.panel.align.multiline.pattern.alternatives=Asignación alternativa de patrón multilínea
wrapping.and.braces.panel.align.in.columns.case.branches=Ordenar columna de rama ''caso''
wrapping.and.braces.panel.do.not.indent.case.clause.body=No sangrar el cuerpo de la cláusula del caso
wrapping.and.braces.panel.match.statement=Declaración ''coincidencia''
wrapping.and.braces.panel.indent.first.parameter.clause.if.on.new.line=Sangrar la cláusula del primer parámetro en una nueva línea
wrapping.and.braces.panel.indent.first.parameter.if.on.new.line=Sangrar el primer parámetro en una nueva línea
wrapping.and.braces.panel.align.parameter.types.in.multiline.declarations=Ordenar tipos de parámetros dentro de declaraciones de varias líneas
wrapping.and.braces.panel.use.normal.indent.for.parameters=Utilice sangría normal para los parámetros.
wrapping.and.braces.panel.parameters.on.new.line=Parámetros en nueva línea
wrapping.and.braces.panel.wrap.before.with.keyword=Salto de línea antes de la palabra clave ''con''
wrapping.and.braces.panel.align.if.else.statements=Alineación de sintaxis if-else
wrapping.and.braces.panel.indent=Sangrar
wrapping.and.braces.panel.new.line.options.no.new.line=Sin nuevas líneas
wrapping.and.braces.panel.new.line.options.new.line.always=Siempre salto de línea
wrapping.and.braces.panel.new.line.options.new.line.for.multiple.arguments=Saltos de línea cuando se utilizan argumentos de varias líneas
wrapping.and.braces.panel.renamed.infix.expressions=Expresión inflix
wrapping.and.braces.panel.renamed.extends.with.list=Extiende/con lista
wrapping.and.braces.panel.renamed.extends.keyword=Expansión de palabras clave
wrapping.and.braces.panel.renamed.force.yield.braces=Tirantes de cedencia forzada
wrapping.and.braces.panel.for.indent.yield.after.one.line.enumerators=Sangrar el rendimiento después de un enumerador de una línea
blank.lines.panel.around.method.in.inner.scopes=Alrededor de un método dentro de un alcance interno
blank.lines.panel.around.field.in.inner.scopes=Alrededor del campo dentro de los límites internos.
blank.lines.panel.around.class.in.inner.scopes=Alrededor de una clase dentro de un ámbito interno
scaladoc.panel.align.parameter.descriptions=Parámetro Descripción Ordenar
scaladoc.panel.align.throws.exception.descriptions=La tarea genera una descripción de excepción
scaladoc.panel.align.return.value.description=Valor de retorno Descripción Ordenar
scaladoc.panel.align.other.tags.descriptions=Otra etiqueta Descripción Ordenar
scaladoc.panel.blank.lines.keep=Mantener (las líneas en blanco entre etiquetas no se eliminan)
scaladoc.panel.between.parameter.descriptions=Entre descripciones de parámetros
scaladoc.panel.before.parameter.descriptions=Antes de la descripción del parámetro
scaladoc.panel.before.tags=Delante de la etiqueta
scaladoc.panel.after.tags=Después de regresar
scaladoc.panel.after.parameter.comments=Después de la descripción del parámetro
scaladoc.panel.preserve.spaces.in.tags=Mantener el espacio entre etiquetas
align.list.items.content=Ordenar el contenido de los elementos de la lista
scala.root.code.style.panel.formatter=Herramientas de formato\:
trailing.comma.panel.title=Coma final
trailing.comma.panel.keep=Mantener
trailing.comma.panel.remove.when.multiline=Eliminar cuando se utilizan varias líneas
trailing.comma.panel.add.when.multiline=Agregar para varias líneas
trailing.comma.panel.scope.arguments.list=Lista de argumentos
trailing.comma.panel.scope.parameters.list=Lista de parámetros
trailing.comma.panel.scope.tuple=Doble
trailing.comma.panel.scope.tuple.type=Tipo de tupla
trailing.comma.panel.scope.pattern.arguments.list=Lista de argumentos de patrón
trailing.comma.panel.scope.type.parameters.list=Lista de parámetros de tipo
trailing.comma.panel.scope.import.selector=Selector de importación
type.annotations.panel.use.for=Que usar
type.annotations.panel.public.member=Miembro público
type.annotations.panel.protected.member=Miembro protegido
type.annotations.panel.private.member=Miembro privado
type.annotations.panel.local.definition=Definición local
type.annotations.panel.function.literal.parameter=Parámetros literales de función
type.annotations.panel.underscore.parameter=Parámetro subrayado
type.annotations.panel.enforce.for=Aplicable a
type.annotations.panel.implicit.definition=Definición implícita
type.annotations.panel.unit.type=Tipo de unidad
type.annotations.panel.accidental.structural.type=Tipo de estructura inesperado*
type.annotations.panel.accidental.structural.type.tooltip=<html>Fuerza la anotación de tipo en el valor, tiene un tipo de estructura inferido, por ejemplo\:<br>\nRunnable {\n()\n()\nExcepción si:
type.annotations.panel.member.of.anonymous.class=Miembro anónimo de la clase
type.annotations.panel.member.of.private.class=Miembro de la clase privada
type.annotations.panel.member.of=Miembros de:
type.annotations.panel.annotated.with=Especificar anotación\:
type.annotations.panel.constant.final.val=Constante (valor final)
type.annotations.panel.type.is.stable=El tipo es estable*
type.annotations.panel.type.is.stable.tooltip=<html><body>Si el lado derecho es\:<br> literal\: <code>123</code>, <code>\"string\"</code>, etc. (incluido <code>null</code>)<br> Expresión de unidad\: <code>()</code><br> Creación de objetos\: <code>new Foo(...)</code> (Mejorado Incluir código\: <code>new Foo() {}</code>)<br> Llamar al método Factory\: <code>Foo(...)</code> (<code>apply(.. en el objeto complementario ) .)</code> call)<br> Colección vacía\: <code>Seq.empty[Int]</code>, <code>Map.empty[Int, String]</code>, etc.<br > Constantes de enumeración de Java\: <code>Enum.VALUE</code><br> Excepciones\: <code>throw Exception()</code></body></html>
type.annotations.panel.type.matches=Tipo de coincidencia\:
type.annotations.panel.in.test.sources=Mi fuente de prueba
type.annotations.panel.in.scala.dialect.sources=En lenguaje fuente derivado de Scala*
type.annotations.panel.in.scala.dialect.sources.tooltip=*.sbt, *.sc, etc.
type.annotations.panel.title=Tipo de anotación
type.annotations.panel.classes=Clase
type.annotations.panel.annotations=Anotación
type.annotations.panel.type.patterns=Patrón de tipo
scala.meta.expand=Macroexpansión
undo.macro.expansion=Deshacer expansión macro
wrong.pattern=Patrón equivocado
right.brace.expected=''}'' se espera
bad.interpolated.string.injection=Inserción de cadena interpolada incorrecta
wrong.string.literal=Literal de cadena no válido
end.of.string.expected=Esperar el final de la cadena
package.qualID.expected=Espera un identificador completo que indique el nombre del paquete.
semi.expected='';'' o esperar una nueva línea
out.of.compilation.unit=Rompiendo el dispositivo de compilación
lbrace.expected=''{'' se requiere
lbrace.or.colon.expected='{' o ':' es obligatorio
unreachable.error=Error inesperado encontrado
missing.toplevel.statement.for.annotation=Falta sintaxis de nivel superior para las anotaciones
rsqbracket.expected='']'' se requiere
identifier.expected=Expectativa del identificador
parameter.expected=Parámetros requeridos
expected.at.least.one.extension.method=Se requiere al menos 1 método de extensión
expected.new.line.after.colon=Se requiere una nueva línea después de los dos puntos
extension.method.expected=Necesitas un método de extensión
identifier.or.opening.brace.expected=Se requiere un identificador o llave de apertura
identifier.or.wild.sign.expected=Esperando un identificador o ''_''
rbrace.expected=''}'' se requiere
import.selector.expected=Expectativa del selector de importación
wrong.annotation.expression=Expresión de anotación no válida
rparenthesis.expected='')'' se requiere
wrong.expression=Expresión no válida
annotation.or.type.expected=Anotación o expectativa de tipo
wrong.type=Tipo incorrecto
wrong.binding=Parametro invalido
wrong.declaration.in.block=El bloque no puede contener declaraciones
missing.statement.for.annotation=Falta sintaxis para anotaciones
choose.expected=Esperando ''<-'' en la sintaxis del generador
case.clauses.expected=Expectativas del arco del caso
while.expected=Esperando la palabra clave while en la declaración ''do''
enumerators.expected=Esperando un enumerador dentro de una declaración ''para''
condition.expected=Espera condicional booleano
expected.then=''entonces'' es necesario
expected.do=''hacer'' es obligatorio
expected.do.or.yield=Se requiere ''hacer'' o ''ceder''
line.is.indented.too.far.to.the.left=La línea tiene una sangría demasiado a la izquierda
assign.expected=''\='' esperado
type.expected=Se requiere tipo
fun.sign.expected=''\=>'' esperado
wrong.parameter=Parametro invalido
implicit.params.excepted=Una cláusula de parámetro implícita debe contener al menos un parámetro.
using.parameter.clause.expected=Se requiere la cláusula de parámetro 'usando'
param.clause.expected=Expectativa de la cláusula de parámetro
variance.annotation.not.allowed=No se permiten anotaciones de cambio.
context.bounds.not.allowed=Límites de contexto no permitidos
view.bounds.not.allowed=No se permiten límites de visualización
expected.more.types=Necesita más tipos
pattern.expected=Expectativas de patrón
wrong.postfix.expression=Expresión de sufijo no válida
wrong.type.associativity=La correlación es incorrecta. Todos los operadores deben tener la misma correlación.
simple.pattern.expected=Inicio incorrecto de patrón simple
wrong.constr.expression=Expresión de constructor no válida
auxiliary.constructor.may.not.have.a.type.annotation=Los constructores auxiliares no pueden tener anotaciones de tipo.
auxiliary.constructor.definition.expected=Se requiere una definición de constructor secundario
expression.expected=Expectativa de expresión
expected.another.pattern=Espere un patrón diferente
wrong.val.declaration=Declaración de valor no válida
wrong.var.declaration=Declaración de variable no válida
wrong.simple.type=Tipo simple no válido
wrong.qual.identifier=Identificador completo no válido
wrong.case.modifier=El controlador del caso no es válido. Úselo como clase u objeto.
colon.expected=''\:'' expectativa
parameter.type.expected=Expectativa de tipo de parámetro
val.var.expected=Esperando la palabra clave val o var
def.dcl.expected=Definir o declarar expectativas
existential.block.expected=Espero que existas
wrong.existential.declaration=Esta es una declaración incorrecta de existencia. Debe ser una declaración de tipo o valor.
compound.type.expected=Expectativa de tipo complejo
match.type.cases.expected=Expectativas de la cláusula de caso de tipo de coincidencia
expected.case.on.a.new.line=Se requiere un caso en una nueva línea
type.lambda.expected=''\=>>'' esperado
identifier.expected.comma.found=Identificador esperado pero '''' encontrado
dot.expected=''.'' expectativa
dot.or.cq.expected=''.'' o calificador de clase requerido
xml.attribute.end.expected=Se esperaba el delimitador final del valor del atributo XML
xml.eq.expected=''\='' esperado
xml.attribute.value.expected=Se requiere valor de la propiedad
xml.cdata.end.expected=Esperando con ansias el final de XML CData
xml.comment.end.expected=Esperar el final del comentario XML (''-->'')
xml.wrong.character=Cadena no válida en comentario XML
xml.tag.end.expected=Expectativa del final de la etiqueta XML
xml.name.expected=Expectativas del nombre de la etiqueta XML
xml.end.tag.expected=Esperando etiqueta final XML (''</'' nombre ''>'')
xml.PI.end.expected=Esperando con ansias el final de las pautas de procesamiento XML
xml.scala.injection.end.expected=Espere el final de la inserción de Scala (''}'') en XML
xml.scala.expression.exected=Espere una expresión de Scala dentro de la inyección XML
xml.scala.patterns.exected=Espere el patrón Scala dentro de la inyección XML
recursive.type.of.type.element=Tipo recursivo de elemento de tipo
cannot.desugarize.typename=No se puede desazucar {0}
cannot.find.partialfunction.class=Clase de función parcial no encontrada
cannot.find.throwable.class=Clase arrojable no encontrada
cannot.infer.type.without.expected.type=No se puede inferir el tipo sin el tipo esperado
cannot.infer.type.without.function.expected.type=No se puede inferir el tipo sin el tipo esperado de scala.FunctionN o scala.PartialFunction
no.type.inferred=No se puede inferir el tipo de expresión ''{0}''
no.alias.type=Sin tipo de alias
file.type.scala.outlines=Esquema de escala
could.not.decompile.file.comment=//No se puede descompilar {0}
can.t.resolve.type=El tipo no se puede resolver
java.constructors.only.have.one.parameter.section=El constructor de Java contiene solo una sección de parámetros
has.no.reference=Sin referencia
cannot.find.method.of.stringcontext=Método {0} de StringContext no encontrado
wrong.psi.for.literal.type=El elemento que obtiene el tipo literal no es válido
cannot.resolve.unknown.symbol=El símbolo no se pudo resolver
cannot.define.expected.type=No se puede definir el tipo de expectativa
no.expected.type.for.wildcard.naming=No se espera ningún tipo de denominación comodín
no.type.element.for.type.pattern=Ningún elemento de tipo para el patrón de tipo
no.type.pattern=Sin patrón de tipo
cannot.determine.expected.type=No se pudo determinar el tipo de expectativa
dependent.function.types.are.not.yet.supported=Los tipos de funciones dependientes aún no son compatibles
match.types.are.not.yet.supported=El tipo de coincidencia aún no es compatible
cannot.find.template.for.this.reference=Plantilla no encontrada para esta referencia
cannot.find.enclosing.container=No puedo encontrar ese contenedor
cannot.resolve.ref=No se pudo resolver la referencia
unknown.macro.in.type.position=Macro desconocida en condición de tipo
recursive.non.value.type.of.type.element=Tipo recursivo, no el valor del elemento de tipo.
cannot.resolve.reference=No se pudo resolver la referencia
suitable.method.not.found=No se encontró ningún método adecuado
cannot.create.expression=No se puede crear expresión.
not.a.polymorphic.lambda=No es una lambda polimórfica
nothing.to.type=Escribe Nada que especificar
empty.new.expression=Nueva expresión vacía
no.expression.in.parentheseses=Sin expresión entre paréntesis
no.declared.type.found=Tipo definido no encontrado
case.class.has.no.primary.constructor=La clase de caso no tiene constructor predeterminado
cannot.resolve.expression=La expresión no se puede resolver.
not.enough.parameter.sections=La sección de parámetros no es suficiente.
cannot.shape.resolve.self.invocation=No se puede resolver la autollamada
cannot.infer.type.of.super.expression=No se puede inferir el tipo de expresión "super"
cannot.infer.type=El tipo no se puede inferir
no.clazz.type.found=Tipo de clase no encontrado
typed.statement.is.not.complete.for.underscore.section=La sintaxis escrita está incompleta para las secciones de subrayado
failed.to.found.corresponging.underscore.section=No se encontró la sección de subrayado correspondiente
could.not.infer.type.of.underscore.section=No se puede inferir el tipo de sección de subrayado
no.type.inferred.for.unknown.expression=No se puede inferir el tipo de expresión
not.found.scala.xml.node=No se puede encontrar scala.xml.Node
both.stub.and.name.identifier.node.are.null=Tanto el nodo de identificador de nombre como el de código auxiliar para {0} están vacíos\nNo se ha definido ningún tipo de retorno
no.type.element.found=Escriba el elemento no encontrado en ''{0}''
cannot.infer.type.without.an.expression=El tipo no se puede inferir sin expresión
wrong.stub.problem=Problema con el trozo malo
wrong.type.element=Elemento de tipo no válido
derives.type.has.no.type.parameters={0} no se puede derivar porque no tiene parámetros de tipo.
derives.type.has.no.companion.object={0} no se puede derivar porque no tiene ningún objeto complementario.
derives.cannot.be.unified={0} no se puede combinar con el argumento de tipo de {1}.
derives.not.a.class.type={0} no es un tipo de clase y no se puede derivar
derives.scala.class.expected=Requiere clase/rasgo de Scala
derives.no.member.named.derived=El valor derivado no es miembro del objeto {0}
cannot.resolve.parent.class=No se puede resolver la clase principal
no.containing.file=No existe el archivo
assignment.missing.right.side=Falta el lado derecho de la tarea
cannot.handle.compatibility.for=No se puede procesar la compatibilidad para {0}
variance.contravariant=Transformación semicolonial
variance.covariant=Covarianza
variance.invariant=No covarianza
variance.bivariant=Inusual
no.element.found=Elemento no encontrado
rearranger.panel.keep.scala.style.getters.and.setters.together=Mantener juntos los captadores y definidores estilo cala
rearranger.panel.keep.java.style.getters.and.setters.together=Mantener juntos los captadores y definidores de estilo Java
rearranger.panel.split.into.unarrangeable.blocks.by.expressions=Dividir en bloques que no se pueden ordenar mediante expresión
rearranger.panel.split.into.unarrangeable.blocks.by.implicits=Dividir en bloques implícitamente no alineables
by.name.parameters.cannot.be.used=Debido a que este método contiene una anulación de Java, no puede utilizar el parámetro de nombre de una clase de valor.
method.is.overridden.by.class.parameter.of.class=El método ha sido anulado por un parámetro de clase de {0} . No se admite la conversión de esto a una definición de función.
updating.of.usages.of.generated.unapply=No se admite la actualización de las ubicaciones de uso del método "desaplicar" generadas
method.is.overridden.in.a.composite.pattern.definition=El método se ha anulado en la definición de patrón complejo de {0}. No se admite la conversión de esto a una definición de función.
method.is.overridden.in.a.composite.variable.definition=El método se ha anulado en la definición de variable compleja de {0}. No se admite la conversión de esto a una definición de función.
default.values=Valor por defecto\:
add.to.definition=Añadir a la definición
modify.method.calls=Editar llamada al método
change.signature.vararg.should.be.last.in.clause=Los parámetros Vararg deben colocarse al final en la cláusula de parámetro.
change.signature.parameters.same.name.{0}=Los parámetros tienen el mismo nombre\: {0}
change.signature.add.parameter.clause=Agregar cláusula de parámetro
change.signature.remove.parameter.clause=Eliminar cláusula de parámetro
default.value.is.missing.default.arguments=No existe un valor predeterminado. El argumento predeterminado contiene espacios en lugar del nuevo valor del parámetro.
default.value.is.missing.method.calls=No existe un valor predeterminado. La llamada al método contiene espacios en lugar de nuevos valores de parámetros.
specify.result.type=Especificar el tipo de resultado
default.ta.settings=Configuración
error.wrong.caret.position.method.name=El símbolo de intercalación debe colocarse en el nombre del método que se va a refactorizar.
change.signature.not.supported.implicit.functions=Los cambios de firma no se admiten en funciones implícitas
change.signature.not.supported.implicit.parameters=Los cambios de firma no son compatibles con funciones con parámetros implícitos
change.signature.not.supported.extractors=El extractor no admite cambios de firma
change.signature.specify.type.for.parameter=Especifica el parámetro de tipo ''{0}''
parameter.could.not.be.repeated.and.by.name=El parámetro es por nombre y no se puede repetir.
could.not.understand.type=Escriba {0} no comprendido
extract.method.title=Extracción del método
default.ta.tooltip=Configurar los ajustes de anotación de tipo
cannot.extract.used.function.definition=Refactorización no compatible\: La definición de función dentro de la selección se usa fuera del fragmento seleccionado
extract.method.cannot.find.possible.scope=Posible alcance para el método extraído no encontrado
extract.local.method={0} Extraer mi método local
extract.method.to.object.name=Extraer método en el objeto {0}
extract.method.to.class.name=Extraer método en la clase {0}
extract.method.to.trait.name=Método de extracción por atributo {0}
extract.method.to.anonymous.class=Extraer métodos en clases anónimas
try.block=Intentar bloquear
constructor=Constructor
case.clause=Cláusula de caso
if.block=Si bloque
def.name=Definitivo {0}
extract.local.method.in.else.block=Extraer métodos locales dentro del bloque else
val.name=Val {0}
var.name=Var {0}
for.statement=Para la sintaxis
while.statement=Mientras declaración
do.statement=Hacer declaración
function.expression=Expresión de función
code.block=Bloque de código
extract.file.method=Método de extracción de archivo
unknown.extraction=Extracto desconocido
choose.level.for.extract.method=Seleccione el nivel del método de extracción
process.duplicates=Procesamiento duplicado
choose.class=Seleccionar clase
cannot.find.package.with.name=No se puede encontrar el paquete con nombre\: {0}
cannot.find.directory.for.package=No se pudo encontrar el siguiente directorio de paquetes\: {0}
class.already.exists.in.package=Ya existe una clase con nombre {0} en el paquete {1}
extract.trait.action.text=Extracción de características...
extract.trait.action.description=Extraer características de clases seleccionadas
extract.trait.title=Extracción de características
extract.trait.top.label.text=Extraer características de\:
extract.trait.name=Nombre del Atributo\:
extract.trait.package.label=Paquete para nueva característica\:
members.to.extract=Miembro para extraer
extract.abstracts=Extracción de elementos abstractos
private.member.cannot.be.used.in.extracted.member=El miembro privado {0} no se puede utilizar en el miembro extraído {1}
member.of.anonymous.class.cannot.be.used.in.extracted.member=El miembro {0} de la clase anónima no se puede utilizar en el miembro extraído {1}
super.reference.used.in.extracted.member=El miembro extraído {0} contiene una referencia de clase principal, pero el atributo extraído no contiene una clase base.
type.parameters.for.self.type.not.supported=La característica extraída contiene {0} como su propio tipo, pero no se admite la identificación del parámetro de tipo.
cannot.inline.different.files=El afiliado se declara en otro expediente. No se admite la inserción en línea.
cannot.inline.used.outside.class=El miembro se utiliza fuera de su clase. No se admite la inserción en línea.
cannot.inline.stable.reference=El valor se utiliza en una referencia estable y no se puede insertar
cannot.inline.never.used=La variable nunca se utiliza.
cannot.inline.not.simple.pattern=La inserción en línea solo se admite para definiciones de patrones simples
cannot.inline.recursive.function=La inserción en línea no es compatible con funciones recursivas
cannot.inline.function.implicit.parameters=La inserción en línea no es compatible con funciones con parámetros implícitos
cannot.inline.function.multiple.clauses=La inserción no es compatible con funciones con cláusulas de múltiples parámetros
cannot.inline.function.varargs=La inserción en línea no es compatible con funciones con parámetros vararg
cannot.inline.implicit.element=La inserción en línea no es compatible con elementos implícitos
cannot.inline.special.function=La inserción en línea no es compatible con funciones especiales
cannot.inline.generic.function=La inserción en línea no es compatible con funciones genéricas
cannot.inline.notsimple.typealias=La inserción en línea solo se admite para alias de tipo simple
cannot.inline.value.functional.type=No se admite la inserción de valores con tipos de funciones
cannot.inline.function.functional.parameters=No se admiten funciones en línea con parámetros de función
cannot.inline.parameter=La inserción en línea no es compatible con los parámetros
cannot.inline.not.method.call=La inserción en línea es compatible con llamadas a métodos regulares.
introduce.field.title=Extracción de campo
field.occurrences={0} Dónde se utiliza
cannot.refactor.not.expression=La cadena seleccionada no se puede extraer mediante expresión
cannot.create.field.from.this.expression=No se pueden crear campos a partir de esta expresión.
cannot.find.place.for.the.new.field=Nueva ubicación de campo no encontrada
choose.class.for.introduce.field=Seleccionar clase para insertar campos
parameter.label.name=Nombre\:
parameter.label.type=Categoría\:
parameter.label.default.value=Valor por defecto\:
replace.all.occurrences=Reemplazar todos los usos
cannot.refactor.no.function=Función no encontrada para insertar parámetros
introduce.parameter.title=Insertar parámetro
refactoring.is.not.supported.contains.return=Refactorización no compatible\: la selección contiene una declaración de devolución
choose.function.for.refactoring=Seleccionar función para {0}
introduce.variable.title=Insertar valores/variables
cannot.refactor.not.valid.type=Se debe seleccionar el elemento tipo
cannot.refactor.scope.not.found=No se encontró ninguna clase o paquete adecuado
choose.scope.for=Seleccionar rango {0}
introduce.type.alias.title=Insertar alias de tipo
command.introduce.type.alias=Insertar alias de tipo
press.hotkey.to.show.more.options=Presione ctrl + alt + v para mostrar un cuadro de diálogo con más opciones
introduce.variable.declare.as.var=&Variable
introduce.variable.specify.type.explicitly=Tipo de designación
introduce.variable.identifier.is.not.valid=El identificador no es válido
replace.all.x.occurrences=Reemplazar todos los {0} usos
1.occurrence=(1 coincidencia)
multi.occurrences=({0} líneas coincidentes)
replace.occurrences.available.from.companion.class=Cambiar uso en clase complementaria {0}
cannot.refactor.not.expression.nor.type=Se debe seleccionar una expresión o elemento de tipo.
press.escape.to.remove.the.highlighting=Presione esc para eliminar el resaltado
pull.up.members.from=Mover al siguiente miembro hacia arriba
class.to.pull.up.members.to.class=Clase para elevar el miembro a {0}
move.to.inner.is.not.supported.title=La refactorización no es compatible
move.to.inner.is.not.supported=Scala no admite el movimiento de clases hacia adentro
move.with.companion=Ir con un acompañante
target.0.already.contains.definition.of.1=<b>{0}</b> ya contiene la definición de miembro <b>{1}</b>
move.members.source.title=Mover miembro del objeto\:
move.members.target.title=Al objeto\:
move.members.object.name.or.qualified.name.expected=Esperando el nombre o el nombre completo de un objeto Scala
move.members.cannot.find.object=No se encontró ningún objeto con ese nombre.
move.members=Mover miembros
move.members.supported.only.stable.objects=Los movimientos de refactorización solo se admiten para miembros de objetos estables
move.members.not.supported.implicits=Los movimientos de refactorización no son compatibles con definiciones implícitas
move.members.not.supported.overridden=Los movimientos de refactorización no son compatibles con definiciones anuladas
rename.companion.module=Cambiar el nombre del compañero {0}
rename.getters.and.setters.title=La función contiene un captador o definidor con el mismo nombre. ¿Le gustaría cambiar los nombres de estos también?
rename.all.base.members=Cambiar todos los nombres de miembros predeterminados
rename.base.member=Cambiar el nombre de miembro predeterminado
rename.only.current.member=Cambiar solo el nombre del miembro actual
rename.has.multiple.base.members={0} contiene varios miembros predeterminados
rename.only.in=Cambiar nombre solo dentro de {0} {1}
name.implements.member.of.qualname={0} implementa los miembros de {1}
name.overrides.member.of.qualname={0} redefine un miembro de {1}
rename.special.method.title=No puedes cambiar el nombre de este método.
rename.special.method.rename.class=Cambiar el nombre de {0}
rename.cancel=Cancelar
rename.aliased.title=No se admite el cambio de nombre de los alias de importación
rename.aliased.rename.actual=Cambiar el nombre del elemento real
rename=Cambiar nombre
could.not.perform.inplace.rename=No se puede realizar el cambio de nombre in situ\:\nNo se ha especificado ningún nombre
presentable.type.unnamed=Tipo sin nombre
only.for.scala=Esto sólo funciona para archivos Scala
cannot.refactor.constr.expression=El bloque seleccionado no debe aparecer como expresión de constructor.
cannot.refactor.under.generic.call=La refactorización no es compatible con llamadas genéricas
cannot.refactor.arg.in.self.invocation.of.constructor=No se admite la refactorización de argumentos de autoinvocación en el cuerpo del constructor
cannot.refactor.named.arg=La refactorización no es compatible con argumentos con nombre
cannot.refactor.literal.pattern=La refactorización no es compatible con argumentos con nombre
cannot.refactor.class.parameter.top.level=La refactorización no es compatible con parámetros en clases de nivel superior
cannot.refactor.interpolated.string.prefix=La refactorización no es compatible con prefijos de cadenas interpoladas
cannot.refactor.self.invocation=La refactorización no es compatible con llamadas al constructor en constructores secundarios
refactoring.is.not.supported.in.guard=La refactorización en guardias no es compatible y tiene el potencial de destruir la estructura del código.
file.is.not.writable=El archivo no se puede escribir
cannot.extract.empty.message=Selección incorrecta del área de refactorización. Se requieren varias expresiones o declaraciones completas.
cannot.extract.self.invocation=No se puede extraer la autoinvocación.
cannot.extract.used.type.definition=Refactorización no compatible\: la definición de tipo dentro de la selección se usa fuera del fragmento seleccionado
choose.expression.for=Seleccione expresión para {0}
choose.type.element.for=Seleccione el tipo de elemento para {0}
introduced.typeAlias.will.conflict.with.type.name=El alias de tipo que insertó entra en conflicto con el nombre de tipo\: {0}
introduced.typeAlias.will.conflict.with.class.name=El alias de tipo que insertó entra en conflicto con el nombre de clase\: {0}
introduced.variable.will.conflict.with.local=La variable insertada entra en conflicto con una variable local (o está oculta por una variable local)\: {0}
introduced.variable.will.conflict.with.parameter=La variable insertada entra en conflicto con el parámetro (o está oculta por el parámetro)\: {0}
introduced.variable.will.conflict.with.field=La variable insertada entra en conflicto con (o está oculta por) un campo o método sin parámetros\: {0}
introduced.variable.will.conflict.with.class.parameter=La variable insertada entra en conflicto con (o está oculta por) un parámetro de clase\: {0}
generate.scaladoc=Crear un Scaladoc
generate.scaladoc.action.text=Crear un Scaladoc
generate.scaladoc.action.description=Crear un Scaladoc
scaladoc.noon=Scaladoc
output.dir=Directorio de salida
documentation.for.project={0} documento
scaladoc.parsing.open.syntax.element=Elemento de sintaxis abierta
scaladoc.parsing.closing.link.tag.before.opening=Cerrar etiqueta de enlace antes de abrir
scaladoc.parsing.closing.code.tag.before.opening=Cerrar etiqueta de código antes de abrir
scaladoc.parsing.error.bad.token=Error\: Token no válido\: {0}
scaladoc.parsing.header.closed.by.opening.new.one=Encabezado cerrado al abrir un nuevo elemento
scaladoc.parsing.wiki.syntax.element.closed.by.message=Elemento de sintaxis wiki cerrado por {0}
scaladoc.parsing.wiki.syntax.closed.by.new.paragraph=Nuevo párrafo
scaladoc.parsing.wiki.syntax.closed.by.tag=Etiqueta
scaladoc.parsing.wiki.syntax.closed.by.inner.code.tag=Etiqueta de código interno
scaladoc.parsing.cross.tags=Etiqueta cruzada
scaladoc.parsing.no.closing.element=Sin elementos de cierre
scaladoc.parsing.unclosed.code.tag=Etiqueta de código abierto
scaladoc.parsing.unexpected.end.of.tag.body=Final del cuerpo de la etiqueta inesperado
scaladoc.parsing.inline.tag=Etiquetas en línea
scaladoc.parsing.missing.tag.param=Parámetro de etiqueta faltante
scaladoc.parsing.unknown.tag=Etiqueta desconocida\: {0}
type.unnamed=Tipo sin nombre
bold.surrounder.template.description=Atrevido\: '''' ''''
italic.surrounder.template.description=Cursiva\: '' ''
monospace.surrounder.template.description=Ancho fijo\: ` `
subscript.surrounder.template.description=Subíndice\: ,, ,,
superscript.surrounder.template.description=Superíndice \: ^ ^
underline.surrounder.template.description=Subrayado\: __ __
desugar.scala.code.in.scope=Desazucarando el código Scala ({0})
scope.selection=Opcional
scope.file=Archivo
desugar.scala.code.action.text=Desazucarando el código Scala...
desugar.scala.code.action.description=Desazucarar el código Scala (área seleccionada/archivo completo)
column.enabled=Usar
column.transformation=Conversión
desugar.group.method.invocations=Llamada al método
desugar.expand.apply.call=Ampliando la convocatoria "aplicar"
desugar.expand.update.call=Ampliando la llamada de "actualización"
desugar.expand.unary.call=Extensión de llamada unaria
desugar.expand.property.setter.call=Ampliar las llamadas al establecimiento de propiedades
desugar.expand.assignment.call=Extensión de llamada de asignación
desugar.expand.dynamic.call=Expansión dinámica de llamadas
desugar.canonize.infix.call=Normalizar llamadas infijas
desugar.canonize.postfix.call=Normalización de llamadas por sufijo
desugar.canonize.arity.0.call=Normalización de llamadas arity-0
desugar.canonize.block.argument=Normalizar argumentos de bloque vacío
desugar.expand.auto.tupling=Extensiones de tupla automática
desugar.expand.vararg.argument=Expansión del argumento vararg
desugar.inscribe.default.arguments=Insertar argumentos predeterminados
desugar.expand.to.equals.call=Expande "\=\=" para llamar "igual"
desugar.group.type.annotations=Tipo de anotación
desugar.value.definition=Definición de valor
desugar.variable.definition=Definición de variable
desugar.method.definition=Definición del método
desugar.function.parameter=Parámetros de función
desugar.underscore.parameter=Parámetro subrayado
desugar.reference.pattern=Patrón de referencia
desugar.type.parameters=Tipo de parámetro
desugar.group.types=Categoría
desugar.expand.function.type=Extensión del tipo de función
desugar.expand.tuple.type=Extensión de tipo tupla
desugar.expand.type.alias=Expansión de alias de tipo
desugar.expand.context.bound=Extensión vinculada al contexto
desugar.expand.view.bound=Ampliar los límites de la vista
desugar.substitute.anyref=Alternativa a AnyRef
desugar.group.implicits=Implícito
desugar.expand.implicit.conversion=Extensión de conversión implícita
desugar.inscribe.implicit.parameters=Insertar parámetros implícitos
desugar.group.functions=Función
desugar.expand.placeholder.syntax=Expansión de sintaxis de marcador de posición
desugar.expand.eta.expansion=Extensión de extensión eta
desugar.make.eta.expansion.explicit=Establecer explícitamente la extensión eta
desugar.expand.single.abstract.methods=Ampliando un único método abstracto
desugar.expand.function.instantiation=Extensión de creación de instancias de funciones
desugar.group.expressions=Expresión
desugar.expand.for.comprehensions=Para expansión anidada
desugar.expand.string.interpolation=Extensión de interpolación de cadenas
desugar.expand.tuple.instantiation=Extensión de creación de instancias de tupla
desugar.group.declarations=Declaración
desugar.expand.procedure.syntax=Extensiones de sintaxis procesal
desugar.make.method.return.expressions.explicit=Establecer explícitamente expresiones de retorno de métodos
desugar.add.explicit.override.modifier=Agregar un controlador de "anulación" explícito
desugar.replace.underscore.section.with.default.value=Reemplace las secciones subrayadas con valores predeterminados
desugar.expand.property.declaration=Ampliación de declaración de propiedad
desugar.expand.property.definition=Ampliar definiciones de propiedades
desugar.convert.implicit.class.to.class.and.function=Convertir clases implícitas en clases y funciones.
desugar.group.references=Referencia
desugar.expand.wildcard.import=Expansión de declaración de importación comodín
desugar.fully.qualify.import.expression=Normalizar completamente las expresiones de importación
desugar.partially.qualify.simple.reference=Normalizar parcialmente referencias simples.
desugar.fully.qualify.reference=Normalizar completamente las referencias
desugar.group.general=Común
desugar.append.semicolon=Agregar punto y coma
desugar.inscribe.explicit.braces=Insertar llaves explícitas
desugar.enforce.parentheses.in.constructor.invocation=Forzar paréntesis al llamar al constructor
desugar.convert.parentheses.to.braces.in.for.comprehensions=Convertir paréntesis en llaves para anidar
desugar.expand.macro=Macroexpansión
specify.return.type.explicitly=Especificar tipo (&T)
add.override.modifier=Insertar &O “anular”
copy.scaladoc=Copiar y ScalaDoc
select.method.override=Seleccionar miembro para anular
select.method.implement=Seleccionar miembros para implementar
action.implement.method=Implementación del método
action.override.method=Anulación de método
compile.order.mixed=Mezcla
compile.order.java.then.scala=Java y luego Scala
compile.order.scala.then.java=Scala y luego Java
debug.info.level.none=Ninguno
debug.info.level.source=Propiedades del archivo fuente
debug.info.level.source.and.line.number=Información de fuente y número de línea
debug.info.level.source.line.number.and.local.variable=Fuente, número de línea e información de variable local
debug.info.level.complete.no.tail.call.optimization=Optimización completa y sin colas
library.type.scala.sdk=Scala SDK
title.fetching.available.this.versions=Recuperando la versión disponible {0}
scala.facets.will.be.converted.to.scala.sdks=Las facetas de Scala se convierten a Scala SDK
scala.project.data.service.scalaLibraryNotFound=No se puede configurar el SDK de Scala para el módulo ''{0}'' (no se encontró la biblioteca de Scala del proyecto {1} para el módulo ''{0}'')
setup.kittitle={0} configuración
project.jdk.is.not.defined=El proyecto JDK no está definido.
kit.title.jdk=JDK
sdk.title=Scala SDK
no.kittitle.in.module={0} no existe en el módulo
module.libraries.attach.sources.immediately.button=Conexión de origen...
multiple.libraries.contain.file=Varias bibliotecas contienen los archivos.<br>Seleccione la biblioteca a la que desea vincular su fuente.
library.sources.not.found=Fuente no encontrada
library.sources.not.attached=Fuente no encontrada
cannot.find.library.for=Biblioteca no encontrada para {0}
cannot.find.library.error.title=Error
sdk.scan.title=Encontrar la ubicación del SDK de Scala\: {0}
brew.packages=Paquete de cerveza
coursier.v1.cache=Caché de Courier v1
ivy2.cache=Hiedra oculta2
maven.local.repo=Repositorio local de Maven
local.project.libraries=Biblioteca de proyectos locales
sdkman=SDKMAN\!
system.wide.scala=Scala en todo el sistema
unresolved.artifact=Artefactos no resueltos: {0}
ambiguous.artifact.resolved=Artefacto oscuro resuelto: {0}
unknown.resolve.issues=Problema desconocido resuelto: {0}
unknown.exception=Excepción desconocida: {0}
scala.compiler=Compilador escala
incrementality.type=Elemento incremental (&I)\:
scala.compiler.profiles.panel.profile.name=Nombre de perfil
scala.compiler.profiles.panel.move.to=Ir al siguiente
scala.compiler.profiles.panel.create.new.profile=Crear un nuevo perfil
scala.compiler.profiles.panel.profile.should.not.be.empty=El nombre del perfil no puede estar en blanco
scala.compiler.profiles.panel.profile.already.exists=El perfil {0} ya existe
unchecked.warnings=&Advertencia no reconocida
unchecked.warnings.tooltip=Habilitar advertencias adicionales en el código generado depende de sus suposiciones.
deprecation.warnings=&Ruta de desaprobación
deprecation.warnings.tooltip=Enviar advertencias y ubicación del uso obsoleto de API
feature.dynamics=Elementos dinámicos (&D)
feature.existential.types=Tipo de existencia (&E)
explain.type.errors=Tipo Descripción del error (&E)
explain.type.errors.tooltip=Tipo de error Descripción detallada
feature.warnings=&Alerta de función
feature.warnings.tooltip=Enviar alerta de función de idioma.
feature.higher.kinded.types=Tipo aguas arriba (&E)
feature.implicit.conversions=Conversión implícita (&I)
feature.macros=Macro
optimise.bytecode=Optimización del curso de bytes (y úselo con cuidado*)
optimise.bytecode.tooltip=Aplique optimizaciones a sus programas para producir códigos de bytes más rápidos. Pueden ocurrir varios problemas de compilación. Úselo con precaución.
feature.postfix.notation=Usando el operador de prefijo (&P)
feature.reflective.calls=Llamada reflexiva (&R)
additional.compiler.options=Opciones adicionales del compilador (&O)\:
compile.order=Orden de compilación (&O)\:
compiler.plugins=Complemento del compilador
debugging.info.level=Nivel de información de depuración (&L)\:
feature.experimental.features=Funciones experimentales (&X)
enable.continuations=&Activación continua
enable.specialization=&Activar materialización
enable.specialization.tooltip=Cumple con la anotación @specialize
enable.warnings=Activar & Advertencia
enable.warnings.tooltip=Crear alerta
features=Detalles de la función
options=Opción
idea.based.scala.project=Proyecto Scala basado en IDEA
module.with.a.scala.sdk=Módulos que contienen el SDK de Scala
package.prefix.label=Prefijo de paquete\:
package.prefix.example=Ejemplo\: ''org.ejemplo.aplicación''
package.prefix.help=Si el prefijo del paquete es <code>org.example.application</code>, <code>PATH</code> en el directorio fuente significa <code>org/example/application/PATH</code>, por lo que un explícito No es necesario crear los subdirectorios <code>org</code>, <code>example</code> y <code>application</code>.
title.download=Descargar
title.error.downloading.scala.libraries=Error de carga redonda de la biblioteca Scala
no.versions.available.for.download=Sin versión descargable
downloading.scala.version=Descargando Scala {0}
error.downloading.scala.version=Error al descargar Scala {0}
invalid.scala.version.format=Formato de versión de Scala no válido: {0}
sdk.create.select.files=Seleccione un JAR para el nuevo SDK de Scala
scala.sdk.selection.button.download=Descargar...
scala.sdk.selection.button.browse=Examinar...
scala.sdk.component.name.compiler.classpath=Ruta de clase del compilador
scala.sdk.component.name.library=Biblioteca
scala.sdk.component.name.library.source=Fuente de la biblioteca
scala.sdk.component.name.library.scaladoc=Biblioteca escaladoc
scala.sdk.descriptor.contains.duplicated.files=El descriptor del SDK de Scala contiene archivos {0} duplicados:
sdk.table.model.location=Ubicación
sdk.table.model.version=Versión
sdk.table.model.sources=salsa
sdk.table.model.docs=Documento
title.scala.sdk.files=Archivo SDK de Scala
choose.either.a.scala.sdk.directory.or.scala.jar.files=Seleccione el directorio Scala SDK o el archivo jar de Scala (permitir\: binarios, fuente, documentación)
no.program.arguments=Sin argumentos de programa
main.method.parameters.table.column.title.name=Nombre
main.method.parameters.table.column.title.type=Categoría
main.method.parameters.table.column.title.value=Valor
provide.program.arguments=Proporcionar argumentos del programa
insert.pair.multiline.quotes=Insertar comillas dobles en varias cadenas
wrap.single.expression.body=Envuelva el cuerpo de una sola expresión con una llave de cierre después de escribir ''{''
upgrade.to.interpolated=Actualice una cadena simple a una cadena interpolada después de escribir ''${''
insert.block.braces.automatically.based.on.indentation=Agregar llaves automáticamente
remove.block.braces.automatically.based.on.indentation=Quitar brackets automáticamente
control.curly.braces.based.on.line.indents=Controlar las llaves según la sangría de línea\:
scala.project.settings=Configurar un proyecto Scala
scala.project.settings.form.tabs.editor=Editor
scala.project.settings.form.tabs.project.view=Vista del proyecto
scala.project.settings.form.tabs.performance=Actuación
scala.project.settings.form.tabs.worksheet=Hoja de cálculo
scala.project.settings.form.tabs.base.packages=Paquete básico
scala.project.settings.form.base.package.inherit=Heredar del prefijo del paquete en la carpeta fuente
scala.project.settings.form.base.package.custom=Usar personalizado\:
scala.project.settings.form.tabs.misc=Otros
scala.project.settings.form.tabs.updates=Actualizar
scala.project.settings.form.tabs.extensions=Expansión
scala.project.settings.form.collection.type.highlighting.option=Resaltar tipo de colección\:
scala.project.settings.form.sbt.index.ivy2.mode=Modo de indexación de caché local ivy2
scala.project.settings.form.sbt.index.ivy2.mode.hint=Deshabilitado: no se completó la indexación\nscala.meta hilo del programa
scala.project.settings.form.scala.meta.settings.annot212.tooltip=Debido a la compatibilidad binaria, las anotaciones en el módulo 2.12 deben utilizar serialización y análisis basados en cadenas, lo cual es muy lento. Esto puede afectar seriamente el rendimiento general.
scala.project.settings.form.scala.meta.settings.modeOptions.tooltip=Habilitado: el metaprograma se ejecuta durante la inferencia de tipos. El cuerpo del método Trim se extiende mediante scala.meta.
scala.project.settings.form.scala.meta.settings.trimBodies.tooltip=Depende del tipo de retorno explícito del método generado (el cuerpo se reemplaza por ???). Acelere la inferencia de tipos omitiendo el método de verificación del tipo de cuerpo.
scala.project.settings.form.show.type.info.on.mouse.hover=Mostrar información de tipo después de cierto período de tiempo al pasar el mouse, ms
scala.project.settings.form.error.highlighting=Error al resaltar:
scala.project.settings.form.highlighting=Destacar
scala.project.settings.form.highlight.implicit.conversions=Resaltado de conversión implícita
scala.project.settings.form.show.hints.if.no.implicit.arguments.found=Mostrar sugerencia si no se encuentra el argumento implícito
scala.project.settings.form.show.hints.if.ambiguous.implicit.arguments.found=Mostrar sugerencias cuando se encuentran argumentos implícitos ambiguos
scala.project.settings.form.highlight.arguments.to.by.name.parameters=Resaltado de argumentos de parámetros por nombre
scala.project.settings.form.include.block.expressions=Contiene expresiones de bloque
scala.project.settings.form.include.literals=Contiene literales
scala.project.settings.form.custom.scalatest.keywords.highlighting=Resalte las palabras clave personalizadas de scalaTest
scala.project.settings.form.autocomplete=Autocompletar
scala.project.settings.form.ahead.of.time.completion=Finalización del código AOT (nombrar parámetros y variables)
scala.project.settings.form.use.scala.classes.priority.over.java=Prefiere las clases de Scala a las clases de Java
scala.project.settings.form.code.conversion=Conversión de código
scala.project.settings.form.convert.java.code.to.scala.on.copy.paste=Convierta el código Java a Scala al copiar y pegar
scala.project.settings.form.automatically.convert.to.scala.code.without.dialog=No mostrar el cuadro de diálogo al pegar, convertir automáticamente a código Scala
scala.project.settings.form.add.override.keyword.to.method.implementation=Agregar palabra clave de anulación a la implementación del método
scala.project.settings.form.group.package.object.with.package=Agrupar y agrupar objetos de paquete con paquetes.
scala.project.settings.form.highlight.nodes.with.errors=Resaltar nodos con errores
scala.project.settings.form.implicit.parameters.search.depth=Profundidad de búsqueda de parámetros implícitos (-1 si no hay ninguno)\:
scala.project.settings.form.search.all.symbols=Buscar todos los símbolos (incluidos los símbolos locales)
scala.project.settings.form.disable.parsing.of.documentation.comments=Deshabilita el análisis de comentarios de documentos. Esto puede mejorar el rendimiento del editor para archivos muy grandes. (SCL-2900)
scala.project.settings.form.disable.language.injection.in.scala.files=Deshabilite la inserción de idiomas dentro de los archivos Scala (los idiomas integrados pueden dejar de escribirse con la finalización automática del código emergente)
scala.project.settings.form.dont.cache.compound.types=No almacene en caché tipos complejos (úselo si experimenta bloqueos graves en GC)
scala.project.settings.form.treat.sc.files.as=Procesar el archivo .sc con\:
scala.project.settings.form.output.cutoff.limit=Límite de corte de salida\:
scala.project.settings.form.output.cutoff.limit.units=Línea
scala.project.settings.form.delay.before.auto.run=Retraso antes de la ejecución automática\:
scala.project.settings.form.delay.before.auto.run.units=Milisegundos
scala.project.settings.form.run.worksheet.in.the.compiler.process=Ejecutar una hoja de trabajo en el proceso del compilador (solo modo normal)
scala.project.settings.form.use.eclipse.compatibility.mode=Utilice el modo "compatibilidad con eclipse"
scala.project.settings.form.treat.scala.scratch.files.as.worksheet.files=Procesar el archivo temporal de Scala como archivo de hoja de trabajo
scala.project.settings.form.collapse.long.output.by.default=Contraer salida larga de forma predeterminada
scala.project.settings.form.scalatest.default.super.class=Clase principal predeterminada de ScalaTest\:
scala.project.settings.form.trailing.commas=Coma final\:
scala.project.settings.form.plugin.update.channel=Actualización del canal\:
scala.project.settings.form.check.for.updates=Revisalo ahora
scala.project.settings.form.info=Siempre puedes volver a una versión más estable seleccionando "Versión estable" o "Programa de acceso anticipado".
scala.collection.highlighting.type.none=Ninguno
scala.collection.highlighting.type.only.non.qualified=Sólo elementos no normalizados
scala.collection.highlighting.type.all=Cada
scala.plugin.chanel.nightly=Construcción nocturna
scala.plugin.chanel.eap=Programa de acceso temprano
scala.plugin.chanel.release=Lanzamiento estable
scala.project.settings.form.tabs.base.package=Paquete básico
scala.meta.mode.enabled=Usar
scala.meta.mode.disabled=Deshabilitar
scala.meta.mode.manual=Manual
ivy2.indexing.mode.disabled=Deshabilitar
ivy2.indexing.mode.metadata=Metadatos
ivy2.indexing.mode.classes=Clase
trailing.commas.mode.enabled=Usar
trailing.commas.mode.disabled=Deshabilitar
trailing.commas.mode.auto=Automático
type.checker.built.in=Básico
type.checker.compiler=Compilador
type.checker.help=<html><strong>Comprobador de tipo integrado:</strong> proporciona más funcionalidad, comentarios más rápidos y es liviano. En código complejo, pueden ocurrir errores falsos.<br><br><strong>Compilador:</strong> Más preciso. Es más lento, consume más recursos y no admite funciones como comparación de tipos, corrección rápida, verificación, etc.<br><br>A menos que encuentre una gran cantidad de errores falsos en su base de código particular, le recomendamos usar el verificador de tipos incorporado Recomendado.</html>
script.file.mode.always.worksheet=Siempre hojas de trabajo
script.file.mode.ammonite.in.test.sources.otherwise.worksheet=Amonita en la fuente de prueba; de lo contrario, hoja de trabajo
script.file.mode.always.ammonite=Siempre amonita
invalid.update.channel=Canal de actualización no válido
changes.in.scalatest.highlighting.will.be.processed...=Los cambios realizados en el resaltado de ScalaTest se manejan correctamente solo en los archivos recién resaltados. Reinicie Intellij IDEA para optimizar su experiencia
base.package.help=<html>Si el paquete base es <code>org.example.application</code>, entonces el paquete <code>org.example.application.NAME</code> es<br><code>paquete org.example.application </code><br>Debe definirse como <code>NOMBRE del paquete</code></html>
show.affected.tests.scala=Mostrar pruebas afectadas (Scala)
no.tests.captured=No hay pruebas capturadas para {0}.
show.affected.tests.action.text=Mostrar pruebas afectadas (Scala)
show.affected.tests.action.description=Mostrar pruebas afectadas (Scala)
run.all.affected.tests.scala=Ejecute todas las pruebas afectadas (Scala)
affected.tests.title.empty.selection=Rango de selección vacío
affected.tests.title.two.tests={0} y {1}
affected.tests.title.more.than.two={0} y otros.
selected.changes=Cambios seleccionados
tests.for.title={0} prueba
open.find.usages.tool.window=Abra la ventana de la herramienta Usar buscador de ubicaciones{0}
test.run.config.multiple.suite.traits.detected=Se detectaron varias propiedades de herramienta\: {0}
test.framework.is.not.specified={0} no está especificado
test.config.choose.executable.classes.to.run.test=Seleccione la clase ejecutable para ejecutar {0}
test.run.config.module.is.not.specified=Módulo no especificado
munit.command.line.state.no.tests.found=No se encontraron pruebas
munit.config.display.name=Fortifica
munit.config.description=Configuración de la ejecución del marco de prueba MUnit
test.in.scope.scalatest.presentable.text=''{0}'' en mis ScalaTests
scalatest.config.display.name=Prueba Scala
scalatest.config.description=Configurar la ejecución del marco de pruebas ScalaTest
test.in.scope.specs2.presentable.text=''{0}'' Mis especificaciones2
specs2.config.display.name=Especificaciones2
specs2.config.description=Configuración de ejecución del marco de prueba Specs2
test.node.provider.show.scala.tests=Pantalla de prueba Scala
test.run.config.test.package.not.found=Paquete de prueba no encontrado. {0}
test.config.package.does.not.exist=El paquete no existe
test.config.can.nott.run.while.indexing.no.class.names.memorized.from.previous.iterations=No se puede ejecutar durante la indexación\: no se recuerda ningún nombre de clase de la iteración anterior
test.config.did.not.find.suite.classes.in.package=Clase de suite no encontrada en el paquete {0}
test.run.config.test.class.not.found=Clase de prueba no encontrada\: {0}
test.config.test.class.is.not.specified=No se ha especificado ninguna clase de prueba
test.config.test.class.not.found.in.module=La clase de prueba ''{0}'' no se encuentra en el módulo ''{1}''
test.config.no.suite.class.is.found.for.class.in.module=No se encontró la clase de suite para la clase ''{0}'' en el módulo ''{1}''
test.config.class.is.not.inheritor.of.suite.trait=La clase ''{0}'' no es heredera del atributo Suite
test.config.clazz.is.not.a.valid.test.suite={0} no es una herramienta de prueba válida
test.config.failed.to.compile.pattern=Error al compilar el patrón {0}
test.config.no.patterns.detected=No se detectó ningún patrón
test.config.cant.run.while.indexing.no.class.names.memorized.from.previous.iterations=No se puede ejecutar durante la indexación\: no se recuerda ningún nombre de clase de la iteración anterior
test.config.test.name.is.not.specified=Nombre de la prueba no especificado
test.config.multiple.classes.specified.for.single.test.run=Varias clases especificadas para una única ejecución de prueba
test.run.config.for.class.pattern=Patrón de clase
test.run.config.test.pattern=Patrón de prueba
scalatest.gutter.run.test=Ejecutar prueba
test.run.config.test.kind=&Tipo de prueba\:
test.run.config.test.class=&Clase de prueba\:
test.run.config.test.name=Nombre de la prueba (&N)\:
test.run.config.regular.expressions=E&xpresión regular\:
test.run.config.test.package=&Paquete de prueba\:
test.run.config.search.for.tests=Búsqueda de prueba\:
test.run.config.use.sbt=Usar SBT
test.run.config.use.ui.with.sbt=Usando la interfaz de usuario con SBT
test.run.config.print.information.messages.to.console=Imprimir un mensaje informativo a la consola.
test.run.config.choose.test.class=Seleccionar clase de prueba
test.run.config.test.kind.all.in.package=Todo en paquete
test.run.config.test.kind.class=Clase
test.run.config.test.kind.test.name=Nombre de la prueba
test.run.config.test.kind.regular.expression=Expresión regular
test.run.config.search.scope.in.whole.project=En todo el proyecto
test.run.config.search.scope.in.single.module=En un solo módulo
test.run.config.search.scope.across.module.dependencies=Todas las dependencias del módulo
test.in.scope.utest.presentable.text=''{0}'' en mis pruebas UT
utest.config.display.name=prueba
utest.config.description=Configuración de ejecución del marco de prueba más reciente
default.notification.title=Advertencia
annotator.error.sunspecified.value.parameters=Parámetro de valor no especificado \: {0}
scala.plugin.update.failed=Error en la actualización del complemento Scala
switch.idea.to.eap.question=IDEA no está actualizada con la rama {0}.<br/>¿Le gustaría cambiar el canal IDEA a EAP?
switch.yes=Sí
switch.not.now=Ahora no
switch.ignore.this.update=Ignora esta actualización
not.all.type.parameters.are.defined=Sólo se definen algunos de los parámetros de tipo. typeargs\=[{0}] y classTypeParams\=[{1}]
expected.with=Con es requerido
expected.parameter.clause.for.extension.method=Se requiere una cláusula de parámetro para los métodos de extensión.
scgivenaliasimpl.returntype.not.yet.implemented=ScGivenAliasImpl.returnType\: Aún no implementado
expected.indented.package.statement=Requiere una declaración de paquete con sangría
expected.indented.template.body=Requiere cuerpo de plantilla con sangría
type.declaration.expected=Expectativas de declaración de tipo
advanced.settings=Ajustes avanzados
match.type.expected=Expectativa del tipo de coincidencia
scala.3.disclaimer=Descargo de responsabilidad de Scala 3
conversion.is.not.available.in.it.s.own.definition=La transformación no se puede utilizar dentro de una definición de transformación.
element.has.incompatible.type.parameter.bounds.for.type={0} contiene límites de parámetros de tipo incompatibles en {1}
type.does.not.conform.to.type={0} no se ajusta a {1}
import.implicitInstance.chooser.title=Seleccionar instancias implícitas para importar
family.name.search.implicit.instances=Búsqueda de instancias implícitas
search.implicit.instances.for=Búsqueda de instancia implícita para {0}
choose.type.to.search=Seleccione el tipo que desea buscar
applicable.implicits.not.found=No se encontraron elementos implícitos aplicables
test.run.config.choose.working.directory=Seleccionar directorio de trabajo
sdk.build.title=Creación de SDK
statement.expected=Expectativas de sintaxis de bloque
star.expected=''*'' expectativa
case.clauses.or.qualified.reference.expected=Esperando una cláusula de caso o una referencia calificada
annotation.expected=Expectativas de anotación
simple.type.expected.requires=Esperando un tipo simple en un bloque requiere
type.dcl.expected=Expectativas de declaración de tipo
block.expected=Bloquear expectativas
type.tale.expected=Se requiere escribir la palabra clave al final del tipo simple.
refined.type.expected=Expectativas de tipo mejoradas
this.expected=Espere la palabra clave ''esta''
arg.expr.expected=Esperar expresión de argumento
expr.type.does.not.conform=El tipo {0} en la expresión no se ajusta al tipo para el cual se declara el valor
patt.type.does.not.conform.expr.type=El tipo de patrón esperado {0} no se ajusta al tipo de expresión {1}
title.cache.updating=Actualizando caché
title.cache.creating=Creando caché
title.cache.files.scanning=Comprobando archivo...
title.cache.files.parsing=Analizando nuevo archivo...
title.please.wait=Espérame
title.cache.saving=Guardar caché
title.cache.datafile.loading=Cargando caché
title.cache.files.removing=Eliminando caché antiguo
title.cache.loading=Cargando caché
error.report.to.jetbrains.action=Informe a JetBrains
error.report.submit.label=<html>Este informe de error se envía al <b>componente <b>''{3}''</b><br><a href\="{1}{2}">{1}{2} </a></b><br>se crea como un nuevo problema <b>JIRA</b> <br><b>''{0}''</b><br>.<br>< br>Proporcione una breve descripción del error y cómo reproducirlo.</html>
error.report.submit.register.in.jira=<html><a href\="{0}">Registrarse para obtener una cuenta</a></html>
error.report.submit.new.issue.url=<html>Problema agregado correctamente.<br> Consulte <a href\="{0}">{0}</a></html>
error.report.submit.new.issue.title=Problema agregado
error.report.wrong.login=Usuario o contraseña invalido;
error.report.canceled=Envío de informe cancelado
error.report.error.creating.issue=Error al crear un nuevo problema de Jira
error.report.jira.issue=Problema de JetScala \#{0}
error.report.dialog.title=Envío de error
error.report.dialog.wrong.password.title=Fallo al enviar
error.report.button.sendreport.caption=&Enviar reporte
error.report.button.cancel.caption=&Cancelar
error.report.form.not.jira=Como no tengo una cuenta JIRA, estoy creando un problema en nombre de ''JetScala Error Reporter''
error.report.form.jira=Soy usuario de JIRA.
error.report.form.jira.login=&Acceso
error.report.form.jira.password=Cont&raseña
error.report.form.jira.password.save=Guardar contraseña
repetitive.method.name.signature=Nombre/firma del método recursivo
repetitive.method.name.signature.and.return.type=Nombres de métodos recursivos, firmas y tipos de retorno
illegal.combination.of.modifiers=La combinación de controladores es incorrecta
modifier.is.not.allowed.here.0=El controlador ''{0}'' no está permitido aquí
illegal.combination.of.modifiers.abstract.and.final=La combinación de controladores ''abstracto'' y ''final'' no es válida
modifier.volatile.not.allowed.here=El controlador "volátil" no está permitido aquí
modifier.transient.not.allowed.here=El controlador "transitorio" no está permitido aquí
intarface.cannot.have.modifier.final=La interfaz no puede tener controlador "final"
script.cannot.have.modifier.abstract=El script no puede tener un controlador "abstracto"
script.cannot.have.modifier.native=El método de script no puede tener un controlador "nativo"
interface.must.have.no.static.method=Las interfaces no pueden tener métodos estáticos.
not.abstract.class.cannot.have.abstract.method=Las clases no abstractas no pueden tener métodos abstractos.
illegal.combination.of.modifiers.volatile.and.final=La combinación de controladores ''abstracto'' y ''final'' no es válida
variable.cannot.be.native=La variable no puede tener modificador ''nativo''
variable.cannot.be.abstract=La variable no puede tener modificador ''abstracto''
not.abstract.class.cannot.have.method.without.body=Las clases no abstractas no pueden tener métodos sin cuerpo.
not.abstract.method.should.have.body=Los métodos abstractos no deben tener cuerpo.
cannot.create.class.error.text=No se puede crear la clase ''{0}''. {Uno}
cannot.create.class.error.title=No se puede crear la clase
no.class.in.file.template=Clase no encontrada en la plantilla de archivo.
interface.must.have.no.private.method=Las interfaces no pueden tener métodos privados.
error.external=Error externo
Inner.methods.are.not.supported=El método interno no es compatible.
final.class.cannot.be.extended=Las clases finales no se pueden ampliar.
element.is.not.accessible=El elemento {0} tiene acceso privado en esta ubicación
class.must.declared.abstract=La clase ''{0}'' debe declararse abstracta o implementar un miembro abstracto heredado
object.must.implement=El objeto ''{0}'' debe implementar un método no implementado
cannot.refactor.constructor.parameter.top.level=La refactorización no es compatible con los parámetros del constructor de clases de nivel superior
wrong.refactoring.context=La refactorización no es compatible en el contexto actual.
operation.not.supported.in.current.block=Operador no admitido en el bloque actual
class.import.title=Agregar declaración de importación de clase\:
0.is.not.a.legal.scala.identifier=''{0}'' no es un identificador válido de Scala
cannot.have.implicit.parameters.and.implicit.bounds=Un parámetro de tipo no puede contener al mismo tiempo un parámetro implícito y un contexto `\:...'' o una vista limitada `<%...''
block.must.end.result.expression=El bloque debe terminar en una expresión de resultado.
illegal.cyclic.reference=Referencia circular no válida ''{0}''
anonymous.class.must.declared.abstract=Las funciones anónimas deben implementar miembros abstractos heredados
cyclic.reference.type=Referencia circular no válida relacionada con el tipo {0}
implicit.usage.tooltip=<html><body>Conversión implícita {0}(<b>{1}</b>)\: <b>{2}</b> detectada
implicit.usage.message=Conversión implícita ''{0}({1})\: {2}'' detectada.
suspicicious.inference=El tipo de inferencia de {0} es cuestionable. Para continuar, anote explícitamente el tipo.
suspicicious.newline=No se deduce que una nueva línea antes de la lista de argumentos sea un punto y coma. Utilice ''.'' antes del nombre del método.
element.method=Método
label.method=Método {0}
method.has.supers=El método {0} anula/implementa un método predeterminado. ¿También le gustaría cambiar el nombre de este método?
remove.explicit.val=Eliminar ''val'' explícito
maven.repository.presentable.name=Repositorio maven
config.display.name=Composición
scala.facet.title=Escala(&L)
config.scala.libraries=Configurar bibliotecas Scala
scala.config.label=Directorio de instalación de Scala
scala.config.dscr=Especifique la ruta del directorio de instalación de Scala
scala.config.noscala.title=Error de configuración de Scala
scala.config.download.link=Https\://www.scala-lang.org/downloads/
scala.config.download.link.label=Puedes descargar Scala desde:
scala.config.compiler.library=Bibliotecas del compilador Scala\:
scala.config.sdk.library=Bibliotecas Scala SDK\:
scala.config.sdk.space.hint=Varias rutas deben estar separadas por un separador de archivos - '';''
scala.config.take.compiler.from.settings=&Utilizar la biblioteca del compilador Scala del jar especificado
scala.config.take.relative.path=Usar la ruta relativa a la raíz del proyecto
error.scala.path.not.valid=La ruta de Scala no es válida
scala.config.project.template.name=Lluvia
scala.config.project.template.description=Módulos para el desarrollo de aplicaciones Scala.
scala.config.project.settings.title=Configuración de escala
scala.config.module.name=Módulo escala
scala.config.module.description=Crear un módulo Scala
no.java.sdk=SDK de Java no configurado
cannot.compile.scala.files.no.facet=Asociar facetas de Scala con módulos.
cannot.compile.scala.files.no.compiler=Especifique bibliotecas del compilador dentro de las facetas de Scala.
cannot.compile.scala.files.compiler.problem=Ajuste las bibliotecas del compilador dentro de la faceta Scala\: {0}.
cannot.compile.scala.files.no.sdk=Configure el SDK Java para el módulo ''{0}''.
cannot.compile.scala.files.no.sdk.mult=Configure el SDK Java para el módulo ''{0}''.
cannot.compile=No se puede compilar el archivo Scala
debug.option=Habilitar el seguimiento de la pila de depuración
scalac.compiler.name=Scalac
javac.error.unknown.jdk.version=No se puede especificar la versión JDK {0}.\nLos módulos dependientes deben contener la misma versión de Scala SDK
scala.compiler.description=Compilador escala
jtype.is.not.found=No se puede compilar el archivo Scala.\nConfiguración del SDK de Scala
new.button.label=Nuevo
scala.sdk.configuration.label=<html><b>Scala SDK\:</b><br>Seleccione un Scala SDK específicamente para este módulo</html>
add.new.scala.lib=Nuevo SDK de Scala
invalid.scala.sdk.path.text=Ruta especificada no válida
scala.sdk.combo.box.project.item=<No Scala SDK>
no.scala.facet=Expectativas de las facetas de Scala
new.scala.facet.detected=Detección de facetas Scala
invalid.scala.sdk.path.message=Ruta del SDK de Scala no válida
facet.create.lib.title=Crear una biblioteca Scala
facet.create.project.lib=Crear biblioteca Scala a nivel de proyecto ''{0}''
facet.create.application.lib=Crear una biblioteca Scala a nivel de aplicación ''{0}''
facet.setting.exclude.compiler.from.cp=Excluir las bibliotecas del compilador Scala del alcance del módulo
facet.setting.exclude.library.from.cp=Excluir las bibliotecas Scala SDK del alcance del módulo
file.template.group.title.scala=escala
newclass.dlg.prompt=Ingrese el nuevo nombre de la clase Scala
newclass.dlg.title=Nueva clase de Scala
newclass.command.name=Crear una clase de Scala
newclass.progress.text=Creando la clase Scala ''{0}''
newworksheet.dlg.prompt=Ingrese un nuevo nombre de hoja de trabajo de Scala
newworksheet.dlg.title=Nueva hoja de trabajo de Scala
newworksheet.menu.action.text=Hoja de trabajo de escala
newworksheet.menu.action.description=Crear una nueva hoja de trabajo de Scala
newworksheet.command.name=Crear una hoja de trabajo de Scala
newworksheet.progress.text=Creando la hoja de trabajo de Scala ''{0}''
newobject.dlg.prompt=Ingrese un nuevo nombre de objeto Scala
newobject.dlg.title=Nuevo objeto Scala
newobject.menu.action.text=Objeto escala
newobject.menu.action.description=Crea un nuevo objeto Scala
newobject.command.name=Crear objeto Scala
newobject.progress.text=Creando el objeto Scala ''{0}''
newtrait.dlg.prompt=Ingrese un nuevo nombre de propiedad de Scala
newtrait.dlg.title=Nuevas propiedades de Scala
newtrait.menu.action.text=Características de escala
newtrait.menu.action.description=Crear una nueva propiedad de Scala
newtrait.command.name=Crear propiedades de Scala
newtrait.progress.text=Creando la función Scala ''{0}''
scala.compiler.option.additional.command.line.parameters=Parámetros de línea de comando adicionales del compilador Scala
psi.decompiled.text.header=// Descompilador de API IntelliJ para lenguaje Scala\nTamaño máximo de almacenamiento dinámico (Mb)\:
scala.compiler.cmd.line.params=Parámetros de línea de comando
scala.compiler.use.deprecation=@compilación de anotaciones obsoletas
scala.compiler.scalac.first=Compile el archivo Scala primero
scala.compiler.show.unchecked=Compile y utilice la anotación @unchecked
scala.compiler.generate.no.warnings=&No generar advertencia
scala.compiler.optimize=Optimización del curso de bytes
scala.compiler.no.generics=Supresión de firma genérica de Scala
no.right.operand.found=No se encontró el operador correcto
cannot.resolve.infix.operator=El operador infijo no se puede resolver.
circular.dependency.detected=Se detectó dependencia circular del tipo alias ''{0}''
no.result.expression.found=Expresión de resultado no encontrada
unreachable.expression=Declaración inalcanzable
choose.inferred.or.super.type.popup.title=Seleccione tipo
test.in.scope.specs.presentable.text=''{0}'' Mis especificaciones
equals.between.inconvertible.types.display.name=Probar la igualdad entre objetos de tipos no convertibles.
equals.between.inconvertible.types.description=Debido a que el tipo estático del operando no es convertible, detecta pruebas de igualdad que siempre devuelven falso.
equals.between.inconvertible.types.problem.descriptor=Prueba de igualdad entre tipos no convertibles ''{0}'' y ''{1}'' \#loc
find.usages.implementing.type.definition=Definición del tipo de implementación
find.usages.companin.module=Dónde utilizar los módulos complementarios
find.usages.instances.title=Crear instancia
introduce.typealias.search.companion=Cambio de acompañante
introduce.typealias.search.inheritors=Cambio de heredero
introduce.field.choose.class=Seleccionar clase para insertar campos
extract.trait.name.not.specified=Nombre del atributo no especificado
change.signature.not.supported.multiple.parameter.clauses=Los cambios de firma no son compatibles con funciones con cláusulas de múltiples parámetros
change.signature.not.supported.constructors=Los constructores no admiten cambios de firma en Scala
parameter.not.from.function=Evaluado en parámetros en lugar de en la definición de función o expresión de función
local.variable.from.anonymous.class=No se puede cargar la variable local {0} en una clase anónima
invalid.expression.in.parentheses=Expresión no válida entre paréntesis\: {0}
formatted.interpolator.not.supported=El interpolador de cadenas formateadas f"..." no es compatible con Scala 2.11
configure.type.aware.highlighting=Configurar el resaltado de reconocimiento de tipo de proyecto
vm.options=Opciones de máquina virtual\:
console.arguments=Argumentos de consola\:
working.directory=Directorio de trabajo\:
use.classpath.and.sdk.of.module=Uso de Classpath y SDK para módulos
test.run.config.sbt.runner.form.environment.variables=Variables ambientales (&E)
scala.project.settings.form.compiler.highlighting=Utilice el compilador para resaltar errores
