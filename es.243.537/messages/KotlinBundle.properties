0.1.be.lifted.out.of.2=''Se puede extraer ''{0}'' de ''{1}''
0.1.could.be.private={0} ''{1}'' podría ser privado
0.1.is.never.used={0} ''{1}'' nunca se utiliza
0.already.exists={0} ya existe
0.always.returns.non.null.type=''{0}'' siempre devuelve tipo distinto de nulo
0.call.could.be.simplified.to.1={0} llamada podría simplificarse a {1}
0.call.should.be.replaced.with.array.literal=''{0}'' llamada debe ser reemplazada con literal de array [...]
0.from.1={0} de {1}
0.has.detected.1.code.fragments.in.2.that.can.be.replaced.with.3={0} ha detectado {1} fragmento(s) de código en {2} que pueden reemplazarse por {3}. ¿Quieres revisar y sustituir {1,choice,1#el fragmento|2#los fragmentos}?
0.has.empty.body=''{0}'' tiene cuerpo vacío
0.in.1.will.require.class.instance=''{0}'' in {1} will require class instance=''{0}'' en {1} requerirá instancia de clase
0.interface.1=La interfaz {0} implementa ''{1}''
0.is.always.non.null.type=''{0}'' es siempre tipo no nulo
0.is.expected.to.be.used.since.kotlin.1.3=Se espera que se use ''{0}'' desde Kotlin 1.3
0.is.missing.documentation={0} no tiene documentación
0.is.overridden.by.declaration.s.in.a.subclass={0} is overridden by declaration(s) in a subclass=0 es anulado por declaración(es) en una subclase
0.may.break.code={0} (puede romper código)
0.on.a.readonly.1.creates.a.new.1.under.the.hood=0.en.un.1.de.solo.lectura.crea.un.nuevo.1.por.debajo
0.references.type.parameters.of.the.containing.class={0} referencias parámetros tipo de la clase contenedora
0.should.return.unit={0} debe retornar Unit
0.try.1.with.2.fails.and.3.verifications={0} [Intento {1} con {2} fallos y {3} verificaciones]
0.will.become.invisible.after.extraction={0} quedará invisible después de la extracción
0.will.no.longer.be.accessible.after.extraction={0} ya no será accesible después de la extracción
a.constructor.call.is.not.yet.supported=La llamada al constructor todavía no está soportada
a.field.without.an.initializer.is.not.yet.supported=Aún no se admiten campos sin inicializador
accessing.non.final.property.0.in.constructor=Accediendo a la propiedad no final {0} en el constructor
action.CacheResetOnProcessCanceledToggleAction.text=Restablecer Cachés en ProcessCanceledException
action.CheckComponentsUsageSearchAction.text=Comprobar componentes del uso de función de búsqueda
action.ConfigureKotlinInProject.text=Configurar Kotlin en Proyecto
action.ConvertJavaToKotlin.text=Convertir archivo Java a archivo Kotlin
action.CopyAsDiagnosticTest.text=Copiar archivo actual como prueba de diagnóstico
action.CopyKotlinProjectInformation.text=Copiar la descripción del proyecto Kotlin al portapapeles
action.DecompileKotlinToJava.text=Descompilar Kotlin a Java
action.DumbModeTremble.text=Modo mudo de temblor
action.ExtractFunction.text=Función...(_F)
action.ExtractFunctionToScope.text=Función a Alcance...(_S)
action.FindImplicitNothingAction.text=Encontrar llamadas implícitas de Nothing
action.GotoSuperClass.MainMenu.text=Ir _a superclase(_U)
action.GotoSuperClass.text=Ir a la Superclase(_U)
action.GotoSuperInterface.MainMenu.text=Interfaz super(_U)
action.GotoSuperInterface.text=Ir a Superinterfaz(_U)
action.GotoSuperProperty.MainMenu.text=PropiedadSuper(_U)
action.GotoSuperProperty.description=Navegar hasta la declaración de una propiedad que reescribe o implementa la propiedad actual
action.GotoSuperProperty.text=Ir a la Super Propiedad(_U)
action.HighlightingBenchmarkAction.text=Indicador de referencia de resaltado
action.InspectBreakpointApplicability.text=Inspeccionar aplicabilidad del punto de interrupción
action.IntroduceProperty.text=Propiedad...(_R)
action.IntroduceTypeAlias.text=Alias de tipo...(_A)
action.IntroduceTypeParameter.text=Parámetro de tipo...(_Y)
action.Kotlin.ClearScratch.description=Borrar scratch de Kotlin
action.Kotlin.ClearScratch.text=Limpiar Kotlin Scratch
action.Kotlin.Gradle.ShowDslLogs.text=Mostrar registros DSL Kotlin Gradle
action.Kotlin.NewFile.description=Crea una nueva clase o archivo Kotlin
action.Kotlin.NewFile.text=Archivo/Clase Kotlin
action.Kotlin.NewScript.description=Crea un nuevo script o una nueva hoja de trabajo Kotlin
action.Kotlin.NewScript.text=Script de Kotlin
action.Kotlin.RunScratch.description=Ejecutar el scratch de Kotlin
action.Kotlin.RunScratch.text=Ejecutar Kotlin Scratch
action.Kotlin.StopScratch.description=Detener ejecución de scratch
action.Kotlin.StopScratch.text=Detener ejecución de Scratch
action.Kotlin.XDebugger.CoroutinesDump.text=Obtener volcado de corrutinas
action.Kotlin.XDebugger.ToggleKotlinVariableView.text=Mostrar solo variables Kotlin
action.KotlinCodeMigration.text=Ejecutar migraciones de código
action.KotlinCodeMigrationToggle.text=Habilitar detección de migraciones
action.KotlinConfigurePlugin.text=Configurar plugin de Kotlin
action.KotlinConsoleREPL.text=Kotlin REPL (Experimental)
action.KotlinFormattingSettingsStatusAction.text=Info de configuración del formateador
action.KotlinGenerateDataMethod.text=Función de parámetros
action.KotlinGenerateEqualsAndHashCode.text=equals() y hashCode()
action.KotlinGenerateMavenCompileExecutionAction.text=Ejecución de compilación de Kotlin
action.KotlinGenerateMavenPluginAction.text=Complemento Kotlin
action.KotlinGenerateMavenTestCompileExecutionAction.text=Ejecución de test-compile de Kotlin
action.KotlinGenerateSecondaryConstructor.text=Constructor secundario
action.KotlinGenerateSetUpMethod.text=Función de configuración
action.KotlinGenerateTearDownMethod.text=Función TearDown
action.KotlinGenerateTestMethod.text=Probar método
action.KotlinGenerateToString.text=toString()
action.KotlinShellExecute.description=Ejecutar código Kotlin en consola
action.KotlinShellExecute.text=Ejecutar código Kotlin
action.KotlinThrowException.text=Eliminar error desde Kotlin Plugin
action.LibraryToSourceDependencySupportToggleAction.text=Alternar soporte de dependencia de biblioteca a código fuente
action.LocalCompletionBenchmarkAction.text=Escenario Local
action.PrintOutNotPropertyMatches.text=Buscar no candidatos de propiedades
action.ShowKotlinBytecode.text=Mostrar código de bytes Kotlin
action.StoredExceptionsThrowToggleAction.text=Lanzar PCEs almacenadas
action.TestMoveRefactiringAction.text=Test de refactorización de mover en un proyecto abierto
action.TopLevelCompletionBenchmarkAction.text=Rendimiento del escenario de nivel superior
action.add.import.chooser.title=Importación
action.generate.equals.choose.equals=Elige las propiedades a incluir en 'equals()'
action.generate.equals.choose.hashcode=Elegir propiedades a incluir en 'hashCode()'
action.generate.functions.already.defined=Las funciones {0} ya están definidas para la clase {1}. ¿Deseas eliminarlas y continuar?
action.generate.secondary.constructor.choose.properties=Elige Propiedades para Inicializar por Constructor
action.generate.secondary.constructor.error.already.exists=El constructor ya existe
action.generate.super.type=Especifica supertipo explícitamente
action.generate.test.support.choose.framework=Seleccionar framework
action.generate.test.support.choose.test.name=Elegir nombre de la prueba:
action.generate.test.support.edit.template=Editar plantilla
action.generate.test.support.error.cant.convert.java.template=No se pudo convertir la plantilla de Java a Kotlin
action.generate.test.support.error.cant.generate.method=No se puede generar el método: {0}
action.generate.test.support.error.no.template.found=No se encontró ninguna plantilla para {0}:{1}
action.generate.tostring.choose.implementation=Elige implementación:
action.generate.tostring.choose.implementation.mnemonic=i
action.generate.tostring.generate.super.call=Generar llamada a super.toString()
action.generate.tostring.generate.super.call.mnemonic=s
action.generate.tostring.name=Generar 'toString()'
action.generate.tostring.template.multiple=Multiples plantillas con concatenación
action.generate.tostring.template.multiple.with.super=Múltiples plantillas con concatenación y llamada a super
action.generate.tostring.template.single=Plantilla simple
action.generate.tostring.template.single.with.super=Plantilla individual con llamada a super
action.hints.settings.text=Ajustes de sugerencias...
action.j2k.correction.errors.multiple=''{0}'' y otros {1} archivos Java contienen errores de sintaxis, el resultado de la conversión puede ser incorrecto
action.j2k.correction.errors.single=''{0}'' contiene errores de sintaxis, el resultado de la conversión puede ser incorrecto
action.j2k.correction.investigate=Investigar errores
action.j2k.correction.proceed=Continuar con la conversión
action.j2k.correction.required=Algún código en el resto de tu proyecto puede requerir correcciones tras realizar esta conversión. ¿Quieres buscar ese código y corregirlo también?
action.j2k.error.cant.find.document=no se pudo encontrar el documento para ''{0}''
action.j2k.error.cant.save.result=No se pudo guardar el resultado de la conversión: {0}
action.j2k.error.nothing.to.convert=Nada que convertir:<br>No se encontraron archivos Java editables
action.j2k.error.read.only=archivo ''{0}'' es de solo lectura
action.j2k.name=Convertir Java a Kotlin
action.j2k.task.name=Convertir ficheros de Java a Kotlin
action.move.method=Mover método...
action.new.file.dialog.annotation.title=Anotación
action.new.file.dialog.class.title=Clase
action.new.file.dialog.data.class.title=Clase de datos
action.new.file.dialog.enum.title=Clase Enum
action.new.file.dialog.file.title=Archivo
action.new.file.dialog.interface.title=Interfaz
action.new.file.dialog.object.title=Objeto
action.new.file.dialog.sealed.class.title=Clase sellada
action.new.file.dialog.sealed.interface.title=Interfaz sellada
action.new.file.dialog.title=Nuevo archivo/clase Kotlin
action.new.file.error.empty.name=El nombre no puede estar vacío
action.new.file.error.empty.name.part=**Los nombres no pueden tener partes vacías.**
action.new.script.dialog.title=Nuevo Archivo Kotlin
action.new.script.name=Script de Kotlin
action.new.worksheet.name=Hoja de cálculo Kotlin
action.text.append=Anexar
action.text.cancel=Cancelar
action.text.install=Instalar
action.text.overwrite=Sobrescribir
action.usage.update.command=Actualización del uso
add.0.constructor.to.1=Agregar constructor {0} a ''{1}''
add.0.library=Añadir biblioteca ''{0}''
add.0.to.argument=Agregar ''{0} ='' al argumento
add.an.opt.in.requirement.marker.compiler.argument=Agregar un argumento de compilador de marcador de requerimiento de suscripción voluntaria
add.braces=Añadir llaves
add.braces.to.0.statement=Añade llaves a la declaración ''{0}''
add.braces.to.all.branches=Añadir llaves a todas las ramas
add.braces.to.if.all.statements=Añade llaves a todas las sentencias 'if'
add.braces.to.when.all.entries=Añade llaves a todas las entradas "when"
add.braces.to.when.entry=Agregar llaves a la instrucción "when"
add.call.or.unwrap.type.fix.text=Añadir ''.{0}()'' al resultado de la función (¡Rompe sitios de uso!)
add.call.or.unwrap.type.fix.text1=Sacar ''{0}'' tipo de retorno (interrumpe los sitios de uso!)
add.constructor.keyword=Agregar palabra clave 'constructor'
add.constructor.parameters.from.0.1=Añadir parámetros de constructor desde {0}{1}
add.constructor.parameters.from.superclass=Añadir parámetros de constructor desde superclase
add.documentation.fix.text=Agregar documentación
add.empty.argument.list=Agregar lista de argumentos vacía
add.empty.brackets.after.primary.constructor=Agrega paréntesis vacíos después del constructor principal
add.explicit.parameter.to.outer.lambda.fix.text=Agregar nombre de parámetro explícito a lambda exterior
add.explicit.type.arguments=Agrega argumentos de tipo explícito
add.external.keyword=Añadir palabra reservada externa
add.full.qualifier=Añadir calificador completo
add.fun.modifier.to.0=Añadir modificador ''fun'' a ''{0}''
add.import.for.0=Agregar importación para ''{0}''
add.import.for.member=Añadir importación para miembro
add.indices.to.for.loop=Agregar índices al bucle 'for'
add.initializer=Añadir inicializador
add.jvminline.annotation=Añadir anotación '@JvmInline'
add.jvmoverloads.annotation=Añadir anotación '@JvmOverloads'
add.jvmoverloads.annotation.to.0=Añadir anotación ''@JvmOverloads'' a {0}
add.jvmstatic.annotation=Añade anotación '@JvmStatic'
add.kotlin.coroutines=Agregar biblioteca de corrutinas de Kotlin
add.kotlin.coroutines.description=Agrega la librería de corrutinas de Kotlin
add.labeled.return.to.last.expression.in.a.lambda=Agregar un return etiquetado a la última expresión en un lambda
add.method=Agregar método
add.method.0.to.1=Agregar método ''{0}'' a ''{1}''
add.missing.class.keyword=Agregar palabra clave 'class' faltante
add.missing.component=Agrega componente desestructurado faltante
add.modifier=Añadir modificador
add.name.to.argument=Añadir nombre al argumento
add.names.in.comment.to.call.arguments=Agregar nombres en el comentario a los argumentos de llamada
add.names.to.call.arguments=Añadir nombres a parámetros de llamada
add.names.to.this.argument.and.following.arguments=Añadir nombres a este y a los siguientes argumentos
add.operator.modifier=Agregar modificador 'operator'
add.remaining.branches=Agregar ramas restantes
add.replacewith.argument.to.specify.replacement.pattern=añade el argumento 'replaceWith' para especificar el patrón de reemplazo
add.return.at.0=Agregar ''return@{0}''
add.return.expression=Añadir expresión 'return'
add.source.retention=Añadir retención de SOURCE
add.throws.annotation=Añadir anotación '@Throws'
add.underscores=Agregar guiones bajos
add.use.site.target=Añadir objetivo de sitio de uso
add.val.to.parameter.0=Agrega ''val'' al parámetro ''{0}''
add.val.var.to.parameter.0=Agregar ''val'' o ''var'' al parámetro ''{0}''
add.val.var.to.primary.constructor.parameter=Añadir 'val' o 'var' a parámetro del constructor principal
add.variance.fix.family.name=Añadir varianza
add.variance.fix.text=Añadir ''{0}'' varianza
advanced.setting.kotlin.mpp.experimental=Habilitar funciones experimentales de IDE multiplataforma
advanced.setting.kotlin.mpp.experimental.description=Requiere reinicio de IDE
all.expected.and.actual.classes.must.be.sealed.classes=Todas las clases esperadas y reales deben ser clases selladas.\n
all.inheritors.must.be.nested.objects.of.the.class.itself.and.may.not.inherit.from.other.classes.or.interfaces=Todos los herederos deben ser objetos anidados de la clase propia y no pueden heredar de otras clases o interfaces.
ambiguous.coroutinecontext.due.to.coroutinescope.receiver.of.suspend.function=CorrutinaContext ambigua debido al receptor del alcance de la corrutina de la función suspendida
ambiguous.non.local.break.or.continue=Rotura o continuación no local ambigua ''{0}'' (''{1}'' contra ''{2}''). Emplea etiquetas aclaratorias o añade un contrato ''callsInPlace''.
ambiguous.non.local.break.or.continue.display.name=Continue o Break no locales ambiguos
analyzed.0.classes.no.difference.found=Se analizaron {0} clases. No se encontró ninguna diferencia.
analyzing.functions=Analizando funciones...
analyzing.members=Analizando los miembros...
and.delete.initializer=y eliminar el inicializador
apply.also.to.internal.members=Aplicar también a los miembros internos
apply.also.to.private.members=Aplicar también a los miembros privados
apply.in.the.project.0=Aplicar en el proyecto: {0}
apply.only.to.public.or.protected.members=Aplicar únicamente a miembros públicos o protegidos
applying.0=Aplicando ''{0}''
array.property.in.data.class.it.s.recommended.to.override.equals.hashcode=Propiedad con tipo "Array" en una clase "data": se recomienda sobrescribir "equals()" y "hashCode()"
assert.should.be.replaced.with.operator=assert debe ser reemplazado con operador
assign.backing.field.fix.text=Asignar campo de respaldo
base.property.0=propiedad base {0}
block.body=bloque body
boolean.literal.argument.without.parameter.name=Argumento literal booleano sin nombre de parámetro
boolean.property.in.external.interface.should.be.nullable=La propiedad booleana en la interfaz externa debe admitir valores nulos
breadcrumbs.tooltip.indexing=Indexación...
button.add.package=Añadir Paquete
button.rename.base=Cambiar nombre de base
button.rename.current=Renombrar actual
button.text.move.nested.class.0.to.another.class=Mover clase anidada {0} a otra clase(&M)
button.text.move.nested.class.0.to.upper.level=Mover la clase anidada {0} al nivel superior
call.chain.length.to.transform=Longitud de la cadena de llamada para transformar:
call.chain.on.collection.could.be.converted.into.sequence.to.improve.performance=La cadena de llamada en una colección se puede convertir en 'Sequence' para mejorar el rendimiento
call.chain.on.collection.type.may.be.simplified=La llamada en cadena sobre el tipo de colección podría simplificarse
call.is.replaceable.with.another.scope.function=La llamada puede ser reemplazada con otra función de alcance
call.of.inline.function.with.nullable.extension.receiver.can.cause.npe.in.kotlin.1.2=La llamada a la 'función en línea' (inline fun) con el receptor nulable causa 'NPE' en Kotlin 1.2 y anteriores
call.of.java.mutator.0.on.immutable.kotlin.collection.1=Llamada del mutador de Java ''{0}'' en la colección de Kotlin inmutable ''{1}''
call.on.collection.type.may.be.reduced=La llamada en el tipo de colección puede ser reducida
call.on.not.null.type.may.be.reduced=Puede simplificarse la llamada al tipo no nulo
call.replaceable.with.binary.operator=Llamada se puede reemplazar con operador binario
call.with.arguments.will.be.skipped.0=Se omitirá la llamada con argumentos: {0}
callable.reference.fix.family.name=Añadir ''{0}'' explícito
callable.reference.transformation.is.not.supported.0=La transformación de la referencia de llamada no está soportada: {0}
calling.non.final.function.0.in.constructor=Llamada a la función no final {0} en el constructor
calls.with.explicit.extension.receiver.won.t.be.processed.0=No se procesarán llamadas con receptor de extensión explícito: {0}
can.be.converted.to.to=La inicialización 'Pair' explícita se puede reemplazar por una llamada 'to()' infija
can.be.joined.with.assignment=Se puede unir con una asignación
can.convert.argument.to.set=El argumento se puede convertir a 'Set' para mejorar el rendimiento
can.t.finish.while.indexing.is.in.progress=No se puede finalizar mientras la indexación esté en curso
can.t.modify.0=No se puede modificar {0}
can.t.replace.foreign.reference.with.call.expression.0=No se puede reemplazar la referencia externa con la expresión de llamada {0}
can.t.replace.non.kotlin.reference.with.call.expression.0=No se puede reemplazar la referencia no-Kotlin con una expresión de llamada: {0}
cannot.extract.super.call=No se puede extraer una super-llamada
cannot.get.or.create.results.file=No es posible obtener o crear el archivo de resultados
cannot.get.project.root.directory=No se puede obtener el directorio raíz del proyecto
cannot.infer.type.for.this.declaration=No se puede inferir tipo para esta declaración
cannot.inline.property.with.accessor.s.and.backing.field=No se puede alinear la propiedad con el/los accesor/es y el campo de respaldo
cannot.introduce.parameter.of.0.type=No se puede introducir el parámetro del tipo ''{0}''
cannot.refactor.expression.has.unit.type=No se puede introducir una expresión de tipo unit
cannot.refactor.no.container=No se puede refactorizar en esta ubicación
cannot.refactor.no.expression=No se puede refactorizar sin una expresión
cannot.refactor.no.type=No se puede refactorizar sin un tipo de dato
cannot.refactor.not.expression=No se puede encontrar una expresión para introducir
cannot.refactor.package.expression=No se puede introducir referencia de paquete
cannot.refactor.syntax.errors=No se puede refactorizar debido a errores de sintaxis
cannot.refactor.synthesized.function=No se puede refactorizar la función sintetizada
cascade.if.should.be.replaced.with.when=La casacada 'if' debería ser reemplazada con 'when'
cast.explicitly.fix.text=Lanzamiento explícito
category.class=Kotlin/Basado en clase
category.comments=Kotlin/Comentarios, KDoc y metadatos
category.declaration=Kotlin/Declaraciones
category.expressions=Kotlin/Expresiones
category.interesting=Kotlin/Interés
category.operators=Kotlin/Operadores
change.all.usages.of.0.in.this.file.to.1=Cambiar todos los usos de {0} en este archivo a {1}
change.all.usages.of.0.in.this.file.to.a.kotlin.class=Cambiar todas las instancias de ''{0}'' en este archivo a una clase Kotlin
change.existent.retention.to.source=Cambiar el retention existente a SOURCE
change.main.function.return.type.to.unit.fix.text=Agregar tipo de retorno Unit explícito
change.main.function.return.type.to.unit.fix.text2=Cambiar el tipo de retorno a Unit
change.signature.conflict.text.kotlin.default.parameter.in.non.kotlin.files=Es posible que el parámetro predeterminado no se admita en otros lenguajes
change.signature.conflict.text.kotlin.default.value.in.non.kotlin.files=El valor de llamada predeterminado de Kotlin puede ocasionar códigos incorrectos en otros lenguajes
change.to.0=Cambiar a ''{0}''
change.to.constructor.invocation=Cambiar a invocación al constructor
change.to.correct.long.suffix.l=Cambia a sufijo largo correcto 'L'
change.to.correct.primitive.type=Cambiar al tipo primitivo correcto
change.to.kotlin.class=Cambiar a clase Kotlin
change.to.val=Cambia a 'val'
change.to.var=Cambiar a 'var'
change.type.of.0.to.1=Cambiar el tipo de {0} a ''{1}''
change.type.to.0=Cambiar tipo a ''{0}''
change.type.to.mutable.fix.text=Cambiar tipo a mutable
change.visibility=Cambiar visibilidad
change.visibility.modifier=Cambiar modificador de visibilidad
change.visibility.popup=Cambiar visibilidad
checkbox.collapse.to.expression.body=Contraer al cuerpo de la expresión
checkbox.text.declare.with.var=Declarar con var
checkbox.text.delete.empty.source.files=Eliminar archivos fuente vacíos(&D)
checkbox.text.extension.property=Propiedad de extensión:(&X)
checkbox.text.introduce.default.value=introducir valor por omisión (&D)
checkbox.text.open.moved.files.in.editor=Abrir miembro movido en editor
checkbox.text.replace.all.occurrences.0=Reemplazar todas las ocurrencias ({0})(&R)
checkbox.text.search.references=Buscar referencias
checkbox.text.specify.type.explicitly=Especificar tipo explícitamente
checkbox.text.update.package.directive=Actualizar directiva de paquete (archivos Kotlin)
checking.data.class.0.of.1=Verificando clase de datos {0} de {1}...
checking.data.classes=Verificando clases de datos
choose.actual.members.title=Elige Miembros Reales
choose.an.appropriate.kotlin.class=Seleccionar una clase Kotlin apropiada
choose.class.container=Seleccionar clase de contenedor
choose.target.class.or.interface=Seleccionar interfaz o clase objetivo
class=Clase
class.0.already.contains.1=La clase ''{0}'' ya contiene {1}
class.name.prompt=Nombre de la clase:(&N)
class.should.be.external.interface=La clase debe ser una interfaz externa
clipboard.content.copied.from.java.file.do.you.want.to.convert.it.to.kotlin.code=Contenido del portapapeles copiado desde archivo Java. ¿Desea convertirlo a código Kotlin?
code.insight.workspace.settings.title=Kotlin
codestyle.layout.import.aliases.separately=Importar alias por separado
codestyle.name.kotlin=Kotlin
column.name.default.parameter=Parámetro por defecto:
column.name.receiver=Receptor:
column.name.val.var=Valor/Variable
command.generate.test.support.generate.test.function=Generar función de prueba
command.move.declarations=Mover Declaraciones
comment=Comentario
companion.object.already.contains.0=El objeto companion ya contiene {0}
compiling.project=Compilando proyecto...
condition.is.always.0=La condición siempre es ''{0}''
configuration.kotlin.code.style.group.name=Estilo de código oficial de Kotlin disponible
configuration.maven.group.name=Importación de Maven de proyecto Kotlin
configuration.message.enter.fully.qualified.method.name=Introduce un nombre de método totalmente calificado:
configuration.migration.group.name=Kotlin: Migraciones a una nueva versión disponibles
configuration.name.method=Método
configuration.status.text.installing=Instalando...
configuration.title.add.exclusion=Agregar exclusión
configuration.title.edit.exclusion=Editar exclusión
const.might.be.used.instead.of.jvmfield=Se puede usar 'const' en lugar de '@JvmField'
const.property=Propiedad const
constructor=Constructor
constructor.has.non.null.self.reference.parameter=El constructor tiene un parámetro de autorreferencia no nulo
constructor.parameter.is.never.used.as.a.property=El parámetro del constructor nunca se usa como propiedad
context.default=Por defecto
context.property.getter.or.setter=Propiedad con getter/setter explícito
convert.0.to.1=Convertir ''{0}'' a ''{1}''
convert.anonymous.function.to.lambda.expression=Convertir función anónima a una expresión lambda
convert.argument.to.set.fix.text=Convertir parámetro a "Set"
convert.body.to.expression=Convertir cuerpo a expresión
convert.boolean.const.to.elvis=Convertir Boolean? == const a elvis
convert.call.chain.into.sequence.fix.text=Convertir cadena de llamada en 'Sequence'
convert.class.0.to.kotlin=Convertir clase ''{0}'' a Kotlin
convert.collection.constructor.to.function=Convierte el constructor de colección en función
convert.concatenation.to.build.string=Convertir concatenación a llamada 'buildString'
convert.concatenation.to.raw.string=Convertir concatenación a cadena literal
convert.concatenation.to.template=Convertir concatenación a plantilla
convert.concatenation.to.template.before.text=La concatenación de 'String' puede convertirse en una plantilla
convert.expression.to.0=Convertir expresión a ''{0}''
convert.expression.to.0.by.inserting.1=Convertir expresión a ''{0}'' insertando ''.{1}''
convert.extension.function.type.to.regular.function.type=Convertir tipo de función de extensión a tipo de función regular
convert.extension.property.initializer.to.getter=Convertir inicializador de propiedad de extensión a getter
convert.from.class.to.kclass=Convertir 'KClass' a 'Class'
convert.function.to.property=Convertir función a propiedad
convert.function.type.parameter.to.receiver=Convertir parámetro de tipo función a receptor
convert.function.type.receiver.to.parameter=Convertir receptor de tipo función a parámetro
convert.lambda.expression.to.anonymous.function=Convertir expresión lambda a función anónima
convert.lambda.to.reference=Convertir lambda en referencia
convert.lambda.to.reference.before.text=Lambda puede convertirse a referencia
convert.left.hand.side.to.0=Convertir el miembro izquierdo a ''{0}''
convert.member.to.extension=Convertir miembro a extensión
convert.na.n.equality.quick.fix.text=Reemplazar por 'isNaN()'
convert.object.literal.to.class=Convertir literal de objeto a clase
convert.object.literal.to.lambda=Convertir literal de objeto a lambda
convert.pair.constructor.to.to.fix.text=Reemplazar con 'a' infijo
convert.parameter.to.receiver=Convertir parámetro hacia receptor
convert.property.getter.to.initializer=Convertir el getter de la propiedad en inicializador
convert.property.initializer.to.getter=Convertir inicializador de propiedad en getter
convert.property.to.function=Convertir propiedad a función
convert.put.to.assignment=Convertir put a asignación
convert.receiver.to.parameter=Convertir el receptor en un parámetro
convert.reference.to.lambda=Convertir referencia a lambda
convert.reference.to.lambda.before.text=La referencia se puede convertir a una lambda
convert.right.hand.side.to.0=Convertir el lado derecho a ''{0}''
convert.scope.function.fix.family.name=Convertir a ''{0}''
convert.sealed.subclass.to.object.fix.family.name=Conversión de subclase sellada al objeto
convert.string.template.to.build.string=Convertir a llamada 'buildString'
convert.string.to.character.literal=Convertir cadena a literal de carácter
convert.supertype.to.0=Convertir super tipo a ''{0}''
convert.template.to.concatenated.string=Convertir plantilla a cadena concatenada
convert.to.0=Convertir a {0}
convert.to.0.as.1=Convertir a ''{0} como {1}''
convert.to.0.unsafecast.1=Convertir a ''{0}.unsafeCast<{1}>()''
convert.to.a.range.check=Convertir a comprobación de rango
convert.to.anonymous.function=Convertir a función anónima
convert.to.anonymous.object=Convertir a objeto anónimo
convert.to.array.parameter=Convertir a Parámetro Array
convert.to.assignment.expression=Convierte la sentencia de asignación a una expresión
convert.to.block.body=Convertir en bloque de cuerpo
convert.to.comparisons=Convertir a comparaciones
convert.to.concatenated.string.statement.analyzing.entry.type=Analizando tipo de entrada...
convert.to.data.object=Convertir a 'objeto de datos'
convert.to.enum.class=Convertir a clase enum
convert.to.expression.body.fix.text=Convertir a cuerpo de expresión
convert.to.indexed.function.call=Convertir a llamada de función indexada
convert.to.lambda=Convertir a lambda
convert.to.lambda.expression=Convertir a expresión lambda
convert.to.lateinit.var=Convertir a lateinit var
convert.to.lazy.property=Convertir a propiedad lazy
convert.to.multi.dollar.string=Convertir a cadena con múltiples signos de dólar
convert.to.notnull.delegate=Convertir a delegado notNull
convert.to.nullable.type=Convertir a tipo anulable
convert.to.nullable.type.fix.text=Convertir a tipo anulable
convert.to.nullable.var=Convertir a var nullable
convert.to.object.declaration=Convertir a declaración de objeto
convert.to.ordinary.property=Convertir a propiedad normal
convert.to.ordinary.string.literal=Convertir a literal de cadena normal
convert.to.primary.constructor=Convertir a constructor primario
convert.to.primary.constructor.before.text=El constructor secundario debería convertirse en uno principal
convert.to.raw.string.literal=Convertir a literal de cadena sin procesar
convert.to.sealed.class=Convertir a clase sellada
convert.to.secondary.constructor=Convertir a constructor secundario
convert.to.trim.indent=Convertir a llamada 'trimIndent()'
convert.to.trim.margin=Convertir a llamada 'trimMargin()'
convert.to.unicode.escape=Convertir a escape Unicode
convert.to.unsafe.cast=Convertir a cast no seguro
convert.to.unsafecast.call=Convertir a llamada unsafeCast()
convert.to.vararg.parameter=Convertir a parámetro vararg
convert.too.long.character.literal.to.string=Convertir literales de caracteres demasiado largos a cadena
convert.try.finally.to.use=Reemplazar 'try-finally' por 'use()'
convert.try.finally.to.use.before.text=try-finally puede remplazarse con 'use()'
copy.concatenation.text.to.clipboard=Copiar concatenación de texto al portapapeles
copy.method.of.data.class.is.called.without.named.arguments=Los nombres de los parámetros deben especificarse explícitamente para la llamada al método 'copy()'
copy.paste.reference.notification={0} {0, choice, 1#importación|2#importaciones} añadidas<p><span><a href=''show''>Revisar las importaciones añadidas...</a></span>
copy.paste.resolve.pasted.references=Resolver referencias pegadas
copy.paste.restore.pasted.references=Restaurar referencias pegadas
copy.paste.restore.pasted.references.capitalized=Restaurar referencias pegadas
copy.paste.select.imports.to.remove.dialog=Seleccionar importaciones a eliminar
copy.paste.select.imports.to.remove.text=<html>El fragmento de código pegado utiliza elementos a los que no se puede acceder en un nuevo contexto. Se agregaron las importaciones necesarias.<br/>Selecciona qué importaciones agregadas quieres eliminar del archivo.</html>
copy.text.adding.imports=Agregando importaciones...
copy.text.clipboard.content.seems.to.be.java.code.do.you.want.to.convert.it.to.kotlin=El contenido del portapapeles parece ser código Java. ¿Quieres convertirlo a Kotlin?
copy.text.convert.java.to.kotlin.title=Convertir Java a Kotlin
copy.text.copied.kotlin.code=Código Kotlin copiado
copy.text.resolving.references=Resolviendo referencias...
copy.title.convert.code.from.java=Convertir el código de Java
could.be.replaced.with.size=Podría reemplazarse con 'size'
could.be.replaced.with.unboxed.first=Podría ser reemplazado por unboxed 'first'
could.be.replaced.with.unboxed.last=Se puede reemplazar con 'last' no en entorno
create.0=Crear {0}
create.0.1=Crear {0} ''{1}''
create.0.in.1=Crear {0} en {1}
create.actual=Crear actual
create.actual.0.for.module.1.2=Crear implementación {0} del módulo {1} ({2})
create.actual.in.0=Crear actual en ''{0}''
create.expected.0.in.common.module.1=Crea ****{0}**** esperado en el módulo common ****{1}****
create.kotlin.file=Crear archivo Kotlin
create.kotlin.subclass=Crear subclase en Kotlin
create.label=Crear etiqueta
create.label.0=Crear etiqueta {0}@
create.package.0=Crear paquete ''{0}''
create.parameter.0=Crear el parámetro ''{0}''
create.property.0.as.constructor.parameter=Crear propiedad ''{0}'' como parámetro de constructor
create.subclass=Crear subclase
create.test=Crear prueba
dangerous.array.comparison=Comparación de arreglos peligrosa
declaration.has.type.inferred.from.a.platform.call.which.can.lead.to.unchecked.nullability.issues=La declaración ha inferido el tipo de una llamada de plataforma, lo que puede ocasionar problemas de nulidad no marcados. Especifique el tipo explícitamente como anulable o no anulable.
declarations.are.used.outside.of.selected.code.fragment=Las siguientes declaraciones se usan fuera del fragmento de código seleccionado:
declarations.will.move.out.of.scope=Las siguientes declaraciones no estarán disponibles fuera del cuerpo de la función extraída.
deferred.result.is.never.used='Deferred'. El resultado no se utiliza
delegating.to.var.property.does.not.take.its.changes.into.account=Delegar a propiedad 'var' no toma sus cambios en cuenta
delete.0=eliminar {0}
delete.equals.and.hash.code.fix.text=Eliminar equals()/hashCode()
delete.fix.family.name=Eliminar flecha
delete.redundant.extension.property=Borrar propiedad de extensión redundante
delete.with.usage.search=Eliminar (con búsqueda de uso)
demorgan.law=Ley de DeMorgan
deprecated.annotation.without.replacewith.argument='anotación de @Deprecated' sin un argumento 'replaceWith'
description.a.reference.to.extracted.type.parameter=una referencia al parámetro de tipo extraído
destination.not.found.for.package.0=Destino no encontrado para el paquete ''{0}''
diagnostic.name.should.be.replaced.by.the.new.one=El nombre del diagnóstico debe reemplazarse por el nuevo
dialog.message.incorrect.target.path.directory.not.specified=Ruta de destino incorrecta. No se ha especificado el directorio.
dialog.message.none.elements.were.selected=No se seleccionaron elementos
dialog.progress.collect.members.to.generate=Recolectando miembros...
dialog.title.build.super.types.hierarchy=Construir jerarquía de super tipos para {0}
dialog.title.resolving.inheritable.status=Resolviendo estado heredable...
difference.found.for.data.class.0.found.1.2=Diferencia encontrada para la clase de datos {0}. Se encontraron {1} usos pero se esperaban {2}
do.you.want.to.delete.expected.declaration.together.with.all.related.actual.ones=¿Quieres eliminar la declaración esperada junto con todas las reales relacionadas?
do.you.want.to.delete.this.parameter.in.expected.declaration.and.all.related.actual.ones=¿Quieres eliminar este parámetro en la declaración esperada y todos los relacionados?
do.you.want.to.make.new.extension.an.expected.declaration=¿Deseas hacer de la nueva extensión una declaración esperada?
doesn.t.match.regex.0=no coincide con la expresión regular ''{0}''
don.t.show.this.dialog.next.time=No mostrar este cuadro de diálogo la próxima vez(&D)
double.negation.fix.text=Remover negaciones redundantes
editor.checkbox.title.auto.add.val.keyword.to.data.value.class.constructor.parameters=Agregar automáticamente la palabra clave 'val' a los parámetros del constructor de la clase de datos/valor
editor.checkbox.title.convert.pasted.java.code.to.kotlin=Convertir código Java pegado a Kotlin
editor.checkbox.title.don.t.show.java.to.kotlin.conversion.dialog.on.paste=No mostrar cuadro de dialogo Java a Kotlin al pegar
editor.title.kotlin=Kotlin
enter.package.fqname=Introduzca el FqName del paquete
enum.entry=Entrada de enumeración
equality.check.0.be.used.instead.of.elvis.for.nullable.boolean.check=Se debe usar comprobación de igualdad {0} en lugar de elvis para comprobación de booleano anulable
equality.check.with.nan.should.be.replaced.with.isnan=La comprobación de igualdad con NaN debería reemplazarse con `isNaN()`
equals.between.objects.of.inconvertible.types='equals()' entre objetos de tipos inconvertibles
equals.hashcode.in.object.declaration='equals()'/'hashCode()' en declaración de objeto
equals.should.take.any.as.its.argument='equals' debe tomar 'Any?' como su argumento
equals.text=Generar 'equals()'
error.cant.refactor.vararg.functions=No se puede refactorizar la función con argumentos variables
error.context.getter.or.setter=Este contexto solo es para propiedades con getter/setter explícito. (establecer el tipo de archivo a Kotlin)
error.expected.an.expression=Se esperaba una expresión
error.expected.catch.or.finally=Falta 'catch' o 'finally'
error.hint.cannot.modify.0.declaration.from.1.file=No se puede modificar la declaración ''{0}'' del archivo ''{1}''
error.hint.library.declarations.cannot.be.changed=Las declaraciones de la librería no se pueden cambiar
error.hint.text.cannot.inline.0.from.a.decompiled.file=No se puede insertar en línea ''{0}'' de un archivo descompilado
error.param.can.t.be.null.at.index.0.in.1=El parámetro no puede ser nulo en el índice {0} de {1}.
error.text.can.t.change.signature.of.method=No se puede cambiar la firma del método {0}
error.text.can.t.copy.class.to.the.containing.file=No se puede copiar la clase al archivo contenedor
error.text.can.t.generate.0.1={0} No se puede generar: {1}
error.text.can.t.introduce.constant.for.this.expression=No se puede introducir una constante para esta expresión
error.text.can.t.introduce.constant.for.this.expression.because.not.constant=No se puede introducir una constante para una expresión que no es constante
error.text.can.t.introduce.lambda.parameter.for.this.expression=No se puede introducir el parámetro lambda para esta expresión
error.text.can.t.introduce.property.for.this.expression=No puede introducir la propiedad para esta expresión
error.text.different.name.expected=Se espera un nombre diferente
error.text.expression.has.no.type=La expresión no tiene tipo
error.text.extraction.from.expect.class.is.not.yet.supported=Actualmente no se admite la extracción de la clase expect
error.text.extraction.from.non.jvm.class.is.not.yet.supported=La extracción desde una clase no-JVM aún no es soportada
error.text.inline.function.is.not.supported.for.functions.with.multiple.return.statements=La función en línea no es compatible con funciones con múltiples declaraciones de retorno.
error.text.inline.function.is.not.supported.for.functions.with.return.statements.not.at.the.end.of.the.body=La función inline no es compatible con funciones con sentencias return que no están al final del cuerpo.
error.text.interface.cannot.be.extracted.from.an.annotation.class=No se puede extraer la interfaz de una clase de anotación
error.text.introduce.parameter.is.not.available.for.default.value=Parámetro de introducción no disponible para valor por defecto
error.text.introduce.parameter.is.not.available.inside.of.annotation.entries=Introducir Parámetro no está disponible dentro de las anotaciones
error.text.invalid.name=Nombre no válido
error.text.invalid.parameter.name=Nombre del parámetro no válido
error.text.invalid.parameter.type=Tipo de parámetro no válido
error.text.invalid.receiver.type=Tipo de receptor inválido
error.text.invalid.return.type=Tipo de retorno no válido
error.text.no.type.to.refactor=No hay tipo para refactorizar
error.text.refactoring.is.not.applicable.in.the.current.context=La refactorización no es aplicable en el contexto actual
error.text.superclass.cannot.be.extracted.from.an.annotation.class=La superclase no puede ser extraída de una clase de anotación
error.text.type.reference.is.expected=Se espera una referencia de tipo
error.types.in.generated.function=Tipo de retorno con error en la función generada
error.wrong.caret.position.function.or.constructor.name=El cursor debe estar en el nombre de la función o constructor a refactorizar.
evaluate.compile.time.expression=Evaluar expresión de tiempo de compilación
excluded.methods=Métodos excluidos:
existing.backing.field.is.not.assigned.by.the.setter=El campo de respaldo existente no es asignado por el setter
expand.boolean.expression.to.if.else=Expandir expresión booleana a 'if else'
experimental.coroutines.usages.are.obsolete.since.1.3=Usos de corrutinas experimentales son obsoletos desde 1.3
explicit.0.call=Llamada explícita ''{0}''
explicit.this.expression.fix.family.name=Quitar la redundancia de ''{0}''
explicitly.given.type.is.redundant.here=El tipo proporcionado explícitamente es redundante aquí
expression=Expresión
external.interface.contains.non.nullable.property.name=Interfaz externa contiene una propiedad booleana no nula
external.interface.contains.val.property.name=Interfaz externa contiene propiedad val
extract.function=Extraer función
extract.new.parameter.name.receiver=<receptor>
failed.to.create.a.wrapper.for.inlining.to.kotlin=No se ha podido crear encapsulador para la integración a Kotlin
family.name.update.usages.on.declarations.cut.paste=Actualizar usos en las declaraciones cortadas/pegadas
file.entity=Archivo
file.lines=Líneas de archivo
files.to.visit=Archivos a visitar
find.declaration.constructor.usages.checkbox=Usos del constructor
find.declaration.derived.classes.checkbox=Clases derivadas(&D)
find.declaration.derived.interfaces.checkbox=Interfaces derivadas(&I)
find.declaration.functions.usages.checkbox=Usos de las funciones
find.declaration.implementing.methods.checkbox=Funcion. implementadora(&I)
find.declaration.implementing.properties.checkbox=Propiedades de implementación(&I)
find.declaration.include.overloaded.methods.checkbox=Incluir funciones sobrecargadas y extensiones
find.declaration.overriding.methods.checkbox=Funciones de reemplazo(&R)
find.declaration.overriding.properties.checkbox=Propiedades sobreescritas
find.declaration.properties.usages.checkbox=Usos de propiedades
find.declaration.property.readers.checkbox=Lectores
find.declaration.property.writers.checkbox=Escritores
find.usages.checkbox.name.expected.classes=Clases esperadas
find.usages.checkbox.name.expected.functions=Funciones esperadas
find.usages.checkbox.name.expected.properties=Propiedades esperadas
find.usages.checkbox.text.fast.data.class.component.search=Búsqueda de componentes data class rápida
find.usages.class=clase
find.usages.class.name.anonymous=Anónimo
find.usages.companion.object=compañero objeto
find.usages.constructor=constructor
find.usages.facade.class=clase fachada
find.usages.for.property={0} para propiedad
find.usages.function=función
find.usages.getter=getter
find.usages.import.alias=importar alias
find.usages.interface=interfaz
find.usages.label=Etiqueta
find.usages.lambda=lambda
find.usages.object=objeto
find.usages.parameter=parámetro
find.usages.prepare.dialog.progress=Preparando el Cuadro de Diálogo
find.usages.progress.text.declaration.superMethods=Resolviendo super métodos...
find.usages.property=propiedad
find.usages.property.accessor=accesor de propiedad
find.usages.setter=setter
find.usages.text.find.usages.for.data.class.components.and.destruction.declarations=<p>Encuentra los usos para los componentes de las clases de datos y las declaraciones de desestructuración.<br/>Puede <a href="{0}">deshabilitarse una vez</a> o <a href="{1}">deshabilitarse para un proyecto</a>.</p>
find.usages.tool.tip.text.disable.search.for.data.class.components.and.destruction.declarations.project.wide.setting=Desactivar búsqueda para componentes de clase de datos y declaraciones de desestructuración. (Configuración de todo el proyecto)
find.usages.type.alias=alias de tipo
find.usages.type.callable.reference=Referencia invocable
find.usages.type.class.object=Clase/objeto anidado
find.usages.type.companion.object=Objeto companion
find.usages.type.constructor.delegation.reference=Referencia de delegación de constructor
find.usages.type.delegate=Delegado
find.usages.type.extension.receiver.type=Tipo de receptor de extensión
find.usages.type.function.call=Llamada a función
find.usages.type.function.return.type=Tipos de retorno de la función
find.usages.type.implicit.get=Obtener implícito
find.usages.type.implicit.invoke=Invocación 'invoke' implícita
find.usages.type.implicit.iteration=Iteración implícita
find.usages.type.implicit.set=Establecer implícito
find.usages.type.is=Tipo de destino de la operación 'is'
find.usages.type.named.argument=Argumento nombrado
find.usages.type.nonLocal.property.type=Tipo de propiedad de clase/objeto no local
find.usages.type.packageDirective=Directiva de package
find.usages.type.packageMemberAccess=Acceso a miembro de paquete
find.usages.type.parameter=parámetro de tipo
find.usages.type.property.delegation=Delegación de propiedades
find.usages.type.receiver=Receptor
find.usages.type.super.type.qualifier=Calificador de supertipo
find.usages.type.superType=Supertipo
find.usages.type.type.alias=Alias de tipo
find.usages.type.type.constraint=Restricción de tipo
find.usages.type.value.parameter.type=Tipo de parámetro
find.usages.variable=variable
fix.add.annotation.family=Añadir anotación
fix.add.annotation.target=Añadir destino de anotación
fix.add.annotation.text.constructor=Agrega la anotación ''@{0}'' al constructor
fix.add.annotation.text.containing.class=Agregar anotación ''@{0}'' a la clase contenedora ''{1}''
fix.add.annotation.text.containing.file=Añadir anotación ''@{0}'' a archivo contenedor ''{1}''
fix.add.annotation.text.declaration=Añadir anotación ''@{0}'' a ''{1}''
fix.add.annotation.text.self=Agregar anotación ''@{0}''
fix.add.annotation.with.arguments.text.copy=Copiar la anotación ''@{0}'' de ''{1}'' a ''{2}''
fix.add.argument.name.family=Añadir nombre a argumento
fix.add.argument.name.step.choose.parameter.title=Seleccionar nombre del parámetro
fix.add.argument.name.text=Añadir nombre al argumento ''{0}''
fix.add.argument.name.text.generic=Agregar nombre al argumento...
fix.add.array.of.type.family=Agregar envoltorio 'arrayOf'
fix.add.array.of.type.text=Agregar envoltura {0}
fix.add.constructor.parameter=Agregar parámetro de constructor ''{0}''
fix.add.default.constructor=Agregar constructor por defecto a la clase 'expect'
fix.add.else.branch.when=Añadir rama si no
fix.add.eq.eq.true=Agregar '== true'
fix.add.exception.to.throws=Agregar ''{0}''
fix.add.explicit.import=Agregar importación explícita
fix.add.function.body=Añadir cuerpo de función
fix.add.function.parameters.add.parameter.constructor=Añadir {0,number,ordinal} {1,choice,1#parámetro|2#parámetros} al constructor ''{2}''
fix.add.function.parameters.add.parameter.function=Agregar el {0,number,ordinal} {1,choice,1# parámetro|2# parámetros} antes de la función ''{2}''
fix.add.function.parameters.add.parameter.generic.constructor=Agrega {0,choice,1#parámetro|2#parámetros} al constructor ''{1}''
fix.add.function.parameters.add.parameter.generic.function=Añadir {0,choice,1#parámetro|2#parámetros} a la función ''{1}''
fix.add.function.parameters.change.signature.constructor=Cambiar la firma del constructor "{0}"
fix.add.function.parameters.change.signature.function=Cambiar firma de función ''{0}''
fix.add.generic.upperbound.family=Agregar límite superior genérico
fix.add.generic.upperbound.text=Añadir ''{0}'' como límite superior para {1}
fix.add.is.to.when=Agregar "is" antes de "{0}"
fix.add.loop.label.text=Agregar ''{0}'' a {1}
fix.add.loop.label.text.generic=Agregar etiqueta al bucle
fix.add.member.supertype.add.to=Agregar ''{0}'' a ''{1}''
fix.add.member.supertype.choose.type=Escoge Tipo
fix.add.member.supertype.family=Añadir {0} a supertipo
fix.add.member.supertype.progress=Agrega {0} a Tipo
fix.add.member.supertype.text=Añadir {0} a supertipo...
fix.add.modifier.family=Agregar modificador
fix.add.modifier.inline.function.family=Agregar 'inline' a función
fix.add.modifier.inline.function.text=Agregar ''inline'' a la función ''{0}''
fix.add.modifier.inline.parameter.family=Agregar ''{0}'' a parámetro
fix.add.modifier.inline.parameter.text=Agrega ''{0}'' al parámetro ''{1}''
fix.add.modifier.text=Hacer {0} ''{1}''
fix.add.modifier.text.generic=Agregar modificador ''{0}''
fix.add.new.line.after.annotations=Agregar línea nueva después de las anotaciones
fix.add.remaining.branches=Añadir ramas restantes
fix.add.remaining.branches.with.star.import=Añadir ramas restantes con importación *
fix.add.return.before.expression=Agregar 'return' antes de la expresión
fix.add.return.before.lambda.expression=Añadir 'run' antes de la expresión lambda
fix.add.return.last.expression=Agregar 'return' a la última expresión
fix.add.semicolon.lambda.expression=Termina la llamada anterior con un punto y coma
fix.add.spread.operator.after.sam=Agregar un operador "spread" delante de un array que se pasa como "vararg"
fix.add.star.projection.family=Agregar proyección de estrella
fix.add.star.projection.text=Agregar ''{0}''
fix.add.suspend.modifier.function=Hacer {0} suspend
fix.add.suspend.modifier.function.generic=Hacer que la función contenedora se suspenda
fix.add.suspend.modifier.receiver=Convertir tipo {0} a suspendido
fix.add.suspend.modifier.receiver.generic=Hacer que el tipo receptor se suspenda
fix.add.tostring.call.family=Añadir llamada 'toString()'
fix.add.tostring.call.text=Añadir llamada 'toString()'
fix.add.tostring.call.text.safe=Agrega llamada segura '?.toString()'
fix.add.type.annotation.family=Añadir anotación de tipo
fix.add.type.annotation.text=Añadir el tipo ''{0}'' al parámetro ''{1}''
fix.assign.to.property=Asignar a propiedad
fix.cast.expression.family=Conversión de tipo
fix.cast.expression.text=Fundición de expresión ''{0}'' a ''{1}''
fix.change.accessor.family=Cambiar tipo de accesor
fix.change.accessor.getter=Cambia el tipo de getter a {0}
fix.change.accessor.setter.parameter=Cambiar tipo del parámetro del setter a {0}
fix.change.jvm.name=Cambiar nombre de la JVM
fix.change.mutability.change.to.val=Cambiar ''{0}'' a val
fix.change.object.to.class=Cambiar 'object' a 'class'
fix.change.package.family=Cambiar el paquete de archivos para que coincida con el directorio
fix.change.package.text=Cambiar el paquete del archivo a {0}
fix.change.progress.analyzing.class.hierarchy=Analizando jerarquía de clases...
fix.change.progress.looking.inheritors=Buscando herederos de la clase {0}...
fix.change.return.type.command.function=Cambio del parámetro ''{0}'' de la función ''{1}'' para escribir ''{2}''
fix.change.return.type.command.primary.constructor=Cambiar el tipo de parámetro ''{0}'' del constructor primario de la clase ''{1}'' a ''{2}''
fix.change.return.type.family=Cambiar el tipo
fix.change.return.type.lambda=Cambia el tipo de retorno de la expresión lambda a {0}
fix.change.return.type.presentation.accessed=accedido {0}
fix.change.return.type.presentation.base=base {0}
fix.change.return.type.presentation.called=llamado {0}
fix.change.return.type.presentation.called.function=función llamada
fix.change.return.type.presentation.enclosing=encapsulado {0}
fix.change.return.type.presentation.enclosing.function=función encapsuladora
fix.change.return.type.presentation.function=función {0}
fix.change.return.type.presentation.property=propiedad {0}
fix.change.return.type.remove.explicit.return.type=Eliminar tipo de retorno explícito especificado
fix.change.return.type.remove.explicit.return.type.of=Quitar tipo de retorno explícitamente especificado de {0}
fix.change.return.type.return.type.text=Cambiar el tipo de retorno a ''{0}''
fix.change.return.type.return.type.text.of=Cambiar el tipo de retorno de {0} a ''{1}''
fix.change.return.type.text.function=Cambiar el tipo de parámetro ''{0}'' de función ''{1}'' a ''{2}''
fix.change.return.type.text.primary.constructor=Cambiar el tipo de parámetro ''{0}'' del constructor principal de la clase ''{1}'' a ''{2}''
fix.change.return.type.type.text=Cambiar tipo a ''{0}''
fix.change.return.type.type.text.of=Cambiar el tipo de {0} a ''{1}''
fix.change.signature.error=<error>
fix.change.signature.family=Cambiar signatura de función/constructor
fix.change.signature.function.family=Cambiar la firma de la función
fix.change.signature.function.popup.title=Cambio de Firma
fix.change.signature.function.text=Cambia la firma de función a ''{0}''
fix.change.signature.function.text.generic=Cambiar firma de función...
fix.change.signature.lambda=Modificar la firma de la expresión lambda
fix.change.signature.lambda.command=Cambiar la firma de la expresión lambda
fix.change.signature.prepare=Preparando...
fix.change.signature.remove.parameter=Eliminar parámetro ''{0}''
fix.change.signature.remove.parameter.command=Quitar parámetro ''{0}''
fix.change.signature.unavailable=<no disponible>
fix.change.signature.unnamed.parameter=parámetro
fix.change.suspend.hierarchy.add=Añadir modificador 'suspend' a todas las funciones en la jerarquía
fix.change.suspend.hierarchy.remove=Quitar modificador 'suspend' de todas las funciones en la jerarquía
fix.change.to.function.invocation=Cambiar a invocación de función
fix.change.to.labeled.return.family=Cambiar para regresar con etiqueta
fix.change.to.labeled.return.text=Cambiar a ''{0}''
fix.change.to.mutable.type=Cambiar tipo a {0}
fix.change.to.mutable.type.family=Cambiar el tipo a mutable
fix.change.to.mutable.type.text=Cambiar tipo a {0}
fix.change.to.property.access.family.change=Cambiar a acceso a propiedad
fix.change.to.property.access.family.remove=Eliminar invocación
fix.change.to.star.projection.family=Cambiar a proyección estrella
fix.change.to.star.projection.text=Cambiar los argumentos de tipo a {0}
fix.change.to.use.spread.operator.family=Cambiar para utilizar operador de propagación
fix.change.to.use.spread.operator.text=Cambiar ''{0}'' a ''{1}''
fix.change.type.argument=Cambiar argumento tipo a {0}
fix.change.type.family=Cambiar tipo
fix.change.type.text=Cambiar tipo de ''{0}'' a ''{1}''
fix.convert.to.is.array.of.call=Convertir a llamada 'isArrayOf'
fix.copy.mismatched.annotation.to.actual.declaration.may.change.semantics=Copiar la anotación no coincidente ''{0}'' de la declaración ''esperada'' a la declaración ''real'' (puede cambiar la semántica)
fix.create.declaration.error=No se puede generar {0}: {1}
fix.create.declaration.error.inaccessible.type=Tipo inaccesible
fix.create.declaration.error.some.types.inaccessible=Algunos tipos no son accesibles:
fix.create.expect.actual=Crear declaración expect / actual
fix.create.from.usage.dialog.title=Crear desde uso
fix.create.from.usage.family=Crear desde uso
fix.create.from.usage.local.variable=Crear variable local ''{0}''
fix.create.from.usage.property=Crear propiedad ''{0}''
fix.create.missing.actual.declarations=Añadir declaraciones actuales ausentes
fix.create.missing.actual.declarations.title=Agregar Declaraciones Reales Ausentes
fix.create.missing.actual.members=Agregar miembros actuales faltantes
fix.import=Importar
fix.import.exclude=Excluir ''{0}'' de la importación automática
fix.import.kind.0.name.1.2=Importar {0} ''{1}''{2,choice,0#|1# y {2} más}
fix.import.kind.0.name.1.and.name.2=Importar {0} ''{1}'', ''{2}''
fix.import.kind.component.functions=Funciones de componente
fix.import.kind.delegate.accessors=Accesores de delegados
fix.import.question=¿Importar {0}?
fix.insert.delegation.call=Insertar llamada ''{0}()''
fix.introduce.non.null.assertion=Añadir llamada con aserción no nula ({0}!!)
fix.make.data.class=Convertir ''{0}'' a clase de datos
fix.make.field.public=Hacer público el campo ''{0}''
fix.make.type.parameter.reified=Convertir {0} en reificado y {1} en inline
fix.make.upperbound.not.nullable.any.text=Añadir ''Any'' como cota superior para {0} para hacerlo no anulable
fix.make.upperbound.not.nullable.family=Hacer el parámetro de tipo genérico no nulo
fix.make.upperbound.not.nullable.remove.nullability.text=Cambia el límite superior de {0} a ''{1}'' para hacer {0} no-nullable
fix.move.file.to.package.dir.name.text=raíz de origen
fix.move.file.to.package.family=Mover archivo a directorio coincidente con el paquete
fix.move.file.to.package.text=Mover archivo a {0}
fix.move.to.sealed.family=Mover miembro de jerarquía al paquete/módulo de su padre sealed
fix.move.to.sealed.text=Mover {0} al paquete/módulo de {1}
fix.move.typealias.to.top.level=Mover typealias al nivel superior
fix.opt_in.annotation.family=Anotar uso de características opt-in
fix.opt_in.migrate.experimental.annotation.remove=Quitar la anotación '@Experimental' obsoleta
fix.opt_in.migrate.experimental.annotation.replace=Reemplazar anotación obsoleta '@Experimental' por '@RequiresOptIn'
fix.opt_in.move.requirement.from.getter.to.property=Mover requisito de inclusión ''{0}'' de getter a propiedad
fix.opt_in.move.requirement.from.value.parameter.to.property=Mover requerimiento de habilitación de ''{0}'' de parámetro de valor a propiedad
fix.opt_in.remove.all.forbidden.targets=Eliminar todos los objetivos prohibidos de opt-in
fix.opt_in.remove.forbidden.retention=Eliminar la retención de anotación de opt-in prohibida
fix.opt_in.text.propagate.constructor=Propagar ''{0}'' requisito de activación a constructor
fix.opt_in.text.propagate.containing.class=Propagar el requisito de inscripción "{0}" a la clase contenedora "{1}"
fix.opt_in.text.propagate.containing.object=Propagar ''{0}'' opt-in a {1}
fix.opt_in.text.propagate.declaration=Propagar el requisito de participación en ''{0}'' a ''{1}''
fix.opt_in.text.use.constructor=Optar por ''{0}'' en constructor
fix.opt_in.text.use.containing.anonymous.object=Opción de activación para ''{0}'' en objeto contenedor
fix.opt_in.text.use.containing.class=Opt in de ''{0}'' en la clase contenedora ''{1}''
fix.opt_in.text.use.containing.file=Optar por ''{0}'' en el archivo contenedor ''{1}''
fix.opt_in.text.use.containing.object=Optar por ''{0}'' en el objeto contenedor ''{1}''
fix.opt_in.text.use.declaration=Suscribirse a ''{0}'' en ''{1}''
fix.opt_in.text.use.module=Seleccionar ''{0}'' en el módulo ''{1}''
fix.opt_in.text.use.statement=Activar "{0}" en la sentencia
fix.potentially.broken.inheritance.message=Este cambio podría romper a los herederos.\n¿Desea continuar?
fix.potentially.broken.inheritance.title=Herencia potencialmente rota
fix.remove.annotation.text=Borrar anotación
fix.remove.argument.text=Eliminar argumento
fix.remove.mismatched.annotation.from.expect.declaration.may.change.semantics=Remover anotación no coincidente ''{0}'' de la declaración ''expect'' (puede cambiar la semántica)
fix.remove.non.null.assertion=Quitar la aserción innecesaria de no nulo (!!)
fix.remove.redundant.star.text=Eliminar * redundante
fix.replace.annotation.family=Reemplazar anotación
fix.replace.annotation.text=Reemplazar anotación con ''@{0}''
fix.replace.mismatched.annotation.args.on.actual.declaration.may.change.semantics=Remplazar argumentos de anotación incompatible ''{0}'' en la declaración ''actual'' (puede cambiar la semántica)
fix.replace.mismatched.annotation.args.on.expect.declaration.may.change.semantics=Reemplazar argumentos de anotación no coincidentes ''{0}'' en la declaración ''expect'' (tal vez cambie la semántica)
fix.replace.with.assign.function.call=Reemplazar con llamada a ''{0}''
fix.replace.with.declaring.java.class=Reemplazar con 'declaringJavaClass'
fix.text=Elimina punto y coma redundante
fix.unused.receiver.parameter.remove=Quitar parámetro redundante de receptor
fix.use.fully.qualified.call=Utilizar llamada completa
fix.with.asdynamic=Solucionar con 'asDynamic'
flatten.when.expression=Expresión flatten 'when'
flip.0=Invertir ''{0}''
flip.binary.expression=Invertir expresión binaria
flip.equals=Voltea 'equals'
floating.point.literal.precision.inspection=El literal de punto flotante no se puede representar con la precisión requerida
floating.point.literal.precision.inspection.display.name=El literal de punto flotante excede la precisión disponible
foldable.if.then=If-then desplegable
following.expression.won.t.be.processed.since.refactoring.can.t.preserve.its.semantics.0=La siguiente expresión no se procesará porque la refactorización no puede preservar su semántica: {0}
following.problems.are.found=Se encontraron los siguientes problemas:\n
for.0=para ''{0}''
for.api.stability.it.s.recommended.to.specify.explicitly.declaration.types=Para el desarrollo estable de API, se recomienda especificar explícitamente los tipos de la declaración
for.api.stability.it.s.recommended.to.specify.explicitly.public.protected.declaration.types=Para la estabilidad de la API, se recomienda especificar explícitamente los tipos de declaración public y protected
for.loop.over.indices.could.be.replaced.with.loop.over.elements=El bucle for sobre los índices podría ser reemplazado con un bucle sobre los elementos
formatter.button.text.use.import.with=Usar importación con '*'
formatter.button.text.use.import.with.when.at.least=Usar import con '*' cuando hay como mínimo
formatter.button.text.use.single.name.import=Usar importación de nombre único
formatter.checkbox.text.insert.imports.for.nested.classes=Insertar imports para clases anidadas
formatter.checkbox.text.use.trailing.comma=usa coma final
formatter.settings.title=Configuración de Kotlin Formato
formatter.text.names.used=Nombres usados
formatter.text.use.defaults.from=Usar valores predeterminados de:
formatter.title.after.colon.before.declaration.type=Después de dos puntos, antes del tipo de declaración
formatter.title.after.colon.in.new.type.definition=Después de los dos puntos en la nueva definición de tipo
formatter.title.align.when.branches.in.columns=Alinear ramas 'when' en columnas
formatter.title.around.arrow.in=Alrededor de la flecha en la cláusula "when"
formatter.title.around.arrow.in.function.types=Alrededor de la flecha en tipos de funciones
formatter.title.around.when.branches.with=Alrededor de las ramas 'when' con {}
formatter.title.before.colon.after.declaration.name=Antes de dos puntos, después del nombre de declaración
formatter.title.before.colon.in.new.type.definition=Antes del dos puntos en una nueva definición de tipo
formatter.title.before.declaration.with.comment.or.annotation=Antes de la declaracion con comentario o anotacion
formatter.title.before.lambda.arrow=Antes de la flecha lambda
formatter.title.chained.function.calls=Llamadas de funciones encadenadas
formatter.title.elvis.expressions=Expresiones Elvis
formatter.title.elvis.operator=Operador Elvis (?:)
formatter.title.expression.body.functions=Funciones en el cuerpo de expresión
formatter.title.function.annotations=Anotaciones de la función
formatter.title.function.call.arguments=Argumentos de llamada a función
formatter.title.function.declaration.parameters=Parámetros de la declaración de la función
formatter.title.function.parentheses=Paréntesis de función
formatter.title.in.simple.one.line.methods=En métodos sencillos de una línea
formatter.title.indent.before.arrow.on.new.line=Sangrar antes de '->' en nueva línea
formatter.title.java.statics.and.enum.members=Miembros de Java estáticos y enum
formatter.title.line.break.after.multiline.when.entry=Salto de línea después de una entrada de varias líneas
formatter.title.load.save=Cargar/Guardar
formatter.title.other=Otros
formatter.title.property.annotations=Anotaciones de propiedades
formatter.title.put.left.brace.on.new.line=Colocar la llave izquierda en una nueva línea
formatter.title.range.operator=Operadores de rango (.., ..<)
formatter.title.top.level.symbols=Símbolos de nivel superior
formatter.title.trailing.comma=Coma final
formatter.title.use.continuation.indent=Usar sangría de continuación
formatter.title.use.continuation.indent.in.conditions=Usar sangría de continuación en las condiciones
formatter.title.when.parentheses=paréntesis 'when'
formatter.title.when.statements='when' sentencias
function=Función
function.0=función ''{0}''
function.0.returning.1.without.the.corresponding=Función ''{0}'' retorna ''{1}'' sin la función correspondiente ''{2}'' retorna ''{3}''
function.01=Función "{0}"
function.name.is.invalid=Nombre de función inválido
function.returning.0.with.a.name.that.does.not.end.with.1=Función que retorna {0} con un nombre que no termina en {1}
function.should.have.operator.modifier=Función debe tener modificador 'operator'
generate.equals.and.hashcode.fix.text=Generar equals() y hashCode()
generate.identity.equals.fix.family.name=Generar equals y hashCode por identidad
goto.related.provider.in.module.0=(en el módulo {0})
goto.super.chooser.class.title=Elija una superclase o interfaz
goto.super.chooser.function.title=Elegir función super
goto.super.chooser.property.title=Elegir Propiedad Super
group.InternalKotlin.text=Acciones internas Kotlin
group.KotlinCompletionBenchmarkGroup.text=Grupo de Benchmark Completados
group.KotlinInternalGroup.text=Kotlin
group.KotlinRefactoringTesting.text=Prueba de refactorización Kotlin
group.KotlinToolsGroup.text=Kotlin
group.advanced.settings.kotlin=Kotlin
group.names.code.migration=Migración de código
group.names.coroutine=Inspección de corrutina
group.names.gradle=Gradle
group.names.java.interop.issues=Problemas de interoperabilidad de Java
group.names.kotlin=Kotlin
group.names.logging=Registro
group.names.maven=Maven
group.names.migration=Migración
group.names.naming.conventions=Convenciones de nomenclatura
group.names.other.problems=Otros problemas
group.names.probable.bugs=Posibles bugs
group.names.redundant.constructs=Construcciones redundantes
group.names.style.issues=Problemas de estilo
group.path.kotlin.migration=Kotlin,Migración
hash.code.text=Generar 'hashCode()'
hierarchy.legend.member.defined.in.superclass=El miembro no está definido en la clase pero si está definido en la superclase
hierarchy.legend.member.is.defined.in.class=Miembro está definido en la clase
hierarchy.legend.member.should.be.defined=Se debe definir un miembro ya que la clase no es abstracta
hierarchy.text.anonymous=[anónimo]
hierarchy.text.in=en {0}
highlight.usages.of.receiver=Resaltar usos de receiver
highlighter.action.text.go.to.actual.declarations=Ir a declaraciones reales
highlighter.action.text.go.to.expected.declaration=Ir a declaración esperada
highlighter.action.text.go.to.implementations=Ir a las implementaciones
highlighter.action.text.go.to.overridden.methods=Ir a métodos reemplazados
highlighter.action.text.go.to.overridden.properties=Ir a propiedades sobrescritas
highlighter.action.text.go.to.subclasses=Ir a subclases
highlighter.action.text.go.to.super.method=Ir a método superior
highlighter.action.text.go.to.super.property=Ir a super propiedad
highlighter.descriptor.text.android.extensions.property=Propiedades y variables//Propiedades sintéticas de Android Extensions
highlighter.descriptor.text.annotation=Anotaciones//Nombre anotación
highlighter.descriptor.text.annotation.attribute.name=Anotación//Nombre de atributo de anotación
highlighter.descriptor.text.arrow=Paréntesis y operadores // Flecha
highlighter.descriptor.text.builtin.annotation=Palabras clave//Modificador
highlighter.descriptor.text.builtin.keyword=Palabras clave//Palabras Clave
highlighter.descriptor.text.builtin.keyword.val=Palabras clave//'val'
highlighter.descriptor.text.builtin.keyword.var=Palabras reservadas//'var'
highlighter.descriptor.text.captured.variable=Propiedades y variables//Variables y valores capturados en un cierre
highlighter.descriptor.text.closure.braces=Llaves y Operadores//Llaves y Flecha de la expresión lambda
highlighter.descriptor.text.colon=Llaves y Operadores//Dos Puntos
highlighter.descriptor.text.constructor.call=Funciones//Llamada a constructor
highlighter.descriptor.text.double.colon=Llaves y Operadores//Doble punto
highlighter.descriptor.text.dynamic.fun.call=Funciones//Llamada dinámica de función
highlighter.descriptor.text.dynamic.property=Propiedades y variables//Propiedad dinámica
highlighter.descriptor.text.enum=Clases e Interfaces//Enumeración
highlighter.descriptor.text.enumEntry=Clases e interfaces//Entrada de enumeración
highlighter.descriptor.text.exclexcl=Llaves y operadores//Aserción de no nulo
highlighter.descriptor.text.extension.fun.call=Funciones//Llamada de función de extensión
highlighter.descriptor.text.extension.property=Propiedades y variables//Propiedad de extensión
highlighter.descriptor.text.field=Propiedades y variables//Variable de campo de respaldo
highlighter.descriptor.text.fun=Funciones//Declaración de función
highlighter.descriptor.text.fun.call=Funciones//Llamada a función
highlighter.descriptor.text.instance.property=Propiedades y variables//Propiedad de instancia
highlighter.descriptor.text.instance.property.custom.property.declaration=Propiedades y Variables//Propiedad de instancia con declaraciones de propiedades personalizadas
highlighter.descriptor.text.it=Parámetros//parámetro por defecto expresión Lambda
highlighter.descriptor.text.kdoc.comment=Comentarios//KDoc//Comentario KDoc
highlighter.descriptor.text.kdoc.tag=Comentarios//KDoc//Etiqueta KDoc
highlighter.descriptor.text.kdoc.value=Comentarios//KDoc//Enlace en etiqueta KDoc
highlighter.descriptor.text.label=Etiqueta
highlighter.descriptor.text.local.variable=Propiedades y variables//Variable o valor local
highlighter.descriptor.text.named.argument=Argumento con nombre
highlighter.descriptor.text.object=Clases e interfaces//Objeto
highlighter.descriptor.text.package.fun.call=Funciones//Llamada a función a nivel de paquete
highlighter.descriptor.text.package.property=Propiedades y Variables//Propiedad de nivel de paquete
highlighter.descriptor.text.package.property.custom.property.declaration=Propiedades y variables//Propiedad a nivel de paquete con declaraciones de propiedad personalizadas
highlighter.descriptor.text.quest=Llaves y Operadores//Marcadores de tipo de anulabilidad nula
highlighter.descriptor.text.safe.access=Llaves y operadores//Punto de acceso seguro
highlighter.descriptor.text.smart.cast=Conversión inteligente//Valor de conversión inteligente
highlighter.descriptor.text.smart.cast.receiver=Conversión smart//Receptor implícito de smart cast
highlighter.descriptor.text.smart.constant=Smart-casts//Constante inteligente
highlighter.descriptor.text.string.escape=Cadena//Escape en cadena y llaves de plantilla
highlighter.descriptor.text.suspend.fun.call=Funciones//Llamada de función suspendida
highlighter.descriptor.text.synthetic.extension.property=Propiedades y variables//Propiedad de extensión sintética
highlighter.descriptor.text.typeAlias=Clases e Interfaces//Alias de tipo
highlighter.descriptor.text.var=Propiedades y Variables//Var (variable mutable, parámetro o propiedad)
highlighter.descriptor.text.variable.as.function.call=Propiedades y variables//Variable como llamada a función
highlighter.descriptor.text.variable.as.function.like.call=Propiedades y variables//Variable como llamada similar a una función
highlighter.message.suspend.function.call=Llamada a función suspender
highlighter.message.suspending.iteration=Iteración suspendida
highlighter.name.dsl=Dsl//
highlighter.name.dsl.markers=Marcadores DSL
highlighter.name.expect.actual.line.markers=Kotlin Marcadores de línea 'expect'//'actual'
highlighter.name.implemented.declaration=Declaración Implementada
highlighter.name.implementing.declaration=Declaración de implementación
highlighter.name.kotlin.line.markers=Marcadores de línea de Kotlin
highlighter.name.multiplatform.actual.declaration=Declaración actual multiplataforma
highlighter.name.multiplatform.expect.declaration=Declaración de expectativa multiplataforma
highlighter.name.overridden.declaration=Declaración sobreescrita
highlighter.name.overriding.declaration=Declaración de sobreescritura
highlighter.name.style=Estilo {0}
highlighter.notification.text.navigation.to.overriding.classes.is.not.possible.during.index.update=No es posible navegar a las clases anuladas durante la actualización de índice
highlighter.prefix.text.has.actuals.in=Tiene valores actuales en {0} {1, choice, 0#módulo|1#módulos}
highlighter.text.click.for.navigate=Haz clic en {0} para navegar
highlighter.text.has.functional.implementations=Tiene implementaciones funcionales
highlighter.text.implements=Implementa
highlighter.text.in={0} en ''{1}''
highlighter.text.or.press=o pulse {0}
highlighter.text.overrides=Anulaciones
highlighter.title.overriding.declarations.of=Declaraciones de Sobrescritura De {0}
highlighter.title.searching.for.overriding.declarations=Buscando declaraciones sobrescritas
highlighter.title.searching.for.overriding.methods=Buscando métodos de anulación
highlighter.tool.tip.has.expect.declaration.in=Tiene expects en {0} {1, choice, 0#módulo|1#módulos}
highlighter.tool.tip.marker.annotation.for.dsl=Marcador de anotación para DSL
highlighter.tool.tip.text.function=función
highlighter.tool.tip.text.property=propiedad
highlighter.tool.tip.text.recursive.call=Llamada recursiva
hint.text.no.expression.found=No se encontró expresión
hints.codevision.implementations.format={0, choice, 1#1 Implementación|2#{0,number} Implementaciones}
hints.codevision.implementations.too_many.format={0,number} Implementaciones
hints.codevision.inheritors.format={0, choice, 1#1 heredero|2#{0,number} herederos}
hints.codevision.inheritors.to_many.format={0,number} + Herederos
hints.codevision.overrides.format={0, choice, 1#1 override|2#{0,number} overrides}
hints.codevision.overrides.to_many.format={0,number}+ Anulaciones
hints.codevision.settings=Configuración...
hints.codevision.usages.format={0, choice, 1#1 uso|2#{0,number} usos}
hints.codevision.usages.too_many.format={0,number} + Usos
hints.ranges.greaterOrEqual=≥
hints.ranges.less=<
hints.ranges.lessOrEqual=≤
hints.settings.common.items=Mostrar sugerencias para:
hints.settings.dont.show.lambda.receivers.parameters=No mostrar los receptores y parámetros implícitos
hints.settings.dont.show.lambda.return=No mostrar sugerencias de expresión de retorno
hints.settings.dont.show.ranges=No mostrar sugerencias de rangos
hints.settings.dont.show.suspending=No mostrar sugerencias de suspensión de llamadas
hints.settings.dont.show.types.parameter=No mostrar el tipo de parámetro de la función
hints.settings.dont.show.types.property=No mostrar sugerencias de tipos de propiedad
hints.settings.dont.show.types.return=No mostrar pistas del tipo de valor retornado de la función
hints.settings.dont.show.types.variable=No mostrar pistas de tipo de variable local
hints.settings.excluded.parameters=Nombre de parámetro excluido
hints.settings.lambda.receivers.parameters=Receptores implícitos y parámetros
hints.settings.lambda.return=Expresiones return
hints.settings.lambdas=Lambas
hints.settings.parameters=Parámetros
hints.settings.ranges=Rangos
hints.settings.show.lambda.receivers.parameters=Mostrar receptor implícito y parámetros sugeridos
hints.settings.show.lambda.return=Mostrar sugerencias de expresiones de retorno
hints.settings.show.ranges=Mostrar sugerencias de rangos
hints.settings.show.suspending=Mostrar sugerencias de llamada en suspenso
hints.settings.show.types.parameter=Mostrar hints del tipo del parámetro de función
hints.settings.show.types.property=Mostrar sugerencias de tipo de propiedad
hints.settings.show.types.return=Mostrar sugerencias de tipo de retorno de función
hints.settings.show.types.variable=Mostrar sugerencias de tipos de variables locales
hints.settings.suspending=Suspendiendo llamadas
hints.settings.types=Tipos
hints.settings.types.parameter=Tipos de parámetros de función
hints.settings.types.property=Tipos de propiedad
hints.settings.types.return=Tipos de retorno de la función
hints.settings.types.variable=Tipos de variables locales
hints.settings.values.ranges=Rangos
hints.title.argument.name.enabled=Nombre del argumento
hints.title.codevision=Visión de Código
hints.title.dont.show.argument.name.enabled=No mostrar sugerencias para nombres de argumento
hints.title.show.argument.name.enabled=Mostrar sugerencia de nombre de argumento
hints.types=Pistas de tipos
if.null.return.break.foldable.to=Retornar/break If-Null/... plegable a '?:'
if.then.foldable.to=Si-Entonces plegable a '?:'
implement.abstract.class=Implementa clase abstracta
implement.abstract.function=Implementar función abstracta
implement.abstract.member=Implementar miembro abstracto
implement.abstract.property=Implementar propiedad abstracta
implement.as.constructor.parameter=Implementar como parámetro del constructor
implement.interface=Implementar interfaz
implement.sealed.class=Implementar clase sellada
implicit.nothing.s=Nada Implícito
implicit.parameter.it.of.enclosing.lambda.is.shadowed=Parámetro implícito 'it' de la lambda englobante es sombreada
implicit.unsafe.cast.from.dynamic.to.0=Cast implícito (no seguro) de dinámico a {0}
import.members.from.0=Importar miembros de ''{0}''
import.members.with=Importar miembros con '*'
import.optimizer.notification.text.unused.imports.not.found=Importaciones no utilizadas no encontradas
import.optimizer.progress.indicator.text.collect.imports.for=Recolectar imports para {0}
import.optimizer.text.import={0, choice, 0#importar|2#importaciones}
import.optimizer.text.non.zero=Se quitó {0} {1} {2, choice, 0#|1#, se agregó {2} {3}}
import.optimizer.text.zero=Importaciones reordenadas
import.order.button.text.add.package=Agregar paquete
import.order.button.text.down=Mover hacia abajo
import.order.button.text.remove=Quitar
import.order.button.text.up=Arriba
import.progress.text.resolve.imports=Resolución de todas las importaciones...
import.text.all.alias.imports=Importar todos los alias
import.text.all.other.imports=todas las demás importaciones
import.text.import=importar
in.class.0=En la clase ''{0}''
inaccessible.declaration=Declaración inaccesible
incomplete.destructuring.declaration.text=Declaración de desestructuración incompleta
incomplete.destructuring.fix.family.name=Añadir variables faltantes a la declaración de desestructuración
indent.raw.string=Indentar cadena sin formato
index.is.not.used.in.the.loop.body=El índice no se usa en el cuerpo del bucle
infix.call.may.be.dot.call=Llamada infija puede ser llamada con un punto.
inheritance.of.kotlin.sealed=Java {0,choice,0#interfaz|1#clase} no puede ser parte de la jerarquía sealed de Kotlin
initialize.with.constructor.parameter=Inicializar con parámetro de constructor
initialize.with.constructor.parameter.analyzing.existing.variables=Analizando las variables existentes…
inlay.kotlin.call.chains.hints=Mostrar pistas de inlay para cadenas de llamada
inlay.kotlin.lambdas.hints=Mostrar sugerencias de inserción para lambdas
inlay.kotlin.lambdas.hints.hints.lambda.receivers.parameters=Mostrar sugerencias insertadas para receptores y parámetros implícitos
inlay.kotlin.lambdas.hints.hints.lambda.return=Mostrar sugerencias incrustadas para expresiones de retorno
inlay.kotlin.parameters.hints=Mostrar nombres de parámetros en sitios de llamadas a funciones
inlay.kotlin.parameters.hints.excluded=Mostrar nombres de parámetros excluidos
inlay.kotlin.references.types.hints=Mostrar sugerencias en línea para tipos
inlay.kotlin.references.types.hints.hints.type.function.parameter=Mostrar sugerencias de inserción para los tipos de parámetro de función
inlay.kotlin.references.types.hints.hints.type.function.return=Mostrar pistas incrustadas para tipos de retorno de funciones
inlay.kotlin.references.types.hints.hints.type.property=Mostrar pistas incrustadas para tipos de propiedad
inlay.kotlin.references.types.hints.hints.type.variable=Mostrar sugerencias de incrustación para tipos de variable local
inlay.kotlin.values.hints=Mostrar sugerencias de inlay para valores
inlay.kotlin.values.hints.kotlin.values.ranges=Mostrar hints incrustados para los rangos
inline.type.parameter=Incrustar parámetro de tipo
inline.variable=Variable en línea
inline.when.argument=Argumento 'when' en línea
insert.curly.braces.around.variable=Insertar llaves alrededor de la variable
insert.explicit.delegation.call=Insertar llamada a delegación explícita
insert.number.conversion=Insertar conversión de número
inspection.add.conversion.call.display.name=Conversión explícita desde "Int" requerida desde la versión 1.9
inspection.add.kotlin.coroutines.display.name=Añadir la biblioteca de corrutinas de Kotlin
inspection.add.operator.modifier.display.name=La función debe tener el modificador 'operador'
inspection.add.variance.modifier.display.name=El parámetro de tipo puede tener varianza 'in' o 'out'
inspection.ambiguous.expression.when.branch.migration.display.name=Expresiones lógicas ambiguas en las ramas 'when' desde la versión 1.7
inspection.array.in.data.class.display.name=Propiedad de array en clase de datos
inspection.boolean.literal.argument.display.name=Argumento literal booleano sin nombre de parámetro
inspection.can.be.parameter.display.name=El parámetro del constructor no se utiliza nunca como una propiedad
inspection.can.be.primary.constructor.property.display.name=La propiedad está explícitamente asignada al parámetro del constructor
inspection.can.be.val.display.name=La variable 'var' no se modifica y se puede declarar como 'val'
inspection.can.sealed.subclass.be.object.display.name=Subclase sellada sin estado y equals sobreescrito
inspection.cascade.if.display.name=El 'if' de cascada se puede reemplazar por 'when'
inspection.class.name.display.name=Convención de nomenclatura de clases
inspection.complex.redundant.let.display.name=Llamada de 'let' redundante basada en argumentos
inspection.conflicting.extension.property.display.name=La propiedad de la extensión entra en conflicto con la sintética
inspection.const.property.name.display.name=Convención de nombramiento de propiedad const
inspection.constant.condition.if.display.name=La condición de la expresión 'if' es constante
inspection.control.flow.with.empty.body.display.name=Flujo de control con cuerpo vacío
inspection.convert.argument.to.set.display.name=El argumento se puede convertir a 'Set' para mejorar el rendimiento
inspection.convert.call.chain.into.sequence.display.name=La cadena de llamada en la colección podría convertirse en 'Sequence' para mejorar el rendimiento
inspection.convert.lambda.to.reference.display.name=Puede sustituirse por referencia de función
inspection.convert.na.n.equality.display.name=Convertir la comparación de igualdad con 'NaN' a llamada 'isNaN'
inspection.convert.object.to.data.object.display.name=Convertir 'object' a 'data object'
inspection.convert.pair.constructor.to.to.function.display.name=Convertir constructor Pair a la función 'a'
inspection.convert.reference.to.lambda.display.name=Se puede reemplazar por lambda
inspection.convert.secondary.constructor.to.primary.display.name=Convertir a constructor primario
inspection.convert.to.string.template.display.name=Concatenación de cadenas que se puede convertir en una plantilla de cadena
inspection.convert.try.finally.to.use.call.display.name=Convertir try / finally en llamada use()
inspection.convert.two.comparisons.to.range.check.display.name=Las dos comparaciones deben convertirse a una verificación de rango
inspection.copy.without.named.arguments.display.name='copiar' método de clase de datos es llamado sin argumentos nombrados
inspection.data.class.private.constructor.display.name=El constructor de la clase de datos privado se expone a través del método 'copiar'
inspection.deferred.is.result.display.name=Función que devuelve Deferred directamente
inspection.deferred.result.unused.display.name=El resultado '@Deferred' no se utiliza
inspection.delegation.to.var.property.display.name=Delegando a propiedad 'var'
inspection.deprecated.callable.add.replace.with.display.name=@Deprecated anotación sin argumento 'replaceWith'
inspection.deprecated.enum.declaring.class.property=Propiedad 'Enum.declaringClass' obsoleta
inspection.deprecated.gradle.dependency.display.name=Se utiliza una librería obsoleta en Gradle
inspection.deprecated.inline.class.text=Clase en línea no recomendada
inspection.deprecated.inline.classes.migration.display.name=Las clases en línea están en desuso desde la 1.5
inspection.deprecated.maven.dependency.display.name=Se ha usado una librería obsoleta en Maven
inspection.destructure.display.name=Usa la declaración de desestructuración
inspection.destructuring.wrong.name.display.name=La variable en la declaración de desestructuración utiliza el nombre de una propiedad de clase de datos incorrecta
inspection.different.kotlin.gradle.version.display.name=Las versiones del complemento de Gradle y el IDE de Kotlin son diferentes
inspection.different.kotlin.maven.version.display.name=Las versiones del complemento IDE y Maven son diferentes
inspection.different.maven.stdlib.version.display.name=Las versiones de la biblioteca y el plugin maven son diferentes
inspection.different.stdlib.gradle.version.display.name=Las versiones de las bibliotecas Kotlin y del complemento Gradle son distintas
inspection.do.not.propagate.method.deprecation.through.overrides=No propagar la deprecación del método por sobrescritura desde la versión 1.9
inspection.empty.range.display.name=El rango con inicio mayor que endInclusive está vacío
inspection.enum.entry.name.display.name=Convención de nombres de entradas de enumeraciones
inspection.enum.values.method.soft.deprecate.in.java.display.name=Se recomienda reemplazar 'Enum.values()' por 'Enum.getEntries()' desde Kotlin 1.9
inspection.enum.values.method.soft.deprecate.migration.display.name=Se recomienda que 'Enum.values()' sea reemplazado por 'Enum.entries' desde la versión 1.9
inspection.equals.or.hash.code.display.name=equals() y 'hashCode()' no están emparejados
inspection.explicit.this.display.name=Redundancia en el 'this' explícito
inspection.fake.jvm.field.constant.display.name=Propiedad Kotlin no const utilizada como constante Java
inspection.filter.is.instance.call.with.class.literal.argument.display.name=llamada 'filterIsInstance' con un argumento literal de clase
inspection.filter.is.instance.call.with.class.literal.argument.quick.fix.text=Reemplazar argumento de literal de clase con parámetro de tipo reificado
inspection.fold.initializer.and.if.to.elvis.display.name=Retorno/rotura If-Null plegable a '? :'
inspection.for.each.parameter.not.used.display.name=Los elementos iterados no se usan en forEach
inspection.from.closed.range.migration.display.name=Paso MINVALUE en fromClosedRange() desde 1.3
inspection.function.name.display.name=Convención de nomenclatura de funciones
inspection.function.with.lambda.expression.body.display.name=Función con '= { ... }' y tipo de retorno inferido
inspection.gradle.kotlinx.coroutines.deprecation.display.name=Se utiliza una dependencia de kotlinx.coroutines incompatible con Kotlin 1.3+ en Gradle
inspection.has.platform.type.display.name=La función o propiedad tiene un tipo de plataforma
inspection.if.then.to.elvis.display.name=If-Then desplegable a '?:'
inspection.if.then.to.safe.access.display.name=If-Then a '?.
inspection.implicit.nullable.nothing.type.display.name=Tipo implícito 'Nothing?'
inspection.implicit.this.action.name=Añadir "this" explícito
inspection.implicit.this.display.name=Implícito 'this'
inspection.incomplete.destructuring.declaration.display.name=Declaración de desestructuración incompleta
inspection.inconsistent.comment.for.java.parameter.display.name=Comentario inconsistente para el parámetro Java
inspection.introduce.when.subject.display.name=un argumento puede introducirse para simplificar "when"
inspection.java.collections.static.method.display.name=Las llamadas a métodos estáticos de colecciones Java pueden remplazarse con Kotlin stdlib
inspection.java.collections.static.method.on.immutable.list.display.name=Llamada del método mutador Java en una colección inmutable de Kotlin
inspection.java.io.serializable.object.must.have.read.resolve.display.name=Un objeto serializable debe implementar 'readResolve'
inspection.java.io.serializable.object.must.have.read.resolve.quick.fix.name=Implementar 'readResolve'
inspection.java.io.serializable.object.must.have.read.resolve.warning=El objeto serializable debe implementar 'readResolve'
inspection.java.map.for.each.display.name=La llamada al método Java Map.forEach debe remplazarse con el método forEach de Kotlin
inspection.join.declaration.and.assignment.display.name=Combinar declaración y asignación
inspection.join.declaration.and.assignment.option.report.with.complex.initialization.of.member.properties=Informar con inicialización compleja de propiedades de miembros
inspection.k.doc.missing.documentation.display.name=Comentarios KDoc ausentes para declaraciones públicas
inspection.k.doc.unresolved.reference.display.name=Referencia no resuelta en KDoc
inspection.kotlin.catch.may.ignore.exception.display.name='bloque `catch` puede ignorar la excepción`
inspection.kotlin.constant.conditions.display.name=Condiciones constantes
inspection.kotlin.covariant.equals.display.name=Covariante 'equals()'
inspection.kotlin.deprecation.display.name=Uso de sintaxis redundante o en desuso o de símbolos descontinuados
inspection.kotlin.double.negation.action.name=Quitar doble negación redundante
inspection.kotlin.double.negation.display.name=Doble negación redundante
inspection.kotlin.equals.between.inconvertible.types.display.name='equals()' entre objetos de tipos no convertibles
inspection.kotlin.internal.in.java.display.name=Uso de declaraciones internas de Kotlin desde Java
inspection.kotlin.invalid.bundle.or.property.display.name=Clave de propiedad no válida
inspection.kotlin.jvm.annotation.in.java.description=La anotación Kotlin JVM ''{0}'' no tiene ningún efecto en Java
inspection.kotlin.jvm.annotation.in.java.display.name=Anotación de Kotlin JVM en Java
inspection.kotlin.maven.plugin.phase.display.name=El plugin Maven de Kotlin está mal configurado
inspection.kotlin.options.to.compiler.options.display.name=Uso de DSL 'kotlinOptions' obsoleto
inspection.kotlin.redundant.override.display.name=Método de override redundante
inspection.kotlin.redundant.suppression.display.name=Supresión de diagnóstico redundante
inspection.kotlin.sealed.in.java.display.name=Herencia de interfaz/clase sellada Kotlin en Java
inspection.kotlin.test.j.unit.display.name=kotlin-test-junit se puede utilizar
inspection.kotlin.throwable.not.thrown.display.name=Throwable no lanzado
inspection.kotlin.unused.import.display.name=Directiva de importación no utilizada
inspection.kotlin.unused.variable.display.name=Variable no utilizada
inspection.lateinit.var.overrides.lateinit.var.display.name=propiedad 'lateinit var' reemplaza a propiedad 'lateinit var'
inspection.leaking.this.display.name=Fuga de 'this' en el constructor
inspection.lift.return.or.assignment.display.name=Se puede extraer la devolución o asignación
inspection.lift.return.or.assignment.option.only.single.statement=Informar solo si cada rama es una sentencia única
inspection.local.variable.name.display.name=Convención de nomenclatura de variables de ámbito local
inspection.logger.initialized.with.foreign.class.display.name=Registro inicializado con clase externa
inspection.logger.placeholder.count.matches.argument.count.display.name=El número de marcadores no coincide con el número de argumentos en la llamada al registro
inspection.loop.to.call.chain.display.name=El bucle puede ser reemplazado con operaciones stdlib
inspection.main.function.return.unit.display.name=La función principal debe devolver 'Unit'
inspection.map.get.with.not.null.assertion.operator.display.name='map.get()' con operador de afirmación distinto de nulo (!!)
inspection.maven.coroutines.deprecation.display.name=Dependencia kotlinx.coroutines incompatible se utiliza con Kotlin 1.3+ en Maven
inspection.may.be.constant.display.name=Posiblemente 'const'
inspection.member.visibility.can.be.private.display.name=El miembro de clase puede tener la visibilidad 'privada'
inspection.message.cast.will.always.fail=Casteo siempre fallará
inspection.message.condition.always.false=La condición ''{0}'' siempre es falsa
inspection.message.condition.always.false.when.reached=La condición ''{0}'' siempre es falsa cuando se alcanza
inspection.message.condition.always.true=La condición ''{0}'' siempre es verdadera
inspection.message.condition.always.true.when.reached=La condición ''{0}'' es siempre verdadera cuando se alcanza
inspection.message.empty.catch.block=Bloque catch vacío
inspection.message.for.never.visited=el rango 'for' siempre está vacío
inspection.message.inconsistent.parameter.name.for.0=Nombre inconsistente de parámetro para ''{0}''
inspection.message.index.out.of.bounds=El índice siempre está fuera de límites
inspection.message.nonnull.cast.will.always.fail=La operación siempre fallará porque el operando siempre es nulo
inspection.message.object.with.manual.tostring.can.be.converted.to.data.object='object' con 'toString' manual se puede convertir a 'data object'
inspection.message.sealed.object.can.be.converted.to.data.object=el sub-objeto 'sealed' puede ser convertido a 'data object'
inspection.message.value.always.false=El valor de '{0}' es siempre falso
inspection.message.value.always.null=El valor de ''{0}'' es siempre nulo
inspection.message.value.always.true=El valor de ''{0}'' siempre es verdadero
inspection.message.value.always.zero=El valor de ''{0}'' siempre es cero
inspection.message.when.condition.always.false=la rama "when" nunca es alcanzable
inspection.migrate.diagnostic.suppression.display.name=El nombre de Diagnóstico debe ser reemplazado
inspection.move.lambda.outside.parentheses.display.name=Argumento Lambda dentro de paréntesis
inspection.move.suspicious.callable.reference.into.parentheses.display.name=Referencia a función sospechosa usada como resultado de lambda
inspection.move.variable.declaration.into.when.display.name=Declaración de variable puede moverse dentro de 'when'
inspection.nested.lambda.shadowed.implicit.parameter.display.name=La lambda anidada tiene un parámetro implícito sombreado
inspection.no.actual.for.expect.display.name=Falta actual para expect
inspection.non.exhaustive.when.statement.migration.display.name=Las sentencias 'when' no exhaustivas estarán prohibidas desde la 1.7
inspection.null.checks.to.safe.call.display.name=Comprobación de nulidad que puede reemplazarse por llamada segura
inspection.nullable.boolean.elvis.action.name=Utiliza comprobación de igualdad en vez de elvis para comprobación booleana anulable
inspection.nullable.boolean.elvis.display.name=La comprobación de igualdad puede usarse en lugar del operador elvis para una verificación booleana nullable
inspection.object.literal.to.lambda.display.name=El literal del objeto se puede convertir a lambda
inspection.object.private.property.name.display.name=Convención de nomenclatura de propiedad privada de objecto
inspection.object.property.name.display.name=Convención de nomenclatura de propiedades de objeto
inspection.obsolete.experimental.coroutines.display.name=Usos de las coroutines experimentales están prohibidos desde 1.3
inspection.obsolete.kotlin.js.packages.display.name=los paquetes 'kotlin.browser' y 'kotlin.dom' están en desuso desde la versión 1.4
inspection.optional.expectation.display.name=La anotación esperada opcional no tiene una anotación real
inspection.package.directory.mismatch.display.name=El nombre del paquete no coincide con el directorio contenedor
inspection.package.name.display.name=Convención de nomenclatura de paquetes
inspection.platform.extension.receiver.of.inline.display.name='inline fun' con receptor nulo hasta Kotlin 1.2
inspection.private.property.name.display.name=Convención de nombres de propiedades privadas
inspection.progression.resolution.change.migration.display.name=Cambio de resolución de progreso desde 1.9
inspection.prohibit.jvm.overloads.on.constructors.of.annotation.classes.migration.display.name=La anotación '@JvmOverloads' no puede usarse en constructores de clases de anotación desde 1.4
inspection.prohibit.repeated.use.site.target.annotations.migration.display.name=Anotación repetida que no está marcada como '@Repeatable'
inspection.prohibit.type.parameters.for.local.variables.migration.display.name=Variable local con parámetros de tipo
inspection.prohibit.use.site.target.annotations.on.super.types.migration.display.name=Objetivos de anotaciones sin sentido en supertipos
inspection.property.name.display.name=Convención de nombres de propiedad
inspection.protected.in.final.display.name='protected' la visibilidad es efectivamente 'privada' en una clase final
inspection.public.api.implicit.type.display.name=Declaración API pública con tipo de retorno implícito
inspection.recursive.equals.call.display.name=Llamada recursiva de equals
inspection.recursive.property.accessor.display.name=Propiedad Acceder Recursivamente
inspection.redundant.anonymous.function.description=Creación innecesaria de función anónima
inspection.redundant.assequence.call=Llamada redundante 'asSequence'
inspection.redundant.async.display.name=Llamada 'async' redundante
inspection.redundant.companion.reference.display.name=Referencia 'Companion' redundante
inspection.redundant.else.in.if.display.name='else' redundante en 'if'
inspection.redundant.elvis.return.null.descriptor="Redundante ': return null'"
inspection.redundant.elvis.return.null.display.name=Devuelve '?: retornar null' redundante
inspection.redundant.empty.initializer.block.display.name=Bloque de inicialización vacío redundante
inspection.redundant.enum.constructor.invocation.display.name=Invocación del constructor de enumeración redundante
inspection.redundant.explicit.type.display.name=Tipo explícito obvio
inspection.redundant.getter.display.name=Getter de propiedad redundante
inspection.redundant.if.display.name=Sentencia 'if' redundante
inspection.redundant.inner.class.modifier.descriptor=Modificador 'inner' redundante
inspection.redundant.inner.class.modifier.display.name=Modificador 'inner' redundante
inspection.redundant.label.migration.display.name=Etiqueta redundante
inspection.redundant.label.text=Etiqueta redundante
inspection.redundant.labeled.return.on.last.expression.in.lambda.display.name=Retorno con etiqueta redundante en la última expresión en lambda
inspection.redundant.lambda.arrow.display.name=Flecha lambda redundante
inspection.redundant.lambda.description=Creación de lambda redundante
inspection.redundant.lambda.or.anonymous.function.display.name=Creación redundante de lambda o función anónima
inspection.redundant.lambda.or.anonymous.function.fix=Incrustar el cuerpo
inspection.redundant.modality.modifier.display.name=Modificador de modalidad redundante
inspection.redundant.not.null.extension.receiver.of.inline.display.name=El receptor de extensión de la función `inline` puede ser explícitamente nullable para Kotlin 1.2
inspection.redundant.nullable.return.type.display.name=Tipo de retorno redundante que acepta null
inspection.redundant.object.type.check.display.name=Comprobación de tipo 'es' no idiomática para un objeto
inspection.redundant.require.not.null.call.display.name=Llamada redundante a 'requireNotNull' o 'checkNotNull'
inspection.redundant.return.label.display.name=Etiqueta "return" redundante
inspection.redundant.run.catching.display.name=Llamada redundante de 'runCatching'
inspection.redundant.sam.constructor.display.name=Constructor SAM redundante
inspection.redundant.semicolon.display.name=Punto y coma redundante
inspection.redundant.setter.display.name=Setter de propiedad redundante
inspection.redundant.suspend.modifier.display.name=Modificador 'suspend' redundante
inspection.redundant.unit.expression.display.name=Expresión redundante "unidad"
inspection.redundant.unit.return.type.action.name=Eliminar tipo de retorno 'Unit' redundante
inspection.redundant.unit.return.type.display.name=Tipo de retorno 'Unit' redundante
inspection.redundant.value.argument.annotation=El argumento de valor coincide con el valor predeterminado del parámetro ''{0}''
inspection.redundant.value.argument.display.name=Argumento de valor redundante
inspection.redundant.visibility.modifier.display.name=Modificador de visibilidad redundante
inspection.redundant.with.display.name=Llamada redundante 'with'
inspection.remove.curly.braces.from.template.display.name=Llaves redundantes en la plantilla de cadena
inspection.remove.empty.class.body.display.name=Reemplazar el cuerpo de clase vacío
inspection.remove.empty.parentheses.from.annotation.entry.display.name=Quitar paréntesis vacíos de la visualización de la entrada de anotación
inspection.remove.empty.parentheses.from.lambda.call.action.name=Eliminar paréntesis innecesarios de llamada de función con lambda
inspection.remove.empty.parentheses.from.lambda.call.display.name=Paréntesis vacíos innecesarios en llamada de función con lambda
inspection.remove.empty.primary.constructor.display.name=Constructor primario vacío redundante
inspection.remove.empty.secondary.constructor.body.display.name=Cuerpo redundante del constructor
inspection.remove.explicit.super.qualifier.display.name=Calificación de supertipo innecesaria
inspection.remove.explicit.type.arguments.display.name=Argumento de tipo explícito innecesario
inspection.remove.for.loop.indices.display.name=Índice de bucle no usado
inspection.remove.redundant.backticks.display.name=Acento grave redundante
inspection.remove.redundant.calls.of.conversion.methods.display.name=Llamada redundante de método de conversión
inspection.remove.redundant.qualifier.name.display.name=Nombre de calificador redundante
inspection.remove.redundant.spread.operator.display.name=Redundante operador spread
inspection.remove.setter.parameter.type.display.name=Tipo de parámetro del setter redundante
inspection.remove.single.expression.string.template.display.name=Plantilla de cadena redundante
inspection.remove.to.string.in.string.template.display.name=Llamada redundante a 'toString()' en la plantilla de literal de cadena
inspection.replace.array.equality.op.with.arrays.equals.display.name=Comparación por medio de '==' y '!=' entre Arrays
inspection.replace.array.of.with.literal.display.name='arrayOf' puede remplazarse con el literal de arreglo [...]
inspection.replace.assert.boolean.with.assert.equality.display.name=Se podría reemplazar la afirmación de booleano con una igualdad de afirmaciones
inspection.replace.associate.function.display.name='associate' se puede reemplazar con 'associateBy' o 'associateWith'
inspection.replace.call.with.binary.operator.display.name=Se puede reemplazar con un operador binario
inspection.replace.collection.count.with.size.display.name=El recuento de colección se puede convertir a tamaño
inspection.replace.get.or.set.display.name=Llamada explícita de 'get' o 'set'
inspection.replace.guard.clause.with.function.call.display.name=La cláusula de protección se puede reemplazar con una llamada a función de Kotlin
inspection.replace.isempty.with.ifempty.display.name='if' la condición puede reemplazarse con invocación lambda
inspection.replace.java.static.method.with.kotlin.analog.display.name=Los métodos de Java deben ser sustituidos por análogos de Kotlin
inspection.replace.manual.range.with.indices.calls.display.name=El rango puede ser convertido a índices o iteraciones
inspection.replace.mapIndexed.with.list.generator.display.name=Sustituir 'mapIndexed' por un generador de lista
inspection.replace.negated.is.empty.with.is.not.empty.display.name=Se puede simplificar la llamada negada
inspection.replace.not.null.assertion.with.elvis.return.display.name=La aserción no nula se puede reemplazar con 'return'
inspection.replace.put.with.assignment.display.name='map.put()' se puede convertir en asignación
inspection.replace.range.start.end.inclusive.with.first.last.display.name=Las propiedades en caja deberían reemplazarse por propiedades sin caja
inspection.replace.range.to.with.rangeUntil.display.name=rangeTo o se debe reemplazar la llamada '..' con '..<'
inspection.replace.range.to.with.until.display.name='rangeTo' o la llamada '..' debe ser reemplazado con 'until'
inspection.replace.readline.with.readln.display.name='readLine' puede ser reemplazado por 'readln' o 'readlnOrNull'
inspection.replace.size.check.with.is.not.empty.display.name=La comprobación de tamaño puede reemplazarse por 'isNotEmpty()'
inspection.replace.size.zero.check.with.is.empty.display.name=La verificación de tamaño cero se puede reemplazar con 'isEmpty()'
inspection.replace.string.format.with.literal.display.name="La llamada 'String.format' se puede reemplazar con plantillas de cadena"
inspection.replace.substring.with.drop.last.display.name='substring' debería reemplazarse por la llamada 'dropLast'
inspection.replace.substring.with.indexing.operation.display.name=La llamada a 'substring' debe reemplazarse con operación de indexación
inspection.replace.substring.with.substring.after.display.name=La llamada 'substring' debería ser reemplazada por 'substringAfter'
inspection.replace.substring.with.substring.before.display.name='substring' debe ser reemplazada por 'substringBefore'
inspection.replace.substring.with.take.display.name=La llamada 'substring' debería reemplazarse con la llamada 'take'
inspection.replace.to.string.with.string.template.display.name=La llamada de "toString" podría ser remplazada con un string template
inspection.replace.to.with.infix.form.display.name='to' debe reemplazar la llamada por la forma de infijo
inspection.replace.until.with.rangeUntil.operator.display.name=Reemplazar 'until' con el operador '..<'
inspection.replace.with.enum.map.display.name='HashMap' puede reemplazarse con 'EnumMap'
inspection.replace.with.ignore.case.equals.display.name=Debe ser reemplazado con 'equals(..., ignoreCase = true)'
inspection.replace.with.import.alias.display.name=El nombre plenamente calificado puede ser reemplazado con un alias de importación existente
inspection.replace.with.operator.assignment.display.name=Se puede reemplazar asignación con operador de asignación
inspection.replace.with.string.builder.append.range.display.name='Llamada a StringBuilder.append(CharArray, offset, len) en la JVM'
inspection.restrict.return.statement.target.migration.display.name=La etiqueta de destino no indica una función desde 1.4
inspection.runblocking.analysis.found.runblocking=--> runBlocking
inspection.runblocking.analysis.graphbuilding.progress=Procesando {0}
inspection.runblocking.presentation.descriptor=Analizando runBlocking:
inspection.runblocking.presentation.display.name=RunBlocking dentro de corrutina
inspection.runblocking.presentation.settings.exploration.option.all=Sí, incluyendo sobreescritura
inspection.runblocking.presentation.settings.exploration.option.declaration=Sí, excluir superposiciones
inspection.runblocking.presentation.settings.exploration.option.strict=no
inspection.runblocking.presentation.settings.exploration.title=Explorar función que sobrescribe
inspection.runblocking.presentation.text=RunBlocking builder llamado desde una corrutina
inspection.safe.cast.with.return.display.name=Los casts seguros con 'return' deberían remplazarse por una comprobación de tipo 'if'
inspection.scope.function.conversion.display.name=La función del ámbito se puede convertir en otra
inspection.self.assignment.display.name=Asignación redundante
inspection.self.reference.constructor.parameter.display.name=El constructor nunca podrá completarse
inspection.setter.backing.field.assignment.display.name=Campo existente de respaldo sin asignación
inspection.simple.redundant.let.display.name=Llamada 'let' basada en receptor redundante
inspection.simplifiable.call.chain.display.name=Se puede simplificar la llamada en cadena para el tipo de colección
inspection.simplifiable.call.display.name=Es posible simplificar la llamada a la función de biblioteca
inspection.simplifiable.scope.function.display.name=Se puede simplificar la función de ámbito con forEach anidado
inspection.simplify.assert.not.null.display.name='assert' se puede reemplazar con '!!' o '?:'
inspection.simplify.boolean.with.constants.display.name=La expresión bool puede simplificarse
inspection.simplify.negated.binary.expression.display.name=La expresión booleana negada se puede simplificar
inspection.simplify.when.with.boolean.constant.condition.display.name=Simplificable 'when'
inspection.sort.modifiers.display.name=Orden de modificadores no canónico
inspection.suspend.function.on.coroutine.scope.display.name=coroutineContext ambiguo debido al receptor CoroutineScope de la función suspend
inspection.suspicious.as.dynamic.display.name=Invocación de miembro sospechoso 'asDynamic'
inspection.suspicious.collection.reassignment.display.name=La asignación aumentada crea una nueva colección debajo del motor
inspection.suspicious.equals.combination.display.name=Combinación sospechosa de == y ===
inspection.suspicious.var.property.display.name=Propiedad 'var' sospechosa: su setter no influye en el resultado de su getter
inspection.test.function.name.display.name=Convención de naming de funciones de tests
inspection.this.class.does.not.have.a.constructor=Llamada a constructor prohibida
inspection.trailing.comma.add.line.break=Añadir salto de línea
inspection.trailing.comma.add.trailing.comma=Añadir coma al final
inspection.trailing.comma.comma.loses.the.advantages.in.this.position=La coma pierde las ventajas en esta posición
inspection.trailing.comma.display.name=Recomendaciones para comas finales
inspection.trailing.comma.fix.comma.position=Corregir posición de la coma
inspection.trailing.comma.missing.line.break=Falta salto de línea
inspection.trailing.comma.missing.trailing.comma=Falta coma al final
inspection.trailing.comma.remove.trailing.comma=Remover la coma final
inspection.trailing.comma.report.also.a.missing.comma=Reportar también una coma o un salto de línea faltante
inspection.trailing.comma.useless.trailing.comma=Coma final innecesaria
inspection.unlabeled.return.inside.lambda.display.name=Retorno sin etiqueta dentro de lambda
inspection.unnecessary.opt_in.annotation.display.name=Anotación '@OptIn' innecesaria
inspection.unnecessary.opt_in.redundant.annotation=La anotación opt-in es redundante: no se usa ninguna API experimental coincidente
inspection.unnecessary.opt_in.redundant.marker=El marcador de inclusión es redundante: no se utiliza la API experimental marcada con ''{0}''
inspection.unnecessary.opt_in.remove.annotation.fix.family.name=Eliminar anotación
inspection.unnecessary.opt_in.remove.marker.fix.family.name=Eliminar marcador de opt-in
inspection.unnecessary.variable.display.name=Variable local innecesaria
inspection.unnecessary.variable.option.report.immediately.returned.variables=Informar variables devueltas inmediatamente
inspection.unsafe.cast.from.dynamic.display.name=Conversión implícita (insegura) de tipo dinámica
inspection.unused.equals.display.name=Expresión equals no utilizada
inspection.unused.lambda.expression.body.display.name=Valor de retorno sin usar de una función con cuerpo de expresión lambda
inspection.unused.main.parameter.display.name=El parámetro principal no es necesario
inspection.unused.receiver.parameter=Parámetro receptor nunca utilizado
inspection.unused.receiver.parameter.display.name=Parámetro receptor no usado
inspection.unused.result.of.data.class.copy=Resultado sin usar de la copia de la clase de datos
inspection.unused.symbol.display.name=Símbolo no utilizado
inspection.unused.unary.operator.display.name=Operador unario sin usar
inspection.use.expression.body.display.name=Es preferible usar un cuerpo de expresión aquí
inspection.use.property.access.syntax.display.name=Llamada de accessor que se puede sustituir por sintaxis de acceso de propiedad
inspection.use.with.index.display.name=La variable de índice incrementada manualmente puede reemplazarse con el uso de 'withIndex()'
inspection.useless.call.on.collection.display.name=Llamada inútil sobre el tipo colección
inspection.useless.call.on.not.null.display.name=Llamada inútil en tipo no nulo
inspection.verbose.nullability.and.emptiness.call=Reemplazar verificaciones siguientes con llamada ''{0}()''
inspection.verbose.nullability.and.emptiness.display.name=Inspección detallada de nulidad y vacío
inspection.warning.on.main.unused.parameter.migration.display.name=Argumentos 'args' desusados en 'main' desde 1.4
inspection.when.with.only.else.action.name=Simplificar 'when' con solo una rama 'else'
inspection.when.with.only.else.display.name='when' solo tiene ramas 'else' y puede simplificarse
inspection.wrap.unary.operator.display.name=Uso ambiguo de un operador unario con una constante numérica
intention.add.import.alias.group.name=Añadir alias de importación
intention.change.package.text=Cambiar paquete
intention.convert.lambda.line=Convertir a lambda de {0,choice,0#una|1#múltiples} líneas
intention.create.test.dialog.kotlin=Kotlin (pruebas)
intention.error.cannot.create.class.message=No se puede crear la clase ''{0}''
intention.error.cannot.create.class.title=No se pudo crear la clase
intention.extract.declarations.from.file.text=Extraer declaracion del archivo actual
intention.extract.declarations.from.file.text.details=Extraer ''{0}'' {1, choice, 0#|1#y subclases} del archivo actual
intention.flow.on.dispatchers.io=Flow en 'Dispatchers.IO'
intention.implement.abstract.method.command.name=Implementar método
intention.implement.abstract.method.searching.for.descendants.progress=Buscando descendientes…
intention.name.specify.supertype=Especificar supertipo
intention.name.use.correct.parameter.name=Usa el nombre de parámetro correcto
intention.switch.context.to.dispatchers.io=Cambiar al contexto 'Dispatchers.IO'
intention.trailing.comma.custom.text={0,choice,0#Activar|1#Desactivar} una coma final por defecto en el formateador
intention.trailing.comma.text=Habilitar/Deshabilitar una coma final en el formateador
intention.wrap.in.with.context=Envolver llamada en 'withContext'
interface=Interfaz
interface.member.dependency.required.by.interfaces=Requerido por {0,choice,1#interfaz|2#interfaces}
interface.should.be.external=La interfaz debería de ser externa
internal.toggle.throwing.cached.pce.title=Interno: Incluir PCE cacheados
introduce.0.as.subject.0.when=Introducir ''{0}'' como sujeto de ''cuando''
introduce.anonymous.parameter.fix.family.name=Introducir parámetro anónimo
introduce.backing.property=Introducir propiedad de respaldo
introduce.constant=Introducir constante
introduce.import.alias=Introducir alias de importación
introduce.property=Introducir propiedad
introduce.type.parameter=Introducir parámetro tipo
introduce.type.parameter.to.declaration=Introducir parámetro tipo en la declaración
introduce.variable=Introducir Variable
introduce.when.subject=Introduce el sujeto 'when'
invert.if.condition=Invertir condición 'if'
it.s.prohibited.to.call.0.with.min.value.step.since.1.3=Está prohibido llamar a {0} con paso MINVALUE desde 1.3
iterate.over.0=Iterar sobre ''{0}''
iterate.over.collection=Iterar sobre colección
java.collections.static.method.call.should.be.replaced.with.kotlin.stdlib=La llamada al método estático de colecciones de Java debe reemplazarse con la biblioteca estándar de Kotlin
java.map.foreach.method.call.should.be.replaced.with.kotlin.s.foreach=La llamada del método forEach de Java Map se debería reemplazar con forEach de Kotlin
join.declaration.and.assignment=Une declaración y asignación
join.with.initializer.fix.text=Unir con inicializador
junit.static.methods=Métodos estáticos de JUnit
kdoc.comment.unresolved=Sin resolver
kdoc.section.title.author=Autores
kdoc.section.title.constructor=Constructor
kdoc.section.title.parameters=Parámetros
kdoc.section.title.properties=Propiedades
kdoc.section.title.receiver=Receptor
kdoc.section.title.returns=Retorna
kdoc.section.title.samples=Muestras
kdoc.section.title.see.also=Véase también
kdoc.section.title.since=Desde
kdoc.section.title.suppress=Supresor
kdoc.section.title.throws=Lanza
kmp.move.not.supported.message=Todavía puedes mover, pero la declaración esperada/real coincidente no se moverá.
kmp.move.not.supported.title=No se admite el desplazamiento multiplataforma
kotlin.call.chains.hints=Kotlin: Mostrar sugerencias de incrustación para cadenas de llamadas
kotlin.compiler.configurable=Compilador Kotlin
kotlin.dist.downloading.failed.group.name=Fallo la descarga de Kotlin dist
kotlin.external.compiler.updates.notification.group.name=Disponible actualización del compilador externo Kotlin
kotlin.jps.plugin.group.name=Grupo de plugin Kotlin JPS
kotlin.lambdas.hints=Kotlin: Mostrar sugerencias de inserción para lambdas
kotlin.lambdas.hints.hints.lambda.receivers.parameters=Kotlin: Mostrar indicadores de inserción para receptores y parámetros implícitos
kotlin.lambdas.hints.hints.lambda.return=Kotlin: Mostrar sugerencias en línea para expresiones de devolución
kotlin.references.types.hints=Kotlin: Mostrar sugerencias integradas para tipos
kotlin.references.types.hints.hints.type.function.parameter=Kotlin: Mostrar indicios de inserción para tipos de parámetros de función
kotlin.references.types.hints.hints.type.function.return=Kotlin: Mostrar sugerencias de retorno de tipo de función
kotlin.references.types.hints.hints.type.property=Kotlin: Mostrar sugerencias incrustadas para los tipos de propiedad
kotlin.references.types.hints.hints.type.variable=Kotlin: Mostrar pistas de incrustación para tipos de variable local
kotlin.script.definitions.model.name.autoReloadScriptDependencies=Recarga automática
kotlin.script.definitions.model.name.autoReloadScriptDependencies.description=Habilita la recarga automática de dependencias de script si quieres cargar las configuraciones del script automáticamente al cambiar el archivo
kotlin.script.definitions.model.name.is.enabled=Está Habilitado
kotlin.script.definitions.model.name.name=Nombre
kotlin.script.definitions.model.name.pattern.extension=Patrón/Extensión
kotlin.script.definitions.title=Gestionar definiciones de script
kotlin.script.in.beta.stage=Kotlin Scripting está ahora en etapa Beta
kotlin.script.in.beta.stage.link=https://kotlinlang.org/docs/components-stability.html#stability-levels-explained
kotlin.script.in.project.sources=<html>Se supone que este script no está dentro de la raíz de la fuente. Después de Kotlin 1.9 será ignorado durante la compilación del módulo.</html>
kotlin.script.in.project.sources.1.9=<html>Se supone que este script no debe estar dentro de la raíz de origen. Desde Kotlin 1.9 se ignora durante la compilación del módulo.</html>
kotlin.script.in.project.sources.allow=Permitir...
kotlin.script.in.project.sources.hide=Ocultar
kotlin.script.in.project.sources.later=Decidir más adelante
kotlin.script.in.project.sources.link=https://youtrack.jetbrains.com/issue/KT-52735
kotlin.script.in.project.sources.move=Mover a...
kotlin.script.lookup.definitions=Buscando definiciones de scripts Kotlin...
kotlin.script.sources.index=Índice
kotlin.script.sources.not.yet.indexed=Fuentes no indexadas para reducir el tiempo de inicio del proyecto
kotlin.script.warning.more.info=Más información
kotlin.scripting.configurable=Secuencias de Comandos de Kotlin
kotlin.values.hints=Mostrar sugerencias en la vista para valores
kotlin.values.hints.kotlin.values.ranges=Kotlin: Mostrar sugerencias in line para rangos
label.text.default.receiver.value=Valor predeterminado del receptor:(&D)
label.text.destination=Destino(&D):
label.text.destination.directory=Directorio de destino:(&D)
label.text.file=Archivo(&F):
label.text.file.name=Nombre de archivo:
label.text.introduce.as=Introducir como:
label.text.move.expect.actual.counterparts=Mover pares esperados/actuales(&M)
label.text.name=Nombre:(&N)
label.text.package=Paquete(&A):
label.text.package.name=Nombre del paquete:(&G)
label.text.receiver.type=Tipo de receptor:(&T)
label.text.source.sets=Sets de fuentes:
label.text.target.file.name=Nombre archivo destino:
label.text.to.class=A clase:
label.text.to.file=A archivo:(&F)
label.text.to.object=A objeto:
label.text.to.package=Paquete objetivo:(&A)
label.text.type=Tipo:(&T)
label.text.visibility=Visibilidad:(&V)
lambda.argument.0.be.moved.out=El argumento de lambda {0,choice,0#puede|1#debe} moverse fuera de los paréntesis
leaking.this.in.constructor.of.enum.class.0.with.overridable.members="this" con fugas en el constructor de la clase enum {0} (con miembros sobrescribibles)
leaking.this.in.constructor.of.non.final.class.0=Fuga de ''this'' en el constructor de la clase que no es final {0}
let.0.1=Que {0} {1}
let.type.implement.interface=Hacer que el tipo implemente la interfaz
lift.assignment.out.fix.text.0=Elevar asignación fuera de ''{0}''
lift.assignment.out.of.try.expression=Mover la asignación fuera de la expresión 'try'
lift.function.call.out.of.if=Sacar llamada a función de 'if'
lift.function.call.out.of.when=Saca la llamada a la función de 'when'
lift.return.out.fix.text.0=Extraer return de ''{0}''
lift.return.out.of.if.expression=Sacar return de la expresión 'if'
listbox.import.package=Paquete
listbox.import.with.subpackages=Con subpaquetes
livetemplate.description.anonymous=Clase anónima
livetemplate.description.closure=Cierre (función sin nombre)
livetemplate.description.exfun=Función de extensión
livetemplate.description.exval=Propiedad de solo lectura de extensión
livetemplate.description.exvar=Propiedad de lectura/escritura de extensión
livetemplate.description.fun0=Función sin parámetros
livetemplate.description.fun1=Función de un parámetro
livetemplate.description.fun2=Función con 2 parámetros
livetemplate.description.ifn=Inserta la expresión 'if null'
livetemplate.description.inn=Inserta la expresión 'if not null'
livetemplate.description.interface=Interfaz
livetemplate.description.iter=Iterador sobre los elementos de un iterable (bucle for-in)
livetemplate.description.main=función main()
livetemplate.description.maina=función main(args)
livetemplate.description.singleton=Singleton
livetemplate.description.soutp=Imprime los nombres y valores de los parámetros de función en System.out
livetemplate.description.void=Función que no devuelve nada
local.variable=Variable local
logger.initialized.with.foreign.class=Logger inicializado con clase externa ''{0}''
looking.for.usages.and.conflicts=Buscando usos y conflictos...
looking.for.usages.in.java.files=Buscando usos en archivos Java...
loop.can.be.replaced.with.stdlib.operations=El bucle puede ser reemplazado por operaciones stdlib
loop.parameter.0.is.unused=El parámetro de bucle ''{0}'' no se usa
loop.to.call.fix.family.name=Reemplazar con el stdlib de operaciones
loop.to.call.fix.family.name2=Reemplace por operaciones stdlib con uso de 'asSequence()'
make.0=Establecer {0}
make.0.1=Convertir ''{0}'' en {1}
make.0.1.explicitly=Forzar ''{0}'' {1} explícitamente
make.0.an.annotation.class=Convierte a ''{0}'' en una clase de anotación
make.0.explicitly=Hacer {0} explícitamente
make.0.in.1.open=Abrir ''{0}'' en {1}
make.0.not.1={0} no {1}
make.class.an.annotation.class=Convertir a clase de anotación
make.constructor.parameter.a.property.0=Hacer parámetro del constructor una propiedad {0}
make.member.static.quickfix=Hacer ''{0}'' estático
make.not.nullable=Hacer no anulable
make.open=Convertir en 'open'
make.open.fix.text=Hacer clase abierta
make.primary.constructor.0=Convertir el constructor principal a {0}
make.private.and.0.1=Hacer privado y {0} ''{1}''
make.private.fix.text=Convertir a privado
make.type.parameter.reified.and.function.inline=Hacer parámetros de tipo reificados y funciones en línea
making.member.static=Haciendo miembro estático...
map.get.with.not.null.assertion.operator='map.get()' con operador de aserción no nula '(!!)'
map.put.should.be.converted.to.assignment=map.put() debe convertirse a asignación
mark.as.deprecated.level.deprecationlevel.hidden=Marcar como '@Deprecated(..., level = DeprecationLevel.HIDDEN)'
max.functions.to.visit=Máximo de funciones por visitar
maximum.count.of.applied.refactoring.before.validity.check=Máximo recuento de refactorizaciones aplicadas antes de la comprobación de validez
may.contain.only.letters.and.digits=debe contener solo letras y dígitos
may.contain.only.letters.digits.or.underscores=solo puede contener letras, dígitos o guiones bajos
member.info.abstract.0=abstract {0}
member.info.companion.0=compañero {0}
merge.else.if=Combinar 'else if'
merge.if.s=fusionar 'if's
message.change.signature.is.not.applicable.to.dynamically.invoked.functions=Cambiar firma no es aplicable a funciones invocadas dinámicamente
message.do.not.show.for.local.variables.in.future=No mostrar para variables locales en el futuro
message.text.property.receiver.type.cannot.be.resolved=No se puede resolver el tipo del receptor de la propiedad ''{0}''.\n¿Continuar?
message.text.property.type.cannot.be.resolved=El tipo de propiedad ''{0}'' no se puede resolver.\n¿Continuar?
message.text.return.type.cannot.be.resolved=No se puede resolver el tipo de retorno ''{0}''.\n¿Continuar?
message.type.for.cannot.be.resolved=El tipo ''{0}'' para {1} no se ha podido resolver.\n¿Continuar?
methods.are.absent.in.coroutines.class.since.1.3=Los métodos están ausentes en la clase de corrutinas desde 1.3
microservices.url.path.inlay.hints=Kotlin: Mostrar sugerencias en línea para la ruta URL
might.be.const=Podría ser 'const'
migrate.type.parameter.list.syntax=Migrar la sintaxis de la lista de parámetros del tipo
migrate.unsupported.yield.syntax=Migrar sintaxis yield no compatible
minimal.line.count=Número mínimo de líneas
missing.documentation=Documentación faltante
modifiers.should.follow.annotations=Los modificadores deben seguir a las anotaciones
move.annotation.to.receiver.type=Mover anotación al tipo receptor
move.else.branch.to.the.end=Mover la rama else al final
move.lambda.argument.into.parentheses=Mover argumento lambda a los paréntesis
move.lambda.argument.out.of.parentheses=Mover argumento lambda fuera de paréntesis
move.members.from=Desde:
move.out.of.companion.object=Mover fuera del objeto companion
move.refactoring.error.text.cannot.perform.refactoring.since.the.following.files.already.exist=No se puede realizar el refactor porque los siguientes archivos ya existen:\n\n
move.refactoring.test=Mover prueba refactorización
move.refactoring.testing=Mover pruebas de refactorización
move.reference.into.parentheses=Mover referencia a paréntesis
move.to.class.body=Mover al cuerpo de la clase
move.to.companion.object=Mover a objeto compañero
move.to.companion.object.command=Mover al objeto compañero
move.to.constructor=Mover a constructor
move.to.constructor.parameters=Mover a parámetros del constructor
move.to.top.level=Mover al nivel superior
move.type.parameter.constraint.to.where.clause=Mover la restricción del parámetro del tipo a la cláusula 'where'
move.unary.operator.to.previous.line.fix.text=Mover el operador unario a la línea anterior
move.variable.declaration.into.when=Mover declaración de variable a 'when'
moving.to.companion.object=Moviendo a objeto companion...
name=Nombre(&N):
name.extract.interface=Extraer interfaz
name.introduce.import.alias=Introducir alias de importación
name.introduce.lambda.parameter=Introducir parámetro Lambda
name.introduce.parameter1=Introducir Parámetro
name.introduce.type.alias=Introducir alias de tipo
name.specify.supertype.command.title=Especificar supertipo
naming.convention.will.be.violated.after.rename=Se violarán convenciones de nomenclatura después de renombrar
negated.operation.can.be.simplified=Se puede simplificar la operación negada
nested.1.call.in.0.could.be.simplified.to.2=La llamada anidada "{1}" en "{0}" podría simplificarse a {2}
no.actual.for.expect.declaration=No hay actual para la declaración expect en el módulo: {0}
non.canonical.modifiers.order=Orden de modificadores no canónicos
non.external.classifier.extending.state.or.props.name=Clasificador no externo que extiende State o Props
not.found.in.0.files=No encontrado en {0} archivo(s)
nothing.to.do=Nada por hacer
notification.navigation.to.overriding.classes=No es posible navegar hacia las clases sobreescritas durante la actualización del índice
notification.text.kotlin.js.compiler.body=Usa el nuevo compilador IR de Kotlin/JS para reducir el tamaño del paquete de tu aplicación y generar automáticamente definiciones TypeScript (d.ts).
notification.text.kotlin.js.compiler.learn.more=Más información
notification.text.kotlin.js.compiler.link=https://kotl.in/jsirstable
notification.text.kotlin.js.compiler.title=Kotlin/JS IR es estable en versiones de 1.8.0 en adelante!
null.checks.replaceable.with.safe.calls=Comprobaciones de nulo pueden remplazarse con llamadas seguras
null.checks.to.safe.call.check.fix.text=Reemplazar encadenados null-check con llamadas seguras
number.of.attempts.then.files.in.project.0=Cantidad de intentos > archivos en el proyecto, {0}
object.0=Objeto "{0}"
object.or.top.level.property=Objeto o propiedad de nivel superior
object.private.property=Propiedad privada del objeto
object.should.be.external.interface=El objeto debe ser una interfaz externa
obsolete.coroutine.usage.fix.family.name=Arreglar el uso experimental de corrutinas
obsolete.coroutine.usage.in.whole.fix.family.name=Arregla usos expérimentales de corrutinas en el proyecto
obsolete.kotlin.js.packages.usage.in.whole.fix.family.name=Corregir usos de paquete 'kotlin.dom' y 'kotlin.browser' en el proyecto
obsolete.package.usage.fix.family.name=Corregir uso de paquete ''{0}''
one.line.return=Retorno de una sola línea
open.moved.members.in.editor=Abrir miembros movidos en el editor
open.moved.method.in.editor=Abrir método desplazado en el editor
optimize.imports=Optimizar importaciones
optimize.imports.collect.unused.imports=Recopilando Importaciones No Utilizadas
optimize.imports.task.removing.redundant.imports=Eliminando importaciones redundantes
optionally.expected.annotation.has.no.actual.annotation.in.module.0.for.platform.1=La anotación esperada opcionalmente no tiene ninguna anotación real en el módulo {0} de la plataforma {1}
overridden.marker.implementation=Se implementa en
overridden.marker.implementations.choose.implementation.find.usages=Propiedades sobreescritas de {0}
overridden.marker.implementations.choose.implementation.title=Seleccionar implementación de {0}
overridden.marker.implementations.multiple=Tiene implementaciones
overridden.marker.overrides=Anula en
overridden.marker.overrides.choose.implementation.find.usages=Super implementaciones de {0}
overridden.marker.overrides.choose.implementation.title=Seleccionar implementación super de {0}
overridden.marker.overrides.multiple=Anulado en subclases
override.declaration.choose.to.delete=Escoge las que quieres que se eliminen.
override.declaration.delete.multiple.parameters={0} es parte de la jerarquía de métodos. ¿Deseas eliminar múltiples parámetros?
override.declaration.member=Miembro
override.declaration.unused.overriding.methods.description=Existen miembros sin usar que sobreescriben métodos que se eliminan.
override.declaration.unused.overriding.methods.title=Miembros sin utilizar que anulan
override.declaration.x.implements.y={0} implementa {1}.
override.declaration.x.in.y={0} en {1}
override.declaration.x.overrides.y.in.class.list={0} reemplaza declaraciones en las siguientes clases/interfaces: {1} ¿Quieres {2} las declaraciones base?
package.0.already.contains.1=El paquete ''{0}'' ya contiene {1}
package.name=Nombre del paquete
package.usages.are.obsolete.since.1.4=''{0}'' usos de paquetes están obsoletos desde 1.4
parameter.0=Parámetro "{0}"
parameter.hints.old=Kotlin: Mostrar sugerencias de los inlay para parámetros
parameter.name.is.invalid=El nombre del parámetro ''{0}'' no es válido
parameter.name.prompt=Nombre de param:(&M)
parameter.type.is.invalid=El tipo de parámetre ''{0}'' no es válido
parameter.types.are.not.denotable=No se puede extraer el método ya que los siguientes tipos no son denotables en el alcance de destino:
parameter.used.in.declaration.body.warning=''{0}'' es usado en el cuerpo de la declaración
parentheses.should.be.removed=Deben quitarse los paréntesis
pass.outer.class.instance.as.parameter=Pasar instancia de clase exterior como parámetro(&O)
perform.refactoring=Realizar refactorización...
placeholder.count.matches.argument.count.fewer.problem.descriptor=Se proporcionaron menos argumentos ({0}) que los marcadores de posición especificados ({1}) #loc
placeholder.count.matches.argument.count.more.problem.descriptor=Se han proporcionado más argumentos ({0}) que los marcadores de posición especificados ({1}) #loc
popup.title.choose.supertype=Selecciona supertipo
popup.title.elements=Elementos
popup.title.expressions=Expresiones
popup.title.types=Tipos
predefined.configuration.all.methods.of.the.class=Todos los métodos de una clase
predefined.configuration.all.vars.of.the.class=Todas las vars de una clase
predefined.configuration.all.vars.of.the.object=Todas las vars de un objeto
predefined.configuration.also.match.vals=Coincidir con variables y valores
predefined.configuration.annotations=Anotaciones
predefined.configuration.anonymous.class=Clase anónima
predefined.configuration.array.access=Acceso a la matriz
predefined.configuration.assert.not.null=Operadores de aseveración no nulo
predefined.configuration.assignments=Asignaciones
predefined.configuration.casts=Conversiones
predefined.configuration.class.annotation=Clases anotadas
predefined.configuration.comments.containing.word=Comentarios que contengan una palabra determinada
predefined.configuration.companion.object.method.calls=Llamadas de método desde objeto complementario
predefined.configuration.do.while=Bucles Do...while
predefined.configuration.elvis=Operadores de Elvis
predefined.configuration.for=Para los bucles
predefined.configuration.function.annotation=Funciones anotadas
predefined.configuration.function.explicit.inferred.type=Tipo explícito e inferido
predefined.configuration.function.signature=Firma de la función
predefined.configuration.ifs=Si
predefined.configuration.instance=Instancias
predefined.configuration.kdoc.tag=Etiquetas KDoc
predefined.configuration.lambda=Expresiones lambda
predefined.configuration.method.calls=Llamadas a métodos
predefined.configuration.object.companion.object=Objeto y objeto companion
predefined.configuration.properties.getter=Propiedades con getter explícito
predefined.configuration.safe.call.operator=Operadores de llamada segura
predefined.configuration.string.literals=Literales de cadena
predefined.configuration.strings=Cadenas
predefined.configuration.strings.with.long.template=Cadenas que contienen una plantilla larga
predefined.configuration.trys=Pruebas
predefined.configuration.vars.of.given.type=Vars de tipo dado
predefined.configuration.when=Cuando es expresion
predefined.configuration.while=Ciclos while
premature.end.of.template=Fin prematuro de plantilla
preparing.move.descriptor=Preparando descriptor de movimiento
presentation.text.for.receiver.in.container.paren=(para {0} en {1})
presentation.text.for.receiver.in.container.paren.no.brackets=para {0} en {1}
presentation.text.in.container={0} en {1}
presentation.text.in.container.paren=(en {0})
presentation.text.in.container.paren.no.brackets=en {0}
presentation.text.object.in.container=Objeto en {0}
presentation.text.paren=({0})
presentation.text.paren.no.brackets={0}
print.should.be.replaced.with.logging.display.name='Llamadas a "print()" o "println()"
private.data.class.constructor.is.exposed.via.the.generated.copy.method=Constructor privado primario expuesto mediante el método 'copy()' generado de una clase 'data'.
private.property=Propiedad privada
progress.finding.implicit.nothing.s=Encontrando Nothigs implícitos
progress.looking.up.add.annotation.usage=Buscando el uso de la anotación...
progress.looking.up.sealed.subclass.usage=Buscando el uso de la subclase sellada...
progress.title.analyze.extraction.data=Analizar datos de extracción...
progress.title.calculate.occurrences=Calculando ocurrencias...
progress.title.calculating.type=Calculando tipo...
progress.title.check.for.conflicts=Comprobando conflictos...
progress.title.collect.hierarchy=Recopilación de la jerarquía de ''{0}'' ...
progress.title.collect.members.to.generate=Recopilando miembros…
progress.title.converting.to.if.then.else.expression=Convirtiendo a expresión if-then-else…
progress.title.introducing.value.for.condition=Introduciendo el valor para la condición…
progress.title.searching.for.expected.actual=Buscando esperado/actual...
project.view.class.error.name=nombre no proporcionado
project.view.class.initializer=inicializador de clase
project.view.expression=expresión
property=Propiedad
property.0=Propiedad "{0}"
property.has.an.actual.declaration.in.the.class.constructor=La propiedad tiene una definición real en el constructor de la clase
property.in.external.interface.should.be.var=La propiedad de la interfaz externa debe ser var
property.is.explicitly.assigned.to.parameter.0.can=La propiedad se asigna explícitamente al parámetro {0}, por lo que se puede declarar directamente en el constructor
property.overloaded.in.child.class.constructor=Propiedad sobrecargada en el constructor de clase hijo
protected.visibility.is.effectively.private.in.a.final.class='protected' visibilidad es efectivamente 'private' en una clase final
provide.return.value=Proporciona el valor de retorno
put.arguments.on.one.line=Colocar los argumentos en una línea
put.arguments.on.separate.lines=Colocar argumentos en líneas separadas
put.calls.on.separate.lines=Poner llamadas en líneas separadas
put.expressions.on.separate.lines=Poner expresiones en líneas separadas
put.parameters.on.one.line=Poner parámetros en una línea
put.parameters.on.separate.lines=Colocar parámetros en líneas separadas
quick.doc.no.documentation=Documentación no disponible
quick.doc.section.deprecated=Obsoleto:
quick.doc.section.java.declaration=Declaración de Java:
quick.doc.section.replace.with=Sustituir por:
quick.doc.text.enum.ordinal=Ordinal de la constante del enumerado: {0}
quick.doc.text.lateinit='lateinit' permite inicializar una <a href="https://kotlinlang.org/docs/reference/properties.html#late-initialized-properties-and-variables">propiedad no nula fuera de un constructor</a>
quick.doc.text.tailrec='tailrec' marca una función como <a href="https://kotlinlang.org/docs/reference/functions.html#tail-recursive-functions">recursiva final</a> (permitiendo que el compilador reemplace la recursión con iteración)
quickFix.add.property.text=Añadir la propiedad ''{0}{1}'' ''{2}'' a ''{3}''
quickfix.add.property.familyName=Añadir propiedad
quickfix.text.suffix.may.change.semantics=(puede modificar la semántica)
random.seed=semilla aleatoria
range.could.be.replaced.with.indices.call=El rango podría reemplazarse con la llamada '.indices'
recursive.equals.call=Llamada recursiva equals
recursive.property.accessor=Acceso a propiedades recursivo
recursive.synthetic.property.accessor=Acceso de propiedad sintética recursiva
redundant.0=Redundante ''@{0}''
redundant.0.call=Redundante ''{0}'' llamada
redundant.0.modifier=Modificador ''{0}'' redundante
redundant.async.call.may.be.reduced.to.0=Llamada ''async'' redundante se podría reducir a ''{0}''
redundant.companion.reference=Redundante referencia de acompañante
redundant.constructor.keyword=Keyword 'constructor' redundante
redundant.curly.braces.in.string.template=Llaves redundantes en plantillas de cadena
redundant.double.negation=Negación doble redundante
redundant.else='else' redundante
redundant.empty.class.body=Cuerpo de clase vacío redundante
redundant.empty.initializer.block=Bloque de inicializador vacío redundante
redundant.enum.constructor.invocation=Llamada redundante al constructor de la enumeración
redundant.explicit.this=This explícito redundante
redundant.getter=Getter redundante
redundant.getter.body=Cuerpo de obtención redundante
redundant.if.option.ignore.chained=Ignorar declaraciones 'if' encadenadas
redundant.if.statement=Sentencia 'if' redundante
redundant.if.statement.analyzing.type=Analizando tipo de condición...
redundant.lambda.arrow=Flecha lambda redundante
redundant.let.call.could.be.removed=Llamada 'let' redundante que podría eliminarse
redundant.modality.modifier=Modificador de modalidad redundante
redundant.override.fix.text=Quitar método de anulación redundante
redundant.overriding.method=Método redundante que anula
redundant.qualifier.name=Nombre de calificador redundante
redundant.qualifier.unnecessary.non.direct.parent.class.qualifier=Calificadores no necesarios directos de clases padres innecesarios
redundant.runcatching.call.may.be.reduced.to.0=La llamada redundante a ''runCatching'' se puede reducir a ''{0}''
redundant.sam.constructor=Constructor SAM redundante
redundant.sam.constructors=Constructores SAM redundantes
redundant.semicolon=Punto y coma redundante
redundant.setter=Setter redundante
redundant.setter.body=Cuerpo del setter innecesario
redundant.setter.parameter.type=Tipo de parámetro redundante para el establecimiento
redundant.string.template=Plantilla de cadena redundante
redundant.suspend.modifier=Modificador 'suspend' redundante
redundant.tostring.call.in.string.template=Llamada 'toString()' redundante en `string template`
redundant.type.checks.for.object=Comprobaciones de tipo redundantes para objeto
redundant.unit=Redundante 'Unit'
redundant.unit.return.type=Tipo de retorno 'Unit' redundante
redundant.visibility.modifier=Modificador de visibilidad redundante
refactoring.cannot.be.applied.no.sources.attached={0} La refactorización no se puede aplicar: no hay fuentes adjuntas
refactoring.cannot.be.applied.to.abstract.declaration={0} No se puede aplicar refactorización a la declaración abstracta
refactoring.cannot.be.applied.to.anonymous.function.without.invocation={0} La refactorización no puede aplicarse a la función anónima sin una llamada
refactoring.cannot.be.applied.to.expect.declaration={0} no se puede aplicar refactorización a la declaración expect
refactoring.cannot.be.applied.to.lambda.expression.without.invocation={0} El refactor no se puede aplicar a una expresión lambda sin invocación
refactoring.extract.to.separate.file.text=Extraer a archivo separado
refactoring.move.non.kotlin.file=El destino debe ser un archivo Kotlin
refactoring.the.function.cannot.be.converted.to.anonymous.function=La función no se puede convertir en una función anónima
refactoring.the.function.not.found=La función no encontrada
refactoring.the.invocation.cannot.be.resolved=La llamada de invocación no se puede resolver
remove.0=Eliminar ''.{0}''
remove.0.from.parameter=Eliminar ''{0}'' del parámetro
remove.0.from.property=Remover {0} de la propiedad
remove.0.modifier=Eliminar modificador ''{0}''
remove.0.variance.from.1=Eliminar varianza ''{0}'' de ''{1}''
remove.all.argument.names=Quitar todos los nombres de argumentos
remove.annotation.doesnt.have.any.effect=Eliminar anotación debido a que no tiene ningún efecto. Ver: https://youtrack.jetbrains.com/issue/KT-48141
remove.argument.name=Eliminar nombre del argumento
remove.as.dynamic.call.fix.text=Eliminar invocación `asDynamic`
remove.assequence.call.fix.text=Quitar llamada 'asSequence'
remove.braces=Remover llaves
remove.braces.fix.text=Quitar corchetes
remove.braces.from.0.statement=Eliminar llaves del enunciado ''{0}''
remove.braces.from.all.branches=Remover llaves de todas las ramas
remove.braces.from.if.all.statements=Eliminar llaves de todas las sentencias 'if'
remove.braces.from.when.all.entries=Eliminar llaves de todas las entradas 'when'
remove.braces.from.when.entry=Quitar llaves de la entrada 'when'
remove.branch=Eliminar rama
remove.condition=Eliminar condición
remove.conflicting.import.0=Eliminar importación conflictiva {0}
remove.constructor.call=Quitar llamada al constructor
remove.conversion.from.kclass.to.class=Eliminar conversión de 'KClass' a 'Class'
remove.curly.braces=Quitar llaves
remove.default.parameter.value=Elimina el valor predeterminado del parámetro
remove.deprecated.symbol.import=Quitar importación de símbolos obsoletos
remove.element=Eliminar elemento
remove.else=Eliminar else en ''{0}''
remove.else.branch=Quitar rama else
remove.empty.constructor.body=Elimina el cuerpo del constructor vacío
remove.empty.parentheses.from.annotation.entry.fix.text=Quitar paréntesis innecesarios
remove.empty.primary.constructor=Eliminar constructor primario vacío
remove.enum.constructor.invocation.fix.text=Eliminar invocación de constructor de enum
remove.explicit.lambda.parameter.types.may.break.code=Eliminar tipos explícitos de parámetros de lambda (puede interrumpir el código)
remove.explicit.supertype.qualification=Eliminar calificación explícita de supertipo
remove.explicit.type.arguments=Quitar argumentos de tipo explícitos
remove.explicit.type.specification=Eliminar la especificación explícita de tipo
remove.explicit.type.specification.from.0=Eliminar especificación de tipo explícito de ''{0}''
remove.expression=Quitar ''{0}''
remove.expression.target=Eliminar destino EXPRESIÓN
remove.extension.function.type.annotation=Eliminar la anotación @ExtensionFunctionType que no aplica
remove.final.upper.bound=Eliminar final límite superior
remove.fix.text=Eliminar expresión
remove.from.annotation.argument=Eliminar @ del argumento de anotación
remove.function.body=Quitar cuerpo de función
remove.identifier.from.anonymous.function=Eliminar Identificador de función anónima
remove.indices.in.for.loop=Remover índices en bucle 'for'
remove.initializer.block.fix.text=Eliminar bloque de inicializador
remove.jvmfield.annotation=Remover anotación @JvmField
remove.jvmoverloads.annotation=Eliminar anotación @JvmOverloads
remove.labeled.return.from.last.expression.in.a.lambda=Eliminar "return" con etiqueta de la última expresión en una lambda
remove.let.call=Eliminar llamada 'let'
remove.modifier=Eliminar modificador
remove.modifier.fix=Hacer ''{0}'' no {1}
remove.modifier.fix.family=Hacer no {0}
remove.parameter.0=Eliminar parámetro ''{0}''
remove.parts.from.property=Eliminar subcomponentes de la propiedad
remove.redundant=Eliminar '?' redundantes
remove.redundant.0.modifier=Eliminar ''{0}'' modificador redundante
remove.redundant.assignment=Eliminar asignación redundante
remove.redundant.backticks.quick.fix.text=Eliminar backticks redundantes
remove.redundant.call.fix.text=Eliminar llamada redundante
remove.redundant.calls.of.the.conversion.method=Eliminar llamadas redundantes del método de conversión
remove.redundant.companion.reference.fix.text=Eliminar referencia redundante al compañero
remove.redundant.constructor.keyword.fix.text=Eliminar la palabra clave 'constructor' redundante
remove.redundant.else.fix.text=Eliminar 'else' redundante
remove.redundant.elvis.return.null.text=Eliminar redundante '?: return null'
remove.redundant.empty.class.body=Eliminar cuerpo de clase vacío redundante
remove.redundant.getter.body.fix.text=Quita el cuerpo del getter redundante
remove.redundant.getter.fix.text=Eliminar getter redundante
remove.redundant.if.expression=Quitar expresión 'if' redundante
remove.redundant.if.may.change.semantics.with.floating.point.types=Quitar sentencia 'if' redundante (puede cambiar las semánticas con tipos de punto flotante)
remove.redundant.if.text=Quitar la instrucción 'if' redundante
remove.redundant.initializer=Eliminar inicializador redundante
remove.redundant.label=Eliminar etiqueta redundante
remove.redundant.modality.modifier=Quitar modificador de modal redundante
remove.redundant.qualifier.name.quick.fix.text=Eliminar nombre de calificador redundante
remove.redundant.sam.constructor=Eliminar constructor SAM redundante
remove.redundant.sam.constructors=Eliminar constructores SAM redundantes
remove.redundant.setter.body.fix.text=Eliminar cuerpo innecesario del setter
remove.redundant.setter.fix.text=Eliminar setter redundante
remove.redundant.spread.operator.quickfix.text=Quitar operador de propagación redundante
remove.redundant.unit.fix.text=Eliminar 'Unit' redundantes
remove.redundant.visibility.modifier=Eliminar modificador de visibilidad redundante
remove.redundant.with.fix.text=Eliminar llamada 'with' redundante
remove.require.not.null.call.fix.text=Eliminar llamada ''{0}''
remove.return.0=Quitar return@{0}
remove.return.label.fix.family=Eliminar etiqueta redundante
remove.return.label.fix.text=Eliminar redundante ''@{0}''
remove.self.assignment.fix.text=Quitar asignación self
remove.single.expression.string.template=Eliminar plantilla de cadena de expresión simple
remove.single.lambda.parameter.declaration=Quitar la declaración de un solo parámetro lambda
remove.star=Quitar '*'
remove.supertype=Eliminar supertipo
remove.to.string.fix.text=Quitar llamada a 'toString()'
remove.token.from.function.declaration=Eliminar token '=' de la declaración de la función
remove.type.arguments=Quitar argumentos de tipo
remove.type.parameters=Eliminar parametros tipo
remove.unary.operator.fix.text=Quitar operador unario no usado
remove.underscores=Eliminar guiones bajos
remove.unnecessary.parentheses=Quitar paréntesis innecesarios
remove.unnecessary.parentheses.from.function.call.with.lambda=Eliminar paréntesis innecesarios de la llamada a función con lambda
remove.use.site.get.target=Elimina 'get:' para hacer efectiva la anotación (cambia la semántica. Ver: https://youtrack.jetbrains.com/issue/KT-48141)
remove.useless=Quitar la '?' inútil
remove.useless.cast=Eliminar conversión inútil
remove.useless.elvis.operator=Eliminar el operador elvis innecesario
remove.useless.is.check=Eliminar comprobación innecesaria is
remove.val.or.var.from.parameter=Eliminar 'val' o 'var' del parámetro
remove.var.keyword.text=Eliminar 'var'
remove.variable=Eliminar variable
remove.variable.0=Eliminar variable ''{0}''
rename.base.0=Renombrar base {0,choice,1#función|2#propiedad|3#miembro|4#método|11#funciones|12#propiedades|13#miembros|14#métodos}
rename.class.to.0=Renombrar clase a {0}
rename.class.to.containing.file.name=Renombrar clase con el nombre del archivo contenedor
rename.declaration.title.0.implements.1.2.of.3={0} {1,choice,1#implementa|2#sobreescribe} {2} de {3}
rename.file=Renombrar archivo
rename.file.0=Renombrar archivo a ''{0}''
rename.file.to.0.1=Renombrar archivo a {0}.{1}
rename.file.to.match.top.level.class.name=Renombrar archivo para que coincida con el nombre de la clase de nivel superior
rename.identifier.fix.text=Renombrar
rename.only.current.0=Renombrar sólo la {0,choice,1#función|2#propiedad} actual
rename.parameter.to.match.overridden.method=Renombrar parámetro para que coincida con el método sobreescrito
rename.searching.for.all.overrides=Buscando todas las sobreescrituras
rename.searching.for.super.declaration=Buscando la declaración super más profunda
rename.to.0=Renombrar a ''{0}''
rename.to.01=Renombrar a {0}
rename.to.fix.text=Cambiar nombre a ''{0}''
rename.to.underscore=Renombrar a _
rename.useless.call.fix.text=Cambiar la llamada a ''{0}''
reorder.parameters=Reordenar parámetros
reorder.parameters.command=Reordenar parámetros
repair.actual.members=Reparar miembros actuales
replace.&&.with.||=Reemplazar '&&' con '||'
replace.0.call.with.indexing.operator=Reemplazar llamada ''{0}' con operador de indexado
replace.0.name.with.spaces=Reemplazar {0} nombre con espacios
replace.0.with=Reemplazar ''{0}()'' con ''=''
replace.0.with.1=Reemplazar ''{0}'' con ''{1}''
replace.0.with.1.and.vice.versa=Reemplazar ''{0}'' por ''{1}'' y viceversa
replace.and.with.when.guard=Reemplazar '&&' con 'if'
replace.annotation=Reemplazar anotación
replace.annotation.with.0=Reemplazar anotación por {0}
replace.array.of.boxed.with.array.of.primitive=Reemplazar arreglo de boxed con arreglo primitivo
replace.assert.boolean.with.assert.equality=Reemplazar assert boolean con assert igualdad
replace.assert.with.operator=Sustituir aserción por operador
replace.assignment.with.if.expression=Reemplazar asignación con expresión 'if'
replace.assignment.with.when.expression=Reemplazar asignación con expresión 'when'
replace.by.0=Reemplazar por ''{0}''
replace.by.reconstructed.type=Reemplazar por tipo reconstruido
replace.call.with.unary.operator=Reemplazar llamada con operador unario
replace.cast.with.call.to.to.0=Reemplazar conversión con llamada a ''to{0}()''
replace.cast.with.primitive.conversion.method=Reemplazar cast con método de conversión primitiva
replace.collection.count.with.size.quick.fix.text=Reemplazar 'count' con 'size'
replace.contains.call.with.in.operator=Reemplazar llamada 'contains' con operador 'in'
replace.deprecated.symbol.usage=Reemplazar el uso del símbolo obsoleto
replace.deprecated.symbol.usage.in.whole.project=Sustituir el uso de símbolos obsoletos en todo el proyecto
replace.diagnostic.name.fix.family.name=Reemplazar nombre de diagnóstico
replace.diagnostic.name.fix.text=Reemplazar {0} por {1}
replace.elvis.expression.with.if.expression=Reemplazar expresión elvis con expresión 'if'
replace.explicit.lambda.parameter.with.it=Reemplazar parámetro lambda explícito con 'it'
replace.explicit.parameter.0.with.it=Reemplazar parámetro explícito ''{0}'' con ''it''
replace.expression.with.if.expression=Reemplazar expresión '!!' por expresión 'if'
replace.function.call.with.if=Reemplazar llamada de función con "if"
replace.function.call.with.the.opposite=Reemplazar la llamada de función con la función opuesta
replace.function.call.with.when=Reemplazar llamada de función con 'cuando'
replace.get.or.set.call.with.indexing.operator=Reemplazar llamada get o set con operador de indexación
replace.guard.clause.with.kotlin.s.function.call=Reemplazar cláusula de guardia con llamada a función Kotlin
replace.if.expression.with.elvis.expression=Reemplazar expresión 'if' por expresión elvis
replace.if.expression.with.return=Reemplazar expresión 'if' por return
replace.if.expression.with.safe.access.expression=Reemplazar expresión 'if' por expresión de acceso seguro
replace.if.expression.with.safe.cast.expression=Reemplazar expresión 'if' con expresión tipo conversión segura
replace.if.with.elvis.operator=Reemplazar 'if' con operador elvis
replace.if.with.when=Reemplazar 'if' por 'when'
replace.index.loop.with.collection.loop.quick.fix.text=Sustituir por un ciclo sobre los elementos
replace.infix.call.with.ordinary.call=Reemplazar llamada infija con llamada ordinaria
replace.int.range.end.inclusive.with.last.quick.fix.text=Reemplazar 'endInclusive' con 'last'
replace.int.range.start.with.first.quick.fix.text=Reemplazar 'start' por 'first'
replace.invalid.positioned.arguments.for.annotation=Reemplazar los argumentos invalidados posicionados para la anotación
replace.invoke.with.direct.call=Reemplazar 'invoke' con llamada directa
replace.it.with.explicit.parameter=Reemplazar 'it' con parámetro explícito
replace.jvmfield.with.const=Reemplazar '@JvmField' con 'const'
replace.kotlin.options.with.compiler.options=Reemplazar 'kotlinOptions' con 'compilerOptions'
replace.manual.range.with.indices.call.quick.fix.text=Reemplazar con indices
replace.modifier=Reemplazar modificador
replace.negated.0.operation.with.1=Reemplaza la operación ''{0}'' negada con ''{1}''
replace.negated.0.operation.with.1.may.change.semantics.with.floating.point.types=Sustituir la operación negativa ''{0}'' con ''{1}'' (puede cambiar la semántica de tipos de coma flotante)
replace.negated.0.with.1=Reemplaza ''{0}'' negado por ''{1}''
replace.overloaded.operator.with.function.call=Reemplazar operador sobrecargado con llamada a función
replace.property.initializer.with.if.expression=Reemplaza el inicializador de la propiedad con una expresión 'if'
replace.property.initializer.with.when.expression=Reemplazar inicializador de propiedad con expresión 'when'
replace.return.with.if.expression=Reemplazar return con expresión 'if'
replace.return.with.when.expression=Sustituye return con expresión 'when'
replace.safe.access.expression.with.if.expression=Sustituir expresión de acceso seguro con expresión 'if'
replace.scope.function.with.safe.call=Reemplazar función de ámbito con llamada segura (?.)
replace.size.check.with.0=Remplazar verificación de tamaño con ''{0}''
replace.size.check.with.isnotempty=Reemplazar verificación de tamaño con 'isNotEmpty'
replace.size.zero.check.with.isempty=reemplazar la comprobación de tamaño cero por 'isEmpty'
replace.substring.call.with.droplast.call=Reemplaza la llamada 'substring' con la llamada 'dropLast'
replace.substring.call.with.indexing.operation.call=Reemplazar llamada "substring" con llamada de operación de indexación
replace.substring.call.with.substringafter.call=Reemplazar la llamada a 'substring' por la llamada a 'substringAfter'
replace.substring.call.with.substringbefore.call=Reemplazar llamada a 'substring' con llamada a 'substringBefore'
replace.substring.call.with.take.call=Reemplazar llamada 'substring' con llamada 'take'
replace.to.with.infix.form.quickfix.text=Reemplazar 'to' con forma infija
replace.tostring.with.string.template=Reemplazar 'toString' con plantilla de cadena
replace.total.order.equality.with.ieee.754.equality=Replace la igualdad de orden total por igualdad IEEE 754
replace.usages.of.0.in.whole.project=Reemplazar usos de "{0}" en el proyecto completo
replace.when.with.if=Reemplazar 'when' con 'if'
replace.with.0=Reemplazar con ''{0}''
replace.with.0.1.2=Reemplazar con {0}[{1}] ?: {2}
replace.with.0.call=Reemplazar con llamada ''{0}()''
replace.with.0.operator=Reemplazar por el operador ''{0}''
replace.with.a.for.loop=Reemplazar por un bucle 'for'
replace.with.a.foreach.function.call=Reemplazar con una llamada de función ''{0}''
replace.with.array.call=Reemplazar con llamada de matriz
replace.with.array.literal.fix.family.name=Reemplazar con [...]
replace.with.arrayof=Reemplazar con 'arrayOf'
replace.with.assignment.fix.text=Replace con asignacion (el original esta vacío)
replace.with.binary.operator=Reemplaza con operador binario
replace.with.block.comment=Reemplazar con comentario de bloque
replace.with.contentequals=Reemplaza '!=' con 'contentEquals'
replace.with.contentequals2=Reemplazar '==' por 'contentEquals'
replace.with.contentequals3=Sustituir con 'contentEquals'
replace.with.dot.call=Reemplazar con llamada por punto
replace.with.elvis.error.fix.text=Reemplazar con '?: error("")'
replace.with.elvis.return.fix.text=Reemplazar con ''?: return{0}''
replace.with.end.of.line.comment=Reemplazar con comentario de fin de línea
replace.with.enum.map.fix.text=Reemplazar con EnumMap
replace.with.equality.check.fix.text=Reemplazar con comprobación de igualdad
replace.with.equality.fix.text=Reemplazar ''{0}'' con ''{1}''
replace.with.error=Reemplazar con '?: error(...)'
replace.with.explicit.type=Remplazar '_' con tipo explícito
replace.with.field.fix.text=Reemplazar por 'campo'
replace.with.filter.fix.text=Reemplazar con filtro
replace.with.generated.publishedapi.bridge.call.0=Reemplazar con la llamada @PublishedApi puente generada ''{0}''
replace.with.get.or.else.fix.text=Reemplazar con llamada a 'getOrElse'
replace.with.get.value.call.fix.text=Reemplazar con llamada 'getValue'
replace.with.if.fix.text=Reemplazar con comprobación de tipo 'if'
replace.with.import.alias=Reemplazar con alias de importación
replace.with.in.when=Reemplazar ',' por '||' en when
replace.with.indexing.and.elvis.operator=Reemplazar con indexación y operador elvis
replace.with.infix.function.call=Reemplazar con llamada a función infija
replace.with.kotlin.analog.function.family.name=Sustituir por función análoga de Kotlin
replace.with.kotlin.analog.function.text=Reemplazar con la función ''{0}''
replace.with.kotlin.s.foreach=Reemplazar con forEach de Kotlin
replace.with.kotlin.s.function.call=Reemplazar con llamada a función Kotlin
replace.with.label.0.at=Reemplaza con la etiqueta {0}@
replace.with.list.generator.fix.text=Reemplazar por generador de listas
replace.with.operator.assignment=Reemplazar con asignación de operador
replace.with.ordinary.assignment=Reemplaza con asignación ordinaria
replace.with.parameter.name=Reemplazar '_' con nombre de parámetro
replace.with.publishedapi.bridge.call=Reemplazar con llamada de puente @PublishedApi
replace.with.rangeUntil.quick.fix.text=Reemplazar con '..<'
replace.with.repeat.fix.family.name=Reemplazar con 'repeat()'
replace.with.return=Reemplazar '!!' con '?: return'
replace.with.safe.call=Reemplazar con llamada segura (?.)
replace.with.safe.this.call=Reemplazar con llamada segura (this?.)
replace.with.std.lib.fix.text=Reemplazar con {0}.{1}
replace.with.stdlib.operations=Reemplazar por operaciones stdlib
replace.with.stdlib.operations.with.use.of.assequence=Reemplazar con operaciones stdlib con uso de 'asSequence()'
replace.with.string.literal.fix.family.name=Reemplazar con plantillas de cadenas
replace.with.underscore=Reemplazar tipo explícito con '_'
replace.with.until.quick.fix.text=Reemplazar con 'until'
replace.with1=Reemplazar con '+='
replace.||.with.&&=Reemplazar '||' con '&&'
replaceable.with.enummap=Puede ser reemplazado con 'EnumMap'
replaceable.with.operator.assignment=Reemplazable con asignación de operador
report.also.for.a.variables.without.a.whitespace.around=Reportar también para variables sin un espacio en blanco alrededor
report.also.on.call.with.single.boolean.literal.argument=Informar también de la llamada con un solo argumento literal booleano
report.also.on.statement=También en la sentencia
report.for.types.with.platform.arguments=Informe para tipos con argumentos de plataforma
reports.only.function.calls.from.kotlinx.coroutines=Informar solo llamadas de función desde 'kotlinx.coroutines'
reset.files=Restablecer archivos...
resolve.pasted.references=resolver referencias pegadas
result.of.0.call.is.not.thrown=El resultado de la llamada ''{0}'' no se lanza
retargeting.usages.progress=Retargeting usos...
rethrow.stored.pce.as.a.new.runtime.exception=Relanzar PCE almacenado como una nueva excepción en tiempo de ejecución
return.type=Tipo de retorno:
return.type.is.invalid=Tipo de devolución no válido
return.when='devolver cuando'
revert.applied.imports.command=Revertir Importaciones Aplicadas
roots.description.text.update.source.roots.for.non.jvm.modules.in.kotlin.project=Actualizar rutas de origen para módulos no JVM en el proyecto Kotlin
round.using.0=Usando {0}() redondear
safe.delete.constructor=Constructor de eliminación segura
saving.files=Guardando archivos...
scanning.files.0.fo.1.file.2.occurrences.found=Escaneando ficheros: {0} de {1} fichero. {2} apariciones encontradas
script.action.text.ignore=Ignorar
script.action.text.open.settings=Abrir configuración
script.action.text.show.all=Mostrar todos
script.name.kotlin.scripting=Kotlin Scripting
script.text.multiple.script.definitions.are.applicable.for.this.script=Se pueden aplicar múltiples definiciones de script para este script. Se utiliza {0}
sealed.sub.class.has.no.state.and.no.overridden.equals="subclase sellada" no tiene estado ni 'equals()' sobrescrito
search.for.not.property.candidates=Buscar por candidatos no propiedades
search.for.text.occurrences=Buscar ocurrencias de text
search.in.comments.and.strings=Buscar en comentarios y cadenas
searching.0=Buscando {0}...
searching.for.0=Buscando {0}
searching.for.imports.to.delete.title=Buscando importaciones para eliminar
searching.for.not.property.candidates=Buscando candidatos No Propiedad
searching.for.overriding.methods=Buscando métodos de anulación
searching.inheritors=Buscando herederos...
searching.usages.of.0.parameter=Buscando usos del parámetro ''{0}''
select.lambda.to.label=Seleccionar lambda a etiquetar
select.loop.statement.to.label=Seleccionar la declaración de bucle para etiquetar
select.target.code.block.file=Seleccionar bloque/archivo de código destino
select.target.file=Seleccionar archivo de destino
selected.code.fragment.has.multiple.exit.points=El fragmento de código seleccionado tiene varios puntos de salida
selected.code.fragment.has.multiple.output.values=El fragmento de código seleccionado tiene más de 3 valores de salida:
selected.code.fragment.has.output.values.and.exit.points=El fragmento de código seleccionado tiene valores de salida así como puntos de salida alternativos
setter.of.0.will.become.invisible.after.extraction=El setter de {0} se volverá invisible después de la extracción
shortening.usages.progress=Acortando usos
should.be.replaced.with.if.type.check=Debe reemplazarse con verificación de tipo 'if'
should.be.replaced.with.indexing=Se debería reemplazar por indizado
should.be.replaced.with.kotlin.function=Debería reemplazarse con la función Kotlin
should.be.replaced.with.list.generator=Debiera reemplazarse con generador de lista
should.not.contain.lowercase.letter=no debe contener minúsculas
should.not.contain.underscores=no puede contener guiones bajos
should.not.contain.underscores.in.the.middle.or.the.end=no debe contener guiones bajos al medio o al final
should.not.contain.underscores.with.camel.case=no debería contener guiones bajos cuando se utiliza notación húngara
should.not.start.with.an.underscore=no debe comenzar con un guion bajo
should.not.start.with.an.uppercase.letter=no se debe comenzar por una letra mayúscula
should.start.with.a.lowercase.letter=debe comenzar con una letra minúscula
should.start.with.an.uppercase.letter=debe comenzar con una letra mayúscula
signature.preview=Vista previa de la firma
simplify.0.to.1=Simplificar ''{0}'' a ''{1}''
simplify.boolean.expression=Simplificar expresión booleana
simplify.call.chain.fix.text=Fusionar cadena de llamada a ''{0}''
simplify.call.fix.text=Convertir llamada ''{0}'' a ''{1}''
simplify.comparison=Simplificar comparación
simplify.fix.text=Simplificar expresión
simplify.foldable.if.then=Simplificar plegable if-then
simplify.negated.operation=Simplificar operación negada
simplify.when.fix.text=Simplificar 'when'
since.kotlin.1.3.main.parameter.is.not.necessary=Desde Kotlin 1.3, el parámetro `main` no es necesario
slicer.text.in=en
slicer.text.tracking.enclosing.lambda=(Rastreando lambda envolvente) 
slicer.text.tracking.lambda.argument=(Seguimiento del parámetro lambda) 
slicer.text.tracking.lambda.calls=(Seguimiento de llamadas lambda)
slicer.text.tracking.lambda.receiver=(Receptor lambda de seguimiento)
slicer.title.dataflow.from.here=Flujo de datos desde aquí
slicer.title.dataflow.to.here=Flujo de datos hasta aquí
slicer.tool.tip.text.variable.dereferenced=Variable referenciada
some.types.are.not.accessible.from.0.1=Algunos tipos no son accesibles desde {0}:\n{1}
sort.modifiers=Organizar modificadores
specify.all.remaining.arguments.by.name=Especifica todos los argumentos restantes por nombre
specify.all.types.explicitly.in.destructuring.declaration=Especificar todos los tipos explícitamente en la declaración de desestructuración
specify.explicit.lambda.signature=Especifica una signatura explícita para tu lambda
specify.override.explicitly=Especificar override explícitamente
specify.override.for.0.explicitly=Especificar reemplazo para ''{0}'' explícitamente
specify.remaining.required.arguments.by.name=Especifica los argumentos requeridos restantes por nombre
specify.return.type.explicitly=Especificar explícitamente el tipo de retorno
specify.super.type=Especificar supertipo ''{0}'' explícitamente
specify.type.explicitly=Especificar tipo explícitamente
split.if.into.two=Dividir 'if' en dos
split.property.declaration=Dividir declaración de propiedad
spring.secured.urls.inlay.hints=Kotlin: Mostrar sugerencias de inserción para URL Spring seguras
ssr.modifier.match.call.semantically=Emparejar llamada semánticamente
ssr.modifier.match.companion.object=Objeto compañero de coincidencia
ssr.modifier.match.val=Coincidencia val
ssr.modifier.match.var=Matching var
start.import.button.text.add=Agregar
start.import.button.text.remove=Eliminar
statement=Sentencia
status=(estado)
status.text.no.definitions=Sin definición
step.1.collecting.0.1.2=Paso 1: Recopilando {0}:{1}:{2}
step.2.0.of.1=Paso 2: {0} de {1}
step.3.0.of.1=Paso 3: {0} de {1}
surround.with.0=Encapsular con {0}(...)
surround.with.array.of=Rodear con arrayOf(...)
surround.with.lambda=Envolver con lambda
surround.with.null.check=Envolver con chequeo de nulidad
surround.with.star.0=Rodear con *{0}(...)
suspicious.asdynamic.member.invocation=Invocación del miembro 'asDynamic' sospechoso
suspicious.callable.reference.as.the.only.lambda.element=Invocación sospechosa como único lambda
suspicious.combination.of.and=Combinación sospechosa de == y ===
suspicious.var.property.its.setter.does.not.influence.its.getter.result=Propiedad 'var' sospechosa: su setter no influye en su resultado de getter
test.function=Probar función
test.integration.button.text.cancel=Cancelar
test.integration.button.text.rewrite=Reescribir
test.integration.message.text.create.test.in.the.same.source.root=¿Crear una prueba en la misma raíz de origen?
test.integration.message.text.kotlin.class=La clase Kotlin ''{0}'' ya existe. ¿Quieres actualizarla?
test.integration.title.no.test.roots.found=No se encontraron raíces de prueba
test.result.log.file.will.be.placed.here=Se colocará aquí el archivo de registro del resultado de la prueba
text.0.1.must.be.moved.with.sealed.parent.class.and.all.its.subclasses={0} ''{1}'' debe moverse con clase padre 'sealed' y todas sus subclases
text.0.already.contains.1={0} ya contiene {1}
text.0.already.contains.nested.class.1={0} ya contiene una clase anidada llamada {1}
text.0.already.declared.in.1={0} ya está declarado en {1}
text.0.have.no.inheritors.warning={0} no tiene herederos\nSi baja miembros, se eliminarán. ¿Desea continuar?
text.0.in.1.will.override.corresponding.member.of.2.after.refactoring={0} in {1} reemplazará al miembro correspondiente de {2} después del refactoring
text.0.inherits.from.1.it.will.not.be.affected.by.refactoring={0} hereda de {1}.\nNo se verá afectado por la refactorización
text.0.is.invalid.destination.package=''{0}'' es un nombre de paquete de destino no válido
text.0.is.not.allowed.in.the.target.context=''{0}'' no está permitido en el contexto objetivo
text.0.is.not.valid.package.name={0} no es un nombre de paquete válido
text.0.to.inline={0} a línea
text.0.uses.1.which.is.not.accessible.from.2={0} usa {1}, que no es accesible desde {2}
text.0.uses.1.which.will.be.inaccessible.after.move={0} usa {1} que estará inaccesible después de la movida
text.0.uses.1.which.will.not.be.accessible.from.subclass={0} usa {1} que no será accesible desde la subclase.
text.0.uses.internal.1.which.will.be.inaccessible.after.move={0} utiliza interna {1} la cual no será accesible después del movimiento
text.0.will.be.shadowed.by.1={0} será ocultado por {1}
text.0.will.clash.with.existing.1.in.2={0} al renombrarlo chocará con el existente {1} en {2}
text.0.will.no.longer.be.accessible.after.signature.change={0} ya no será accesible después de la modificación de la firma
text.Assignment=Asignación
text.Function=Función
text.Name=Nombre
text.Package=Paquete
text.Property=Propiedad
text.Return=Valor devuelto
text.abstract=abstracto
text.actual.moved.to.common.modules.target=La declaración real ''{0}'' se moverá a los módulos comunes.
text.add.getter=Añadir getter
text.add.getter.and.setter=Añadir getter y setter
text.add.setter=Añadir setter
text.add.use.site.target.0=Agregar el destino del sitio de uso ''{0}''
text.all.declarations.must.belong.to.the.same.directory.or.class=Todas las declaraciones deben pertenecer al mismo directorio o clase
text.annotation=anotación
text.annotation.class=Clase de anotación
text.anonymous=[Anónimo]
text.anonymous.function=función anónima
text.at.least.one.file.must.be.selected=Debe seleccionar al menos un miembro
text.callee.text.would.be.shown.here=El texto del llamado se mostraría aquí
text.caller.text.with.highlighted.callee.call.would.be.shown.here=Texto del llamador\ncon la llamada al receptor resaltada se mostraría aquí
text.can=puede
text.cannot.create.target.directory.0=No se puede crear el directorio de destino {0}
text.cannot.determine.source.directory=No se puede determinar directorio fuente
text.cannot.find.package.corresponding.to.0=No se encontró el paquete correspondiente a {0}
text.cannot.find.target.package.name=No se puede encontrar el nombre del paquete de destino
text.cannot.inline.reference.from.0.to.1=No se puede incorporar la referencia en línea de {0} a {1}
text.cannot.move.expect.actual.declaration.to.file=No se pudo mover la declaración esperada/real al archivo
text.cannot.move.for.current.project=No se puede mover para el proyecto actual
text.cannot.move.inner.class.0.into.itself=No se puede mover la clase anidada {0} hacia sí misma
text.cannot.move.to.original.file=No se puede mover al archivo original
text.change.file.package.to.0=Cambiar el paquete del archivo a ''{0}''
text.choose.containing.file=Seleccionar archivo contenedor
text.class=clase
text.class.0={0,choice,1#clase|2#clases}
text.class.0.already.contains.member.1={0} ya contiene {1}
text.class.0.already.exists.in.package.1=La Clase {0} ya existe en el Paquete {1}
text.class.0.already.exists.in.the.target.scope=La clase {0} ya existe en el ámbito objetivo
text.class.0.is.final={0} es final
text.constructor=constructor
text.convert._it_.to.explicit.lambda.parameter=Convertir 'it' al parámetro lambda explícito
text.create=Crear
text.create.destructuring.declaration=Crear declaración destructurante
text.create.single.variable=Crea una variable única
text.declaration=declaración
text.declarations.clash.move.0.destination.1.declared.in.scope.2=Las siguientes declaraciones entrarían en conflicto: mover {0} y destino {1} declarados en el alcance {2}
text.default.value=// Valor predeterminado = {0}
text.destination.class.should.be.kotlin.class=La clase de destino debe ser una clase de Kotlin
text.do.you.want.to.rename.0.as.well=¿Quieres renombrar {0}() también?
text.do.you.want.to.rename.base.property=¿Quieres renombrar la propiedad base?
text.do.you.want.to.rename.base.property.from.0=¿Quieres renombrar la propiedad base desde {0}?
text.done=Hecho
text.duplicating.local.variable=Duplicando variable local ''{0}''
text.duplicating.parameter=Duplicando el parámetro ''{0}''
text.duplicating.property=Duplicando propiedad ''{0}''
text.enum=Enumeración
text.enum.class=enum class
text.enum.constant=Constante enum
text.expected.moved.to.platform.modules.target=Se espera que la declaración ''{0}'' se mueva a los módulos de la plataforma.
text.explicit.receiver.is.already.present.in.call.element.0=El receptor explícito ya está presente en el elemento de llamada: {0}
text.extend=extender
text.extension=extensión
text.extension.function=función de extensión
text.extension.function.0=extensión {0,choice,1#función|2#funciones}
text.extension.property=propiedad de extensión
text.extension.property.0=extensión{0,choice,1#propiedad|2#propiedades}
text.extract.superclass=Extraer superclase
text.file.0.already.exists.in.1=El archivo {0} ya existe en {1}
text.file.name.cannot.be.empty=El nombre del archivo no puede estar vacío
text.first.definition.that.matches.script.pattern.extension.applied.starting.from.top=Se aplica la primera definición que coincide con el patrón/extensión del script, comenzando desde arriba.
text.function=función
text.function.0={0,choice,1#función|2#funciones}
text.function.already.exists=Función ya existe: ''{0}''
text.function.in.ticks.0=función ''{0}''
text.getter=getter
text.implement=implementar
text.implements=implementa
text.implicit.companion.object.will.be.inaccessible.0=El companion object implícito no será accesible: {0}
text.incorrect.target.path.directory.0.does.not.belong.to.current.project=Ruta de destino incorrecta. El directorio {0} no pertenece al proyecto actual.
text.indirect.outer.instances.will.not.be.extracted.0=Las instancias externas indirectas no serán extraídas: {0}
text.initializer=Inicializador
text.inline.0=Inline {0}
text.inline.all.references.and.verb.0.the.kind.1.occurrences.2=Inlinear todas las referencias y {0} {1}{2}
text.inline.function.not.supported=La función en línea aún no es compatible
text.inline.recursive.function.is.supported.only.on.references=La función recursiva en línea solo es compatible con referencias
text.inline.this.reference.and.keep.the.0=Intercala esta referencia y conserva el {0}
text.inlined.0.overrides.0.1=Implícito {0} sobreescribe {0} {1}
text.inlining.0.1=Incrustación de {0} {1}
text.inner.class.0.cannot.be.moved.to.interface={0} es una clase interna. No puede moverse a la interfaz
text.interface=interfaz
text.introduce.default.value=Introduce valor por defecto(&D)
text.invalid.target.path.0=Ruta de destino no válida {0}
text.invalid.target.specified=Meta especificada no válida
text.keep=retener
text.lambda.parameter=parámetro lambda
text.lambda.parameters=Lambda parameters:
text.lambda.return.type=Tipo devuelto lambda(&T)
text.lazy.property=propiedad perezosa
text.local.property=propiedad
text.local.variable=variable local
text.looking.for.usages=Buscando Usos
text.member=miembro
text.member.0.in.super.class.will.clash.with.existing.member.of.1={0} en superclase chocará con miembro existente de {1}
text.member.extension.call.will.not.be.processed.0=La llamada a la membresía extendida no será procesada: {0}
text.move.declaration.no.support.for.companion.objects=El movimiento de la declaración no se admite para objetos complementarios
text.move.declaration.no.support.for.enums=Mover la declaración no está soportado para enumeraciones
text.move.declaration.no.support.for.multi.file=No compatible con mover declaraciones entre varios archivos
text.move.declaration.no.support.for.nested.declarations=Mover declaración no soportado para declaraciones anidadas
text.move.declaration.proceed.move.without.mpp.counterparts.text=Esta refactorización moverá la declaración seleccionada sin sus contrapartes expect/actual, lo que podría causar errores de compilación.\n¿Desea continuar?
text.move.declaration.proceed.move.without.mpp.counterparts.title=No es posible realizar la refactorización. Las declaraciones MPP no son compatibles con esta refactorización.
text.move.declaration.supports.only.top.levels.and.nested.classes=Mover declaración sólo es compatible con declaraciones de nivel superior y clases anidadas
text.move.declarations=Mover declaraciones
text.move.file.0=Mover {0}
text.move.file.no.support.for.file.target=El destino del archivo no es compatible con el desplazamiento de archivos
text.move.method.is.not.supported.for.generic.classes=Mover método no es compatible con clases genéricas
text.move.method.is.not.supported.for.non.project.methods=Mover método no es compatible con métodos no de proyecto
text.move.method.is.not.supported.when.method.is.a.part.of.inheritance.hierarchy=No se admite Move method cuando el método es parte de la jerarquía de herencia
text.move.refactoring.not.available.during.indexing=Movimiento de refactorización no disponible durante la indexación
text.moving.multiple.nested.classes.to.top.level.not.supported=No se admite mover múltiples clases anidadas al nivel superior
text.name=nombre
text.nested.classes.to.upper.level=Clases anidadas a nivel superior
text.no.destination.object.specified=No se ha especificado ningún objeto de destino
text.no.elements.to.move.are.selected=No se han seleccionado elementos para mover
text.no.files.to.move=No hay archivos especificados para mover
text.no.name.provided.for.type.alias=No se proporcionó nombre para el alias de tipo
text.no.package.corresponds.to.directory=Ningún paquete corresponde a este directorio
text.non.kotlin.0.will.not.be.affected.by.refactoring=Los que no sean Kotlin {0} no se verán afectados por la refactorización
text.object=objeto
text.object.0={0,choice,1#objeto|2#objetos}
text.operator.0={0,choice,1#operador|2#operadores}
text.overload=Sobrecarga
text.overrides=override
text.package.directive.dont.match.file.location=La directiva del paquete no coincide con la ubicación del archivo
text.parameter=Parámetro
text.parameter.0=parámetro ''{0}''
text.parameter.name=Parámetro nombre:
text.parameter.reference.can.t.be.safely.replaced.with.0.since.1.is.ambiguous.in.this.context=La referencia de parámetro no puede ser reemplazada por {0} de manera segura porque {1} es ambigua en este contexto
text.parameter.reference.can.t.be.safely.replaced.with.0.since.target.function.can.t.be.referenced.in.this.context=La referencia de parámetro no se puede reemplazar de forma segura con {0} porque la función objetivo no se puede hacer referencia en este contexto
text.parameter.type=Tipo del parámetro:(&T)
text.parameters=Parámetros:(&P)
text.part=parte
text.pattern=Patrón:
text.primary=primario
text.primary.constructor=constructor principal
text.proceed.with.extraction=Continuar con la extracción
text.process.duplicates=Procesar duplicados
text.processing.file.0=Procesando {0}
text.property=propiedad
text.property.0={0,choice,1#propiedad|2#propiedades}
text.property.in.ticks.0=propiedad ''{0}''
text.property.with.getter=propiedad con getter
text.property.with.initializer=propiedad con inicializador
text.pushed.member.will.not.be.available.in.0=El miembro insertado no estará disponible en ''{0}''
text.qualified.call.will.not.be.processed.0=La llamada calificada no será procesada: {0}
text.receiver=receptor
text.receiver.can.t.be.safely.transformed.to.value.argument=El receptor no se puede transformar de forma segura en el argumento del valor: {0}
text.refactoring.can.t.be.performed.on.the.selected.code.element=La refactorizaci'on no se puede realizar en el elemento de c'odigo seleccionado
text.refactoring.is.not.applicable.to.this.code.fragment=La refactorización no aplica a este fragmento de código
text.reference.cannot.be.converted.to.a.lambda=La referencia no se puede convertir a una lambda
text.references.in.code.to.0.1.and.its.declarations=Referencias en código a {0} {1} y sus declaraciones
text.references.to.outer.classes.have.to.be.added.manually=Las referencias a clases externas tendrán que ser agregadas manualmente después de mover
text.remove=eliminar
text.remove.0.no.longer.used=Eliminar {0} ya no se está utilizando
text.remove.question=¿Eliminar '?'
text.rename.as.part.of.phrase=renombrar
text.rename.is.not.applicable.to.compiler.plugin.generated.declarations=Renombrar no es aplicable a declaraciones generadas por complementos del compilador
text.rename.is.not.applicable.to.secondary.constructors=El renombrado no es aplicable a constructores secundarios
text.rename.is.not.applicable.to.synthetic.declarations=Cambiar nombre no es aplicable a las declaraciones sintéticas
text.rename.not.applicable.to.backing.field.reference=Renombrar no es aplicable a la referencia del campo de respaldo
text.rename.not.applicable.to.dynamically.invoked.methods=Renombrar no es aplicable a métodos dinámicamente invocados
text.rename.overloads.title=Renombrar sobrecargas
text.rename.parameters.title=Renombrar parámetros
text.return=retornar
text.sealed.broken.hierarchy.none.in.target=La jerarquía sellada de ''{0}'' se dividiría. Ninguno de sus miembros reside en el paquete ''{1}'' del módulo ''{2}'': {3}.
text.sealed.broken.hierarchy.still.in.source=La jerarquía sellada de ''{0}'' se dividiría. El paquete ''{1}'' del módulo ''{2}'' aún contendría sus miembros: {3}.
text.sealed.class.0.must.be.moved.with.all.its.subclasses=La clase sellada ''{0}'' debe moverse con todas sus subclases
text.secondary=secundario
text.secondary.constructor=constructor secundario
text.select.target.code.block=Seleccionar bloque de código de destino
text.select.target.code.block.file=Selecciona bloque de código / archivo destino
text.select.target.file=Seleccionar archivo objetivo
text.setter=setter
text.should=debería
text.there.is.already.a.parameter=Ya existe un parámetro ''{0}'' en {1}. Entrará en conflicto con el nuevo parámetro.
text.there.is.already.a.variable.0.in.1.it.will.conflict.with.the.new.parameter=Ya hay una variable "{0}" en {1}. Entrará en conflicto con el nuevo parámetro.
text.type=Tipo
text.type.alias=alias de tipo
text.type.alias.0=type{0,choice,1#alias|2#aliases}
text.type.alias.cannot.refer.to.types.which.aren.t.accessible.in.the.scope.where.it.s.defined=Un alias de tipo no puede referenciar tipos que no sean accesibles en el ámbito donde se define
text.type.alias.name.must.be.a.valid.identifier.0=El nombre del alias de tipo debe ser un identificador válido: {0}
text.type.already.exists.in.the.target.scope=El tipo {0} ya existe en el ámbito de destino
text.type.parameter=tipo {0, choice, 0#parámetro|2#parámetros}
text.type.parameter.names.must.be.distinct=Los nombres de los parámetros de tipo deben ser distintos
text.type.parameters=Tipo e parâmetros(&P)
text.unexpected.element.type.0=Tipo de elemento inesperado: {0}
text.update.usages.to.reflect.declaration.0.move=Actualizar los usos para reflejar el movimiento de la {0, choice, 0#declaración|1#declaraciones}
text.updating.usages.progress=Actualizando los usos en la base de datos...
the.anonymous.object=el objeto anónimo
the.declaration.has.0.modifier=La declaración tiene el modificador ''{0}''
the.function.declaration.shouldn.t.have.a.default.implementation=La declaración de la función no debe tener implementación por defecto
there.are.possible.side.effects.found.in.expressions.assigned.to.the.variable.0=Se han encontrado posibles efectos secundarios en las expresiones asignadas a la variable ''{0}''.<br>Puede:<br>-&nbsp;<b>Eliminar</b> la asignación completa, o<br>-&nbsp;<b>Transformar</b> el lado derecho de la asignación en una sentencia independiente.<br>
there.is.own.replacewith.on.0.that.is.used.through.this.alias.please.replace.usages.first=Existe un ''ReplaceWith'' propio en ''{0}'' usado a través de este alias. Reemplace los usos primero.
these.declarations.cannot.be.transformed=Estas declaraciones no se pueden transformar:
this.call.is.useless.with=Esta llamada es inútil con ?.
this.property.conflicts.with.synthetic.extension.and.should.be.removed.or.renamed.to.avoid.breaking.code.by.future.changes.in.the.compiler=Propiedad entra en conflicto con una extensión sintética y debería ser eliminada o renombrado para evitar quebrantar código por futuras versiones del compilador Kotlin
this.range.is.empty=El rango está vacío.
this.range.is.empty.did.you.mean.to.use.0=Este rango está vacío. ¿Pretendía utilizar ''{0}''?
this.type.probably.can.be.changed.to.nullable=Este tipo probablemente puede cambiarse a anulable
this.when.is.simplifiable=Este 'when' puede simplificarse
throwable.instance.0.is.not.thrown=La instancia de Throwable ''{0}'' no se lanza
titile.not.found=No se encontró
title.choose.destination.object=Seleccionar Objeto de Destino
title.choose.logger.factory.class=Seleccionar clase factory del registrador
title.choose.use.site.target=Seleccionar objetivo de uso del sitio
title.done=Finalizado
title.error=Error
title.import.layout=Importar diseño
title.inline.function=Inlinear función
title.inline.property=Propiedad en línea
title.inline.type.alias=Alias de tipo en línea
title.introduce.parameter.to.declaration=Introducir parámetro en declaración
title.kdoc.for.abstracts=KDoc para abstractos
title.lateinit.var.overrides.lateinit.var='lateinit var' sobreescribe la super 'lateinit var'
title.logger.factory.class.name=Nombre de clase de fábrica de registrador
title.logger.factory.method.name=Nombre del método de fábrica del registrador
title.move.method=Mover método
title.move.nested.classes.to.upper.level=Mover clases anidadas a un nivel superior
title.packages.to.use.import.with=Paquetes a Usar para Importar con '*'
title.parameters=Parámetros
title.rename.file=Renombrar Archivo
title.rename.file.to=Renombrar archivo como:
title.rename.overloads.to=Renombrar sobrecargas a:
title.rename.warning=Advertencia para cambio de nombre
title.select.a.name.for.this.parameter=Seleccionar el nombre para el parámetro ''this@{0}''
title.select.target.code.block=Seleccionar bloque de código de destino
title.success=Éxito
to.fully.qualified.name=A (nombre totalmente calificado):
tooltip.implements.function=Implementa la función en
tooltip.implements.property=Implementa la propiedad in
tooltip.is.implemented.by=Implementado por
tooltip.is.subclassed.by=Tiene subclases en
tooltip.overrides.function=Anula función en
tooltip.overrides.property=Sobrescribe propiedad en
top.level=De nivel superior
two.comparisons.should.be.converted.to.a.range.check=Las dos comparaciones deberían convertirse en una comprobación de rango
type.0.1.is.not.accessible.from.target.module={0, choice, 0#Tipo|2#Tipos} {1} no es accesible desde el módulo destino
type.alias.0=Alias de tipo "{0}"
type.arguments.will.be.lost.after.conversion.0=Los argumentos de tipo se perderán después de la conversión: {0}
type.parameter.0=Parámetro de tipo "{0}"
type.parameter.can.have.0.variance=El parámetro de tipo puede tener una varianza ''{0}''
type.provider.anonymous.object=Objeto anónimo
type.provider.no.expression.found=No se encontró expresión
type.provider.smart.cast.from=(lanzamiento inteligente de {0})
type.provider.unknown.type=Tipo es desconocido
unclear.precedence.of.binary.expression.inspection=La expresión debe usar paréntesis para aclarar
unclear.precedence.of.binary.expression.inspection.display.name=Múltiples operadores con distinta prioridad
unclear.precedence.of.binary.expression.quickfix=Añadir paréntesis explicativos
unclear.precedence.of.binary.expression.report.even.obvious.cases.checkbox=Reportar también casos obvios
unknown.types.title=Tipos desconocidos
unlabeled.return.inside.lambda=Retorno sin etiqueta dentro de una lambda
unrecognized.reference.will.be.skipped.0=Referencia no reconocida que se omitirá: {0}
unsupported.usage.0=Uso no admitido: {0}
until.can.be.replaced.with.rangeUntil.operator='until' se puede reemplazar con el operador '..<'
unused.equals.expression=expresión equals no utilizada
unused.import.directive=Directiva de importación no usada
unused.return.value.of.a.function.with.lambda.expression.body=Valor de retorno no usado de una función con cuerpo con expresión lambda
unused.unary.operator=Operador unario sin usar
unwrap.else=Desplegar else en ''{0}''
unwrap.expression=Quitar encapsulado ''{0}''
unwrap.parameter=Desenvolver parámetro ''{0}'' arg ''{1}''
update.indices=Actualizar índices...
update.obsolete.label.syntax=Actualiza la sintaxis de la etiqueta obsoleta
usage.of.kotlin.internal.declaration.from.different.module=Uso de declaración interna de Kotlin desde módulo diferente
usage.of.redundant.or.deprecated.syntax.or.deprecated.symbols=Uso de sintaxis redundante o en desuso o símbolos en desuso
usage.provider.text.property.of.0={0} de {1}
usage.provider.text.unnamed=<sin nombre>
usages.of.outer.class.instance.inside.of.property.0.won.t.be.processed=Los usos de la instancia de la clase externa dentro de la propiedad ''{0}'' no serán procesados
use.destructuring.declaration=Usa declaración de destructuración
use.expression.body.instead.of.0=Usa el cuerpo de la expresión en lugar de {0}
use.inherited.visibility=Usar visibilidad heredada
use.of.getter.method.instead.of.property.access.syntax=Uso del método getter en lugar de la sintaxis de acceso a la propiedad
use.of.non.const.kotlin.property.as.java.constant.is.incorrect.will.be.forbidden.in.1.4=El uso de una propiedad Kotlin no constante como una constante Java es incorrecto. Se prohibirá en la versión 1.4
use.of.setter.method.instead.of.property.access.syntax=Usar el método setter en lugar de la sintaxis de acceso a propiedad
use.property.access.syntax=Usar sintaxis de acceso a propiedad
use.property.access.syntax.option.report.non.trivial.accessors=Informar accesores no triviales
use.withindex.instead.of.manual.index.increment=Usar withIndex() en lugar del incremento manual del índice
useless.call.on.collection.type=Llamada inútil sobre tipo colección
useless.call.on.not.null.type=Llamada inútil sobre tipo no-nulo
uses.of.should.be.replaced.with.logging=Se debería sustituir el uso de <code>{0}</code> por un registro más robusto
variable.0.is.assigned.to.itself=Variable ''{0}'' se reasigna a sí misma
variable.declaration.could.be.inlined=La declaración de variable se podría dejar en línea
variable.declaration.could.be.moved.into.when=La declaración de variable se puede mover a 'when'
variable.is.never.modified.and.can.be.declared.immutable.using.val=La variable nunca se modifica, por lo que se puede declarar utilizando 'val'
variable.is.same.as.0.and.should.be.inlined=Variable es igual a ''{0}'' y debe ser incluida inline
variable.name.0.matches.the.name.of.a.different.component=El nombre de variable ''{0}'' coincide con el nombre de un componente diferente
variable.used.only.in.following.return.and.should.be.inlined=Variable únicamente usada en el siguiente retorno; debería estar en línea
vcs.code.author=Kotlin: Mostrar sugerencias de inserción con el autor del código
version={version}
visibility=Visibilidad:(&V)
when.has.only.else.branch.and.should.be.simplified=when tiene solo rama 'else' y debe simplificarse
when.with.subject.should.be.used=Cuando se debería usar 'when' con el sujeto
wrap.argument.with.parentheses=Envolver argumento con paréntesis
wrap.element.with.0.call=Envolver elemento con la llamada a ''{0}()''
wrap.expression.in.parentheses=Encerrar expresión entre paréntesis
wrap.run.fix.text=Convertir a ejecutar { ... }
wrap.unary.operator.quickfix.text=Ajustar operador unario y sus argumentos con paréntesis ()
wrap.with=Envolve con []
wrap.with.array.literal=Envolver con un literal de array
wrap.with.collection.literal.call=Envolver con llamada a literal de colección
wrap.with.coroutine.scope.fix.family.name=Envolver con coroutineScope
wrap.with.coroutine.scope.fix.text=Envolver el cuerpo de la función con 'coroutineScope { ... }'
wrap.with.coroutine.scope.fix.text2=Englobar la llamada con 'coroutineScope { ... }'
wrap.with.coroutine.scope.fix.text3=Eliminar el receptor y encapsular con 'coroutineScope { ... }'
wrap.with.let.call=Envolver con llamada '?.let { ... }'