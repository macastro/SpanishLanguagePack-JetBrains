action.AnActionButton.description.disable.selected=Deshabilitar el seleccionado
action.AnActionButton.description.duplicate=Duplicar
action.AnActionButton.description.enable.selected=Habilitar Seleccionado
action.AnActionButton.description.export=Exportar
action.AnActionButton.description.import=Importar
action.AnActionButton.text.disable.selected=Deshabilitar selección
action.AnActionButton.text.duplicate=Duplicar
action.AnActionButton.text.enable.selected=Habilitar seleccionado
action.AnActionButton.text.export=Exportar
action.AnActionButton.text.import=Importar
action.add.field.watchpoint.text=Agregar reloj de campo
action.auto.variables.mode=Mostrar variables sólo cerca del punto de ejecución
action.auto.variables.mode.description=Mostrar solo variables usadas cerca del punto de ejecución
action.calculate.retained.size.info=Los objetos retenidos de ''{0}'' están resaltados
action.calculate.retained.size.text=El tamaño retenido de ''{0}'' es {1}, el tamaño superficial es {2}
action.calculate.retained.size.title=Tamaño retenido de ''{0}''
action.calculate.retained.size.waiting.message=Calculando tamaño retenido...
action.do.not.stop.if.called.from.text=No detener si se llama desde: {0}
action.do.not.stop.in.class.text=No detenerse en la clase: {0}
action.failed=Acción fallida
action.hide.text=Ocultar
action.interrupt.thread.text=Interrumpir
action.resume.thread.text.resume=Reanudar
action.show.objects.text=Mostrar {0} objetos...
action.stop.only.if.called.from.text=Detener únicamente si se invoca desde: {0}
action.stop.only.in.class.text=Parar solamente en la clase: {0}
action.stop.only.in.current.object.text=Detener solo en el objeto actual
action.watch.method.return.value.description=Habilita el seguimiento del último valor de retorno del método ejecutado
action.watches.method.return.value.enable=Mostrar valores de retorno del método
action.watches.method.return.value.unavailable.reason=La función no está soportada por la MV objetivo
add.exception.breakpoint.classchooser.title=Ingrese la clase de excepción
add.field.breakpoint.dialog.classchooser.title=Seleccionar clase de campo
add.field.breakpoint.dialog.field.chooser.title={0,choice, 0#Clase no tiene campos|1#Seleccionar campo}
add.field.breakpoint.dialog.title=Agregar punto de interrupción de campo
add.instance.filter.dialog.error.numeric.value.expected=El ID de instancia debería ser un valor numérico de tipo 'long'
add.instance.filter.dialog.prompt=Introduce el ID de la instancia:
add.instance.filter.dialog.title=Agregar Filtro de Instancia
add.method.breakpoint=Añadir punto de interrupción de método
add.stepping.filter=Añadir filtro de rastreo
array.filter.node.clear.link=Borrar
async.stacktraces.configurable.display.name=Rastros de pila asíncronos
breakpoint.any.exception.display.name=Cualquier excepción
breakpoint.properties.panel.option.caller.filter=Filtros de Caller:(&R)
breakpoint.properties.panel.option.catch.class.filters=Filtros de atrapamiento de clase:(&H)
breakpoint.properties.panel.option.class.filters=Filtros de clase:(&L)
breakpoint.properties.panel.option.instance.filters=Filtros de instancia:(&I)
breakpoint.properties.panel.option.pass.count=Número de pasadas:(&P)
breakpoint.property.name.class.filters=Filtros de clase:
breakpoint.property.name.instance.filters=Filtros de instancias:
breakpoint.property.name.pass.count=Número de pases
breakpoint.variant.text.line=Línea
breakpoint.variant.text.line.and.lambda=Línea y {0,choice,1#lambda|2#lambdas}
breakpoint.variant.text.line.and.lambda.uknown.count=Línea y Lambda(s)
button.add=Añadir
button.copy=Copiar
button.debugger.settings=Configuración del depurador...
button.drop.anyway=No ejecutar
button.execute.finally=Ejecutar bloques finally
button.perform.reload.classes=Ejecutar Recargar clases
button.skip.reload.classes=Omitir recarga de clases(&S)
call.tracer=Trazador de llamadas
caller.filters.dialog.title=Filtros de llamadas
cancel.emulation=Cancelar emulación
capture.node.settings.link=Ajustes
checkbox.start.tracing=iniciar
checkbox.stop.tracing=detener
checkbox.tracing=Trazado
checkbox.tracking.filters=filtros
class.filters.dialog.exclusion.filters.group=Excluir
class.filters.dialog.inclusion.filters.group=Incluir
class.filters.dialog.title=Filtros de clases
class.pattern.not.specified=Patrón de clase no especificado
collection.history=Historial de colecciones
collection.history.tab.title=Historial de {0}
collection.watchpoint.description=Punto de observación de colección
collection.watchpoints.tab.title=Puntos de observación de la colección Java
column.name.hits=Aciertos
column.name.instances=Instancias
column.name.retained.size=Tamaño retenido
column.name.shallow.size=Tamaño superficial
column.name.time.ms=Tiempo (ms)
command.name.surround.with.runtime.cast=Rodear con una conversión en tiempo de ejecución
condition=Condición:
debugger.actions.group.title=Acciones del depurador
debugger.attach.group.name.java=Java
debugger.attach.group.name.java.read.only=Java solo lectura
debugger.attach.password.for.sudo=Introduce tu contraseña para adjuntar con privilegios su:
debugger.collection.visualizer.title=Visualización de colecciones
debugger.collection.visualizer.title.0=Presentación de la colección: {0}
debugger.data.views.configurable.show.title=Mostrar
debugger.jdi.bootstrap.error={0}. Verifique la instalación de su JDK.
debugger.memory.agent.loading.error=No se pudo cargar el agente de memoria a la MV
debugger.memory.agent.timeout.error=Tiempo de espera del cálculo (el heap es demasiado grande y el agente de memoria no puede ejecutar esta operación en un tiempo razonable, es preferible capturar el volcado del heap)
default.package.name=<Default>
dialog.title.exception.to.throw=Excepción a lanzar
dialog.title.return.value=Valor Retornado
drop.frame.error.no.information=No hay información disponible del frame
editor.notification.alternative.source=Fuente alternativa disponible para la clase {0}
enable.tracking.for.new.instances=Habilitar rastreo para nuevas instancias
error.absent.exception.breakpoint.class.name=Nombre de clase inexistente para punto de ruptura de excepción
error.array.renderer.configurable.end.index.less.than.start=El índice final es menor que el índice inicial
error.array.renderer.configurable.start.index.less.than.zero=El índice de inicio es menor que 0
error.breakpoint.file.not.found=Archivo ''{0}'' no encontrado; se ignorarán los puntos de interrupción para este archivo
error.cannot.create.expression.from.code.fragment=No se puede crear una expresión a partir de un fragmento de código.
error.cannot.load.breakpoint.file=No se pudo cargar el archivo ''{0}''; se ignorarán los puntos de interrupción para este archivo
error.cannot.open.debugger.port=No se puede abrir el puerto del depurador
error.class.circularity.error=Error de circularidad de clase: {0}
error.class.def.not.found=Definición de clase no encontrada: {0}
error.class.format.error=Error de formato de clase: {0}
error.class.not.loaded=Clase no cargada: {0}
error.compound.renderer.configurable.fqn.generic=No se permiten tipos genéricos
error.context.has.changed=El contexto ha cambiado, la operación no es posible
error.context.not.available=El contexto no está disponible
error.corrupt.debug.info=La información de depuración puede estar corrupta: {0}
error.debug.connector.not.found=No se encontró el conector requerido ''{0}''. Compruebe su instalación de JDK.
error.debugger.already.listening=El depurador ya está escuchando
error.early.return=Error al hacer un retorno temprano: {0}
error.evaluating.breakpoint.condition.or.action=Problema procesando evento VM:
error.exception.while.connecting=Error durante la conexión a un proceso remoto.
error.exception.while.reloading=Excepción al recargar las clases: {0}: {1}
error.executing.finally=Error al ejecutar los bloques finally: {0}
error.failed.evaluating.breakpoint.condition=Error al evaluar la condición del punto de interrupción
error.field.breakpoint.class.name.not.specified=No se puede añadir watchdog: no se especificó un nombre de clase
error.field.breakpoint.class.sources.not.found=No se puede crear un punto de observación de campo para ''{0}.{1}''.
error.field.breakpoint.field.name.not.specified=No se puede agregar watchpoint: No se especificó un nombre de campo
error.field.breakpoint.field.not.found=No se puede crear un punto de observación de campo para ''{0}.{1}''.
error.field.not.found.in.class=El campo {0} no existe en {1}
error.inconsistent.debug.info=Información de depuración inconsistente
error.internal=Error interno
error.invalid.argument={0,choice, 1#Argumento inválido|2#Argumentos inválidos}
error.invalid.breakpoint.method.not.found=Método no encontrado en la clase {0}
error.invalid.breakpoint.missing.field.in.class=No se encuentra el campo ''{0}'' en la clase ''{1}''
error.invalid.breakpoint.no.executable.code=No se ha encontrado código ejecutable en la línea {0} en la clase {1}
error.invalid.breakpoint.no.line.info=Los números de línea no están disponibles en la clase {0}
error.invalid.breakpoint.source.changed=El archivo fuente ha cambiado o no se encuentra o el archivo encontrado no corresponde al archivo del punto de interrupción
error.invalid.breakpoint.source.not.found=La clase {0}, encontrada en el classpath del proyecto, no tiene archivos de origen asociados
error.invalid.field.name=Nombre de campo no válido ''{0}''
error.invalid.local.variable.name=Nombre de variable local inválido ''{0}''
error.invalid.stackframe=Excepción interna - stackframe inválido
error.invalid.type.name=Nombre de tipo no válido ''{0}''
error.io.error=Error de E/S
error.jdk.not.specified=JDK no especificado
error.native.method.exception=Ninguno de los frames incluyendo **frame** puede ser nativo
error.no.debug.attach.port=El puerto de conexión no está especificado
error.no.debug.listen.port=El puerto para escuchar no se ha especificado
error.no.debug.process=Sin proceso de depuración
error.no.pid=Pid no especificado
error.no.shmem.address=Dirección de memoria compartida no especificada
error.operation.canceled=Operación cancelada
error.operation.not.supported.by.vm=Operación no soportada por la máquina virtual
error.pop.bottom.stackframe=No se puede eliminar el marco inferior
error.pop.stackframe=Se ha producido un error al hacer pop del frame de pila: {0}
error.running.to.cursor.no.executable.code=No hay código ejecutable en {0}:{1}
error.text.invalid.port=Puerto no especificado
error.throw.exception=Error al lanzar la excepción: {0}
error.unable.to.create.sapidattachingconnector=No es posible crear SAPIDAttachingConnector
error.unable.to.evaluate.capture.expression=No se pudo evaluar la expresión de la clave de captura: {0}
error.unable.to.evaluate.children.expression=No se puede evaluar la expresión del renderizador de subconjuntos
error.unable.to.evaluate.expression=No se puede evaluar la expresión
error.unable.to.evaluate.insert.expression=No se puede evaluar la expresión de inserción de clave: {0}
error.unknown.host=No se pudo conectar al proceso remoto. El host es desconocido
error.unknown.host.with.address=No se puede conectar al proceso remoto. El host es desconocido ({0})
error.unsupported.class.version=Versión no compatible de clase: {0}
error.verification.error=Error de verificación: {0}
error.vm.disconnected=VM desconectada. La máquina virtual de destino cerró la conexión
evaluation.error.anonymous.class.evaluation.not.supported=No se admite la evaluación de la clase anónima
evaluation.error.array.collected=El array ha sido recopilado
evaluation.error.array.dimention.numeric.value.expected=Se esperaba valor numérico como dimensión de array
evaluation.error.array.reference.expected=Se esperaba una referencia de matriz
evaluation.error.array.type.expected=Se esperaba tipo Array
evaluation.error.boolean.condition.expected=se esperaba un valor 'booleano' en la condición
evaluation.error.boolean.expected=Se esperaba un valor booleano
evaluation.error.boolean.value.expected.in.condition=Se esperaba un valor de tipo 'boolean' para este parámetro
evaluation.error.cannot.cast.boolean=No se puede convertir el valor booleano en ''{0}''
evaluation.error.cannot.cast.char=No se puede convertir un valor de caracter a ''{0}''
evaluation.error.cannot.cast.null=No se puede convertir null a ''{0}''
evaluation.error.cannot.cast.numeric=No se puede convertir el valor numérico a ''{0}''
evaluation.error.cannot.cast.object=No se puede convertir ''{0}'' a ''{1}''
evaluation.error.cannot.evaluate.array.initializer=No se pueden evaluar los valores de inicialización del arreglo
evaluation.error.cannot.evaluate.class.type=No se puede evaluar el tipo de clase
evaluation.error.cannot.evaluate.qualifier=No se puede evaluar el calificador ''{0}''
evaluation.error.cannot.evaluate.tostring=No se pudo evaluar {0}.toString()
evaluation.error.cannot.find.source=No se puede encontrar la clase fuente para {0}
evaluation.error.cannot.find.stackframe.source=No se puede encontrar la clase fuente para el marco de pila actual
evaluation.error.cannot.initialize.array=No se puede inicializar el array
evaluation.error.cannot.resolve.constructor=No se puede resolver el constructor ''{0}''
evaluation.error.cannot.resolve.field.class=No puede resolverse la clase que contiene el campo ''{0}''
evaluation.error.cannot.sources.for.field.class=No se puede encontrar el origen de la clase que contiene el campo ''{0}''
evaluation.error.class.not.loaded=No se ha cargado la clase ''{0}''
evaluation.error.class.or.array.expected=Se esperaba un tipo clase o array al evaluar el campo ''{0}''
evaluation.error.debug.info.unavailable=Info de debug no disponible
evaluation.error.during.indexing=No es posible evaluar durante la indexación
evaluation.error.empty.code.fragment=Se espera un fragmento de código
evaluation.error.evaluating.field=Error en la evaluación del campo: ''{0}''
evaluation.error.evaluating.method=Error evaluando el método : ''{0}''
evaluation.error.identifier.expected=Identificador esperado en lugar de ''{0}''
evaluation.error.incompatible.array.initializer.type=El tipo de inicializador no coincide con el tipo de componente matriz
evaluation.error.incompatible.types=Tipos incompatibles para la operación ''{0}''
evaluation.error.incompatible.variable.initializer.type=El inicializador para ''{0}'' tiene un tipo incompatible
evaluation.error.inconsistent.debug.info=La información de depuración es inconsistente
evaluation.error.integer.expected=Se esperaba un valor entero
evaluation.error.invalid.array.dimension.expression=Expresión no válida para la dimensión del array: {0}
evaluation.error.invalid.array.size=Tamaño de array no válido
evaluation.error.invalid.expression=Expresión inválida : {0}
evaluation.error.invalid.index.expression=Expresión de índice no válida
evaluation.error.invalid.this.expression=No se puede sustituir ''{0}'' en ''{1}'' como ''this''
evaluation.error.invalid.type.name=Nombre de tipo no válido: ''{0}''
evaluation.error.lambda.evaluation.not.supported=La evaluación de Lambdas no es compatible
evaluation.error.lebeled.loops.not.found=No hay un bucle etiquetado con la etiqueta "{0}"
evaluation.error.local.variable.declarations.not.supported=No se soportan declaraciones de variables locales aquí.
evaluation.error.local.variable.missing=No se encuentra la variable local ''{0}''
evaluation.error.local.variable.missing.from.class.closure=La variable local ''{0}'' no se encuentra en el cierre de clase
evaluation.error.method.exception=El método lanzó la excepción ''{0}''.
evaluation.error.method.reference.evaluation.not.supported=La evaluación de la referencia al método no es compatible
evaluation.error.multi.dimensional.arrays.creation.not.supported=La creación de matrices multidimensionales no es compatible
evaluation.error.nested.evaluation=La evaluación no es compatible durante la evaluación de otro método
evaluation.error.no.instance.field=No existe dicho campo de instancia: ''{0}''
evaluation.error.no.instance.method=Ningún método de instancia de este tipo: ''{0}''
evaluation.error.no.stackframe=No se puede evaluar: marco de pila no disponible
evaluation.error.no.static.field=No existe dicho campo estático: ''{0}''
evaluation.error.no.static.method=No existe ningún método estático: ''{0}''
evaluation.error.not.lvalue=La parte izquierda de la asignación no es un lvalue
evaluation.error.not.rvalue=El lado derecho de la asignación no es un valor
evaluation.error.numeric.expected=Se esperaba valor numérico
evaluation.error.object.collected=El objeto fue recolectado
evaluation.error.object.is.being.initialized=El objeto se está inicializando
evaluation.error.object.reference.expected=Se esperaba referencia de objeto
evaluation.error.operation.not.supported=La operación ''{0}'' no es válida
evaluation.error.process.exited=No se puede evaluar: ejecución del proceso terminada
evaluation.error.signature.polymorphic.call.evaluation.not.supported=La evaluación de llamadas polimórficas de firma no está soportada
evaluation.error.sources.out.of.sync=Fuentes no coinciden con el código que se está ejecutando
evaluation.error.stack.frame.unavailable=Marco de pila no disponible
evaluation.error.statement.not.supported=La declaración ''{0}'' no es compatible
evaluation.error.surrounded.expression.null=Expresión rodeada es nula
evaluation.error.this.not.avalilable='this' no está disponible
evaluation.error.thread.collected=Hilo recopilado
evaluation.error.thread.not.at.breakpoint=No se pueden evaluar métodos tras la acción Pausar
evaluation.error.thread.resumed=Hilo reiniciado
evaluation.error.type.mismatch=Error de tipo no coincidente
evaluation.error.unknown.expression.operand=Operando de expresión desconocido: {0}
evaluation.error.unknown.expression.type=Tipo de expresión desconocido: {0}
evaluation.error.unknown.method.return.type=No se puede resolver el tipo de retorno del método: {0}
evaluation.error.unknown.type=No se puede resolver el tipo: {0}
evaluation.error.unsupported.declaration=Declaración no válida: {0}. Solo se admiten declaraciones de variables locales.
evaluation.error.unsupported.expression.type=Tipo de expresión no admitido
evaluation.error.variable.already.declared=La variable ''{0}'' ya está declarada
evaluation.error.variable.not.declared=La variable ''{0}'' no está declarada
exception.breakpoint.console.message=Ocurrió la excepción ''{0}'' en {1}({2})
exception.breakpoint.console.message.location.info={0}:{1,number,#}
exception.breakpoint.console.message.location.info.absent=No hay información de depuración
exception.breakpoint.console.message.with.thread.info=La excepción ''{0}'' ocurrió en el hilo ''{1}'' en {2}({3})
exception.breakpoint.description=Punto de interrupción de excepción
exception.breakpoints.tab.title=Puntos de ruptura de excepciones de Java
export.failed=Error al exportar
export.selected.capture.points.to.file=Exportar Puntos de Captura Seleccionados a Archivo...
field.watchpoint.description=Punto de control de campo
field.watchpoint.property.name.access=Acceso a la observación:
field.watchpoint.property.name.modification=Vigilancia de la modificación:
field.watchpoints.tab.title=Puntos de control de campos Java
filters=Filtros...
filters.not.configured=Sin filtros configurados
frame.panel.async.stacktrace=Rastreo de pila asíncrono
frame.panel.frames.not.available=Los frames no están disponibles para thread no suspendido
frame.panel.thread.finished=El subproceso ha finalizado la ejecución
hotswap.dialog.hang.warning=La JVM está actualmente suspendida.\nRecargar clases con agentes JVM de terceros activos puede hacer que la JVM se bloquee. 
hotswap.dialog.reload.action.text=Recargar
hotswap.dialog.run.prompt=Algunas clases han sido modificadas. ¿Desea recargar las clases modificadas ahora?
hotswap.dialog.title=Recargar clases modificadas
hotswap.dialog.title.with.session=Recargar las clases de {0} modificadas
if.the.value.is.referenced.by.a.constant.field=Si el valor es referenciado por un campo constante de una clase abstracta, \nIDEA podría adicionalmente marcar todos los valores referenciados desde esta clase con los nombres de los campos de referencia. 
import.capture.points=Puntos de captura de importación
instance.filters.dialog.title=Filtros de instancia
instances.window.show.history=InstancesWindow.MostrarHistorial
internal.debugger.error=Error interno. Revisa los logs para más detalles
internal.error.locations.of.line=Error interno al cargar información de depuración desde ''{0}''. Los breakpoints no estarán disponibles en esta clase.
invoke.completion.once.more=Invocar completado una vez más para ver variantes de tipo en ejecución
label.add.field.breakpoint.dialog.field.name=Nombre del campo:
label.add.field.breakpoint.dialog.fq.name=Nombre completamente cualificado de una clase:
label.add.wildcard.breakpoint.dialog.class.pattern=Patrón de clase(&C)
label.add.wildcard.breakpoint.dialog.method.name=Nombre del método:(&M)
label.array.renderer.configurable.end.index=Índice final:(&D)
label.array.renderer.configurable.max.count1=Mostrar el máximo
label.array.renderer.configurable.max.count2=elementos arrays
label.array.renderer.configurable.start.index=Índice inicial del array:(&R)
label.arrays.could.not.be.tracked=No se pueden rastrear arreglos
label.base.renderer.configurable.all.overriding=Para todas las clases que sobreescriben el método 'toString()'
label.base.renderer.configurable.alternate.view=Habilidar vista alternativa para clases de colecciones(&E)
label.base.renderer.configurable.autoscroll=Autodeslizamiento a nuevas variables locales
label.base.renderer.configurable.classes.from.list=Para las clases de la lista:
label.base.renderer.configurable.dfa.assist=Predice valores de condición y excepciones según el análisis del flujo de datos
label.base.renderer.configurable.dfa.assist.gray.out=Atenuar bloques de código que se predice que serán inalcanzables
label.base.renderer.configurable.enable.toString=Habilitar vista de objeto 'toString()':(&O)
label.base.renderer.configurable.hide.null.array.elements=Ocultar elementos null de las matrices y colecciones(&N)
label.base.renderer.configurable.populate.throwable.stack=Rellenar automáticamente el seguimiento de pila del objeto Throwable
label.base.renderer.configurable.show.declared.type=Tipo declarado(&T)
label.base.renderer.configurable.show.fq.names=Nombres completos y calificados(&Q)
label.base.renderer.configurable.show.hex.value=Mostrar valor hexadecimal para primitivos
label.base.renderer.configurable.show.object.id=Objeto id
label.base.renderer.configurable.show.static.fields=Campos estáticos(&S)
label.base.renderer.configurable.show.static.final.fields=Campos estáticos y finales(&F)
label.base.renderer.configurable.show.strings.type=Mostrar tipo para cadenas
label.base.renderer.configurable.show.synthetic.fields=Campos sintéticos(&Y)
label.base.renderer.configurable.show.val.fields.as.locals=Campos $val como variables locales(&V)
label.capture.configurable.annotations.configure=Configurar anotaciones...
label.capture.configurable.capture.variables=Captura variables locales (puede ralentizar significativamente la ejecución)
label.capture.configurable.debugger.agent=Agente de instrumentación (requiere reiniciar el depurador)
label.capture.point.at=Punto de captura en {0}.{1}
label.collection.breakpoint.properties.save.history=Guardar historial de colección
label.compound.renderer.configurable.append.default.children=Agregar elementos predeterminados
label.compound.renderer.configurable.apply.to=Aplicar el renderizador a objetos de tipo (nombre completamente calificado):
label.compound.renderer.configurable.ondemand=Bajo demanda
label.compound.renderer.configurable.show.type=Mostrar tipo e id de objeto
label.compound.renderer.configurable.table.header.expression=Expresión
label.compound.renderer.configurable.table.header.name=Nombre
label.compound.renderer.configurable.table.header.ondemand=A petición
label.compound.renderer.configurable.test.can.expand=Prueba si un nodo se puede expandir (opcional):
label.compound.renderer.configurable.use.default.renderer=Usar el presentador predeterminado
label.compound.renderer.configurable.use.expression=Usar la siguiente expresión:
label.compound.renderer.configurable.use.expression.list=Usar lista de expresiones:
label.compound.renderer.configurable.when.expanding=Al expandir un nodo
label.compound.renderer.configurable.when.rendering=Al representar un nodo
label.debugger.general.configurable.always.debug=Iniciar configuraciones de ejecución con el agente depurador
label.debugger.general.configurable.always.smart.step.into=Siempre realizar un paso a paso inteligente
label.debugger.general.configurable.enable.memory.agent=Conectar agente de memoria
label.debugger.general.configurable.enable.memory.agent.tooltip.text=El depurador de Java proporcionará información adicional sobre los objetos en el heap
label.debugger.general.configurable.evaluate.finally.always=Siempre(&A)
label.debugger.general.configurable.evaluate.finally.ask=Preguntar(&K)
label.debugger.general.configurable.evaluate.finally.never=Nunca(&E)
label.debugger.general.configurable.evaluate.finally.on.pop=Evaluar bloques finally en el marco de pop y retorno anticipado:
label.debugger.general.configurable.hide.stack.frames.using.step.filter=Ocultar marcos de pila mediante filtros de paso(&F)
label.debugger.general.configurable.kill.immediately=Finalizar inmediatamente el proceso de depuración
label.debugger.general.configurable.resume.only.current.thread=Reanudar sólo el hilo actual
label.debugger.general.configurable.show.alternative.source=Mostrar el cambiador de fuente alternativo
label.debugger.general.configurable.skip.classLoaders=Saltar cargador de clases
label.debugger.general.configurable.skip.constructors=Saltar constructores(&C)
label.debugger.general.configurable.skip.simple.getters=Omitir getters simples(&G)
label.debugger.general.configurable.skip.synthetic.methods=Omitir métodos sintéticos(&P)
label.debugger.general.configurable.step.filters.list.header=No entrar en las clases(&I)
label.debugger.hotswap.configurable.always=Siempre(&A)
label.debugger.hotswap.configurable.ask=Preguntar(&K)
label.debugger.hotswap.configurable.compile.before.hotswap=Compilar proyecto antes de recargar clases
label.debugger.hotswap.configurable.enable.vm.hang.warning=Activar advertencia de 'JVM se bloqueará'
label.debugger.hotswap.configurable.never=Nunca(&N)
label.debugger.hotswap.configurable.reload.classes=Recargar clases después de compilar:
label.debugger.hotswap.configurable.suggest.in.editor=Sugerir HotSwap en el editor cuando se modifique el código
label.debugger.hotswap.option.suggest.in.editor=Sugerir HotSwap en el editor
label.debugger.launching.configurable.debugger.transport=Transporte:
label.debugger.launching.configurable.disable.jit=Desactivar JIT
label.debugger.launching.configurable.shmem=Memoria compartida
label.debugger.launching.configurable.socket=Socket
label.exception.breakpoint.properties.panel.caught.exception=Excepción detectada(&N)
label.exception.breakpoint.properties.panel.group.notifications=Notificaciones
label.exception.breakpoint.properties.panel.uncaught.exception=Excepción no capturada(&O)
label.field.breakpoint.properties.panel.field.access=Acceso de campo
label.field.breakpoint.properties.panel.field.modification=Modificación de campo(&M)
label.generic.debugger.parameters.patcher.configurable.port=Puerto:
label.generic.debugger.parameters.patcher.configurable.shmem=Memoria compartida
label.generic.debugger.parameters.patcher.configurable.shmem.address=Dirección de memoria compartida:
label.generic.debugger.parameters.patcher.configurable.socket=Socket(&S)
label.generic.debugger.parameters.patcher.configurable.transport=Transporte:
label.group.watch.events=Ver
label.instrumentation.tracker=Rastreador de instrumentación: {0}
label.method.breakpoint.properties.panel.emulated=Emulado(&U)
label.method.breakpoint.properties.panel.method.entry=Entrada de método(&Y)
label.method.breakpoint.properties.panel.method.exit=Salida de método(&X)
label.method.breakpoints.processing.classes=Procesamiento de clases para puntos de interrupción de métodos emulados
label.method.breakpoints.setting.breakpoints=Ajuste de puntos de interrupción de método emulado
label.object.markup.dialog.mark.referenced=Marcar valores referenciados desde constantes
label.thread.group.node=Grupo de subprocesos "{0}"@{1}
label.thread.group.node.group.collected=El grupo de subprocesos "{0}" se recolectó como basura
label.thread.node="{0}"@{1}: {2}
label.thread.node.in.group="{0}"@{1} en grupo "{3}": {2}
label.thread.node.thread.collected=Hilo ''{0}'' ha sido recogido por el recolector de basura
label.threads.view.configurable.current.thread.on.top=Mover hilo actual al principio
label.threads.view.configurable.show.class.name=Mostrar nombre de clase
label.threads.view.configurable.show.line.number=Mostrar número de línea
label.threads.view.configurable.show.package=Mostrar nombre de paquete
label.threads.view.configurable.show.prams.types=Mostrar tipos de parámetros del método
label.threads.view.configurable.show.source.file.name=Mostrar archivo fuente
label.threads.view.configurable.show.stack.frames.for.synthetic.methods=Mostrar marcos de pila para métodos sintéticos(&F)
label.threads.view.configurable.show.thread.groups=Mostrar grupos de subprocesos(&G)
label.too.many.frames.rest.truncated=Demasiados marcos, el resto se trunca...
label.undefined=No definido
label.unknown.value=<desconocido>
label.user.renderers.configurable.renderer.name=Nombre del renderizador:
line.breakpoint.description.basic.line=Punto de interrupción de línea
line.breakpoint.description.conditional.return=Punto de ruptura de retorno
line.breakpoint.description.lambda=Punto de interrupción de lambda
line.breakpoint.display.name=Línea {0,number,#}
line.breakpoint.display.name.with.class.or.method=Línea {0,number,#} en {1}
line.breakpoint.display.name.with.column=Línea {0,number,#} columna {1,number,#}
line.breakpoint.display.name.with.column.and.class.or.method=Línea {0,number,#} columna {1,number,#} en {2}
line.breakpoints.tab.title=Puntos de ruptura de línea de Java
memory.toolwindow.title=Memoria
memory.view.constructor.tracker.name=MemoryViewConstructorTracker: {0}
message.breakpoint.skipped.during.evaluation=Punto de corte omitido en {0} porque sucedió dentro de evaluación del depurador
message.breakpoint.skipped.during.stepping.in.another.thread=Punto de interrupción omitido en {0} debido al paso a paso en otro hilo
message.breakpoint.skipped.learn.more=Guía de solución de problemas
message.breakpoint.skipped.other.vm=Se omitió el punto de interrupción en {0} por que sucedió fuera de la JVM actual
message.conditional.return.breakpoint.on.android=Los puntos de interrupción en retorno condicional aún no son compatibles en Android; se establece un punto de interrupción regular de línea.
message.node.all.array.elements.null=Todos los elementos en el rango ({0}, {1}) son null
message.node.all.elements.null=Todos los elementos son nulos
message.node.array.elements.more=+{0} más
message.node.class.has.no.fields=La clase no tiene campos
message.node.class.no.fields.to.display=No hay campos a mostrar
message.node.debug.info.not.available=Información de depuración no disponible
message.node.elements.null.hidden=Ocultar elementos null
message.node.empty.array=Vacio
message.node.evaluate=... Evaluar
message.node.evaluation.not.possible=La MV de destino no está en pausa por la solicitud del punto de interrupción. La evaluación de los métodos no es posible en este modo
message.node.filtered=Filtrado por:
message.node.local.variables.capture.disabled=Las variables locales no fueron capturadas, puedes cambiarlo en
message.node.local.variables.debug.info.not.available=Variables de depuración no disponibles
message.node.local.variables.not.captured=Las variables locales no se capturan para métodos sintéticos, puente, etc.
message.node.navigate=... Navegar
message.node.object.collected=El objeto ha sido recolectado como basura durante la llamada a método
message.node.open=… Abrir
message.node.show.icon=... Mostrar icono
message.node.show.image=... Mostrar imagen
message.node.thread.has.no.frames=El hilo no tiene frames
message.node.thread.running=Hilo en ejecución
message.node.toString=... toString()
message.other.threads.reached.breakpoints={0,choice,1#Otro hilo también alcanzó un punto de interrupción|2#{0} otros hilos también alcanzaron puntos de interrupción}
message.remote.jre.version.mismatch=La versión del JRE de destino ({0}) no coincide con la versión del JDK del proyecto ({1}), se usarán las fuentes del JDK: {2}
method.breakpoint.description=Punto de interrupción de método
method.breakpoint.property.name.emulated=Emulado:
method.breakpoint.property.name.watch.entry=Entrada de observación:
method.breakpoint.property.name.watch.exit=Observar salida:
method.breakpoints.slowness.warning=Los puntos de interrupción en los métodos pueden retrasar la depuración dramáticamente
method.breakpoints.tab.title=Puntos de interrupción del método Java
method.name.not.specified=Nombre del método no especificado
notification.group.hotswap=Se realizó intercambio en caliente
notification.method.has.not.been.called=El método <b>{0}()</b> no se ha invocado
overhead.toolwindow.title=Sobrecarga
paths.to.closest.gc.roots.for=Rutas a las raíces GC más cercanas para {0}
please.select.a.file.to.import=Seleccionar fichero a importar
process.attach.run.configuration.type.name=Depurar proceso
progress.evaluating=Evaluando {0}
progress.hot.swap.title=Sustitución en caliente
progress.hotswap.reloading=Recargando clases...
progress.hotswap.scanning.classes=Escaneando clases para recargar...
progress.hotswap.scanning.path=Escaneo: {0}
progress.suffix.filtering.has.been.interrupted=(El filtrado ha sido interrumpido)
progress.suffix.limit.has.been.reached=(Se ha alcanzado el límite)
progress.text.errors.count=Errores: {0}
progress.text.shown.x.of.y=Mostrado: {0} / {1}
renderer.name={0} renderizador
rule.name.group.by.class=Agrupar por clase
rule.name.group.by.package=Agrupar por paquete
select.stack.frame=Seleccionar marco de pila
settings.async.annotations.configuration=Configuración de anotaciones asíncronas
settings.async.execute=Ejecutar asíncronamente
settings.async.schedule=Planificación asincrónica
settings.breakpoints.based=Puntos de interrupción basados en:
settings.capture.column.capture.class.name=Capturar nombre clase
settings.capture.column.capture.key.expression=Expresión de tecla de captura
settings.capture.column.capture.method.name=Nombre del método de captura
settings.capture.column.insert.class.name=Insertar Nombre de la Clase
settings.capture.column.insert.key.expression=Insertar expresión de clave
settings.capture.column.insert.method.name=Insertar nombre del método
status.app.running=Aplicación en ejecución
status.breakpoint.invalid=PUNTODEINTERRUPCIÓNNOVÁLIDO
status.breakpoint.reached.in.thread=Punto de ruptura alcanzado en el hilo {0}
status.breakpoint.reached.in.thread.switch=<a href="#">Cambiar hilo</a> 
status.classes.not.all.versions.reloaded=Para {0} de {1} {1,choice, 1#clase|2#clases} no se recargaron todas las versiones
status.classes.reloaded={0,number} {0,choice, 0#clases|1#clase|2#clases} recargadas
status.connect.failed=No se pudo establecer conexión con la VM de destino, dirección: {0}
status.connected=Conectado a la VM de destino, dirección: {0}
status.connecting=Conectando a la máquina virtual objetivo, dirección: {0}
status.debug.stopped=Depuración detenida
status.disconnected=Desconectado de la VM de destino, dirección: {0}
status.field.watchpoint.reached.access='{'{0}@{5}'}'.{1} se accederá en {2}({3}:{4,number,#})
status.field.watchpoint.reached.modification='{'{0}@{7}'}'.{1} se va a modificar en {4}({5}:{6,number,#}). Valor actual = ''{2}''. Nuevo valor = ''{3}''
status.generic.breakpoint.reached=Se alcanzó punto de interrupción
status.hot.swap.completed.restart=Reiniciar sesión de depuración
status.hot.swap.completed.stop=Detener sesión de depuración
status.hot.swap.completed.with.errors=Hot Swap fallido
status.hot.swap.completed.with.warnings=Intercambio activo completado con advertencias
status.hotswap.loaded.classes.up.to.date=Las clases cargadas están actualizadas. No hay nada para volver a cargar
status.hotswap.uptodate=Las clases cargadas están actualizadas. No hay cambios recientes.
status.invalid.breakpoint.out.of.class=El punto de interrupción no pertenece a ninguna clase
status.line.breakpoint.reached=Punto de interrupción alcanzado en {0}({1}:{2,number,#})
status.line.breakpoint.reached.full.trace=Rastreo de punto de interrupción completo alcanzado
status.listening=Escuchando la conexión, dirección: {0} 
status.method.entry.breakpoint.reached=Método ''{0}'' ingresó en {1}({2}:{3,number,#})
status.method.exit.breakpoint.reached=Punto de corte de método alcanzado. El método ''{0}'' está a punto de salir en {1}({2}:{3,number.#})
status.paused=En pausa
status.paused.in.another.thread=Pausado en otro hilo
status.process.resumed=Proceso reanudado
status.process.started=Proceso iniciado
status.process.terminated=Proceso terminado
status.run.to.cursor=Ejecutar hasta el cursor
status.run.to.cursor.in=Ejecutar hasta el cursor en {0}
status.static.field.watchpoint.reached.access={0}.{1} será accedido en {2}({3}:{4,number,#})
status.static.field.watchpoint.reached.modification={0}.{1} se modificará en {4}({5}:{6,number,#}). Valor actual = ''{2}''. Nuevo valor = ''{3}''
status.step.into=Paso a
status.step.out=Bajar de nivel
status.step.over=Paso a
status.stepping.in=Entrando en {0}
status.stopped.at.cursor=Detenido en el cursor
status.text.no.stack.frame.for.this.instance=No hay marco de pila para esta instancia
status.text.select.instance.to.see.stack.frame=Selecciona una instancia para ver la pila de llamadas
status.thread.blocked.by=La ejecución por pasos en el hilo {0} está bloqueada por el hilo {1}
status.thread.blocked.by.resume=<a href="#">Reanudar {0}</a>
status.thread.monitor=MONITOR
status.thread.not.started=NOINICIADO
status.thread.running=EJECUTANDO
status.thread.sleeping=Dormido
status.thread.undefined=NODEFINIDO
status.thread.unknown=Desconocido
status.thread.wait=ESPERA
status.thread.zombie=ZOMBIE
status.waiting.attach=Debugger esperando el inicio de la aplicación
status.waiting.attach.address=dirección de depuración: {0}
status.waiting.evaluation.result=Espera hasta que finalice el último comando del depurador
stepping.filter.real.thread.name=Hilo {0}
string.connection=''{0}'', transporte: ''{1}''
string.file.line.position=Clase en {0}:{1}
string.null.context=Contexto nulo
surround.with.runtime.type.template=((RuntimeType)expr)
text.user.renderers.configurable.no.renderers=Sin renderizadores
thread.dump=Volcado de subprocesos
thread.dump.name=Volcar {0}
thread.operation.interrupt.is.not.supported.by.vm=La operación de thread 'interrupt' no es soportada por la MV
threads.export.attribute.error.incompatible.state=Estado de hilo incompatible: hilo no suspendido
threads.export.attribute.label.blocks.thread=bloques {0}
threads.export.attribute.label.daemon=demonio
threads.export.attribute.label.locked=bloqueado {0}
threads.export.attribute.label.object-id=<0x{0}> (un {1})
threads.export.attribute.label.priority=prio={0}
threads.export.attribute.label.tid=tid=0x{0}
threads.export.attribute.label.waiting.for.thread=esperando que {0} libere el bloqueo en {1}
threads.view.configurable.display.name=Personalizar vista de hilos
title.compound.renderer.configurable.choose.renderer.reference.type=Tipo de referencia del renderizador
title.customize.data.views=Personalizar vistas de datos
title.error.evaluating.breakpoint.action=Error al Evaluar la Acción del Punto de Interrupción
title.error.evaluating.breakpoint.condition=Error en la condición del punto de ruptura
title.evaluating=Evaluando...
title.jdk140.unstable=Advertencia de versión VM
title.range.too.big=Rango demasiado grande
title.set.value=Establecer valor
title.smart.step.popup=Método a Depurar
tracing.class.filters=Filtros de clases de rastreo
transport.name.shared.memory=memoria compartida
transport.name.socket=socket
user.renderers.configurable.button.description.copy=Copia el renderizador seleccionado
user.renderers.configurable.display.name=Visores de Tipo Java
waiting.for.debugger.response=Esperando a que termine el proceso de forma correcta
warning.0=ADVERTENCIA! {0}
warning.filtering.may.have.side.effects=Advertencia: filtrar puede tener efectos colaterales
warning.finally.block.detected=Bloques finalmente no vacíos detectados:
warning.jdk140.unstable=La versión de la máquina virtual del depurador es "1.4.0".\nLos errores documentados en J2SDK 1.4.0 pueden provocar un comportamiento inestable del depurador.\nSe recomienda utilizar J2SDK 1.4.0_01 o una versión posterior.
warning.range.too.big=El rango especificado es demasiado grande. {0} necesita demasiados recursos para realizar la operación solicitada. ¿Estás seguro de que quieres continuar?
warning.recalculate=El valor será recalculado
warning.source.code.not.match=El código fuente no coincide con el bytecode