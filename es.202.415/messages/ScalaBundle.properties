### org/jetbrains/plugins/scala/DesktopUtils.scala
title.problem.opening.web.page=웹 페이지 열기 문제
html.unable.to.launch.web.browser=<html><body>웹 브라우저를 실행할 수 없으므로, 수동으로 여십시오\:<br />{0} (<a href\="{0}">클립보드로 복사</a>)</body></html>

### org/jetbrains/plugins/scala/actions/MakeExplicitAction.scala
make.implicit.conversion.explicit.action.text=묵시적 변환을 명시적으로 만들기
make.implicit.conversion.explicit.action.description=묵시적 변환을 명시적으로 만들기
title.choose.implicit.conversion.method=묵시적 변환 메소드 선택\:
press.alt.enter=Alt+Enter 누르기

### org/jetbrains/plugins/scala/actions/NewPackageObjectAction.scala
new.packageobject.menu.action.text=패키지 객체
new.packageobject.menu.action.description=새 Scala 패키지 객체 생성

### org/jetbrains/plugins/scala/actions/NewScalaTypeDefinitionAction.scala
newclass.menu.action.text=Scala 클래스
newclass.menu.action.description=새 Scala 클래스 생성
create.new.scala.class=새 Scala 클래스 생성
this.is.not.a.valid.scala.qualified.name=올바른 Scala 정규화된 이름이 아닙니다

### org/jetbrains/plugins/scala/actions/ScalaExpressionTypeProvider.scala
no.expression.found=표현식을 찾을 수 없습니다

### org/jetbrains/plugins/scala/actions/ShowTypeInfoAction.scala
type.info.text=유형 정보
type.info.description=유형 정보 표시

### org/jetbrains/plugins/scala/actions/ToggleTypeAwareHighlightingAction.scala
toggle.type.aware.highlighting.menu.action.text=유형 인식 강조 표시 전환
toggle.type.aware.highlighting.menu.action.description=유형 인식 강조 표시 전환

### org/jetbrains/plugins/scala/actions/implicitArguments/ImplicitArgumentNodes.scala
implicit.argument.is.applicable=묵시적 인수를 적용할 수 있습니다
implicit.is.diverged=implicit이 분기되었습니다
can.t.infer.proper.types.for.type.parameters=유형 매개변수에 적절한 유형을 추론할 수 없음
can.t.find.implicit.argument.for.this.definition=이 정의에 대한 묵시적 인수를 찾을 수 없습니다
no.implicits.applicable.by.type=유형별로 적용 가능한 묵시적 항목이 없습니다

### org/jetbrains/plugins/scala/actions/implicitArguments/ShowImplicitArgumentsAction.scala
show.implicit.arguments.action.text=묵시적 인수 표시
show.implicit.arguments.action.description=묵시적 인수 표시
no.implicit.arguments=묵시적 인수 없음
title.expressions=표현식
navigate=탐색
implicit.arguments.for.implicit.conversion=묵시적 변환에 대한 묵시적 인수\:
implicit.arguments=묵시적 인수\:

### org/jetbrains/plugins/scala/actions/implicitConvertions/ShowImplicitConversionsAction.scala
implicit.conversions.action.text=묵시적 변환 표시
implicit.conversions.action.description=묵시적 변환 표시

### org/jetbrains/plugins/scala/actions/internal/ScalaCollectShortTroubleshootingInfoAction.scala
scala.collect.troubleshooting.information.short.action.text=(Scala) 짧은 문제 해결 정보 수집
scala.collect.troubleshooting.information.short.action.description=Scala 플러그인 및 IntelliJ IDEA 버전을 수집하여 YouTrack에 빠르게 붙여넣으십시오
short.troubleshooting.summary.copied.to.your.clipboard.with.summary=짧은 문제 해결 요약이 클립보드에 복사됨\n\
{0}

### org/jetbrains/plugins/scala/annotator/AnnotatorUtils.scala
# TODO unify type mismatch messages
type.mismatch.found.required=유형 불일치, 발견\: {0}, 필요\: {1}
# TODO unify type mismatch messages
type.mismatch.expected.actual=유형 불일치, 기대\: {0}, 실제\: {1}
abstract.member.not.have.private.modifier=추상 멤버는 private 제어자를 가질 수 없습니다
illegal.inheritance.from.sealed.kind=봉인된 {0} ''{1}'' (으)로부터의 올바르지 않은 상속

### org/jetbrains/plugins/scala/annotator/ByNameParameter.scala
passed.as.by.name.parameter=by-name 매개변수로 전달됨

### org/jetbrains/plugins/scala/annotator/FunctionAnnotator.scala
function.must.define.type.explicitly=메소드 {0} 에 return 문이 있으므로 결과 유형이 필요합니다
function.recursive.need.result.type=재귀 메소드 {0} 에 결과 유형이 필요합니다
return.expression.is.redundant=Unit 결과 유형을 가진 메소드에서 {0} 반환 중
family.name.remove.tailrec.annotation=@tailrec 어노테이션 제거
method.annotated.with.tailrec.is.neither.private.nor.final=@tailrec 어노테이션이 지정된 메소드가 private 또는 final이 아닙니다(재정의될 수 있음)
method.annotated.with.tailrec.contains.no.recursive.calls=@tailrec 어노테이션이 지정된 메소드가 재귀 호출을 포함하지 않습니다
recursive.call.not.in.tail.position=재귀 호출이 꼬리 위치에 없습니다(@tailrec 어노테이션이 지정된 메소드 내)

### org/jetbrains/plugins/scala/annotator/OverridingAnnotator.scala
member.needs.override.modifier={0} ''{1}'' 에 재정의 제어자가 필요합니다
member.overrides.nothing={0} ''{1}'' 이(가) 아무 것도 재정의하지 않습니다
can.not.override.final={0} ''{1}'' 이(가) final 멤버를 재정의할 수 없습니다
member.cannot.override.var=메소드 {0} 이(가) 가변 변수를 재정의할 수 없습니다
member.cannot.override.val= 메소드 {0} 에 안정적인 변경 불가한 값이 필요합니다
var.cannot.override.val= 변수 {0} 이(가) 변경 불가한 값을 재정의할 수 없습니다
override.types.not.conforming=재정의 유형 {0} 이(가) 기본 유형 {1} 을(를) 준수하지 않습니다

### org/jetbrains/plugins/scala/annotator/ScalaAnnotator.scala
covariant.type.contravariant.position.of.method=공변성 유형 {0} 이(가) 메소드 {2} 의 유형 {1} 내 반공변성 위치에 나타납니다
covariant.type.contravariant.position.of.value=공변성 유형 {0} 이(가) 값 {2} 의 유형 {1} 내 반공변성 위치에 나타납니다
covariant.type.invariant.position.of.method=공변성 유형 {0} 이(가) 메소드 {2} 의 유형 {1} 내 무공변성 위치에 나타납니다
covariant.type.invariant.position.of.value=공변성 유형 {0} 이(가) 값 {2} 의 유형 {1} 내 무공변성 위치에 나타납니다
contravariant.type.covariant.position.of.method=반공변성 유형 {0} 이(가) 메소드 {2} 의 유형 {1} 내 공변성 위치에 나타납니다
contravariant.type.covariant.position.of.value=반공변성 유형 {0} 이(가) 값 {2} 의 유형 {1} 내 공변성 위치에 나타납니다
contravariant.type.invariant.position.of.method=반공변성 유형 {0} 이(가) 메소드 {2} 의 유형 {1} 내 무공변성 위치에 나타납니다
contravariant.type.invariant.position.of.value=반공변성 유형 {0} 이(가) 값 {2} 의 유형 {1} 내 무공변성 위치에 나타납니다

### org/jetbrains/plugins/scala/annotator/ScopeAnnotator.scala
id.is.already.defined={0} 이(가) 범위 안에 이미 정의되어 있습니다

### org/jetbrains/plugins/scala/annotator/TypeMismatchError.scala
# TODO unify type mismatch messages
type.mismatch.message=유형이 불일치합니다. 필요\: {0}, 발견\: {1}

### org/jetbrains/plugins/scala/annotator/TypeMismatchHints.scala
type.mismatch.tooltip=<html><body>유형이 불일치합니다.<table><tr><td>필요\:</td>{0}</tr><tr><td>발견\:</td>{1}</tr></table></body></html>

### org/jetbrains/plugins/scala/annotator/TypeMismatchToggleAction.scala
type.mismatch.hints.action.text=유형 불일치 힌트
type.mismatch.hints.action.description=유형 불일치 힌트 전환

### org/jetbrains/plugins/scala/annotator/createFromUsage/CreateApplyQuickFix.scala
family.name.create.apply.method='apply' 메소드 생성
create.apply.method.in={0} 내 ''apply'' 메소드 생성

### org/jetbrains/plugins/scala/annotator/createFromUsage/CreateEntityQuickFix.scala
error.message.title.create.entity.quickfix=엔티티 빠른 수정 생성

### org/jetbrains/plugins/scala/annotator/createFromUsage/CreateExtractorObjectQuickFix.scala
family.name.create.extractor.object=추출기 객체 생성
create.extractor.object.named=추출기 객체 ''{0}'' 생성

### org/jetbrains/plugins/scala/annotator/createFromUsage/CreateParameterlessMethodQuickFix.scala
family.name.create.parameterless.method=매개변수 없는 메소드 생성
create.parameterless.method.named=매개변수 없는 메소드 ''{0}'' 생성
family.name.create.variable=변수 생성
create.variable.named=변수 ''{0}'' 생성
family.name.create.value=값 생성
create.value.named=값 ''{0}'' 생성
family.name.create.method=메소드 생성
create.method.named=메소드 ''{0}''을(를) 생성합니다.

### org/jetbrains/plugins/scala/annotator/createFromUsage/CreateTypeDefinitionQuickFix.scala
family.name.create.object=객제 생성
family.name.create.trait=특성 생성
family.name.create.class=클래스 생성
family.name.create.case.class=케이스 클래스 생성
create.object.named=객제 ''{0}'' 생성
create.trait.named=특성 ''{0}'' 생성
create.class.named=클래스 ''{0}'' 생성
create.case.class.named=case 클래스 ''{0}'' 생성
choose.level.popup.title=수준 선택

### org/jetbrains/plugins/scala/annotator/createFromUsage/CreateUnapplyQuickFix.scala
family.name.create.unapply.method='unapply' 메소드 생성
create.unapply.method.in={0} 내 ''unapply'' 메소드 생성

### org/jetbrains/plugins/scala/annotator/element/ScAnnotationAnnotator.scala
scala.meta.recompile=메타프로그램이 최신 상태가 아닙니다. 여기를 클릭하여 컴파일하십시오
scala.meta.expandfailed=매크로 확장 실패\: {0}

### org/jetbrains/plugins/scala/annotator/element/ScAssignmentAnnotator.scala
annotator.error.wrong.right.assignment.side=잘못된 오른쪽 대입
annotator.error.reassignment.to.val=val에 다시 대입
illegal.assignment.target=Illegal assignment target

### org/jetbrains/plugins/scala/annotator/element/ScCatchBlockAnnotator.scala
# TODO unify type mismatch messages
expr.type.does.not.conform.expected.type=유형 {0} 표현식이 기대 유형 {1} 을(를) 준수하지 않습니다
method.is.not.member=메소드 {0} 이(가) 유형 {1} 의 멤버가 아닙니다
expected.type.boolean=메소드 {0} 반환 유형으로 부울 유형 기대

### org/jetbrains/plugins/scala/annotator/element/ScClassAnnotator.scala
illegal.secondary.constructors.value.class=보조 생성자는 값 클래스에서 허용되지 않습니다
value.class.can.have.only.one.parameter=값 클래스는 하나의 매개변수만 가질 수 있습니다
value.class.can.have.only.val.parameter=값 클래스는 단 하나의 비 private val 매개변수를 가질 수 있습니다
type.parameter.value.class.may.not.be.specialized=값 클래스의 유형 매개변수는 특수화될 수 없습니다
value.classes.cannot.have.nested.objects=값 클래스는 중첩 클래스, 객체 또는 특성을 가질 수 없습니다.
value.classes.cannot.redefine.equals.hashcode=값 클래스는 equals 및 hashCode를 재정의할 수 없습니다
value.classes.can.have.only.defs=값 클래스에서는 필드 정의가 허용되지 않습니다
value.classes.may.not.be.member.of.another.class=값 클래스는 다른 클래스의 멤버일 수 없습니다

### org/jetbrains/plugins/scala/annotator/element/ScConstrBlockAnnotator.scala
constructor.invocation.expected='this' 기대
called.constructor.definition.must.precede=호출된 생성자 정의가 생성자 정의 호출보다 선행해야 합니다

### org/jetbrains/plugins/scala/annotator/element/ScConstructorInvocationAnnotator.scala
# TODO unify type mismatch messages
type.mismatch.default.args.expected.actual=디폴트 인수 관련 유형 불일치, 기대\: {0}, 실제\: {1}
annotator.error.class.type.required.but.found=클래스 유형이 기대되나 ({0}) 이(가) 발견됨
annotator.error.constructor.has.malformed.definition=생성자 정의 형식이 잘못되었습니다
annotator.error.no.constructor.accessible=여기에서 접근 가능한 생성자가 없습니다
annotator.error.cannot.resolve.overloaded.constructor=오버로드된 생성자 `{0}`을(를) 해결할 수 없음
annotator.error.unspecified.value.parameters=지정되지 않은 값 매개변수\: {0}
annotator.error.trait.has.no.constructor=특성 {0} 은(는) 특성이므로 생성자 인수를 취하지 않습니다
annotator.error.too.many.arguments.for.constructor=생성자 {0} 의 인수가 너무 많음
annotator.error.missing.argument.list.for.constructor=생성자 {0} 의 인수 목록 누락
annotator.error.expansion.for.non.repeated.parameter=반복되지 않는 매개변수 확장
annotator.error.positional.after.named.argument=명명된 인수 뒤 위치 인수
annotator.error.parameter.specified.multiple.times=매개변수가 여러 번 지정됨
annotator.error.cannot.apply.constructor=생성자 {0} 을(를) 적용할 수 없음

### org/jetbrains/plugins/scala/annotator/element/ScEnumeratorsAnnotator.scala
semicolon.not.allowed.here=세미콜론이 허용되지 않음
remove.all.erroneous.semicolons.from.forexpression=for 표현식의 모든 잘못된 세미콜론 제거

### org/jetbrains/plugins/scala/annotator/element/ScForBindingAnnotator.scala
enumerators.binding.val.keyword.deprecated=열거자 내 'val' 키워드는 더 이상 사용되지 않습니다
enumerators.binding.case.keyword.found=패턴이 기대되나 'case'가 발견되었습니다
remove.case='case' 제거
family.name.remove.case.from.enumerator=열거자에서 'case' 제거

### org/jetbrains/plugins/scala/annotator/element/ScFunctionExprAnnotator.scala
annotator.error.too.many.parameters=매개변수가 너무 많음
annotator.error.missing.parameter.type=매개변수 유형 누락
type.mismatch.expected=유형 불일치, 기대\: {0}, 실제\: {1}

### org/jetbrains/plugins/scala/annotator/element/ScFunctionalTypeElementAnnotator.scala
repeated.param.non.method=메소드 시그니처에는 반복 매개변수가 허용되지 않습니다. 대신 `Seq`를 사용하십시오

### org/jetbrains/plugins/scala/annotator/element/ScGeneratorAnnotator.scala
for.pattern.bindings.require.scala3='for' 패턴 바인딩 내 'case' 구문을 사용하려면 Scala 3.0이 필요합니다
enumerators.generator.val.keyword.found=패턴이 기대되나 'val'이 발견되었습니다

### org/jetbrains/plugins/scala/annotator/element/ScImportExprAnnotator.scala
import.expr.should.be.qualified=import 표현식이 정규화되어야 합니다

### org/jetbrains/plugins/scala/annotator/element/ScInterpolatedStringLiteralAnnotator.scala
cannot.resolve.in.StringContext=값 ''{0}'' 이(가) StringContext의 멤버가 아닙니다

### org/jetbrains/plugins/scala/annotator/element/ScLiteralTypeElementAnnotator.scala
wrong.type.no.literal.types=잘못된 유형 `{0}`, 리너털 유형 지원을 위해 Scala 2.13 또는 `-Yliteral-types` 컴파일러 플래그가 있는 Typelevel Scala를 사용하십시오

### org/jetbrains/plugins/scala/annotator/element/ScMacroDefAnnotator.scala
macro.defs.must.have.explicit.return.type=매크로 정의는 명시적으로 지정된 반환 유형을 포함해야 합니다

### org/jetbrains/plugins/scala/annotator/element/ScMethodInvocationAnnotator.scala
annotator.error.unspecified.value.parameters.mkstring=지정되지 않은 값 매개변수\: {0}
annotator.error.cannot.resolve.overloaded.method=오버로드된 메소드를 해결할 수 없음
annotator.error.too.many.arguments=인수가 너무 많음
annotator.error.target.does.not.take.parameters={0} 은(는) 매개변수를 취하지 않습니다
missing.argument.list.for.method.with.explicit.list=메소드 {1}의 인수 목록 {0} 누락
missing.argument.list.for.method=메소드 {0}의 인수 목록 누락

### org/jetbrains/plugins/scala/annotator/element/ScNewTemplateDefinitionAnnotator.scala
illegal.instantiation={0} ''{1}'' 은(는) abstract이므로 인스턴스화할 수 없습니다

### org/jetbrains/plugins/scala/annotator/element/ScNumericLiteralAnnotator.scala
octal.literals.removed=8진 리터널 구문은 Scala 2.11 이후 비활성화되었습니다
octal.literals.deprecated=8진 리터널 구문은 Scala 2.10에서 더 이상 사용되지 않습니다
trailing.underscore.separator=후미 밑줄 구분자가 허용되지 않습니다
illegal.underscore.separator=밑줄 구분자를 사용할려면 Scala 2.13이 필요합니다
long.literal.is.out.of.range=Integer 숫자가 Long 유형의 범위조차 벗어납니다
integer.literal.is.out.of.range=Integer 리터럴이 int 유형의 범위를 벗어납니다
lowercase.long.marker=소문자로 쓰인 long 리터럴 마커

### org/jetbrains/plugins/scala/annotator/element/ScParameterAnnotator.scala
annotator.error.parameter.without.an.owner.name=소유자가 없는 매개변수\: {0}
annotator.error.missing.type.annotation.for.parameter=매개변수의 유형 어노테이션 누락\: {0}
missing.parameter.type.name=매개변수 유형 누락\: {0}
topic.parameters.may.not.be.call.by.name={0} 매개변수는 이름에 의한 호출(call-by-name)이 아닐 수 있습니다

### org/jetbrains/plugins/scala/annotator/element/ScParametersAnnotator.scala
annotator.error.repeated.parameter.must.be.last=*-매개변수가 마지막에 와야 합니다
annotator.error.repeated.or.default=*-매개변수가 있는 매개변수 섹션이 디폴트 인수를 포함할 수 없습니다

### org/jetbrains/plugins/scala/annotator/element/ScPatternAnnotator.scala
pattern.on.refinement.unchecked=개선 유형의 패턴 일치가 검사되지 않았습니다
type.cannot.be.used.in.type.pattern=유형 {0} 이(가) 유형 패턴 또는 isInstanceOf 테스트에서 사용될 수 없습니다
scrutinee.incompatible.pattern.type=Scrutinee이 패턴 유형과 호환되지 않습니다, 발견\: {0}, 필요\: {1}
pattern.type.incompatible.with.expected=패턴 유형이 기대 유형과 호환되지 않습니다, 발견\: {0}, 필요\: {1}
constructor.cannot.be.instantiated.to.expected.type=생성자를 기대 유형으로 초기화할 수 없습니다, 발견\: {0}, 필요\: {1}
fruitless.type.test=결과가 없는 유형 테스트\: 유형 {0} 값이 동시에 {1} 이(가) 될 수 없습니다
erasure.warning= (여전히 해당 이레이저와 일치할 수 있음)
wrong.number.arguments.extractor=추출기의 잘못된 인수 개수, 발견\: {0}, 기대\: {1}
wrong.number.arguments.extractor.unapplySeq=추출기의 잘못된 인수 개수, 발견\: {0}, 기대\: {1} 이상
stable.identifier.required=안정적 식별자가 기대되나 {0} 이(가) 발견됨
better.monadic.for.invalid.pattern=인수에 명시적 유형 어노테이션이 지정되어야 합니다

### org/jetbrains/plugins/scala/annotator/element/ScPatternArgumentListAnnotator.scala
vararg.pattern.must.be.last.pattern=_*는 마지막 인수로만 사용될 수 있습니다

### org/jetbrains/plugins/scala/annotator/element/ScPatternTypeUnawareAnnotator.scala
vararg.pattern.with.colon.requires.scala3=vararg 패턴 내 '\:' 구문을 사용하려면 Scala 3.0이 필요합니다
vararg.pattern.with.at.deprecated.since.scala3=vararg 패턴 내 '@' 구문은 Scala 3.0 이후 버전에서 더 이상 사용되지 않습니다
vararg.short.pattern.with.at.deprecated.since.scala3=짧은 _* 패턴 구문은 Scala 3.0 이후 버전에서 더 이상 사용되지 않습니다
family.name.replace.type.with.type.in.vararg.pattern=vararg 패턴 내 ''{0}'' 을(를) ''{1}'' (으)로 교체
replace.with.type=''{0}''(으)로 교체
replace.with.scala3.wildcard.varargs=다음으로 교체 '_\: _*'
family.name.replace.old.varags.with.scala3.varargs.pattern=vararg 패턴 내  '_*'를  '_\: _*'로 교체

### org/jetbrains/plugins/scala/annotator/element/ScReferenceAnnotator.scala
cannot.resolve=심볼 {0}을(를) 해결할 수 없습니다.
cannot.resolve.overloaded=오버로드된 메소드 ''{0}'' 을(를) 해결할 수 없음
forward.reference.detected=잘못된 전방 참조
cannot.resolve.apply.method=메소드 {0}.apply를 해결할 수 없음
cannot.resolve.unapply.method=메소드 {0}.unapply를 해결할 수 없음
annotator.error.unspecified.type.parameters=지정되지 않은 값 매개변수\: {0}
annotator.error.does.not.take.type.parameters={0} 은(는) 유형 매개변수를 취하지 않습니다
annotator.error.too.many.type.arguments={0} 의 유형 인수가 너무 많음
annotator.error.too.many.arguments.method=메소드 {0} 의 인수가 너무 많음
annotator.error.sunspecified.value.parameters=지정되지 않은 값 매개변수\: {0}
annotator.error.name.has.malformed.definition=''{0}''에 형식이 잘못된 정의가 있습니다
annotator.error.missing.arguments.for.method=메소드 {0} 의 인수 누락

### org/jetbrains/plugins/scala/annotator/element/ScReturnAnnotator.scala
return.outside.method.definition=메소드 정의 외부의 return 문

### org/jetbrains/plugins/scala/annotator/element/ScSelfInvocationAnnotator.scala
annotator.error.cannot.find.constructor.for.this.call=이 호출에 대한 생성자를 찾을 수 없음

### org/jetbrains/plugins/scala/annotator/element/ScSimpleTypeElementAnnotator.scala
type.takes.type.parameters=유형 {0} 은(는) 유형 매개변수를 취합니다

### org/jetbrains/plugins/scala/annotator/element/ScStringLiteralAnnotator.scala
string.literal.is.too.long=문자열 리터럴 크기가 컴파일러 제한을 초과합니다

### org/jetbrains/plugins/scala/annotator/element/ScSymbolLiteralAnnotator.scala
symbolliterals.are.deprecated=심볼 리터널은 Scala 2.13에서 더 이상 사용되지 않습니다. 대신 Symbol("{0}")을 사용하십시오.

### org/jetbrains/plugins/scala/annotator/element/ScTemplateDefinitionAnnotator.scala
illegal.inheritance.from.final.kind=final {0} ''{1}'' (으)로부터의 올바르지 않은 상속
illegal.inheritance.from.value.class=값 클래스 ''{0}'' (으)로부터의 올바르지 않은 상속
illegal.inheritance.multiple={0} ''{1}'' 이(가) 여러 번 상속됨
illegal.inheritance.self.type=올바르지 않은 상속, 자체 유형 {0} 이(가) {1} 을(를) 준수하지 않습니다
illegal.mixin={0} ''{1}'' 은(는) 혼합 가능한 특성이여야 합니다
member.implementation.required={0} ''{1}'' 이(가) abstract로 선언되거나 ''{3}'' 내 abstract 멤버 ''{2}'' 을(를) 구현해야 합니다
mixin.required=''{3}'' 내 멤버 ''{2}'' 이(가) ''abstract'' 및  ''override'' 로 표시되나 기본 클래스에서 구체 구현을 찾을 수 없으므로, {0} ''{1}'' 은(는) mixin이여야 합니다
illegal.undefined.member=선언되었으나 정의되지 않은 멤버는 오직 클래스만 가질 수 있습니다

### org/jetbrains/plugins/scala/annotator/element/ScTraitAnnotator.scala
trait.parameter.require.scala3=특성 매개변수를 사용하려면 Scala 3.0이 필요합니다

### org/jetbrains/plugins/scala/annotator/element/ScTypeBoundsOwnerAnnotator.scala
lower.bound.conform.to.upper=하한이 상한을 준수하지 않습니다

### org/jetbrains/plugins/scala/annotator/element/ScTypedExpressionAnnotator.scala
cannot.upcast.type.to.other.type={0}을(를) {1}(으)로 업캐스트할 수 없습니다

### org/jetbrains/plugins/scala/annotator/element/ScUnderscoreSectionAnnotator.scala
unbound.placeholder.parameter=바인딩되지 않은 자리표시자 매개변수
local.variables.must.be.initialized=지역 변수가 초기화되어야 합니다
default.init.prohibited.literal.types=리터럴 유형 var에서 금지된 디폴트 초기화

### org/jetbrains/plugins/scala/annotator/element/ScValueOrVariableAnnotator.scala
annotation.ascriptions.in.pattern.definitions.require.scala3=패턴 정의 내 어노테이션 귀속을 사용하려면 Scala 3.0이 필요합니다

### org/jetbrains/plugins/scala/annotator/gutter/RecursiveCallLineMarkerProvider.scala
method.is.recursive=Method ''{0}'' 이(가) 재귀 메소드입니다
method.is.tail.recursive=Method ''{0}'' 이(가) 꼬리 재귀 메소드입니다

### org/jetbrains/plugins/scala/annotator/gutter/ScalaGoToSuperActionHandler.scala
goto.super.member.chooser.title=상위 멤버 선택
goto.super.class.chooser.title=상위 클래스 선택
goto.super.class.or.member.chooser.title=상위 클래스/상위 멤버 선택

### org/jetbrains/plugins/scala/annotator/gutter/ScalaLineMarkerProvider.scala
companion.class=클래스
companion.object=객체
companion.trait=특성
go.to.companion=컴패니언 {0}(으)로 이동
go.to.implementation=구현으로 이동
go.to.super.method=Go to super member
gutter.companion=컴패니언
gutter.implemented=Implemented member
gutter.implementing=Implementing member
gutter.overridden=Overridden member
gutter.overriding=Overriding member
gutter.recursion=재귀 유형
gutter.sam=SAM 구현
has.companion=컴패니언 {0} 포함
multiple.overriding.tooltip=여러 개의 재정의 멤버
multiple.overriden.tooltip=여러 개의 재정의된 멤버
scala.line.markers=Scala 줄 마커

### org/jetbrains/plugins/scala/annotator/gutter/ScalaMarkerType.scala
implements.member.prefix=Implements member
implements.member.from.prefix=Implements member from
implements.member.from.several.classes=Implements members from {0} classes
overrides.member.from.prefix=Overrides member from
overrides.member.from.several.classes=Overrides members from {0} classes
overrides.type.prefix=유형 재정의
overrides.type.from.super.several.classes={0} 클래스의 유형 재정의
navigation.title.super.members={0} 의 상위 멤버 선택
navigation.findUsages.title.super.members={0} 의 상위 멤버
navigation.title.super.types={0} 의 상위 유형 멤버 선택
navigation.findUsages.title.super.types={0} 의 상위 유형 멤버
trait.has.implementations=Is mixed into
trait.has.several.implementations={0} 클래스로 혼합됨
class.has.subclasses=확장 기준
class.has.several.subclasses={0} 하위 클래스별로 확장
has.implementations=멤버가 구현을 포함합니다
is.overridden.by=멤버가 재정의를 포함합니다
navigation.title.inheritors.trait=<html><b>{0}</b> 구현 선택({1} 클래스 발견)</html>
navigation.findUsages.title.inheritors.trait={0}의 구현
navigation.title.inheritors.class=<html><b>{0}</b> 하위 클래스 선택({1} 클래스 발견)</html>
navigation.findUsages.title.inheritors.class={0} 의 하위 클래스
navigation.title.implementing.member=<html><b>{0}</b> 의 구현 멤버 선택({1} 멤버 발견)</html>
navigation.findUsages.title.implementing.member={0} 의 구현 멤버
navigation.title.overriding.member=<html><b>{0}</b> 의 재정의 멤버 선택({1} 멤버 발견)</html>
navigation.findUsages.title.overriding.member={0} 의 재정의 멤버

### org/jetbrains/plugins/scala/annotator/hints/HintUI.scala
type.mismatch.dot=유형 불일치.

### org/jetbrains/plugins/scala/annotator/modifiers/ModifierChecker.scala
lazy.modifier.is.not.allowed.here='lazy' 제어자는 값 정의에만 허용됨
lazy.modifier.is.not.allowed.with.param='lazy' 제어자는 허용되지 않으므로, 대신 call-by-name 매개변수를 사용하십시오
lazy.values.may.not.be.abstract=lazy 값이 abstract일 수 없습니다
final.modifier.not.with.declarations='final' 제어자는 불완전한 멤버와 사용될 수 없습니다
final.modifier.not.with.trait='final' 제어자는 특성에 허용되지 않음
final.modifier.is.redundant.with.final.parents='final' 제어자는 객체 또는 final 클래스 멤버와 중복됩니다
final.modifier.is.not.allowed.here='final' 제어자는 허용되지 않습니다
access.modifier.is.not.allowed.here=''{0}'' 제어자는 허용되지 않습니다
abstract.modifier.redundant.fot.traits='abstract' 제어자는 특성과 중복됩니다
abstract.modifier.is.not.allowed='abstract' 제어자는 클래스 또는 'override' 제어자가 있는 정의에만 허용됩니다
abstract.override.modifier.is.not.allowed='abstract override' 제어자는 특성 멤버에만 허용됨
override.modifier.is.not.allowed.for.classes='override' 제어자는 유형 정의 멤버에만 허용됨
override.modifier.is.not.allowed='override' 제어자는 허용되지 않습니다
sealed.modifier.is.not.allowed.here='sealed' 제어자는 허용되지 않습니다
illegal.modifiers.combination=올바르지 않은 제어자 조합\: {0} 및 {1}
implicit.modifier.cannot.be.used.for.top.level.objects='implicit' 제어자는 최상위 객체에 사용할 수 없습니다
implicit.class.must.have.a.primary.constructor.with.one.argument=묵시적 클래스에는 첫 번째 매개변수 목록에 정확히 하나의 인수가 있는 기본 생성자가 있어야 합니다
implicit.modifier.can.be.used.only.for='implicit' 제어자는 값, 변수, 메소드, 클래스에만 사용할 수 있습니다

### org/jetbrains/plugins/scala/annotator/quickfix/AddBreakoutQuickFix.scala
add.collection.breakout.argument=`collection.breakOut` 인수 추가
family.name.add.collection.breakout=`collection.breakOut` 추가

### org/jetbrains/plugins/scala/annotator/quickfix/AddElementToMethodCallFix.scala
add.element={0} 추가

### org/jetbrains/plugins/scala/annotator/quickfix/AddReturnTypeFix.scala
add.return.type=반환 유형 추가

### org/jetbrains/plugins/scala/annotator/quickfix/ChangeTypeFix.scala
family.name.change.type=유형 변경
change.type.to=유형 ''{0}'' 을(를) ''{1}'' (으)로 변경

### org/jetbrains/plugins/scala/annotator/quickfix/ConvertToExplicitSymbolQuickFix.scala
convert.to.explicit.symbol=심볼("{0}")로 변환
convert.to.explicit.symbol.family=명시적 심볼로 변환

### org/jetbrains/plugins/scala/annotator/quickfix/EnableTypeMismatchHints.scala
family.name.enable.type.mismatch.hints=유형 불일치 힌트 활성화

### org/jetbrains/plugins/scala/annotator/quickfix/ImplementMethodsQuickFix.scala
implement.methods.fix=메소드 구현

### org/jetbrains/plugins/scala/annotator/quickfix/ModifierQuickFix.scala
make.non.private.title=프로퍼티를 비 private으로 만들기
add.modifier.fix.without.name=''{0}'' 제어자를 추가합니다
remove.named.modifier.fix=''{0}'' 제어자를 제거합니다
make.protected.fix=프로퍼티를 protected로 만들기
make.public.fix=프로퍼티를 public으로 만들기

### org/jetbrains/plugins/scala/annotator/quickfix/NumberLiteralQuickFix.scala
numeric.literal.family=숫자 리터럴
convert.to.hex.fix=8진 리터럴을 16진수로 변환
convert.to.long.fix=long 리터럴로 변환
lowercase.long.marker.fix=long 리터널 마커를 대문자로 변환

### org/jetbrains/plugins/scala/annotator/quickfix/PullUpQuickFix.scala
pull.method.to=다음으로 메소드 ''{0}'' 끌어오기...
pull.value.to=다음으로 값 ''{0}'' 끌어오기...
pull.variable.to=다음으로 변수 ''{0}'' 끌어오기...

### org/jetbrains/plugins/scala/annotator/quickfix/ReportHighlightingErrorQuickFix.scala
report.highlighting.error.fix=강조 표시 오류 보고...

### org/jetbrains/plugins/scala/annotator/quickfix/WrapInOptionQuickFix.scala
wrap.in.option.name=옵션 줄 바꿈
wrap.in.option.hint=Option(...) 내 표현식을 줄 바꿈하시겠습니까?

### org/jetbrains/plugins/scala/annotator/template/CaseClassWithoutParamList.scala
family.name.add.empty.parentheses=빈 소괄호 추가
family.name.convert.to.object=객체로 변환
case.classes.without.parameter.list.not.allowed=매개변수 목록이 없는 케이스 클래스가 허용되지 않습니다
case.classes.without.parameter.list.deprecated=매개변수 목록이 없는 케이스 클래스는 더 이상 사용되지 않습니다

### org/jetbrains/plugins/scala/annotator/template/PrivateBeanProperty.scala
annotator.error.bean.property.should.not.be.private=Bean 프로퍼티가 private일 수 없습니다

### org/jetbrains/plugins/scala/annotator/template/TraitHasImplicitBound.scala
traits.cannot.have.type.parameters.with.context.bounds=특성은 컨텍스트 바운드가 있는 유형 매개변수를 가질 수 없습니다
traits.cannot.have.type.parameters.with.view.bounds=특성은 뷰 바운드가 있는 유형 매개변수를 가질 수 없습니다

### org/jetbrains/plugins/scala/autoImport/quickFix/ImportImplicitConversionFix.scala
import.with=가져오기 ''{0}''
import.implicit.conversion=변환 가져오기...

### org/jetbrains/plugins/scala/autoImport/quickFix/ImportImplicitInstanceFix.scala
import.implicit=묵시적 항목 가져오기...

### org/jetbrains/plugins/scala/autoImport/quickFix/ScalaAddImportAction.scala
import.class.chooser.title=가져올 클래스
import.package.chooser.title=가져올 패키지
import.something.chooser.title=가져올 이륾
import.conversion.chooser.title=가져올 변환
import.implicit.chooser.title=가져올 묵시적 항목
add.import.action=import 액션 추가
exclude.value.from.auto.import=자동 가져오기에서 ''{0}''을(를) 제외합니다.

### org/jetbrains/plugins/scala/autoImport/quickFix/ScalaImportElementFix.scala
import.hint.text={0}? Alt+Enter {1}
import.multiple.choices=(다중 선택...)

### org/jetbrains/plugins/scala/autoImport/quickFix/ScalaImportGlobalMemberFix.scala
import.global.member=전역 멤버 가져오기
import.as=''{0}''로서 가져오기
import.with.prefix.ellipsis=접두어 포함 가져오기...
import.with.prefix=접두어 포함 가져오기
import.something=가져오기...

### org/jetbrains/plugins/scala/autoImport/quickFix/ScalaImportTypeFix.scala
import.class=클래스 가져오기
import.package=패키지 가져오기

### org/jetbrains/plugins/scala/build/BuildToolWindowReporter.scala
report.build.toolwindow.cancel=빌드 취소
report.build.toolwindow.running=실행 중...
report.build.toolwindow.failed=실패
report.build.toolwindow.canceled=Cancelado
report.build.toolwindow.items=항목

### org/jetbrains/plugins/scala/build/ExternalSystemNotificationReporter.scala
report.build.task.canceled=task canceled

### org/jetbrains/plugins/scala/build/IndicatorReporter.scala
report.build.running=빌드 실행 중...
report.build.completed=빌드 완료
report.build.failed=빌드 실패
report.failed.with.message=실패\: {0}
report.canceled=Cancelado
report.warning.with.message=경고\: {0}
report.error.with.message=Error\: {0}
report.building=빌드 중...

### org/jetbrains/plugins/scala/codeInsight/intention/AddBracesIntention.scala
family.name.add.braces=중괄호 추가
add.braces.around.single.line.expression=단일 줄 표현식 주위에 중괄호 추가

### org/jetbrains/plugins/scala/codeInsight/intention/CreateCompanionObjectIntention.scala
create.companion.object.for.class=클래스에 대한 컴패니언 객체 생성
family.name.create.companion.object=컴패니언 객체 생성

### org/jetbrains/plugins/scala/codeInsight/intention/RemoveBracesIntention.scala
family.name.remove.braces=중괄호를 제거합니다.

### org/jetbrains/plugins/scala/codeInsight/intention/collections/ComparingLengthIntention.scala
family.name.comparing.length=길이 비교 중

### org/jetbrains/plugins/scala/codeInsight/intention/collections/FilterSetContainsIntention.scala
family.name.filter.set.contains=Set Contains 필터링

### org/jetbrains/plugins/scala/codeInsight/intention/collections/SomeToOptionIntention.scala
family.name.some.to.option=Some을 Option으로

### org/jetbrains/plugins/scala/codeInsight/intention/comprehension/ConvertToCurlyBracesIntention.scala
family.name.convert.to.curly.braces=중괄호로 변환

### org/jetbrains/plugins/scala/codeInsight/intention/comprehension/ConvertToParenthesesIntention.scala
intention.for.comprehension.convert.to.parentheses=소괄호로 변환

### org/jetbrains/plugins/scala/codeInsight/intention/comprehension/DesugarForIntention.scala
desugar.for.comprehension=for 내포 디슈가링
family.name.convert.to.desugared.expression=디슈가링된 표현식으로 변환

### org/jetbrains/plugins/scala/codeInsight/intention/expression/ConvertFromInfixExpressionIntention.scala
family.name.convert.from.infix.expression=infix 표현식 변환

### org/jetbrains/plugins/scala/codeInsight/intention/expression/ConvertParameterToUnderscoreIntention.scala
family.name.convert.parameter.to.underscore.section=매개변수를 밑줄 섹션으로 변환

### org/jetbrains/plugins/scala/codeInsight/intention/expression/ConvertToInfixExpressionIntention.scala
family.name.convert.to.infix.expression=infix 표현식으로 변환

### org/jetbrains/plugins/scala/codeInsight/intention/expression/ConvertUnderscoreToParameterIntention.scala
family.name.convert.underscore.section.to.parameter=밑줄 섹션을 매개변수로 변환

### org/jetbrains/plugins/scala/codeInsight/intention/expression/MakeImplicitConversionExplicit.scala
family.name.make.implicit.conversion.explicit=묵시적 변환을 명시적으로 만들기

### org/jetbrains/plugins/scala/codeInsight/intention/expression/RemoveApplyIntention.scala
family.name.remove.unnecessary.apply=불필요한 적용 제거

### org/jetbrains/plugins/scala/codeInsight/intention/expression/RemoveUnnecessaryParenthesesIntention.scala
remove.unnecessary.parentheses=불필요한 소괄호를 제거합니다.

### org/jetbrains/plugins/scala/codeInsight/intention/expression/ReplaceTypeCheckWithMatchIntention.scala
family.name.replace.type.check.with.pattern.matching=유형 검사를 패턴 매칭으로 교체

### org/jetbrains/plugins/scala/codeInsight/intention/imports/ImportAdditionalIdentifiersIntention.scala
family.name.import.additional.identifiers=추가 식별자 가져오기
import.additional.identifiers.from.qualifier=한정자에서 추가 식별자 가져오기

### org/jetbrains/plugins/scala/codeInsight/intention/imports/ImportAllMembersIntention.scala
family.name.import.all.members=모든 멤버 가져오기
import.all.members.of.reference={0} 의 모든 멤버 가졍오기

### org/jetbrains/plugins/scala/codeInsight/intention/imports/ImportStableMemberIntention.scala
family.name.import.member.with.stable.path=안정적 경로로 멤버 가져오기
import.stable.member={0} 가져오기

### org/jetbrains/plugins/scala/codeInsight/intention/matcher/ConvertToTypedPatternIntention.scala
convert.to.typed.pattern=유형이 지정된 패턴으로 변환

### org/jetbrains/plugins/scala/codeInsight/intention/matcher/ExpandPatternIntention.scala
family.name.expand.to.constructor.pattern=생성자 패턴으로 확장
expand.to.new.pattern=다음으로 확장자\: {0}

### org/jetbrains/plugins/scala/codeInsight/intention/types/AddUnitTypeAnnotationIntention.scala
intention.add.explicit.unit.type.annotation=묵시적 Unit 유형 어노테이션 추가
intention.type.annotation.function.add.text=함수 정의에 유형 어노테이션 추가

### org/jetbrains/plugins/scala/codeInsight/intention/types/AdjustTypesIntention.scala
family.name.adjust.types=유형 조정

### org/jetbrains/plugins/scala/codeInsight/intention/types/ConvertFromInfixIntention.scala
family.name.use.prefix.type.syntax=접두사 유형 구문 사용

### org/jetbrains/plugins/scala/codeInsight/intention/types/ConvertImplicitBoundsToImplicitParameter.scala
family.name.convert.implicit.bounds=묵시적 바운드 변환
convert.view.and.context.bounds.to.implicit.parameters=뷰 및 컨텍스트 바운드를 묵시적 매개변수로 변환

### org/jetbrains/plugins/scala/codeInsight/intention/types/ConvertJavaToScalaCollectionIntention.scala
convert.java.to.scala.collection.hint=asScala를 사용하여 Scala 컬렉션으로 변환하시겠습니까?
convert.java.to.scala.collection.name=Scala 컬렉션으로 변환

### org/jetbrains/plugins/scala/codeInsight/intention/types/ConvertScalaToJavaCollectionIntention.scala
convert.scala.to.java.collection.hint=asJava를 사용하여 Java 컬렉션으로 변환하시겠습니까?
convert.scala.to.java.collection.name=Java 컬렉션으로 변환

### org/jetbrains/plugins/scala/codeInsight/intention/types/ConvertToInfixIntention.scala
family.name.use.infix.type.syntax=Infix 유형 구문 사용

### org/jetbrains/plugins/scala/codeInsight/intention/types/MakeTypeMoreSpecificIntention.scala
make.type.more.specific.fun=반환 유형을 더 구체적으로 만들기
make.type.more.specific=선언된 유형을 더 구체적으로 만들기

### org/jetbrains/plugins/scala/codeInsight/intention/types/RegenerateTypeAnnotation.scala
intention.type.annotation.regen.family=유형 어노테이션 다시 생성
intention.type.annotation.function.regenerate.text=함수 정의에 대한 유형 어노테이션 다시 생성
intention.type.annotation.value.regenerate.text=값 정의에 대한 유형 어노테이션 다시 생성
intention.type.annotation.variable.regenerate.text=변수 정의에 대한 유형 어노테이션 다시 생성

### org/jetbrains/plugins/scala/codeInsight/intention/types/ToggleTypeAnnotation.scala
intention.type.annotation.toggle.family=유형 어노테이션 전환
intention.type.annotation.function.remove.text=함수 정의에서 유형 어노테이션 제거
intention.type.annotation.value.add.text=값 정의에 유형 어노테이션 추가
intention.type.annotation.value.remove.text=값 정의에서 유형 어노테이션 제거
intention.type.annotation.variable.add.text=변수 정의에 유형 어노테이션 추가
intention.type.annotation.variable.remove.text=변수 정의에서 유형 어노테이션 제거
intention.type.annotation.pattern.add.text=패턴 정의에 유형 어노테이션 추가
intention.type.annotation.pattern.remove.text=패턴 정의에서 유형 어노테이션 제거
intention.type.annotation.parameter.add.text=매개변수에 유형 어노테이션 추가
intention.type.annotation.parameter.remove.text=매개변수에서 유형 어노테이션 제거
intention.type.annotation.underscore.add.text=밑줄 매개변수에 유형 어노테이션 추가
intention.type.annotation.underscore.remove.text=밑줄 매개변수에서 유형 어노테이션 제거

### org/jetbrains/plugins/scala/codeInsight/unwrap/ScalaCaseClauseRemover.scala
remove.case.clause=case 절 제거

### org/jetbrains/plugins/scala/codeInsight/unwrap/ScalaCatchOrFinallyRemover.scala
remove.finally=finally 블록 제거
remove.catch=catch 블록 제거

### org/jetbrains/plugins/scala/codeInsight/unwrap/ScalaInterpolatedStringUnwrapper.scala
unwrap.interpolated.string.injection=보간된 문자열 삽입 줄 바꿈 해제

### org/jetbrains/plugins/scala/codeInsight/unwrap/ScalaMatchUnwrapper.scala
unwrap.case.clause=case 절 줄 바꿈 해제

### org/jetbrains/plugins/scala/codeInsight/unwrap/ScalaTryOrFinallyUnwrapper.scala
unwrap.finally=finally 줄 바꿈 해제

### org/jetbrains/plugins/scala/codeInsight/unwrap/ScalaTryWithFinallyUnwrapper.scala
unwrap.try.with.finally=try/finally 줄 바꿈 해제

### org/jetbrains/plugins/scala/codeInspection/caseClassParamInspection/CaseClassParamInspection.scala
val.on.case.class.param.redundant=케이스 클래스 기본 생성자의 매개변수와 'val' 제어자가 중복됩니다

### org/jetbrains/plugins/scala/codeInspection/caseClassParamInspection/RemoveValQuickFix.scala
remove.val='val' 제거

### org/jetbrains/plugins/scala/codeInspection/catchAll/ReplaceDangerousCatchAllQuickFix.scala
specify.type.of.exception=예외 유형 지정

### org/jetbrains/plugins/scala/codeInspection/forwardReferenceInspection/ForwardReferenceInspection.scala
suspicicious.forward.reference.template.body=클래스 내 의심스러운 전방 참조

### org/jetbrains/plugins/scala/codeInspection/imports/RemoveBracesForSingleImportQuickFix.scala
remove.braces.from.import=import 문의 중괄호 제거

### org/jetbrains/plugins/scala/codeInspection/relativeImports/RelativeImportInspection.scala
make.import.fully.qualified=import 문 정규화하기

### org/jetbrains/plugins/scala/codeInspection/scaladoc/ScalaDocInlinedTagInspection.scala
delete.inlined.tag=인라인화된 태그 삭제
replace.with.wiki.syntax=인라인화된 태그를 고정폭 wiki 구문으로 교체

### org/jetbrains/plugins/scala/codeInspection/scaladoc/ScalaDocUnbalancedHeaderInspection.scala
move.text.after.header.to.new.line=헤더 닫기 뒤 텍스트를 새 줄로 이동
balance.header=밸런스 헤더

### org/jetbrains/plugins/scala/codeInspection/scaladoc/ScalaDocUnclosedTagWithoutParserInspection.scala
replace.tag.with.esc.seq=태그를 이스케이프 시퀀스로 교체

### org/jetbrains/plugins/scala/codeInspection/scaladoc/ScalaDocUnknownParameterInspection.scala
delete.duplicating.param=중복 매개변수 삭제
delete.tag=태그 삭제

### org/jetbrains/plugins/scala/codeInspection/scaladoc/ScalaDocUnknownTagInspection.scala
delete.unknown.tag=알 수 없는 태그 삭제

### org/jetbrains/plugins/scala/codeInspection/syntacticSimplification/FunctionTupleSyntacticSugarInspection.scala
replace.tuple.type=TupleN[A1, A1,...,  AN]를 (A1, A1,...,  AN)로 교체
replace.fun.type=FunctionN[A1, A1,...,  AN, R]을 (A1, A1,...,  AN) \=> R로 교체

### org/jetbrains/plugins/scala/codeInspection/syntacticSimplification/RedundantNewCaseClassInspection.scala
new.on.case.class.instantiation.redundant='new' 제어자 제거

### org/jetbrains/plugins/scala/codeInspection/syntacticSimplification/RemoveRedundantReturnInspection.scala
remove.return.keyword=반환 키워드 제거

### org/jetbrains/plugins/scala/codeInspection/xml/ScalaXmlUnmatchedTagInspection.scala
xml.no.opening.tag=여는 태그 없음
xml.no.closing.tag=닫는 태그 없음
xml.delete.unmatched.tag=일치하지 않는 태그 삭제
xml.rename.opening.tag=여는 태그 이름 변경
xml.rename.closing.tag=닫는 태그 이름 변경

### org/jetbrains/plugins/scala/compiler/CompileServerLauncher.scala
cannot.start.scala.compile.server=Scala 컴파일 서버를 시작할 수 없음

### org/jetbrains/plugins/scala/compiler/CompileServerManager.scala
scala.compile.server.title=Scala 컴파일 서버
action.run=실행(&R)
start.compile.server=컴파일 서버 시작
action.stop=De&tener
shutdown.compile.server=컴파일 서버 종료
action.configure=구성(&C)...
configure.compile.server=컴파일 서버 구성

### org/jetbrains/plugins/scala/compiler/EnsureModulesHaveDifferentProdAndTestOutputsTask.scala
shared.compile.output.paths.in.scala.modules=Scala 모듈 내 공유 컴파일 출력 경로
production.and.test.output.paths.are.shared.in=프로덕션 및 테스트 출력 경로가 다음에 공유됩니다\: {0}
split.output.paths.automatically=출력 경로 자동 분할
cancel.compilation=컴파일 취소

### org/jetbrains/plugins/scala/compiler/ScalaCompileServerForm.form
#ScalaCompileServer UI
jvm.options=JVM 옵션(&O)\:
jvm.maximum.heap.size.mb=JVM 최대 힙 크기, MB(&H)\:
jdk=JDK(&J)\:
advanced.settings=고급 설정
minutes=분
compile.server.new.project.restart=새 프로젝트를 컴파일할 때마다 컴파일 서버가 다시 시작됩니다.
compile.server.use.project.home=프로젝트 홈을 컴팦일 서버 작업 디렉토리로 사용(&W)
compile.server.jvm.command.line.parameters=컴파일 서버 JVM 명령 줄 매개변수
compile.server.shutdown.if.idle.for=서버가 유휴 상태인 경우 종료
compile.server.description=컴파일 서버가 애플리케이션 전체에서 실행됩니다(모든 프로젝트에 단일 인스턴스가 있습니다).\n\
JDK는 컴파일 서버를 인스턴스화하고 \n\
프로세스 내부 Java 컴파일러를 호출하는 데(JDK와 모듈 SDK가 일치하는 경우) 사용됩니다.
compile.server.use.for.scala=Scala 컴파일 서버 사용(&S)

### org/jetbrains/plugins/scala/components/PluginVersionVerifier.scala
incompatible.plugin.detected=호환되지 않는 플러그인 탐지됨

### org/jetbrains/plugins/scala/components/Scala3Disclaimer.scala
scala.3.disclaimer=Scala 3 면책조항
scala.3.support.is.experimental=Scala 3 지원은 개발 중입니다.<br>야간 빌드를 사용해 보세요. <a href\=''{0}''>자세히 알아보기</a>
configure.updates=업데이트 구성...
scala.3.support.is.incompatible=Dotty 버전\: {0}, 지원되는 버전\: {1}
adjust.dotty.version=Dotty {0} 사용

### org/jetbrains/plugins/scala/components/TypeAwareWidgetProvider.scala
type.aware.highlighting.title=Scala 유형 인식 강조 표시
click.or.press.shortcut.to.change=(변경하려면 {0} 을(를) 클릭하거나 누르십시오)
click.to.change=(클릭하여 변경)
enabled.word=Habilitado
disabled.word=비활성화됨

### org/jetbrains/plugins/scala/components/libextensions/ExtensionDownloader.scala
downloading.url={0} 다운로드 중

### org/jetbrains/plugins/scala/components/libextensions/LibraryExtensionsManager.scala
title.searching.for.library.extensions=라이브러리 확장 검색

### org/jetbrains/plugins/scala/components/libextensions/ui/LibExtensionsSettingsPanelWrapper.scala
select.library.from.the.list.above=위 목록에서 라이브러리 선택
idea.will.try.to.search.for.extra.support.for.particular.libraries=IDEA가 프로젝트의 특정 라이브러리에 대한 추가 지원 검색을 시도합니다
title.failed.to.load.extension.jar=확장 JAR 로드 실패
no.known.extension.libraries=알려진 확장 라이브러리 없음
known.extension.libraries=알려진 확장 라이브러리
extensions.in.selected.library=선택한 라이브러리 내 확장
enable.loading.external.extensions=외부 확장 로드 활성화
how.to.add.custom.macro.support.help.link.title=사용자 지정 Scala 매크로 지원을 추가하는 방법

### org/jetbrains/plugins/scala/components/libextensions/ui/PopupHelper.scala
title.extensions.available=사용 가능한 확장
additional.support.has.been.found.popup=<p>일부 라이브러리에 대한 추가 지원을 찾았습니다.</p><p>활성화하시겠습니까? <a href\="Yes">네</a>/<a href\="No">아니요</a></p>

### org/jetbrains/plugins/scala/console/actions/RunConsoleAction.scala
scala.console.actions.scala.repl=Scala REPL
scalarepl.menu.action.text=Scala REPL...
scalarepl.menu.action.description=Scala REPL 실행

### org/jetbrains/plugins/scala/console/actions/ScalaConsoleCleanAction.scala
clean.scala.repl.content.menu.action.text=Scala REPL 내용 삭제
clean.scala.repl.content.menu.action.description=Scala REPL 내용 삭제

### org/jetbrains/plugins/scala/console/actions/ScalaConsoleExecuteAction.scala
execute.scala.repl.statement.menu.action.text=Scala REPL 구문 실행
execute.scala.repl.statement.menu.action.description=Scala REPL 구문 실행

### org/jetbrains/plugins/scala/console/actions/SendSelectionToConsoleAction.scala
send.selection.to.scala.repl.menu.action.text=Scala REPL에 선택 항목 전송
send.selection.to.scala.repl.menu.action.description=Scala REPL에 선택 항목 전송

### org/jetbrains/plugins/scala/console/configuration/ScalaConsoleConfigurationType.scala
scala.console.config.display.name=Scala REPL
scala.console.config.scala.repl.run.configurations=Scala REPL 실행 구성

### org/jetbrains/plugins/scala/console/configuration/ScalaConsoleRunConfiguration.scala
scala.console.configure.scala.sdk.classpath=Scala SDK 클래스 경로 구성(&C)
scala.console.config.module.is.not.specified=모듈이 지정되지 않았습니다
scala.console.config.unknown.sdk=<unknown sdk>
scala.console.config.scala.console.requires.jline={0} 을(를) 실행하려면 {1} 이(가) 필요합니다\n\
`{2}` 컴파일러 클래스 경로에 추가하십시오

### org/jetbrains/plugins/scala/console/configuration/ScalaConsoleRunConfigurationForm.form
scala.console.config.working.directory=작업 디렉토리\:
scala.console.config.use.classpath.and.sdk.of.module=클래스 경로 및 모듈 SDK 사용\:

### org/jetbrains/plugins/scala/console/configuration/ScalaConsoleRunConfigurationForm.java
scala.console.config.vm.options=VM 옵션
scala.console.config.console.arguments=콘솔 인수
scala.console.config.test.run.config.choose.working.directory=작업 디렉토리 선택

### org/jetbrains/plugins/scala/debugger/breakpoints/ScalaLineBreakpointType.scala
line.breakpoints.tab.title=Scala 줄 중단점

### org/jetbrains/plugins/scala/debugger/evaluation/ScalaEvaluatorBuilder.scala
non-scala.code.fragment=Scala 평가자 빌더 내 Scala가 아닌 코드 조각

### org/jetbrains/plugins/scala/debugger/evaluation/ScalaEvaluatorBuilderUtil.scala
cannot.evaluate.imported.reference=가져온 참고를 평가할 수 없음
cannot.evaluate.local.method=로컬 메소드를 평가할 수 없음
cannot.evaluate.parameter=매개변수 {0} 을(를) 평가할 수 없음
cannot.evaluate.method=메소드 {0} 을(를) 평가할 수 없음
cannot.evaluate.local.object=로컬 객체 {0} 을(를) 평가할 수 없음
cannot.evaluate.local.variable=지역 변수 {0} 을(를) 평가할 수 없음
wrong.number.of.arguments=메소드 {0} 의 인수 개수가 잘못됨
array.instance.is.not.found=메소드 {0} 을(를) 평가할 수 없음\: 배열 인스턴스를 찾을 수 없습니다
array.method.not.supported=배열 메소드가 지원되지 않음
cannot.find.implicit.parameters=전달할 묵시적 매개변수를 찾을 수 없음
implicit.parameters.from.dependent.objects=종속 객체의 묵시적 매개변수는 지원되지 않습니다
implicit.conversions.from.dependent.objects=종속 객체의 묵시적 변환은 지원되지 않습니다
method.with.by-name.parameters=by-name 매개변수를 가진 메소드를 평가할 수 없음
wrong.number.of.expressions=인수를 평가할 수 없음\: 일치하는 표현식 개수가 잘못됨
tupling.not.supported=튜플화가 지원되지 않습니다. 튜플 표현식을 사용하십시오.
not.used.from.for.statement=for 문의 변수 {0} 은(는) 본문에서 사용되지 않으므로 평가할 수 없습니다
cannot.find.pattern=case 절의 패턴을 찾을 수 없음
cannot.find.expression.of.match=match 문 표현식을 찾을 수 없음
invalid.case.clause=유효하지 않은 case 절
assignent.without.expression=표현식이 없는 할당문을 평가할 수 없음
unapply.without.arguments=인수가 없는 unapply의 값을 추출할 수 없음
pattern.doesnot.resolves.to.unapply=패턴 참조 {0} 이(가) unapply 또는 unapplySeq로 해결되지 않음
pattern.alternatives.cannot.bind.vars=패턴 대체가 변수를 바인딩할 수 없습니다
xml.patterns.not.supported=XML 패턴이 지원되지 않습니다
kind.of.patterns.not.supported=이 패턴 종류는 지원되지 않습니다\: {0}
anon.classes.not.supported=익명 함수가 지원되지 않습니다
new.expression.without.class.reference=클래스 참조가 없는 새 표현식을 평가할 수 없음
new.expression.without.constructor.call=생성자 호출이 없는 표현식을 평가할 수 없음
new.expression.without.template.parents=템플릿 상위가 없는 표현식을 평가할 수 없음
could.not.resolve.constructor=생성자를 해결할 수 없음
if.statement.without.condition=조건이 없는 if 문을 평가할 수 없음
if.statement.without.if.branch=if 브랜치가 없는 if 문을 평가할 수 없음
while.statement.without.condition=조건이 없는 while 문을 평가할 수 없음
while.statement.without.body=본문이 없는 while 문을 평가할 수 없음
do.statement.without.condition=조건이 없는 do 문을 평가할 수 없음
do.statement.without.body=본문이 없는 do 문을 평가할 수 없음
method.call.implicitly.converted.qualifier=묵시적으로 변환된 한정자가 있는 메소드 호출을 평가할 수 없음\: {0}

### org/jetbrains/plugins/scala/debugger/evaluation/evaluator/ScalaThisEvaluator.scala
outer.this.not.available=외부 `this`를 사용할 수 없습니다

### org/jetbrains/plugins/scala/debugger/filters/ScalaDebuggerSettingsConfigurable.form
friendly.collection.debug.start.index=컬렉션 시작 색인
friendly.collection.debug.end.index=컬렉션 끝 색인
friendly.collection.display.enabled=디버거에 Scala 컬렉션 표시
friendly.collection.do.not.display.streams=스트림 및 뷰 확장 안 함
dont.show.runtime.refs=디버거에 런타임 참조 표시 안 함
force.class.prepare.request.for.nested.types=\ 중첩 클래스가 VM에서 로드된 경우 강제 처리
force.position.lookup.in.nested.types=중첩 유형 내 중단점 강제 생성
show.variables.from.outer.scopes.in.variables.view=변수 뷰에 외부 범위의 변수 표시

### org/jetbrains/plugins/scala/debugger/filters/ScalaDebuggerSettingsConfigurable.java
scala.debug.caption=Scala

### org/jetbrains/plugins/scala/debugger/filters/ScalaSteppingConfigurable.form
scala.debug.disable.specific.methods=특정 Scala 클래스로 스텝인투 안 함(&I)

### org/jetbrains/plugins/scala/editor/autoimport/ScalaAutoImportOptionsProviderForm.scala
auto.import.insert.imports.on.paste=붙여넣기 시 import 문 삽입\:
auto.import.show.import.popup.for=import 문 팝업 표시\:
auto.import.add.unambiguous.imports.on.the.fly.for=다음에서 모호하지 않은 import 문 즉시 추가\:
auto.import.optimize.imports.on.the.fly=import 문 즉시 최적화
auto.import.show.popup.classes=클래스
auto.import.show.popup.methods=static 멤버
auto.import.show.popup.conversions=묵시적 변환
auto.import.show.popup.implicits=묵시적 정의
options.scala.display.name=Scala
auto.import.find.more.options.in=다음에서 더 많은 옵션 찾기 
auto.import.code.style.link=코드 스타일

### org/jetbrains/plugins/scala/externalHighlighters/CompilerEventGeneratingClient.scala
highlighting.compilation.progress=강조 표시\: {0}

### org/jetbrains/plugins/scala/externalHighlighters/JpsCompiler.scala
highlighting.compilation=오류/경고 강조 표시

### org/jetbrains/plugins/scala/findUsages/compilerReferences/ScalaCompilerReferenceService.scala
open.compiler.index.reader=컴파일러 색인 리더 열기
index.invalidation.callback=색인 무효화 콜백

### org/jetbrains/plugins/scala/findUsages/compilerReferences/SearchTargetExtractors.scala
bytecode.indices.target.sam.type=SAM 유형
bytecode.indices.target.unapply.method=apply/unapply 메소드
bytecode.indices.target.for.comprehension.method=for-comprehension 메소드
bytecode.indices.target.implicit.definition=묵시적 정의

### org/jetbrains/plugins/scala/findUsages/compilerReferences/compilation/JpsCompilationWatcher.scala
malformed.message.from.builder=빌더의 messageText의 형식이 잘못됨\: {0}

### org/jetbrains/plugins/scala/findUsages/compilerReferences/compilation/SbtCompilationWatcher.scala
failed.to.parse.offline.compilation.analysis.files=오프라인 컴파일 분석 파일 파싱에 실패했습니다.
sbt.module.added=SBT 모듈이 추가되었습니다.
sbt.connection.failure=SBT 컴파일 감시자\: 연결에 실패했습니다.
failed.to.parse.compilation.info.file=컴파일 정보 파일 {0} 파싱 실패
error.while.reading.sbt.compilation.info=SBT 컴파일 정보 파일 읽기 시도 도중 오류가 발생했습니다.

### org/jetbrains/plugins/scala/findUsages/compilerReferences/indices/CompilerReferenceIndexer.scala
bytecode.indices.indexing=클래스 파일 색인화 중...
title.initializing.compiler.indices.writer=컴파일러 색인 작성자 초기화 중
title.closing.compiler.indices.writer=컴파일러 색인 작성자 닫는 중
title.invalidating.compiler.indices=컴파일러 색인 무효화 중

### org/jetbrains/plugins/scala/findUsages/compilerReferences/indices/CompilerReferenceIndexerScheduler.scala
bytecode.indices.progress.title=다시 컴파일된 클래스 파일 색인화 중...

### org/jetbrains/plugins/scala/findUsages/compilerReferences/search/CompilerIndicesReferencesSearcher.scala
bytecode.indices.unavailable=컴파일 도중에는 바이트 코드 색인을 통한 사용 위치 검색을 사용할 수 없습니다.
bytecode.indices.in.progress=색인화 진행 중

### org/jetbrains/plugins/scala/findUsages/compilerReferences/search/CompilerIndicesSearcher.scala
bytecode.indices.find.usages=사용 찾기
bytecode.indices.invalidated.title=사용 위치 무효화됨
bytecode.indices.invalidated.message=외부 변경으로 인해 다음 파일의 일부 사용 위치가 무효화되었을 수 있습니다\: {0}.

### org/jetbrains/plugins/scala/findUsages/compilerReferences/search/ImplicitUsagesSearchDialogs.scala
bytecode.indices.find.usages.with.title=사용 위치 검색({0})
bytecode.indices.settings.navigate=바이트 코드 색인 설정으로 이동
bytecode.indices.enable.indexing=바이트 코드 색인화 활성화
bytecode.indices.enable=활성화
bytecode.indices.enable.and.restart=활성화 후 다시 시작
bytecode.indices.precompile=검색 전 사용 범위 안의 모듈 사전 컴파일
bytecode.indices.bytecode=바이트 코드
bytecode.indices.settings=설정 | 바이트 코드 색인 생성
bytecode.indices.required=이 검색은 다음에 의존합니다
bytecode.indices.outdated=, 이는 최신이 아닙니다.
bytecode.indices.incomplete=컴파일하지 않으면 결과가 불완전할 수 있습니다.
bytecode.indices.must.be.enabled.1={0} 사용 위치를 검색하려면 바이트 코드 색인이 활성화되어 있어야 합니다.
bytecode.indices.must.be.enabled.2=바이트 코드 색인화를 활성화하시겠습니까(IDEA 다시 시작 후 적용됨)?

### org/jetbrains/plugins/scala/findUsages/compilerReferences/settings/CompilerIndicesConfigurable.scala
bytecode.indices=바이트 코드 색인
bytecode.indices.restart.title=바이트 코드 색인 설정 업데이트
bytecode.indices.restart.message=IDEA를 다시 시작하여 바이트 코드 색인 설정의 변경을 활성화하시겠습니까?
bytecode.indices.shutdown.message=IDEA를 종료하여 바이트 코드 색인 설정의 변경을 활성화하시겠습니까?

### org/jetbrains/plugins/scala/findUsages/compilerReferences/settings/CompilerIndicesSettingsForm.form
scala.compiler.indices.settings.enable.cb=.class 파일 색인 생성(&I)
scala.compiler.indices.settings.invalidate.button=색인 삭제(&D)
scala.compiler.indices.sbt.automatic=자동 (SBT 쉡 필요)(&A)
scala.compiler.indices.sbt.manual=&Manual
#Bytecode indices settings
apply.unapply.methods=apply/unapply 메소드
for.comprehension.methods=for-comprehension 메소드(map, withFilter, flatMap, foreach)
add.line.to.build.sbt=build.sbt에 다음 줄 추가\:
add.line.to.plugins.sbt=project/plugins.sbt에 다음 줄 추가\:
implicit.definitions=묵시적 정의
port.number=포트 번호\:
sam.types=SAM 유형
sbt.compilation.listener=SBT 컴파일 리스너 구성 (애플리케이션 전체)
use.indices.to.search=색인을 사용하여 사용 위치 검색\:

### org/jetbrains/plugins/scala/findUsages/factory/ScalaFindUsagesHandlerFactory.scala
find.usages.member.has.supers= 멤버 {0} 이(가) 일부 기본 멤버를 재정의/구현합니다.\n\
기본 멤버의 사용 위치를 찾으시겠습니까?
title.warning=경고

### org/jetbrains/plugins/scala/findUsages/factory/ScalaTypeDefinitionUsagesDialog.scala
find.what.members.usages.checkbox=멤버 사용 위치(&M)
find.what.implementing.type.definitions.checkbox=유형 정의 구현 중(&D)
find.what.companion.module.checkbox=컴패니언 모듈 사용 위치(&C)
find.what.new.instances.usages=인스턴스 생성 전용(&I)

### org/jetbrains/plugins/scala/highlighter/ScalaColorSchemeAnnotator.scala
scala.mutable.collection=가변 컬렉션
scala.immutable.collection=불변 컬렉션
java.collection=Java 컬렉션

### org/jetbrains/plugins/scala/lang/completion/ScalaCompletionUtil.scala
wrong.top.statment.declaration=잘못된 top 구문 선언

### org/jetbrains/plugins/scala/lang/completion/ScalaGlobalMembersCompletionContributor.scala
to.import.method.statically.press.hotkey=메소드를 정적으로 가져오려면 {0}(을)를 누릅니다.

### org/jetbrains/plugins/scala/lang/completion/lookups/ScalaImportStaticLookupActionProvider.scala
action.import.member=멤버 가져오기

### org/jetbrains/plugins/scala/lang/findUsages/ScalaUsageTypeProvider.scala
usage.extractor=추출기
usage.typed.pattern=유형이 지정된 패턴
usage.typed.statement=유형이 지정된 구문
usage.method.apply=메소드 `apply`
usage.this.reference=이 참조
usage.access.modifier=접근 제어자
usage.package.clause=패키지 절
usage.function.expression=함수 표현식
usage.named.parameter=명명된 매개변수
usage.interpolated.string.prefix=보간된 문자열 접두사
usage.parameter.in.pattern=패턴 내 매개변수
usage.self.type=자체 유형
usage.type.bound=유형 바운드
usage.type.alias=유형 별칭
usage.secondary.constructor=보조 생성자
usage.implicit.conversion.parameter=묵시적 변환/매개변수
usage.unresolved.implicit.conversion.parameter=해결되지 않은 묵시적 변환/매개변수
usage.sam.interface.implementation=SAM 인터페이스 구현

### org/jetbrains/plugins/scala/lang/formatting/scalafmt/ScalaFmtSuggesterService.scala
scalafmt.suggester.detected.in.project=이 프로젝트에서 Scalafmt 구성이 탐지됨
scalafmt.suggester.use.scalafmt.formatter=Scalafmt 서식 지정 도구 사용
scalafmt.suggester.continue.using.intellij.formatter=IntelliJ 서식 지정 도구 계속 사용

### org/jetbrains/plugins/scala/lang/formatting/scalafmt/ScalafmtDynamicConfigServiceImpl.scala
#Scalafmt
scalafmt.picked.new.config=Scalafmt에 새 스타일 설정(v{0})이 적용되었습니다
scalafmt.can.not.find.config.file=구성 파일을 찾을 수 없습니다. {0}
scalafmt.can.not.find.config.file.go.to.settings=Ajustes...
scalafmt.can.not.find.config.file.create.new=새 파일을 생성합니다.
scalafmt.can.not.create.config.file=구성 파일을 생성할 수 없습니다
scalafmt.config.load.errors.failed.to.load.config=Scalafmt 구성 로드 실패
scalafmt.config.load.errors.file.not.found=파일을 찾을 수 없음
scalafmt.config.load.errors.parse.error=파싱 오류\: {0}
scalafmt.config.load.errors.unknown.error=알 수 없는 오류\: {0}
scalafmt.config.load.errors.cyclic.includes.detected=순환 include가 탐지되었습니다
scalafmt.config.load.actions.open.config.file=구성 파일 열기

### org/jetbrains/plugins/scala/lang/formatting/scalafmt/ScalafmtDynamicServiceImpl.scala
scalafmt.download=Descargar
scalafmt.resolve.again=다시 해결
scalafmt.progress.resolving.scalafmt.version=Scalafmt 버전 {0} 해결 중
scalafmt.progress.downloading.scalafmt.version=Scalafmt 버전 {0} 다운로드 중
scalafmt.progress.resolving.scalafmt.version.cancel=해결 중지
scalafmt.progress.downloading.scalafmt.version.cancel=다운로드 중지
scalafmt.progress.version.was.downloaded=Scalafmt 버전 {0} 이(가) 다운로드되었습니다
scalafmt.resolve.errors.cant.resolve.scalafmt.version=Scalafmt 버전 {0} 을(를) 해결할 수 없음
scalafmt.resolve.errors.version.is.not.downloaded.yet=Scalafmt 버전 `{0}` 이(가) 다운로드되지 않았습니다.<br>다운로드 하시겠습니까?
scalafmt.resolve.errors.download.is.in.progress=다운로드가 진행 중입니다
scalafmt.resolve.errors.downloading.error.occurred=다운로드 중 오류 발생
scalafmt.resolve.errors.classpath.is.corrupted=클래스 경로가 손상되었습니다
scalafmt.resolve.errors.unknown.error=알 수 없는 오류

### org/jetbrains/plugins/scala/lang/formatting/scalafmt/dynamic/ScalafmtDynamic.scala
file.does.not.exist=파일이 없습니다.
failed.to.resolve.scalafmt.version=Scalafmt 버전 ''{0}'' 해결 실패

### org/jetbrains/plugins/scala/lang/formatting/scalafmt/processors/ScalaFmtPreFormatProcessor.scala
#0:file link;1:error message
scalafmt.format.errors.scala.file.parse.error=Scalafmt 파싱 오류 ({0})\:<br>{1}
#0:file link;1:error message
scalafmt.format.errors.failed.to.find.correct.surrounding.code=Scalafmt 오류 ({0})\:<br> scalafmt에 전달할 올바른 둘러싸는 코드 찾기 실패, 서식 지정이 수행되지 않습니다

### org/jetbrains/plugins/scala/lang/formatting/settings/ImportPanelConverterProvider.scala
scala.imports.settings.will.be.moved.to.code.style.settings=Scala import 문 설정이 코드 스타일 설정으로 이동됩니다

### org/jetbrains/plugins/scala/lang/formatting/settings/ImportsPanel.form
imports.panel.class.count.to.use.import.with='_'로 import를 사용하는 클래스 수\:
imports.panel.add.import.statement.in.closest.block=가장 가까운 블록에 import 문 추가
imports.panel.add.fully.qualified.imports=정규화된 import 문 추가
imports.panel.do.not.change.path.during.optimize.imports.for.local.imports=로컬 가져오기 import 문 최적화 도중 경로 변경 안 함
imports.panel.sort.imports.for.optimize.imports=import 문 정렬(import 문 최적화)\:
imports.panel.lexicographically=사전순
imports.panel.scalastyle.consistent=scalastyle 일치
#TODO
imports.panel.merge.imports.with.the.same.prefix.into.one.statement=동일한 접두사를 가진 import 문을 한 구문으로 병합
imports.panel.use.the.shortest.path.when.trying.to.import.reference.with.already.imported.name=이미 가져온 이름을 가진 참조 가져오기 시도 시 최단 경로 사용
imports.panel.classes.to.use.only.with.prefix=접두사만 포함하는 사용할 클래스
imports.panel.import.layout=레이아웃 가져오기
imports.panel.imports.always.marked.as.used=항상 사용됨으로 표시된 import 문

### org/jetbrains/plugins/scala/lang/formatting/settings/ImportsPanel.java
# Imports panel
imports.panel.title=가져오기
imports.panel.add.pattern.to.use.appropriate.classes.only.with.prefix=접두사만 포함하는 클래스를 사용하는 패턴 추가
imports.panel.use.references.with.prefix=접두사를 포함하는 참조 사용\:
imports.panel.no.imports.with.prefix=접두사를 포함하는 import 문 없음
imports.panel.add.package.name=패키지 이름 추가
imports.panel.import.layout.manager=가져오기 레이아웃 관리자
imports.panel.add.import.to.always.mark.it.as.used=항상 사용됨으로 표시할 import 문 추가
imports.panel.always.mark.as.used=항상 사용됨으로 표시
imports.panel.honestly.mark.imports.as.unused=import 문을 사용 안 됨으로 솔직하게 표시

### org/jetbrains/plugins/scala/lang/formatting/settings/MultiLineStringCodeStylePanel.form
multi.line.string.panel.opening.quotes.on.new.line=새 줄에 여는 따옴표 배치(&O)
multi.line.string.panel.place.closing.quotes.on.new.line.on.enter.press=Enter 입력 시 새 줄에 닫는 따옴표 배치(&C)
multi.line.string.panel.align.dangling.closing.quotes=허상 닫는 따옴표 할당(&A)
multi.line.string.panel.insert.margin.char.on.enter=Enter 입력 시 새 줄에 여백 문자 삽입(&I)
multi.line.string.panel.process.margin.on.copy.paste=복사/붙여넣기 시 여백 제거/삽입(&S)
multi.line.string.panel.margin.char.value=여백 문자\:
multi.line.string.panel.margin.char.indent=여백 문자 들여쓰기\:

### org/jetbrains/plugins/scala/lang/formatting/settings/MultiLineStringCodeStylePanel.java
#Multi-line strings panel
multi.line.string.panel.title=다중 줄 문자열

### org/jetbrains/plugins/scala/lang/formatting/settings/OtherCodeStylePanel.form
other.panel.enforce.functional.syntax.for.methods.with.unit.return.type=Unit 반환 유형을 가진 메소드에 대한 함수 구문 강제 실행
other.panel.reformat.on.compile=컴파일 시 서식 다시 지정
other.panel.replace.with.unicode.symbol='\=>'를 유니코드 심볼로 교체
other.panel.replace.with.unicode.symbol1='->'를 유니코드 심볼로 교체
other.panel.replace.in.for.generator.with.unicode.symbol='<-' in \"for\" 생성기를 유니코드 심볼로 교체
other.panel.kind.projector.replace.lambda.with.unicode.symbol=Kind Projector\: 'Lambda'를 유니코드 심볼로 교체
other.panel.alternate.indentation.for.constructor.args.and.parameter.declarations=생성자 인수 및 매개변수 선언에 대한 대체 들여쓰기\:
other.panel.spaces=공백
other.panel.implicit.value.class.prefix.suffix=Implicit value class prefix/suffix

### org/jetbrains/plugins/scala/lang/formatting/settings/OtherCodeStylePanel.java
#Other panel
other.panel.title=Otros

### org/jetbrains/plugins/scala/lang/formatting/settings/ScalaCodeStyleSettings.java
#align options
wrapping.and.braces.panel.extends.do.not.align=정렬하지 않음
wrapping.and.braces.panel.extends.on.first.token=첫 번째 토큰
wrapping.and.braces.panel.extends.align.to.extends='extends'에 할당

### org/jetbrains/plugins/scala/lang/formatting/settings/ScalaDocFormattingPanel.scala
#Scaladoc panel
scaladoc.panel.title=ScalaDoc
scaladoc.panel.enable.scaladoc.formatting=scaladoc 서식 지정 활성화
scaladoc.panel.add.additional.space.for.leading.asterisk=선행 별표에 추가 공백 추가
scaladoc.panel.groups.blank.lines=빈 줄
scaladoc.panel.groups.alignment=맞추기
scaladoc.panel.groups.other=기타

### org/jetbrains/plugins/scala/lang/formatting/settings/ScalaFmtSettingsPanel.scala
scalafmt.default=Por defecto
scalafmt.default.path=디폴트 값\: {0}
#Code style panel
scalafmt.settings.panel.show.warnings.when.formatting.invalid.code=유효하지 않은 코드 서식 지정 시도 시 경고 표시
scalafmt.settings.panel.use.intellij.formatter.for.code.range.formatting=코드 범위 서식 지정을 위해 IntelliJ 서식 지정 도구 사용
scalafmt.settings.panel.use.intellij.formatter.for.code.range.formatting.warning.tooltip=코드 범위 서식 지정을 위해 Scalafmt을 사용하면 코드 불일치가 발생할 수 있습니다.<br>Scalafmt은 Scala 코드를 포함하는 전체 파일 서식 지정을 위해서만 사용해야 합니다.
scalafmt.settings.panel.reformat.on.file.save=파일 저장 시 서식 다시 지정
scalafmt.settings.panel.fallback.to.default.settings=디폴트 IntelliJ 설정으로 되돌리기
scalafmt.settings.panel.configuration.label=구성
scalafmt.settings.panel.scalafmt.version.label=Scalafmt 버전
scalafmt.settings.panel.select.custom.scalafmt.configuration.file=사용자 지정 Scalafmt 구성 파일 선택
scalafmt.settings.panel.no.config.found.under.path.using.default=지정된 경로에서 구성 파일을 찾을 수 없습니다
scalafmt.settings.panel.errors.cant.resolve.version=Scalafmt 버전 {0} 을(를) 해결할 수 없음
scalafmt.settings.panel.errors.failed.to.parse.config=파싱 설정 실패\:<br> {0}
scalafmt.settings.panel.errors.cant.find.config.file=다음 경로를 가진 Scalafmt 구성 파일을 찾을 수 없습니다.<br> {0}

### org/jetbrains/plugins/scala/lang/formatting/settings/ScalaLanguageCodeStyleSettingsProvider.scala
#Spaces
spaces.panel.simple.one.line.block.braces=단순한 한 줄 블록 중괄호
spaces.panel.import.braces=중괄호 가져오기
spaces.panel.self.type.braces=자체 유형 중괄호
spaces.panel.before.context.bound.colon.rest=컴텍스트 바운드 콜론 앞 (rest)
spaces.panel.before.context.bound.colon.leading.higher.kinded=컨텍스트 바운드 콜론 앞 (선행 상류)
spaces.panel.before.context.bound.colon.leading=컨텍스트 바운드 콜론 앞 (선행)
spaces.panel.before.opening.square.bracket=여는 대괄호 앞
spaces.panel.keep.one.line.comments.on.same.line=같은 줄에 한 줄 주석 유지
spaces.panel.newline.after.annotations=어노테이션 뒤 새 줄
spaces.panel.around.at.in.pattern.bindings=패턴 바인팅 내 '@' 주위
spaces.panel.inside.closure.braces=클로저 중괄호 내부
spaces.panel.before.colon.after.declarations.name=콜론 앞, 선언 이름 뒤
spaces.panel.after.colon.before.declarations.type=콜론 뒤, 선언 유형 앞
spaces.panel.method.call.left.brace=메소드 호출 왼쪽 중괄호
spaces.panel.preserve.space.before.method.parentheses=메소드 소괄호 앞 공백 유지
spaces.panel.infix.method.parentheses=inflix 메소드 소괄호
spaces.panel.infix.operator.like.method.call.parentheses=inflix 연산자식 메소드 호출 소괄호
spaces.panel.infix.method.call.parentheses=inflix 메소드 호출 소괄호
spaces.panel.constructor.parameters.with.modifiers=제어자를 가진 생성자 매개변수
#Wrapping and Braces
#custom groups
wrapping.and.braces.panel.groups.method.definition=메소드 정의
wrapping.and.braces.panel.groups.anonymous.method.definition=익명 메소드 정의
wrapping.and.braces.panel.groups.class.definition=클래스 정의
wrapping.and.braces.panel.groups.xml.formatting=XML 서식 지정
wrapping.and.braces.panel.groups.tuple=튜플
wrapping.and.braces.panel.groups.type.arguments=유형 인수
wrapping.and.braces.panel.groups.type.parameters=유형 매개변수
wrapping.and.braces.panel.force.braces=중괄호 강제 적용
wrapping.and.braces.panel.force.try.braces='try' 중괄호 강제 적용
wrapping.and.braces.panel.force.case.branch.braces='case' 중괄호 강제 적용
wrapping.and.braces.panel.force.finally.braces='finally' 중괄호 강제 적용
wrapping.and.braces.panel.align.tuple.elements=튜플 요소 정렬
wrapping.and.braces.panel.do.not.indent.tuples.closing.parenthesis=튜플 닫는 소괄호 들여쓰기 안 함
wrapping.and.braces.panel.do.not.align.block.expression.parameters=블록 표현식 매개변수 정렬 안 함
wrapping.and.braces.panel.indent.braced.arguments=중괄호 안 인수 들여쓰기
wrapping.and.braces.panel.simple.one.line.lambdas.in.arg.list=인수 목록 내 간단한 한 줄 람다
wrapping.and.braces.panel.keep.xml.formatting=XML 서식 지정 유지
wrapping.and.braces.panel.place.self.type.on.new.line=새 줄에 자체 유형 배치
wrapping.and.braces.panel.align.multiline.pattern.alternatives=다중 줄 패턴 대체 할당
wrapping.and.braces.panel.align.in.columns.case.branches='case' 브랜치 열 정렬
wrapping.and.braces.panel.do.not.indent.case.clause.body=case 절 본문 들여쓰기 안 함
wrapping.and.braces.panel.match.statement='match' 문
wrapping.and.braces.panel.indent.first.parameter.clause.if.on.new.line=새 줄에서 첫 번째 매개변수 절 들여쓰기
wrapping.and.braces.panel.indent.first.parameter.if.on.new.line=새 줄에서 첫 번쨰 매개변수 들여쓰기
wrapping.and.braces.panel.align.parameter.types.in.multiline.declarations=다중 줄 선언 내 매개변수 유형 정렬
wrapping.and.braces.panel.use.normal.indent.for.parameters=매개변수 일반 들여쓰기 사용
wrapping.and.braces.panel.parameters.on.new.line=새 줄의 매개변수
wrapping.and.braces.panel.wrap.before.with.keyword='with' 키워드 앞 줄 바꿈
wrapping.and.braces.panel.align.if.else.statements=if-else 구문 정렬
wrapping.and.braces.panel.indent=Sangrar
wrapping.and.braces.panel.new.line.options.no.new.line=새 줄 없음
wrapping.and.braces.panel.new.line.options.new.line.always=항상 줄 바꿈
wrapping.and.braces.panel.new.line.options.new.line.for.multiple.arguments=다중 줄 인수 사용 시 줄 바꿈
wrapping.and.braces.panel.renamed.infix.expressions=inflix 표현식
wrapping.and.braces.panel.renamed.extends.with.list=extends/with 목록
wrapping.and.braces.panel.renamed.extends.keyword=키워드 확장
wrapping.and.braces.panel.renamed.force.yield.braces=yield 중괄호 강제 적용
#Blank Lines
blank.lines.panel.around.method.in.inner.scopes=내부 범위 내 메소드 주위
blank.lines.panel.around.field.in.inner.scopes=내부 범위 내 필드 주위
scaladoc.panel.align.parameter.descriptions=매개변수 설명 정렬
scaladoc.panel.align.throws.exception.descriptions=할당이 예외 설명을 던집니다
scaladoc.panel.align.return.value.description=반환 값 설명 정렬
scaladoc.panel.align.other.tags.descriptions=기타 태그 설명 정렬
scaladoc.panel.blank.lines.keep=유지(태그 사이의 빈 줄이 제거되지 않습니다)
scaladoc.panel.between.parameter.descriptions=매개변수 설명 사이
scaladoc.panel.before.parameter.descriptions=매개변수 설명 앞
scaladoc.panel.preserve.spaces.in.tags=태그 공백 유지

### org/jetbrains/plugins/scala/lang/formatting/settings/ScalaTabbedCodeStylePanel.scala
scala.root.code.style.panel.formatter=서식 지정 도구\:

### org/jetbrains/plugins/scala/lang/formatting/settings/TrailingCommaPanel.scala
#Trailing comma
trailing.comma.panel.title=후행 쉼표
trailing.comma.panel.keep=유지
trailing.comma.panel.remove.when.multiline=다중 줄 사용 시 제거
trailing.comma.panel.add.when.multiline=여러 줄일 경우 추가
trailing.comma.panel.scope.arguments.list=인수 목록
trailing.comma.panel.scope.parameters.list=매개변수 목록
trailing.comma.panel.scope.tuple=튜플
trailing.comma.panel.scope.tuple.type=튜플 유형
trailing.comma.panel.scope.pattern.arguments.list=패턴 인수 목록
trailing.comma.panel.scope.type.parameters.list=유형 매개변수 목록
trailing.comma.panel.scope.import.selector=가져오기 선택자

### org/jetbrains/plugins/scala/lang/formatting/settings/TypeAnnotationsPanelBase.form
#Use for
type.annotations.panel.use.for=사용 대상
type.annotations.panel.public.member=public 멤버
type.annotations.panel.protected.member=protected 멤버
type.annotations.panel.private.member=private 멤버
type.annotations.panel.local.definition=로컬 정의
type.annotations.panel.function.literal.parameter=함수 리터럴 매개변수
type.annotations.panel.underscore.parameter=밑줄 매개변수
#Enforce for
type.annotations.panel.enforce.for=적용 대상
type.annotations.panel.implicit.definition=묵시적 정의
type.annotations.panel.unit.type=Unit 유형
type.annotations.panel.accidental.structural.type=예기치 않은 구조 유형*
type.annotations.panel.accidental.structural.type.tooltip=<html>값에 유형 어노테이션 강제 적용, 추론된 구조 유형을 가짐, 예\:<br>\n\
<pre><code>\n\
val foo \= Runnable {\n\
  override def run()\: Unit \= ()\n\
  def helper()\: Unit \= ()\n\
} // foo has inferred type Runnable { def helper()\: Unit } \n\
</code></pre></html>
#Except when
type.annotations.panel.except.when=다음과 같은 경우 예외
type.annotations.panel.member.of.anonymous.class=익명 클래스 멤버
type.annotations.panel.member.of.private.class=private 클래스 멤버
type.annotations.panel.member.of=다음의 멤버\:
type.annotations.panel.annotated.with=어노테이션 지정\:
type.annotations.panel.constant.final.val=상수 (final val)
type.annotations.panel.type.is.stable=유형이 안정적입니다*
type.annotations.panel.type.is.stable.tooltip=<html><body>오른쪽이\:<br> 리터럴\: <code>123</code>인 경우, <code>\"string\"</code> 등. (<code>null</code> 포함)<br> Unit 표현식\: <code>()</code><br> 객체 생성\: <code>new Foo(...)</code> (개선 코드 포함\: <code>new Foo() {}</code>)<br> Factory 메소드 호출\: <code>Foo(...)</code> (컴패니언 객체에서 <code>apply(...)</code> 호출)<br> 빈 컬렉션\: <code>Seq.empty[Int]</code>, <code>Map.empty[Int, String]</code>, etc.<br> Java 열거형 상수\: <code>Enum.VALUE</code><br> 예외\: <code>throw Exception()</code></body></html>
type.annotations.panel.type.matches=유형 일치\:
type.annotations.panel.in.test.sources=테스트 소스 내
type.annotations.panel.in.scala.dialect.sources=Scala 파생 언어 소스 내*
type.annotations.panel.in.scala.dialect.sources.tooltip=*.sbt, *.sc, etc.

### org/jetbrains/plugins/scala/lang/formatting/settings/TypeAnnotationsPanelBase.java
#Type Annotations panel
type.annotations.panel.title=유형 어노테이션
type.annotations.panel.classes=클래스
type.annotations.panel.annotations=어노테이션
type.annotations.panel.type.patterns=유형 패턴

### org/jetbrains/plugins/scala/lang/macros/expansion/MacroExpansionLineMarkerProvider.scala
scala.meta.expand=매크로 확장

### org/jetbrains/plugins/scala/lang/parser/parsing/CommonUtils.scala
wrong.pattern=잘못된 패턴
right.brace.expected='}' 이(가) 기대됩니다
bad.interpolated.string.injection=보간된 문자열 삽입이 잘못됨
wrong.string.literal=잘못된 문자열 리터럴

### org/jetbrains/plugins/scala/lang/parser/parsing/CompilationUnit.scala
package.qualID.expected=패키지 이름이 표시된 정규화된 식별자 기대
semi.expected=';' 또는 새 줄 기대
out.of.compilation.unit=컴파일 장치를 범어남

### org/jetbrains/plugins/scala/lang/parser/parsing/Packaging.scala
lbrace.expected='{' 이(가) 필요합니다
unreachable.error=예기치 않은 오류 발견

### org/jetbrains/plugins/scala/lang/parser/parsing/base/AccessQualifier.scala
rsqbracket.expected=']' 가 필요합니다
identifier.expected=식별자 기대

### org/jetbrains/plugins/scala/lang/parser/parsing/base/ImportExpr.scala
identifier.or.opening.brace.expected=식별자 또는 여는 중괄호가 필요합니다

### org/jetbrains/plugins/scala/lang/parser/parsing/base/ImportSelector.scala
identifier.or.wild.sign.expected=식별자 또는 '_' 기대

### org/jetbrains/plugins/scala/lang/parser/parsing/base/ImportSelectors.scala
rbrace.expected='}' 이(가) 필요합니다
import.selector.expected=import 선택자 기대

### org/jetbrains/plugins/scala/lang/parser/parsing/expressions/Annotation.scala
wrong.annotation.expression=잘못된 어노테이션 표현식

### org/jetbrains/plugins/scala/lang/parser/parsing/expressions/ArgumentExprs.scala
rparenthesis.expected=')' 이(가) 필요합니다
wrong.expression=잘못된 표현식

### org/jetbrains/plugins/scala/lang/parser/parsing/expressions/Ascription.scala
annotation.or.type.expected=어노테이션 또는 유형 기대

### org/jetbrains/plugins/scala/lang/parser/parsing/expressions/Binding.scala
wrong.type=잘못된 유형

### org/jetbrains/plugins/scala/lang/parser/parsing/expressions/Bindings.scala
wrong.binding=잘못된 매개변수

### org/jetbrains/plugins/scala/lang/parser/parsing/expressions/BlockStat.scala
wrong.declaration.in.block=블록에 선언이 포함될 수 없습니다

### org/jetbrains/plugins/scala/lang/parser/parsing/expressions/Enumerator.scala
choose.expected=생성기 구문 내 '<-' 기대

### org/jetbrains/plugins/scala/lang/parser/parsing/expressions/Expr1.scala
case.clauses.expected=case 절 기대
while.expected='do' 구문 내 while 키워드 기대
enumerators.expected='for' 문 내 열거자 기대
condition.expected=부울 조건 기대
expected.then='then'이 필요합니다
expected.do='do'가 필요합니다
expected.do.or.yield='do' 또는 'yield'가 필요합니다

### org/jetbrains/plugins/scala/lang/parser/parsing/expressions/InfixExpr.scala
wrong.type.associativity=연관성이 잘못되었습니다. 모든 연산자가 동일한 연관성을 가져야 합니다

### org/jetbrains/plugins/scala/lang/parser/parsing/expressions/NameValuePair.scala
assign.expected='\=' 예상

### org/jetbrains/plugins/scala/lang/parser/parsing/expressions/Quoted.scala
type.expected=유형이 필요합니다

### org/jetbrains/plugins/scala/lang/parser/parsing/expressions/ResultExpr.scala
fun.sign.expected='\=>' 예상

### org/jetbrains/plugins/scala/lang/parser/parsing/params/FunTypeParamClause.scala
wrong.parameter=잘못된 매개변수

### org/jetbrains/plugins/scala/lang/parser/parsing/params/ImplicitParamClause.scala
implicit.params.excepted=묵시적 매개변수 절은 최소 하나의 매개변수를 포함해야 합니다

### org/jetbrains/plugins/scala/lang/parser/parsing/params/ParamClauses.scala
param.clause.expected=매개변수 절 기대

### org/jetbrains/plugins/scala/lang/parser/parsing/params/TypeParam.scala
variance.annotation.not.allowed=변화 어노테이션이 허용되지 않습니다
context.bounds.not.allowed=컨텍스트 바운드가 허용되지 않습니다
view.bounds.not.allowed=뷰 바운드가 허용되지 않습니다

### org/jetbrains/plugins/scala/lang/parser/parsing/params/TypesAsParamsOrParams.scala
expected.more.types=더 많은 유형이 필요합니다

### org/jetbrains/plugins/scala/lang/parser/parsing/patterns/CaseClause.scala
pattern.expected=패턴 기대

### org/jetbrains/plugins/scala/lang/parser/parsing/patterns/Guard.scala
wrong.postfix.expression=잘못된 접미사 표현식

### org/jetbrains/plugins/scala/lang/parser/parsing/patterns/Pattern3.scala
simple.pattern.expected=단순 패턴의 올바르지 않은 시작

### org/jetbrains/plugins/scala/lang/parser/parsing/statements/FunDef.scala
constr.block.expected=생성자 블록 기대
wrong.constr.expression=잘못된 생성자 표현식
expected.parameter.clause.for.extension.method=확장 메소드에 대한 매개변수 절이 필요합니다

### org/jetbrains/plugins/scala/lang/parser/parsing/statements/PatDef.scala
expression.expected=표현식 기대

### org/jetbrains/plugins/scala/lang/parser/parsing/statements/TypeDef.scala
match.type.expected=Match 유형 기대

### org/jetbrains/plugins/scala/lang/parser/parsing/statements/ValDcl.scala
wrong.val.declaration=잘못된 값 선언

### org/jetbrains/plugins/scala/lang/parser/parsing/statements/VarDcl.scala
wrong.var.declaration=잘못된 변수 선언

### org/jetbrains/plugins/scala/lang/parser/parsing/statements/VarDef.scala
type.declaration.expected=유형 선언 기대

### org/jetbrains/plugins/scala/lang/parser/parsing/top/Parents.scala
wrong.simple.type=잘못된 단순 유형

### org/jetbrains/plugins/scala/lang/parser/parsing/top/Qual_Id.scala
wrong.qual.identifier=정규화된 식별자가 잘못됨

### org/jetbrains/plugins/scala/lang/parser/parsing/top/TmplDef.scala
wrong.case.modifier=케이스 제어자가 잘못되었습니다. 클래스 또는 객체로 사용하십시오

### org/jetbrains/plugins/scala/lang/parser/parsing/top/params/ClassParam.scala
colon.expected='\:' 예상
parameter.type.expected=매개변수 유형 기대
val.var.expected=val 또는 var 키워드 기대

### org/jetbrains/plugins/scala/lang/parser/parsing/top/template/TemplateBody.scala
def.dcl.expected=정의 또는 선언 기대
expected.indented.template.body=들여쓰기된 템플릿 본문이 필요합니다

### org/jetbrains/plugins/scala/lang/parser/parsing/types/ExistentialClause.scala
existential.block.expected=존재 절 기대

### org/jetbrains/plugins/scala/lang/parser/parsing/types/ExistentialDclSeq.scala
wrong.existential.declaration=잘못된 존재 선언입니다. 유형 또는 값 선언이어야 합니다

### org/jetbrains/plugins/scala/lang/parser/parsing/types/InfixType.scala
compound.type.expected=복합 유형 기대

### org/jetbrains/plugins/scala/lang/parser/parsing/types/MatchTypeSuffix.scala
match.type.cases.expected=Match 유형 case 절 기대

### org/jetbrains/plugins/scala/lang/parser/parsing/types/PolyFunOrTypeLambda.scala
type.lambda.expected='\=>>' 예상

### org/jetbrains/plugins/scala/lang/parser/parsing/types/SimpleType.scala
identifier.expected.comma.found=식별자가 기대되나 ','이 발견됨

### org/jetbrains/plugins/scala/lang/parser/parsing/types/StableId.scala
dot.expected='.' 예상
dot.or.cq.expected='.' 또는 클래스 한정자가 필요합니다

### org/jetbrains/plugins/scala/lang/parser/parsing/xml/AttrValue.scala
xml.attribute.end.expected=XML 속성 값 끝 구분자 기대

### org/jetbrains/plugins/scala/lang/parser/parsing/xml/Attribute.scala
xml.eq.expected='\=' 예상
xml.attribute.value.expected=속성 값이 필요합니다

### org/jetbrains/plugins/scala/lang/parser/parsing/xml/CDSect.scala
xml.cdata.end.expected=XML CData 끝 기대

### org/jetbrains/plugins/scala/lang/parser/parsing/xml/Comment.scala
xml.comment.end.expected=XML 주석 끝('-->') 기대
xml.wrong.character=XML 주석 내 잘못된 문자열

### org/jetbrains/plugins/scala/lang/parser/parsing/xml/ETag.scala
xml.tag.end.expected=XML 태그 끝 기대
xml.name.expected=XML 태그 이름 기대

### org/jetbrains/plugins/scala/lang/parser/parsing/xml/Element.scala
xml.end.tag.expected=XML 끝 태그('</' name '>') 기대

### org/jetbrains/plugins/scala/lang/parser/parsing/xml/PI.scala
xml.PI.end.expected=XML 처리 지침 끝 기대

### org/jetbrains/plugins/scala/lang/parser/parsing/xml/ScalaExpr.scala
xml.scala.injection.end.expected=XML 내 Scala 삽입 끝('}') 기대
xml.scala.expression.exected=XML 주입 내 Scala 표현식 기대

### org/jetbrains/plugins/scala/lang/parser/parsing/xml/pattern/ScalaPatterns.scala
xml.scala.patterns.exected=XML 주입 내 Scala 패턴 기대

### org/jetbrains/plugins/scala/lang/psi/api/base/types/ScTypeElement.scala
recursive.type.of.type.element=유형 요소의 재귀 유형
cannot.desugarize.typename={0} 을(를) 디슈가링할 수 없습니다

### org/jetbrains/plugins/scala/lang/psi/api/expr/ScBlock.scala
cannot.find.partialfunction.class=PartialFunction 클래스를 찾을 수 없음
cannot.find.throwable.class=Throwable 클래스를 찾을 수 없음
cannot.infer.type.without.expected.type=기대 유형이 없는 유형을 추론할 수 없음
cannot.infer.type.without.function.expected.type=scala.FunctionN 또는 scala.PartialFunction의 기대 유형이 없는 유형을 추론할 수 없음

### org/jetbrains/plugins/scala/lang/psi/api/expr/ScExpression.scala
no.type.inferred=표현식 ''{0}'' 의 유형을 추론할 수 없음

### org/jetbrains/plugins/scala/lang/psi/api/statements/ScTypeAliasDefinition.scala
no.alias.type=별칭 유형 없음

### org/jetbrains/plugins/scala/lang/psi/compiled/SigFileViewProviderFactory.scala
file.type.scala.outlines=Scala 개요
could.not.decompile.file.comment=//{0} 을(를) 디컴파일할 수 없음

### org/jetbrains/plugins/scala/lang/psi/impl/base/ScConstructorInvocationImpl.scala
can.t.resolve.type=유형을 해결할 수 없음
java.constructors.only.have.one.parameter.section=Java 생성자가 단 하나의 매개변수 섹션을 포함합니다 
has.no.reference=참조 없음

### org/jetbrains/plugins/scala/lang/psi/impl/base/literals/ScLiteralImplBase.scala
wrong.psi.for.literal.type="리터럴 유형을 얻는 요소가 잘못됨"

### org/jetbrains/plugins/scala/lang/psi/impl/base/patterns/ScConstructorPatternImpl.scala
cannot.resolve.unknown.symbol=심볼을 해결할 수 없음

### org/jetbrains/plugins/scala/lang/psi/impl/base/patterns/ScNamingPatternImpl.scala
no.expected.type.for.wildcard.naming=와일드카드 이름 지정을 위한 기대 유형 없음

### org/jetbrains/plugins/scala/lang/psi/impl/base/patterns/ScPatternImpl.scala
cannot.type.pattern=패턴 유형을 지정할 수 없음

### org/jetbrains/plugins/scala/lang/psi/impl/base/patterns/ScReferencePatternImpl.scala
cannot.define.expected.type=기대 유형을 정의할 수 없음

### org/jetbrains/plugins/scala/lang/psi/impl/base/patterns/ScTypedPatternImpl.scala
no.type.element.for.type.pattern=유형 패턴에 대한 유형 요소 없음
no.type.pattern=유형 패턴 없음

### org/jetbrains/plugins/scala/lang/psi/impl/base/patterns/ScWildcardPatternImpl.scala
cannot.determine.expected.type=기대 유형을 확인할 수 없음

### org/jetbrains/plugins/scala/lang/psi/impl/base/types/ScSimpleTypeElementImpl.scala
cannot.find.template.for.this.reference=이 참조의 템플릿을 찾을 수 없음
cannot.find.enclosing.container=해당 컨테이너를 찾을 수 없음
cannot.resolve.ref=참조를 해결할 수 없음
unknown.macro.in.type.position=유형 조건 내 알 수 없는 매크로
recursive.non.value.type.of.type.element=유형 요소의 값이 아닌 재귀 유형

### org/jetbrains/plugins/scala/lang/psi/impl/base/types/ScTypeProjectionImpl.scala
cannot.resolve.reference=참조를 해결할 수 없음

### org/jetbrains/plugins/scala/lang/psi/impl/expr/MethodInvocationImpl.scala
suitable.method.not.found=적합한 메소드를 찾을 수 없음

### org/jetbrains/plugins/scala/lang/psi/impl/expr/ScForImpl.scala
cannot.create.expression=표현식을 생성할 수 없음

### org/jetbrains/plugins/scala/lang/psi/impl/expr/ScGenericCallImpl.scala
not.a.polymorphic.lambda=polymorphic 람다가 아님

### org/jetbrains/plugins/scala/lang/psi/impl/expr/ScIfImpl.scala
nothing.to.type=유형 지정할 항목 없음

### org/jetbrains/plugins/scala/lang/psi/impl/expr/ScParenthesisedExprImpl.scala
no.expression.in.parentheseses=소괄호 안에 표현식 없음

### org/jetbrains/plugins/scala/lang/psi/impl/expr/ScReferenceExpressionImpl.scala
no.declared.type.found=정의된 유형을 찾을 수 없음
case.class.has.no.primary.constructor=케이스 클래스에 기본 생성자가 없습니다
cannot.resolve.expression=표현식을 해결할 수 없음

### org/jetbrains/plugins/scala/lang/psi/impl/expr/ScSuperReferenceImpl.scala
cannot.infer.type.of.super.expression=`super' 표현식의 유형을 추론할 수 없음

### org/jetbrains/plugins/scala/lang/psi/impl/expr/ScThisReferenceImpl.scala
cannot.infer.type=유형을 추론할 수 없음
no.clazz.type.found=클래스 유형을 찾을 수 없습니다

### org/jetbrains/plugins/scala/lang/psi/impl/expr/ScUnderscoreSectionImpl.scala
typed.statement.is.not.complete.for.underscore.section=유형이 지정된 구문이 밑줄 섹션에 대해 완전하지 않습니다
failed.to.found.corresponging.underscore.section=해당하는 밑줄 섹션을 찾을 수 없습니다
could.not.infer.type.of.underscore.section=밑줄 섹션 유형을 추론할 수 없음
no.type.inferred.for.unknown.expression=표현식 유형을 추론할 수 없음

### org/jetbrains/plugins/scala/lang/psi/impl/statements/ScFunctionImpl.scala
both.stub.and.name.identifier.node.are.null={0} 의 스텁 및 이름 식별자 노드 모두 비어 있습니다\n\
{1}
no.defined.return.type=정의된 반환 유형 없음

### org/jetbrains/plugins/scala/lang/psi/impl/statements/ScValueDeclarationImpl.scala
no.type.element.found=''{0}'' 에서 유형 요소를 찾을 수 없음

### org/jetbrains/plugins/scala/lang/psi/impl/statements/ScVariableDefinitionImpl.scala
cannot.infer.type.without.an.expression=표현식 없이 유형을 추론할 수 없음

### org/jetbrains/plugins/scala/lang/psi/impl/statements/params/ScParameterImpl.scala
wrong.stub.problem=잘못된 스텁 문제
wrong.type.element=잘못된 유형 요소 

### org/jetbrains/plugins/scala/lang/psi/impl/toplevel/typedef/ScTypeDefinitionImpl.scala
cannot.resolve.parent.class=상위 클래스를 해결할 수 없음

### org/jetbrains/plugins/scala/lang/psi/light/DummyLightTypeParam.scala
no.containing.file=해당 파일 없음

### org/jetbrains/plugins/scala/lang/psi/types/Compatibility.scala
found.chekced.named.parameter=검사하지 말아야 할 명명 매개변수 발견
assignment.missing.right.side=대입 오른쪽 누락
cannot.handle.compatibility.for={0} 에 대한 호환성을 처리할 수 없음

### org/jetbrains/plugins/scala/lang/psi/types/api/Variance.scala
variance.contravariant=반공변성
variance.covariant=공변성
variance.invariant=무공변성
variance.bivariant=이변적

### org/jetbrains/plugins/scala/lang/psi/types/recursiveUpdate/RecursiveUpdateException.scala
type.mismatch.after.update.method=메소드 업데이트 후 유형 불일치

### org/jetbrains/plugins/scala/lang/psi/types/result/package.scala
no.element.found=요소를 찾을 수 없음

### org/jetbrains/plugins/scala/lang/rearranger/RearrangerUtils.scala
#Rearranger panel
rearranger.panel.keep.scala.style.getters.and.setters.together=cala-style getter 및 setter 함께 유지
rearranger.panel.keep.java.style.getters.and.setters.together=java-style getter 및 setter 함께 유지
rearranger.panel.split.into.unarrangeable.blocks.by.expressions=표현식을 통해 정렬할 수 없는 블록으로 분할
rearranger.panel.split.into.unarrangeable.blocks.by.implicits=implicit으로 정렬할 수 없는 블록으로 분할

### org/jetbrains/plugins/scala/lang/refactoring/changeSignature/ConflictsUtil.scala
by.name.parameters.cannot.be.used=이 메소드는 Java 재정의자를 포함하므로, 값 클래스의 by-name 매개변수를 사용할 수 없습니다.
method.is.overridden.in.composite.kind.in.class=메소드가 {1} 의 복합 {0} 에 재정의되었습니다. 이를 함수 정의로 변환하는 것은 지원되지 않습니다.
method.is.overridden.by.class.parameter.of.class=메소드가 {0} 의 클래스 매개변수에 의해 재정의되었습니다. 이를 함수 정의로 변환하는 것은 지원되지 않습니다.
updating.of.usages.of.generated.unapply=생성된 `unapply` 메소드 사용 위치 업데이트는 지원되지 않습니다

### org/jetbrains/plugins/scala/lang/refactoring/changeSignature/DefaultValuesUsagePanel.scala
default.values=디폴트 값\:
add.to.definition=정의에 추가
modify.method.calls=메소드 호출 수정

### org/jetbrains/plugins/scala/lang/refactoring/changeSignature/ScalaChangeSignatureDialog.scala
change.signature.vararg.should.be.last.in.clause=Vararg 매개변수가 매개변수 절의 마지막에 위치해야 합니다
change.signature.parameters.same.name.{0}=매개변수의 이름이 동일합니다\: {0}
change.signature.add.parameter.clause=매개변수 절 추가
change.signature.remove.parameter.clause=매개변수 절 제거
default.value.is.missing.default.arguments=디폴트 값이 없습니다. 디폴트 인수에 새로운 매개변수 값 대신 공백이 포함됩니다.
default.value.is.missing.method.calls=디폴트 값이 없습니다. 메소드 호출에 새로운 매개변수 값 대신 공백이 포함됩니다.

### org/jetbrains/plugins/scala/lang/refactoring/changeSignature/ScalaChangeSignatureHandler.scala
error.wrong.caret.position.method.name=캐럿이 리팩토링할 메소드 이름에 위치해야 합니다.
change.signature.not.supported.implicit.functions=시그니처 변경은 묵시적 함수에서 지원되지 않습니다
change.signature.not.supported.implicit.parameters=시그니처 변경은 묵시적 매개변수를 가진 함수에서 지원되지 않습니다
change.signature.not.supported.extractors=시그니처 변경은 추출기에서 지원되지 않습니다

### org/jetbrains/plugins/scala/lang/refactoring/changeSignature/ScalaParameterTableModelItem.scala
change.signature.specify.type.for.parameter=매개변수 ''{0}'' 유형 지정
parameter.could.not.be.repeated.and.by.name=매개변수가 by-name이면서 반복될 수 없습니다
could.not.understand.type=유형 {0} 을(를) 이해할 수 없음

### org/jetbrains/plugins/scala/lang/refactoring/extractMethod/ScalaExtractMethodDialog.java
extract.method.title=메소드 추출

### org/jetbrains/plugins/scala/lang/refactoring/extractMethod/ScalaExtractMethodHandler.scala
cannot.extract.used.function.definition=리팩토링이 지원되지 않습니다\: 선택 영역 내 함수 정의가 선택한 조각 외부에서 사용됩니다
extract.method.cannot.find.possible.scope=추출한 메소드의 가능한 범위를 찾을 수 없음
extract.local.method={0} 내 로컬 메소드 추출
extract.method.to.object.name=객체 {0} (으)로 메소드 추출
extract.method.to.class.name=클래스 {0} (으)로 메소드 추출
extract.method.to.trait.name=특성 {0} (으)로 메소드 추출
extract.method.to.anonymous.class=익명 클래스로 메소드 추출
try.block=try 블록
constructor=생성자
case.clause=case 절
if.block=if 블록
def.name=def {0}
extract.local.method.in.else.block=else 블록 내 로컬 메소드 추출
val.name=val {0}
var.name=var {0}
for.statement=구문의 경우
while.statement=while 문
do.statement=do 문
function.expression=함수 표현식
code.block=코드 블록
extract.file.method=파일 메소드 추출
unknown.extraction=알 수 없는 추출
choose.level.for.extract.method=추출 메소드 레벨 선택

### org/jetbrains/plugins/scala/lang/refactoring/extractMethod/duplicates/DuplicatesUtil.scala
process.duplicates=중복 처리

### org/jetbrains/plugins/scala/lang/refactoring/extractTrait/ExtractSuperUtil.scala
choose.class=클래스 선택
cannot.find.package.with.name=다음 이름을 가진 패키지를 찾을 수 없음\: {0}
cannot.find.directory.for.package=다음 패키지 디렉토리를 찾을 수 없음\: {0}
class.already.exists.in.package=패키지 {1} 에 이름이 {0} 인 클래스가 이미 존재합니다

### org/jetbrains/plugins/scala/lang/refactoring/extractTrait/ScalaExtractTraitAction.scala
extract.trait.action.text=특성 추출...
extract.trait.action.description=선택한 클래스에서 특성 추출

### org/jetbrains/plugins/scala/lang/refactoring/extractTrait/ScalaExtractTraitDialog.java
extract.trait.title=특성 추출
extract.trait.top.label.text=다음에서 특성 추출\:
extract.trait.name=특성 이름\:
extract.trait.package.label=새 특성용 패키지\:
members.to.extract=추출할 멤버
extract.abstracts=추상 요소 추출

### org/jetbrains/plugins/scala/lang/refactoring/extractTrait/ScalaExtractTraitHandler.scala
private.member.cannot.be.used.in.extracted.member=private 멤버 {0} 은(는) 추출된 멤버 {1} 에서 사용될 수 없습니다
member.of.anonymous.class.cannot.be.used.in.extracted.member=익명 클래스의 멤버 {0} 은(는) 추출된 멤버 {1} 에서 사용될 수 없습니다
super.reference.used.in.extracted.member=추출된 멤버 {0} 은(는) 상위 클래스 참조를 포함하지만 추출된 특성은 기본 클래스를 포함하지 않습니다
type.parameters.for.self.type.not.supported=추출된 특성이 {0} 을(를) 자체 유형으로 포함하지만 유형 매개변수의 식별은 지원되지 않습니다

### org/jetbrains/plugins/scala/lang/refactoring/inline/ScalaInlineHandler.scala
cannot.inline.different.files=멤버가 다른 파일에 선언되어 있습니다. 인라인화가 지원되지 않습니다.
cannot.inline.used.outside.class=멤버가 해당 클래스 외부에서 사용됩니다. 인라인화가 지원되지 않습니다.
cannot.inline.stable.reference=값이 안정된 참조에서 사용되며 인라인화될 수 없습니다
cannot.inline.never.used=변수가 한 번도 사용되지 않습니다.
cannot.inline.not.simple.pattern=단순 패턴 정의에 대해서만 인라인화가 지원됩니다
cannot.inline.recursive.function=인라인화는 재귀 함수에 대해 지원되지 않습니다
cannot.inline.function.implicit.parameters=인라인화는 묵시적 매개변수를 가진 함수에 대해 지원되지 않습니다
cannot.inline.function.multiple.clauses=인라인화는 다수의 매개변수 절을 가진 함수에 대해 지원되지 않습니다
cannot.inline.function.varargs=인라인화는 vararg 매개변수를 가진 함수에 대해 지원되지 않습니다
cannot.inline.implicit.element=인라인화는 묵시적 요소에 대해 지원되지 않습니다
cannot.inline.special.function=인라인화는 특수 함수에 대해 지원되지 않습니다
cannot.inline.generic.function=인라인화는 제네릭 함수에 대해 지원되지 않습니다
cannot.inline.notsimple.typealias=단순 유형 별칭에 대해서만 인라인화가 지원됩니다
cannot.inline.value.functional.type=함수 유형을 가진 값의 인라인화는 지원되지 않습니다
cannot.inline.function.functional.parameters=함수 매개변수을 가진 함수의 인라인화는 지원되지 않습니다
cannot.inline.parameter=인라인화는 매개변수에 대해 지원되지 않습니다
cannot.inline.not.method.call=정규 메소드 호출에 대해 인라인화가 지원됩니다

### org/jetbrains/plugins/scala/lang/refactoring/introduceField/ScalaIntroduceFieldDialog.java
introduce.field.title=필드 추출

### org/jetbrains/plugins/scala/lang/refactoring/introduceField/ScalaIntroduceFieldFromExpressionHandler.scala
cannot.refactor.not.expression=선택한 문자열을 표현식으로 추출할 수 없습니다
cannot.create.field.from.this.expression=이 표현식에서 필드를 생성할 수 없음
cannot.find.place.for.the.new.field=새 필드 위치를 찾을 수 없음
choose.class.for.introduce.field=필드 삽입용 클래스 선택

### org/jetbrains/plugins/scala/lang/refactoring/introduceParameter/ScalaIntroduceParameterDialog.scala
parameter.label.name=이름\:
parameter.label.type=유형\:
parameter.label.default.value=디폴트 값\:
replace.all.occurrences=모든 사용 위치 교체

### org/jetbrains/plugins/scala/lang/refactoring/introduceParameter/ScalaIntroduceParameterHandler.scala
cannot.refactor.no.function=매개변수 삽입을 위한 함수를 찾을 수 없음
introduce.parameter.title=매개변수 삽입
refactoring.is.not.supported.contains.return=리팩토링이 지원되지 않습니다\: 선택 영역이 return 문을 포함합니다
choose.function.for.refactoring={0} 에 대한 함수 선택

### org/jetbrains/plugins/scala/lang/refactoring/introduceVariable/IntroduceExpressions.scala
introduce.variable.title=값/변수 삽입

### org/jetbrains/plugins/scala/lang/refactoring/introduceVariable/IntroduceTypeAlias.scala
cannot.refactor.not.valid.type=유형 요소가 선택되어야 합니다
cannot.refactor.scope.not.found=적합한 클래스 또는 패키지를 찾을 수 없음
choose.scope.for={0} 범위 선택
introduce.type.alias.title=유형 별칭 삽입

### org/jetbrains/plugins/scala/lang/refactoring/introduceVariable/ScalaInplaceTypeAliasIntroducer.scala
command.introduce.type.alias=유형 별칭 삽입
press.hotkey.to.show.more.options=ctrl + alt + v를 눌러 더 많은 옵션을 가진 대화상자를 표시하십시오

### org/jetbrains/plugins/scala/lang/refactoring/introduceVariable/ScalaInplaceVariableIntroducer.scala
introduce.variable.declare.as.var=변수(&V)
introduce.variable.specify.type.explicitly=유형 지정
introduce.variable.identifier.is.not.valid=식별자가 유효하지 않습니다

### org/jetbrains/plugins/scala/lang/refactoring/introduceVariable/ScalaIntroduceVariableHandler.scala
cannot.refactor.not.expression.nor.type=표현식 또는 유형 요소가 선택되어야 합니다
press.escape.to.remove.the.highlighting=esc 키를 눌러 강조 표시를 제거하십시오

### org/jetbrains/plugins/scala/lang/refactoring/memberPullUp/ScalaPullUpProcessor.scala
pull.up.members.from=다음의 멤버를 위로 이동
class.to.pull.up.members.to.class=멤버를 {0} (으)로 올릴 클래스

### org/jetbrains/plugins/scala/lang/refactoring/move/ScalaMoveClassesOrPackagesHandler.scala
move.to.inner.is.not.supported.title=리팩토링이 지원되지 않습니다
move.to.inner.is.not.supported=내부로 클래스 이동은 Scala에서 지원되지 않습니다
move.with.companion=컴패니언과 함께 이동

### org/jetbrains/plugins/scala/lang/refactoring/move/members/ScalaMoveMemberHandler.scala
target.0.already.contains.definition.of.1=<b>{0}</b> 이(가) 멤버 <b>{1}</b> 의 정의를 이미 포함합니다

### org/jetbrains/plugins/scala/lang/refactoring/move/members/ScalaMoveMembersDialog.scala
move.members.object.name.or.qualified.name.expected=Scala 객체의 이름 또는 정규화된 이름 기대
move.members.cannot.find.object=그러한 이름을 가진 객체를 찾을 수 없음
move.members.source.title=객체 멤버 이동\:
move.members.target.title=객체로\:

### org/jetbrains/plugins/scala/lang/refactoring/move/members/ScalaMoveMembersHandler.scala
move.members.supported.only.stable.objects=안정적 객체 멤버에 대해서만 리팩토링 이동이 지원됩니다
move.members.not.supported.implicits=묵시적 정의에 대해 리팩토링 이동이 지원되지 않습니다
move.members.not.supported.overridden=재정의된 정의에 대해 리팩토링 이동이 지원되지 않습니다
move.members=멤버 이동

### org/jetbrains/plugins/scala/lang/refactoring/rename/RenameScalaClassProcessor.scala
rename.companion.module=컴패니언 {0} 이름 변경

### org/jetbrains/plugins/scala/lang/refactoring/rename/RenameScalaMethodProcessor.scala
rename.getters.and.setters.title=함수가 동일한 이름을 가진 getter 또는 setter를 포함합니다. 이것들의 이름 또한 변경하시겠습니까?

### org/jetbrains/plugins/scala/lang/refactoring/rename/RenameSuperMembersUtil.scala
rename.all.base.members=모든 기본 멤버 이름 변경
rename.base.member=기본 멤버 이름 변경
rename.only.current.member=현재 멤버만 이름 변경
rename.has.multiple.base.members={0} 이(가) 여러 기본 멤버를 포함합니다
rename.only.in={0} {1} 안에서만 이름 변경
name.implements.member.of.qualname={0}이(가) {1}의 멤버를 구현합니다
name.overrides.member.of.qualname={0}이(가) {1}의 멤버를 재정의합니다

### org/jetbrains/plugins/scala/lang/refactoring/rename/inplace/ScalaInplaceRenameHandler.scala
rename.special.method.title=이 메소드의 이름을 변경할 수 없습니다
rename.special.method.rename.class=해당 {0} 이름 변경
rename.cancel=Cancelar
rename.aliased.title=import 별칭 이름 변경은 지원되지 않습니다
rename.aliased.rename.actual=실제 요소 이름 변경

### org/jetbrains/plugins/scala/lang/refactoring/rename/inplace/ScalaMemberInplaceRenamer.scala
rename=이름 변경
could.not.perform.inplace.rename=인플레이스 이름 변경을 수행할 수 없음\:\n\
이름 변경할 요소\: {0} {1}\n\
대체됨\: {2}\n\
캐럿 주위\: {3}

### org/jetbrains/plugins/scala/lang/refactoring/util/ScalaRefactoringUtil.scala
only.for.scala=이는 Scala 파일에서만 작동합니다
cannot.refactor.constr.expression=선택한 블록이 생성자 표현식으로 표시되면 안 됩니다
cannot.refactor.under.generic.call=리팩토링은 제네릭 호출에서 지원되지 않습니다
cannot.refactor.arg.in.self.invocation.of.constructor=리팩토링은 생성자 본문의 자체 호출 인수에 대해 지원되지 않습니다
cannot.refactor.named.arg=리팩토링은 명명된 인수에 대해 지원되지 않습니다
cannot.refactor.literal.pattern=리팩토링은 명명된 인수에 대해 지원되지 않습니다
cannot.refactor.class.parameter.top.level=리팩토링은 최상위 클래스의 매개변수에 대해 지원되지 않습니다
cannot.refactor.interpolated.string.prefix=리팩토링은 보간된 문자열 접두사에 대해 지원되지 않습니다
cannot.refactor.self.invocation=리팩토링은 보조 생성자의 생성자 호출에 대해 지원되지 않습니다
refactoring.is.not.supported.in.guard=가드에서 리팩토링이 지원되지 않으며 코드 구조를 파괴할 가능성이 있습니다
file.is.not.writable=파일은 쓰기 가능한 파일이 아닙니다
cannot.extract.empty.message=리팩토링 영역 선택이 잘못되었습니다. 완전한 표현식 또는 구문의 개수가 필요합니다.
cannot.extract.self.invocation=자체 호출을 추출할 수 없습니다.
cannot.extract.used.type.definition=리팩토링이 지원되지 않습니다\: 선택 영역 내 유형 정의가 선택한 조각 외부에서 사용됩니다
choose.expression.for={0} 에 대한 표현식 선택
choose.type.element.for={0} 에 대한 유형 요소 선택

### org/jetbrains/plugins/scala/lang/refactoring/util/ScalaTypeValidator.scala
introduced.typeAlias.will.conflict.with.type.name=삽입한 유형 별칭이 유형 이름과 충돌합니다\: {0}
introduced.typeAlias.will.conflict.with.class.name=삽입한 유형 별칭이 클래스 이름과 충돌합니다\: {0}

### org/jetbrains/plugins/scala/lang/refactoring/util/ScalaVariableValidator.scala
introduced.variable.will.conflict.with.local=삽입된 변수가 지역 변수와 충돌합니다(또는 지역 변수에 의해 숨겨집니다)\: {0}
introduced.variable.will.conflict.with.parameter=삽입된 변수가 매개변수와 충돌합니다(또는 매개변수에 의해 숨겨집니다)\: {0}
introduced.variable.will.conflict.with.field=삽입된 변수가 매개변수가 없는 필드 또는 메소드와 충돌합니다(또는 그것들에 의해 숨겨집니다)\: {0}
introduced.variable.will.conflict.with.class.parameter=삽입된 변수가 클래스 매개변수와 충돌합니다(또는 이에 의해 숨겨집니다)\: {0}

### org/jetbrains/plugins/scala/lang/resolve/processor/MethodResolveProcessor.scala
not.all.type.parameters.are.defined=유형 매개변수의 일부만 정의되었습니다. typeargs\=[{0}] 및 classTypeParams\=[{1}]

### org/jetbrains/plugins/scala/lang/scaladoc/generate/ScaladocAction.scala
generate.scaladoc=Scaladoc 생성
generate.scaladoc.action.text=Scaladoc 생성
generate.scaladoc.action.description=Scaladoc 생성

### org/jetbrains/plugins/scala/lang/scaladoc/parser/parsing/MyScaladocParsing.scala
scaladoc.parsing.open.syntax.element=구문 요소 열기
scaladoc.parsing.closing.link.tag.before.opening=열기 전 링크 태그 닫기
scaladoc.parsing.closing.code.tag.before.opening=열기 전 코드 태그 닫기
scaladoc.parsing.error.bad.token=오류\: 잘못된 토큰\: {0}
scaladoc.parsing.header.closed.by.opening.new.one=새 요소 열기에 의해 닫힌 헤더
scaladoc.parsing.wiki.syntax.element.closed.by.message={0} 에 의해 닫힌 Wiki 구문 요소
scaladoc.parsing.wiki.syntax.closed.by.new.paragraph=새 단락
scaladoc.parsing.wiki.syntax.closed.by.tag=태그
scaladoc.parsing.wiki.syntax.closed.by.inner.code.tag=내부 코드 태그
scaladoc.parsing.closing.link.element.before.opening.one=새 요소 열기 전 링크 요소 닫기
scaladoc.parsing.cross.tags=크로스 태그
scaladoc.parsing.no.closing.element=요소 닫기 없음
scaladoc.parsing.unclosed.code.tag=닫히지 않은 코드 태그
scaladoc.parsing.unexpected.end.of.tag.body=예기치 않은 태그 본문 끝
scaladoc.parsing.inline.tag=태그 인라인화
scaladoc.parsing.missing.tag.param=태그 매개변수 누락
scaladoc.parsing.unknown.tag=알 수 없는 태그\: {0}

### org/jetbrains/plugins/scala/lang/surroundWith/surrounders/scaladoc/ScalaDocWithBoldSurrounder.scala
bold.surrounder.template.description=굵게\: '''' ''''

### org/jetbrains/plugins/scala/lang/surroundWith/surrounders/scaladoc/ScalaDocWithItalicSurrounder.scala
italic.surrounder.template.description=기울임꼴\: ' '

### org/jetbrains/plugins/scala/lang/surroundWith/surrounders/scaladoc/ScalaDocWithMonospaceSurrounder.scala
monospace.surrounder.template.description=고정폭\: ` `

### org/jetbrains/plugins/scala/lang/surroundWith/surrounders/scaladoc/ScalaDocWithSubscriptSurrounder.scala
subscript.surrounder.template.description=아래 첨자\: ,, ,,

### org/jetbrains/plugins/scala/lang/surroundWith/surrounders/scaladoc/ScalaDocWithSuperscriptSurrounder.scala
superscript.surrounder.template.description=위 첨자\: ^ ^

### org/jetbrains/plugins/scala/lang/surroundWith/surrounders/scaladoc/ScalaDocWithUnderlinedSurrounder.scala
underline.surrounder.template.description=밑줄\: __ __

### org/jetbrains/plugins/scala/lang/transformation/DesugarCodeAction.scala
desugar.scala.code.in.scope=Scala 코드 ({0}) 디슈가링
scope.selection=선택 항목
scope.file=파일
desugar.scala.code.action.text=Scala 코드 디슈가링...
desugar.scala.code.action.description=Scala 코드 디슈가링 (선택 영역/파일 전체)

### org/jetbrains/plugins/scala/lang/transformation/SelectionDialog.scala
column.enabled=사용
column.transformation=변환

### org/jetbrains/plugins/scala/overrideImplement/ScalaMemberChooser.scala
specify.return.type.explicitly=유형 지정(&T)
add.override.modifier="override" 삽입(&O)
copy.scaladoc=ScalaDoc 복사(&S)

### org/jetbrains/plugins/scala/overrideImplement/ScalaOIUtil.scala
select.method.override=재정의할 멤버 선택
select.method.implement=구현할 멤버 선택
action.implement.method=메소드 구현
action.override.method=메소드 재정의

### org/jetbrains/plugins/scala/project/CompileOrderDescriptions.scala
compile.order.mixed=혼합
compile.order.java.then.scala=Java 다음 Scala
compile.order.scala.then.java=Scala 다음 Java

### org/jetbrains/plugins/scala/project/DebuggingInfoLevelDescription.scala
debug.info.level.none=없음
debug.info.level.source=소스 파일 속성
debug.info.level.source.and.line.number=소스 및 줄 번호 정보
debug.info.level.source.line.number.and.local.variable=소스, 줄 번호 및 지역 변수 정보
debug.info.level.complete.no.tail.call.optimization=완전함, 테일 호출 최적화 없음

### org/jetbrains/plugins/scala/project/Versions.scala
title.fetching.available.this.versions=사용 가능한 {0} 버전 가져오는 중

### org/jetbrains/plugins/scala/project/converter/ScalaProjectConverterProvider.scala
scala.facets.will.be.converted.to.scala.sdks=Scala 패싯이 Scala SDK로 변환됩니다

### org/jetbrains/plugins/scala/project/notification/AbstractNotificationProvider.scala
setup.kittitle={0} 설정

### org/jetbrains/plugins/scala/project/notification/SetupJdkNotificationProvider.scala
project.jdk.is.not.defined=프로젝트 JDK가 정의되지 않았습니다

### org/jetbrains/plugins/scala/project/notification/SetupScalaSdkNotificationProvider.scala
sdk.title=Scala SDK

### org/jetbrains/plugins/scala/project/notification/source/AttachSourcesUtil.java
module.libraries.attach.sources.immediately.button=소스 연결...
multiple.libraries.contain.file="여러 라이브러리가 파일을 포함합니다.<br>소스를 연결할 라이브러리를 선택하십시오."

### org/jetbrains/plugins/scala/project/notification/source/ScalaAttachSourcesNotificationProvider.scala
library.sources.not.found=소스를 찾을 수 없음
library.sources.not.attached=소스를 찾을 수 없음
cannot.find.library.for={0} 에 대한 라이브러리를 찾을 수 없음
cannot.find.library.error.title=Error

### org/jetbrains/plugins/scala/project/sdkdetect/ScalaSdkProvider.scala
sdk.scan.title=Scala SDK 위치 찾는 중\: {0}

### org/jetbrains/plugins/scala/project/settings/ScalaCompilerConfigurable.scala
scala.compiler=Scala 컴파일러

### org/jetbrains/plugins/scala/project/settings/ScalaCompilerConfigurationPanel.form
#Scala compiler settings UI
incrementality.type=증분 요소(&I)\:

### org/jetbrains/plugins/scala/project/settings/ScalaCompilerProfilesPanel.scala
scala.compiler.profiles.panel.profile.name=프로파일 이름
scala.compiler.profiles.panel.move.to=다음으로 이동
scala.compiler.profiles.panel.create.new.profile=새 프로파일 생성
scala.compiler.profiles.panel.profile.should.not.be.empty=프로파일 이름은 공백일 수 없습니다
scala.compiler.profiles.panel.profile.already.exists=프로파일 {0} 이(가) 이미 존재합니다

### org/jetbrains/plugins/scala/project/settings/ScalaCompilerSettingsPanel.form
unchecked.warnings=확인되지 않은 경고(&U)
unchecked.warnings.tooltip=생성된 코드에서 추가 경고 활성화는 가정에 따라 달라집니다.
deprecation.warnings=사용 중단 경로(&D)
deprecation.warnings.tooltip=경고 및 사용 중단된 API 사용 위치 전송
feature.dynamics=동적 요소(&D)
feature.existential.types=존재 유형(&E)
explain.type.errors=유형 오류 설명(&E)
explain.type.errors.tooltip=유형 오류 자세히 설명
feature.warnings=기능 경고(&F)
feature.warnings.tooltip=언어 기능 경고를 전송합니다.
feature.higher.kinded.types=상류 유형(&E)
feature.implicit.conversions=묵시적 변환(&I)
feature.macros=매크로(&M)
optimise.bytecode=바이트 코스 최적화(신중히 사용*)(&O)
optimise.bytecode.tooltip=프로그램에 최적화를 적용하여 더 빠른 바이트 코드를 생성하십시오. 다양한 컴파일 문제가 발생할 수 있습니다. 신중히 사용하십시오.
feature.postfix.notation=접두사 연산자 사용(&P)
feature.reflective.calls=리플렉티브 호출(&R)
additional.compiler.options=추가 컴파일러 옵션(&O)\:
compile.order=컴파일 순서(&O)\:
compiler.plugins=컴파일러 플러그인
debugging.info.level=디버그 정보 레벨(&L)\:
feature.experimental.features=실험적 기능(&X)
enable.continuations=연속 활성화(&C)
enable.specialization=구체화 활성화(&S)
enable.specialization.tooltip=@specialize 어노테이션 준수
enable.warnings=경고 활성화(&W)
enable.warnings.tooltip=경고 생성
features=기능세부
options=옵션

### org/jetbrains/plugins/scala/project/template/ScalaFilesChooserDescriptor.scala
title.scala.sdk.files=Scala SDK 파일
choose.either.a.scala.sdk.directory.or.scala.jar.files=Scala SDK 디렉토리 또는 Scala jar 파일 중 하나를 선택하십시오(허용\: 바이너리, 소스, 문서)

### org/jetbrains/plugins/scala/project/template/ScalaProjectTemplate.scala
idea.based.scala.project=IDEA 기반 Scala 프로젝트
module.with.a.scala.sdk=Scala SDK를 포함하는 모듈

### org/jetbrains/plugins/scala/project/template/SdkSelectionDialog.java
sdk.create.select.files=새 Scala SDK용 JAR 선택
sdk.create.missing.version=Ivy 저장소에 Scala 버전 {0}이(가) 없습니다

### org/jetbrains/plugins/scala/project/template/SdkTableModel.scala
sdk.table.model.location=위치
sdk.table.model.version=버전
sdk.table.model.sources=소스
sdk.table.model.docs=문서

### org/jetbrains/plugins/scala/project/template/VersionDialog.scala
title.download=Descargar
title.error.downloading.scala.libraries=Scala 라이브러리 라운로드 오류
no.versions.available.for.download=다운로드 가능한 버전 없음
downloading.scala.version=Scala {0} 다운로드 중
error.downloading.scala.version=Scala {0} 다운로드 오류

### org/jetbrains/plugins/scala/settings/ScalaEditorSmartKeysConfigurable.scala
insert.pair.multiline.quotes=다중 중 문자열에 쌍따옴표 삽입
wrap.single.expression.body='{' 입력 후 닫는 중괄호를 가진 단일 표현식 본문 줄 바꿈
upgrade.to.interpolated=Upgrade simple string into interpolated after typing '${'
insert.block.braces.automatically.based.on.indentation=Add braces automatically
remove.block.braces.automatically.based.on.indentation=Remove braces automatically
control.curly.braces.based.on.line.indents=Control curly braces based on line indentation\:

### org/jetbrains/plugins/scala/settings/ScalaProjectSettingsPanel.form
scala.project.settings.form.tabs.editor=에디터
scala.project.settings.form.tabs.project.view=프로젝트 뷰
scala.project.settings.form.tabs.performance=성능
scala.project.settings.form.tabs.worksheet=워크시트
scala.project.settings.form.tabs.base.packages=기본 패키지
scala.project.settings.form.tabs.misc=Otros
scala.project.settings.form.tabs.updates=업데이트
scala.project.settings.form.tabs.extensions=확장
scala.project.settings.form.collection.type.highlighting.option=컬렉션 유형 강조 표시\:
scala.project.settings.form.sbt.index.ivy2.mode=로컬 ivy2 캐시 색인화 모드
scala.project.settings.form.sbt.index.ivy2.mode.hint=비활성화됨 - 완료된 색인화 없음\n\
메타데이터 - 라이브러리 이름 및 버전만 색인화, SBT 파일 의존 요소 코드 완성에 사용됨\n\
클래스 - 캐시에 클래스 이름 색인화,  "SBT 의존 요소 추가" 빠른 수정에 사용됨
scala.project.settings.form.scala.meta.settings.annot212=scala.meta 프로그램 실챙
scala.project.settings.form.scala.meta.settings.annot212.tooltip=2진 호환성 때문에 2.12 모듈의 어노테이션이 매우 느린 문자열 기반의 직렬화 및 재파싱을 사용해야 합니다. 이는 전반적인 성능에 심각하게 영향을 미칠 수 있습니다.
scala.project.settings.form.scala.meta.settings.modeOptions.tooltip=활성화됨 - 유형 추론 도중 메타프로그램이 실행됩니다\n\
비활성화됨 - \\  유형 추론 도중 메타프로그램을 건너뜁니다\n\
수동 - 수동으로 확장된 경우에만 메타프로그램이 실행됩니다
scala.project.settings.form.scala.meta.settings.trimBodies.caption=Trim 메소드 본문이 scala.meta에 의해 확장됩니다
scala.project.settings.form.scala.meta.settings.trimBodies.tooltip=생성된 메소드의 명시적 반환 유형에 의존합니다(본문이 ???로 교체됩니다). 메소드 본문 유형 검사를 건너뛰어 유형 추론 속도를 높입니다.
scala.project.settings.form.show.type.info.on.mouse.hover=마우스 오버 시 일정 시간 후 유형 정보 표시, ms
scala.project.settings.form.highlighting=강조 표시
scala.project.settings.form.highlight.implicit.conversions=묵시적 변환 강조 표시
scala.project.settings.form.show.hints.if.no.implicit.arguments.found=묵시적 인수를 찾을 수 없는 경우 힌트 표시
scala.project.settings.form.show.hints.if.ambiguous.implicit.arguments.found=Show hints if ambiguous implicit arguments found
scala.project.settings.form.highlight.arguments.to.by.name.parameters=by-name 매개변수 인수 강조 표시
scala.project.settings.form.include.block.expressions=블록 표현식 포함
scala.project.settings.form.include.literals=리터럴 포함
scala.project.settings.form.custom.scalatest.keywords.highlighting=사용자 정의 scalaTest 키워드 강조 표시
scala.project.settings.form.autocomplete=자동 완성
scala.project.settings.form.ahead.of.time.completion=AOT 코드 완성(매개변수 및 변수 이름 지정)
scala.project.settings.form.use.scala.classes.priority.over.java=Java 클래스보다 Scala 클래스 우선 사용
scala.project.settings.form.code.conversion=코드 변환
scala.project.settings.form.convert.java.code.to.scala.on.copy.paste=복사-붙여넣기 시 Java 코드를 Scala로 변환
scala.project.settings.form.automatically.convert.to.scala.code.without.dialog=붙여넣기 시 대화상자 표시 안 함, Scala 코드로 자동 변환
scala.project.settings.form.add.override.keyword.to.method.implementation=메소드 구현에 재정의 키워드 추가
scala.project.settings.form.group.package.object.with.package=패키지 객체를 패키지와 그룹화(&G)
scala.project.settings.form.highlight.nodes.with.errors=오류가 있는 노드 강조 표시(&H)
scala.project.settings.form.implicit.parameters.search.depth=묵시적 매개변수 검색 깊이 (아무것도 없는 경우 -1)\:
scala.project.settings.form.search.all.symbols=모든 심볼(로컬 심볼 포함) 검색
scala.project.settings.form.resolve.to.all.classes.even.in.wrong.directories=모든 클래스로 해결, 잘못된 디렉토리 내 클래스까지 포함(이는 성능 문제를 야기할 수 있습니다)
scala.project.settings.form.disable.parsing.of.documentation.comments=문서 주석 파싱을 비활성화합니다. 이는 매우 큰 파일에 대해 에디터 성능을 향상시킬 수 있습니다. (SCL-2900)
scala.project.settings.form.disable.language.injection.in.scala.files=Scala 파일 내 언어 삽입 비활성화 (삽입된 언어는 자동 팝업 코드 완성 기능으로 입력을 중지시킬 수 있습니다)
scala.project.settings.form.dont.cache.compound.types=복합 유형 캐시 안 함(GC에서 심한 멈춤 현상이 발생하는 경우 사용하십시오)
scala.project.settings.form.treat.sc.files.as=.sc 파일을 다음으로 처리\:
scala.project.settings.form.output.cutoff.limit=출력 컷오프 제한, 줄\:
scala.project.settings.form.run.worksheet.in.the.compiler.process=컴파일러 프로세스에서 워크시트 실행(일반 모드만 해당)
scala.project.settings.form.use.eclipse.compatibility.mode="eclipse 호환성" 모드 사용
scala.project.settings.form.treat.scala.scratch.files.as.worksheet.files=Scala 스크래치 파일을 워크시트 파일로 처리
scala.project.settings.form.collapse.long.output.by.default=디폴트로 긴 출력 접기
scala.project.settings.form.delay.before.auto.run=자동 실행 전 지연
scala.project.settings.form.scalatest.default.super.class=ScalaTest 디폴트 상위 클래스\:
scala.project.settings.form.trailing.commas=후행 쉼표\:
scala.project.settings.form.plugin.update.channel=채널 업데이트\:
scala.project.settings.form.check.for.updates=지금 확인
scala.project.settings.form.info=언제든지 "안정화된 릴리스" 또는 "얼리 액세스 프로그램"을 선택하여 더 안정적인 빌드로 돌아갈 수 있습니다

### org/jetbrains/plugins/scala/settings/ScalaProjectSettingsPanel.java
scala.collection.highlighting.type.none=없음
scala.collection.highlighting.type.only.non.qualified=정규화되지 않은 항목만
scala.collection.highlighting.type.all=모두
scala.plugin.chanel.nightly=야간 빌드
scala.plugin.chanel.eap=얼리 액세스 프로그램
scala.plugin.chanel.release=안정화된 릴리스
scala.meta.mode.enabled=사용
scala.meta.mode.disabled=사용 안함
scala.meta.mode.manual=Manual
ivy2.indexing.mode.disabled=사용 안함
ivy2.indexing.mode.metadata=메타데이터
ivy2.indexing.mode.classes=클래스
trailing.commas.mode.enabled=사용
trailing.commas.mode.disabled=사용 안함
trailing.commas.mode.auto=자동
script.file.mode.always.worksheet=항상 워크시트
script.file.mode.ammonite.in.test.sources.otherwise.worksheet=테스트 소스에서 Ammonite, 그 외의 경우 워크시트
script.file.mode.always.ammonite=항상 Ammonite

### org/jetbrains/plugins/scala/testDiscovery/actions/ScalaShowAffectedTestsAction.java
show.affected.tests.action.text=영향을 받는 테스트 표시(Scala)
show.affected.tests.action.description=영향을 받는 테스트 표시(Scala)

### org/jetbrains/plugins/scala/testingSupport/test/AbstractTestRunConfiguration.scala
test.run.config.module.is.not.specified=모듈이 지정되지 않았습니다
test.run.config.multiple.suite.traits.detected=여러 도구 특성이 탐지됨\: {0}
test.framework.is.not.specified={0} 이(가) 지정되지 않았습니다

### org/jetbrains/plugins/scala/testingSupport/test/MyInheritorChooser.scala
test.config.choose.executable.classes.to.run.test={0} 을(를) 실행할 실행 파일 클래스 선택

### org/jetbrains/plugins/scala/testingSupport/test/scalatest/ScalaTestConfigurationProducer.scala
test.in.scope.scalatest.presentable.text=''{0}'' 내 ScalaTests

### org/jetbrains/plugins/scala/testingSupport/test/scalatest/ScalaTestConfigurationType.scala
scalatest.config.display.name=ScalaTest
scalatest.config.description=ScalaTest 테스트 프레임 워크 실행 구성

### org/jetbrains/plugins/scala/testingSupport/test/specs2/Specs2ConfigurationProducer.scala
test.in.scope.specs2.presentable.text=''{0}'' 내 Specs2

### org/jetbrains/plugins/scala/testingSupport/test/specs2/Specs2ConfigurationType.scala
specs2.config.display.name=Specs2
specs2.config.description=Specs2 테스트 프레임 워크 실행 구성

### org/jetbrains/plugins/scala/testingSupport/test/structureView/TestNodeProvider.scala
test.node.provider.show.scala.tests=Scala 테스트 표시

### org/jetbrains/plugins/scala/testingSupport/test/testdata/AllInPackageTestData.scala
test.run.config.test.package.not.found=테스트 패키지를 찾을 수 없습니다. {0}
test.config.package.does.not.exist=패키지가 존재하지 않습니다
test.config.can.nott.run.while.indexing.no.class.names.memorized.from.previous.iterations=색인화 도중 실행할 수 없음\: 이전 반복 시 기억된 클래스 이름 없음
test.config.did.not.find.suite.classes.in.package=패키지 {0} 내 Suite 클래스를 찾을 수 없음

### org/jetbrains/plugins/scala/testingSupport/test/testdata/ClassTestData.scala
test.run.config.test.class.not.found=테스트 클래스를 찾을 수 없음\: {0}
test.config.test.class.is.not.specified=테스트 클래스가 지정되지 않았습니다
test.config.test.class.not.found.in.module=모듈 ''{1}'' 에서 테스트 클래스 ''{0}'' 을(를) 찾을 수 없음
test.config.no.suite.class.is.found.for.class.in.module=모듈 ''{1}'' 에서 클래스 ''{0}'' 에 대한 Suite 클래스를 찾을 수 없음
test.config.class.is.not.inheritor.of.suite.trait=클래스 ''{0}'' 이(가) Suite 특성의 상속자가 아닙니다
test.config.clazz.is.not.a.valid.test.suite={0} 이(가) 유효한 테스트 도구가 아닙니다

### org/jetbrains/plugins/scala/testingSupport/test/testdata/RegexpTestData.scala
test.config.failed.to.compile.pattern=패턴 {0} 컴파일 실패
test.config.no.patterns.detected=탐지된 패턴 없음
test.config.cant.run.while.indexing.no.class.names.memorized.from.previous.iterations=색인화 도중 실행할 수 없음\: 이전 반복 시 기억된 클래스 이름 없음

### org/jetbrains/plugins/scala/testingSupport/test/testdata/SingleTestData.scala
test.config.test.name.is.not.specified=테스트 이름이 지정되지 않았습니다
test.config.multiple.classes.specified.for.single.test.run=단일 테스트 실행에 대해 여러 클래스가 지정됨

### org/jetbrains/plugins/scala/testingSupport/test/ui/RegexpPanel.scala
test.run.config.for.class.pattern=클래스 패턴
test.run.config.test.pattern=테스트 패턴

### org/jetbrains/plugins/scala/testingSupport/test/ui/ScalaTestRunLineMarkerProvider.scala
scalatest.gutter.run.test=테스트 실행

### org/jetbrains/plugins/scala/testingSupport/test/ui/TestRunConfigurationForm.scala
test.run.config.test.kind=테스트 종류(&T)\:
test.run.config.test.class=테스트 클래스(&C)\:
test.run.config.test.name=테스트 이름(&N)\:
test.run.config.regular.expressions=정규식(&X)\:
test.run.config.test.package=테스트 패키지(&G)\:
test.run.config.search.for.tests=테스트 검색\:
test.run.config.use.sbt=SBT 사용(&T)
test.run.config.use.ui.with.sbt=SBT와 함께 UI 사용
test.run.config.print.information.messages.to.console=콘솔에 정보 메시지 출력(&P)
test.run.config.choose.test.class=테스트 클래스 선택
test.run.config.test.kind.all.in.package=패키지 내 전체
test.run.config.test.kind.class=클래스
test.run.config.test.kind.test.name=테스트 이름
test.run.config.test.kind.regular.expression=정규 표현식
test.run.config.search.scope.in.whole.project=전체 프로젝트에서
test.run.config.search.scope.in.single.module=단일 모듈에서
test.run.config.search.scope.across.module.dependencies=모듈 종속 요소 전체

### org/jetbrains/plugins/scala/testingSupport/test/utest/UTestConfigurationProducer.scala
test.in.scope.utest.presentable.text=''{0}'' 내 UTests

### org/jetbrains/plugins/scala/testingSupport/test/utest/UTestConfigurationType.scala
utest.config.display.name=utest
utest.config.description=utest 테스트 프레임 워크 실행 구성

### org/jetbrains/plugins/scala/util/NotificationUtil.scala
default.notification.title=경고

### org/jetbrains/plugins/scala/worksheet/actions/CreateLightWorksheetAction.scala
create.light.scala.worksheet.menu.action.text=Light Scala 워크시트 생성
create.light.scala.worksheet.menu.action.description=Light Scala 워크시트 생성

### org/jetbrains/plugins/scala/worksheet/actions/NewScalaWorksheetAction.scala
new.scalaworksheet.menu.action.text=Scala 워크시트
new.scalaworksheet.menu.action.description=새 Scala 워크시트 생성

### org/jetbrains/plugins/scala/worksheet/actions/topmenu/CleanWorksheetAction.scala
worksheet.clear.button=결과 클리어
clean.scala.worksheet.action.text=Scala 워크시트 삭제
clean.scala.worksheet.action.description=Scala 워크시트 삭제

### org/jetbrains/plugins/scala/worksheet/actions/topmenu/CopyWorksheetAction.scala
worksheet.copy.button=워크시트 복사
copy.scala.worksheet.action.text=Scala 워크시트 복사
copy.scala.worksheet.action.description=Scala 워크시트 복사

### org/jetbrains/plugins/scala/worksheet/actions/topmenu/RunWorksheetAction.scala
worksheet.execute.button=워크시트 평가
run.scala.worksheet.action.text=Scala 워크시트 실행
run.scala.worksheet.action.description=Scala 워크시트 실행

### org/jetbrains/plugins/scala/worksheet/actions/topmenu/ShowWorksheetSettingsAction.scala
worksheet.settings.button=워크시트 설정 표시

### org/jetbrains/plugins/scala/worksheet/actions/topmenu/StopWorksheetAction.scala
worksheet.stop.button=워크시트 실행 중지

### org/jetbrains/plugins/scala/worksheet/ammonite/AmmoniteGotoHandler.scala
ammonite.goto=이동

### org/jetbrains/plugins/scala/worksheet/ammonite/AmmoniteScriptWrappersHolder.scala
notification.title.ammonite.imports.found=Ammonite import 문 발견
ammonite.import.ivy.dependencies.message=<html><body>{0}에서 선언된 모든 $ivy 종속 요소(로컬 캐시에 있음)를 <a href\="ftp\://run">가져오시겠어요</a>? <a href\="ftp\://disable">무시</a></body></html>

### org/jetbrains/plugins/scala/worksheet/ammonite/AmmoniteUnresolvedLibraryInspection.scala
ammonite.cannot.resolve.import=가져오기를 해결할 수 없음
display.name.unresolved.ivy.import=해결되지 않은 Ivy 가져오기

### org/jetbrains/plugins/scala/worksheet/ammonite/CreateImportedLibraryQuickFix.scala
ammonite.create.library.from.jar=jar에서 라이브러리 생성...

### org/jetbrains/plugins/scala/worksheet/ammonite/ImportAmmoniteDependenciesFix.scala
ammonite.loading.list.of.versions=Ammonite\: 버전 목록 로드 중...
ammonite.extracting.info.from.sbt=Ammonite\: SBT에서 정보 추출 중...
ammonite.adding.dependencies.title=종속 요소 추가 중
ammonite.adding.dependencies.progress=Ammonite\: 종속 요소 추가 중...
add.a.all.ammonite.deps.to.project=<html><body><p>모든 Ammonite 표준 종속 요소를 프로젝트에 <a href\="ftp\://run">추가하시겠어요</a>? <a href\="ftp\://disable">무시</a></p></body></html>

### org/jetbrains/plugins/scala/worksheet/ammonite/runconfiguration/AmmoniteRunConfiguration.scala
ammonite.config.select=선택...
ammonite.script=스크립트\:
ammonite.executable=Amm 실행 파일\:
ammonite.script.parameters=스크립트 매개변수\:

### org/jetbrains/plugins/scala/worksheet/ammonite/runconfiguration/AmmoniteRunConfigurationType.scala
ammonite.config.display.name=Ammonite
ammonite.config.run.ammonite.script=Ammonite 스크립트 실행

### org/jetbrains/plugins/scala/worksheet/ammonite/runconfiguration/AmmoniteRunScriptAction.scala
ammonite.run.script=스크립트 실행...

### org/jetbrains/plugins/scala/worksheet/processor/WorksheetCompiler.scala
worksheet.compilation=워크시트 {0} 컴파일

### org/jetbrains/plugins/scala/worksheet/processor/WorksheetCompilerErrorReporter.scala
worksheet.configuration.errors.base=워크시트 구성 오류
worksheet.configuration.errors.repl.is.available.only.in.compile.server.process=컴파일 서버 프로세스에서 REPL 모드의 워크시트만 실행할 수 있습니다
worksheet.configuration.errors.project.indexing.not.finished=프로젝트 색인 생성이 완료되지 않았습니다
worksheet.configuration.errors.enable.compile.server=컴파일 서버 활성화
worksheet.configuration.errors.configure.compile.server=컴파일 서버 구성
compile.server.is.not.running=컴파일 서버가 실행 중이 아닙니다

### org/jetbrains/plugins/scala/worksheet/ui/dialog/ShowCompilerProfileSettingsButton.scala
worksheet.show.compiler.profiles.settings=컴파일러 프로파일 설정 표시

### org/jetbrains/plugins/scala/worksheet/ui/dialog/WorksheetAllSettingsPanel.scala
worksheet.settings.panel.settings.for.module={0} 설정
worksheet.settings.panel.default.settings=디폴트 설정

### org/jetbrains/plugins/scala/worksheet/ui/dialog/WorksheetFileSettingsDialog.scala
worksheet.settings.panel.title=워크시트 설정

### org/jetbrains/plugins/scala/worksheet/ui/dialog/WorksheetSettingsSetForm.form
worksheet.settings.panel.change.make.button=실행 전 프로젝트 만들기
worksheet.settings.panel.interactive.mode=대화형 모드
worksheet.settings.panel.run.type=실행 유형\:
worksheet.settings.panel.use.class.path.of.module=모듈의 클래스 경로 사용\:
worksheet.settings.panel.compiler.profile=컴파일러 프로파일\:

### org/jetbrains/plugins/scala/worksheet/ui/dialog/WorksheetSettingsSetForm.java
worksheet.settings.panel.using.class.path.of.the.module=모듈의 클래스 경로 사용 중...

### org/jetbrains/plugins/scala/worksheet/ui/printers/WorksheetEditorPrinterBase.scala
worksheet.internal.error=예기치 못한 예외로 인해 워크시트를 평가할 수 없습니다

### org/jetbrains/plugins/scala/worksheet/ui/printers/WorksheetEditorPrinterFactory.scala
worksheet.printers.output.exceeds.cutoff.limit=출력이 컷오프 제한을 초과합니다.

### <unused>
conversion.is.not.available.in.it.s.own.definition=변환 정의 안에서 변환을 사용할 수 없습니다
element.has.incompatible.type.parameter.bounds.for.type={0} 이(가) {1} 에서 호환되지 않는 유형 매개변수 바운드를 포함합니다
type.does.not.conform.to.type={0} 이(가) {1} 을(를) 준수하지 않습니다
import.implicitInstance.chooser.title=가져올 묵시적 인스턴스 선택
family.name.search.implicit.instances=묵시적 인스턴스 검색
search.implicit.instances.for={0} 에 대한 묵시적 인스턴스 검색
choose.type.to.search=검색할 유형 선택
applicable.implicits.not.found=적용 가능한 묵시적 항목을 찾을 수 없습니다
test.run.config.choose.working.directory=작업 디렉토리 선택
sdk.build.title=SDK 빌드 중
statement.expected=블록 구문 기대
star.expected='*' 예상
case.clauses.or.qualified.reference.expected=case 절 또는 정규화된 참조 기대
annotation.expected=어노테이션 기대
simple.type.expected.requires=requires 블록 내 단순 유형 기대
type.dcl.expected=유형 선언 기대
block.expected=블록 기대
type.tale.expected=Type keyword expected in simple type tale
refined.type.expected=개선된 유형 기대
this.expected='this' 키워드 기대
arg.expr.expected=인수 표현식 기대
# TODO unify type mismatch messages
expr.type.does.not.conform=표현식 내 {0} 유형이 값이 선언된 유형을 준수하지 않습니다
# TODO unify type mismatch messages
patt.type.does.not.conform.expr.type=패턴 {0} 의 기대 유형이 포현식 유형 {1} 을(를) 준수하지 않습니다
title.cache.updating=캐시 업데이트 중
title.cache.creating=캐시 생성 중
title.cache.files.scanning=파일 검사 중...
title.cache.files.parsing=새 파일 파싱 중...
title.please.wait=기다려주세요
title.cache.saving=캐시 저장 중
title.cache.datafile.loading=캐시 로드 중
title.cache.files.removing=오래된 캐시 제거 중
title.cache.loading=캐시 로드 중
error.report.to.jetbrains.action=JetBrains에 보고하기
error.report.submit.label=<html>이 오류 보고서는 <b>구성 요소 <b>''{3}''</b>로<br><a href\="{1}{2}">{1}{2}</a></b> 에서<br>새 <b>JIRA</b> 이슈 <br><b>''{0}''</b><br>로 생성됩니다.<br><br>오류 및 재현 방법에 대한 짧은 설명을 제공하십시오.</html>
error.report.submit.register.in.jira=<html><a href\="{0}">계정 가입</a></html>
error.report.submit.new.issue.url=<html>이슈가 성공적으로 추가되었습니다.<br>     <a href\="{0}">{0}</a>를 참조하십시오</html>
error.report.submit.new.issue.title=이슈 추가됨
error.report.wrong.login=유효하지 않은 사용자 이름 또는 비밀번호,
error.report.canceled=보고서 전송이 취소됨
error.report.error.creating.issue=새 Jira 이슈 생성 오류
error.report.jira.issue=JetScala 이슈 \#{0}
error.report.dialog.title=오류 제출
error.report.dialog.wrong.password.title=전송 실패
error.report.button.sendreport.caption=보고서 전송(&S)
error.report.button.cancel.caption=&Cancelar
error.report.form.not.jira=JIRA 계정이 없으므로 'JetScala 오류 보고자'를 대신해 이슈를 생성합니다(&I)
error.report.form.jira=JIRA 사용자입니다(&J)
error.report.form.jira.login=로그인(&L)
error.report.form.jira.password=비밀번호(&P)
error.report.form.jira.password.save=비밀번호 저장
repetitive.method.name.signature=반복적 메소드 이름/시그니처
repetitive.method.name.signature.and.return.type=반복적 메소드 이름, 시그니처 및 반환 유형
illegal.combination.of.modifiers=제어자 조합이 올바르지 않습니다
modifier.is.not.allowed.here.0=제어자 ''{0}'' 은(는) 여기에서 허용되지 않습니다
illegal.combination.of.modifiers.abstract.and.final=제어자 'abstract' 및 'final'의 조합이 올바르지 않습니다
modifier.volatile.not.allowed.here=제어자 'volatile'은 여기에서 허용되지 않습니다
modifier.transient.not.allowed.here=제어자 'transient'는 여기에서 허용되지 않습니다
intarface.cannot.have.modifier.final=인터페이스는 제어자 'final'을 가질 수 없습니다
script.cannot.have.modifier.abstract=스크립트는 제어자 'abstract'를 가질 수 없습니다
script.cannot.have.modifier.native=스크립트 메소드는 제어자 'native'를 가질 수 없습니다
interface.must.have.no.static.method=인터페이스는 정적 메소드를 가질 수 없습니다.
not.abstract.class.cannot.have.abstract.method=비 추상 클래스는 추상 메소드를 가질 수 없습니다
illegal.combination.of.modifiers.volatile.and.final=제어자 'abstract' 및 'final'의 조합이 올바르지 않습니다
variable.cannot.be.native=변수는 제어자 'native'를 가질 수 없습니다
variable.cannot.be.abstract=변수는 제어자 'abstract'를 가질 수 없습니다
not.abstract.class.cannot.have.method.without.body=비 추상 클래스는 본문이 없는 메소드를 가질 수 없습니다
not.abstract.method.should.have.body=추상 메소드에 본문이 있어서는 안 됩니다.
cannot.create.class.error.text=클래스 ''{0}''을(를) 생성할 수 없습니다. {1}
cannot.create.class.error.title=클래스를 생성할 수 없음
no.class.in.file.template=파일 템플릿에서 클래스를 찾을 수 없습니다.
interface.must.have.no.private.method=인터페이스는 private 메소드를 가질 수 없습니다
error.external=외부 오류
Inner.methods.are.not.supported=내부 메소드가 지원되지 않습니다.
final.class.cannot.be.extended=final 클래스는 확장할 수 없습니다.
element.is.not.accessible=요소 {0} 이(가) 이 위치에서 private 액세스를 가집니다
class.must.declared.abstract=클래스 ''{0}'' 이(가)  추상으로 선언되거나 상속된 추상 멤버를 구현해야 합니다
object.must.implement=객체 ''{0}'' 이(가) 구현되지 않은 메소드를 구현해야 합니다
cannot.refactor.constructor.parameter.top.level=리팩토링은 최상위 클래스의 생성자 매개변수에 대해 지원되지 않습니다
wrong.refactoring.context=리팩토링이 현재 컨텍스트에서 지원되지 않습니다.
operation.not.supported.in.current.block=현재 블록에서 연산자가 지원되지 않습니다
class.import.title=클래스 import 문 추가\:
0.is.not.a.legal.scala.identifier=''{0}'' 이(가) 올바른 Scala 식별자가 아닙니다
cannot.have.implicit.parameters.and.implicit.bounds=유형 매개변수가 묵시적 매개변수 및 컨텍스트 바운드 `\:...'  또는 뷰 바운드 `<%...'를 둘 다 포함할 수 없습니다
block.must.end.result.expression=블록이 결과 표현식에서 끝나야 합니다
illegal.cyclic.reference=올바르지 않은 순환 참조 ''{0}''
anonymous.class.must.declared.abstract=익명 함수는 상속된 추상 멤버를 구현해야 합니다
cyclic.reference.type=유형 {0} 관련 올바르지 않은 순환 참조
implicit.usage.tooltip=<html><body>묵시적 변환 {0}(<b>{1}</b>)\: <b>{2}</b> 탐지됨
implicit.usage.message=묵시적 변환 ''{0}({1})\: {2}'' 탐지됨.
suspicicious.inference={0} 의 추론 유형이 의심스럽습니다. 계속 진행하려면 유형에 명시적으로 어노테이션을 지정하십시오.
suspicicious.newline=인수 목록 앞 새 줄은 세미콜론으로 추론되지 않습니다. 메소드 이름 앞에 '.'를 사용하십시오.
# TODO Remove? (or even better, do show a clarification, just as the scalac does)
missing.arguments.for.method=메소드 {0} 의 인수가 누락되었으며 부분적으로 적용된 함수가 아닙니다. 더 많은 인수를 추가하거나 자리표시자를 삽입하십시오.
element.of.trait=특성
element.of.class=클래스의
element.method=메소드
label.method=메소드 {0}
method.has.supers= 메소드 {0} 이(가) 기본 메소드를 재정의/구현합니다. 이 메소드의 이름 또한 변경하시겠습니까?
remove.explicit.val=명시적 'val' 제거
maven.repository.presentable.name=Maven 저장소
config.display.name=구성
scala.facet.title=Scala(&L)
config.scala.libraries=Scala 라이브러리 구성
scala.config.label=Scala 설치 디렉토리
scala.config.dscr=Scala 설치 디렉토리 경로를 지정하십시오
scala.config.noscala.title=Scala 설정 오류
scala.config.download.link=https\://www.scala-lang.org/downloads/
scala.config.download.link.label=다음에서 Scala를 다운로드할 수 있습니다\:
scala.config.compiler.library=Scala 컴파일러 라이브러리(&I)\:
scala.config.sdk.library=Scala SDK 라이브러리(&S)\:
scala.config.sdk.space.hint=여러 경로가 파일 구분 기호 - ';'로 구분되어야 합니다
scala.config.take.compiler.from.settings=지정된 jar의 Scala 컴파일러 라이브러리 사용(&L)
scala.config.take.relative.path=프로젝트 루트 상대 경로 사용
error.scala.path.not.valid=Scala 경로가 유효하지 않습니다
scala.config.project.template.name=비 sbt
scala.config.project.template.description=Scala 애플리케이션 개발용 모듈
scala.config.project.settings.title=Scala 설정
scala.config.module.name=Scala 모듈
scala.config.module.description=Scala 모듈 생성
no.java.sdk=Java SDK가 구성되지 않음
cannot.compile.scala.files.no.facet=모듈에 Scala 패싯을 연결하십시오. 
cannot.compile.scala.files.no.compiler=Scala 패싯 내 컴파일러 라이브러리를 지정하십시오.
cannot.compile.scala.files.compiler.problem=Scala 패싯 내 컴파일러 라이브러리를 조정하십시오\: {0}.
cannot.compile.scala.files.no.sdk=모듈 ''{0}'' 에 대한 SDK Java를 설정하십시오.
cannot.compile.scala.files.no.sdk.mult=모듈 ''{0}'' 에 대한 SDK Java를 설정하십시오.
cannot.compile=Scala 파일을 컴파일할 수 없음
debug.option=디버그 스택 트레이스 활성화
scalac.compiler.name=Scalac
javac.error.tools.jar.missing=JDK {0} 에 대한 경로 javac 클래스를 불러올 수 없습니다.\n\
JDK 설정을 업데이트하십시오.
javac.error.unknown.jdk.version=JDK {0} 버전을 지정할 수 없습니다.\n\
JDK 설정을 업데이트하십시오.
different.scala.sdk.in.modules=종속 모듈이 동일한 Scala SDK 버전을 포함해야 합니다
scala.compiler.description=Scala 컴파일러
jtype.is.not.found=Scala 파일을 컴파일할 수 없습니다.\n\
ch.epfl.lamp.fjbg.JType 클래스를 찾을 수 없습니다.\n\
모듈 ''{0}'' 에 적절할 jar를 연결하십시오.
scala.sdk.configuration=Scala SDK 설정
new.button.label=새로 작성
scala.sdk.configuration.label=<html><b>Scala SDK\:</b><br>이 모듈 전용 Scala SDK 선택</html>
add.new.scala.lib=새 Scala SDK
invalid.scala.sdk.path.text=잘못된 경로가 지정됨
duplicate.scala.lib.version=Scala SDK 버전 중복
duplicate.scala.lib.version.add=버전 {0} 의 Scala SDK를 하나 더 추가하시겠습니까?
scala.sdk.combo.box.project.item=<No Scala SDK>
no.scala.facet=Scala 패싯 기대
new.scala.facet.detected=Scala 패싯 탐지
invalid.scala.sdk.path.message=유효하지 않은 Scala SDK 경로
facet.create.lib.title=Scala 라이브러리 생성
facet.create.project.lib=프로젝트 수준 Scala 라이브러리 ''{0}'' 생성(&P)
facet.create.application.lib=애플리케이션 수준 Scala 라이브러리 ''{0}'' 생성(&A)
facet.setting.exclude.compiler.from.cp=모듈 범위에서 Scala 컴파일러 라이브러리 제외(&P)
facet.setting.exclude.library.from.cp=모듈 범위에서 Scala SDK 라이브러리 제외(&L)
file.template.group.title.scala=Scala
# class
newclass.dlg.prompt=새 Scala 클래스 이름 입력
newclass.dlg.title=새 Scala 클래스
newclass.command.name=Scala 클래스 생성
newclass.progress.text=Scala 클래스 ''{0}'' 생성 중
# worksheet
newworksheet.dlg.prompt=새 Scala 워크시트 이름 입력
newworksheet.dlg.title=새 Scala 워크시트
newworksheet.menu.action.text=Scala 워크시트
newworksheet.menu.action.description=새 Scala 워크시트 생성
newworksheet.command.name=Scala 워크시트 생성
newworksheet.progress.text=Scala 워크시트 ''{0}'' 생성 중
#object
newobject.dlg.prompt=새 Scala 객체 이름 입력
newobject.dlg.title=새 Scala 객체
newobject.menu.action.text=Scala 객체
newobject.menu.action.description=새 Scala 객체 생성
newobject.command.name=Scala 객체 생성
newobject.progress.text=Scala 객체 ''{0}'' 생성 중
#trait
newtrait.dlg.prompt=새 Scala 특성 이름 입력
newtrait.dlg.title=새 Scala 특성
newtrait.menu.action.text=Scala 특성
newtrait.menu.action.description=새 Scala 특성 생성
newtrait.command.name=Scala 특성 생성
newtrait.progress.text=Scala 특성 ''{0}'' 생성 중
scala.compiler.option.additional.command.line.parameters=Scala 컴파일러 추가 명령줄 매개변수
psi.decompiled.text.header=// Scala 언어용 IntelliJ API 디컴파일러\n\
// 클래스 파일에서 생성된 스텁 소스\n\
// 함수 구현을 사용할 수 없습니다
scala.compiler.heap.size=최대 힙 사이즈(Mb)\:
scala.compiler.cmd.line.params=명령줄 매개변수
scala.compiler.use.deprecation=@deprecated 어노테이션 컴파일(&D)
scala.compiler.scalac.first=Scala 파일 먼저 컴파일(&S)
scala.compiler.show.unchecked=@unchecked 어노테이션 컴파일(&U)
scala.compiler.generate.no.warnings=경고 생성 안 함(&W)
scala.compiler.optimize=바이트 코스 최적화(&O)
scala.compiler.no.generics=Scala 제네릭 시그니처 억제(&G)
no.right.operand.found=오른쪽 비연산자를 찾을 수 없음
cannot.resolve.infix.operator=infix 연산자를 해결할 수 없음
circular.dependency.detected=유형 별칭 ''{0}'' 의 순환 종속 요소 탐지됨
no.result.expression.found=결과 표현식을 찾을 수 없음
unreachable.expression=도달할 수 없는 명령문
choose.inferred.or.super.type.popup.title=유형 선택
test.in.scope.specs.presentable.text=''{0}'' 내 사양
equals.between.inconvertible.types.display.name=변환할 수 없는 유형의 객체 간 상등 테스트
equals.between.inconvertible.types.description=static 연산자 유형은 변환할 수 없으므로, 항상 false를 반환하는 상등 테스트를 탐지합니다.
equals.between.inconvertible.types.problem.descriptor=변환할 수 없는 유형 ''{0}'' 및 ''{1}'' 간 상등 테스트 \#loc
find.usages.implementing.type.definition=유형 정의 구현 중
find.usages.companin.module=컴패니언 모듈 사용 위치
find.usages.instances.title=인스턴스 생성
introduce.typealias.search.companion=컴패니언에서 교체
introduce.typealias.search.inheritors=상속자에서 교체
introduce.field.choose.class=필드 삽입용 클래스 선택
extract.trait.name.not.specified=특성 이름이 지정되지 않음
change.signature.not.supported.multiple.parameter.clauses=시그니처 변경은 여러 개의 매개변수 절을 가진 함수에 대해 지원되지 않습니다
change.signature.not.supported.constructors=Scala 내 시그니처 변경은 생성자에 대해 지원되지 않습니다
default.ta.settings=설정
default.ta.tooltip=유형 어노테이션 설정 구성
parameter.not.from.function=함수 정의 또는 함수 표현식에서가 아닌 매개변수에서 평가
local.variable.from.anonymous.class=익명 클래스에서 지역 변수 {0} 을(를) 로드할 수 없음
invalid.expression.in.parentheses=소괄호 안 유효하지 않은 표현식\: {0}
formatted.interpolator.not.supported=서식 지정된 문자열 보간자 f"..."는 Scala 2.11에서 지원되지 않습니다
gradle.dataService.scalaVersionCantBeDetected=모듈 {0} 의 Scala 컴파일러 버전을 확인할 수 없음
gradle.dataService.scalaLibraryIsNotFound=모듈 {1} 에 대한 프로젝트 Scala 라이브러리 {0} 을(를) 찾을 수 없음
configure.type.aware.highlighting=프로젝트 유형 인식 강조 표시 구성
vm.options=VM 옵션\:
console.arguments=콘솔 인수\:
working.directory=작업 디렉토리\:
use.classpath.and.sdk.of.module=모듈의 클래스 경로 및 SDK 사용
test.run.config.sbt.runner.form.environment.variables=환경 변수(&E)
