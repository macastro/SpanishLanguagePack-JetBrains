1.occurrence=(1 coincidencia)
abstract.member.not.have.private.modifier=Los miembros abstractos no pueden tener modificadores privados
abstract.modifier.is.not.allowed=El modificador 'abstracto' solo se permite en clases o definiciones que tienen un modificador 'anular'
abstract.modifier.redundant.fot.traits=El modificador 'abstracto' es redundante con el atributo.
abstract.override.modifier.is.not.allowed=El modificador 'anulación abstracta' solo está permitido en miembros de atributos
access.modifier.is.not.allowed.here=El controlador ''{0}'' no está permitido
action.implement.method=Implementación del método
action.import.member=Obtener miembros
action.override.method=Anulación de método
add.braces.around.single.line.expression=Agregue llaves alrededor de expresiones de una sola línea
add.collection.breakout.argument=Agregue el argumento 'colección.breakOut'
add.import.action=Agregar acción de importación
add.modifier.fix.without.name=Agregar controlador ''{0}''
add.override.modifier=Insertar &O 'anular'
add.return.type=Agregar tipo de devolución
add.to.definition=Añadir a la definición
additional.compiler.options=Opciones adicionales del compilador (&O)\:
additional.support.has.been.found.popup=<p>Se ha encontrado soporte adicional para algunas bibliotecas.</p><p>¿Le gustaría habilitarlo? <a href\="Sí">Sí</a> / <a href\="No">No</a></p>
align.list.items.content=Ordenar el contenido de los elementos de la lista
ambiguous.artifact.resolved=Se resolvió un artefacto ambiguo. {0}
annotation.ascriptions.in.pattern.definitions.require.scala3=La atribución de anotaciones dentro de las definiciones de patrones requiere Scala 3.0
annotation.or.type.expected=Anotación o tipo requerido
annotator.error.annotation.type.expected=Se requiere tipo de anotación
annotator.error.bean.property.should.not.be.private=Las propiedades de Bean no deben ser privadas.
annotator.error.cannot.apply.constructor=El constructor {0} no se puede aplicar
annotator.error.cannot.find.constructor.for.this.call=No se encontró ningún constructor para esta llamada.
annotator.error.cannot.resolve.overloaded.constructor=El constructor sobrecargado ''{0}'' no se puede resolver
annotator.error.cannot.resolve.overloaded.method=No se puede resolver el método sobrecargado
annotator.error.class.type.required.but.found=Tipo de clase requerida pero ({0}) encontrada
annotator.error.constructor.has.malformed.definition=El tipo de definición del constructor es incorrecto.
annotator.error.enum.case.must.extend.parent=Un caso de enumeración debe extender la clase de enumeración correspondiente {0}
annotator.error.enum.nonvariant.type.param,in.enum=No se puede determinar el argumento de tipo del padre {0} de la clase de enumeración. El parámetro de tipo {1} es invariante
annotator.error.enum.two.type.parameter.clauses=Tanto los casos de enumeración como las clases de enumeración contienen parámetros de tipo y, por lo tanto, requieren una cláusula de extensión explícita.
annotator.error.expansion.for.non.repeated.parameter=Expansión de parámetros no repetitivos
annotator.error.missing.argument.list.for.constructor=Falta la lista de argumentos para el constructor {0}
annotator.error.missing.arguments.for.method=Al método {0} le falta un argumento
annotator.error.missing.parameter.type=Falta el tipo de parámetro
annotator.error.missing.type.annotation.for.parameter=Falta la anotación de tipo para el parámetro. {0}
annotator.error.name.has.malformed.definition=''{0}'' tiene una definición incorrecta
annotator.error.no.constructor.accessible=No hay ningún constructor accesible aquí.
annotator.error.parameter.specified.multiple.times=Parámetro especificado varias veces
annotator.error.parameter.without.an.owner.name=Parámetro sin propietario\: {0}
annotator.error.positional.after.named.argument=Argumentos posicionales después de argumentos con nombre
annotator.error.reassignment.to.val=Asignar nuevamente a val
annotator.error.repeated.or.default=La sección de parámetros con parámetros * no debe contener argumentos predeterminados
annotator.error.repeated.parameter.must.be.last=*-el parámetro debe ser el último
annotator.error.target.does.not.take.parameters={0} no toma parámetros
annotator.error.too.many.arguments=Demasiados argumentos
annotator.error.too.many.arguments.for.constructor=Demasiados argumentos para el constructor {0}
annotator.error.too.many.arguments.method=Demasiados argumentos para el método {0}
annotator.error.too.many.parameters=Demasiados parámetros
annotator.error.trait.has.no.constructor=La propiedad {0} es una propiedad y, por lo tanto, no acepta argumentos de constructor.
annotator.error.unspecified.value.parameters=Parámetro de valor no especificado \: {0}
annotator.error.wrong.right.assignment.side=El lado derecho de la tarea es incorrecto
assign.expected='\=' es obligatorio
assignment.missing.right.side=Falta el lado derecho de la tarea
auto.import.add.unambiguous.imports.on.the.fly.for=Agregue inmediatamente una declaración de importación inequívoca en \:
auto.import.find.more.configuration.options=Encuentre más opciones de configuración en <a>Estilo de código</a>
auto.import.optimize.imports.on.the.fly=Optimización inmediata de las declaraciones de importación.
auto.import.show.import.popup.for=Mostrar ventana emergente de declaración de importación cuando\:
auto.import.show.popup.classes=Clase
auto.import.show.popup.conversions=Conversión implícita
auto.import.show.popup.extension.methods=Método de extensión
auto.import.show.popup.implicits=Definición implícita
auto.import.show.popup.methods=Miembro estático
auxiliary.constructor.definition.expected=Se requiere una definición de constructor secundario
auxiliary.constructor.may.not.have.a.type.annotation=Los constructores auxiliares no pueden tener anotaciones de tipo.
bad.interpolated.string.injection=Inserción de cadena interpolada incorrecta
balance.header=Encabezado de saldo
base.package.help=<html>Si el paquete base es <code>org.example.application</code>, entonces el paquete <code>org.example.application.NAME</code> es<br><code>paquete org.example.application </code><br>Debe definirse como <code>NOMBRE del paquete</code></html>
better.monadic.for.invalid.pattern=Se deben agregar anotaciones de tipo explícitas a los argumentos.
binary.literals.not.supported=Binary literals require Scala 2.13 or Scala 3.5
blank.lines.panel.around.class.in.inner.scopes=Alrededor de una clase dentro de un ámbito interno
blank.lines.panel.around.field.in.inner.scopes=Alrededor del campo dentro de los límites internos.
blank.lines.panel.around.method.in.inner.scopes=Alrededor de un método dentro de un alcance interno
bold.surrounder.template.description=Atrevido\: '''' ''''
both.stub.and.name.identifier.node.are.null=Tanto el nodo de identificador de nombre como el de código auxiliar en {0} son nulos\n{1}
brew.packages=Brew 패키지
bundled.distribution.info.name=Incluido en el paquete
by.name.parameters.cannot.be.used=Debido a que este método tiene una anulación de Java, no puede utilizar parámetros de llamada por nombre de la clase de valor.
bytecode.indices.target.for.comprehension.method=Método de comprensión
bytecode.indices.target.implicit.definition=Definición implícita
bytecode.indices.target.sam.type=Tipo SAM
bytecode.indices.target.unapply.method=Aplicar/desaplicar métodos
call.is.recursive=Llamada recursiva
called.constructor.definition.must.precede=La definición del constructor llamado debe preceder a la definición del constructor llamado.
can.not.override.final={0} ''{1}'' no puede anular el miembro final
can.t.find.implicit.argument.for.this.definition=No se encontró ningún argumento implícito para esta definición.
can.t.infer.proper.types.for.type.parameters=No se puede inferir el tipo adecuado de parámetro de tipo
can.t.resolve.type=El tipo no se puede resolver
cannot.be.a.top.level.definition.in.scala.2=No puede ser una definición de nivel superior en Scala 2
cannot.create.expression=No se puede generar expresión
cannot.create.field.from.this.expression=No se puede crear un campo a partir de esta expresión.
cannot.define.expected.type=El tipo requerido no se puede definir
cannot.desugarize.typename=No se puede deshugar {0}
cannot.determine.expected.type=No puedo entender qué tipo necesito
cannot.extract.empty.message=Sus opciones de refactorización son incorrectas. Se requieren varias expresiones o declaraciones completas.
cannot.extract.self.invocation=No se puede extraer la autollamada.
cannot.extract.used.function.definition=No se admite la refactorización. Las definiciones de funciones dentro de la selección se utilizan fuera del fragmento seleccionado.
cannot.extract.used.type.definition=No se admite la refactorización. Las definiciones de tipo dentro de la selección se utilizan fuera del fragmento seleccionado.
cannot.find.directory.for.package=No se puede encontrar el siguiente directorio de paquetes: {0}
cannot.find.enclosing.container=No se encontró el contenedor adjunto
cannot.find.method.of.stringcontext=Método {0} de StringContext no encontrado
cannot.find.package.with.name=No se pudo encontrar un paquete con el siguiente nombre. {0}
cannot.find.partialfunction.class=Clase de función parcial no encontrada
cannot.find.place.for.the.new.field=Nueva ubicación de campo no encontrada
cannot.find.template.for.this.reference=No se puede encontrar la plantilla para esta referencia.
cannot.find.throwable.class=Clase arrojable no encontrada
cannot.handle.compatibility.for=No se puede procesar la compatibilidad para {0}
cannot.have.infix.type.directly.in.typed.pattern.try.to...=Los patrones escritos no pueden tener tipos de notación infija directamente. Rodéelo entre paréntesis.
cannot.infer.type=No se pudo inferir el tipo
cannot.infer.type.of.super.expression=No se puede inferir el tipo de expresión 'super'
cannot.infer.type.without.an.expression=El tipo no se puede inferir sin expresión
cannot.infer.type.without.expected.type=No se puede inferir un tipo sin el tipo requerido
cannot.infer.type.without.function.expected.type=No se puede inferir el tipo sin el tipo requerido de scala.FunctionN o scala.PartialFunction
cannot.inline.different.files=El afiliado se declara en otro expediente. No se admite la inserción en línea.
cannot.inline.function.functional.parameters=No se admiten funciones en línea con parámetros de función
cannot.inline.function.implicit.parameters=La inserción en línea no es compatible con funciones con parámetros implícitos
cannot.inline.function.multiple.clauses=La inserción no es compatible con funciones con cláusulas de múltiples parámetros
cannot.inline.function.varargs=La inserción en línea no es compatible con funciones con parámetros vararg
cannot.inline.generic.function=La inserción en línea no es compatible con funciones genéricas
cannot.inline.implicit.element=La inserción en línea no es compatible con elementos implícitos
cannot.inline.never.used=La definición no se utiliza
cannot.inline.not.method.call=La inserción en línea solo se admite para llamadas a métodos regulares
cannot.inline.not.simple.definition=La inserción solo se admite para definiciones {0} simples
cannot.inline.notsimple.typealias=La inserción en línea solo se admite para alias de tipo simple
cannot.inline.read.only=No se pueden insertar elementos de solo lectura
cannot.inline.recursive.function=La inserción en línea no es compatible con funciones recursivas
cannot.inline.special.function=La inserción en línea no es compatible con funciones especiales
cannot.inline.stable.reference=El valor se utiliza en una referencia estable y no se puede insertar.
cannot.inline.used.outside.class=El miembro se utiliza fuera de la clase contenedora. No se admite la inserción en línea.
cannot.inline.value.functional.type=No se admite la inserción de valores con tipos de funciones
cannot.refactor.arg.in.self.invocation.of.constructor=No se admite la refactorización de argumentos de autoinvocación en cuerpos de constructores
cannot.refactor.class.parameter.top.level=La refactorización no es compatible con parámetros en clases de nivel superior
cannot.refactor.constr.expression=El bloque seleccionado no debe aparecer como expresión de constructor.
cannot.refactor.interpolated.string.prefix=La refactorización no es compatible con prefijos de cadenas interpoladas
cannot.refactor.literal.pattern=La refactorización no es compatible con patrones literales
cannot.refactor.named.arg=La refactorización no es compatible con argumentos con nombre
cannot.refactor.no.function=Función no encontrada para la inserción de parámetros
cannot.refactor.not.expression=La cadena seleccionada no se puede extraer mediante expresión
cannot.refactor.not.expression.nor.type=Se debe seleccionar una expresión o elemento de tipo.
cannot.refactor.not.valid.type=Se debe seleccionar el elemento tipo.
cannot.refactor.scope.not.found=No se encontró ninguna clase o paquete adecuado
cannot.refactor.self.invocation=La refactorización no es compatible con llamadas al constructor en constructores secundarios
cannot.refactor.under.generic.call=La refactorización no es compatible con llamadas genéricas
cannot.resolve=El símbolo {0} no se pudo resolver
cannot.resolve.apply.method=No se pudo resolver el método {0}.apply
cannot.resolve.expression=La expresión no se puede resolver.
cannot.resolve.in.StringContext=El valor ''{0}'' no es miembro de StringContext
cannot.resolve.overloaded=El método sobrecargado ''{0}'' no se puede resolver
cannot.resolve.parent.class=No se puede resolver la clase principal
cannot.resolve.ref=No se pudo resolver la referencia {0}
cannot.resolve.reference=No se pudo resolver la referencia
cannot.resolve.unapply.method=No se pudo resolver el método {0}.unaapply
cannot.resolve.unknown.symbol=No se pudo resolver el símbolo
cannot.shape.resolve.self.invocation=No se puede resolver la autollamada
cannot.upcast.type.to.other.type=No se puede transmitir {0} a {1}
case.class.has.no.primary.constructor=La clase de caso no tiene constructor predeterminado
case.classes.without.parameter.list.deprecated=Las clases de casos sin listas de parámetros están en desuso
case.classes.without.parameter.list.not.allowed=No se permiten clases de casos sin listas de parámetros.
case.clause=Cláusula de caso
case.clauses.expected=Se requiere cláusula de caso
change.signature.add.parameter.clause=Agregar cláusula de parámetro
change.signature.not.supported.extractors=El extractor no admite cambios de firma
change.signature.not.supported.implicit.functions=Los cambios de firma no se admiten en funciones implícitas
change.signature.not.supported.implicit.parameters=Los cambios de firma no son compatibles con funciones con parámetros implícitos
change.signature.parameters.same.name.{0}=Los parámetros tienen el mismo nombre. {0}
change.signature.remove.parameter.clause=Eliminar cláusula de parámetro
change.signature.specify.type.for.parameter=Especificación del tipo de parámetro ''{0}''
change.signature.vararg.should.be.last.in.clause=Los parámetros de Vararg deben aparecer al final de la cláusula de parámetro.
change.type.to=Cambiar tipo ''{0}'' a ''{1}''
changes.in.scalatest.highlighting.will.be.processed...=Los cambios realizados en el resaltado de ScalaTest se manejan correctamente solo en los archivos recién resaltados. Reinicie Intellij IDEA para optimizar su experiencia
channel.early.access.program=Acceso temprano
channel.nightly.builds=Construcción nocturna
channel.stable.releases=Lanzamiento estable
choose.class.for.introduce.field=Seleccionar clase para insertar campos
choose.either.a.scala.sdk.directory.or.scala.jar.files=Seleccione el directorio Scala SDK o el archivo jar de Scala (permitir\: binarios, fuente, documentación)
choose.expected='<-' es necesario en la sintaxis del generador
choose.expression.for=Seleccione expresión para {0}
choose.function.for.refactoring=Seleccionar función para {0}
choose.level.for.extract.method=Seleccione el nivel de extracción del método.
choose.level.popup.title=Selecciona el nivel
choose.scope.for=Seleccionar rango {0}
choose.type.element.for=Seleccione el tipo de elemento para {0}
class.already.exists.in.package=Ya existe una clase con nombre {0} en el paquete {1}
class.has.several.subclasses={0} se extiende por subclase
class.has.subclasses=Criterios ampliados
class.is.abstract.it.cannot.be.instantiated=La clase ''{0}'' es abstracta y no se puede crear una instancia de ella.
class.to.pull.up.members.to.class=Clase para elevar el miembro a {0}
click.or.press.shortcut.to.change=(Haga clic o toque {0} para cambiar)
click.to.change=(Haga clic para cambiar)
code.block=Bloque de código
codegeneration.panel.title=Codigo de GENERACION
colon.expected='\:' se requiere
column.enabled=Activado
column.transformation=Conversión
command.introduce.type.alias=Insertar alias de tipo
companion.class=Clase
companion.enum=Enumeración
companion.object=Objeto
companion.trait=Característica
compile.order=Orden de compilación (&O)\:
compile.order.java.then.scala=Java seguido de Scala
compile.order.mixed=Mezcla
compile.order.scala.then.java=Scala seguido de Java
compiler.plugins=Complemento del compilador
compound.type.expected=Se requiere un tipo compuesto
condition.expected=Requiere condición booleana
configure.updates=Configurar actualizaciones...
constructor=Constructor
constructor.cannot.be.instantiated.to.expected.type=No se puede crear una instancia de un constructor con el tipo requerido. Encontrado\: {0}, Requerido\: {1}
constructor.invocation.expected=Los constructores secundarios deben comenzar con una llamada a 'esto'
context.bounds.not.allowed=Límites de contexto no permitidos
contravariant.type.covariant.position.of.method=El tipo convariante {0} aparece en la posición covariante en el tipo {1} en el método {2}
contravariant.type.covariant.position.of.value=El tipo covariante {0} aparece en la posición covariante en el tipo {1} para el valor {2}
contravariant.type.invariant.position.of.method=El tipo convariante {0} aparece en la posición no covariante en el tipo {1} del método {2}
contravariant.type.invariant.position.of.value=El tipo contravariante {0} aparece en la posición no covariante en el tipo {1} del valor {2}
control.curly.braces.based.on.line.indents=Controlar llaves basadas en sangría\:
convert.binary.to.hex.fix=8진 리터럴을 16진수로 변환
convert.java.to.scala.collection.hint=¿Convertir a la colección Scala usando asScala?
convert.java.to.scala.collection.name=Convertir a la colección Scala
convert.octal.to.hex.fix=8진 리터럴을 16진수로 변환
convert.scala.to.java.collection.hint=¿Convertir a una colección Java usando asJava?
convert.scala.to.java.collection.name=Convertir a colección Java
convert.to.explicit.symbol=Convertir a símbolo (''{0}'')
convert.to.explicit.symbol.family=Convertir a símbolo explícito
convert.to.long.fix=Convertir a literal largo
convert.to.typed.pattern=Convertir a patrón escrito
convert.view.and.context.bounds.to.implicit.parameters=Convertir límites de contexto en parámetros implícitos
copy.link.to.clipboard=Copiar enlace al portapapeles
copy.scaladoc=Copiar y ScalaDoc
could.not.decompile.file.comment=//No se puede descompilar {0}
could.not.find.type.for.selection=Tipo de selección no encontrada
could.not.infer.type.of.underscore.section=No se puede inferir el tipo de sección de subrayado
could.not.perform.inplace.rename=No se puede realizar el cambio de nombre in situ.\nElemento a cambiar de nombre\: {0} {1}\nReemplazado\: {2}\nAlrededor del cursor\: {3}
could.not.understand.type=타입 {0}을(를) 이해할 수 없습니다
coursier.v1.cache=Caché de Courier v1
covariant.type.contravariant.position.of.method=El tipo covariante {0} aparece en la posición contravariante en el tipo {1} del método {2}
covariant.type.contravariant.position.of.value=El tipo covariante {0} aparece en la posición contravariante en el tipo {1} para el valor {2}
covariant.type.invariant.position.of.method=El tipo covariante {0} aparece en la posición no covariante en el tipo {1} en el método {2}
covariant.type.invariant.position.of.value=El tipo covariante {0} aparece en la posición no covariante en el tipo {1} del valor {2}
create.annotation.class.named=Crear clase de anotación ''{0}''
create.apply.method.in={0} Crear mi método ''aplicar''
create.case.class.named=Crear clase de caso ''{0}''
create.class.named=Crear clase ''{0}''
create.companion.object.for.class=Crea un objeto complementario para tu clase.
create.extractor.object.named=Crear objeto extractor ''{0}''
create.method.named=Crear método ''{0}''
create.new.scala.class=Crear una nueva clase de Scala
create.new.scala.class.or.file=Crear una nueva clase/archivo de Scala
create.object.named=Crear objeto ''{0}''
create.parameter.named=Crear parámetro {0}
create.parameterless.method.named=Crear método sin parámetros ''{0}''
create.trait.named=Crear propiedad ''{0}''
create.unapply.method.in={0} Crear mi método ''desaplicar''
create.value.named=Crear valor ''{0}''
create.variable.named=Crear variable ''{0}''
debug.info.level.complete.no.tail.call.optimization=Completo (sin optimización de llamadas finales)
debug.info.level.none=Ninguno
debug.info.level.source=Propiedades del archivo fuente
debug.info.level.source.and.line.number=Información de fuente y número de línea
debug.info.level.source.line.number.and.local.variable=Fuente, número de línea e información de variable local
debugging.info.level=Nivel de información de depuración (&L)\:
def.dcl.expected=Se requiere una definición o declaración
def.name=Def {0}
default.init.prohibited.literal.types=La inicialización predeterminada está prohibida en el tipo literal var
default.ta.settings=Configuración
default.ta.tooltip=Configurar los ajustes de anotación de tipo
default.value.is.missing.default.arguments=No existe un valor predeterminado. El argumento predeterminado contiene un espacio en lugar del nuevo valor del parámetro.
default.value.is.missing.method.calls=No existe un valor predeterminado. La llamada al método contiene espacios en lugar de nuevos valores de parámetros.
default.values=Valor por defecto\:
delete.closing.brace=Elimine '{' y elimine el paréntesis de cierre.
delete.inlined.tag=Eliminar etiquetas en línea
delete.unknown.tag=Eliminar etiquetas desconocidas
dependent.function.types.are.not.yet.supported=Los tipos de funciones dependientes aún no son compatibles
deprecation.warnings=&Advertencia de obsolescencia
deprecation.warnings.tooltip=Envíe advertencias sobre dónde se utilizan las API obsoletas y sus ubicaciones.
derives.cannot.be.unified={0} no se puede combinar con el argumento de tipo de {1}
derives.no.member.named.derived=El valor derivado no es miembro del objeto {0}
derives.not.a.class.type={0} no es un tipo de clase y no se puede derivar
derives.scala.class.expected=Requiere clase/rasgo de Scala
derives.type.has.no.companion.object={0} no se puede derivar porque no tiene ningún objeto complementario
derives.type.has.no.type.parameters={0} no se puede derivar porque no tiene parámetros de tipo
descriptive.name.anonymous=Anónimo
desugar.add.explicit.override.modifier=Agregar un controlador de "anulación" explícito
desugar.append.semicolon=Agregar punto y coma
desugar.canonize.arity.0.call=Normalización de llamadas arity-0
desugar.canonize.block.argument=Normalizar argumentos de bloque vacío
desugar.canonize.infix.call=Normalizar llamadas infijas
desugar.canonize.postfix.call=Normalización de llamadas por sufijo
desugar.convert.implicit.class.to.class.and.function=Convertir clases implícitas en clases y funciones.
desugar.convert.parentheses.to.braces.in.for.comprehensions=Convertir paréntesis en llaves para anidar
desugar.enforce.parentheses.in.constructor.invocation=Forzar paréntesis al llamar al constructor
desugar.expand.apply.call=Ampliando la convocatoria "aplicar"
desugar.expand.assignment.call=Extensión de llamada de asignación
desugar.expand.auto.tupling=Extensiones de tupla automática
desugar.expand.context.bound=Extensión vinculada al contexto
desugar.expand.dynamic.call=Expansión dinámica de llamadas
desugar.expand.eta.expansion=Extensión de extensión eta
desugar.expand.for.comprehensions=Para expansión anidada
desugar.expand.function.instantiation=Extensión de creación de instancias de funciones
desugar.expand.function.type=Extensión del tipo de función
desugar.expand.implicit.conversion=Extensión de conversión implícita
desugar.expand.macro=Macroexpansión
desugar.expand.placeholder.syntax=Extensiones de sintaxis de marcadores de posición
desugar.expand.procedure.syntax=Extensiones de sintaxis procesal
desugar.expand.property.declaration=Ampliación de declaración de propiedad
desugar.expand.property.definition=Ampliar definiciones de propiedades
desugar.expand.property.setter.call=Ampliar las llamadas al establecimiento de propiedades
desugar.expand.single.abstract.methods=Ampliando un único método abstracto
desugar.expand.string.interpolation=Extensión de interpolación de cadenas
desugar.expand.to.equals.call=Expande "\=\=" para llamar "igual"
desugar.expand.tuple.instantiation=Extensión de creación de instancias de tupla
desugar.expand.tuple.type=Extensión de tipo tupla
desugar.expand.type.alias=Expansión de alias de tipo
desugar.expand.unary.call=Extensión de llamada unaria
desugar.expand.update.call=Ampliando la llamada de "actualización"
desugar.expand.vararg.argument=Expansión del argumento vararg
desugar.expand.view.bound=Ampliar los límites de la vista
desugar.expand.wildcard.import=Expansión de declaración de importación comodín
desugar.for.comprehension=Para la comprensión disuga
desugar.fully.qualify.import.expression=Normalizar completamente las expresiones de importación
desugar.fully.qualify.reference=Normalizar completamente las referencias
desugar.function.parameter=Parámetros de función
desugar.group.declarations=Declaración
desugar.group.expressions=Expresión
desugar.group.functions=Función
desugar.group.general=Común
desugar.group.implicits=Implícito
desugar.group.method.invocations=Llamada al método
desugar.group.references=Referencia
desugar.group.type.annotations=Tipo de anotación
desugar.group.types=Tipo
desugar.inscribe.default.arguments=Insertar argumentos predeterminados
desugar.inscribe.explicit.braces=Insertar llaves explícitas
desugar.inscribe.implicit.parameters=Insertar parámetros implícitos
desugar.make.eta.expansion.explicit=Establecer explícitamente la extensión eta
desugar.make.method.return.expressions.explicit=Establecer explícitamente expresiones de retorno de métodos
desugar.method.definition=Definición del método
desugar.partially.qualify.simple.reference=Normalizar parcialmente referencias simples.
desugar.reference.pattern=Patrón de referencia
desugar.replace.underscore.section.with.default.value=Reemplace las secciones subrayadas con valores predeterminados
desugar.scala.code.action.description=Disquete de código Scala (rango seleccionado/archivo completo)
desugar.scala.code.action.text=Plato de código Scala...
desugar.scala.code.in.scope=Código Scala disuga({0})
desugar.substitute.anyref=Alternativa a AnyRef
desugar.type.parameters=Tipo de parámetro
desugar.underscore.parameter=Parámetro subrayado
desugar.value.definition=Definición de valor
desugar.variable.definition=Definición de variable
disabled.word=Deshabilitado
displayname.scala.compiler=Compilador escala
do.statement=Hacer declaración
documentation.for.project={0} documento
does.not.take.parameter.default.target=Solicitud
dot.expected='.' se requiere
dot.or.cq.expected='.' o necesitas un calificador de clase
downloading.scala.version=Descargando Scala {0}
downloading.url=Descargando {0}
edit.package.prefix=Editar prefijo de paquete...
else.expected=Se requiere 'más'
empty.new.expression=Nueva expresión vacía
enable.continuations=&Activación continua
enable.loading.external.extensions=Habilitar carga de extensión externa
enable.specialization=Activar especialización
enable.specialization.tooltip=Cumple con la anotación @specialize
enable.warnings=Activar & Advertencia
enable.warnings.tooltip=Crear alerta
enabled.word=Habilitado
end.of.string.expected=Requiere el final de la cadena
enumerators.binding.case.keyword.found=Patrón requerido pero 'caso' encontrado
enumerators.binding.val.keyword.deprecated=La palabra clave 'val' en los enumeradores está obsoleta
enumerators.expected=Necesito un enumerador dentro de una declaración 'para'
enumerators.generator.val.keyword.found=Patrón esperado pero 'val' encontrado
erasure.warning=(Es posible que aún coincida con ese borrador)
error.downloading.scala.version=Se produjo un error al descargar Scala {0}
error.message.title.create.entity.quickfix=Crear solución rápida de entidad
error.wrong.caret.position.method.name=El símbolo de intercalación debe estar en el nombre del método que se va a refactorizar.
except.for.base.package=Excluido el paquete básico
exclude.value.from.auto.import=Excluir ''{0}'' de la importación automática
existential.block.expected=Se requiere cláusula de existencia
expand.macro=Macroexpansión
expand.to.new.pattern=Se expande a\: {0}
expected.another.pattern=Necesito un patrón diferente
expected.at.least.one.extension.method=Se requiere al menos 1 método de extensión
expected.case.on.a.new.line=Una nueva línea requiere un caso
expected.do=Se requiere 'hacer'
expected.do.or.yield=Se requiere 'hacer' o 'ceder'
expected.more.types=Necesitamos más tipos
expected.new.line.after.colon=Se requiere una nueva línea después de los dos puntos
expected.then='entonces' es requerido
expected.type.boolean=El método {0} requiere un tipo booleano como tipo de retorno
expected.type.constructor=Se requiere el constructor de tipo {0}
explain.type.errors=Escriba la descripción del error (&E)
explain.type.errors.tooltip=Los errores tipográficos se explican en detalle.
expr.type.does.not.conform.expected.type=La expresión de tipo {0} no se ajusta al tipo esperado {1}
expression.expected=Se requiere expresión
extension.method.expected=Necesitas un método de extensión
extension.method.overrides.regular=El método {0} es un método de extensión y no se puede anular como método normal.
extensions.in.selected.library=Ampliación dentro de la biblioteca seleccionada
extract.abstracts=Abstracto a abstracto
extract.file.method=Método de extracción de archivo
extract.local.method={0} Extraer mi método local
extract.local.method.in.else.block=Extraer métodos locales dentro del bloque else
extract.method.cannot.find.possible.scope=Posible alcance para el método extraído no encontrado
extract.method.title=Extracción del método
extract.method.to.anonymous.class=Extraer métodos en clases anónimas
extract.method.to.class.name=Extraer método en la clase {0}
extract.method.to.object.name=Extraer método para objetar {0}
extract.method.to.package.name=Extraer método en el paquete {0}
extract.method.to.trait.name=Método de extracción por atributo {0}
extract.trait.action.description=Extraer características de clases seleccionadas
extract.trait.action.text=Extracción de características...
extract.trait.name=Nombre del Atributo\:
extract.trait.package.label=Paquete para nueva característica\:
extract.trait.title=Extracción de características
extract.trait.top.label.text=Extraer características de\:
extraction.of.anonymous.class.with.vars.refs.unsupported=Actualmente no se admite la extracción de clases anónimas con referencias a variables fuera de alcance.
failed.to.found.corresponding.underscore.section=No se encontró la sección de subrayado correspondiente
family.name.add.braces=Agregar llaves
family.name.add.collection.breakout=Agregue 'colección.breakOut'
family.name.add.empty.parentheses=Agregar paréntesis vacíos
family.name.adjust.types=Ajuste de tipo
family.name.change.type=Tipo de cambio
family.name.comparing.length=Reemplazar con .sizeIs
family.name.convert.from.infix.expression=Conversión de expresión infija
family.name.convert.implicit.bounds=Conversión ligada implícita
family.name.convert.parameter.to.underscore.section=Convertir parámetros a secciones subrayadas
family.name.convert.to.curly.braces=Convertir a llaves
family.name.convert.to.desugared.expression=Convertir a expresión decodificada
family.name.convert.to.infix.expression=Convertir a expresión infija
family.name.convert.to.object=Convertir a objeto
family.name.convert.underscore.section.to.parameter=Convertir secciones subrayadas en parámetros
family.name.create.annotation.class=Crear clase de anotación
family.name.create.apply.method=Crear método 'aplicar'
family.name.create.case.class=Crear clase de caso
family.name.create.class=crear clase
family.name.create.companion.object=Crear objeto complementario
family.name.create.extractor.object=Crear objeto extractor
family.name.create.method=Crear método
family.name.create.object=Creación de objetos
family.name.create.parameter=Crear parámetros
family.name.create.parameterless.method=Crear método sin parámetros
family.name.create.trait=Crear características
family.name.create.unapply.method=Crear método 'desaplicar'
family.name.create.value=crear valor
family.name.create.variable=Crear variable
family.name.enable.type.mismatch.hints=Habilitar sugerencia de discrepancia de tipos
family.name.expand.to.constructor.pattern=Extendiendo al patrón constructor
family.name.filter.set.contains=Eliminar 'contiene' innecesarios en el filtro
family.name.give.a.name.to.anonymous.abstract.given=Nombrar el resumen anónimo proporcionado
family.name.implement.anonymous.abstract.given=Resumen anónimo dada la implementación
family.name.import.additional.identifiers=Obtener identificadores adicionales
family.name.import.all.members=Obtener todos los miembros
family.name.import.member.with.stable.path=Importar miembros por ruta estable
family.name.make.implicit.conversion.explicit=Hacer explícitas las conversiones implícitas
family.name.remove.braces=Quitar los frenillos
family.name.remove.case.from.enumerator=Eliminar 'caso' del enumerador
family.name.remove.tailrec.annotation=Eliminar la anotación @tailrec
family.name.remove.unnecessary.apply=Eliminar aplicaciones innecesarias
family.name.replace.type.check.with.pattern.matching=Reemplazo de verificación de tipo con coincidencia de patrones
family.name.replace.type.with.type.in.vararg.pattern=Reemplazar '\:' con '@' en el patrón vararg
family.name.replace.with.scala3.vararg.pattern=Reemplazo de la sintaxis '\:' con el patrón vararg de Scala 3.0
family.name.some.to.option=De algunos a la opción
family.name.use.infix.type.syntax=Utilice sintaxis de tipo infijo
family.name.use.prefix.type.syntax=Usar sintaxis de tipo de prefijo
feature.dynamics=Dinámica
feature.existential.types=Tipo de existencia (&E)
feature.experimental.features=&Características experimentales
feature.higher.kinded.types=Tipo de padre (&H)
feature.implicit.conversions=Conversión implícita (&I)
feature.macros=Macro
feature.postfix.notation=Notación del operador Postfix (&P)
feature.reflective.calls=Llamada reflexiva (&R)
feature.warnings=&Alerta de función
feature.warnings.tooltip=Enviar alerta de función de idioma.
features=Función
field.occurrences={0} elementos encontrados
file.is.not.writable=No tienes permiso de escritura en el archivo.
file.type.scala.outlines=Esquema de escala
final.modifier.is.not.allowed.here=El modificador 'final' no está permitido.
final.modifier.is.redundant.with.final.parents=El modificador 'final' es redundante con un objeto o miembro de clase final
final.modifier.not.with.declarations=El modificador 'final' no se puede utilizar con miembros incompletos
final.modifier.not.with.trait=Modificador 'final' no permitido para propiedades
find.what.companion.module.checkbox=&Dónde utilizar los módulos complementarios
find.what.implementing.type.definitions.checkbox=&Implementación de definición de tipo
find.what.members.usages.checkbox=&Dónde utilizar los miembros
find.what.new.instances.usages=&Solo creación de instancias
for.pattern.bindings.require.scala3=El uso de la sintaxis 'case' dentro del enlace de patrón 'for' requiere Scala 3.0
for.statement=Para declaración
forward.reference.detected=Referencia directa incorrecta
fruitless.type.test=Prueba de tipo infructuosa\: el valor del tipo {0} no puede ser {1}
fun.sign.expected='\=>' es obligatorio
function.expression=Expresión de función
function.must.define.type.explicitly=El método {0} tiene una declaración de devolución, por lo que necesitamos un tipo de resultado
function.recursive.need.result.type=El método recursivo {0} requiere el tipo de resultado
generate.scaladoc=Crear un Scaladoc
generate.scaladoc.action.description=Crear un Scaladoc
generate.scaladoc.action.text=Crear un Scaladoc
given.alias.declaration.must.be.named=Anónimo dado no puede ser abstracto
go.to.companion=Ir al compañero {0}
go.to.implementation=Ir a Implementación
go.to.super.method=Ir al miembro padre
goto.super.class.chooser.title=Seleccionar clase principal
goto.super.class.or.member.chooser.title=Seleccionar clase principal/miembro principal
goto.super.member.chooser.title=Seleccionar miembro padre
gutter.companion=Compañero
gutter.implemented=Miembros implementados
gutter.implementing=Implementación de miembros
gutter.overridden=Miembro redefinido
gutter.overriding=Anulación de miembro
gutter.recursion=Tipo recursivo
gutter.sam=Implementación SAM
has.companion=Incluye acompañante {0}
has.implementations=Miembro tiene implementación
has.no.reference=sin referencia
hint.label.expected=Necesario
hint.label.non.singleton=no singleton
hint.label.original=original
hint.label.simplified=Simplificado
how.to.add.custom.macro.support.help.link.title=Cómo agregar compatibilidad con macros Scala personalizadas
html.unable.to.launch.web.browser=No puedo iniciar mi navegador web. Ejecútelo manualmente. {0}
id.is.already.defined={0} ya está definido en el alcance
idea.based.scala.project=Proyecto Scala basado en IDEA
idea.is.outdated.please.update=IDEA no está actualizada para su uso con la rama {0} del complemento Scala.<br/>Para utilizar el complemento Scala más reciente, actualice IDEA a {1} o superior.
idea.will.try.to.search.for.extra.support.for.particular.libraries=IDEA está intentando recuperar soporte adicional para una biblioteca específica en su proyecto
identifier.expected=Se requiere un identificador
identifier.expected.but.0.found=Se requiere identificador pero se encontró {0}
identifier.expected.comma.found=Se requiere identificador pero se encontró ','
identifier.or.opening.brace.expected=Se requiere un identificador o llave de apertura
identifier.or.wild.sign.expected=Se requiere identificador o '_'
if.block=Si bloque
illegal.assignment.target=Objetivo de asignación incorrecto
illegal.inheritance.extends.enum=Se prohíben las ampliaciones de enumeración.
illegal.inheritance.from.final.kind=Herencia incorrecta final {0} de ''{1}''
illegal.inheritance.from.sealed.kind=Selló {0} herencia incorrecta de ''{1}''
illegal.inheritance.from.value.class=Herencia no válida de la clase de valor ''{0}''
illegal.inheritance.multiple={0} ''{1}'' se hereda varias veces
illegal.inheritance.self.type=Herencia inválida. El autotipo {0} no se ajusta a {1}
illegal.instantiation={0} ''{1}'' es abstracto y no se puede crear una instancia
illegal.mixin={0} ''{1}'' debe ser una característica combinable
illegal.modifiers.combination=Combinación de controlador no válida\: {0} y {1}
illegal.secondary.constructors.value.class=Los constructores secundarios no están permitidos en clases de valor.
illegal.undefined.member=Los miembros declarados pero no definidos solo pueden existir en clases
illegal.underscore.separator=Necesitas Scala 2.13 para usar el delimitador de guión bajo
implement.members.fix=Implementación de miembros
implements.member.from.prefix=Implementación de miembros en
implements.member.from.several.classes=Miembro de implementación en la clase {0}
implements.member.prefix=Implementación de miembros
implicit.argument.is.applicable=Se pueden aplicar argumentos implícitos.
implicit.arguments=Argumentos implícitos\:
implicit.arguments.for.implicit.conversion=Argumentos implícitos para la conversión implícita\:
implicit.class.must.have.a.primary.constructor.with.one.argument=Las clases implícitas deben tener un constructor predeterminado con exactamente un argumento en la primera lista de parámetros.
implicit.conversions.action.description=Mostrar conversión implícita
implicit.conversions.action.text=Mostrar conversión implícita
implicit.is.diverged=Se ramifica implícitamente
implicit.modifier.can.be.used.only.for=Los modificadores 'implícitos' solo se pueden usar en valores, variables, métodos y clases.
implicit.modifier.cannot.be.used.for.top.level.objects=El modificador 'implícito' no se puede utilizar en objetos de nivel superior
implicit.params.excepted=Una cláusula de parámetro implícita debe contener al menos un parámetro.
import.additional.identifiers.from.qualifier=Obtenga identificadores adicionales de los calificados
import.all.members.of.reference=Consigue todos los miembros de {0}
import.as=Importar como ''{0}''
import.class=Clase de importación
import.class.chooser.title=Clase para importar
import.conversion.chooser.title=Conversión para importar
import.expr.should.be.qualified=Las expresiones de importación deben estar normalizadas.
import.extension.method=Importar método de extensión...
import.extension.method.chooser.title=Método de extensión para obtener
import.global.member=Consigue miembros globales
import.hint.text={0}? Alt+Enter {1}
import.implicit=Obtener elementos implícitos...
import.implicit.chooser.title=Elemento implícito para obtener
import.implicit.conversion=Importar conversión...
import.multiple.choices=(selección múltiple...)
import.package=Paquete de importación
import.package.chooser.title=Paquete para importar
import.selector.expected=Se requiere selector de importación.
import.something=Importar...
import.something.chooser.title=Que traer
import.stable.member={0} importar
import.with=Importar ''{0}''
import.with.prefix=Importar con prefijo
import.with.prefix.ellipsis=Importar con prefijo...
imports.panel.add.fully.qualified.imports=Agregar declaraciones de importación completas
imports.panel.add.import.statement.in.closest.block=Agregar declaración de importación al bloque más cercano
imports.panel.add.import.to.always.mark.it.as.used=Agregue una declaración de importación para marcar como siempre utilizada
imports.panel.add.package.name=Agregar nombre del paquete
imports.panel.add.pattern.to.use.appropriate.classes.only.with.prefix=Agregue patrones para usar clases apropiadas solo usando prefijos
imports.panel.always.mark.as.used=Marcar siempre como usado
imports.panel.base.package.help=Si el paquete base es <code>org.example.application</code>, la clase <code>org.example.application.NAME</code> debe importarse con <code>import NAME</code>
imports.panel.class.count.to.use.import.with=Número de clases que utilizan declaraciones de importación con '_'\:
imports.panel.classes.to.use.only.with.prefix=Las clases a utilizar deben incluir el prefijo
imports.panel.do.not.change.path.during.optimize.imports.for.local.imports=No cambie las rutas mientras optimiza las declaraciones de importación locales
imports.panel.force.scala2.in.source3=Obtener sintaxis al usar -Xsource\:3\:
imports.panel.honestly.mark.imports.as.unused=Marcar francamente las declaraciones de importación como obsoletas
imports.panel.import.layout=Diseño de declaración de importación
imports.panel.import.layout.manager=Administrador de diseño de declaración de importación
imports.panel.imports.always.marked.as.used=Declaración de importación marcada como siempre utilizada
imports.panel.lexicographically=Alfabéticamente
imports.panel.merge.imports.with.the.same.prefix.into.one.statement=Fusionar declaraciones de importación con el mismo prefijo en una sola declaración
imports.panel.no.imports.with.prefix=No hay ninguna declaración de importación que contenga el prefijo.
imports.panel.scalastyle.consistent=Cumplimiento de Scalastyle
imports.panel.sort.imports.for.optimize.imports=Alineación de declaraciones de importación (optimización de declaraciones de importación)\:
imports.panel.title=Declaración de importación
imports.panel.use.references.with.prefix=Utilice referencias que incluyan el prefijo\:
imports.panel.use.the.shortest.path.when.trying.to.import.reference.with.already.imported.name=Utilice la ruta más corta al importar referencias con nombres ya importados
incompatible.plugin.detected=Se detectó un complemento incompatible
incrementality.type=Tipo incremental (&I)\:
indent.pasted.lines.at.caret=Sangrar líneas pegadas en la posición del cursor
indented.definitions.expected=Necesito una definición sangrada
inline.local.method.elements.header=Método local para en línea
inline.local.method.label=¿Quiere incorporar el método local {0}?
inline.local.type.alias.elements.header=Alias de tipo local en línea
inline.local.type.alias.label=¿Quiere incorporar el alias de tipo local {0}?
inline.local.variable.elements.header=Variables locales para en línea
inline.local.variable.label=¿Quiere incorporar la variable local {0}?
inline.method.elements.header=Método para en línea
inline.method.label=¿Quieres incorporar el método {0}?
inline.method.title=Método en línea
inline.occurrences.label=({0} {0,choice, 1\#donde se usa|2\#donde se usa})
inline.type.alias.elements.header=Escriba alias en línea
inline.type.alias.label=¿Quieres escribir el alias {0} en línea?
inline.type.alias.title=Alias de tipo en línea
inline.variable.elements.header=Variables para en línea
inline.variable.label=¿Quieres incorporar la variable {0}?
inline.variable.title=Variables en línea
insert.block.braces.automatically.based.on.indentation=Agregar llaves automáticamente
insert.block.braces.automatically.based.on.indentation.tooltip=Agregue llaves al editar código para convertir un bloque de una sola línea en un bloque de varias líneas
insert.pair.multiline.quotes=Insertar pares de comillas en varias cadenas
integer.literal.is.out.of.range=El literal entero está fuera del rango para el tipo int
intention.add.explicit.unit.type.annotation=Agregar anotación de tipo de unidad implícita
intention.family.put.on.one.line=Coloque {0} en una línea
intention.family.put.on.separate.lines=Coloque {0} en una línea separada
intention.for.comprehension.convert.to.parentheses=Convertir a paréntesis
intention.type.annotation.function.add.text=Agregar anotación de tipo a la definición de función
intention.type.annotation.function.regenerate.text=Regenerar anotaciones de tipo para definiciones de funciones
intention.type.annotation.function.remove.text=Eliminar anotación de tipo de la definición de función
intention.type.annotation.parameter.add.text=Agregar anotación de tipo a los parámetros
intention.type.annotation.parameter.remove.text=Eliminar anotación de tipo de los parámetros
intention.type.annotation.pattern.add.text=Agregar anotación de tipo a la definición de patrón
intention.type.annotation.pattern.remove.text=Eliminar anotación de tipo de la definición de patrón
intention.type.annotation.regen.family=Regenerar anotaciones de tipo
intention.type.annotation.toggle.family=Conversión de anotaciones de tipo
intention.type.annotation.underscore.add.text=Agregar anotación de tipo al parámetro de subrayado
intention.type.annotation.underscore.remove.text=Eliminar anotación de tipo del parámetro de guión bajo
intention.type.annotation.value.add.text=Agregar anotación de tipo a la definición de valor
intention.type.annotation.value.regenerate.text=Regenerar anotaciones de tipo para definiciones de valores
intention.type.annotation.value.remove.text=Eliminar anotación de tipo de la definición de valor
intention.type.annotation.variable.add.text=Agregar anotación de tipo a la definición de variable
intention.type.annotation.variable.regenerate.text=Regenerar anotaciones de tipo para definiciones de variables
intention.type.annotation.variable.remove.text=Eliminar anotación de tipo de la definición de variable
introduce.field.title=Extracción de campo
introduce.parameter.title=Insertar parámetro
introduce.type.alias.title=Insertar alias de tipo
introduce.variable.declare.as.var=&Variable
introduce.variable.identifier.is.not.valid=El identificador es incorrecto
introduce.variable.specify.type.explicitly=Especificar tipo
introduce.variable.title=Insertar valores/variables
introduced.typeAlias.will.conflict.with.class.name=El alias de tipo que insertó entra en conflicto con el nombre de la clase. {0}
introduced.typeAlias.will.conflict.with.type.name=El alias de tipo que insertó entra en conflicto con el nombre del tipo. {0}
introduced.variable.will.conflict.with.class.parameter=La variable insertada entra en conflicto con un parámetro de clase (o está oculta por ese elemento). {0}
introduced.variable.will.conflict.with.field=Las variables insertadas pueden entrar en conflicto con (o estar ocultas por) un campo o método sin parámetros {0}.
introduced.variable.will.conflict.with.local=La variable insertada entra en conflicto con una variable local (o está oculta por ese elemento). {0}
introduced.variable.will.conflict.with.parameter=La variable insertada entra en conflicto con el parámetro (o está oculta por ese elemento). {0}
invalid.scala.version.format=Formato de versión de Scala no válido\: {0}
invalid.update.channel=Canal de actualización no válido
is.overridden.by=El miembro ha anulado
italic.surrounder.template.description=Cursiva \: ' '
ivy2.cache=Caché Ivy2
ivy2.indexing.mode.classes=Clase
ivy2.indexing.mode.disabled=Deshabilitar
ivy2.indexing.mode.metadata=Metadatos
java.collection=Colección Java
java.constructors.only.have.one.parameter.section=Los constructores de Java tienen solo una sección de parámetros.
known.extension.libraries=Bibliotecas de extensiones conocidas
lazy.modifier.is.not.allowed.here=El modificador 'perezoso' solo está permitido para definiciones de valores.
lazy.modifier.is.not.allowed.with.param=El modificador "lazy" no está permitido; utilice en su lugar el parámetro llamada por nombre
lazy.values.may.not.be.abstract=El valor perezoso no puede ser abstracto.
lbrace.expected='{' se requiere
library.type.scala.sdk=Scala SDK
line.is.indented.too.far.to.the.left=La línea tiene una sangría demasiado a la izquierda
local.project.libraries=Biblioteca de proyectos locales
local.variables.must.be.initialized=Las variables locales deben inicializarse.
location.description.anonymous.class=Clase anónima
location.description.body.of.name=Cuerpo de {0}
location.description.containing.block=Bloque incluido
location.description.parameter.of.getclassnametext=Parámetros de {0}
location.description.parameter.of.name=Parámetros de {0}
long.literal.is.out.of.range=El número entero está incluso fuera de rango para el tipo Largo
lower.bound.conform.to.upper=El límite inferior no respeta el límite superior
lowercase.long.marker=Marcador literal largo escrito en minúsculas
lowercase.long.marker.fix=Convertir marcador literal largo a mayúsculas
macro.defs.must.have.explicit.return.type=Las definiciones de macro deben tener un tipo de retorno especificado explícitamente
main.method.parameters.table.column.title.name=Nombre
main.method.parameters.table.column.title.type=Tipo
main.method.parameters.table.column.title.value=Valor
make.explicit=Establecer explícitamente
make.explicit.and.import.method=Establecer explícitamente (método de importación)
make.implicit.conversion.explicit.action.description=Hacer explícita la conversión implícita
make.implicit.conversion.explicit.action.text=Hacer explícitas las conversiones implícitas
make.import.fully.qualified=Normalizar declaraciones de importación
make.non.private.title=Hacer que una propiedad no sea privada
make.protected.fix=Hacer una propiedad protegida
make.public.fix=Hacer pública una propiedad
make.type.more.specific=Hacer que los tipos declarados sean más específicos
make.type.more.specific.fun=Hacer que los tipos de devolución sean más específicos
match.type.cases.expected=Se requiere una cláusula de caso de tipo de coincidencia
maven.local.repo=Repositorio local de Maven
member.cannot.override.val=El método {0} requiere un valor inmutable estable
member.implementation.required={0} ''{1}'' debe declararse abstracto o ''{3}'' debe implementar el miembro abstracto ''{2}''
member.is.not.defined=El miembro {0} de {1} no está definido
member.needs.override.modifier={0} ''{1}'' requiere anular el controlador
member.of.anonymous.class.cannot.be.used.in.extracted.member=El miembro {0} de la clase anónima no se puede utilizar en el miembro extraído {1}
member.overrides.nothing={0} ''{1}'' no anula nada
members.to.extract=Miembro para extraer
method.annotated.with.tailrec.contains.no.recursive.calls=El método anotado @tailrec no contiene una llamada recursiva
method.annotated.with.tailrec.is.neither.private.nor.final=Los métodos anotados con @tailrec no son privados ni finales (pueden anularse)
method.invocation.might.produce.nullpointerexception=La llamada al método puede causar NullPointerException
method.invocation.will.produce.nullpointerexception=La llamada al método arroja NullPointerException
method.is.not.member=El método {0} no es miembro del tipo {1}
method.is.overridden.by.class.parameter.of.class=El método ha sido anulado por un parámetro de clase de {0}. No se admite la conversión de esto a una definición de función.
method.is.overridden.in.a.composite.pattern.definition=El método se ha anulado en la definición de patrón complejo de {0}. No se admite la conversión de esto a una definición de función.
method.is.overridden.in.a.composite.variable.definition=El método se ha anulado en la definición de variable compleja de {0}. No se admite la conversión de esto a una definición de función.
method.is.recursive=El método ''{0}'' es recursivo
method.is.tail.recursive=El método ''{0}'' es recursivo de cola
method.of.containingclass={0} de {1}
missing.argument.list.for.method=Falta lista de argumentos para el método {0}
missing.argument.list.for.method.with.explicit.list=Falta la lista de argumentos {0} para el método {1}
missing.char.value=Valor de carácter faltante
missing.getter.implementation=Falta implementación para getter\: {0}
missing.parameter.type.name=Tipo de parámetro faltante\: {0}
missing.setter.implementation=Falta implementación para setter\: {0}
missing.statement.for.annotation=Falta sintaxis para anotaciones
mixin.required=''{3}'' Mi miembro ''{2}'' está marcado como ''abstracto'' y ''override'', pero no se puede encontrar ninguna implementación concreta en la clase base, por lo que {0} ''{ 1}'' debe ser una mezcla
modifier.is.redundant.for.this.definition=El modificador ''{0}'' no es necesario para esta definición.
modify.method.calls=Editar llamada al método
module.with.a.scala.sdk=Módulos que contienen el SDK de Scala
monospace.surrounder.template.description=ancho fijo\: ' '
move.anonymousToInner.dialog.title=Convertir anónimo a interno
move.anonymousToInner.name=Convertir anónimo a interno…
move.members=Mover miembros
move.members.cannot.find.object=No se encontró ningún objeto con ese nombre.
move.members.not.supported.implicits=La refactorización de movimientos no es compatible con definiciones implícitas
move.members.not.supported.overridden=La refactorización de movimientos no es compatible con definiciones anuladas
move.members.object.name.or.qualified.name.expected=Requiere el nombre o el nombre completo del objeto Scala
move.members.source.title=Mover miembro en objeto\:
move.members.supported.only.stable.objects=La refactorización de movimientos solo es compatible con miembros de objetos estables
move.members.target.title=Al objeto\:
move.text.after.header.to.new.line=Mover texto a una nueva línea después de cerrar el encabezado
move.to.inner.is.not.supported=Scala no admite el movimiento de clases hacia adentro
move.to.inner.is.not.supported.title=La refactorización no es compatible
move.with.companion=Ir con un acompañante
multi.line.string.panel.align.dangling.closing.quotes=Asignar una comilla de cierre imaginaria (&A)
multi.line.string.panel.insert.margin.char.on.enter=Inserte un carácter de espacio (&I) en una nueva línea al escribir Enter
multi.line.string.panel.margin.char.indent=Caracteres de margen de sangría \:
multi.line.string.panel.margin.char.value=Carácter de margen\:
multi.line.string.panel.opening.quotes.on.new.line=Coloque una comilla de apertura (&O) en una nueva línea
multi.line.string.panel.place.closing.quotes.on.new.line.on.enter.press=Coloque comillas de cierre (&C) en una nueva línea al escribir Enter
multi.line.string.panel.process.margin.on.copy.paste=&Eliminar/Insertar márgenes al copiar/pegar
multi.line.string.panel.title=Cadena multilínea
multi.occurrences=({0} líneas coincidentes)
multiple.overriden.tooltip=Varios miembros anulados
multiple.overriding.tooltip=Múltiples miembros primordiales
name.does.not.take.type.arguments={0} no acepta argumentos de tipo
name.implements.member.of.qualname={0} implementa los miembros de {1}
name.overrides.member.of.qualname={0} redefine un miembro de {1}
navigate=Navegar
navigation.findUsages.title.implementing.member=Miembro de implementación de {0}
navigation.findUsages.title.inheritors.class=Subclase de {0}
navigation.findUsages.title.inheritors.trait=Implementación de {0}
navigation.findUsages.title.overriding.member=Anular miembro de {0}
navigation.findUsages.title.super.members=Miembro padre de {0}
navigation.findUsages.title.super.types=Miembro supertipo de {0}
navigation.title.implementing.member=<html>Seleccione miembros de implementación de <b>{0}</b> ({1} miembros encontrados)</html>
navigation.title.inheritors.class=<html>Seleccione subclases de <b>{0}</b> ({1} clases encontradas)</html>
navigation.title.inheritors.trait=<html>Seleccione la implementación de <b>{0}</b> ({1} clases encontradas)</html>
navigation.title.overriding.member=<html>Seleccione anular miembro de <b>{0}</b> (miembro {1} encontrado)</html>
navigation.title.super.members=Seleccione miembro padre de {0}
navigation.title.super.types=Seleccione el tipo de padre miembro de {0}
new.class.location.inner.in.class=Dentro de {0}
new.class.location.local.scope=Alcance local
new.class.location.new.file=Archivo nuevo
new.class.location.top.level.in.this.file=Nivel superior de este archivo
new.on.case.class.instantiation.redundant=Eliminar el controlador 'nuevo'
new.packageobject.menu.action.description=Crear un nuevo objeto de paquete Scala
new.packageobject.menu.action.text=Objeto de paquete
newclass.menu.action.description=Crear una nueva clase de Scala
newclass.menu.action.text=Clases de escala
newclassorfile.menu.action.description=Crear una nueva clase o archivo de Scala
newclassorfile.menu.action.text=Clase/archivo Scala
no.alias.type=No hay ningún tipo de alias
no.clazz.type.found=Tipo de clase no encontrado
no.containing.file=No hay archivos que contengan
no.declared.type.found=Tipo declarado no encontrado
no.defined.return.type=No hay ningún tipo de devolución definido
no.element.found=Elemento no encontrado
no.expected.type.for.wildcard.naming=No hay ningún tipo requerido para los nombres comodín
no.expression.in.parentheses=Sin expresión entre paréntesis
no.implicit.arguments=Sin argumentos implícitos
no.implicit.arguments.of.type=No hay argumentos de tipo implícitos. {0}
no.implicits.applicable.by.type=No hay elementos implícitos aplicables a cada tipo.
no.known.extension.libraries=No se conocen bibliotecas de extensiones
no.program.arguments=No hay argumentos de programa.
no.response.status.from.connection.to.url=No se recibió ningún estado de respuesta de la conexión {0}
no.type.element.for.typed.pattern=Ningún elemento de tipo para el patrón de tipo
no.type.element.found=Elemento de tipo no encontrado en ''{0}''
no.type.inferred=No se puede inferir el tipo de expresión ''{0}''
no.type.inferred.for.unknown.expression=No hay ningún tipo inferido para esa expresión.
no.type.pattern=No hay ningún patrón de tipo
no.versions.available.for.download=No hay versiones descargables.
not.a.polymorphic.lambda=No es una lambda polimórfica.
not.enough.parameter.sections=La sección de parámetros no es suficiente.
not.found.scala.xml.node=No se puede encontrar scala.xml.Node
nothing.to.type=El tipo no se pudo calcular
notification.navigation.to.overriding.members=No puede navegar a miembros reemplazantes durante una actualización de índice
nullable.to.notnull.param.always.message=Null se pasa a los parámetros anotados con @NotNull.
nullable.to.notnull.param.sometimes.message=A los parámetros anotados con @NotNull se les pasan argumentos que pueden ser nulos.
nullable.to.unannotated.param.always.message=Null se pasa a un parámetro que tal vez no pueda manejar valores nulos. Intente agregar una anotación con @Nullable.
nullable.to.unannotated.param.sometimes.message=Los argumentos que pueden ser nulos se pasan a parámetros que tal vez no puedan manejar valores nulos. Intente agregar una anotación con @Nullable.
numeric.literal.family=Literal numérico
object.creation.impossible.since={0}, por lo tanto no se puede crear el objeto
octal.literals.removed=La sintaxis literal octal no está disponible desde Scala 2.11
only.classes.can.be.open=Sólo se pueden abrir clases.
only.for.scala=Esto sólo funciona para archivos Scala
only.inline.methods.may.have.inline.args=El modificador 'inline' solo se puede usar en argumentos de métodos en línea
opaque.modifier.allowed.only.for.type.aliases=El modificador 'opaco' solo se permite en alias de tipo
optimise.bytecode=Optimización de código de bytes (&úselo con precaución*)
optimise.bytecode.tooltip=Aplique optimizaciones a sus programas para producir códigos de bytes más rápidos. Úselo con precaución ya que pueden ocurrir varios problemas de compilación.
options=Opción
options.scala.display.name=Scala
other.panel.alternate.indentation.for.constructor.args.and.parameter.declarations=Sangría alternativa para declaraciones de parámetros y argumentos del constructor\:
other.panel.enforce.functional.syntax.for.methods.with.unit.return.type=Sintaxis de función forzada para métodos con tipo de retorno Unidad
other.panel.implicit.class.prefix.suffix=Prefijo/sufijo de clase implícito
other.panel.kind.projector.replace.lambda.with.unicode.symbol=Kind Proyector\: Convertir 'Lambda' a símbolo Unicode
other.panel.reformat.on.compile=Reformatear en tiempo de compilación
other.panel.replace.in.for.generator.with.unicode.symbol=Convirtiendo '<-' en el generador "for" a un símbolo Unicode
other.panel.replace.with.unicode.symbol=Convertir '\=>' al símbolo Unicode
other.panel.replace.with.unicode.symbol1=Convertir '->' a símbolo Unicode
other.panel.spaces=brecha
other.panel.title=Otros
out.of.compilation.unit=Fuera de la unidad de compilación
output.dir=Directorio de salida
override.modifier.is.not.allowed=El modificador 'anular' no está permitido
override.modifier.is.not.allowed.for.classes=El modificador 'anular' solo está permitido en miembros de definición de tipo
override.types.not.conforming=El tipo de anulación {0} no se ajusta al tipo base {1}
overrides.member.from.prefix=Anular miembro en
overrides.member.from.several.classes=Anulando miembros en la clase {0}
overrides.type.from.super.several.classes=Redefiniendo el tipo de clase {0}
overrides.type.prefix=Redefinición de tipo
package.prefix.example=Ejemplo\: 'org.ejemplo.aplicación'
package.prefix.help=Si el prefijo del paquete es <code>org.example.application</code>, <code>PATH</code> en el directorio fuente significa <code>org/example/application/PATH</code>, entonces hay No es necesario crear los subdirectorios <code>org</code>, <code>example</code> y <code>application</code>.
package.prefix.label=Prefijo de paquete\:
package.qualID.expected=Se requiere un identificador completo del paquete
param.clause.expected=Se requiere cláusula de parámetro
parameter.could.not.be.repeated.and.by.name=No puede ser una llamada por nombre con ambos parámetros repetidos
parameter.expected=Parámetros requeridos
parameter.info.not.matchable=<not matchable>
parameter.label.default.value=Valor por defecto\:
parameter.label.name=Nombre\:
parameter.label.type=Tipo\:
parameter.type.expected=Se requiere el tipo de parámetro
parameterised.trait.is.implemented.indirectly=La propiedad parametrizada {0} se implementa indirectamente. Para que se pasen argumentos, deben implementarse directamente.
passed.as.by.name.parameter=Pasado como parámetro de llamada por nombre.
pattern.expected=Necesito un patrón
pattern.on.refinement.unchecked=La coincidencia de patrones de tipos materializados no está marcada
pattern.type.incompatible.with.expected=El tipo de patrón no es compatible con el tipo requerido. Encontrado\: {0}, Requerido\: {1}
please.select.scala.plugin.update.channel=Seleccione el canal de actualización del complemento Scala.
poly.function.without.parameters=La función polimórfica {0} debe tener un parámetro de valor
presentable.definition.unnamed=No se ha especificado ningún nombre
presentable.type.unnamed=Escriba sin nombre
press.alt.enter=Presione Alt+Entrar
press.escape.to.remove.the.highlighting=Presione ESC para eliminar el resaltado
press.hotkey.to.show.more.options=Presione ctrl + alt + v para mostrar un cuadro de diálogo con más opciones
private.member.cannot.be.used.in.extracted.member=El miembro privado {0} no se puede utilizar en el miembro extraído {1}
problem.prefix.ambiguous=(ambiguo)
problem.prefix.not.found=(extraviado)
process.duplicates=Procesamiento duplicado
processing.imports.modified.during.refactoring=Procesamiento de elementos importados modificados durante la refactorización
provide.program.arguments=Proporcionar argumentos del programa
pull.method.to=Desempaqueta el método ''{0}'' en...
pull.up.members.from=Mover al siguiente miembro hacia arriba
pull.value.to=Resuelva el valor ''{0}'' en...
pull.variable.to=Desempaquetar la variable ''{0}'' en...
rbrace.expected='}' se requiere
rearranger.panel.keep.java.style.getters.and.setters.together=Mantener juntos los captadores y definidores de estilo Java
rearranger.panel.keep.scala.style.getters.and.setters.together=Mantener juntos los captadores y definidores de estilo Scala
rearranger.panel.split.into.unarrangeable.blocks.by.expressions=Dividir en bloques que no se pueden clasificar debido a expresiones
rearranger.panel.split.into.unarrangeable.blocks.by.implicits=Dividido en bloques que no se pueden ordenar debido a definiciones implícitas
reason.prefix.applicable=Aplicable\:
reason.prefix.candidate=Candidato\:
reason.prefix.cannot.infer.type=No se puede inferir el tipo\:
reason.prefix.diverged=Ramificado\:
recursive.call.not.in.tail.position=La llamada recursiva no está en la posición final (en un método anotado con @tailrec)
recursive.non.value.type.of.type.element=Tipo recursivo, no el valor del elemento de tipo.
recursive.type.of.type.element=Tipo recursivo de elemento de tipo
refactoring.is.not.supported.contains.return=No se admite la refactorización. Hay una declaración de devolución en el rango de selección.
refactoring.is.not.supported.in.guard=La refactorización no es compatible con los guardias y puede romper la estructura del código.
refresh.roots.synchronizing.output.directories=Sincronizando directorio de salida...
regular.method.overrides.extension=El método {0} es un método normal y no se puede anular como método de extensión.
remove.all.erroneous.semicolons.from.forexpression=Eliminar todos los puntos y comas no válidos en las expresiones
remove.block.braces.automatically.based.on.indentation=Quitar brackets automáticamente
remove.block.braces.automatically.based.on.indentation.tooltip=Al editar código, elimine las llaves al cambiar un bloque de varias líneas a un bloque de una sola línea
remove.braces.from.import=Eliminar llaves de la declaración de importación
remove.case=Quitar 'caso'
remove.case.clause=Eliminar cláusula de caso
remove.catch=Quitar bloque de captura
remove.finally=Eliminar bloque finalmente
remove.generic=Eliminar {0}
remove.named.modifier.fix=Elimina el controlador ''{0}''
remove.return.keyword=Eliminar palabra clave de retorno
remove.unnecessary.parentheses=Eliminar paréntesis innecesarios
remove.val=Eliminar 'valor'
rename=Cambiar nombre
rename.aliased.rename.actual=Cambiar el nombre del elemento real.
rename.aliased.title=No se admite el cambio de nombre de los alias de importación
rename.all.base.members=Cambiar los nombres de todos los miembros predeterminados
rename.base.member=Cambiar el nombre de un miembro predeterminado
rename.cancel=Cancelar
rename.companion.module=Cambiar el nombre del compañero {0}
rename.getters.and.setters.title=La función contiene un captador o definidor con el mismo nombre. ¿También te gustaría cambiar el nombre de este artículo?
rename.has.multiple.base.members={0} tiene varios miembros predeterminados
rename.only.current.member=Cambiar el nombre únicamente del miembro actual
rename.only.in=Cambiar nombre solo en {0} {1}
rename.special.method.rename.class=Cambiar nombre que contiene {0}
rename.special.method.title=No puedes cambiar el nombre de este método.
repeated.param.non.method=Los parámetros repetidos sólo se permiten en las firmas de métodos. Utilice 'Seq' en su lugar
replace.all.occurrences=Reemplazar todos los elementos encontrados
replace.all.x.occurrences=Reemplazar todos los {0} elementos encontrados
replace.fun.type=Cambie la función N[A1, A1, ..., AN, R] a (A1, A1, ..., AN) \=> R
replace.occurrences.available.from.companion.class=Reemplazar elemento encontrado en la clase complementaria {0}
replace.tag.with.esc.seq=Reemplazar etiquetas con secuencias de escape
replace.tuple.type=Convertir TuplaN[A1, A1, ..., AN] a (A1, A1, ..., AN)
replace.with.type=Reemplazar con ''{0}''
replace.with.wiki.syntax=Conversión de etiquetas en línea a sintaxis wiki de ancho fijo
report.highlighting.error.fix=Informar de un error de resaltado...
resolving.compiler.bridge.progress.message=Resolviendo el puente del compilador
response.to.connection.to.url.was.code=La respuesta recibida de la conexión {0} es ''{1}''
return.expression.is.redundant=Devolviendo {0} del método con tipo de resultado Unidad
return.outside.method.definition=Declaración de retorno fuera de la definición del método
right.brace.expected='}' se requiere
rparenthesis.expected=')' se requiere
rsqbracket.expected=']' se requiere
scala.3.support.is.experimental=La compatibilidad con Scala 3 está en desarrollo activo.<br>Aproveche las nuevas mejoras utilizando nuestras compilaciones nocturnas.
scala.collection.highlighting.type.all=Cada
scala.collection.highlighting.type.none=Ninguno
scala.collection.highlighting.type.only.non.qualified=Sólo elementos no normalizados
scala.compiler.profiles.panel.create.new.profile=Crear un nuevo perfil
scala.compiler.profiles.panel.move.to=Ir al siguiente
scala.compiler.profiles.panel.profile.already.exists=El perfil {0} ya existe
scala.compiler.profiles.panel.profile.name=Nombre de perfil
scala.compiler.profiles.panel.profile.should.not.be.empty=El nombre del perfil no puede estar en blanco
scala.immutable.collection=Colección inmutable
scala.library.editor.form.compiler.bridge.jar=Puente del compilador\:
scala.library.editor.form.compiler.classpath=Ruta de clase del compilador\:
scala.library.editor.form.scala.version=Versión Scala\:
scala.library.editor.form.standard.library=Biblioteca estándar\:
scala.line.markers=Marcador de línea escala
scala.meta.mode.disabled=Deshabilitar
scala.meta.mode.enabled=Activado
scala.meta.mode.manual=Manual
scala.mutable.collection=Colección de variables
scala.notification.group.id.features.advertiser=Anunciante de funciones de Scala
scala.notification.group.id.general=Escala (general)
scala.notification.group.id.java.to.scala.converter=Convertidor de Java a Scala
scala.notification.group.id.plugin.updater=Actualizador de complementos de Scala
scala.notification.group.id.plugin.verifier=Verificador de complementos de Scala
scala.notification.group.id.sbt.project.import=Importar proyecto SBT
scala.notification.group.id.sbt.shell=Cáscara SBT
scala.notification.group.id.scala3.disclaimer=Descargo de responsabilidad de Scala 3
scala.notification.group.id.scalafmt=Scalafmt
scala.notification.group.id.scalafmt.fatal.errors=Error fatal de Scalafmt
scala.notification.group.id.scalafmt.format.errors=Error de formato de Scalafmt
scala.plugin.chanel.eap=Programa de acceso temprano
scala.plugin.chanel.nightly=Construcción nocturna
scala.plugin.chanel.release=Lanzamiento estable
scala.plugin.update=Actualizaciones del complemento Scala
scala.project.data.service.scalaLibraryNotFound=No se puede configurar el SDK de Scala para el módulo ''{0}'' (no se encontró la biblioteca de Scala del proyecto {1} para el módulo ''{0}'')
scala.project.settings=Configurar un proyecto Scala
scala.project.settings.form.add.override.keyword.to.method.implementation=Agregar palabra clave de anulación a la implementación del método
scala.project.settings.form.ahead.of.time.completion=Completar código de diccionario (nombres de parámetros y variables)
scala.project.settings.form.alias.definition=Justicia
scala.project.settings.form.alias.export=Exportar
scala.project.settings.form.alias.export.semantics=Alias para Scala y Scala.Predef\:
scala.project.settings.form.autocomplete=Autocompletar
scala.project.settings.form.automatically.convert.to.scala.code.without.dialog=Se convierte automáticamente a código Scala sin mostrar un cuadro de diálogo al pegar
scala.project.settings.form.base.package.custom=Usar personalizado\:
scala.project.settings.form.base.package.inherit=Heredar del prefijo del paquete en la carpeta fuente
scala.project.settings.form.check.for.updates=Revisalo ahora
scala.project.settings.form.code.conversion=Conversión de código
scala.project.settings.form.collapse.long.output.by.default=Contraer salida larga de forma predeterminada
scala.project.settings.form.collection.type.highlighting.option=Resaltar tipo de colección\:
scala.project.settings.form.convert.java.code.to.scala.on.copy.paste=Convierta código Java a Scala al copiar y pegar
scala.project.settings.form.custom.scalatest.keywords.highlighting=Resaltado de palabras clave de scalaTest personalizado
scala.project.settings.form.delay.before.auto.run=Retraso antes de la ejecución automática\:
scala.project.settings.form.delay.before.auto.run.units=Milisegundos
scala.project.settings.form.disable.language.injection.in.scala.files=<html>Deshabilite la inyección de idioma en archivos Scala.<br>(Los idiomas integrados pueden hacer que la finalización automática de la ventana emergente deje de escribir)</html>
scala.project.settings.form.disable.parsing.of.documentation.comments=<html>Deshabilite el análisis de comentarios de documentos.<br>Esto puede mejorar el rendimiento del editor cuando se trabaja con archivos grandes.</html>
scala.project.settings.form.dont.cache.compound.types=No almacene en caché tipos complejos (úselo si se producen bloqueos graves en GC)
scala.project.settings.form.error.highlighting=Error al resaltar
scala.project.settings.form.error.highlighting.use.compiler.ranges=Utilice rangos de texto informados por el compilador de Scala
scala.project.settings.form.group.package.object.with.package=Agrupar y agrupar objetos de paquete con paquetes.
scala.project.settings.form.highlight.arguments.to.by.name.parameters=Resalte los argumentos para los parámetros de llamada por nombre
scala.project.settings.form.highlight.implicit.conversions=Resaltado de conversión implícita
scala.project.settings.form.highlight.nodes.with.errors=Resaltar nodos con errores
scala.project.settings.form.highlighting=Destacar
scala.project.settings.form.implicit.parameters.search.depth=Profundidad de búsqueda de parámetros implícitos (-1 si no hay ninguno)\:
scala.project.settings.form.include.block.expressions=Contiene expresiones de bloque
scala.project.settings.form.include.literals=Contiene literales
scala.project.settings.form.info=Siempre puedes volver a una versión más estable seleccionando "Versión estable" o "Programa de acceso anticipado".
scala.project.settings.form.output.cutoff.limit=Límite de corte de salida\:
scala.project.settings.form.output.cutoff.limit.units=filas
scala.project.settings.form.plugin.update.channel=Actualización del canal\:
scala.project.settings.form.run.worksheet.in.the.compiler.process=Ejecutar una hoja de trabajo en el proceso del compilador (solo modo normal)
scala.project.settings.form.sbt.index.ivy2.mode=Modo de indexación de caché local ivy2
scala.project.settings.form.sbt.index.ivy2.mode.hint=Deshabilitado: no se realiza ninguna indexación\nMetadatos: solo indexa el nombre y la versión de la biblioteca. Se utiliza para completar la dependencia del archivo SBT\nClase: indexa los nombres de las clases en la memoria caché. Se utiliza para la solución rápida 'Agregar dependencia SBT'
scala.project.settings.form.scala.meta.settings.annot212=scala.meta 프로그램 실행
scala.project.settings.form.scala.meta.settings.annot212.tooltip=Debido a la compatibilidad binaria, las anotaciones en el módulo 2.12 deben utilizar serialización y análisis basados en cadenas, lo cual es muy lento. Esto puede tener un impacto grave en el rendimiento general.
scala.project.settings.form.scala.meta.settings.modeOptions.tooltip=Habilitado: todos los metaprogramas se ejecutan durante la inferencia de tipos\nDesactivado: los metaprogramas se omiten durante la inferencia de tipos\nManual: los metaprogramas se ejecutan solo si se expanden manualmente
scala.project.settings.form.scala.meta.settings.trimBodies.caption=El cuerpo del método Trim se extiende mediante scala.meta
scala.project.settings.form.scala.meta.settings.trimBodies.tooltip=Depende del tipo de retorno explícito del método generado (el cuerpo se reemplaza por ???). Acelere la inferencia de tipos omitiendo el método de verificación del tipo de cuerpo.
scala.project.settings.form.scalatest.default.super.class=Clase principal predeterminada de ScalaTest\:
scala.project.settings.form.search.all.symbols=Buscar todos los símbolos (incluidos los símbolos locales)
scala.project.settings.form.show.hints.if.ambiguous.implicit.arguments.found=Mostrar sugerencias cuando se encuentran argumentos implícitos ambiguos
scala.project.settings.form.show.hints.if.no.implicit.arguments.found=Mostrar sugerencia si no se encuentra el argumento implícito
scala.project.settings.form.show.type.mismatch.hints=Sugerencia mostrada en caso de que el tipo no coincida
scala.project.settings.form.tabs.base.package=Paquete básico
scala.project.settings.form.tabs.base.packages=Paquete básico
scala.project.settings.form.tabs.editor=Editor
scala.project.settings.form.tabs.extensions=Expansión
scala.project.settings.form.tabs.misc=Otros
scala.project.settings.form.tabs.performance=Actuación
scala.project.settings.form.tabs.project.view=Vista del proyecto
scala.project.settings.form.tabs.updates=Actualizar
scala.project.settings.form.tabs.worksheet=Hoja de cálculo
scala.project.settings.form.tabs.xray.mode=Modo de rayos X
scala.project.settings.form.trailing.commas=Coma final\:
scala.project.settings.form.treat.sc.files.as=Procesar el archivo .sc con\:
scala.project.settings.form.treat.scala.scratch.files.as.worksheet.files=Procesar el archivo temporal de Scala como archivo de hoja de trabajo
scala.project.settings.form.use.eclipse.compatibility.mode=Utilice el modo 'compatibilidad con eclipse'
scala.project.settings.form.use.scala.classes.priority.over.java=Prefiere las clases de Scala a las clases de Java
scala.project.settings.form.xray.activate=Fecha de activacion:
scala.project.settings.form.xray.by-name.argument.hints=Sugerencias de argumentos pasadas por nombre
scala.project.settings.form.xray.double.press.and.hold=Presione Ctrl dos veces y mantenga presionado
scala.project.settings.form.xray.implicit.hints=Pista implícita
scala.project.settings.form.xray.indent.guides=Guía de sangría
scala.project.settings.form.xray.lambda.parameters=Parámetro lambda
scala.project.settings.form.xray.lambda.placeholders=Marcador de posición lambda
scala.project.settings.form.xray.local.variables=Variable local
scala.project.settings.form.xray.member.variables=Variable miembro
scala.project.settings.form.xray.method.chain.hints=Sugerencia de cadena de métodos
scala.project.settings.form.xray.method.results=Resultado del método
scala.project.settings.form.xray.method.separators=Separador de métodos
scala.project.settings.form.xray.parameter.name.hints=Sugerencia de nombre de parámetro
scala.project.settings.form.xray.press.and.hold=Mantenga presionada la tecla Ctrl una vez
scala.project.settings.form.xray.show=Marca\:
scala.project.settings.form.xray.type.hints=Escriba sugerencias\:
scala.project.settings.form.xray.variable.patterns=Patrón variable
scala.project.settings.form.xray.widget=Aparatos\:
scala.project.settings.form.xray.widget.display=Marca\:
scala.root.code.style.panel.formatter=Herramientas de formato\:
scala.sdk.component.name.compiler.classpath=Ruta de clase del compilador
scala.sdk.component.name.library=Biblioteca
scala.sdk.component.name.library.scaladoc=Biblioteca escaladoc
scala.sdk.component.name.library.source=Fuente de la biblioteca
scala.sdk.descriptor.contains.duplicated.files=Hay un archivo {0} duplicado en el descriptor del SDK de Scala.
scala.sdk.selection.button.browse=Navegar...
scala.sdk.selection.button.download=Descargar...
scala.type.aware.highlighting.indicator=Indicador resaltado de reconocimiento de tipo Scala
scala3.panel.title=Scala 3
scala3.panel.use.indentation.based.syntax=Utilice sintaxis basada en sangría
scaladoc.noon=Scaladoc
scaladoc.panel.add.additional.space.for.leading.asterisk=Agregue espacio al asterisco inicial
scaladoc.panel.after.parameter.comments=Después de la descripción del parámetro
scaladoc.panel.after.tags=Después de regresar
scaladoc.panel.align.other.tags.descriptions=Otra etiqueta Descripción Ordenar
scaladoc.panel.align.parameter.descriptions=Parámetro Descripción Ordenar
scaladoc.panel.align.return.value.description=Valor de retorno Descripción Ordenar
scaladoc.panel.align.throws.exception.descriptions=Lanzar excepción Descripción Ordenar
scaladoc.panel.before.parameter.descriptions=Antes de la descripción del parámetro
scaladoc.panel.before.tags=Delante de la etiqueta
scaladoc.panel.between.parameter.descriptions=Entre descripciones de parámetros
scaladoc.panel.blank.lines.keep=Mantener (las líneas en blanco entre etiquetas no se eliminan)
scaladoc.panel.enable.scaladoc.formatting=Habilitar el formato Scaladoc
scaladoc.panel.groups.alignment=Clasificar
scaladoc.panel.groups.blank.lines=Linea en blanco
scaladoc.panel.groups.other=Otros
scaladoc.panel.preserve.spaces.in.tags=Mantener espacios dentro de las etiquetas
scaladoc.panel.title=ScalaDoc
scaladoc.parsing.closing.code.tag.before.opening=Cerrar etiqueta de código antes de abrir
scaladoc.parsing.closing.link.tag.before.opening=Cerrar etiqueta de enlace antes de abrir
scaladoc.parsing.cross.tags=Etiqueta cruzada
scaladoc.parsing.error.bad.token=Error\: Token no válido\: {0}
scaladoc.parsing.header.closed.by.opening.new.one=Encabezado cerrado cuando se abre un nuevo encabezado
scaladoc.parsing.inline.tag=Etiquetas en línea
scaladoc.parsing.missing.tag.param=Parámetro de etiqueta faltante
scaladoc.parsing.no.closing.element=Sin elemento de cierre
scaladoc.parsing.open.syntax.element=Elemento de sintaxis abierta
scaladoc.parsing.unclosed.code.tag=Etiqueta de código abierto
scaladoc.parsing.unexpected.end.of.tag.body=Final del cuerpo de la etiqueta inesperado
scaladoc.parsing.unknown.tag=Etiqueta desconocida\: {0}
scaladoc.parsing.wiki.syntax.closed.by.inner.code.tag=Etiqueta de código interno
scaladoc.parsing.wiki.syntax.closed.by.new.paragraph=Nuevo párrafo
scaladoc.parsing.wiki.syntax.closed.by.tag=Etiqueta
scaladoc.parsing.wiki.syntax.element.closed.by.message=Elemento de sintaxis Wiki cerrado basado en {0}
scalafmt.can.not.create.config.file=No se puede crear el archivo de configuración
scalafmt.can.not.find.config.file=Archivo de configuración no encontrado. {0}
scalafmt.can.not.find.config.file.create.new=Crear nuevo archivo
scalafmt.can.not.find.config.file.go.to.settings=Configuración...
scalafmt.config.load.actions.open.config.file=Abrir archivo de configuración
scalafmt.config.load.errors.cyclic.includes.detected=Incluye circular detectada
scalafmt.config.load.errors.failed.to.load.config=No se pudo cargar la configuración de Scalafmt
scalafmt.config.load.errors.parse.error=Error de análisis\: {0}
scalafmt.default=Por defecto
scalafmt.default.path=Valor por defecto\: {0}
scalafmt.download=Descargar
scalafmt.format.errors.failed.to.find.correct.surrounding.code=Error de Scalafmt ({0})\:<br> No se pudo encontrar el código adjunto correcto para pasar a scalafmt. No se realiza ningún formateo.
scalafmt.format.errors.scala.file.parse.error=Error de análisis de Scalafmt ({0})\:<br>{1}
scalafmt.picked.new.config=Nueva configuración de estilo (v{0}) aplicada a Scalafmt
scalafmt.progress.downloading.scalafmt.version=Descargando la versión Scalafmt {0}
scalafmt.progress.downloading.scalafmt.version.cancel=Descarga detenida
scalafmt.progress.resolving.scalafmt.version=Resolviendo la versión de Scalafmt {0}
scalafmt.progress.resolving.scalafmt.version.cancel=Deja de resolver
scalafmt.progress.version.was.downloaded=Se ha descargado la versión {0} de Scalafmt
scalafmt.resolve.again=Resuelto de nuevo
scalafmt.resolve.errors.cant.resolve.scalafmt.version=No se pudo resolver la versión {0} de Scalafmt
scalafmt.resolve.errors.classpath.is.corrupted=Classpath está corrupto
scalafmt.resolve.errors.download.is.in.progress=La descarga está en curso.
scalafmt.resolve.errors.downloading.error.occurred=Error al descargar
scalafmt.resolve.errors.unknown.error=Error desconocido
scalafmt.resolve.errors.version.is.not.downloaded.yet=La versión ''{0}'' de Scalafmt no se ha descargado.<br>¿Quieres descargarla?
scalafmt.settings.panel.configuration.label=Composición
scalafmt.settings.panel.errors.cant.find.config.file=No se pudo encontrar el archivo de configuración de Scalafmt con la siguiente ruta:<br> {0}
scalafmt.settings.panel.errors.cant.resolve.version=No se puede resolver la versión scalafmt {0}
scalafmt.settings.panel.errors.failed.to.parse.config=Error en el análisis de configuración.<br> {0}
scalafmt.settings.panel.fallback.to.default.settings=Volver a la configuración predeterminada de IntelliJ
scalafmt.settings.panel.no.config.found.under.path.using.default=Archivo de configuración no encontrado en la ruta especificada
scalafmt.settings.panel.reformat.on.file.save=Reformatear al guardar ({0})
scalafmt.settings.panel.reformat.on.file.save.tooltip=Sugerencia\: Utilice ''Reformatear código'' ({0})
scalafmt.settings.panel.scalafmt.version.label=Versión escalafón
scalafmt.settings.panel.select.custom.scalafmt.configuration.file=Seleccione un archivo de configuración Scalafmt personalizado
scalafmt.settings.panel.show.warnings.when.formatting.invalid.code=Mostrar una advertencia cuando se intenta formatear el código incorrectamente
scalafmt.settings.panel.use.intellij.formatter.for.code.range.formatting=Utilice herramientas de formato IntelliJ para formatear rangos de códigos
scalafmt.settings.panel.use.intellij.formatter.for.code.range.formatting.warning.tooltip=El uso de Scalafmt para formatear rangos de código puede causar inconsistencias en el código.<br>Scalafmt está diseñado para usarse solo al formatear archivos completos que contienen código Scala.
scalafmt.suggester.detected.in.project=Se ha detectado una configuración de Scalafmt en su proyecto. ¿Le gustaría habilitar la herramienta de formato Scalafmt?
scalafmt.suggester.dont.show=No mostrar
scalafmt.suggester.enable=activar
scope.file=archivo
scope.selection=Rango de selección
script.file.mode.always.ammonite=Siempre amonita
script.file.mode.always.worksheet=Siempre hoja de trabajo
script.file.mode.ammonite.in.test.sources.otherwise.worksheet=Amonita en la fuente de prueba. De lo contrario Hoja de trabajo
scrutinee.incompatible.pattern.type=El escrutador no es compatible con el tipo de patrón. Encontrado\: {0}, Requerido\: {1}
sdk.create.select.files=Seleccione un JAR para el nuevo SDK de Scala
sdk.notification.provider.no.scala.sdk.in.module=El módulo no tiene Scala SDK
sdk.notification.provider.setup.scala.sdk=Instalar el SDK de Scala
sdk.scan.title=Buscando el SDK de Scala\: {0}
sdk.table.model.docs=Documento
sdk.table.model.location=Ubicación
sdk.table.model.sources=Salsa
sdk.table.model.version=Versión
sdkman=SDKMAN\!
sealed.modifier.is.not.allowed.here=El modificador 'sellado' no está permitido.
searching.for.overriding.members=Anular la búsqueda de miembros
select.library.from.the.list.above=Seleccione una biblioteca de la lista anterior
select.method.implement=Seleccionar miembros para implementar
select.method.override=Seleccionar miembro para anular
selected.file.is.not.a.valid.jar.file=El archivo seleccionado no es un archivo jar válido
semi.expected=';' o necesitas una nueva línea
semicolon.not.allowed.here=Aquí no se permiten puntos y coma
show.implicit.arguments.action.description=Muestra argumentos implícitos.
show.implicit.arguments.action.text=Mostrar argumentos implícitos
simple.pattern.expected=Inicio incorrecto de patrón simple
spaces.panel.after.colon.before.declarations.type=Después de los dos puntos, antes del tipo de declaración
spaces.panel.around.at.in.pattern.bindings=Alrededor de '@' dentro del enlace de patrón
spaces.panel.before.colon.after.declarations.name=Antes de los dos puntos, después del nombre de la declaración
spaces.panel.before.context.bound.colon.leading=Antes (principal) de dos puntos vinculados al contexto
spaces.panel.before.context.bound.colon.leading.higher.kinded=Antes de los dos puntos vinculados al contexto (tipo principal anterior)
spaces.panel.before.context.bound.colon.rest=Antes (el resto de) los dos puntos vinculados al contexto
spaces.panel.before.opening.square.bracket=Antes del corchete de apertura
spaces.panel.constructor.parameters.with.modifiers=Parámetros del constructor con controladores.
spaces.panel.import.braces=Conseguir frenillos
spaces.panel.infix.method.call.parentheses=Paréntesis de llamada al método inflix
spaces.panel.infix.method.parentheses=Paréntesis del método inflix
spaces.panel.infix.operator.like.method.call.parentheses=Paréntesis de llamada al método de expresión del operador inflix
spaces.panel.inside.closure.braces=Dentro de los tirantes de cierre
spaces.panel.keep.one.line.comments.on.same.line=Mantenga los comentarios de una sola línea en la misma línea
spaces.panel.method.call.left.brace=Llamada al método llave izquierda
spaces.panel.newline.after.annotations=Nueva línea después de la anotación
spaces.panel.preserve.space.before.method.parentheses=Preservar espacio antes de los paréntesis del método
spaces.panel.self.type.braces=Brackets tipo uno mismo
spaces.panel.simple.one.line.block.braces=Tirantes de bloque simples de una línea
specify.result.type=Especificar el tipo de resultado
specify.return.type.explicitly=Especificar tipo (&T)
specify.type.of.exception=Especificar tipo de excepción
stable.identifier.required=Se requiere un identificador estable pero se encontró {0}
string.literal.invalid.escape.character=Carácter de escape no válido
string.literal.invalid.unicode.escape=Escape Unicode incorrecto
string.literal.is.too.long=El tamaño literal de la cadena excede el límite del compilador
subscript.surrounder.template.description=Subíndice\: ,, ,,
suitable.method.not.found=No se encontró ningún método adecuado
super.reference.used.in.extracted.member=El miembro extraído {0} tiene una referencia a su padre, pero el atributo extraído no tiene una clase base
superscript.surrounder.template.description=Superíndice \: ^ ^
support.back.references.in.shared.sources=Soporte para desreferenciación de fuentes compartidas (función experimental)
support.back.references.in.shared.sources.tooltip=Cuando esta configuración está habilitada, IntelliJ puede manejar referencias de módulos fuente compartidos a declaraciones de módulos dependientes.
suspicious.forward.reference.template.body=Referencias directas sospechosas dentro de una clase
symbol.is.inaccessible.from.this.place=No se puede acceder al símbolo {0} desde esta ubicación
symbolliterals.are.deprecated=Los literales de símbolos están en desuso en Scala 2.13. Utilice Símbolo(''{0}'') en su lugar.
system.wide.scala=Scala en todo el sistema
target.0.already.contains.definition.of.1=<b>{0}</b> ya contiene una definición para el miembro <b>{1}</b>
this.is.not.a.valid.scala.qualified.name=No es un nombre válido y completo de Scala
title.choose.implicit.conversion.method=Seleccione el método de conversión implícita\:
title.download=Descargar
title.error.downloading.scala.libraries=Error al descargar la biblioteca Scala
title.expressions=Expresión
title.extensions.available=Extensiones disponibles
title.failed.to.load.extension.jar=Falló la carga del JAR de extensión
title.fetching.available.this.versions=Obteniendo la versión disponible {0}
title.problem.opening.web.page=Problemas al abrir páginas web
title.scala.sdk.files=Archivo SDK de Scala
title.searching.for.library.extensions=Búsqueda de extensiones de biblioteca
to.import.method.statically.press.hotkey=Para importar estáticamente un método, presione {0}
toggle.type.aware.highlighting.menu.action.description=Alternar resaltado de reconocimiento de tipo
toggle.type.aware.highlighting.menu.action.text=Alternar resaltado usando información de tipo
too.many.type.arguments.for.typeparamowner=Hay demasiados argumentos de tipo para {0}. {1} necesario, {2} encontrado
topic.parameters.may.not.be.call.by.name=El parámetro {0} puede no ser llamada por nombre
trailing.comma.panel.add.when.multiline=Agregar para varias líneas
trailing.comma.panel.keep=Mantener
trailing.comma.panel.remove.when.multiline=Eliminar si hay varias líneas
trailing.comma.panel.scope.arguments.list=Lista de argumentos
trailing.comma.panel.scope.import.selector=Selector de importación
trailing.comma.panel.scope.parameters.list=Lista de parámetros
trailing.comma.panel.scope.pattern.arguments.list=Lista de argumentos de patrón
trailing.comma.panel.scope.tuple=Tupla
trailing.comma.panel.scope.tuple.type=Tipo de tupla
trailing.comma.panel.scope.type.parameters.list=Lista de parámetros de tipo
trailing.comma.panel.title=Coma final
trailing.commas.mode.auto=Automático
trailing.commas.mode.disabled=Deshabilitar
trailing.commas.mode.enabled=Activado
trailing.underscore.separator=No se permiten separadores de subrayado al final
trait.has.implementations=Siguiente mezcla
trait.has.several.implementations=Mezclado en la clase {0}
trait.is.already.implemented.by.superclass=La propiedad {0} ya está implementada por la superclase {1}, por lo que no se volverá a llamar a su constructor.
trait.may.not.call.constructor=La propiedad {0} no puede llamar al constructor de {1}
trait.parameter.require.scala3=El uso de parámetros de rasgos requiere Scala 3.0
traits.cannot.have.type.parameters.with.context.bounds=Los rasgos no pueden tener parámetros de tipo con límites de contexto
traits.cannot.have.type.parameters.with.view.bounds=Las propiedades no pueden tener parámetros de tipo con límites de vista
transparent.method.must.be.inline=La palabra clave "transparente" solo se puede utilizar en métodos en línea
tree.mismatch.tooltip=<html><body>{0}<table><tr><td>필요\:</td>{1}</tr><tr><td>발견\:</td>{2}</ tr></table></body></html>
try.block=Intentar bloquear
type.annotations.panel.accidental.structural.type=Tipo de rescate accidental
type.annotations.panel.accidental.structural.type.tooltip=<html>Aplica una anotación de tipo a valores con un tipo estructural inferido. Ejemplo\:<br>\n<pre><código>\nval foo \= Ejecutable {\n override def run()\: Unidad \= ()\n def helper()\: Unidad \= ()\n } // tipo inferido de foo\: Runnable { def helper()\: Unidad } \n</code></pre></html>
type.annotations.panel.annotated.with=다음 어노테이션 추가\:
type.annotations.panel.annotations=Anotación
type.annotations.panel.classes=Clase
type.annotations.panel.constant.final.val=Constante (valor final)
type.annotations.panel.enforce.for=Obligado a aplicar
type.annotations.panel.except.when=Excepciones para:
type.annotations.panel.function.literal.parameter=Parámetros literales de función
type.annotations.panel.implicit.definition=Definición implícita
type.annotations.panel.in.scala.dialect.sources=De fuentes de lenguaje derivadas de Scala
type.annotations.panel.in.scala.dialect.sources.tooltip=*.sbt, *.sc, etc.
type.annotations.panel.in.test.sources=Mi fuente de prueba
type.annotations.panel.local.definition=Definición local
type.annotations.panel.member.of=Miembros de:
type.annotations.panel.member.of.anonymous.class=Miembro anónimo de la clase
type.annotations.panel.member.of.private.class=Miembro de la clase privada
type.annotations.panel.private.member=Miembro privado
type.annotations.panel.protected.member=Miembro protegido
type.annotations.panel.public.member=Miembro público
type.annotations.panel.title=Tipo de anotación
type.annotations.panel.type.is.stable=El tipo es estable.
type.annotations.panel.type.is.stable.tooltip=<html><body>Si el lado derecho es\:<br> literal\: <code>123</code>, <code>"string"</code>, etc. (excluyendo <code>null</code> ) <br> Expresión unitaria\: <código>()</código><br> Crear objeto\: <código>nuevo Foo(...)</código>(excluyendo código concreto\: <código>nuevo Foo( ) {}</code>)<br> Llamada al método de fábrica\: <code>Foo(...)</code> (llamando a <code>apply(...)</code> en el objeto complementario)<br > Colecciones vacías\: <code>Seq.empty[Int]</code>, <code>Map.empty[Int, String]</code>, etc.<br> Constantes de enumeración de Java\: <code>Enum. VALOR </code><br> Excepción\: <code>lanzar excepción()</code> </body></html>
type.annotations.panel.type.matches=Tipo de coincidencia\:
type.annotations.panel.type.patterns=Patrón de tipo
type.annotations.panel.underscore.parameter=Parámetro subrayado
type.annotations.panel.unit.type=Tipo de unidad
type.annotations.panel.use.for=Que usar
type.arg.does.not.conform.to.lower.bound=El tipo {0} no respeta el límite inferior {1} del parámetro de tipo {2}
type.arg.does.not.conform.to.upper.bound=El tipo {0} no respeta el límite superior {1} del parámetro de tipo {2}
type.aware.highlighting.title=Resalte el reconocimiento de tipo Scala
type.cannot.be.used.in.type.pattern=El tipo {0} no se puede utilizar en un patrón de tipo ni en una prueba isInstanceOf
type.checker.built.in=Incorporado
type.checker.compiler=Compilador
type.checker.help=<html><strong>Listo para usar\: </strong> Más funciones, más capacidad de respuesta y más liviano. En código complejo, pueden ocurrir errores falsos.<br><br><strong>Compilador\:</strong> es más preciso. Sin embargo, es más lento, consume más recursos y no admite funciones como comparación de tipos, corrección rápida, verificación, etc.<br><br>A menos que experimente una gran cantidad de errores falsos en su base de código particular, use Se recomienda el verificador de tipos incorporado.</html>
type.checker.label.scala2=Scala 2\:
type.checker.label.scala3=Scala 3\:
type.constructor.does.not.conform=El constructor de tipo {0} no se ajusta a {1}
type.constructor.mismatch=El constructor de tipos no coincide.
type.expected=Se requiere tipo
type.info.description=Información del tipo de pantalla
type.info.text=Clasificar información
type.is.not.a.valid.result.type.of.an.unapply.method={0} no es un tipo de resultado válido para el método de no aplicar
type.is.not.a.valid.result.type.of.an.unapplyseq.method={0} no es un tipo de resultado válido para el método unaapplySeq
type.lambda.expected='\=>>' es obligatorio
type.mismatch.default.args.expected.actual=Hay una discrepancia en los tipos relacionados con los argumentos predeterminados. Requerido\: {0}, Real\: {1}
type.mismatch.dot=El tipo no coincide.
type.mismatch.expected=El tipo no coincide. Requerido\: {0}, Real\: {1}
type.mismatch.expected.actual=El tipo no coincide. Requerido\: {0}, Real\: {1}
type.mismatch.found.required=El tipo no coincide. Encontrado\: {0}, Requerido\: {1}
type.mismatch.hint.context.menu.configure=Configurando sugerencia de discrepancia de tipos...
type.mismatch.message=El tipo no coincide. Requerido\: {0}, Encontrado\: {1}
type.parameter.value.class.may.not.be.specialized=Los parámetros de tipo de clases de valor no se pueden especializar
type.parameters.for.self.type.not.supported=La característica extraída tiene {0} como tipo, pero no se admite la identificación de su parámetro de tipo.
type.takes.type.parameters=El tipo {0} toma un parámetro de tipo
typed.statement.is.not.complete.for.underscore.section=La sintaxis escrita está incompleta para las secciones de subrayado
unbound.placeholder.parameter=Parámetro de marcador de posición independiente
unchecked.warnings=&Advertencia no reconocida
unchecked.warnings.tooltip=Habilite advertencias adicionales si el código generado depende de sus suposiciones.
underline.surrounder.template.description=Subrayado\: __ __
unknown.exception=Excepción desconocida\: {0}
unknown.extraction=Extracto desconocido
unknown.macro.in.type.position=Macro desconocida en posición de tipo
unknown.resolve.issues=Problema desconocido resuelto\: {0}
unknown.type=<desconocido>
unreachable.error=Se detectó un error inesperado
unresolved.artifact=Artefactos no resueltos\: {0}
unspecified.type.parameters=Parámetro de valor no especificado \: {0}
unwrap.case.clause=Desenvolviendo la cláusula del caso
unwrap.finally=Finalmente desenvolver
unwrap.interpolated.string.injection=Desenvolver inserciones de cadenas interpoladas
unwrap.try.with.finally=Intentar/finalmente desenvolver
updating.of.usages.of.generated.unapply=No se admite la actualización del uso del método 'desaplicar' generado
upgrade.to.interpolated=Actualice una cadena simple a una cadena interpolada después de ingresar '${'
usage.access.modifier=Controlador de acceso
usage.extractor=Extractor
usage.function.expression=Expresión de función
usage.implicit.conversion.parameter=Conversión implícita/parámetros
usage.interpolated.string.prefix=Prefijo de cadena interpolada
usage.method.apply=Método 'aplicar'
usage.named.parameter=Parámetro con nombre
usage.package.clause=Cláusula del paquete
usage.parameter.in.pattern=Parámetros dentro del patrón.
usage.sam.interface.implementation=Implementación de la interfaz SAM
usage.secondary.constructor=Constructor secundario
usage.self.type=Tipo magnético
usage.this.reference=Mira esto
usage.type.alias=Escriba alias
usage.type.bound=Tipo enlazado
usage.typed.pattern=Patrón mecanografiado
usage.typed.statement=Sintaxis escrita
usage.unresolved.implicit.conversion.parameter=Conversiones/parámetros implícitos no resueltos
use.compiler.ranges.help=<html><strong>El compilador aplicará el resaltado de errores al proyecto</strong><br><br>Si está marcado, el rango de texto informado por el compilador de Scala se utilizará al resaltar el código dentro del editor. Se pueden resaltar rangos de texto grandes para errores de compilación seleccionados.<br><br>Si no está marcado, se pueden resaltar rangos de texto pequeños para errores de compilación seleccionados</html>
using.parameter.clause.expected=Se requiere la cláusula de parámetro 'usando'
val.name=Val {0}
val.on.case.class.param.redundant=Los parámetros del constructor predeterminado de la clase Case y el controlador 'val' están duplicados
val.or.var.can.only.be.used.in.class.parameters=''{0}'' sólo se puede utilizar en parámetros de clase
val.var.expected=Requiere la palabra clave val o var
value.class.can.have.only.one.parameter=Una clase de valor puede tener solo un parámetro
value.class.can.have.only.val.parameter=Una clase de valor solo puede tener un parámetro val no privado
value.classes.can.have.only.defs=No se permiten definiciones de campos en clases de valor
value.classes.cannot.have.nested.objects=Las clases de valor no pueden tener clases, objetos o propiedades anidadas
value.classes.cannot.redefine.equals.hashcode=Las clases de valor no pueden anular iguales y hashCode
value.classes.may.not.be.member.of.another.class=Una clase de valor no puede ser miembro de otra clase.
var.cannot.be.overridden=Las variables mutables no se pueden redefinir
var.cannot.override.val=La variable {0} no puede redefinir su valor inmutable
var.name=Var {0}
vararg.pattern.must.be.last.pattern=_* sólo se puede utilizar en el último argumento
vararg.pattern.with.at.deprecated.since.scala3=La sintaxis '@' en los patrones vararg está obsoleta en Scala 3.0 y versiones posteriores.
vararg.pattern.with.colon.requires.scala3=La sintaxis '\:' dentro de los patrones vararg requiere Scala 3.0
variable.names=Nombre de variable\: {0}
variance.annotation.not.allowed=Aquí no se permiten anotaciones de volatilidad.
variance.bivariant=inusual
variance.contravariant=Anticomunista
variance.covariant=Covariante
variance.invariant=No covariante
view.bounds.not.allowed=Aquí no se permiten límites de visualización
while.expected=La palabra clave while dentro de la declaración 'do' es obligatoria
while.statement=Mientras declaración
wrap.in.option.hint=¿Le gustaría ajustar la expresión en Opción(...)?
wrap.in.option.name=Envoltura con opción
wrap.single.expression.body=Envuelva el cuerpo de una sola expresión con una llave de cierre después de escribir '{'
wrapping.and.braces.panel.align.if.else.statements=Ordenar sintaxis si no
wrapping.and.braces.panel.align.in.columns.case.branches=Ordenar por columna de rama 'caso'
wrapping.and.braces.panel.align.multiline.pattern.alternatives=Sustitución de patrones multilínea
wrapping.and.braces.panel.align.parameter.types.in.multiline.declarations=Ordenar tipos de parámetros cuando hay varias líneas presentes
wrapping.and.braces.panel.align.tuple.elements=Ordenar elementos de tupla
wrapping.and.braces.panel.do.not.align.block.expression.parameters=Parámetros de expresión de bloque de desorden
wrapping.and.braces.panel.do.not.indent.case.clause.body=No sangrar el cuerpo de la cláusula del caso
wrapping.and.braces.panel.do.not.indent.tuples.closing.parenthesis=No aplicar sangría a los paréntesis de cierre de tuplas
wrapping.and.braces.panel.extends.align.to.extends=Asignación a 'extiende'
wrapping.and.braces.panel.extends.do.not.align=Sin clasificación
wrapping.and.braces.panel.extends.on.first.token=En la primera ficha
wrapping.and.braces.panel.for.indent.yield.after.one.line.enumerators=Sangrar el rendimiento después de un enumerador de una línea
wrapping.and.braces.panel.force.braces=Tirantes de fuerza
wrapping.and.braces.panel.force.case.branch.braces=Forzar tirantes de rama 'caso'
wrapping.and.braces.panel.force.finally.braces=Forzar llaves 'finalmente'
wrapping.and.braces.panel.force.try.braces=Forzar "probar" brackets
wrapping.and.braces.panel.groups.anonymous.method.definition=Definición del método anónimo
wrapping.and.braces.panel.groups.class.definition=Definición de clase
wrapping.and.braces.panel.groups.method.definition=Definición del método
wrapping.and.braces.panel.groups.tuple=Tupla
wrapping.and.braces.panel.groups.type.arguments=Tipo argumento
wrapping.and.braces.panel.groups.type.parameters=Tipo de parámetro
wrapping.and.braces.panel.groups.xml.formatting=Formatear XML
wrapping.and.braces.panel.indent=Sangrar
wrapping.and.braces.panel.indent.braced.arguments=Sangrar argumentos encerrados entre llaves
wrapping.and.braces.panel.indent.first.parameter.clause.if.on.new.line=Sangrar la cláusula del primer parámetro si está en una nueva línea
wrapping.and.braces.panel.indent.first.parameter.if.on.new.line=Sangrar el primer parámetro si está en una nueva línea
wrapping.and.braces.panel.keep.xml.formatting=Mantener el formato XML
wrapping.and.braces.panel.match.statement=Declaración de 'coincidencia'
wrapping.and.braces.panel.new.line.options.new.line.always=Siempre salto de línea
wrapping.and.braces.panel.new.line.options.new.line.for.multiple.arguments=Saltos de línea cuando se utilizan argumentos de varias líneas
wrapping.and.braces.panel.new.line.options.no.new.line=Sin nuevas líneas
wrapping.and.braces.panel.parameters.on.new.line=Parámetros en nueva línea
wrapping.and.braces.panel.place.self.type.on.new.line=Coloque su tipo en una nueva línea
wrapping.and.braces.panel.renamed.extends.keyword=Extiende la palabra clave
wrapping.and.braces.panel.renamed.extends.with.list=Extiende/con lista
wrapping.and.braces.panel.renamed.force.yield.braces=Tirantes de cedencia forzada
wrapping.and.braces.panel.renamed.infix.expressions=Expresión inflix
wrapping.and.braces.panel.simple.one.line.lambdas.in.arg.list=Lambda simple de una línea en la lista de argumentos
wrapping.and.braces.panel.use.normal.indent.for.parameters=Utilice sangría normal para los parámetros.
wrapping.and.braces.panel.wrap.before.with.keyword=Salto de línea antes de la palabra clave 'con'
wrong.annotation.expression=Expresión de anotación no válida
wrong.binding=Parametro invalido
wrong.case.modifier=El controlador del caso no es válido. Úselo como clase u objeto.
wrong.constr.expression=Expresión de constructor no válida
wrong.declaration.in.block=El bloque no puede contener declaraciones
wrong.existential.declaration=Esta es una declaración incorrecta de existencia. Debe ser una declaración de tipo o valor.
wrong.expression=Expresión no válida
wrong.number.arguments.extractor=Número de argumentos no válidos en el extractor, encontrado\: {0}, requerido\: {1}
wrong.number.arguments.extractor.unapplySeq=Número de argumentos no válidos en el extractor, encontrados\: {0}, requeridos\: {1} o más.
wrong.parameter=Parametro invalido
wrong.pattern=Patrón incorrecto
wrong.postfix.expression=Expresión de sufijo no válida
wrong.qual.identifier=Identificador completo no válido
wrong.string.literal=Literal de cadena no válido
wrong.stub.problem=Problema con el trozo malo
wrong.top.statement.declaration=Declaración de sintaxis superior incorrecta
wrong.type=Tipo incorrecto
wrong.type.associativity=La ley asociativa es incorrecta. Todos los operadores deben tener las mismas leyes asociativas.
wrong.type.element=Elemento de tipo no válido
wrong.type.no.literal.types=El tipo ''{0}'' no es válido. Para compatibilidad con tipos literales, utilice Scala 2.13 o Typelevel Scala con el indicador del compilador ''-Yliteral-types''.
wrong.val.declaration=Declaración de valor no válida
wrong.var.declaration=Declaración de variable no válida
xml.PI.end.expected=Es necesario finalizar las instrucciones de procesamiento XML
xml.attribute.end.expected=Se requiere un delimitador de terminación para los valores de atributos XML
xml.attribute.value.expected=Se requiere valor de la propiedad
xml.cdata.end.expected=Se requiere la terminación de XML CData
xml.comment.end.expected=El comentario XML requiere terminación ('-->')
xml.delete.unmatched.tag=Eliminar etiquetas no coincidentes
xml.end.tag.expected=Se requiere la etiqueta final XML ('</' nombre '>')
xml.eq.expected='\=' es obligatorio
xml.name.expected=Se requiere el nombre de la etiqueta XML
xml.no.closing.tag=Sin etiqueta de cierre
xml.no.opening.tag=Sin etiqueta de apertura
xml.rename.closing.tag=Cambiar el nombre de la etiqueta de cierre
xml.rename.opening.tag=Cambiar el nombre de la etiqueta de apertura
xml.scala.expression.expected=La inserción en XML requiere expresión Scala
xml.scala.injection.end.expected=La inserción de Scala en XML requiere terminación ('}')
xml.scala.patterns.expected=La inserción de XML requiere el patrón Scala
xml.tag.end.expected=Se requiere el fin de la etiqueta XML
xml.wrong.character=Cadena no válida en comentario XML
