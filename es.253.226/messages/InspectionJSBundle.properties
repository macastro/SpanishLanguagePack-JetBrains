add.require.amd.module.fix=Añadir dependencia del módulo {0}
add.require.amd.module.group.name=Node.js
add.return.statement.fix.name=Añadir sentencia return
anonymous.function.contains.multiple.loops.error.string=#ref contiene {0} bucles #loc
anonymous.function.contains.multiple.return.points.error.string=#ref tiene {0} puntos de retorno #loc
anonymous.function.contains.too.many.negation.error.string=#ref contiene {0} negaciones #loc
anonymous.function.display.name=Función anónima
anonymous.function.error.string=Función anónima #loc
anonymous.function.has.inconsistent.return.points.error.string=#ref tiene puntos de retorno inconsistentes #loc
anonymous.function.has.too.many.parameters.error.string=#ref tiene demasiados parámetros (número de parámetros = {0}) #loc
anonymous.function.is.overly.complex.cyclomatic.complexity.error.string=#ref es demasiado compleja (complejidad ciclomática = {0}) #loc
anonymous.function.is.overly.long.statement.error.string=#ref es demasiado largo (número de sentencias = {0}) #loc
anonymous.function.is.overly.nested.error.string=#ref está demasiado anidado (la profundidad de anidamiento es {0}, pero el máximo permitido es {1}) #loc
assignment.replaceable.with.operator.assignment.display.name=La asignación se puede reemplazar por una asignación con operador
assignment.replaceable.with.operator.assignment.error.string=#ref se puede simplificar a {0} #loc
assignment.to.for.loop.parameter.display.name=Asignación a un parámetro de bucle 'for'
assignment.to.for.loop.parameter.error.string=Asignación al parámetro del bucle for #ref #loc
assignment.to.function.parameter.display.name=Asignación a un parámetro de función
assignment.to.function.parameter.error.string=Asignación al parámetro de función '#ref' #loc
break.statement.display.name=Sentencia 'break'
break.statement.error.string=Sentencia '#ref' #loc
break.statement.with.label.display.name=Sentencia 'break' con etiqueta
break.statement.with.label.error.string=Sentencia '#ref' con etiqueta #loc
call.to.document.write.display.name=Llamada a 'document.write()'
caller.display.name=Uso de la propiedad 'caller'
caller.error.string=Uso de la propiedad '#ref' #loc
chained.equality.display.name=Igualdad encadenada
chained.equality.error.string=Comparación de igualdad encadenada <code>#ref</code> #loc
chained.function.call.display.name=Llamada a función encadenada
chained.function.call.problem.descriptor=Llamada encadenada a la función '#ref' #loc
class.name.doesnt.match.regex.error.string=El nombre de la clase ''{0}'' no coincide con la expresión regular ''{1}'' #loc
class.name.is.too.long.error.string=El nombre de la clase ''{0}'' es demasiado largo #loc
class.name.is.too.short.error.string=El nombre de la clase ''{0}'' es demasiado corto #loc
class.naming.convention.display.name=Convención de nomenclatura de clases
collapse.conditional.expression.fix=Contraer expresión condicional
collapse.if.statement.fix=Contraer sentencia 'if'
comma.expression.display.name=Expresión de coma
comma.expression.error.string=Expresión de coma #loc
conditional.expression.display.name=Expresión condicional
conditional.expression.error.string=Expresión condicional #loc
conditional.expression.with.identical.branches.display.name=Expresión condicional con ramas idénticas
conditional.expression.with.identical.branches.error.string=Expresión condicional <code>#ref</code> con ramas idénticas #loc
confusing.floating.point.literal.change.quickfix=Cambiar a la forma canónica
confusing.floating.point.literal.display.name=Literal de punto flotante confuso
confusing.floating.point.literal.problem.descriptor=Literal de punto flotante confuso <code>#ref</code> #loc
confusing.pluses.or.minuses.display.name=Secuencia confusa de '+' o '-'
confusing.pluses.or.minuses.error.string=La secuencia de '+' o '-' puede cambiar de significado si se elimina el espacio en blanco #loc
constant.conditional.expression.display.name=Expresión condicional constante
constant.conditional.expression.error.string=<code>#ref</code> se puede simplificar #loc
constant.on.left.side.of.comparison.display.name=Constante en el lado izquierdo de la comparación
constant.on.left.side.of.comparison.error.string=#ref: constante en el lado izquierdo de la comparación #loc
constant.on.right.side.of.comparison.display.name=Constante a la derecha de la comparación
constant.on.right.side.of.comparison.error.string=#ref: constante en el lado derecho de la comparación #loc
constructor.name.doesnt.match.regex.error.string=El nombre del constructor ''{0}'' no coincide con la expresión regular ''{1}'' #loc
constructor.name.is.too.long.error.string=El nombre del constructor ''{0}'' es demasiado largo #loc
constructor.name.is.too.short.error.string=El nombre del constructor ''{0}'' es demasiado corto #loc
continue.or.break.inside.finally.block.display.name=Continue' o 'break' dentro del bloque 'finally
continue.or.break.inside.finally.block.error.string='#ref' dentro del bloque 'finally' #loc
continue.statement.display.name=Sentencia 'continue'
continue.statement.error.string=Sentencia '#ref' #loc
continue.statement.with.label.display.name=Sentencia 'continue' con etiqueta
continue.statement.with.label.error.string=Sentencia '#ref' con etiqueta #loc
debugger.statement.display.name=Sentencia 'debugger'
debugger.statement.error.string=Sentencia '#ref' #loc
default.branch.not.last.case.in.switch.error.string=La rama <code>#ref</code> no es el último caso en 'switch' #loc
default.not.last.case.in.switch.display.name=Default' no es el último case en 'switch
divide.by.zero.display.name=División por cero
division.by.zero.error.string=División por cero #loc
document.write.error.string=Llamada a '#ref()' #loc
duplicate.case.label.display.name=Etiqueta 'case' duplicada
duplicate.case.label.error.string=Etiqueta de case duplicada #ref #loc
duplicate.condition.error.string=Condición duplicada <code>#ref</code> #loc
duplicate.condition.in.if.statement.display.name=Condición duplicada en la sentencia 'if'
dynamically.generated.code.display.name=Ejecución de código generado dinámicamente
dynamically.generated.code.error.string=La función '#ref' indica código generado dinámicamente #loc
empty.catch.block.display.name=Bloque 'catch' vacío
empty.catch.block.error.string=Bloque '#ref' vacío #loc
empty.finally.block.display.name=Bloque 'finally' vacío
empty.finally.block.error.string=Bloque 'finally' vacío #loc
empty.try.block.display.name=Bloque 'try' vacío
empty.try.block.error.string=Bloque '#ref' vacío #loc
exception.caught.locally.error.string='#ref' de la excepción capturada localmente #loc
exception.used.for.local.control.flow.display.name=Excepción utilizada para el flujo de control local
expression.statement.is.not.assignment.or.call.error.string=La sentencia de expresión no es una asignación ni una llamada #loc
expression.statement.which.is.not.assignment.or.call.display.name=Sentencia de expresión que no es una asignación o llamada
fall.through.in.switch.statement.display.name=Fallthrough en la instrucción 'switch'
fall.through.in.switch.statement.error.string=Fallthrough en la sentencia 'switch' #loc. Falta 'break' o 'return'
flip.comparison.fix=Invertir comparación
for.loop.not.use.loop.variable.display.name=Bucle 'for' donde la actualización o la condición no utilizan la variable de bucle
for.loop.not.use.loop.variable.problem.descriptor.both.condition.and.update=La sentencia <code>#ref</code> contiene una condición y una actualización que no utilizan la variable del bucle for #loc
for.loop.not.use.loop.variable.problem.descriptor.condition=La sentencia <code>#ref</code> tiene una condición que no utiliza la variable del bucle for #loc
for.loop.not.use.loop.variable.problem.descriptor.update=La sentencia <code>#ref</code> contiene una actualización que no utiliza la variable del bucle for #loc
for.loop.replaceable.by.while.display.name=El bucle 'for' se puede reemplazar por un bucle 'while'
for.loop.replaceable.by.while.ignore.option=Ignorar bucles 'for' infinitos sin condiciones
for.loop.replaceable.by.while.problem.descriptor=El bucle <code>#ref</code> puede reemplazarse por un bucle 'while' #loc
for.loop.replaceable.by.while.replace.quickfix=Reemplazar con 'while'
function.complexity.limit.parameter=Límite de complejidad de la función:
function.contains.multiple.loops.error.string=La función ''#ref'' contiene {0} bucles #loc
function.contains.multiple.return.points.error.string=La función ''#ref'' tiene {0} puntos de retorno #loc
function.contains.too.many.negation.error.string=La función ''#ref'' contiene {0} negaciones #loc
function.has.inconsistent.return.points.error.string=La función '#ref' tiene puntos de retorno inconsistentes #loc
function.has.too.many.parameters.error.string=La función ''#ref'' tiene demasiados parámetros (número de parámetros = {0}) #loc
function.is.overly.long.statement.error.string=La función ''#ref'' es demasiado larga (número de sentencias = {0}) #loc
function.is.overly.nested.error.string=La función ''#ref'' está excesivamente anidada (la profundidad de anidamiento es {0}, pero el máximo permitido es {1}) #loc
function.name.doesnt.match.regex.error.string=El nombre de la función ''{0}'' no coincide con la expresión regular ''{1}'' #loc
function.name.is.too.long.error.string=El nombre de la función ''{0}'' es demasiado largo #loc
function.name.is.too.short.error.string=El nombre de la función ''{0}'' es demasiado corto #loc
function.naming.convention.display.name=Convención de nomenclatura de funciones
function.parameter.limit=Límite de parámetros de la función:
function.parameter.naming.convention.display.name=Convención de nomenclatura de parámetros de función
function.ref.is.overly.complex.cyclomatic.complexity.error.string=La función ''#ref'' es demasiado compleja (complejidad ciclomática = {0}) #loc
function.with.inconsistent.returns.display.name=Función con retornos inconsistentes
function.with.more.than.three.negations.display.name=Función con más de tres negaciones
function.with.multiple.loops.display.name=Función con múltiples bucles
function.with.multiple.return.points.display.name=Función con múltiples puntos de retorno
function.with.too.many.parameters.display.name=Función con demasiados parámetros
group.path.javascript=JavaScript
if.statement.with.identical.branches.display.name=Sentencia 'if' con ramas idénticas
if.statement.with.too.many.branches.display.name=Sentencia 'if' con demasiadas ramas
if.statement.with.too.many.branches.error.string=''#ref'' tiene demasiadas ramas ({0}) #loc
include.anonymous.functions.parameter=Incluir funciones anónimas
include.statement.bodies.that.are.empty.code.blocks.parameter=Incluir cuerpos de sentencia que sean bloques de código vacíos
incompatible.mask.operation.display.name=Operación de máscara de bits incompatible
incompatible.mask.operation.problem.descriptor.always.false=<code>#ref</code> siempre es falso #loc
incompatible.mask.operation.problem.descriptor.always.true=<code>#ref</code> siempre es true #loc
infinite.loop.error.string=La sentencia <code>#ref</code> no puede completarse sin lanzar una excepción #loc
infinite.loop.statement.display.name=Sentencia de bucle infinito
infinite.recursion.display.name=Recursión infinita
infinite.recursion.problem.descriptor=La función <code>#ref</code> realiza una recursión infinita y solo puede finalizar lanzando una excepción #loc
inner.html.error.string=Uso de la propiedad '#ref' #loc
invert.condition.fix=Invertir condición
invert.if.condition.fix=Invertir condición 'if'
javascript.dom.issues.group.name=Problemas del DOM
js.inspection.group.path=JavaScript y TypeScript
js.inspection.switch.group.name=Problemas de la sentencia switch
labeled.statement.display.name=Sentencia con etiqueta
local.variable.naming.convention.display.name=Convención de nomenclatura de variables locales
loop.statement.that.doesn.t.loop.display.name=Sentencia de bucle que no realiza bucles
loop.statement.that.doesnt.loop.error.string=La sentencia <code>#ref</code> no realiza ciclos #loc
magic.number.display.name=Número mágico
magic.number.problem.descriptor=Número mágico '#ref' #loc
maximum.number.of.branches.parameter=Número máximo de ramas:
maximum.number.of.terms.parameter=Número máximo de términos:
maximum.statements.per.function=Número máximo de sentencias por función:
missing.return.statement.error.string=Falta la sentencia return #loc
negated.conditional.expression.display.name=Expresión condicional negada
negated.conditional.expression.error.string=Expresión condicional negada #loc
negated.if.statement.display.name=Sentencia 'if' negada
negated.ref.statement.error.string=Sentencia '#ref' negada #loc
nested.anonymous.function.error.string=#ref anidado #loc
nested.assignment.display.name=Asignación anidada
nested.assignment.error.string=Asignación anidada <code>#ref</code> #loc
nested.conditional.expression.display.name=Expresión condicional anidada
nested.conditional.expression.error.string=Expresión condicional anidada #loc
nested.function.call.display.name=Llamada a función anidada
nested.function.call.problem.descriptor=Llamada anidada a la función '#ref' #loc
nested.function.display.name=Función anidada
nested.function.error.string=Función anidada '#ref' #loc
nested.switch.statement.display.name=Sentencia 'switch' anidada
nested.switch.statement.error.string=Sentencia '#ref' anidada #loc
nesting.depth.limit=Límite de profundidad de anidamiento:
non.block.body.error.string=La sentencia <code>#ref</code> tiene un cuerpo que no es un bloque #loc
non.block.branch.error.string=La instrucción <code>#ref</code> tiene una rama que no es de bloque #loc
non.block.statement.body.display.name=Cuerpo de la sentencia sin llaves
octal.integer.display.name=Entero octal
overly.complex.arithmetic.expression.display.name=Expresión aritmética excesivamente compleja
overly.complex.arithmetic.expression.error.string=Expresión aritmética excesivamente compleja #loc
overly.complex.boolean.expression.display.name=Expresión booleana excesivamente compleja
overly.complex.boolean.expression.error.string=Expresión booleana excesivamente compleja #loc
overly.complex.function.display.name=Función excesivamente compleja
overly.long.function.display.name=Función demasiado larga
overly.nested.function.display.name=Función excesivamente anidada
parameter.name.doesnt.match.regex.error.string=El nombre del parámetro ''#ref'' no coincide con la expresión regular ''{0}'' #loc
parameter.name.is.too.long.error.string=El nombre del parámetro '#ref' es demasiado largo #loc
parameter.name.is.too.short.error.string=El nombre del parámetro '#ref' es demasiado corto #loc
platform.detection.display.name=Detección de plataforma inexacta
platform.detection.error.string='#ref' probablemente se utiliza para la detección de plataforma #loc
pointless.arithmetic.error.message=#ref puede reemplazarse por {0} #loc
pointless.arithmetic.expression.display.name=Expresión aritmética inútil
pointless.bitwise.expression.display.name=La expresión bit a bit se puede simplificar
pointless.bitwise.expression.ignore.option=Ignorar constantes con nombre al determinar expresiones sin sentido
pointless.bitwise.expression.problem.descriptor=''{1}'' se puede reemplazar por ''{0}'' #loc
pointless.bitwise.expression.simplify.quickfix=Simplificar
pointless.boolean.error.string=Puede simplificarse a {0} #loc
pointless.boolean.expression.display.name=Sentencia o expresión booleana sin sentido
pointless.statement.error.string=La sentencia {0} se puede simplificar #loc
redundant.conditional.expression.display.name=Expresión condicional redundante
redundant.if.statement.display.name=Sentencia 'if' redundante
redundant.local.variable.display.name=Variable local redundante
redundant.local.variable.ignore.option=Ignorar las variables que se devuelven o se lanzan de inmediato
redundant.local.variable.quickfix=Incrustar variable
ref.statement.with.identical.branches.error.string=Sentencia <code>#ref</code> con ramas idénticas #loc
remove.label.fix=Eliminar etiqueta
remove.unnecessary.continue.fix=Eliminar 'continue' innecesario
remove.unnecessary.return.fix=Eliminar return innecesario
rename.fix=Renombrar
replace.redundant.await.family.name=Reemplazar await redundante
replace.with.operator.assign.fix=Reemplazar = por {0}=
reserved.word.used.as.name.display.name=Palabra reservada utilizada como nombre
reserved.word.used.as.name.error.string=Palabra reservada '#ref' utilizada como nombre
result.of.assignment.expression.used.error.string=Se utiliza el resultado de la expresión de asignación #loc
result.of.assignment.used.displayName=Resultado de la asignación utilizado
result.of.increment.or.decrement.expression.used.error.string=Resultado de la expresión de incremento o decremento utilizado #loc
result.of.increment.or.decrement.used.display.name=Resultado de incremento o decremento utilizado
result.of.object.allocation.ignored.display.name=Resultado de la asignación de objetos ignorado
result.of.object.allocation.ignored.error.string=El resultado de <code>new #ref()</code> se ignora #loc
return.inside.finally.block.display.name=Return' dentro del bloque 'finally
return.inside.finally.block.error.string='#ref' dentro del bloque 'finally' #loc
reuse.of.local.variable.display.name=Reutilización de variable local
reuse.of.local.variable.problem.descriptor=Reutilización de la variable local <code>#ref</code> #loc
set.return.type.to.void.fix.name=Establecer el tipo de retorno a void
shift.operation.by.inappropriate.constant.display.name=Operación de desplazamiento por una constante posiblemente incorrecta
shift.operation.by.inappropriate.constant.problem.descriptor.negative=Operación de desplazamiento <code>#ref</code> por un valor constante negativo #loc
shift.operation.by.inappropriate.constant.problem.descriptor.too.large=Operación de desplazamiento <code>#ref</code> por un valor constante excesivamente grande #loc
shift.out.of.range.family.name=Corregir valor de desplazamiento
silly.assignment.display.name=Variable asignada a sí misma
silly.assignment.error.string=La variable se asigna a sí misma #loc
simplify.fix=Simplificar
statement.has.empty.body.error.string=La sentencia <code>#ref</code> tiene un cuerpo vacío #loc
statement.has.empty.branch.error.string=La sentencia <code>#ref</code> tiene una rama vacía #loc
statement.label.error.string=Etiqueta de sentencia '#ref' #loc
statement.simplify.quickfix=Simplificar sentencia
statement.with.empty.body.display.name=Sentencia con cuerpo vacío
string.literal.breaks.html.display.name=Literal de cadena que interrumpe el análisis HTML
string.literal.breaks.html.error.string=El literal de cadena #ref puede interrumpir los analizadores de HTML #loc
tail.recursion.display.name=Recursividad de cola
tail.recursion.problem.descriptor=Recursión de cola #loc
terminate.statement.fix=Terminar sentencia
text.label.in.switch.statement.display.name=Etiqueta de texto en la sentencia 'switch'
text.label.in.switch.statement.error.string=Etiqueta de texto <code>#ref:</code> en la instrucción 'switch' #loc
this.expression.references.global.object.error.string=Expresión '#ref' de nivel superior #loc
this.expression.which.references.the.global.object.display.name=Expresión 'this' que hace referencia al objeto global
throw.inside.finally.block.display.name=Throw' dentro del bloque 'finally
throw.inside.finally.block.error.string='#ref' dentro del bloque 'finally' #loc
trivial.conditional.error.string=''{0}'' se puede simplificar a ''{1}'' #loc
trivial.if.error.string=La sentencia <code>#ref</code> se puede simplificar #loc
typeof.using.incorrect.case.display.name=Comparación de 'typeof' con un valor no estándar
typeof.using.incorrect.case.error=Typeof comparado con un valor no estándar
typeof.using.incorrect.convert=Convertir a {0}
typeof.using.incorrect.family.name=Convertir a valor estándar
unnecessary.block.statement.display.name=Sentencia de bloque innecesaria
unnecessary.block.statement.error.string=Sentencia de bloque innecesaria #loc
unnecessary.continue.error.string=<code>#ref</code> es innecesario como última sentencia en un bucle #loc
unnecessary.continue.statement.display.name=Sentencia 'continue' innecesaria
unnecessary.label.display.name=Etiqueta innecesaria
unnecessary.label.error.string=Etiqueta innecesaria <code>#ref</code> #loc
unnecessary.label.on.break.error.string=Sentencia <code>#ref</code> con etiqueta innecesaria #loc
unnecessary.label.on.break.statement.display.name=Etiqueta innecesaria en la sentencia 'break'
unnecessary.label.on.continue.error.string=Sentencia <code>#ref</code> con una etiqueta innecesaria #loc
unnecessary.label.on.continue.statement.display.name=Etiqueta innecesaria en la sentencia 'continue'
unnecessary.local.variable.problem.descriptor=La variable local {0} es redundante
unnecessary.return.error.string=<code>#ref</code> es innecesario como última sentencia en una función sin valor de retorno #loc
unnecessary.return.statement.display.name=Sentencia 'return' innecesaria
unreachable.code.display.name=Código inalcanzable
unreachable.code.error.string=Código inaccesible #loc
unterminated.statement.display.name=Sentencia no terminada
unterminated.statement.error.string=Sentencia sin terminar #loc
unterminated.statement.ignore.atend.of.block=Permitir la ausencia de punto y coma al final del bloque
unterminated.statement.possibly.unterminated.statement.error=Sentencia posiblemente no finalizada #loc
unused.catch.parameter.display.name=Parámetro 'catch' no utilizado
unused.catch.parameter.ignore.catch.option=Ignorar bloques catch que contienen comentarios
unused.catch.parameter.problem.descriptor=Parámetro catch no utilizado <code>#ref</code> #loc
use.of.innerhtml.property.display.name=Uso de la propiedad 'innerHTML'
variable.name.doesnt.match.regex.error.string=El nombre de la variable ''#ref'' no coincide con la expresión regular ''{0}'' #loc
variable.name.is.too.long.error.string=El nombre de la variable '#ref' es demasiado largo #loc
variable.name.is.too.short.error.string=El nombre de la variable '#ref' es demasiado corto #loc
void.expression.display.name=Expresión 'void'
void.expression.error.string='#ref' expresión #loc
with.expression.error.string=Sentencia '#ref' #loc
with.statement.display.name=sentencia 'with'
wrap.statement.body.fix=Envolver el cuerpo de la sentencia
xhtml.incompatabilities.error.string='#ref' puede producir resultados inconsistentes para documentos XHTML #loc
xhtml.incompatibilities.display.name=Usos de XHTML incompatibles
