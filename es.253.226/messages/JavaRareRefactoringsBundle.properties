action.Generify.description=Convierte el código para usar tipos genéricos
action.Generify.text=Convertir tipos raw a genéricos…
action.RemoveMiddleman.description=Inlinear la delegación al método de campo seleccionado
action.RemoveMiddleman.text=Eliminar intermediario(_M)…
action.ReplaceTempWithQuery.description=Convierte la variable seleccionada en un método
action.ReplaceTempWithQuery.text=Reemplazar temporal con consulta(_Q)…
action.WrapReturnValue.description=Envuelve el valor de retorno del método especificado con un objeto
action.WrapReturnValue.text=Envolver el valor de retorno del método(_P)…
cannot.replace.temp.with.query.in.interface=No se puede reemplazar temp con una consulta en una interfaz
constructor.returns.can.not.be.wrapped=No se puede envolver el valor de retorno del constructor.
could.not.find.selected.wrapping.class=No se pudo encontrar la clase envolvente seleccionada
declaration.s.to.be.generified=Declaración(es) a las que se aplicarán genéricos {0}
delegating.field=Delegando campo
dialog.message.inner.class.with.name.already.exist=Ya existe una clase interna con el nombre ''{0}''
dialog.message.invalid.inner.class.name=''{0}'' no es un nombre de clase interna válido
dialog.message.invalid.qualified.wrapper.class.name=''{0}'' no es un nombre de clase de envoltorio calificado válido
dialog.message.invalid.wrapper.class.name=''{0}'' es un nombre de clase wrapper no válido
dialog.message.invalid.wrapper.class.package.name=''{0}'' es un nombre de paquete de clase wrapper no válido
dialog.message.wrapper.field.not.found=No se encontró el campo del envoltorio
error.wrong.caret.position.local.name=El cursor debe situarse sobre el nombre de la variable local a refactorizar.
exposed.delegation.command.name=Delegación expuesta a {0}
field.selected.is.not.used.as.a.delegate=El campo seleccionado no se utiliza como delegado.
generify.title=Convertir tipos raw a genéricos
method.selected.returns.void=El método seleccionado devuelve 'void'.
method.to.wrap.returns.from.label=Método desde el cual envolver los retornos:
method.whose.return.are.to.wrapped=Métodos cuyos valores de retorno deben ser envueltos
references.to.be.modified.usage.view=Referencias a modificar {0, choice, 0#(no encontradas)|1#{0} referencia|2#{0} referencias}{1, choice, 0#|1# en {1} archivo|2# en {1} archivos}
references.to.expose.usage.view=Referencias para mostrar {0, choice, 0#(no encontradas)|1#{0} referencia|2#{0} referencias}{1, choice, 0#|1# en {1} archivo|2# en {1} archivos}
remove.middleman=Eliminar intermediario
remove.middleman.column.header=Eliminar
remove.middleman.deleted.hierarchy.conflict={0} se eliminará. Se romperá la jerarquía.
remove.middleman.field.header=Eliminar campo intermediario:
remove.middleman.methods.to.inline.title=Métodos para insertar en línea (&M)
remove.middleman.title=Eliminar intermediario
remove.middleman.tooltip.warning=La eliminación romperá la jerarquía de tipos
replace.temp.with.query.title=Reemplazar variable temporal con consulta
the.caret.should.be.positioned.at.the.name.of.the.field.to.be.refactored=El cursor debe estar situado en el nombre del campo que se va a refactorizar.
there.already.exists.a.class.with.the.selected.name=Ya existe una clase con el nombre seleccionado
type.cook.command=Generalización
type.cook.drop.obsolete.casts=Eliminar casts obsoletos (&D)
type.cook.elements.header=Ámbito de generificación
type.cook.generify.objects=Generificar objetos(&O)
type.cook.leave.object.parameterized.types.raw=Dejar los tipos parametrizados de objeto como raw (&L)
type.cook.perform.exhaustive.search=Realizar búsqueda exhaustiva(&E)
type.cook.preserve.raw.arrays=Preservar arrays originales (&A)
type.cook.produce.wildcard.types=Generar tipos comodín (&W)
type.cook.ratio.generified={0,choice,-1#No calculado|0#{0,number}/{1}}
type.cook.report=Elementos generalizados: {0}, conversiones eliminadas: {1}
wrap.return.value=Envolver valor de retorno
wrap.return.value.title=Envolver valor de retorno
wrapped.return.command.name=Envolver el valor de retorno como {0} de {1}()
