ACT.CMD.use.import=Usar un módulo importado
ACT.from.some.module.import=Importar desde…
ACT.qualify.with.module=Calificar con un módulo importado
ANN.assign.to.none=Asignación a None
ANN.assignment.expression.as.a.target=La expresión de asignación no se puede utilizar como destino aquí
ANN.assignment.expression.in.an.iterable=No se puede utilizar una expresión de asignación en un iterable de comprensión
ANN.assignment.expressions.within.a.comprehension.cannot.be.used.in.a.class.body=Las expresiones de asignación dentro de una comprensión no se pueden usar en el cuerpo de una clase
ANN.assignment.to.keyword=Asignación a palabra clave
ANN.async.for.outside.function='async for' fuera de una función async
ANN.async.with.outside.function='async with' fuera de una función async
ANN.await.outside.async.function='await' fuera de una función asíncrona
ANN.break.outside.loop='break' fuera del bucle
ANN.can.t.use.starred.expression.here=No se puede usar una expresión con asterisco aquí
ANN.cannot.assign.to.debug=No se puede asignar a _debug__(_D)
ANN.cant.assign.to.await.expr=No se puede asignar a una expresión await
ANN.cant.assign.to.call=No se puede asignar a una llamada a función
ANN.cant.assign.to.comprh=No se puede asignar a una comprensión de lista
ANN.cant.assign.to.dict.comprh=No se puede asignar a una comprensión de diccionario
ANN.cant.assign.to.generator=No se puede asignar a una expresión generadora
ANN.cant.assign.to.lambda=No se puede asignar a una lambda
ANN.cant.assign.to.literal=No se puede asignar a un literal
ANN.cant.assign.to.operator=No se puede asignar al operador
ANN.cant.assign.to.parens=No se puede asignar a ()
ANN.cant.assign.to.set.comprh=No se puede asignar a una comprensión de conjuntos
ANN.cant.aug.assign.starred.assignment.target.must.be.in.list.or.tuple=El destino de la asignación con asterisco debe estar en una lista o tupla
ANN.cant.aug.assign.to.comprh=No es posible la asignación aumentada en una comprensión de listas
ANN.cant.aug.assign.to.dict.comprh=No es posible realizar una asignación aumentada a una comprensión de diccionario
ANN.cant.aug.assign.to.generator=No es posible realizar una asignación aumentada a una expresión generadora
ANN.cant.aug.assign.to.list.or.comprh=No es posible la asignación aumentada a un literal de lista o comprensión
ANN.cant.aug.assign.to.set.comprh=La asignación aumentada a una comprensión de conjuntos no es posible
ANN.cant.aug.assign.to.tuple.or.generator=No es posible realizar una asignación aumentada en un literal de tupla o una expresión generadora
ANN.cant.delete.call=No se puede eliminar la llamada a la función
ANN.cant.delete.literal=No se puede eliminar literal
ANN.continue.break.or.return.in.star.except='break', 'continue' y 'return' no pueden aparecer en un bloque except*
ANN.continue.outside.loop=continuar fuera del bucle
ANN.default.except.must.be.last=El 'except:' por defecto debe ser el último
ANN.deleting.none=Eliminando None
ANN.duplicate.param.name=Nombre de parámetro duplicado
ANN.exception.group.in.star.except=ExceptionGroup no se puede usar en except*
ANN.fstrings.illegal.conversion.character=Carácter de conversión no válido ''{0}'': debe ser uno de ''s'', ''r'', ''a''
ANN.fstrings.missing.conversion.character=Se espera un carácter de conversión: debe ser uno de 's', 'r', 'a'
ANN.fstrings.single.right.brace.not.allowed.inside.fstrings=No se permite una sola '}' dentro de f-strings
ANN.generator.expression.must.be.parenthesized.if.not.sole.argument=La expresión generadora debe estar entre paréntesis si no es el único argumento
ANN.ignore.errors.like.this=Ignorar errores como este
ANN.illegal.target.for.variable.annotation=Destino no válido para una anotación de variable
ANN.missing.closing.quote=Falta la comilla de cierre [{0}]
ANN.missing.closing.triple.quotes=Faltan las comillas triples de cierre
ANN.multiple.args=múltiples * parámetros no están permitidos
ANN.multiple.kwargs=No se permiten múltiples parámetros **
ANN.multiple.slash=No se permiten múltiples parámetros /
ANN.name.used.both.as.global.and.param=El nombre ''{0}'' se utiliza tanto como parámetro como global
ANN.named.parameters.after.star=Los parámetros con nombre deben seguir a un * solo
ANN.named.parameters.before.slash=Los parámetros con nombre deben preceder a /
ANN.no.exception.to.reraise=No hay ninguna excepción para volver a lanzar
ANN.non.default.param.after.default=Un parámetro no predeterminado sigue a un parámetro predeterminado
ANN.non.empty.return.inside.asynchronous.generator='return' no vacío dentro de un generador asíncrono
ANN.patterns.attribute.name.is.repeated=El nombre de atributo ''{0}'' está repetido
ANN.patterns.double.star.pattern.cannot.be.used.outside.mapping.patterns=El patrón de doble asterisco no se puede usar fuera de los patrones de mapeo
ANN.patterns.invalid.complex.number.literal=Literal de número complejo no válido
ANN.patterns.key.pattern.can.only.be.value.or.literal.pattern=El patrón de clave solo puede ser un patrón de valor o un patrón literal
ANN.patterns.name.already.bound=El nombre ''{0}'' ya está vinculado
ANN.patterns.pattern.does.not.bind.names=El patrón no vincula {0,choice,1#el nombre|2#los nombres} {1}
ANN.patterns.pattern.makes.remaining.alternatives.unreachable=El patrón hace que las alternativas restantes sean inalcanzables
ANN.patterns.pattern.makes.remaining.case.clauses.unreachable=El patrón hace que las cláusulas case restantes sean inalcanzables
ANN.patterns.repeated.star.pattern=Patrón de asterisco repetido
ANN.patterns.single.star.pattern.cannot.be.used.outside.sequence.patterns=El patrón de estrella única no se puede usar fuera de los patrones de secuencia.
ANN.positional.only.param.after.keyword=Un parámetro únicamente de posición sigue a un parámetro que no es únicamente de posición
ANN.python.does.not.support.yield.from.inside.async.functions=Python no admite 'yield from' dentro de funciones asíncronas
ANN.regular.param.after.keyword=Parámetro regular después del parámetro **
ANN.regular.param.after.vararg=Parámetro normal después del parámetro *
ANN.return.outside.of.function='return' fuera de la función
ANN.slash.param.after.keyword=El parámetro / debe preceder al parámetro **
ANN.slash.param.after.vararg=El parámetro / debe preceder al parámetro *
ANN.star.import.at.top.only='import *' sólo está permitido a nivel del módulo
ANN.starred.param.after.kwparam=Parámetro * después del parámetro **
ANN.try.except.can.not.have.except.and.star.except=La sentencia try no puede contener tanto except como except*
ANN.tuple.py3=El desempaquetado de parámetros de tupla no se admite en Python 3
ANN.unparenthesized.assignment.expression.statement=Las expresiones de asignación sin paréntesis están prohibidas en el nivel superior de una sentencia de expresión
ANN.unparenthesized.assignment.expression.value=Se prohíben las expresiones de asignación sin paréntesis en el nivel superior del lado derecho de una sentencia de asignación
ANN.variable.annotation.cannot.be.combined.with.tuple.unpacking=Una anotación de variable no se puede combinar con el desempaquetado de tuplas
ANN.variable.annotation.cannot.be.used.in.assignment.with.multiple.targets=Una anotación de variable no se puede utilizar en una asignación con múltiples destinos
ANN.yield.outside.of.function='yield' fuera de la función
INLAY.function.return=Tipos de retorno de función
INLAY.reveal.type=Tipo de argumento de 'reveal_type'
INLAY.type.hints=Sugerencias de tipo de Python
INSP.GROUP.python=Python
INSP.NAME.abstract.class=Definición y usos de clase abstracta no válidos
INSP.NAME.argument.equal.default=El argumento de la función es igual al valor predeterminado del parámetro
INSP.NAME.assert.type=typing.assert_type
INSP.NAME.assignment.to.loop.or.with.parameter=Asignaciones a parámetros de bucle 'for' o de sentencia 'with'
INSP.NAME.attribute.outside.init=Atributo de instancia definido fuera de `__init__`
INSP.NAME.augment.assignment=La asignación puede reemplazarse por una asignación compuesta
INSP.NAME.bad.except.clauses.order=Orden incorrecto de las cláusulas 'except'
INSP.NAME.byte.literal=Un literal de byte contiene un carácter no ASCII
INSP.NAME.calling.non.callable=Intento de llamada a un objeto no invocable
INSP.NAME.chained.comparisons=Comparaciones encadenadas demasiado complejas
INSP.NAME.check.can.be.simplified=Comprobación de variable booleana redundante
INSP.NAME.class.has.no.init=La clase no tiene el método `__init__`
INSP.NAME.class.var.variables=Uso no válido de variables ClassVar
INSP.NAME.classic.class.usage=Uso de clase de estilo clásico
INSP.NAME.comparison.with.none=Uso de operadores de igualdad para comparar con None
INSP.NAME.compatibility=El código es incompatible con versiones específicas de Python
INSP.NAME.coroutine.is.not.awaited=La corrutina ''{0}'' no se ha esperado
INSP.NAME.dataclass.definition.and.usages=Definición y uso no válidos de clases de datos
INSP.NAME.decorator.outside.class=Decorador específico de clase utilizado fuera de la clase
INSP.NAME.default.argument=El argumento por defecto es mutable
INSP.NAME.deprecated.function.class.or.module=Función, clase o módulo en desuso
INSP.NAME.dict.creation=La creación de diccionarios se puede reescribir con un literal de diccionario
INSP.NAME.docstring.types=El tipo en la docstring no coincide con el tipo inferido
INSP.NAME.dunder.slots=Usos no válidos de clases con definiciones '_slots__'(_S)
INSP.NAME.duplicate.keys=El diccionario contiene claves duplicadas
INSP.NAME.enum=Definición y usos de enumeraciones no válidos
INSP.NAME.exception.not.inherit=Las excepciones no heredan de la clase estándar 'Exception'
INSP.NAME.final.classes.methods.and.variables=Usos no válidos de clases, métodos y variables final
INSP.NAME.first.arg.assign=El primer argumento del método se reasigna
INSP.NAME.from.future.import=Posición incorrecta de from _future__ import(_F)
INSP.NAME.global.undefined=Variable global no definida a nivel de módulo
INSP.NAME.inconsistent.indentation=Sangría inconsistente
INSP.NAME.inconsistent.returns=Sentencias de retorno inconsistentes
INSP.NAME.incorrect.call.arguments=Argumentos de llamada incorrectos
INSP.NAME.incorrect.docstring=Docstring incorrecto
INSP.NAME.init.return=Método _init__ que devuelve un valor(_I)
INSP.NAME.invalid.interpreter=Intérprete no válido
INSP.NAME.invalid.usages.of.override.decorator=Usos inválidos del decorador @override
INSP.NAME.list.creation=Declaración de lista no óptima
INSP.NAME.mandatory.encoding=Codificación no especificada para el archivo
INSP.NAME.method.may.be.static=El método no está declarado como static
INSP.NAME.method.over=La firma del método no coincide con la firma del método sobrescrito
INSP.NAME.missing.or.empty.docstring=Docstring ausente o vacío
INSP.NAME.missing.super.constructor=Falta la llamada a '_init__' de la superclase(_I)
INSP.NAME.missing.type.hints=Faltan sugerencias de tipo para la definición de la función
INSP.NAME.nested.decorators=Anidamiento problemático de decoradores
INSP.NAME.new.init.signature=Firmas incompatibles de _new__ e _init__(_N)
INSP.NAME.new.style.generics.type.param.syntax=Parámetros de tipo de estilo nuevo y pseudónimos de tipos de uso no válido
INSP.NAME.new.type=Uso no válido de NewType
INSP.NAME.new.type.cannot.be.subclassed=''{0}'' no puede tener subclases
INSP.NAME.new.type.expected.class=Clase esperada
INSP.NAME.new.type.new.type.cannot.be.generic=NewType no puede ser genérico
INSP.NAME.new.type.new.type.cannot.be.used.with=NewType no se puede usar con ''{0}''
INSP.NAME.new.type.variable.name.does.not.match.new.type.name=El nombre de la variable ''{0}'' no coincide con el nombre de NewType ''{1}''
INSP.NAME.non.ascii=El archivo contiene caracteres no ASCII
INSP.NAME.none.function.assignment=Asignación de llamadas a funciones que no devuelven nada
INSP.NAME.oldstyle.class=Clase de estilo antiguo contiene características de clase de estilo nuevo
INSP.NAME.overloads.in.regular.python.files=Sobrecargas en archivos Python normales
INSP.NAME.pep8.naming=Violación de la convención de nomenclatura PEP 8
INSP.NAME.problematic.first.parameter=Primer parámetro incorrecto
INSP.NAME.property.access=Acceso inadecuado a propiedades
INSP.NAME.property.definition=Definición de propiedad incorrecta
INSP.NAME.protected.member=Acceso a un miembro protegido de una clase o un módulo
INSP.NAME.protocol.definition.and.usages=Definiciones y usos de protocolos inválidos
INSP.NAME.pytest-parametrized=Argumentos incorrectos en @pytest.mark.parametrize
INSP.NAME.pytest.unpassed.fixture=El fixture no es solicitado por las funciones de prueba
INSP.NAME.redeclaration=Nombres redeclarados sin uso
INSP.NAME.redundant.parentheses=Paréntesis redundantes
INSP.NAME.relative.import=Importaciones relativas sospechosas
INSP.NAME.requirements=Requisitos de paquetes no satisfechos
INSP.NAME.set.function.to.literal=La llamada a la función se puede reemplazar por un literal de conjunto
INSP.NAME.shadowing.builtins=Sombreado de nombres integrados
INSP.NAME.single.quoted.docstring=Docstring con comillas simples
INSP.NAME.statement.effect=La sentencia no tiene efecto
INSP.NAME.str.format=Errores en operaciones de formato de cadenas
INSP.NAME.too.broad.exception.clauses=Cláusulas de excepción poco claras
INSP.NAME.trailing.semicolon=Punto y coma final prohibido en una sentencia
INSP.NAME.tuple.assignment.balance=El balance de la asignación de tuplas es incorrecto
INSP.NAME.tuple.item.assignment=La asignación de elementos de tupla está prohibida
INSP.NAME.type.checker=Error de tipo
INSP.NAME.type.hints=Definiciones y usos de sugerencias de tipos no válidos
INSP.NAME.typed.dict=Definición y usos de TypedDict no válidos
INSP.NAME.unbound=Variables locales no vinculadas
INSP.NAME.unnecessary.backslash=Barra invertida innecesaria
INSP.NAME.unreachable.code=Código inalcanzable
INSP.NAME.unresolved.refs=Referencias sin resolver
INSP.NAME.unused=Símbolos locales no utilizados
INSP.NAME.unused.imports=Importaciones no utilizadas
INSP.NAME.wrong.super.arguments=Argumentos incorrectos para llamar a super
INSP.abstract.class.abstract.methods.are.allowed.in.classes.whose.metaclass.is.abcmeta=Se permiten métodos abstractos en clases cuya metaclase sea 'ABCMeta'
INSP.abstract.class.add.to.superclasses=Añadir ''{0}'' a las superclases
INSP.abstract.class.cannot.instantiate.abstract.class=No se puede instanciar la clase abstracta ''{0}''
INSP.abstract.class.class.must.implement.all.abstract.methods=La clase {0} debe implementar todos los métodos abstractos
INSP.abstract.class.set.as.metaclass=Establecer ''{0}'' como metaclase
INSP.argument.equals.to.default=El argumento es igual al valor predeterminado del parámetro
INSP.arguments.not.declared.but.provided.by.decorator=Los siguientes argumentos no están declarados pero son proporcionados por el decorador: {0}
INSP.assert.type.expected.type.got.type.instead=Se esperaba el tipo ''{0}'', pero se obtuvo ''{1}''
INSP.assignment.can.be.replaced.with.augmented.assignment=La asignación puede reemplazarse por una asignación compuesta
INSP.assignment.to.loop.or.with.parameter=La variable ''{0}'' ya está declarada en el bucle ''for'' o en la sentencia ''with'' anterior
INSP.async.call=Falta la sintaxis `await` en las llamadas a corrutinas
INSP.attribute.outside.init=Atributo de instancia {0} definido fuera de _init__(_I)
INSP.auto.to.manual.field.numbering=No se puede cambiar de la numeración de campos automática a la especificación de campos manual
INSP.bad.except.exception.class.already.caught=La clase de excepción ''{0}'' ya ha sido capturada
INSP.bad.except.superclass.of.exception.class.already.caught=''{0}'', superclase de la clase de excepción ''{1}'', ya ha sido capturada
INSP.byte.literal.contains.illegal.characters=El literal de byte contiene caracteres > 255
INSP.cant.return.value.from.init=No se puede devolver un valor desde _init__(_I)
INSP.chained.comparisons.ignore.statements.with.constant.in.the.middle=Ignorar sentencias con una constante en el medio
INSP.class.has.no.init=La clase no tiene el método _init__(_I)
INSP.class.is.not.subtype.of.class='{0}'' no es una instancia o una subclase de ''{1}'
INSP.class.object.is.not.callable=El objeto ''{0}'' no es invocable
INSP.class.var.can.be.used.only.in.class.body='ClassVar' solo puede usarse en el cuerpo de la clase
INSP.class.var.can.not.be.assigned.to.instance=No se puede asignar a la variable de clase ''{0}'' a través de una instancia
INSP.class.var.can.not.be.nested='ClassVar' no se puede anidar
INSP.class.var.can.not.be.used.in.annotation.for.function.return.value=No se puede usar 'ClassVar' en la anotación del valor de retorno de una función
INSP.class.var.can.not.be.used.in.annotations.for.function.parameters='ClassVar' no se puede usar en anotaciones para parámetros de función
INSP.class.var.can.not.be.used.in.function.body=No es posible usar 'ClassVar' en anotaciones para variables locales
INSP.class.var.can.not.include.type.variables=El parámetro 'ClassVar' no puede incluir variables de tipo
INSP.class.var.can.not.override.class.variable=No se puede sobrescribir la variable de clase ''{0}'' (declarada anteriormente en la clase base ''{1}'') con una variable de instancia
INSP.class.var.can.not.override.instance.variable=No se puede sobrescribir la variable de instancia ''{0}'' (declarada previamente en la clase base ''{1}'') con una variable de clase
INSP.class.var.can.only.be.parameterized.with.one.type='ClassVar' solo puede parametrizarse con un tipo
INSP.class.var.is.not.allowed.here=No se permite 'ClassVar' aquí
INSP.class.var.not.a.valid.type=No es un tipo válido
INSP.classic.class.usage.old.style.class=Clase de estilo antiguo
INSP.classic.class.usage.old.style.class.ancestors=Clase de estilo antiguo, porque todas las clases de las que hereda son de estilo antiguo
INSP.comparison.with.none.performed.with.equality.operators=Comparación con None realizada con operadores de igualdad
INSP.compatibility.basestring.type.not.available.in.py3=El tipo basestring no está disponible en Python 3
INSP.compatibility.check.for.compatibility.with.python.versions=Comprobar compatibilidad con las versiones de Python:
INSP.compatibility.feature.allow.async.and.await.as.names=Permitir 'async' y 'await' como nombres
INSP.compatibility.feature.allow.backslashes.in.f-strings=Permitir barras invertidas dentro de las partes de expresión de las f-strings
INSP.compatibility.feature.allow.deep.expression.nesting.in.f-strings=Permitir el anidamiento de expresiones en especificadores de formato a esta profundidad
INSP.compatibility.feature.allow.duplicate.kwargs=Permitir expresiones ** duplicadas
INSP.compatibility.feature.allow.duplicate.positional.varargs=Permitir expresiones * duplicadas
INSP.compatibility.feature.allow.keyword.arguments.after.kwargs=Permitir argumentos de palabra clave después de la expresión **
INSP.compatibility.feature.allow.new.lines.in.f-strings=Permitir saltos de línea en las partes de expresión de f-strings sin comillas triples
INSP.compatibility.feature.allow.positional.arguments.after.expression=Permitir argumentos posicionales después de *expression
INSP.compatibility.feature.allow.quote.reuse.in.f-strings=Permitir el anidamiento de literales de cadena con el mismo tipo de comillas dentro de f-strings
INSP.compatibility.feature.allow.to.mix.bytes.and.non.bytes.literals=Permitir mezclar literales de bytes y no bytes
INSP.compatibility.feature.allow.trailing.comma.after.kwargs=Permitir una coma final después de la expresión **
INSP.compatibility.feature.allow.trailing.comma.after.positional.vararg=Permitir una coma final después de la expresión *
INSP.compatibility.feature.have.method=Tiene el método {0}
INSP.compatibility.feature.have.module=Tiene el módulo {0}
INSP.compatibility.feature.have.module.builtin=tiene módulo builtin
INSP.compatibility.feature.have.module.builtins=Tener integrados del módulo
INSP.compatibility.feature.have.nonlocal.keyword=Tiene la palabra clave nonlocal
INSP.compatibility.feature.have.type.long=Es de tipo long. Use int en su lugar.
INSP.compatibility.feature.line.comments.in.f-strings=Permitir comentarios dentro de las partes de expresión de las f-strings
INSP.compatibility.feature.support.arbitrary.expressions.as.decorator=Soporte para expresiones arbitrarias como decorador
INSP.compatibility.feature.support.assignment.expressions=Soporte para expresiones de asignación
INSP.compatibility.feature.support.backquotes=se soporta comillas invertidas, usar repr() en su lugar
INSP.compatibility.feature.support.continue.inside.finally.clause=Soporte para 'continue' dentro de la cláusula 'finally'
INSP.compatibility.feature.support.diamond.operator=Admite <>, use != en su lugar
INSP.compatibility.feature.support.ellipsis.outside.slices=soportar '...' fuera de las secciones de secuencias
INSP.compatibility.feature.support.long.integer.literal.suffix=Soporte para un ''{0}'' final
INSP.compatibility.feature.support.match.statements=Soporte para sentencias match
INSP.compatibility.feature.support.matrix.multiplication.operators=Soporte para operadores de multiplicación de matrices
INSP.compatibility.feature.support.old.style.octal.literals=Admite esta sintaxis. Requiere el prefijo '0o' para literales octales.
INSP.compatibility.feature.support.parenthesized.context.expressions=Soporte para expresiones de contexto entre paréntesis
INSP.compatibility.feature.support.positional.only.parameters=Admite parámetros únicamente posicionales
INSP.compatibility.feature.support.print.statement=Admite esta sintaxis. La sentencia print se ha sustituido por una función print()
INSP.compatibility.feature.support.raise.with.no.arguments.outside.except.block=Admite esta sintaxis. raise sin argumentos solo se puede utilizar en un bloque except
INSP.compatibility.feature.support.starred.except.part=Soporte para la parte except*
INSP.compatibility.feature.support.starred.expressions.as.assignment.targets=Soporte de expresiones con asterisco como objetivos de asignación
INSP.compatibility.feature.support.starred.expressions.in.dicts=Soporte para expresiones con asterisco en diccionarios
INSP.compatibility.feature.support.starred.expressions.in.subscriptions=Soporte para expresiones con asterisco en las suscripciones
INSP.compatibility.feature.support.starred.expressions.in.tuples.lists.and.sets=Soporte para expresiones con asterisco en tuplas, listas y conjuntos
INSP.compatibility.feature.support.starred.expressions.in.type.annotations=Soporte para expresiones con asterisco en anotaciones de tipo
INSP.compatibility.feature.support.string.literal.prefix=Admite un prefijo ''{0}''
INSP.compatibility.feature.support.super.without.arguments=Admite esta sintaxis. super() debe tener argumentos en Python 2
INSP.compatibility.feature.support.this.syntax=Admite esta sintaxis
INSP.compatibility.feature.support.this.syntax.in.list.comprehensions=Soporta esta sintaxis en comprensiones de lista
INSP.compatibility.feature.support.type.alias.statements=Soporte para sentencias de alias de tipo
INSP.compatibility.feature.support.underscores.in.numeric.literals=Soporte para guiones bajos en literales numéricos
INSP.compatibility.feature.support.unpacking.without.parentheses.in.return.statements=Soporte para desempaquetado sin paréntesis en sentencias return
INSP.compatibility.feature.support.unpacking.without.parentheses.in.yield.statements=Soporte para el desempaquetado sin paréntesis en sentencias yield
INSP.compatibility.feature.support.variable.annotations=Soporte de anotaciones de variables
INSP.compatibility.feature.support.yield.from=Admite esta sintaxis. La delegación a un subgenerador está disponible desde Python 3.3; utilice una iteración explícita sobre el subgenerador en su lugar.
INSP.compatibility.inspection.unsupported.feature.prefix=Python {0,choice,1#versión|2#versiones} {1} {0,choice,1#no|2#no} {2}
INSP.compatibility.keyword.argument.repeated=Argumento de palabra clave repetido
INSP.compatibility.new.union.syntax.not.available.in.earlier.version=Permitir escribir tipos de unión como X | Y
INSP.compatibility.old.dict.methods.not.available.in.py3=Los métodos dict.iterkeys(), dict.iteritems() y dict.itervalues() no están disponibles en Python 3
INSP.compatibility.positional.argument.after.keyword.argument=Argumento posicional después de un argumento de palabra clave
INSP.compatibility.positional.argument.after.kwargs=Argumento posicional después de la expresión **
INSP.compatibility.pre35.versions.do.not.allow.return.with.argument.inside.generator=Las versiones de Python < 3.3 no permiten 'return' con argumentos dentro de un generador.
INSP.compatibility.support.equality.signs.in.fstrings=Soporte para signos de igualdad en f-strings
INSP.compatibility.this.syntax.available.only.since.py3=Esta sintaxis solo está disponible desde Python 3
INSP.dataclasses.argument.ignored.if.class.already.defines.method='{0}'' se ignora si la clase ya define el método ''{1}'
INSP.dataclasses.attribute.default.set.using.method=Se establece un valor predeterminado mediante ''{0}''
INSP.dataclasses.attribute.lacks.type.annotation=El atributo ''{0}'' carece de una anotación de tipo
INSP.dataclasses.attribute.useless.until.post.init.declared=El atributo ''{0}'' es inútil hasta que se declare ''__post_init__''
INSP.dataclasses.attrs.post.init.should.not.take.any.parameters.except.self=__attrs_post_init__' no debería aceptar ningún parámetro excepto 'self
INSP.dataclasses.attrs.post.init.would.not.be.called.until.init.parameter.set.to.true='__attrs_post_init__' no se llamará hasta que el parámetro 'init' se establezca en True
INSP.dataclasses.cannot.specify.both.default.and.default.factory=No se pueden especificar tanto 'default' como 'default_factory'
INSP.dataclasses.cannot.specify.both.default.and.factory=No se pueden especificar tanto 'default' como 'factory'
INSP.dataclasses.eq.must.be.true.if.order.true='eq' debe ser true si 'order' es true
INSP.dataclasses.expected.type.got.type.instead=Se esperaba el tipo ''{0}'', pero se obtuvo ''{1}'' en su lugar
INSP.dataclasses.field.cannot.have.default.factory=El campo no puede tener una factoría predeterminada
INSP.dataclasses.frozen.attribute.should.be.false.if.class.defines.setattr.or.delattr='frozen' debe ser False si la clase define '_setattr__' o '_delattr__'(_S)
INSP.dataclasses.frozen.dataclasses.can.not.inherit.non.frozen.one=Las clases de datos congeladas no pueden heredar de las no congeladas y viceversa
INSP.dataclasses.hash.ignored.if.class.already.defines.cmp.or.order.or.frozen.parameters=__hash__' se ignora si la clase ya define los parámetros 'cmp/order' y 'frozen
INSP.dataclasses.method.is.ignored.if.class.already.defines.parameter='{0}'' se ignora si la clase ya define el parámetro ''{1}'
INSP.dataclasses.method.should.be.called.on.attrs.instances=El método ''{0}'' debe llamarse en instancias de attrs
INSP.dataclasses.method.should.be.called.on.attrs.types=El método ''{0}'' se debe llamar en tipos attrs
INSP.dataclasses.method.should.be.called.on.dataclass.instances=El método ''{0}'' debe llamarse en instancias de dataclass
INSP.dataclasses.method.should.be.called.on.dataclass.instances.or.types=El método ''{0}'' debe llamarse en instancias o tipos de dataclass
INSP.dataclasses.method.should.take.only.n.parameter=''{0}'' solo debe tener {1} {1,choice,1#parámetro|2#parámetros}
INSP.dataclasses.mutable.attribute.default.not.allowed.use.default.factory=No se permite un valor predeterminado mutable ''{0}''. Utilice ''default_factory''
INSP.dataclasses.object.attribute.read.only=El atributo de objeto ''{1}'' de ''{0}'' es de solo lectura
INSP.dataclasses.object.could.have.no.attribute.because.it.declared.as.init.only=El objeto ''{0}'' podría no tener el atributo ''{1}'' porque está declarado como de solo inicialización
INSP.dataclasses.operator.not.supported.between.instances.of.class='{0}'' no es compatible entre instancias de ''{1}'
INSP.dataclasses.operator.not.supported.between.instances.of.classes='{0}'' no se admite entre instancias de ''{1}'' y ''{2}'
INSP.dataclasses.order.argument.should.be.false.if.class.defines.one.of.order.methods='order' debe ser False si la clase define uno de los métodos de ordenación (order methods)
INSP.dataclasses.post.init.should.take.all.init.only.variables.in.same.order.they.defined='__post_init__' debe recibir todas las variables de solo inicialización en el mismo orden en el que fueron definidas
INSP.dataclasses.post.init.should.take.all.init.only.variables.including.inherited.in.same.order.they.defined='__post_init__' debe aceptar todas las variables de solo inicialización (incluidas las heredadas) en el mismo orden en que están definidas
INSP.dataclasses.post.init.would.not.be.called.until.init.parameter.set.to.true='__post_init__' no se llamará hasta que el parámetro 'init' se establezca en True
INSP.dataclasses.unsafe.hash.attribute.should.be.false.if.class.defines.hash=Unsafe_hash' debe ser False si la clase define '__hash__
INSP.decorator.receives.unexpected.builtin=Este decorador no recibirá el objeto invocable que espera; el decorador llamado anteriormente ''{0}'' devuelve un objeto especial
INSP.decorators.method.only.decorator.on.method.outside.class=Decorador {0} en un método fuera de la clase
INSP.default.arguments.default.argument.value.mutable=El valor del argumento predeterminado es mutable
INSP.deleter.should.not.return=El eliminador no debe devolver un valor
INSP.deleter.signature.advice=La signatura del deleter debe ser (self)
INSP.deprecation.abc.decorator.deprecated.use.alternative=''{0}'' está en desuso desde Python 3.3. Use ''{1}'' con ''{2}'' en su lugar.
INSP.dict.creation.this.dictionary.creation.could.be.rewritten.as.dictionary.literal=Esta creación de diccionario podría reescribirse como un literal de diccionario
INSP.doc.param.should.be.str=El parámetro doc debe ser una cadena de caracteres
INSP.docstring.types.change.type=Cambiar el tipo de {0} de {1} a {2}
INSP.docstring.types.dynamically.inferred.type.does.not.match.specified.type=El tipo inferido dinámicamente ''{0}'' no coincide con el tipo especificado ''{1}''
INSP.docstring.types.fix.docstring=Corregir docstring
INSP.dunder.slots.class.object.attribute.read.only=''{0}'' atributo de objeto ''{1}'' es de solo lectura
INSP.dunder.slots.name.in.slots.conflicts.with.class.variable=''{0}'' en '_slots__' entra en conflicto con una variable de clase(_S)
INSP.duplicate.keys.dictionary.contains.duplicate.keys=El diccionario contiene claves duplicadas ''{0}''
INSP.empty.docstring=Docstring vacío
INSP.enum.enum.class.is.final.and.cannot.be.subclassed=La clase enum ''{0}'' es final y no puede ser subclaseada
INSP.enum.type.annotations.are.not.allowed.for.enum.members=No se permiten anotaciones de tipo para los miembros de la enumeración
INSP.enum.type.is.not.assignable.to.declared.type=El tipo ''{0}'' no se puede asignar al tipo declarado ''{1}''
INSP.exception.inheritance.exception.does.not.inherit.from.base.exception.class=La excepción no hereda de la clase base 'Exception'
INSP.expected.dict.got.type=Se esperaba un mapeo, se obtuvo {0}
INSP.expected.iterable.got.type=Se esperaba un iterable, se obtuvo {0}
INSP.expression.can.be.simplified=La expresión se puede simplificar
INSP.expression.is.not.callable=La expresión no es invocable
INSP.final.already.declared.name.could.not.be.redefined.as.final=El nombre ya declarado no se pudo redefinir como 'Final'
INSP.final.can.only.be.parameterized.with.one.type='Final' solo puede parametrizarse con un tipo
INSP.final.either.instance.attribute.or.class.attribute.could.be.type.hinted.as.final=El atributo de instancia o el atributo de clase podrían tener la sugerencia de tipo 'Final'
INSP.final.final.attribute.could.not.be.overridden=''{0}'' es ''Final'' y no se puede sobrescribir
INSP.final.final.attribute.should.be.declared.in.class.body.or.init=El atributo 'Final' debe declararse en el cuerpo de la clase o en '_init__'(_I)
INSP.final.final.class.could.not.contain.abstract.methods=La clase 'final' no puede contener métodos abstractos
INSP.final.final.could.not.be.mixed.with.abstract.decorators='Final' no puede combinarse con decoradores abstractos
INSP.final.final.could.not.be.used.in.annotation.for.function.return.value='Final' no se puede usar en la anotación para el valor de retorno de una función
INSP.final.final.could.not.be.used.in.annotations.for.function.parameters='Final' no se puede utilizar en anotaciones para parámetros de función
INSP.final.final.could.not.be.used.inside.loop='Final' no se puede usar dentro de un bucle
INSP.final.final.could.only.be.used.as.outermost.type='Final' solo puede utilizarse como el tipo más externo
INSP.final.final.name.should.be.initialized.with.value=El nombre 'Final' debe inicializarse con un valor
INSP.final.final.should.be.placed.on.first.overload='@final' deberá estar en la primera sobrecarga
INSP.final.final.should.be.placed.on.implementation='@final' se debe colocar en la implementación
INSP.final.final.target.could.not.be.reassigned=''{0}'' es ''Final'' y no se puede reasignar
INSP.final.if.assigned.value.omitted.there.should.be.explicit.type.argument.to.final=Si se omite el valor asignado, debe haber un argumento de tipo explícito para 'Final'
INSP.final.method.marked.as.final.should.not.be.overridden=''{0}'' está marcado como ''@final'' y no debería ser sobrescrito
INSP.final.no.need.to.mark.method.in.final.class.as.final=No es necesario marcar el método de una clase 'Final' como '@final'
INSP.final.non.method.function.could.not.be.marked.as.final=Una función que no es un método no se puede marcar como '@final'
INSP.final.super.classes.are.marked.as.final.and.should.not.be.subclassed={0} {1,choice,1#está marcado|2#están marcados} como ''@final'' y no {1,choice,1#debería|2#deberían} subclasificarse
INSP.first.arg.assign.method.parameter.reassigned=El parámetro del método ''{0}'' ha sido reasignado
INSP.first.param.must.not.be.tuple=El primer parámetro de un método no estático no debe ser una tupla.
INSP.format.requires.mapping=El formato requiere un mapeo
INSP.format.requires.no.mapping=El formato no requiere un mapeo
INSP.from.future.import.from.future.imports.must.occur.at.beginning.file=Las importaciones from _future__ deben aparecer al principio del archivo(_F)
INSP.func.property.name.mismatch=Los nombres de la función y del decorador no coinciden; no se ha creado el descriptor de acceso de la propiedad
INSP.function.lacks.positional.argument=La función ''{0}'' carece de un argumento posicional
INSP.getter.return.smth=El getter debe devolver o producir algo
INSP.getter.signature.advice=La firma del getter debe ser (self)
INSP.global.variable.undefined=La variable global ''{0}'' no está definida a nivel de módulo
INSP.incompatible.options=Las opciones de formato en el fragmento "{0}" son incompatibles
INSP.inconsistent.indentation.mix.tabs.spaces=Sangría inconsistente: mezcla de tabulaciones y espacios
INSP.inconsistent.indentation.previous.line.used.spaces.this.line.uses.tabs=Sangría inconsistente: la línea anterior usa espacios, esta línea usa tabulaciones
INSP.inconsistent.indentation.previous.line.used.tabs.this.line.uses.spaces=Sangría inconsistente: la línea anterior usó tabuladores, esta línea usa espacios
INSP.inconsistent.returns.missing.return.stmt.on.some.paths=Falta la instrucción return en algunas rutas
INSP.inconsistent.returns.return.without.value='return' sin valor es inconsistente con otras rutas
INSP.inconsistent.returns.stmt.expected=Se espera una instrucción de retorno explícita
INSP.inconsistent.returns.value.expected=Se esperaba un valor de retorno explícito
INSP.incorrect.arguments=Argumento(s) incorrecto(s)
INSP.init.incompatible.to.new=La firma no es compatible con _new__(_N)
INSP.interpreter.configure.python.interpreter=Configurar el intérprete de Python
INSP.interpreter.interpreter.settings=Configuración del intérprete
INSP.interpreter.invalid.python.interpreter.selected.for.module=Intérprete de Python no válido seleccionado para el módulo
INSP.interpreter.invalid.python.interpreter.selected.for.project=Se ha seleccionado un intérprete de Python no válido para el proyecto
INSP.interpreter.no.python.interpreter.configured.for.module=No se ha configurado ningún intérprete de Python para el módulo
INSP.interpreter.no.python.interpreter.configured.for.project=No se ha configurado ningún intérprete de Python para el proyecto
INSP.interpreter.pipenv.interpreter.associated.with.another.module=El intérprete Pipenv está asociado con otro módulo: ''{0}''
INSP.interpreter.pipenv.interpreter.associated.with.another.project=El intérprete de Pipenv está asociado con otro proyecto: ''{0}''
INSP.interpreter.pipenv.interpreter.not.associated.with.any.module=El intérprete de Pipenv no está asociado con ningún módulo
INSP.interpreter.pipenv.interpreter.not.associated.with.any.project=El intérprete Pipenv no está asociado a ningún proyecto
INSP.interpreter.python.has.reached.its.end.life.and.is.no.longer.supported.in.python.plugin=Python {0} ha alcanzado el final de su vida útil y ya no es compatible con el plugin de Python
INSP.interpreter.python.has.reached.its.end.of.life.and.is.no.longer.supported.in.pycharm=Python {0} ha llegado al final de su vida útil y ya no es compatible con PyCharm
INSP.interpreter.use.interpreter=Usar {0}
INSP.interpreter.use.suggested.interpreter=Usar el intérprete sugerido
INSP.list.creation.this.list.creation.could.be.rewritten.as.list.literal=La inicialización de lista en varios pasos se puede reemplazar con un literal de lista
INSP.mandatory.encoding.checkbox.enable.in.python.3=Habilitar en Python 3+
INSP.mandatory.encoding.label.encoding.comment.format=Formato de comentario de codificación:
INSP.mandatory.encoding.label.select.default.encoding=Seleccionar codificación predeterminada:
INSP.mandatory.encoding.no.encoding.specified.for.file=No se ha especificado una codificación para el archivo
INSP.manual.to.auto.field.numbering=No se puede cambiar de la especificación manual de campos a la numeración automática de campos
INSP.message.single.quoted.docstring=Se deben usar cadenas con triple comilla doble para los docstrings.
INSP.method.may.be.static=El método <code>#ref</code> puede ser 'static'
INSP.method.parameters.metaclass.method.first.argument.name=Nombre del primer argumento del método de la metaclasa
INSP.missing.parameter.in.docstring=Falta el parámetro {0} en el docstring
INSP.missing.super.constructor.message=Falta la llamada a _init__ de la superclase(_I)
INSP.missing.type.hints.add.type.hints=Añadir sugerencias de tipo
INSP.missing.type.hints.add.type.hints.for=Añadir sugerencias de tipo para ''{0}''
INSP.missing.type.hints.checkbox.only.when.types.are.known=Solo cuando los tipos sean conocidos (recopilados en tiempo de ejecución o inferidos)
INSP.missing.type.hints.type.hinting.missing.for.function.definition=Falta la indicación de tipos para una definición de función
INSP.must.have.first.parameter=El método debe tener un primer parámetro, normalmente llamado ''{0}''
INSP.named.tuple=Definición no válida de 'typing.NamedTuple'
INSP.new.incompatible.to.init=La firma no es compatible con _init__(_I)
INSP.new.style.generics.are.not.allowed.inside.type.param.bounds=No se permiten tipos genéricos dentro de las restricciones y límites de los parámetros de tipo
INSP.new.style.generics.assignment.expressions.not.allowed=No se permiten expresiones de asignación dentro de las declaraciones de clases, funciones y alias de tipo que tengan una lista de parámetros de tipo
INSP.new.style.generics.classes.with.type.param.list.should.not.extend.generic=Las clases con una lista de parámetros de tipo explícita no deben extender 'Generic'
INSP.new.style.generics.extending.protocol.does.not.need.parameterization=Extender 'Protocol' no requiere parametrización en clases con una lista de parámetros de tipo
INSP.new.style.generics.mixing.old.style.and.new.style.type.vars.not.allowed=No se permite mezclar variables de tipo de estilo tradicional y de nuevo estilo
INSP.new.style.generics.old.style.type.vars.not.allowed.in.new.style.type.aliases=No se permiten TypeVars tradicionales dentro de sentencias de alias de tipo de nuevo estilo
INSP.new.style.type.parameter.out.of.scope=La variable de tipo ''{0}'' está fuera de ámbito
INSP.no.docstring=Falta el docstring
INSP.no.format.specifier.char=Falta el carácter especificador de formato
INSP.non.ascii.char.non.ascii.character.in.file.but.no.encoding.declared=Carácter no ASCII ''{0}'' en el archivo, pero no se ha declarado ninguna codificación
INSP.none.function.assignment=La función ''{0}'' no devuelve nada
INSP.oldstyle.class.getattribute=La clase de estilo antiguo contiene la definición de _getattribute__(_G)
INSP.oldstyle.class.slots=La clase de estilo antiguo contiene la definición de _slots__(_S)
INSP.oldstyle.class.super=La clase de estilo antiguo contiene una llamada al método super
INSP.overloads.at.least.two.overloads.must.be.present=Deben estar presentes al menos dos {0,choice,0#funciones|1#métodos} decorados con @overload
INSP.overloads.final.should.be.placed.on.the.implementation='@final' debe colocarse en la implementación
INSP.overloads.final.should.be.placed.only.on.the.first.overload='@final' debe colocarse solo en la primera sobrecarga
INSP.overloads.override.should.be.placed.on.the.implementation='@override' debe colocarse en la implementación
INSP.overloads.override.should.be.placed.only.on.the.first.overload='@override' solo debe colocarse en la primera sobrecarga
INSP.overloads.series.overload.decorated.functions.should.always.be.followed.by.implementation=Una serie de funciones decoradas con @overload siempre debe ir seguida de una implementación que no esté decorada con @overload
INSP.overloads.series.overload.decorated.methods.should.always.be.followed.by.implementation=Una serie de métodos @overload-decorated debe ser siempre seguida por una implementación no @overload-ed
INSP.overloads.series.overloads.should.always.be.followed.by.implementation=Una serie de {0,choice,0#funciones|1#métodos} decorados con @overload siempre debe estar seguida de una implementación que no sea @overload-ed
INSP.overloads.this.function.overload.signature.not.compatible.with.implementation=La firma de esta función decorada por @overload no es compatible con su implementación
INSP.overloads.this.method.overload.signature.not.compatible.with.implementation=La firma de este método decorado como @overload no es compatible con la implementación
INSP.overloads.this.overload.signature.not.compatible.with.implementation=La firma de {0,choice,0#esta función decorada con @overload|1#este método decorado con @overload} no es compatible con la implementación
INSP.overloads.use.classmethod.inconsistently=Las sobrecargas usan @classmethod de manera inconsistente
INSP.overloads.use.staticmethod.inconsistently=Las sobrecargas usan @staticmethod de forma inconsistente
INSP.override.missing.super.method=Falta el método super para la sobrescritura
INSP.package.requirements.add.import=Añadir importación
INSP.package.requirements.administrator.privileges.required=Se requieren privilegios de administrador
INSP.package.requirements.administrator.privileges.required.button.configure=Configurar
INSP.package.requirements.administrator.privileges.required.button.install.anyway=Instalar de todos modos
INSP.package.requirements.administrator.privileges.required.description=La instalación de paquetes en ''{0}'' requiere privilegios de administrador.\n\nConfigure un entorno virtual por proyecto como intérprete del proyecto\npara evitar instalar paquetes en un área protegida del sistema de archivos.
INSP.package.requirements.requirement.has.been.ignored=Se ha ignorado ''{0}''
INSP.package.requirements.requirements.file.empty=El archivo de requisitos está vacío
INSP.package.requirements.requirements.have.been.ignored=Se han ignorado los requisitos
INSP.pandas.series.values.replace.with.tolist=Se recomienda el método Series.tolist()(_L)
INSP.parameter(s).unfilled=Parámetro(s) sin completar
INSP.parameter.unfilled=Parámetro ''{0}'' no completado
INSP.pep8.coding.style.violation=Violación del estilo de codificación PEP 8
INSP.pep8.ignore.base.class=Ignorar clase base
INSP.pep8.ignore.method.names.for.descendants.of.class=Ignorar nombres de métodos para descendientes de la clase
INSP.pep8.naming.argument.name.should.be.lowercase=El nombre del argumento debe estar en minúsculas
INSP.pep8.naming.camelcase.variable.imported.as.constant=Variable en CamelCase importada como constante
INSP.pep8.naming.camelcase.variable.imported.as.lowercase=Variable en CamelCase importada como minúscula
INSP.pep8.naming.class.names.should.use.capwords.convention=Los nombres de las clases deben seguir la convención CapWords
INSP.pep8.naming.column.name.excluded.base.classes=Clases base excluidas:
INSP.pep8.naming.column.name.ignored.errors=Errores ignorados:
INSP.pep8.naming.constant.variable.imported.as.non.constant=Variable constante importada como no constante
INSP.pep8.naming.function.name.should.be.lowercase=El nombre de la función debe estar en minúsculas
INSP.pep8.naming.lowercase.variable.imported.as.non.lowercase=Variable en minúsculas importada como no minúsculas
INSP.pep8.naming.variable.in.function.should.be.lowercase=La variable en la función debe estar en minúsculas
INSP.possible.callees=Posibles destinatarios de la llamada
INSP.probably.mistyped.self=¿No quiso decir 'self'?
INSP.property.cannot.be.deleted=La propiedad ''{0}'' no se puede eliminar
INSP.property.cannot.be.read=No se puede leer la propiedad ''{0}''
INSP.property.cannot.be.set=No se puede establecer la propiedad ''{0}''
INSP.protected.member.access.to.protected.member.of.class=Acceso a un miembro protected {0} de una clase
INSP.protected.member.access.to.protected.member.of.module=Acceso a un miembro protegido {0} de un módulo
INSP.protected.member.ignore.annotations=Ignorar anotaciones
INSP.protected.member.ignore.test.functions=Ignorar funciones de prueba
INSP.protected.member.name.not.declared.in.all=''{0}'' no está declarado en _all__(_A)
INSP.protocol.all.bases.protocol.must.be.protocols=Todas las bases de un protocolo deben ser protocolos
INSP.protocol.element.type.incompatible.with.protocol=El tipo de ''{0}'' es incompatible con ''{1}''
INSP.protocol.newtype.cannot.be.used.with.protocol.classes=NewType no se puede usar con clases de protocolo
INSP.protocol.only.runtime.checkable.protocols.can.be.used.with.instance.class.checks=Solo se pueden usar protocolos @runtime_checkable con comprobaciones de instancia y clase
INSP.python.suppressor.suppress.for.class=Suprimir para una clase
INSP.python.suppressor.suppress.for.function=Suprimir para una función
INSP.python.suppressor.suppress.for.statement=Suprimir para la sentencia
INSP.redeclared.name=Se ha vuelto a declarar ''{0}'', definido arriba sin uso
INSP.redundant.parens.ignore.argument.of.operator=Ignorar el argumento del operador %
INSP.redundant.parens.ignore.empty.lists.of.base.classes=Ignorar listas vacías de clases base
INSP.redundant.parens.ignore.tuples=Ignorar tuplas
INSP.relative.import.relative.import.outside.package=Importación relativa fuera de un paquete
INSP.requirements.ignore.packages.label=Paquetes ignorados:
INSP.requirements.package.containing.module.not.listed.in.project.requirements=El paquete que contiene el módulo ''{0}'' no figura en los requisitos del proyecto
INSP.requirements.package.requirements.not.satisfied={1,choice,1#El requisito|2#Los requisitos} de paquete {0} no {1,choice,1#está satisfecho|2#están satisfechos}
INSP.setter.should.not.return=El setter no debe devolver un valor
INSP.setter.signature.advice=La firma del setter debe ser (self, value)
INSP.shadowing.builtins.ignore.built.ins.label=Elementos integrados ignorados:
INSP.shadowing.builtins.shadows.built.in.name=Sombra al nombre integrado ''{0}''
INSP.shadowing.names=Ocultación de nombres de ámbitos externos
INSP.shadows.name.from.outer.scope=Oculta el nombre ''{0}'' del ámbito externo
INSP.signature.mismatch=La firma del método ''{0}'' no coincide con la firma del método base en la clase ''{1}''
INSP.simplify.boolean.check.ignore.comparison.to.zero=Ignorar la comparación con cero
INSP.simplify.chained.comparison=Simplificar comparación encadenada
INSP.statement.effect.statement.having.no.effect.can.be.replaced.with.function.call=La sentencia parece no tener efecto y puede reemplazarse por una llamada a función para que tenga efecto
INSP.statement.effect.statement.seems.to.have.no.effect=La sentencia parece no tener efecto
INSP.str.format.can.not.use.star.in.formats.when.using.mapping=No se puede utilizar '*' en los formatos cuando se utiliza un mapeo
INSP.str.format.key.has.no.argument=La clave ''{0}'' no tiene ningún argumento correspondiente
INSP.str.format.unexpected.argument.type=Tipo inesperado {0}
INSP.str.format.unsupported.format.character.b=Carácter de formato 'b' no compatible
INSP.strange.arg.want.callable=Argumento extraño; se espera un objeto invocable
INSP.stub.packages=Anunciador de paquetes stub
INSP.stub.packages.compatibility=Paquetes de stubs incompatibles
INSP.stub.packages.compatibility.ignore=Ignorar
INSP.stub.packages.compatibility.ignored.packages.label=Paquetes stub ignorados:
INSP.stub.packages.compatibility.incompatible.packages.message=El stub ''{0}'' es incompatible con el paquete original.
INSP.symbol.is.not.callable=''{0}'' no se puede llamar
INSP.too.broad.exception.clause=Cláusula de excepción demasiado amplia
INSP.too.few.args.for.fmt.string=Muy pocos argumentos para la cadena de formato
INSP.too.few.keys=Muy pocas claves de mapeo
INSP.too.many.args.for.fmt.string=Demasiados argumentos para la cadena de formato
INSP.trailing.semicolon=Punto y coma al final de la sentencia
INSP.try.except.import.error=''except ImportError'' en el bloque try con ''{0}'' también debería estar definido en el bloque except
INSP.tuple.assignment.balance.need.more.values.to.unpack=Se necesitan más valores para desempaquetar
INSP.tuple.assignment.balance.only.one.starred.expression.allowed.in.assignment=Solo se permite una expresión con asterisco en la asignación
INSP.tuple.assignment.balance.too.many.values.to.unpack=Demasiados valores para desempaquetar
INSP.tuples.never.assign.items=Las tuplas no admiten la asignación de elementos
INSP.type.checker.access.to.generic.instance.variables.via.class.is.ambiguous=El acceso a las variables de instancia genéricas a través de la clase es ambiguo
INSP.type.checker.expected.matched.type.got.type.instead=Se esperaba el tipo ''{0}'' (tipo genérico coincidente ''{1}''), pero se obtuvo ''{2}''
INSP.type.checker.expected.to.return.type.got.no.return=Se esperaba que devolviera ''{0}'', pero no devolvió nada
INSP.type.checker.expected.type.from.dunder.set.got.type.instead=Se esperaba el tipo ''{0}'' (de ''__set__''), se obtuvo ''{1}'' en su lugar
INSP.type.checker.expected.type.got.type.instead=Se esperaba el tipo ''{0}'', pero se obtuvo ''{1}''
INSP.type.checker.expected.types.prefix=Tipo(s) posible(s):
INSP.type.checker.init.should.return.none=_init__ debe devolver None(_I)
INSP.type.checker.only.concrete.class.can.be.used.where.matched.protocol.expected=Solo se puede utilizar una clase concreta donde se espera el protocolo ''{0}'' (tipo genérico coincidente ''{1}'')
INSP.type.checker.only.concrete.class.can.be.used.where.protocol.expected=Solo se puede utilizar una clase concreta donde se espera el protocolo ''{0}''
INSP.type.checker.tuple.index.out.of.range=Índice de tupla fuera de rango
INSP.type.checker.type.does.not.have.expected.attribute=El tipo ''{0}'' no tiene {1,choice,1#el atributo esperado|2#los atributos esperados} {2}
INSP.type.checker.typed.dict.extra.key=Clave adicional ''{0}'' para TypedDict ''{1}''
INSP.type.checker.typed.dict.missing.keys=A TypedDict ''{0}'' le {1,choice,1#falta la clave|2#faltan las claves}: {2}
INSP.type.checker.unexpected.argument.from.paramspec=Argumento inesperado (de ParamSpec ''{0}'')
INSP.type.checker.unexpected.types.prefix=Tipo(s) inesperado(s):
INSP.type.checker.unfilled.parameter.for.paramspec=Parámetro ''{0}'' sin completar (de ParamSpec ''{1}'')
INSP.type.checker.unfilled.vararg=Parámetro ''{0}'' no completado, se esperaba ''{1}''
INSP.type.checker.yield.from.async.generator=No se puede usar ''yield from'' en ''{0}'', use ''async for'' en su lugar
INSP.type.checker.yield.from.send.type.mismatch=Se esperaba el tipo de 'send' ''{0}'', se obtuvo ''{1}'' en su lugar
INSP.type.checker.yield.type.mismatch=Se esperaba el tipo de yield ''{0}'', pero se obtuvo ''{1}'' en su lugar
INSP.type.hints.annotated.must.be.called.with.at.least.two.arguments='Annotated' debe llamarse con al menos dos argumentos
INSP.type.hints.argument.to.paramspec.must.be.string.equal.to.variable.name=El argumento de 'ParamSpec()' debe ser una cadena igual al nombre de la variable a la que se asigna
INSP.type.hints.argument.to.typevar.must.be.string.equal.to.variable.name=El argumento de 'TypeVar()' debe ser una cadena igual al nombre de la variable a la que se asigna
INSP.type.hints.argument.to.typevar.tuple.must.be.string.equal.to.variable.name=El argumento de 'TypeVarTuple()' debe ser una cadena igual al nombre de la variable a la que se asigna
INSP.type.hints.at.most.one.unpacked.tuple=La lista de argumentos de tipo puede tener como máximo un TypeVarTuple desempaquetado o una tupla sin límites
INSP.type.hints.bivariant.type.variables.are.not.supported=No se admiten variables de tipo bivariante
INSP.type.hints.builtin.cannot.be.parameterized.directly=El elemento incorporado ''{0}'' no se puede parametrizar directamente
INSP.type.hints.cannot.be.used.in.default.type.of.type.var=''{0}'' no se puede usar en el tipo predeterminado de TypeVar
INSP.type.hints.cannot.inherit.from.generic.multiple.times=No se puede heredar de 'Generic[…]' varias veces
INSP.type.hints.cannot.inherit.from.plain.generic=No se puede heredar de 'Generic' simple
INSP.type.hints.cannot.use.contravariant.in.return.type=No se puede utilizar una variable de tipo contravariante en el tipo de retorno de la función
INSP.type.hints.cannot.use.covariant.in.function.param=No se puede utilizar una variable de tipo covariante en el tipo de parámetro
INSP.type.hints.circular.reference=Referencia circular
INSP.type.hints.concatenate.can.only.be.used.inside.callable='Concatenate' solo se puede usar como el primer argumento de 'Callable' en este contexto
INSP.type.hints.default.type.do.not.match.bounds=El tipo predeterminado de TypeVar no es un subtipo del límite
INSP.type.hints.default.type.do.not.match.constraints=El tipo por defecto de TypeVar debe ser uno de los tipos de restricción
INSP.type.hints.default.type.must.be.type.expression=El tipo predeterminado debe ser una expresión de tipo
INSP.type.hints.default.type.of.param.spec.must.be.param.spec.or.list.of.types=El tipo predeterminado de ParamSpec debe ser un tipo ParamSpec o una lista de tipos
INSP.type.hints.default.type.of.type.var.tuple.must.be.unpacked=El tipo por defecto de TypeVarTuple debe estar desempaquetado
INSP.type.hints.default.type.refers.to.type.var.out.of.scope=El tipo por defecto de este parámetro de tipo hace referencia a una o más variables de tipo que están fuera de su ámbito
INSP.type.hints.default.type.var.cannot.follow.type.var.tuple=Un TypeVar con un valor por defecto no puede ir después de un TypeVarTuple
INSP.type.hints.expected.a.type=Se esperaba un tipo
INSP.type.hints.forward.reference.in.union=Las anotaciones de tipo de unión con referencias anticipadas deben estar completamente envueltas entre comillas
INSP.type.hints.generic.or.protocol.should.list.all.type.variables=''Generic[…]'' o ''Protocol[…]'' debe enumerar todas las variables de tipo ({0})
INSP.type.hints.generic.type.alias.is.not.generic.or.already.parameterized=El alias de tipo no es genérico o ya está especializado
INSP.type.hints.generics.should.be.specified.through.square.brackets=Los genéricos deben especificarse mediante corchetes
INSP.type.hints.illegal.callable.format=Callable' debe utilizarse como 'Callable[[arg, …], result]
INSP.type.hints.illegal.first.parameter=El primer parámetro de 'Callable' debe ser una expresión de parámetro
INSP.type.hints.illegal.literal.parameter='Literal' se puede parametrizar con enteros literales, cadenas de bytes y unicode, booleanos, valores de Enum, None, otros tipos de literales o alias de tipo de otros tipos de literales
INSP.type.hints.invalid.type.argument=Argumento de tipo no válido
INSP.type.hints.invalid.type.expression=Expresión de tipo no válida
INSP.type.hints.invalid.type.self=Tipo 'self' no válido
INSP.type.hints.literal.must.have.at.least.one.parameter='Literal' debe tener al menos un parámetro
INSP.type.hints.metaclass.cannot.be.generic=La metaclase no puede ser genérica
INSP.type.hints.new.type.type.cannot.be.used.in.isinstance.tests=El tipo NewType no se puede usar en comprobaciones de instancia y clase
INSP.type.hints.non.default.type.vars.cannot.follow.defaults=Los TypeVar sin valor predeterminado no pueden seguir a aquellos que tienen valores predeterminados
INSP.type.hints.non.self.attribute.could.not.be.type.hinted=Un atributo que no es "self" no puede tener sugerencias de tipo
INSP.type.hints.parameterized.generics.cannot.be.used.with.instance.class.checks=Los genéricos parametrizados no se pueden usar con comprobaciones de instancia y clase
INSP.type.hints.parameters.to.generic.must.all.be.type.variables=Los parámetros de ''{0,choice,0#Generic|1#Protocol}[…]'' deben ser todos variables de tipo
INSP.type.hints.parameters.to.generic.must.all.be.unique=Los parámetros de 'Generic[…]' deben ser todos únicos
INSP.type.hints.parameters.to.generic.types.cannot.contain.more.than.one.unpacking=Los parámetros de los tipos genéricos no pueden contener más de un desempaquetado
INSP.type.hints.parameters.to.generic.types.must.be.types=Los parámetros de tipos genéricos deben ser tipos
INSP.type.hints.paramspec.expects.string.literal.as.first.argument='ParamSpec()' espera un literal de cadena como primer argumento
INSP.type.hints.self.use.for.cls.parameter.with.self.annotation=No se puede usar 'Self' si el parámetro 'cls' no está anotado con 'Self'
INSP.type.hints.self.use.for.self.parameter.with.self.annotation=No se puede usar 'Self' si el parámetro 'self' no está anotado con 'Self'
INSP.type.hints.self.use.in.staticmethod=No se puede usar 'Self' en staticmethod
INSP.type.hints.self.use.outside.class=No se puede usar 'Self' fuera de una clase
INSP.type.hints.single.typevar.constraint.not.allowed=No se permite una única restricción
INSP.type.hints.some.type.variables.are.not.listed.in.generic=Algunas variables de tipo ({0}) no se listan en ''Generic[{1}]''
INSP.type.hints.some.type.variables.are.used.by.an.outer.scope=Algunas variables de tipo ({0}) son utilizadas por un ámbito externo
INSP.type.hints.type.alias.cannot.be.parameterized=No se puede parametrizar 'TypeAlias'
INSP.type.hints.type.alias.invalid.assigned.value=El valor asignado del alias de tipo debe ser un tipo correcto
INSP.type.hints.type.alias.must.be.immediately.initialized=El alias de tipo debe inicializarse inmediatamente
INSP.type.hints.type.alias.must.be.top.level.declaration=El alias de tipo debe ser una declaración de nivel superior
INSP.type.hints.type.alias.must.be.used.as.standalone.type.hint='TypeAlias' debe utilizarse como una pista de tipo independiente
INSP.type.hints.type.arguments.class.is.already.parameterized=La clase ''{0}'' ya está parametrizada
INSP.type.hints.type.arguments.do.not.match.type.parameters=Los argumentos de tipo pasados no coinciden con los parámetros de tipo {0} de la clase ''{1}''
INSP.type.hints.type.arguments.do.not.match.type.parameters.of.alias=Los argumentos de tipo pasados no coinciden con los parámetros de tipo del alias de tipo ''{0}''
INSP.type.hints.type.arguments.do.not.match.type.parameters.of.class=Los argumentos de tipo pasados no coinciden con los parámetros de tipo {0} de la clase ''{1}''
INSP.type.hints.type.cannot.be.used.with.instance.class.checks=''{0}'' no se puede utilizar con comprobaciones de instancia y clase
INSP.type.hints.type.comment.cannot.be.matched.with.unpacked.variables=El comentario de tipo no puede coincidir con variables despaquetadas
INSP.type.hints.type.hint.is.not.valid=La indicación de tipo no es válida o hace referencia a una expresión que no es un tipo correcto
INSP.type.hints.type.self.not.supertype.its.class=El tipo de self ''{0}'' no es un supertipo de su clase ''{1}''
INSP.type.hints.type.signature.has.too.few.arguments=La firma de tipo tiene muy pocos argumentos
INSP.type.hints.type.signature.has.too.many.arguments=La firma de tipo tiene demasiados argumentos
INSP.type.hints.type.specified.both.in.type.comment.and.annotation=Tipos especificados tanto en un comentario de tipo como en una anotación
INSP.type.hints.type.var.tuple.must.always.be.unpacked=TypeVarTuple siempre debe estar desempaquetado
INSP.type.hints.type.variables.cannot.be.used.with.instance.class.checks=Las variables de tipo no se pueden utilizar con comprobaciones de instancia y clase
INSP.type.hints.type.variables.must.not.be.redefined=Las variables de tipo no se deben redefinir
INSP.type.hints.typeIs.does.not.match=El tipo de retorno de TypeIs ''{0}'' no coincide con el tipo del primer parámetro ''{1}''
INSP.type.hints.typeIs.has.zero.parameters=Las funciones TypeGuard o TypeIs definidas por el usuario deben tener al menos un parámetro
INSP.type.hints.typed.dict.is.not.allowed.as.a.bound.for.a.type.var=No se permite usar TypedDict como límite para un TypeVar
INSP.type.hints.typed.dict.type.cannot.be.used.in.isinstance.tests=El tipo TypedDict no se puede usar en comprobaciones de instancia y clase
INSP.type.hints.typevar.constraints.cannot.be.combined.with.bound=Las restricciones no se pueden combinar con bound=…
INSP.type.hints.typevar.constraints.cannot.be.parametrized.by.type.variables=Las restricciones no pueden ser parametrizadas por variables de tipo
INSP.type.hints.typevar.expects.string.literal.as.first.argument='TypeVar()' espera un literal de cadena como primer argumento
INSP.type.hints.typevar.expression.must.be.always.directly.assigned.to.variable=Una expresión 'TypeVar()' siempre debe asignarse directamente a una variable
INSP.type.hints.typevar.tuple.expects.string.literal.as.first.argument='TypeVarTuple()' espera un literal de cadena como primer argumento
INSP.type.hints.typing.self.cannot.be.parameterized='Self' no se puede parametrizar
INSP.type.hints.unbound.type.variable=Variable de tipo no vinculada
INSP.typeddict.cannot.add.non.string.key.to.typeddict=No se puede añadir una clave que no sea de tipo cadena a TypedDict "{0}"
INSP.typeddict.cannot.be.required.and.not.required.at.the.same.time=La clave no puede ser requerida y no requerida al mismo tiempo
INSP.typeddict.cannot.overwrite.typeddict.field=No se puede sobrescribir el campo TypedDict
INSP.typeddict.cannot.overwrite.typeddict.field.while.merging=No se puede sobrescribir el campo de TypedDict ''{0}'' al fusionar
INSP.typeddict.expected.a.dictionary.literal=Se esperaba un literal de diccionario
INSP.typeddict.first.argument.has.to.match.variable.name=El primer argumento debe coincidir con el nombre de la variable
INSP.typeddict.invalid.statement.in.typeddict.definition.expected.field.name.field.type=Sentencia no válida en la definición de TypedDict; se esperaba 'field_name: field_type'
INSP.typeddict.key.cannot.be.deleted=No se puede eliminar la clave ''{0}'' de TypedDict ''{1}''
INSP.typeddict.key.should.be.string=La clave debe ser una cadena de caracteres
INSP.typeddict.qualifiers.cannot.be.used.outside.typeddict.definition=''{0}'' solo se puede utilizar en una definición de TypedDict
INSP.typeddict.read.only.cannot.be.nested=ReadOnly[] no se puede anidar
INSP.typeddict.required.and.not.required.cannot.be.nested=Required[] y NotRequired[] no se pueden anidar
INSP.typeddict.required.notrequired.cannot.be.used.outside.typeddict.definition=''{0}'' sólo se puede usar en una definición TypedDict
INSP.typeddict.required.notrequired.must.have.exactly.one.type.argument=''{0}'' debe tener exactamente un argumento de tipo
INSP.typeddict.right.hand.side.values.are.not.supported.in.typeddict=Los valores en el lado derecho no son compatibles en TypedDict
INSP.typeddict.specifying.metaclass.not.allowed.in.typeddict=No se permite especificar una metaclase en TypedDict
INSP.typeddict.this.operation.might.break.typeddict.consistency=Esta operación podría romper la consistencia de TypedDict
INSP.typeddict.total.value.must.be.true.or.false=El valor de 'total' debe ser True o False
INSP.typeddict.typeddict.cannot.have.key=TypedDict "{0}" no puede tener la clave ''{1}''
INSP.typeddict.typeddict.cannot.inherit.from.non.typeddict.base.class=TypedDict no puede heredar de una clase base que no sea TypedDict
INSP.typeddict.typeddict.field.is.readonly=La clave TypedDict "{0}" es ReadOnly
INSP.typeddict.typeddict.has.no.key=TypedDict "{0}" no tiene la clave ''{1}''
INSP.typeddict.typeddict.has.no.keys=TypedDict "{0}" no tiene claves ({1})
INSP.typeddict.typeddict.key.must.be.string.literal.expected.one=La clave de TypedDict debe ser un literal de cadena; se esperaba uno de ({0})
INSP.typeddict.unexpected.argument.for.__init_subclass__.of.TypedDict=Argumento inesperado ''{0}'' para __init_subclass__ de TypedDict
INSP.typeddict.value.must.be.type=El valor debe ser un tipo
INSP.unbound.function.too.large=La función ''{0}'' es demasiado grande para ser analizada
INSP.unbound.local.variable=La variable local ''{0}'' podría ser referenciada antes de su asignación
INSP.unbound.name.undefined=El nombre ''{0}'' puede no estar definido
INSP.unbound.nonlocal.variable=La variable nolocal ''{0}'' debe estar vinculada en un ámbito de función externa
INSP.unexpected.arg=Argumento inesperado
INSP.unexpected.arg(s)=Argumento(s) inesperado(s)
INSP.unexpected.parameter.in.docstring=Parámetro inesperado {0} en docstring
INSP.unnecessary.backslash.unnecessary.backslash.in.expression=Barra invertida innecesaria en la expresión
INSP.unreachable.code=Este código es inaccesible
INSP.unresolved.refs.cannot.find.reference.in.type=No se puede encontrar la referencia ''{0}'' en ''{1}''
INSP.unresolved.refs.class.does.not.define.operator=La clase ''{0}'' no define ''{1}'', por lo que el operador ''{2}'' no se puede usar en sus instancias
INSP.unresolved.refs.class.object.has.no.attribute=El objeto ''{0}'' no tiene el atributo ''{1}''
INSP.unresolved.refs.ignore.references.label=Referencias ignoradas:
INSP.unresolved.refs.import.resolves.to.its.containing.file=La importación se resuelve en el archivo que la contiene
INSP.unresolved.refs.module.not.found=Módulo ''{0}'' no encontrado
INSP.unresolved.refs.unresolved.attribute.for.class=Referencia a atributo no resuelta ''{0}'' para la clase ''{1}''
INSP.unresolved.refs.unresolved.reference=Referencia no resuelta ''{0}''
INSP.unsupported.format.character=Carácter de formato no compatible ''{0}''
INSP.unused.import.statement=Instrucción de importación no utilizada: <code>#ref</code>
INSP.unused.imports.try.except.import.error=''{0}'' en el bloque try con ''except ImportError'' también debe definirse en el bloque except
INSP.unused.imports.unused.import.statement=Sentencia import no utilizada <code>#ref</code>
INSP.unused.locals.ignore.lambda.parameters=Ignorar parámetros lambda
INSP.unused.locals.ignore.range.iteration.variables=Ignorar variables de iteración de rango
INSP.unused.locals.ignore.variables.starting.with=Ignorar las variables que comienzan con '_'
INSP.unused.locals.ignore.variables.used.in.tuple.unpacking=Ignorar variables usadas en el desempaquetado de tuplas
INSP.unused.locals.local.class.isnot.used=La clase local ''{0}'' no se utiliza
INSP.unused.locals.local.function.isnot.used=La función local ''{0}'' no se utiliza
INSP.unused.locals.local.variable.isnot.used=El valor de la variable local ''{0}'' no se utiliza
INSP.unused.locals.parameter.isnot.used=El valor del parámetro ''{0}'' no se utiliza
INSP.unused.locals.replace.with.wildcard=Reemplazar con _
INSP.unused.locals.type.alias.isnot.used=El alias de tipo local ''{0}'' no se utiliza
INSP.unused.locals.type.parameter.isnot.used=El parámetro de tipo ''{0}'' no se utiliza
INSP.use.fixture.without.declaration.in.test.function=El fixture ''{0}'' no es solicitado por las funciones de prueba ni por el marcador ''@pytest.mark.usefixtures''
INSP.usually.named=Normalmente, el primer parámetro de estos métodos se llama ''{0}''
INSP.usually.named.self=El primer parámetro de un método suele llamarse 'self'
INTN.NAME.add.type.hint.for.variable=Añadir pista de tipo para la variable
INTN.NAME.add.type.hints.for.function=Agregar sugerencias de tipo para la función
INTN.NAME.convert.between.f.string.t.string=Convertir entre f-string y t-string
INTN.NAME.convert.collection.literal=Convertir colección a {0}
INTN.NAME.convert.import.qualify=Convertir 'from module import' a 'import module'
INTN.NAME.convert.import.unqualify=Convertir 'import module' a 'from module import'
INTN.NAME.convert.type.comment.to.variable.annotation=Convertir comentario de tipo en anotación de variable
INTN.NAME.demorgan.law=Leyes de De Morgan
INTN.NAME.flip.comparison=Invertir comparación
INTN.NAME.hide.type.annotations=Ocultar anotaciones de tipo
INTN.NAME.insert.docstring.stub=Insertar stub de docstring
INTN.NAME.join.if=Unir sentencias 'if'
INTN.NAME.negate.comparison=Negar comparación
INTN.NAME.specify.type.in.annotation=Especificar el tipo de la referencia mediante una anotación
INTN.NAME.specify.type.in.docstring=Especificar tipo para referencia en el docstring
INTN.NAME.split.if=Dividir sentencia 'if'
INTN.NAME.toggle.import.alias=Alternar el uso de alias de importación
INTN.add.import.alias=Añadir alias
INTN.add.import.alias.dialog.message=Alias para ''{0}'':
INTN.add.import.alias.title=Añadir alias
INTN.add.import.alias.to.name=Añadir alias a ''{0}''
INTN.add.parameters.to.docstring=Añadir parámetros al docstring
INTN.add.qualifier=Añadir el calificador ''{0}''
INTN.add.type.hint.for.variable=Añadir pista de tipo para la variable ''{0}''
INTN.add.type.hint.for.variable.PEP484.incompatible.type=El tipo ''{0}'' no se puede expresar en línea en el formato PEP 484
INTN.add.type.hints.for.function=Añadir sugerencias de tipo para la función ''{0}''
INTN.category.python=Python
INTN.convert.absolute.to.relative=Convertir importación absoluta en relativa
INTN.convert.builtin.import=Convertir la importación de un módulo integrado a una forma admitida
INTN.convert.collection.literal=Convertir {0} a {1}
INTN.convert.dict.constructor.to.dict.literal=Convertir el constructor de dict en un literal de dict
INTN.convert.dict.literal.to.dict.constructor=Convertir literal de dict a constructor de dict
INTN.convert.except.to=Convertir 'except exceptClass, Target' a 'except exceptClass as Target'
INTN.convert.f.string.to.t.string=Convertir f-string a t-string
INTN.convert.lambda.to.function=Convertir lambda a función
INTN.convert.method.to.property=Convertir método en propiedad
INTN.convert.relative.to.absolute=Convertir importación relativa a absoluta
INTN.convert.static.method.to.function=Convertir método estático en función
INTN.convert.t.string.to.f.string=Convertir t-string a f-string
INTN.convert.to.from.import=Convertir a ''from {0} import {1}''
INTN.convert.to.fstring.literal=Convertir a literal de f-string
INTN.convert.to.plain.import=Convertir a ''import {0}''
INTN.convert.type.comment.to.variable.annotation=Convertir en una anotación de variable
INTN.convert.variadic.param=Convertir parámetros variádicos en normales
INTN.flip.comparison=Invertir ''{0}''
INTN.flip.comparison.to.operator=Invertir ''{0}'' a ''{1}''
INTN.format.operator.to.method=Convertir el operador de formato en una llamada al método 'str.format'
INTN.hide.type.annotations=Ocultar anotaciones de tipo
INTN.insert.assertion=Insertar aserción de tipo
INTN.insert.docstring.stub=Insertar un stub de cadena de documentación
INTN.invert.if.condition=Invertir condición 'if'
INTN.join.if=Unir dos sentencias 'if'
INTN.multiple.usages.of.import.found=Se encontraron múltiples usos de la importación
INTN.negate.comparison=Negar ''{0}'' a ''{1}''
INTN.quoted.string=Convertir cadenas de comillas simples a comillas dobles y viceversa
INTN.quoted.string.double.to.single=Convertir cadena con comillas dobles a cadena con comillas simples
INTN.quoted.string.single.to.double=Convertir cadena con comillas simples a cadena con comillas dobles
INTN.remove.import.alias=Eliminar el alias ''{0}''
INTN.remove.qualifier=Eliminar el calificador ''{0}''
INTN.remove.qualifier.from.all.usages=Eliminar el calificador de todos los usos
INTN.remove.qualifier.from.this.name=Quitar el calificador de este nombre
INTN.replace.backquote.expression=Reemplazar expresión de comilla invertida
INTN.replace.list.comprehensions=Convertir las comprensiones de lista al formato compatible
INTN.replace.list.comprehensions.with.for=Convertir las comprensiones de lista en un bucle 'for'
INTN.replace.noteq.operator=Reemplazar el operador de desigualdad
INTN.replace.octal.numeric.literal=Convertir el literal numérico octal a una forma compatible
INTN.replace.plus.with.format.operator=Reemplazar + con el operador de formato de cadena
INTN.replace.plus.with.str.format=Reemplazar + por una llamada al método str.format
INTN.replace.raise.statement=Convertir la sentencia raise a una forma compatible
INTN.replace.with.method=Reemplazar con la llamada al método str.format
INTN.specify.return.type.in.annotation=Especificar el tipo de retorno mediante una anotación
INTN.specify.return.type.in.docstring=Especificar el tipo de retorno en la docstring
INTN.specify.type.in.annotation=Especificar el tipo de la referencia mediante una anotación
INTN.specify.type.in.docstring=Especificar tipo para la referencia en docstring
INTN.split.if=Dividir en 2 sentencias 'if'
INTN.string.concatenation.to.format=Reemplazar la concatenación de cadenas por 'str.format'
INTN.transform.into.if.else.statement=Transformar expresiones condicionales en sentencias 'if/else'
INTN.triple.quoted.string=Convertir cadena entre triples comillas a cadena entre comillas simples
INTN.yield.from=Transformar iteraciones explícitas con 'yield' en expresiones 'yield from'
QDOC.accessor.kind=Tipo de descriptor de acceso:
QDOC.assigned.to=Asignado a:
QDOC.attributes=Atributos:
QDOC.built.in.description=Descripción integrada
QDOC.class=Clase
QDOC.class.attribute=Atributo de clase {0} de {1}
QDOC.copied.from=Copiado de:
QDOC.directory.name=Directorio "{0}"
QDOC.epydoc.python2.sdk.not.found=Es necesario un SDK de Python 2 configurado para visualizar cadenas de documentación <a href='http://epydoc.sourceforge.net/'>Epydoc</a>
QDOC.file.name=Archivo "{0}"
QDOC.inferred.type.name=Tipo inferido: {0}
QDOC.instance.attribute=Atributo de instancia {0} de {1}
QDOC.keyword.args=Argumentos de palabra clave:
QDOC.local.sdk.not.found=Se necesita un SDK local de Python configurado para mostrar docstrings.
QDOC.module.name=Módulo {0}
QDOC.module.path.unknown=(La ruta del módulo es desconocida)
QDOC.not.defined.in.parentheses=(no definido)
QDOC.package.name=Paquete {0}
QDOC.parameter.name=Parámetro "{0}"
QDOC.parameter.name.of.link=Parámetro {0} de {1}
QDOC.parameter.of.function.name=Parámetro "{0}" de la función "{1}"
QDOC.parameter.of.method.name=Parámetro "{0}" del método "{1}"
QDOC.params=Parámetros:
QDOC.property.getter=Getter de propiedad
QDOC.property.name.of.link=Propiedad {0} de {1}
QDOC.python.3.sdk.needed.to.render.docstrings=Se necesita un SDK de Python 3 local configurado para renderizar docstrings.
QDOC.raises=Lanza:
QDOC.returns=Retorna:
QDOC.type.alias.statement.name.of.link=Sentencia de alias de tipo {0} de {1}
QDOC.type.parameter.kind=Tipo:
QDOC.type.parameter.name=Parámetro de tipo {0}
QDOC.type.parameter.name.of.link=Parámetro de tipo {0} de {1}
QDOC.variable.name=Variable "{0}"
QFIX.NAME.add.exception.base=Añadir clase base de excepción
QFIX.NAME.add.field.to.class=Agregar campo a clase
QFIX.NAME.add.method.to.class=Agregar método a la clase
QFIX.NAME.add.specifier=Añadir carácter especificador de formato
QFIX.NAME.auto.import=Importar
QFIX.NAME.convert.builtin=Convertir importación de módulo incorporado
QFIX.NAME.create.function.in.module=Crear función en el módulo
QFIX.NAME.docstring=Corregir docstring
QFIX.NAME.ignore.errors.like.this=Ignorar errores como este
QFIX.NAME.ignore.requirements=Ignorar {0,choice,1#requisito|2#requisitos}
QFIX.NAME.ignore.shadowed.built.in.name=Ignorar nombre integrado sombreado
QFIX.NAME.install.and.import.package=Instalar e importar el paquete ''{0}''
QFIX.NAME.install.requirements=Instalar {0,choice,1#requisito|2#requisitos}
QFIX.NAME.local.auto.import=Importar localmente
QFIX.NAME.make.function=Crear función a partir del método
QFIX.NAME.make.function.return.type=Hacer que la función devuelva el tipo inferido
QFIX.NAME.make.list=Reemplazar tupla por lista
QFIX.NAME.make.return.stmts.explicit=Hacer explícitas las sentencias 'return None'
QFIX.NAME.make.static=Hacer estático el método
QFIX.NAME.move.except.up=Mover cláusula except hacia arriba
QFIX.NAME.remove.argument=Eliminar argumento
QFIX.NAME.remove.assignment=Eliminar asignación
QFIX.NAME.remove.assignment.target=Eliminar destino de la asignación
QFIX.NAME.remove.call=Eliminar llamada
QFIX.NAME.remove.dict.key=Eliminar esta clave
QFIX.NAME.remove.exception.target=Quitar destino de excepción
QFIX.NAME.remove.parameter=Eliminar parámetro
QFIX.NAME.remove.statement=Eliminar sentencia
QFIX.NAME.remove.string.prefix=Eliminar prefijo
QFIX.NAME.remove.underscores.in.numeric=Eliminar guiones bajos en literales numéricos
QFIX.NAME.remove.with.target=Eliminar el destino de 'with'
QFIX.NAME.rename.argument=Renombrar argumento
QFIX.NAME.rename.parameter=Renombrar parámetro
QFIX.NAME.replace.with.true.or.false=Reemplazar con True o False
QFIX.NAME.simplify.boolean.expression=Simplificar expresión booleana
QFIX.NAME.unpack.type.var.tuple=Desempaquetar TypeVarTuple
QFIX.NAME.unresolved.reference.add.param=Crear parámetro para la referencia
QFIX.NAME.unresolved.reference.create.function=Crear función ''{0}''
QFIX.NAME.update.parameters=Actualizar parámetros
QFIX.action.failed=Acción fallida
QFIX.add.encoding=Añadir declaración de codificación
QFIX.add.explicit.return.none=Añadir 'return None' explícito
QFIX.add.field.to.class=Agregar el campo ''{0}'' a la clase {1}
QFIX.add.field.to.class.popup.content.added.init=Se ha añadido un __init__ a la clase <code>{0}</code><br/>para dar cabida al nuevo campo <code>{1}</code>
QFIX.add.fixture.to.test.function.parameters.list=Añadir fixture a los parámetros de la función de prueba
QFIX.add.from.future.import.annotations=Añadir 'from _future__ import annotations'(_F)
QFIX.add.global=Añadir declaración global
QFIX.add.imported.package.to.declared.packages=Añadir el paquete "{0}" a requirements…
QFIX.add.imported.packages.to.requirements=Añadir paquetes importados a requirements…
QFIX.add.method.to.class=Añadir el método {0}() a la clase {1}
QFIX.add.parameter.self=Añadir el parámetro ''{0}''
QFIX.add.property=Agregar propiedad para el campo
QFIX.add.qualifier=Añadir calificador
QFIX.add.super=Añadir llamada a la superclase
QFIX.augment.assignment=Reemplazar asignación por asignación compuesta
QFIX.auto.import.import.name=Importar ''{0}''
QFIX.auto.import.import.this.name=Importar este nombre
QFIX.chained.comparison=Simplificar la comparación encadenada
QFIX.change.base.class=Cambiar clase base
QFIX.classic.class.transform=Heredar de objeto
QFIX.convert.indents=Convertir sangría
QFIX.convert.indents.to.spaces=Convertir sangrías en espacios
QFIX.convert.indents.to.tabs=Convertir sangrías en tabulaciones
QFIX.convert.into.async.function=Convertir en función asíncrona
QFIX.convert.single.quoted.docstring=Convertir el docstring al formato de cadena con triples comillas dobles
QFIX.convert.to.new.style=Convertir a clase de estilo nuevo
QFIX.coroutine.is.not.awaited=La corrutina no se está esperando
QFIX.create.class=Crear clase
QFIX.create.class.0=Crear clase ''{0}''
QFIX.create.class.in.module=Crear clase ''{0}'' en el módulo {1}
QFIX.create.function.in.module=Crear función {0}() en el módulo {1}
QFIX.create.property=Crear propiedad
QFIX.default.argument=Reemplazar argumento predeterminado mutable
QFIX.dict.creation=Reemplazar creación de diccionario
QFIX.docstring.add.parameter=Añadir el parámetro de docstring ''{0}''
QFIX.docstring.insert.stub=Insertar docstring
QFIX.docstring.remove.parameter=Eliminar el parámetro de docstring ''{0}''
QFIX.failed.to.add.field=<br/>¡Error al añadir el campo!<br/><br/>
QFIX.failed.to.add.function=<br/>¡No se pudo añadir la función!<br/><br/>
QFIX.failed.to.add.method=<br/>¡Error al añadir un método!<br/><br/>
QFIX.ignore.shadowed.built.in.name=Ignorar el nombre integrado oculto "{0}"
QFIX.install.and.import.package=Instalar e importar paquete
QFIX.introduce.variable=Introducir variable para la sentencia
QFIX.list.creation=Reemplazar con un literal de lista
QFIX.local.auto.import.import.locally={0} localmente
QFIX.make.function.return.type=Hacer que ''{0}'' devuelva ''{1}''
QFIX.make.public=Hacer público
QFIX.move.attribute=Mover atributo al método _init__(_I)
QFIX.move.from.future.import=Mover 'from _future__ import' a la ubicación correcta(_F)
QFIX.optimize.imports=Optimizar importaciones
QFIX.pandas.series.values.replace.with.tolist=Reemplazar list(Series.values) con Series.tolist()(_L)
QFIX.redundant.parentheses=Eliminar paréntesis redundantes
QFIX.remove.annotation=Eliminar la anotación
QFIX.remove.argument.equal.default=Eliminar argumentos iguales al valor predeterminado
QFIX.remove.decorator=Eliminar decorador
QFIX.remove.function.annotations=Eliminar anotaciones de función
QFIX.remove.generic.parameters=Eliminar parámetros genéricos
QFIX.remove.square.brackets=Eliminar corchetes
QFIX.remove.string.prefix=Eliminar {0} inicial
QFIX.remove.trailing.semicolon=Eliminar el punto y coma final
QFIX.remove.trailing.suffix=Eliminar sufijo final
QFIX.remove.type.comment=Eliminar el comentario de tipo
QFIX.remove.unnecessary.backslash=Eliminar la barra invertida innecesaria en la expresión
QFIX.rename.parameter=Renombrar a ''{0}''
QFIX.rename.unresolved.reference=Renombrar referencia
QFIX.replace.equality=Reemplazar igualdad
QFIX.replace.function.set.with.literal=Reemplazar llamada a función con literal de conjunto
QFIX.replace.star.by.unpack=Reemplazar por typing_extensions.Unpack
QFIX.replace.with.old.union.style=Reemplazar por una unión de estilo antiguo
QFIX.replace.with.return.none=Reemplazar con 'return None'
QFIX.replace.with.square.brackets=Reemplazar por corchetes
QFIX.replace.with.target.name=Reemplazar por el nombre de destino
QFIX.replace.with.true.or.false=Reemplazar por {0}
QFIX.replace.with.type.name=Reemplazar con el nombre del tipo
QFIX.replace.with.typing.alias=Reemplazar con alias de tipo
QFIX.simplify.boolean.expression=Reemplazar la expresión booleana por ''{0}''
QFIX.statement.effect=Reemplazar por llamada a función
QFIX.surround.with.square.brackets=Rodear con corchetes
QFIX.unresolved.reference=Reemplazar ''{0}'' por ''{1}.{0}''
QFIX.unresolved.reference.add.param=Crear parámetro ''{0}''
QFIX.unresolved.reference.create.function=Crear función
QFIX.use.property=Usar propiedad para el campo
custom.type.mimic.name=Clase dinámica basada en {0}
debugger.cleaning.signature.cache=Limpiando la caché de tipos recopilados dinámicamente
element.presentation.location.string.in.class=({0} en {1})
element.presentation.location.string.in.class.stub=({0} en el stub {1})
element.presentation.location.string.module=({0})
element.presentation.location.string.module.stub=({0} stub)
filetype.python.docstring.description=Docstring de Python
filetype.python.function.type.annotation.description=Comentario de tipo de función Python PEP-484
filetype.python.type.hint.description=Sugerencia de tipo PEP-484 de Python
find.usages.class=Clase
find.usages.function=Función
find.usages.imported.module.alias=Alias de módulo importado
find.usages.keyword.argument=Argumento de palabra clave
find.usages.method=Método
find.usages.parameter=Parámetro
find.usages.unnamed=<sin nombre>
find.usages.variable=Variable
ignore.overridden.functions=Ignorar funciones sobrescritas
python.docstring.format=Formato de docstring:
python.docstring.select.type=Seleccionar tipo de docstring
python.find.usages=Buscar usos
python.find.usages.base.method.question=El método {0} sobrescribe el método de la clase {1}.\n¿Desea buscar los usos del método base?
python.find.usages.untyped.probable.usage=Uso no tipado (probable)
python.find.usages.usage.in.import.statement=Uso en una sentencia import
python.find.usages.usage.in.isinstance=Uso en isinstance()
python.find.usages.usage.in.superclass.list=Uso en la lista de superclases
python.find.usages.usage.in.type.hint=Uso en una sugerencia de tipo
refactoring.extract.method=Extraer método
refactoring.extract.method.error.bad.selection=No se puede realizar la refactorización Extraer método con los elementos seleccionados
refactoring.extract.method.error.class.level=No se puede realizar la refactorización a nivel de clase
refactoring.extract.method.error.empty.fragment=No se puede realizar la refactorización a partir de un fragmento de código vacío
refactoring.extract.method.error.interrupted.execution.flow=No se puede realizar la refactorización cuando el flujo de ejecución está interrumpido
refactoring.extract.method.error.local.variable.modifications=No se puede realizar la refactorización a partir de una expresión que contiene modificaciones de variables locales dentro de un fragmento de código.
refactoring.extract.method.error.local.variable.modifications.and.returns=No se puede realizar la refactorización a partir de una expresión que contenga modificaciones de variables locales e instrucciones de retorno dentro de un fragmento de código
refactoring.extract.method.error.name.clash=El nombre del método entra en conflicto con un nombre ya existente
refactoring.extract.method.error.returns=No se puede extraer un método con instrucciones de retorno dentro de un fragmento de código
refactoring.extract.method.error.star.import=No se puede realizar la refactorización con una sentencia de importación con asterisco dentro de un bloque de código
refactoring.extract.method.error.yield=No se puede realizar la refactorización con una sentencia 'yield' dentro de un bloque de código
refactoring.inline.all.border.title=Inline
refactoring.inline.all.keep.declaration=Inlinear todas las invocaciones y mantener la declaración
refactoring.inline.all.remove.declaration=Sustituir todas las invocaciones y eliminar la declaración
refactoring.inline.can.not.multiline.string.to.f.string=No se puede incluir en línea una cadena multilínea en una f-string
refactoring.inline.can.not.string.to.nested.f.string=No se puede integrar la cadena en una f-string anidada
refactoring.inline.can.not.string.with.backslashes.or.quotes.to.f.string=No se puede aplicar inline a una cadena con barras invertidas y comillas en una f-string
refactoring.inline.function=Incorporar función {0}
refactoring.inline.function.async=No se pueden aplicar funciones asíncronas inline
refactoring.inline.function.builtin=No se pueden inlinear las funciones integradas
refactoring.inline.function.command.name=Incorporando {0}
refactoring.inline.function.constructor=No se pueden poner en línea las llamadas al constructor
refactoring.inline.function.decorator=No se pueden insertar en línea funciones con decoradores
refactoring.inline.function.function.to.inline=Función a integrar
refactoring.inline.function.generator=No se pueden inlinear los generadores
refactoring.inline.function.global=No se pueden integrar en línea funciones con variables globales
refactoring.inline.function.interrupts.flow=No se pueden integrar en línea funciones que interrumpen el flujo de control
refactoring.inline.function.invocations.to.be.inlined=Invocaciones para integrar en línea en {0} archivos
refactoring.inline.function.is.decorator=La función {0} se utiliza como decorador y no se puede integrar. No se eliminará la definición de la función.
refactoring.inline.function.is.overridden=No se pueden integrar los métodos sobreescritos
refactoring.inline.function.is.reference=La función {0} se utiliza como referencia y no se puede integrar. No se eliminará la definición de la función
refactoring.inline.function.nested=No se pueden integrar funciones con otra declaración de función
refactoring.inline.function.nonlocal=No se pueden inlinear funciones con variables no locales
refactoring.inline.function.overrides.method=No se pueden inlinear métodos que sobrescriben otros métodos
refactoring.inline.function.self.referrent=No se pueden integrar funciones que se referencian a sí mismas
refactoring.inline.function.skeleton.only=No se puede inlinear una función desde el módulo binario
refactoring.inline.function.special.method=No se pueden insertar métodos especiales en línea
refactoring.inline.function.star=No se pueden inlinear funciones con argumentos *
refactoring.inline.function.title=Insertar función en línea
refactoring.inline.function.uses.unpacking=La función {0} utiliza el desempaquetado de argumentos y no se puede integrar en línea. La definición de la función no se eliminará.
refactoring.inline.label.function=Función {0}
refactoring.inline.label.method=Método {0}
refactoring.inline.local.multiassignment=La definición se encuentra en una asignación múltiple
refactoring.inline.method=Poner en línea el método {0}
refactoring.inline.this.only=Incrustar solo esta invocación y mantener la declaración
refactoring.introduce.constant.cannot.extract.selected.expression=La expresión seleccionada no se puede extraer a una constante
refactoring.introduce.constant.dialog.title=Extraer constante
refactoring.introduce.constant.scope.error=El nombre ya está declarado en el ámbito
refactoring.introduce.name.error=Nombre incorrecto
refactoring.introduce.selection.error=No se puede realizar la refactorización con los elementos seleccionados
refactoring.introduce.variable.dialog.title=Extraer variable
refactoring.introduce.variable.scope.error=El nombre entra en conflicto con una variable o parámetro existente
refactoring.move.module.members.error.cannot.place.elements.into.nonpython.file=No se pueden colocar elementos en un archivo que no sea de Python
refactoring.name.label.text={0} tiene {1} coincidencia{2, choice, 0#|1#s}
refactoring.progress.title.updating.existing.usages=Actualizando los usos existentes…
type.param.list.annotator.two.or.more.types.required=Se requieren dos o más tipos
type.param.list.annotator.type.parameter.already.defined=El parámetro de tipo con el nombre ''{0}'' ya está definido en esta lista de parámetros de tipo
type.param.list.annotator.type.var.tuple.and.param.spec.can.not.have.bounds=ParamSpec y TypeVarTuple no pueden tener restricciones ni límites superiores
unresolved.docstring.param.reference=La función ''{0}'' no tiene un parámetro ''{1}''
unresolved.import.reference=No hay ningún módulo llamado ''{0}''
