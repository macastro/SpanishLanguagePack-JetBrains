action.defaultLombokData.description=Acción para reemplazar los métodos getter/setter/equals/hashcode/toString con la anotación @Data de Lombok
action.defaultLombokData.text=@Data predeterminado
action.defaultLombokEqualsAndHashcode.description=Acción para reemplazar los métodos equals y hashCode por la anotación @EqualsAndHashCode de Lombok
action.defaultLombokEqualsAndHashcode.text=@EqualsAndHashCode predeterminado
action.defaultLombokGetter.description=Acción para reemplazar todos los métodos getter por la anotación @Getter de Lombok
action.defaultLombokGetter.text=@Getter por defecto
action.defaultLombokLogger.description=Acción para reemplazar el logger con la anotación @Log de Lombok
action.defaultLombokLogger.text=@Log (y compañía)
action.defaultLombokSetter.description=Acción para reemplazar todos los métodos setter con la anotación @Setter de Lombok
action.defaultLombokSetter.text=@Setter predeterminado
action.defaultLombokToString.description=Acción para reemplazar el método toString con la anotación @ToString de Lombok
action.defaultLombokToString.text=@ToString por defecto
action.delombokAny.description=Acción para reemplazar todas las anotaciones de Lombok con métodos Java estándar
action.delombokAny.text=Todas las anotaciones de Lombok
action.delombokBuilder.description=Acción para reemplazar la anotación @Builder de lombok con métodos Java estándar
action.delombokBuilder.text=@Builder
action.delombokConstructor.description=Acción para reemplazar las anotaciones @NoArgsConstructor, @RequiredArgsConstructor y @AllArgsConstructor de lombok con métodos Java puros
action.delombokConstructor.text=@Constructores
action.delombokData.description=Acción para reemplazar la anotación @Data de Lombok con métodos Java estándar
action.delombokData.text=@Data
action.delombokDelegate.description=Acción para reemplazar la anotación @Delegate de Lombok con métodos Java estándar
action.delombokDelegate.text=@Delegate
action.delombokEqualsAndHashCode.description=Acción para reemplazar la anotación @EqualsAndHashCode de Lombok con métodos Java estándar
action.delombokEqualsAndHashCode.text=@EqualsAndHashCode
action.delombokFieldNameCostants.description=Acción para reemplazar la anotación @FieldNameConstants de Lombok con campos Java estándar
action.delombokFieldNameCostants.text=@FieldNameConstants
action.delombokGetter.description=Acción para reemplazar la anotación @Getter de Lombok con métodos getter convencionales
action.delombokGetter.text=@Getter
action.delombokLogger.description=Acción para reemplazar la anotación @Log de Lombok (y otras) por un campo de log estándar
action.delombokLogger.text=@Log (y similares)
action.delombokSetter.description=Acción para reemplazar la anotación @Setter de Lombok con métodos setter estándar
action.delombokSetter.text=@Setter
action.delombokStandardException.description=Acción para reemplazar la anotación @StandardException de Lombok con métodos Java estándar
action.delombokStandardException.text=@StandardException
action.delombokSuperBuilder.description=Acción para reemplazar la anotación @SuperBuilder de lombok con métodos Java estándar
action.delombokSuperBuilder.text=@SuperBuilder
action.delombokToString.description=Acción para reemplazar la anotación @ToString de Lombok con métodos Java estándar
action.delombokToString.text=@ToString
action.delombokUtilityClass.description=Acción para reemplazar la anotación @UtilityClass de Lombok con campos Java convencionales
action.delombokUtilityClass.text=@UtilityClass
action.delombokValue.description=Acción para reemplazar la anotación @Value de lombok con métodos Java puros
action.delombokValue.text=@Value
action.delombokWither.description=Acción para reemplazar la anotación @Wither de Lombok con métodos Java estándar
action.delombokWither.text=@Wither
checkbox.settings.jps.fix=Agregar automáticamente la opción de compilación '-Djps.track.ap.dependencies=false' para versiones antiguas de Lombok (<1.18.16)
checkbox.settings.version.warning=Habilitar la advertencia de la versión de Lombok para versiones de Lombok antiguas
color.settings.clear=Limpiar
color.settings.comment=Comentario
color.settings.key=Clave
color.settings.separator=Separador
color.settings.value=Valor
config.warn.annotation-processing.disabled.title=Lombok requiere el procesamiento de anotaciones habilitado
config.warn.dependency.outdated.message=<br>El proyecto "{0}" parece tener una dependencia Lombok obsoleta.<br>La versión configurada es "{1}", pero ya se ha publicado al menos la versión "{2}"<br><a href="https://projectlombok.org/download">¿Quizás quieras actualizarla?</a> <br>
config.warn.dependency.outdated.title=Dependencia Lombok posiblemente obsoleta
configurable.name.lombok.config=Configuración de Lombok
dialog.message.logger.field.s.not.private.sfinal.field.named.s.refactor.anyway=Campo del logger: "{0}" no es un campo private {1, choice, 0#|1#static } final llamado "{2}". ¿Refactorizar de todos modos?
dialog.message.this.element.cannot.be.renamed=Este elemento no se puede renombrar.
dialog.title.attention=¡Atención!
filetype.lombok.config.description=Archivo de configuración de Lombok
group.DelombokActionGroup.description=Refactorizar código eliminando las anotaciones de Lombok
group.DelombokActionGroup.text=Delombok
group.LombokActionGroup.description=Refactorizar código con anotaciones de Lombok
group.LombokActionGroup.text=Lombok
inspection.builder.static.import.name=Uso de importación estática para métodos generados por Lombok
inspection.deprecated.lombok.display.name=Anotaciones de Lombok en desuso
inspection.lombok.display.name=Anotaciones de Lombok
inspection.lombok.getter.may.be.used.display.class.message=La clase ''{0}'' puede usar Lombok @Getter
inspection.lombok.getter.may.be.used.display.field.message=El campo ''{0}'' puede tener Lombok @Getter
inspection.lombok.getter.may.be.used.display.fix.family.name=Reemplazar el método getter explícito por @Getter de Lombok
inspection.lombok.getter.may.be.used.display.fix.name=Usar @Getter de Lombok para ''{0}''
inspection.lombok.getter.may.be.used.display.name=Se puede usar @Getter de Lombok
inspection.lombok.group.name.lombok=Lombok
inspection.lombok.group.name.redundant.definitions=Definiciones redundantes
inspection.lombok.group.name.redundant.modifiers=Modificadores redundantes
inspection.lombok.setter.may.be.used.display.class.message=La clase ''{0}'' puede usar Lombok @Setter
inspection.lombok.setter.may.be.used.display.field.message=El campo ''{0}'' puede tener Lombok @Setter
inspection.lombok.setter.may.be.used.display.fix.family.name=Reemplazar el método setter explícito por @Setter de Lombok
inspection.lombok.setter.may.be.used.display.fix.name=Usar Lombok @Setter para ''{0}''
inspection.lombok.setter.may.be.used.display.name=Se puede usar Lombok @Setter
inspection.message.annotation.copy.duplicate=La anotación ''{0}'' ya está presente en el campo y será duplicada por la configuración de onX
inspection.message.annotation.not.lombok.copyable=Lombok no copia la anotación ''{0}'' en el constructor
inspection.message.annotation.only.supported.on.class.or.enum.type={0} solo se admite en una clase o una enumeración.
inspection.message.builder.can.be.used.only=@Builder solo se admite en clases, registros, constructores y métodos.
inspection.message.builder.default.requires.builder.annotation=@Builder.Default requiere @Builder o @SuperBuilder en la clase para que tenga algún sentido.
inspection.message.builder.default.requires.initializing.expression=@Builder.Default requiere una expresión de inicialización (' = something;').
inspection.message.builder.default.singular.cannot.be.mixed=@Builder.Default y @Singular no se pueden mezclar.
inspection.message.can.t.singularize.this.name=No se puede singularizar este nombre: ''{0}''; especifique la forma singular explícitamente (p. ej., @Singular("sheep"))
inspection.message.cleanup.legal.only.on.local.variable.declaration.inside.block=@Cleanup: solo es válido en una declaración de variable local dentro de un bloque
inspection.message.cleanup.legal.only.on.local.variable.declarations=@Cleanup solo es legal en declaraciones de variables locales
inspection.message.cleanup.method.s.not.found.on.target.class=@Cleanup: no se encontró el método ''{0}()'' en la clase de destino
inspection.message.cleanup.value.cannot.be.empty.string=@Cleanup: el valor no puede ser una cadena vacía
inspection.message.cleanup.variable.declarations.need.to.be.initialized=Las declaraciones de variables @Cleanup deben inicializarse.
inspection.message.constructor.noargs.needs.to.be.forced=La clase contiene campos obligatorios, debe forzar NoArgsConstructor.
inspection.message.constructor.with.d.parameters.already.defined=El constructor ''{0}'' ya está definido
inspection.message.constructor.without.parameters.already.defined=El constructor sin parámetros ya está definido
inspection.message.custom.log.does.not.allow.topic=@CustomLog no permite un tema.
inspection.message.custom.log.not.configured.correctly=@CustomLog no está configurado correctamente; por favor, establezca log.custom.declaration en lombok.config.
inspection.message.custom.log.requires.topic=@CustomLog requiere un tópico.
inspection.message.data.only.supported.on.class.type=@Data solo se admite en tipos de clase
inspection.message.default.constructor.doesn.t.exist=El constructor por defecto no existe
inspection.message.delegate.can.only.use.concrete.class.types=@Delegate solo puede usar tipos de clase concretos, no comodines, arrays, variables de tipo o primitivos. ''{0}'' es un tipo de clase incorrecto
inspection.message.delegate.does.not.support.recursion.delegating=@Delegate no admite recursión (delegar en un tipo que ya tiene miembros @Delegate). El miembro ''{0}'' es @Delegate en el tipo ''{1}''
inspection.message.delegate.legal.only.on.instance.fields=@Delegate solo es válido en campos de instancia o métodos de instancia sin argumentos.
inspection.message.delegate.legal.only.on.no.argument.methods=@Delegate solo es válido en métodos sin argumentos.
inspection.message.delegate.unknown.type.method=No se puede encontrar {0, choice, 1#el método|1<los métodos} en el tipo de destino: {1}
inspection.message.equals.and.hashcode.only.supported.on.class.type=@EqualsAndHashCode solo se admite en un tipo de clase
inspection.message.exclude.are.mutually.exclusive.exclude.parameter.will.be.ignored=Los parámetros 'exclude' y 'of' son mutuamente excluyentes; el parámetro 'exclude' será ignorado
inspection.message.existing.builder.must.be.abstract.static.inner.class=El Builder existente debe ser una clase interna estática y abstracta.
inspection.message.field.name.constants.inner.type=El tipo interno @FieldNameConstants ya existe, pero asEnum={0} no coincide con el tipo existente
inspection.message.field.name.constants.only.supported.on.class.enum.or.field.type=@FieldNameConstants solo se admite en una clase, enumeración, registro o tipo de campo
inspection.message.field.name.constants.only.supported.on.class.or.enum=@FieldNameConstants solo se admite en una clase, un enum o un record.
inspection.message.field.s.does.not.exist=El campo ''{0}'' no existe.
inspection.message.field.s.does.not.exist.exclude=El campo ''{0}'' no existe
inspection.message.field.s.does.not.exist.field=El campo ''{0}'' no existe
inspection.message.field.s.would.have.been.excluded.anyway=El campo ''{0}'' se habría excluido de todos modos
inspection.message.generating.equals.hashcode.implementation=Generando la implementación de equals/hashCode pero sin una llamada a la superclase, aunque esta clase no extiende java.lang.Object. Si esto es intencional, añada '(callSuper=false)' a su tipo.
inspection.message.generating.equals.hashcode.with.super.call=Generar equals/hashCode con una llamada a super a java.lang.Object no tiene sentido.
inspection.message.getter.only.supported.on.class.enum.or.field.type=@Getter solo se admite en una clase, enumeración o tipo de campo
inspection.message.jacksonized.builder.on.abstract.classes=Los builders en clases abstractas no pueden ser @Jacksonized (el builder nunca se utilizaría).
inspection.message.jacksonized.cannot.process.both.builder.superbuilder=@Jacksonized no puede procesar @Builder y @SuperBuilder a la vez en la misma clase.
inspection.message.jacksonized.jsondeserialize.already.exists=@JsonDeserialize ya existe en la clase. Elimine @JsonDeserialize o elimine @Jacksonized y configure Jackson manualmente.
inspection.message.jacksonized.requires.builder.superbuilder=@Jacksonized requiere @Builder o @SuperBuilder para que tenga sentido.
inspection.message.lazy.does.not.work.with.access.level.none='lazy' no funciona con AccessLevel.NONE.
inspection.message.lazy.not.supported.for.getter.on.type='lazy' no es compatible con @Getter en un tipo
inspection.message.lazy.requires.field.initialization='lazy' requiere la inicialización del campo.
inspection.message.lazy.requires.field.to.be.private.final='lazy' requiere que el campo sea private y final
inspection.message.lombok.annotation.deprecated.not.supported=La anotación ''{0}'' de Lombok está en desuso y ya no es compatible con el complemento de Lombok. Use ''{1}'' en su lugar.
inspection.message.lombok.annotations.are.not.allowed.on.builder.class=No se permiten las anotaciones de Lombok en la clase builder.
inspection.message.lombok.builder.needs.proper.constructor.for.this.class=Lombok @Builder necesita un constructor adecuado para esta clase
inspection.message.lombok.does.not.know=Lombok no puede generar métodos builder de forma singular para el tipo ''{0}''
inspection.message.lombok.needs.default.constructor.in.base.class=Lombok necesita un constructor predeterminado en la clase base
inspection.message.method.s.matched.static.constructor.name.already.defined=El método ''{0}'' que coincide con staticConstructorName ya está definido
inspection.message.method.s.with.d.parameters.matched.static.constructor.name.already.defined=El método ''{0}'' con ''{1}'' parámetros que coincide con staticConstructorName ya está definido
inspection.message.not.allowed.in.old.style.for.loops=''{0}'' no está permitido en bucles for de estilo antiguo
inspection.message.not.allowed.with.lambda.expressions=No se permite ''{0}'' con expresiones lambda.
inspection.message.not.compatible.with.array.initializer.expressions=''{0}'' no es compatible con las expresiones de inicialización de arreglos. Use la forma completa (new int[] ''{'' … ''}'' en lugar de solo ''{'' … ''}'')
inspection.message.not.generated.s.method.with.same.name.already.exists=No se generó ''{0}()'': ya existe un método con el mismo nombre
inspection.message.not.generated.s.method.with.similar.name.s.already.exists=No se generó ''{0}()'': ya existe un método con un nombre similar ''{0}''
inspection.message.not.generating.constant=No se generará una constante para este campo: el nombre de la constante sería igual al nombre de este campo.
inspection.message.not.generating.equals.hashcode=No se generarán equals ni hashCode: ya existe un método con uno de esos nombres. (Se generarán ambos métodos o ninguno).
inspection.message.not.generating.field.s.field.with.same.name.already.exists=No se genera el campo ''{0}'': ya existe un campo con el mismo nombre
inspection.message.not.generating.getter.for.this.field=No se genera el getter para este campo: no coincide con su lista de prefijos @Accessors.
inspection.message.not.generating.s.method.with.that.name.already.exists=No se generará ''{0}()'': ya existe un método con ese nombre
inspection.message.not.generating.setter.for.this.field.it=No se genera el setter para este campo: no coincide con su lista de prefijos @Accessors.
inspection.message.not.generating.setter.for.this.field.setters=No se genera el setter para este campo: no se pueden generar setters para campos final.
inspection.message.not.generating.wither=No se está generando un wither para este campo: no se pueden generar withers para campos estáticos.
inspection.message.not.generating.wither.for.this.field.withers=No se genera el método wither para este campo: no se pueden generar withers para campos que comiencen con $.
inspection.message.not.generating.wither.for.this.field.withers.cannot.be.generated=No se genera un wither para este campo: no se pueden generar withers para campos final inicializados.
inspection.message.obtain.via.is.static.true.not.valid.unless.method.has.been.set=@ObtainVia(isStatic = true) no es válido a menos que se haya establecido 'method'.
inspection.message.on.local.variable.requires.initializer.expression=''{0}'' en una variable local requiere una expresión de inicialización
inspection.message.s.legal.only.on.classes.enums=''@{0}'' solo es válido en clases y enumeraciones
inspection.message.s.not.valid.identifier=''{0}'' no es un identificador válido
inspection.message.s.only.supported.on.class.or.field.type=''@{0}'' solo está soportado en un tipo de clase o campo
inspection.message.setter.only.supported.on.class.or.field.type=@Setter solo es compatible con tipos de clase o de campo
inspection.message.slf4j.logger.defined.explicitly=El logger Slf4j está definido explícitamente. Use la anotación @Slf4j de Lombok en su lugar.
inspection.message.sneakythrows.calls.to.sibling.super.constructors.excluded=Las llamadas a constructores hermanos o superconstructores siempre se excluyen de @SneakyThrows; se ha ignorado @SneakyThrows porque no hay otro código en este constructor.
inspection.message.standardexception.accesslevel.none.not.valid=AccessLevel.NONE no es válido aquí
inspection.message.standardexception.class.only.supported.on.class=@StandardException solo se admite en una clase
inspection.message.standardexception.should.extend.throwable=@StandardException requiere que extiendas un tipo Throwable
inspection.message.superbuilder.can.be.used.on.classes.only=@SuperBuilder solo es compatible con clases.
inspection.message.superbuilder.can.be.used.on.static.inner.classes.only=@SuperBuilder no es compatible con clases anidadas no estáticas.
inspection.message.synchronized.field.is.not.static=El campo ''{0}'' no es estático y no puede utilizarse en este método estático
inspection.message.synchronized.legal.only.on.concrete.methods=@Synchronized solo es válido en métodos concretos.
inspection.message.synchronized.legal.only.on.methods.in.classes.enums=@Synchronized solo es válido en métodos de clases y enumeraciones.
inspection.message.syntax.either.obtain.via.field=La sintaxis es @ObtainVia(field = "fieldName") o @ObtainVia(method = "methodName").
inspection.message.to.string.only.supported.on.class.or.enum.type=@ToString solo es compatible con tipos de clase o enumeración
inspection.message.utility.class.already.marks.class.final=@UtilityClass ya marca la clase como final.
inspection.message.utility.class.already.marks.fields.static=@UtilityClass ya marca los campos como static.
inspection.message.utility.class.already.marks.inner.classes.static=@UtilityClass ya marca las clases internas como static.
inspection.message.utility.class.already.marks.methods.static=@UtilityClass ya marca los métodos como static.
inspection.message.utility.class.automatically.makes.class.static=@UtilityClass convierte automáticamente la clase en static; sin embargo, esta clase no puede definirse como static.
inspection.message.utility.class.cannot.be.placed=@UtilityClass no se puede colocar en una clase local de método o clase interna anónima, ni en ninguna clase anidada en tales clases.
inspection.message.utility.class.only.supported.on.class=@UtilityClass solo se admite en una clase (no puede ser una interfaz, enumeración o anotación).
inspection.message.utility.classes.cannot.have.declared.constructors=@UtilityClasses no pueden tener constructores declarados.
inspection.message.val.already.marks.variables.final='val' ya marca las variables como final.
inspection.message.val.works.only.on.local.variables='val' solo funciona en variables locales y en bucles foreach
inspection.message.value.already.marks.class.final=@Value ya marca la clase como final.
inspection.message.value.already.marks.non.static.fields.final=@Value ya marca los campos no estáticos como final.
inspection.message.value.already.marks.non.static.package.local.fields.private=@Value ya marca los campos no estáticos y de visibilidad de paquete como privados.
inspection.message.value.only.supported.on.class.type=@Value solo se admite en tipos de clase
inspection.message.var.works.only.on.local.variables.on.for.foreach.loops='var' solo funciona en variables locales y en bucles for/foreach
inspection.message.wither.needs.constructor.for.all.fields.d.parameters=@Wither requiere un constructor para todos los campos (''{0}'' parámetros)
inspection.message.wither.only.supported.on.class.or.field=@Wither solo se admite en una clase o un campo.
inspection.redundant.modifiers.utility.class.lombok.display.name=Modificadores de @UtilityClass
inspection.redundant.modifiers.val.lombok.display.name=Final' innecesario antes de 'val
inspection.redundant.modifiers.value.lombok.display.name=Modificadores @Value
inspection.redundant.slf.4.j.definition.display.name=@Slf4j
inspection.springqualifiercopyable.lombok.display.name=@Qualifier no copiable por Lombok
inspection.static.method.import.error=Las importaciones estáticas de métodos generados por Lombok no funcionan con javac
intention.category.lombok=Java/Lombok
intention.family.name.slf4j.annotation=Reemplazar el campo del logger con la anotación @Slf4j
intention.name.create.new.field.s=Crear nuevo campo ''{0}''
intention.name.replace.with.lombok=Reemplazar con Lombok
make.abstract.and.static.modifier.quickfix=Hacer que ''{0}'' sea abstract y static
make.abstract.and.static.modifier.quickfix.family.name=Cambiar modificador
notification.enable.annotation.processing=Habilitar el procesamiento de anotaciones
notification.group.lombok=Problema de integración de Lombok
plugin.settings.title=Lombok
popup.content.java.annotation.processing.has.been.enabled=Se ha habilitado el procesamiento de anotaciones de Java
replace.0.with.explicit.type.lombok=Reemplazar ''{0}'' con el tipo explícito (Lombok)
replace.explicit.type.with.0.lombok=Reemplazar el tipo explícito con ''{0}'' (Lombok)
replace.synchronized.lombok.intention=Reemplazar con Lombok @Synchronized
replace.with.annotations.lombok=Reemplazar con anotaciones (Lombok)
