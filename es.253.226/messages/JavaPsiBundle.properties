0.is.not.an.identifier=''{0}'' no es un identificador.
annotation.name.is.missing=El atributo de anotación debe tener el formato 'name=value'
annotation.target.ANNOTATION_TYPE=Tipo de anotación
annotation.target.CONSTRUCTOR=Constructor
annotation.target.FIELD=Campo
annotation.target.LOCAL_VARIABLE=Variable local
annotation.target.METHOD=Método
annotation.target.MODULE=Módulo
annotation.target.PACKAGE=Paquete
annotation.target.PARAMETER=Parámetro
annotation.target.RECORD_COMPONENT=Componente de registro
annotation.target.TYPE=Tipo
annotation.target.TYPE_PARAMETER=Parámetro de tipo
annotation.target.TYPE_USE=Uso de tipo
anonymous.class.context.display=Anónima en {0}
anonymous.class.derived.display=Clase anónima derivada de {0}
aux.context.display=De {0}
bad.return.type.in.lambda.expression=Tipo de retorno incorrecto en la expresión lambda: {0} no se puede convertir a {1}
bad.return.type.in.lambda.expression1=Tipo de retorno incorrecto en la expresión lambda: {0} no se puede convertir a void
bad.return.type.in.method.reference=Tipo de retorno incorrecto en la referencia de método: no se puede convertir {0} a {1}
bound.not.expected=Vínculo inesperado
catch.without.try=catch' sin 'try
class.context.display={0} en {1}
class.file.version=Versión {0}
class.literal.expected=Se esperaba .class
command.name.insert.block.statement=Insertar sentencia de bloque
conflicting.conjuncts={0} y {1}
context.type.java.comment=Comentario
context.type.string=Cadena
default.language.level.description=Predeterminado del SDK
diamond.error.anonymous.inner.classes=No se puede usar '<>' con clases internas anónimas
diamond.error.anonymous.inner.classes.non.private=No se puede usar '<>' debido a un método no privado que no sobrescribe ni implementa un método de un supertipo
diamond.error.cannot.infer.arguments=No se pueden inferir los argumentos
diamond.error.cannot.infer.arguments.unable.to.resolve.constructor=No se pueden inferir los argumentos (no se puede resolver el constructor)
diamond.error.cannot.infer.type.arguments=No se pueden inferir los argumentos de tipo para {0}
diamond.error.explicit.type.parameters.for.constructor=No se pueden utilizar diamantes con parámetros de tipo explícitos para el constructor
element.abstract_method=Método abstracto
element.annotation=Anotación
element.anonymous_class=Clase anónima
element.class=Clase
element.constant=Campo constante
element.constructor=Constructor
element.enum=Enumeración
element.enum_constant=Constante de enumeración
element.expression=Expresión
element.extends.list=Lista de extends
element.field=Campo
element.initializer=Inicializador
element.interface=interfaz
element.kind.and.name={0} {1}
element.label=Etiqueta
element.local_variable=Variable local
element.method=Método
element.method.call=Llamada a método
element.module=Módulo
element.package=Paquete
element.package.statement=Sentencia package
element.parameter=Parámetro
element.pattern_variable=Variable de patrón
element.permits.list=Lista de permits
element.receiver.parameter=Parámetro del receptor
element.record=Registro
element.record_component=Componente de registro
element.record_header=Encabezado de registro
element.snippet_body=Cuerpo del fragmento
element.statement=Sentencia
element.throws.list=lista de throws
element.type.arguments=Argumentos de tipo
element.type.parameter=Parámetro de tipo
element.type.parameters=Parámetros de tipo
element.type.semicolon=Punto y coma
element.unknown=Elemento
element.variable=Variable
else.without.if=else' sin 'if
enum.constant.context=Constante de enumeración ''{0}'' en ''{1}''
error.incompatible.type={0} no es compatible con {1}
error.incompatible.type.bad.lambda.return.type=Tipo de retorno incorrecto en la expresión lambda: {0} no se puede convertir a {1}
error.incompatible.type.declaration.for.the.method.reference.not.found=No se encontró ninguna declaración en tiempo de compilación para la referencia de método
error.incompatible.type.expected.non.void.got.void.method.reference=Tipos incompatibles: se esperaba un tipo distinto de void, pero la declaración en tiempo de compilación para la referencia de método tiene un tipo de retorno void
error.incompatible.type.expected.value.lambda=Tipos incompatibles: se esperaba un tipo distinto de void, pero el cuerpo de la lambda es un bloque que no es compatible con valores
error.incompatible.type.failed.to.resolve.argument=Error al resolver el argumento
error.incompatible.type.incompatible.equality.constraint=Restricción de igualdad incompatible: {0} y {1}
error.incompatible.type.incompatible.parameter.types.in.lambda=Número incorrecto de parámetros lambda: se esperaban {0} pero se encontraron {1}
error.incompatible.type.incompatible.parameter.types.in.method.reference=Tipos de parámetros incompatibles en la expresión de referencia de método
error.incompatible.type.incompatible.types.expected.not.void.got.void.method.reference=Tipos incompatibles: se esperaba un tipo distinto de void, pero la declaración en tiempo de compilación de la referencia de método tiene un tipo de retorno void
error.incompatible.type.incompatible.types.expected.void.lambda=Tipos incompatibles: se esperaba void, pero el cuerpo de la lambda no es ni una expresión de sentencia ni un bloque compatible con void
error.incompatible.type.no.type.variable=No existen instancias de las variables de tipo de modo que {0}
error.incompatible.type.no.type.variable.0=No existen instancias de la(s) variable(s) de tipo {0} de modo que {1}
error.incompatible.type.no.valid.function.type.found=No se encontró un tipo de función válido para {0}
error.incompatible.type.not.a.functional.interface={0} no es una interfaz funcional
error.incompatible.type.not.convertible=Tipos incompatibles: {0} no se puede convertir a {1}
error.incompatible.type.parameter.type.is.not.yet.inferred=El tipo de parámetro aún no se ha inferido: {0}
error.incompatible.type.return.type.is.not.yet.inferred=El tipo de retorno aún no se ha inferido: {0}
error.incompatible.type.unhandled.exception=Excepción no controlada: {0}
error.incompatible.upper.bounds=Límites superiores incompatibles: {0}
error.inference.variable.has.incompatible.bounds=La variable de inferencia {0} tiene límites incompatibles:\n {1}: {2}\n{3}: {4}
error.message.wildcard.not.expected=Comodín inesperado
error.type.parameter.has.incompatible.upper.bounds=El parámetro de tipo {0} tiene límites superiores incompatibles: {1}
expected.array.initializer=Se esperaba un inicializador de matriz
expected.boolean.expression=Se esperaba una expresión booleana
expected.case.label.element=Se esperaba una expresión, patrón, 'default' o 'null'
expected.catch.or.finally=Se esperaba 'catch' o 'finally'
expected.class.or.interface=Se esperaba 'class' o 'interface'
expected.class.reference=Se esperaba una referencia de clase
expected.colon=Se esperaba ':'
expected.colon.or.arrow=Se esperaba ':' o '->'
expected.comma=Se esperaba ','
expected.comma.or.rparen=Se esperaba ',' o ')'
expected.comma.or.semicolon=Se esperaba ',' o ';'
expected.dot=Se esperaba '.'
expected.eq=Se esperaba '='
expected.expression=Se esperaba una expresión
expected.gt=Se esperaba '>'.
expected.gt.or.comma=Se espera '>' o ','
expected.identifier=Se esperaba un identificador
expected.identifier.or.semicolon=Se esperaba un identificador o ';'
expected.identifier.or.type=Se esperaba un identificador o tipo
expected.lbrace=Se espera '{'
expected.lbrace.or.semicolon=Se esperaba '{' o ';'
expected.lbracket=Se esperaba '['
expected.lparen=Se esperaba '('
expected.lparen.or.lbracket=Se esperaba '(' o '['
expected.lt.or.lparen=Se esperaba '<' o '('
expected.module.declaration=Se esperaba una declaración de módulo
expected.module.statement=Se esperaba una directiva de módulo
expected.package.reference=Se esperaba una referencia de paquete
expected.parameter=Se esperaba un parámetro
expected.parameter.or.rparen=Se esperaba un atributo de anotación o ')'
expected.pattern=Se esperaba un patrón
expected.rbrace=Se esperaba '}'
expected.rbracket=Se esperaba ']'
expected.resource=Se esperaba una definición de recurso
expected.rparen=Se esperaba ')'
expected.semicolon=Se esperaba ';'
expected.statement=Se esperaba una sentencia
expected.string=Se esperaba un literal de cadena
expected.switch.label=Se espera 'case', 'default' o '}'
expected.switch.rule=Se esperaba una expresión, un bloque o una sentencia throw
expected.template.fragment=Se esperaba un fragmento de plantilla
expected.type=Tipo esperado
expected.type.parameter=Se esperaba un parámetro de tipo
expected.value=Se esperaba un valor
expected.while=Se esperaba 'while'
expected.with=Se esperaba 'with'
feature.advanced.collection.api=Métodos lambda en colecciones
feature.annotations=Anotaciones
feature.assertions=Aserciones
feature.auto.root.modules=Todos los módulos que exportan API son implícitamente módulos raíz
feature.binary.literals=Literales binarios
feature.classfile.api=ClassFile API
feature.collection.factories=Métodos de fábrica de colecciones
feature.diamond.types=Tipos de argumento
feature.effectively.final=Variables efectivamente finales
feature.enhanced.switch=Bloques 'switch' mejorados
feature.enum.qualified.name.in.switch=Enum cualificado como constante en switch
feature.enums=Enumeraciones
feature.extension.methods=Métodos de extensión
feature.for.each=Bucles for-each
feature.foreign.functions=Funciones y memoria de API externas
feature.generics=Genéricos
feature.hex.fp.literals=Literales de punto flotante hexadecimales
feature.implicit.classes=Clases implícitamente declaradas
feature.implicit.import.in.implicit.classes=Importación implícita en clases declaradas implícitamente
feature.inherited.static.main.method=Método main estático heredado
feature.inner.statics=Declaraciones estáticas en clases internas
feature.instance.main.method=Método main de instancia
feature.intersections.in.casts=Tipos de intersección en casts
feature.javadoc.snippets=@snippet en Javadoc
feature.lambda.expressions=Expresiones lambda
feature.local.enums=Enumeraciones locales
feature.local.interfaces=Interfaces locales
feature.lvti=Inferencia de tipos de variables locales
feature.markdown.comment=Comentario de documento Markdown
feature.method.references=Referencias de métodos
feature.module.import.declarations=Declaraciones de importación de módulo
feature.modules=Módulos
feature.multi.catch=Multi capturas
feature.nestmates=Control de acceso basado en nidos
feature.no.this.capture=Las clases internas no capturan 'this'
feature.objects.class=java.util.Objects API
feature.override.interface=@Override en interfaces
feature.package.import.shadow.module.import=La importación bajo demanda es mejor que la importación de módulo
feature.package.transitive.dependency.on.java.base=Dependencia transitiva en el módulo java.base
feature.pattern.guard.and.record.patterns=Guardas de patrón y patrones de registro
feature.patterns.in.switch=Patrones en switch
feature.patterns.instanceof=Patrones en 'instanceof'
feature.primitive.types.in.patterns=Tipos primitivos en patterns, instanceof y switch
feature.private.interface.methods=Métodos de interfaz privados
feature.record.patterns.in.for.each=Patrones de registro en bucles for-each
feature.records=Registros
feature.repeating.annotations=Repetición de anotaciones
feature.scoped.values=Valores de ámbito
feature.sealed.classes=Clases selladas
feature.sequenced.collections=Colecciones secuenciadas
feature.serial.annotation=Anotación @Serial
feature.statements.before.super=Sentencias antes de super()
feature.static.imports=Importaciones estáticas
feature.static.interface.calls=Llamadas a métodos estáticos de interfaz
feature.stream.and.optional.api=API de corrientes y opcionales
feature.stream.gatherers=Stream Gatherers
feature.strictfp=Semántica de punto flotante siempre estricta
feature.string.switch=Cadenas en sentencias 'switch'
feature.string.templates=Plantillas de cadena
feature.structured.concurrency=Concurrencia estructurada
feature.switch.expressions='switch' expresiones
feature.text.block.escape.sequences=Secuencias de escape 's'
feature.text.blocks=Literales de bloque de texto
feature.try.with.resources=Try-with-resources
feature.try.with.resources.refs=Referencias a recursos
feature.type.annotations=Anotaciones de tipo
feature.type.receivers=Parámetros de receptor
feature.underscores.in.literals=Subrayado en literales
feature.unnamed.vars=Patrones y variables sin nombre
feature.utf8.property.files=Archivos de propiedades con codificación UTF-8
feature.valhalla.value.classes=Clases de valor de Valhalla
feature.var.lambda.parameter='var' en parámetros lambda
feature.varargs=Métodos con aridad variable
feature.virtual.threads=Subprocesos Virtuales
feature.with.initial=ThreadLocal.withInitial()
filetype.class.description=Clase Java
filetype.class.display.name=Clase Java
filetype.java.description=Java
filetype.java.module.description=Módulo Java
filetype.java.module.display.name=Módulo Java
filetype.jshell.description=Fragmento de código JShell
finally.without.try=finally' sin 'try
implicit.class.context.display=Clase implícita
import.statement.identifier.or.asterisk.expected.=Se esperaba un identificador o '*'
java.terms.anonymous.class.base.ref={0} anónima
javadoc.exception.tag.class.is.not.throwable=La clase {0} no es descendiente de Throwable
javadoc.exception.tag.exception.is.not.thrown={0} no está declarado como lanzado por el método {1}
javadoc.exception.tag.wrong.tag.value=Valor de etiqueta incorrecto
javadoc.param.tag.parameter.name.expected=Se esperaba un nombre de parámetro
javadoc.param.tag.type.parameter.gt.expected=Se esperaba '>'
javadoc.param.tag.type.parameter.name.expected=Se esperaba un nombre de parámetro de tipo
javadoc.ref.tag.class.ref.expected=Se esperaba una referencia de clase
javadoc.value.field.required=La etiqueta @value debe hacer referencia a un campo
javadoc.value.field.with.initializer.required=La etiqueta @value debe hacer referencia a un campo con un inicializador constante
javadoc.value.static.field.required=La etiqueta @value debe hacer referencia a un campo estático
javadoc.value.tag.jdk15.required=La etiqueta @value no puede tener ningún argumento cuando se utiliza JDK 1.4 o versiones anteriores
jdk.1.3.language.level.description=1.3 - Java clásico
jdk.1.4.language.level.description=1.4 - palabra clave 'assert'
jdk.1.5.language.level.description=5 - palabra clave 'enum', genéricos, autoboxing, etc.
jdk.1.6.language.level.description=6 - @Override en las interfaces
jdk.1.7.language.level.description=7 - Diamantes, ARM, multi-catch, etc.
jdk.1.8.language.level.description=8 - Lambdas, anotaciones de tipo, etc.
jdk.1.9.language.level.description=9 - Módulos, métodos privados en interfaces, etc.
jdk.10.language.level.description=10 - Inferencia de tipos de variables locales
jdk.11.language.level.description=11 - Sintaxis de variable local para parámetros lambda
jdk.12.language.level.description=12 - Sin nuevas características de idioma
jdk.13.language.level.description=13 - Sin nuevas funcionalidades de idioma
jdk.14.language.level.description=14 - Expresiones switch
jdk.15.language.level.description=15 - Bloques de texto
jdk.16.language.level.description=16 - Records, patrones, enumeraciones locales e interfaces
jdk.17.language.level.description=17 - Tipos sellados, semántica de punto flotante siempre estricta
jdk.18.language.level.description=18 - Fragmentos de JavaDoc
jdk.19.language.level.description=19 - Sin nuevas características del lenguaje
jdk.20.language.level.description=20 - Sin características de lenguaje nuevas
jdk.21.language.level.description=21 - Patrones de registro, comparación de patrones para switch
jdk.21.preview.language.level.description=21 (Vista previa) - Plantillas de cadenas, clases sin nombre y métodos main de instancia, etc.
jdk.22.language.level.description=22 - Variables y patrones sin nombre
jdk.22.preview.language.level.description=22 (vista previa): declaraciones antes de super(), plantillas de cadena (2.ª versión previa)
jdk.23.language.level.description=23 - Comentario de documentación de Markdown
jdk.23.preview.language.level.description=23 (Vista previa) - Tipos primitivos en patrones, clases declaradas implícitamente, etc.
jdk.24.language.level.description=24 - Recolectores de Flujo
jdk.24.preview.language.level.description=24 (Vista previa) - cuerpos de constructor flexibles, archivos fuente simples, etc.
jdk.X.language.level.description=X - Funciones experimentales
jdk.unsupported.preview.language.level.description={0} (Vista previa) - No compatible
lambda.body.must.be.a.statement.expression=El cuerpo de la lambda debe ser una expresión de sentencia
list.item.no.module=<sin módulo>
local.class.preposition=Local
method.context.display={0}() en {1}
missing.return.value.lambda=Falta el valor de retorno
node.abstract.flag.tooltip=Abstracto
node.annotation.tooltip=Anotación
node.anonymous.class.tooltip=Clase anónima
node.class.tooltip=Clase
node.enum.tooltip=Enumeración
node.exception.tooltip=Excepción
node.field.tooltip=Campo
node.final.flag.tooltip=Final
node.interface.tooltip=Interfaz
node.junit.test.tooltip=Prueba de JUnit
node.method.tooltip=Método
node.record.tooltip=Registro
node.runnable.class.tooltip=Clase ejecutable
node.simple.source.file.tooltip=Compactar archivo fuente
node.static.flag.tooltip=Estático
psi.error.attempt.to.edit.class.file=No se puede modificar el elemento compilado en el archivo ''{0}''
task.background.title.maven=Maven
type.can.be.converted={0} se puede convertir a {1}
type.conforms.to.constraint={0} cumple con {1}
unexpected.identifier=Identificador inesperado
unexpected.return.value=Valor de retorno inesperado
unexpected.token=Token inesperado
unexpected.tokens=Tokens inesperados
