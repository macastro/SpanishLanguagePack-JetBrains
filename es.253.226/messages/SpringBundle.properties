ActivateSpringProfileIntentionAction.activate.profile=Activar perfil ''{0}''
ActivateSpringProfileIntentionAction.activate.profile.family.name=Activar perfil
ActivateSpringProfileIntentionAction.deactivate.profile=Desactivar perfil ''{0}''
ActivateSpringProfileIntentionAction.deactivate.profile.family.name=Desactivar perfil
AsyncMethodInspection.incorrect.signature=El método anotado con @Async debe devolver 'void' o un tipo "similar a Future"
AsyncMethodInspection.inspection.display.name=Firma de método @Async incorrecta
AutowireBeanGenerateAction.popup.beans.title=Autovincular Bean
AutowireBeanGenerateAction.search.beans.progress.title=Buscando beans…
ChangeActiveProfileDialogUi.radio.button.comment=Lista de perfiles separados por comas
ChangeActiveProfileDialogUi.radio.button.context=Contexto
ChangeActiveProfileDialogUi.radio.button.module=Módulo
ChangeActiveProfileDialogUi.radio.button.profiles=Perfiles:
ChangeActiveProfileDialogUi.radio.button.project=Proyecto
ChangeActiveProfileDialogUi.radio.button.scope=Ámbito:
ContextComponentScanInconsistencyInspection.annotation.is.expected.here=Se espera una anotación aquí
ContextJavaBeanUnresolvedMethodsInspection.cannot.resolve.method=No se puede resolver el método
ContextJavaBeanUnresolvedMethodsInspection.display.name=Método init/destroy desconocido en la anotación @Bean
GenerateEventListenerMethodAction.command.title=Generar método de escuchador de eventos
GenerateEventListenerMethodAction.popup.context.events=Contexto
GenerateEventListenerMethodAction.popup.lifecycle.events=Ciclo de vida
GenerateEventListenerMethodAction.popup.other.events=Otros
GenerateEventListenerMethodAction.popup.project.events=Proyecto
GenerateEventListenerMethodAction.popup.title=Seleccionar evento
GenerateEventListenerMethodAction.search.events.progress.title=Buscando eventos…
GenerateEventListenerMethodAction.title=Método Listener de Evento...
ImplicitSubclassInspection.display.bean.in.configuration=El método @Bean en @Configuration debe poder sobrescribirse
ImplicitSubclassInspection.display.forClass.annotated=Las clases anotadas con ''@{0}'' pueden ser subclasificadas implícitamente y no deben ser final
ImplicitSubclassInspection.display.forMethod.annotated=Los métodos anotados con ''@{0}'' deben ser sobrescribibles
ScheduledMethodInspection.incorrect.signature=Los métodos @Scheduled no deben recibir ningún argumento ni devolver ningún valor
ScheduledMethodInspection.inspection.display.name=Firma de método @Scheduled incorrecta
SpringAutowiredFieldsWarningInspection.inspection.display.name=Inyecciones de campos no recomendadas
SpringAutowiringInspection.add.qualifier.fix=Añadir calificador
SpringBeanMoveHandler.choose.file=Seleccionar archivo
SpringBeanMoveHandler.no.other.files.found=No se encontraron otros archivos de Spring
SpringContextConfigurationInspection.cannot.find.default.app.context=No se puede encontrar el archivo de contexto de aplicación predeterminado {0}
SpringContextConfigurationInspection.create.nested.configuration.class=Crear clase 'ContextConfiguration' anidada
SpringEventListenerInspection.inspection.display.name=Métodos @EventListener configurados incorrectamente
SpringInactiveProfilesHighlightingPass.inactive.profile=Perfil inactivo
SpringIncorrectResourceTypeInspection.expected.resource.types=Tipo de recurso incorrecto. Tipos esperados: {0}
SpringIncorrectResourceTypeInspection.incorrect.resource.type=Tipo de recurso incorrecto
SpringSpiRegistrationAnnotator.choose.registration=Seleccionar registro
SpringSpiRegistrationAnnotator.spring.factories.registration=Registro en spring.factories
SpringSpiRegistrationAnnotator.tooltip=Navegar al registro en 'spring.factories'
SpringStaticMembersAutowiringInspection.display.name=Autowiring o inyección incorrecta de componentes Spring en un miembro de clase estático
SpringUpdateSchemaIntention.schema.update.failed.for.invalid.file=La actualización del esquema falló para el archivo no válido {0}
SpringUpdateSchemaIntention.spring.schema.update=Actualización del esquema de Spring
UnparsedCustomBeanInspection.unsupported.tag=Etiqueta ''{0}'' no compatible para el espacio de nombres ''{1}'', informe del problema (Ayuda|{2})
abstract.class.not.allowed=No se permite una clase abstracta para beans no abstractos
action.DumpSpringConfiguration.text=Volcar configuración de Spring
action.Spring.Beans.Generate.Autowiring.Action.text=Vincular bean automáticamente…
action.Spring.Beans.Generate.Autowiring.Filter.Separator.text=Filtro
action.Spring.Beans.Generate.Autowiring.SearchInLibraries.Action.text=Mostrar de las bibliotecas
action.Spring.Beans.Generate.Autowiring.ShowBeanImplAction.Action.text=Mostrar clase de implementación del Bean
action.Spring.Beans.Generate.Autowiring.ShowPackagesAction.Action.text=Mostrar paquetes
action.Spring.Beans.Generate.Autowiring.ShowProjectBeans.Action.text=Mostrar beans del proyecto
action.Spring.Beans.Generate.Autowiring.ShowRepositoryBeans.Action.text=Mostrar repositorios
action.Spring.Beans.Generate.Autowiring.ShowServices.Action.text=Mostrar servicios
action.Spring.Beans.Generate.Autowiring.UseGroupsAction.Action.text=Usar grupos
action.Spring.Beans.Generate.Autowiring.View.Separator.text=Vista
action.Spring.Beans.Generate.Autowiring.ViewSuperClassesAction.Action.text=Agrupar por clases base
action.Spring.Beans.Generate.Constructor.Dependency.Action.text=Dependencia de constructor de Spring…
action.Spring.Beans.Generate.Setter.Dependency.Action.text=Dependencia de setter de Spring…
action.Spring.Beans.View.Configuration.Implicit.text=Mostrar Beans implícitos
action.Spring.Beans.View.Configuration.Infrastructure.text=Mostrar beans de infraestructura XML
action.Spring.Create.Component.Generate.description=Crea un nuevo componente Spring
action.Spring.Create.Component.Generate.text=Componente de Spring…
action.Spring.Create.Component.Java.description=Crea un nuevo componente Java Spring
action.Spring.Create.Component.Java.text=Componente Spring (Java)
action.Spring.Create.Component.Kotlin.description=Crear un nuevo componente Spring de Kotlin
action.Spring.Create.Component.Kotlin.text=Componente de Spring (Kotlin)
action.Spring.Create.Component.dialog.title=Nuevo componente Spring
action.Spring.Create.Context.File.text=Configuración de Spring
action.Spring.Events.Generate.Listener.text=Escuchador de eventos…
action.SpringChangeActiveProfiles.text=Cambiar perfiles de Spring activos…
action.SpringConfigurationCheckAction.text=Comprobar la configuración de Spring
action.generate.autowired.dependencies.action.text=Dependencia @Autowired…
application.context.configuration=Configuración del contexto de la aplicación
autowired.dependencies.goto.related.item.group.name=Dependencias autowired
bean.autowiring.by.type=No se pudo realizar la vinculación automática. Hay más de un bean de tipo ''{0}''. Beans: {1}. Propiedades: ''{2}''
bean.autowiring.by.type.no.beans=No se pudo realizar el autowire. No se encontraron beans de los tipos ''{0}'' o ''{1}''.
bean.autowiring.by.type.no.parameter.for.autowired.method=Autowired {0} sin parámetros
bean.autowiring.by.type.none=No se pudo autovincular. No se encontraron beans de tipo ''{0}''.
bean.bad.property.type=La propiedad de tipo ''{0}'' no puede ser inyectada por ''{1}''
bean.class.autowired.by.type=No se pudo realizar la autovinculación. Hay más de un bean de tipo ''{0}''.
bean.class.autowired.incorrect.qualifier.type=No se pudo realizar la autovinculación. El bean calificado debe ser de tipo ''{0}''.
bean.class.unknown.qualifier.bean=No se puede encontrar el bean con el calificador ''{0}''
bean.method.called.from.configuration.without.proxy=El método anotado con @Bean se invoca directamente en un @Configuration donde proxyBeanMethods está establecido en false. Establezca proxyBeanMethods en true o utilice la inyección de dependencias.
bean.method.called.without.proxy=El método anotado con @Bean se llama directamente. Use la inyección de dependencias en su lugar.
bean.property.extract.name=Extraer valor de la propiedad al archivo de configuración
cacheable.and.cache.put.on.the.same.method=Spring no recomienda el uso de las anotaciones @CachePut y @Cacheable en el mismo método
cacheable.annotations.should.be.defined.on.public.methods=Las anotaciones de caché deben definirse en métodos públicos
cacheable.no.cache.could.be.resolved.for.cache.operation=Se requiere al menos un nombre de caché no vacío por cada operación de caché.
cacheable.should.be.defined.on.concrete.method=Spring no recomienda anotar métodos de interfaz con la anotación @Cache*
cannot.autowire.bean.of.type=No se pudo realizar el autowire. El bean debe ser de tipo ''{0}''
cannot.find.bean.constructor.with.parameters.count=No se encontró ningún constructor coincidente en la clase ''{0}''
cannot.find.bean.qualified.by=No se puede encontrar el bean calificado con {0}
cannot.find.constructor.arg.index=No se puede encontrar el constructor con el índice de argumento {0}
cannot.find.constructor.arg.index.in.class=No se puede encontrar el constructor con el índice de argumento {0} en la clase {1}
cannot.find.factory.method.index=No se puede encontrar el método de fábrica con el índice de argumento {0} en la clase {1}
cannot.find.factory.method.with.parameters.count=No se encontró ningún método de fábrica coincidente en la clase
change.active.profile.dialog.context=Contexto ''{0}''
change.active.profile.dialog.module=Módulo ''{0}''
change.active.profile.dialog.spring.profiles=Cambiar perfiles de Spring activos
checkbox.remember.my.choice=Recordar mi elección
checking.spring.configuration=Comprobando las configuraciones de Spring en el módulo ''{0}''
class.is.not.spring.bean.autowired=Los miembros autowired deben definirse en un bean de Spring válido (@Component|@Service|…)
class.without.matching.constructor.for.autowiring=La clase no contiene un constructor coincidente para autowiring
component.scan.setup.inspection.key=Paquete no válido en @ComponentScan o su meta-anotación
config.detecting.contexts=Detectando contextos de la aplicación…
config.display.name=Configuración
config.file.is.not.spring=El archivo no se reconoce como una configuración de Spring
config.file.not.found=Archivo no encontrado
config.files.not.found=No se encontraron archivos
config.new.file=Configuración de Spring
config.no.contexts.defined=No se han definido contextos de aplicación
config.unmapped.configs.popup.title=Archivos de configuración de Spring no mapeados en {0}
configuration.tab.additional.settings=Configuración adicional
constructor.arg.incorrect.value.type=El tipo de valor inyectado debe corresponder al tipo del argumento del constructor
context.schema.inspection.name=Definición de filtro no válida en escaneos de componentes basados en XML
create.component.action.this.already.exists=El archivo {0} ya existe
create.component.fix.text=Crear componente ''{0}''…
create.component.rename.reference=Renombrar referencia de clase
create.missing.mappings=Crear mapeos faltantes para ''{0}''
create.missing.mappings.family.name=Crear mapeos faltantes
create.missing.properties=Crear propiedades faltantes
create.new.spring.configuration.file=Crear nuevo archivo de configuración de Spring
custom.bean.no.id=IntelliJ IDEA no puede encontrar el ID de este bean en un archivo de configuración. Cambiar el nombre probablemente produzca\ncódigo incorrecto. ¿Desea continuar?
custom.bean.no.id.title=Advertencia
custom.namespace.quick.fixes.create.custom.namespace.bean=Crear bean de espacio de nombres personalizado ({0} variantes)…
custom.namespace.quick.fixes.create.custom.namespace.bean.with.id=Crear bean de espacio de nombres personalizado {0}
custom.namespace.quick.fixes.create.name=Crear {0}
custom.namespace.quick.fixes.family.name=Crear bean de espacio de nombres personalizado
custom.namespace.quick.fixes.popup.title=Crear Bean de espacio de nombres personalizado
custom.namespace.registration.inspection.key=Referencia de archivo o clase no resuelta en el archivo 'spring.handlers' o 'spring.schemas'
dependency.node.in.module.tail=(en el módulo {0})
do.you.want.to.move.bean.to.the.top.level=¿Desea mover el bean al nivel superior?
duplicated.bean.name.inspection.name.view.duplicates=Ver duplicados
duplicated.bean.quick.fix.description=Navegar a los duplicados
duplicated.bean.quick.fix.popup.title=Ver duplicados
editor.panel.profiles.tooltip=Perfil activo
editor.panel.profiles.tooltip.action.name=Cambiar perfiles…
event.listener.method.parameters.count=El método debe tener como máximo un parámetro
event.listener.method.visibility.nonstatic=El método anotado con @EventListener debe ser no estático
facet.context.autoconfigured.suffix=(autoconfigurado)
facet.context.autodetected.suffix=(autodetectado)
facet.context.code.files=Configuraciones basadas en código
facet.context.default.name=Contexto de la aplicación Spring
facet.context.edit.add.file.choose.type=Seleccionar tipo
facet.context.edit.name.label=&Nombre:
facet.context.edit.name.validation.already.exists=Ya existe un contexto con ese nombre. Si ha eliminado un contexto existente con ese nombre, primero debe usar "Aplicar".
facet.context.edit.name.validation.not.empty=El nombre no puede estar vacío
facet.context.edit.parent.label=Contexto &padre:
facet.context.edit.parent.none.selected=<ninguno>
facet.context.edit.title=Editar contexto de aplicación ''{0}''
facet.context.new.title=Nuevo contexto de aplicación
facet.context.other.files=Otros archivos
facet.context.properties.files=Archivos de propiedades adicionales
facet.context.remove.message=¿Realmente desea eliminar el contexto de la aplicación "{0}"? (No se eliminará ningún archivo)
facet.context.remove.title=Eliminar
facet.context.xml.files=Configuraciones basadas en XML
field.injection.add.parameter.family.warning=Cambiar inyección de campos. Añadir parámetro(s) al constructor
field.injection.add.parameters=<html>Añadir parámetro(s) al constructor: {0}</html>
field.injection.create.constructor.family.warning=Cambiar inyección de campos. Crear constructor
field.injection.create.constructor.injection=<html>Crear constructor: {0}</html>
field.injection.is.not.recommended=No se recomienda la inyección de campo
fileset.circular.dependencies=Dependencias circulares entre contextos:<br/>{0}<br/>{1}
fileset.contains.testing.configs.full={0, choice, 1#El archivo de configuración|1<{0, number} archivos de configuración} para pruebas <em>no</em> se deben agregar a los contextos:<br/>{1}
fileset.contains.testing.configs.short={0, choice, 1#Archivo de configuración|1<{0, number} archivos de configuración} para pruebas <em>no</em> debe añadirse a los contextos
fileset.editor.help.label=<html>Los archivos de configuración referenciados mediante <b>&lt;import …/&gt;</b> o <b>@Import</b> se añadirán implícitamente.<br/>Los archivos de configuración utilizados para pruebas <em>no</em> deben añadirse a los contextos.</html>
group.Internal.Spring.text=Spring
group.Spring.Beans.Generate.Action.text=Bean de Spring
group.spring.components=Componentes
group.spring.config=Configuración
gutter.choose.autowired.candidates.title=Elegir candidato autowired
gutter.choose.bean.factory.calls.title=Seleccionar usos de BeanFactory.getBean(…)
gutter.navigate.no.bean.factory.calls=No se han encontrado usos de BeanFactory coincidentes
gutter.navigate.no.matching.autowired.candidates=No se encontraron candidatos autowired coincidentes
gutter.navigate.no.matching.beans=No se encontraron beans coincidentes
gutter.navigate.to.autowired.candidates.title=Navegar a los candidatos autovinculados
gutter.navigate.to.bean.factory.calls.title=Navegar a los usos de BeanFactory.getBean(…)
idref.cannot.be.added.in.collection=No se puede añadir a una colección de tipo ''{0}''
incorrect.constructor.arg.index.not.unique=El índice debe ser único
injection.lookup.defaultMethodCommentText=Este método será sobrescrito por Spring y devolverá una nueva instancia de {0}
injectionType.CONSTRUCTOR.description=Inyectar instancia bean mediante método constructor
injectionType.CONSTRUCTOR.name=Dependencia de constructor
injectionType.CONSTRUCTOR.settings=Constructor
injectionType.FIELD.description=Inyectar la instancia bean vía campo con la annotación @Autowired
injectionType.FIELD.name=@Autowired Dependencia
injectionType.LOOKUP_METHOD.description=Crea un método Lookup que devolverá la instancia del Bean desde BeanFactory.
injectionType.LOOKUP_METHOD.name=Dependencia de método de búsqueda
injectionType.LOOKUP_METHOD.settings=Método de búsqueda
injectionType.OBJECT_FACTORY_METHOD.description=Define un factory que puede devolver una instancia de bean (posiblemente compartida o independiente) cuando se invoca.
injectionType.OBJECT_FACTORY_METHOD.name=Dependencia de método de fábrica de objetos
injectionType.OBJECT_FACTORY_METHOD.settings=Fábrica de Objetos
injectionType.SETTER.description=Inyecta una instancia de bean a través de un método setter con la anotación @Autowired
injectionType.SETTER.name=Inyección de Setter
injectionType.SETTER.settings=Setter
inspection.group.code=Código
inspection.group.xml=XML
interface.not.allowed=Interfaz no permitida para beans no abstractos
internal.error.parsing.bean=Error interno al analizar el bean; salida:\n{0}
introduce.bean.intention=Introducir bean
live.template.bean.description=Plantilla '@Bean' de Spring
live.template.component.description=Plantilla de Spring '@Component'
live.template.configuration.description=Plantilla Spring '@Configuration'
live.template.service.description=Plantilla '@Service' de Spring
logical.spring.bean.autowired.in=Autowired en
logical.spring.bean.autowires=Autocableado
logical.spring.bean.implementations=Implementaciones
logical.spring.bean.requires=Requiere
logical.spring.configuration.imports=Importaciones
logical.spring.event.listeners=Listeners
logical.spring.event.publishers=Publicadores
logical.spring.scanned.components=Componentes escaneados
logical.spring.service.methods=Métodos
mark.bean.as.abstract=Marcar bean como abstracto
message.navigation.available.during.indexing=La navegación no está disponible, analizando el proyecto…
method.cannot.instantiate.bean=El método factory ''{0}'' no puede instanciar el bean
method.must.be.public=El método de factoría ''{0}'' debe ser público
method.must.be.static=El método de factoría ''{0}'' debe ser estático
method.must.not.be.static=El método de fábrica ''{0}'' no debe ser static
method.parameters.removing.fix.family.name=Eliminar parámetros del método
method.parameters.removing.fix.text=Cambiar ''{0}'' a sin argumentos
method.return.type.make.async.family.name=Cambiar el método para devolver un valor de tipo "Future"
method.return.type.make.async.fix.text=Cambiar el método para que devuelva ''{0}''
model.add.constructor.args.for.method.quickfix.description=Generar las etiquetas 'constructor-arg' faltantes
model.add.constructor.args.for.method.quickfix.message=Añadir <constructor-arg>(s) para ''{0}''
model.add.constructor.args.for.method.quickfix.message.family.name=Añadir <constructor-arg>(s)
model.bean.not.found.error.message=No se pudo encontrar el bean con el nombre ''{0}''
model.bean.quickfix.message=Crear nuevo bean ''{0}''
model.bean.quickfix.message.family.name=Crear nuevo bean
model.create.factory.method.quickfix.family.name=Crear método factory
model.create.factory.method.quickfix.message=Crear método de factoria ''{0}''
model.goto.related.item.group.application.context=Contextos de aplicación de Spring
model.goto.related.item.group.context=Contexto de Spring: "{0}"
model.goto.related.item.group.test.context=Contextos de prueba de Spring
model.inspection.bean.autowiring=Autowiring de beans XML de Spring incorrecto
model.inspection.bean.constructor.arg=Inyección de constructor incorrecta en bean de Spring XML
model.inspection.bean.factory.method=Método definido incorrectamente referenciado en un atributo "factory-method"
model.inspection.bean.property.value=Tipo de punto de inyección no asignable en el contexto de aplicación XML
model.inspection.bean.public.factory.method=Método no público incorrecto referenciado en un atributo "factory-method"
model.inspection.display.bean.name.convention=El nombre del bean de Spring infringe las convenciones
model.inspection.display.name=Contexto de aplicación de Spring Core basado en XML incorrecto
model.inspection.inactive.profile=Resaltado de perfil inactivo
model.inspection.injection.value.add.array=Añadir etiqueta <array>
model.inspection.injection.value.add.list=Añadir etiqueta <list>
model.inspection.injection.value.add.map=Añadir etiqueta <map>
model.inspection.injection.value.add.ref=Añadir atributo "ref"
model.inspection.injection.value.add.set=Añadir etiqueta <set>
model.inspection.injection.value.consistency=Valor de inyección inconsistente en el contexto de aplicación XML
model.inspection.injection.value.entry.key=La entrada de mapa debe especificar una clave
model.inspection.injection.value.message={0} debe especificar un ref o un valor
model.inspection.injection.value.style=El valor de inyección en el contexto de la aplicación XML infringe las convenciones
model.inspection.injection.value.style.message=Uso del elemento <value> explícito
model.inspection.injection.value.style.ref.fix=Reemplazar el elemento <ref> por el atributo "{0}"
model.inspection.injection.value.style.ref.fix.family.name=Reemplazar el elemento <ref> por un atributo
model.inspection.injection.value.style.ref.message=Uso de un elemento <ref> explícito
model.inspection.injection.value.style.value.fix=Reemplazar el elemento <value> con el atributo "{0}"
model.inspection.injection.value.style.value.fix.family.name=Reemplazar el elemento <value> por un atributo
model.inspection.invalid.identifier.message=''{0}'' no cumple con la convención de nomenclatura de beans
model.inspection.invalid.lowercase.name.message=''{0}'' debe comenzar con una letra minúscula
model.inspection.validator.progress.text=Validando el modelo Spring…
model.method.choose.method=Seleccionar método
model.method.resolve.class.error.message=No se pudo resolver la clase ''{0}''
model.method.signature.parse.error.message=No se pudo analizar la firma ''{0}''
model.property.error.message=No se puede resolver la propiedad ''{0}''
model.qualifiers.in.class.inspection.display.name=Autowiring incorrecto en componentes de bean de Spring
move.bean=Mover Bean
move.bean.to.the.top.level=Mover Bean al nivel superior
multiple.autowiring.constructor=Solo un constructor puede tener la anotación @Autowired
multiple.context.description.in.module.text=<html><body>  en el módulo <b>{0}</b>.</body></html>
multiple.context.description.in.modules.label.text=<html><body>El archivo está incluido en <b>{0} contextos</b> en <b>{1}</b> módulos.</body></html>
multiple.context.description.label.text=<html><body>El archivo está incluido en <b>{0} contextos</b>.</body></html>
multiple.context.tooltip.text=Contexto activo
navigate.to.autowired.dependencies=Navegar a las dependencias autoinyectadas
navigate.to.by.name.autowired.dependencies=Navegar a las dependencias autoinyectadas 'byName'
navigate.to.fileset.configuration=Navegar a las configuraciones del contexto de la aplicación
notification.group.spring.beans=Error en el análisis de beans personalizados de Spring
notification.group.spring.configuration=Se han detectado problemas de configuración de Spring
parse.custom.bean.error=Error al analizar el Bean personalizado
parse.custom.bean.intention=Analizar bean personalizado
parse.custom.bean.success=El manejador personalizado ha finalizado con éxito
parse.no.custom.beans=El analizador no produjo beans
parse.no.namespace.handler=No se encontró el controlador personalizado para el espacio de nombres ''{0}''
parse.only.infrastructure.beans=El analizador solo generó beans de infraestructura
parse.these.beans=El manejador de espacio de nombres personalizado generó las siguientes definiciones de bean:\n{0}
parse.these.beans.induct=El manejador de espacios de nombres personalizado generó la siguiente definición de bean:\n{0}\n\n¿Desea asumir que todos los beans\ndel espacio de nombres ''{1}'' con el nombre local ''{2}''\ntienen la misma clase y toman su id del atributo ''{3}''?
parse.these.beans.induct.all.beans=Todos los beans
parse.these.beans.induct.only.this=Este Bean
parsing.custom.bean=Ejecutando manejadores de beans de Spring personalizados…
placeholders.inspection.display.name=Marcadores de posición no resueltos configurados en el contexto de aplicación XML de Spring
popup.title.select.injection.type=Seleccionar tipo de inyección
popup.title.select.prototypeInjection.type=Seleccionar tipo de inyección de prototipo
process.explicitly.annotated.beans=Procesar beans anotados explícitamente
process.unexpectedly.terminated=Proceso terminado inesperadamente{0}
progress.creating.component=Creando el componente Spring {0}
reference.injector.spring.bean.name=Nombre del Bean de Spring
reference.injector.spring.placeholder=Marcador de posición de Spring
reference.injector.spring.resource.path=Ruta de recurso de Spring
required.properties.inspection=La propiedad del bean de Spring @Required no se ha inyectado
required.properties.missed=Faltan propiedades requeridas: ''{0}''
required.property.not.mapped=No se ha inyectado la propiedad requerida ''{0}''
required.spring.bean.type.inspection=Tipo de bean inyectado incorrecto
scopes.inspection.display.name=Ámbito <bean> desconocido
searching.for.implicit.usages=Buscando usos implícitos…
searching.for.stereotype.usages=Buscando usos del estereotipo…
spring=Spring
spring.add.bean.dependency.fix.family.name=Añadir dependencia al bean
spring.add.bean.dependency.fix.text=Añadir dependencia con nombre coincidente con ''{0}''
spring.aliases=Alias
spring.app.context.navigate.tooltip=Navegar al contexto de la aplicación
spring.app.context.to.navigate=Seleccionar contexto de la aplicación
spring.application.auto.configuration=Autoconfiguración
spring.bean=Bean de Spring
spring.bean.abstract.bean.references.inspection=Referencia incorrecta a un bean abstracto
spring.bean.already.exists=Ya existe un Spring Bean con el nombre ''{0}'' en {1}
spring.bean.attributes.inspection.key=Atributo de bean de Spring en conflicto
spring.bean.autowire.escape=Hacer explícita la dependencia autowired
spring.bean.autowire.escape.inspection.name=Dependencia autowired innecesaria en el contexto de aplicación XML
spring.bean.class.navigate.choose.class.title=Seleccionar Bean
spring.bean.class.tooltip.navigate.declaration=Navegar a la(s) declaración(es) del bean de Spring
spring.bean.class.tooltip.show.in.description=Seleccionar en la vista Spring
spring.bean.constructor.arg=Argumento del constructor
spring.bean.constructor.navigate.choose.class.title=Seleccionar el Bean que contiene el constructor
spring.bean.constructor.tooltip.navigate.declaration=Navegar al bean de Spring
spring.bean.dependencies.chooser.title=Seleccionar Bean
spring.bean.duplicate.bean.name=Nombre de Bean duplicado
spring.bean.duplicated.bean.name.inspection=Nombres de bean duplicados en el contexto de la aplicación basado en XML
spring.bean.filter.tooltip=Comience a escribir para filtrar elementos
spring.bean.idref.attributes.inconsistency=La etiqueta <idref> solo puede contener el atributo "bean" o el atributo "local"
spring.bean.idref.attributes.must.specify=La etiqueta <idref> debe especificar un bean
spring.bean.instantiation.by.factory=Spring Bean (instanciado por un Factory Bean)
spring.bean.instantiation.inspection=Instanciación no válida de bean no abstracto
spring.bean.instantiation.using.factory.method=Spring Bean (instanciado mediante un método de fábrica estático)
spring.bean.lookup.method.bean.has.no.class=El bean ''{0}'' no tiene clase
spring.bean.lookup.method.constructor.not.allowed=No se permite un constructor aquí
spring.bean.lookup.method.incorrect.return.type=Tipo de retorno del método de búsqueda incorrecto
spring.bean.lookup.method.inspection=Configuración incorrecta del método lookup-method de bean XML
spring.bean.lookup.method.must.be.not.static=No se permite un método estático aquí
spring.bean.lookup.method.must.be.public.or.protected=El método debe ser public o protected
spring.bean.lookup.method.must.have.no.parameters=El método no debe tener parámetros
spring.bean.lookup.method.return.type.mismatch=El tipo de retorno del método lookup no coincide con la clase bean ''{0}''
spring.bean.map.entry=Entrada de mapa
spring.bean.method.tooltip.navigate.declaration=Navegar a la declaración del método del bean de Spring {0}
spring.bean.methods.tooltip.navigate.declaration=Navegar a las declaraciones de los métodos de bean de Spring
spring.bean.properties.chooser.title=Seleccionar propiedades
spring.bean.property=Propiedad
spring.bean.property.navigate.choose.class.title=Seleccionar el bean que contiene la propiedad
spring.bean.property.tooltip.navigate.declaration=Navegar a la propiedad del bean de Spring
spring.bean.property.value.inconsistency.key=La entrada de mapa solo puede contener el atributo "key" O el atributo "key-ref" O el subelemento <key>
spring.bean.property.value.inconsistency.more.one.sub.element={0} no debe contener más de un subelemento
spring.bean.property.value.inconsistency.ref.or.value.sub.element.must.defined={0} solo puede contener el atributo "ref", el atributo "value" o un subelemento
spring.bean.ref.attributes.inconsistency=La etiqueta <ref> solo puede contener el atributo "bean", el atributo "local" o el atributo "parent"
spring.bean.ref.attributes.must.specify=La etiqueta <ref> debe especificar un bean
spring.bean.referenced.by.abstract.bean=No se puede utilizar un bean abstracto aquí
spring.bean.show.beans.candidates.title=Candidatos de bean
spring.bean.use.autowire=Dependencia autowired innecesaria
spring.beans=Beans producidos
spring.beans.chooser.all.context.files=Todos los beans
spring.beans.chooser.show.context.files=Mostrar archivos de contexto
spring.cacheable.and.cache.put.on.the.same.method.display.name=Uso incorrecto de @CachePut y @Cacheable en el mismo método
spring.cacheable.annotations.inspection.display.name=Anotación 'caching' configurada incorrectamente
spring.cacheable.annotations.on.interfaces=Anotaciones Cache* definidas en interfaces/métodos de interfaz
spring.cacheable.element.choose.title=Seleccionar operación cacheable
spring.cacheable.element.tooltip.text=Ir a la operación almacenable en caché con el mismo nombre
spring.cacheable.method.calls.inspection.display.name=Llamadas de autoinvocación a métodos @Cacheable
spring.cacheable.names.inspection.display.name=Definición incorrecta de nombres de caché requeridos
spring.cacheable.self.method.calls=Autoinvocación de @Cacheable (en la práctica, un método dentro del objeto de destino que llama a otro método del mismo objeto). La anotación de caché se ignorará en tiempo de ejecución.
spring.choose.bean.templates.dialog.beans=Beans
spring.choose.bean.templates.dialog.title=Añadir {0} Beans
spring.component.container.current.file=Archivo actual
spring.component.container.custom.package=Paquete personalizado…
spring.component.container.custom.package.dialog.package=Paquete:
spring.component.container.custom.package.dialog.select.package=Seleccionar paquete
spring.component.container.custom.package.dialog.source.root=Raíz de fuentes:
spring.component.container.custom.package.dialog.title=Seleccionar raíz de fuentes y paquete
spring.component.template.application=Aplicación
spring.component.template.bean=Bean
spring.component.template.boot.test=Prueba de Spring Boot
spring.component.template.component=Componente
spring.component.template.configuration=Configuración
spring.component.template.configuration.properties=Propiedades de configuración
spring.component.template.service=Servicio
spring.configurable.create.bean.tab.title=Para aceptar la sugerencia, presione Tab.
spring.configuration.check=Comprobación de la configuración de Spring
spring.configuration.proxy.methods.display.name=Advertencias de uso de @Configuration proxyMethods
spring.context.configuration.inspection.display.name=@ContextConfiguration inválida
spring.core.autowired.annotator.name=Autocableado
spring.core.bean.annotator.name=Bean
spring.core.cacheable.annotator.name=Operaciones cacheables con los mismos nombres
spring.core.component.scan.annotator.name=Escaneo de componentes
spring.core.dom.annotator.name=Configuración (XML)
spring.core.event.listener.annotator.name=Eventos de aplicación
spring.core.properties.annotator.name=Propiedades
spring.core.test.configuration.annotator.name=Configuración de prueba
spring.core.testing.annotator.navigate.to.overridden=Navegar a los beans sobrescritos
spring.core.testing.annotator.navigate.to.overriden=Navegar a beans reemplazados
spring.core.testing.inject.annotator.name=Prueba de beans
spring.create.bean.command.text=Crear y autovincular nuevo {0}
spring.create.bean.dependency.default.name=Componente Spring
spring.create.bean.dependency.fix.family.name=Crear un nuevo bean
spring.create.bean.dependency.fix.text=Crear y autoconectar nuevo {1} ''{0}''
spring.depends.on.inspection.display.name=Bean referenciado incorrectamente en la anotación @DependsOn
spring.dom.component.scan.stereotypes=Seleccionar estereotipo
spring.dom.component.scan.stereotypes.title=Navegar a componentes
spring.event.listener.choose.title=Seleccionar oyente de eventos
spring.event.listener.empty.tooltip.text=No se encontraron escuchadores de eventos
spring.event.listener.tooltip.text=Ir al escuchador de eventos
spring.event.publisher.choose.title=Seleccionar publicador de eventos
spring.event.publisher.empty.tooltip.text=No se encontraron publicadores de eventos
spring.event.publisher.tooltip.text=Ir al publicador de eventos
spring.facet.config.detection=Detección de configuración de Spring
spring.facet.detection.disable.detection=Desactivar detección
spring.facet.detection.will.be.disabled.for.whole.project=Se desactivará la detección para todo el proyecto.\nTenga en cuenta que la mayoría de las funciones relacionadas con Spring no funcionarán si no se realiza la configuración del facet de Spring.\n\nEstructura del proyecto | Facets | Detección\npuede utilizarse para excluir solo archivos o carpetas específicos y volver a habilitarla.
spring.facet.validation.disable.action=Deshabilitar…
spring.facet.validation.help.action=Mostrar ayuda
spring.factories.file.type=Factorías de Spring
spring.generate.constructor.dependencies=Dependencias de constructor…
spring.generate.properties=Propiedades…
spring.generate.setter.dependencies=Dependencia de setter…
spring.import.resource.error.message.trailing.space=Espacio al final en ''{0}''
spring.import.resource.inspection.display.name=Referencias de archivo no resueltas en ubicaciones @ImportResource
spring.incorrect.resource.type.inspection=Tipo de recurso incorrecto
spring.injection.autowiring.code.style=Estilo de código de autowiring
spring.injection.default.beans.inject.strategy=Estrategia de inyector de beans predeterminada:
spring.injection.group.libraries=Bibliotecas
spring.injection.group.project=Proyecto
spring.injection.group.repository=Repositorio
spring.injection.group.service=Servicio
spring.injection.injectToBeanMethodSignature=Usar inyección de parámetros de método para métodos @Bean
spring.injection.variants.collection=Colección
spring.injection.variants.default=Predeterminado
spring.injection.variants.primary=Primario
spring.injection.variants.qualifier={0}
spring.intention.category=Spring
spring.lookup.inspection.display.name=Bean referenciado incorrectamente en la anotación @Lookup de un componente Spring
spring.model.actions.dump.model.gathering.spring.models=Recopilando modelos de Spring…
spring.model.actions.dump.model.generating.json=Generando JSON…
spring.model.actions.dump.model.scanning.spring.models=Escaneando modelos Spring…
spring.model.actions.generate.beans=Crear Spring Bean
spring.parent.bean.tooltip=Navegar a las declaraciones secundarias
spring.profile=Perfil
spring.profile.expression.empty=La expresión de perfil debe contener texto
spring.profile.expression.inspection=Expresión @Profile configurada incorrectamente
spring.profile.expression.malformed=Expresión de perfil mal formada
spring.profile.unresolved.message=Perfil desconocido
spring.property.source.inspection.display.name=Referencias a archivos sin resolver en ubicaciones @PropertySource y @TestPropertySource
spring.required.property.inspection=Faltan inyecciones de propiedades @Required en la declaración de beans XML de Spring
spring.scheduled.inspection.display.name=Bean referenciado incorrectamente en la anotación @Scheduled
spring.scheduled.method=Ejecutar el método @Scheduled
spring.scheduled.tasks=Tareas programadas
spring.scope=Ámbito
spring.settings.configuration.completion=Completado
spring.settings.configuration.file.editor=Editor de archivos de configuración
spring.settings.multiple.context.panel=Mostrar panel de &múltiples contextos
spring.settings.multiple.context.panel.tooltip=Permitir elegir el contexto activo si un archivo se utiliza en varios contextos
spring.settings.profiles.panel=Mostrar el panel de &perfiles
spring.settings.profiles.panel.tooltip=Permitir elegir perfil(es) activo(s)
spring.settings.smartCompletionAvailability=Completado inteligente de beans
spring.stereotype.bean=Bean
spring.stereotype.component=Componente
spring.stereotype.configuration=Configuración
spring.stereotype.service=Servicio
spring.template.context.type=Spring
spring.test.override.bean.resolve.inspection.cannot.find.factory.method=No se puede encontrar el método de fábrica estático
spring.test.override.bean.resolve.inspection.display.name=Bean referenciado incorrectamente en las anotaciones @MockitoBean, @MockitoSpyBean y @TestBean
spring.testing.context.dirties.inspection.display.name=Configuración de 'mode' de @DirtiesContext no válida
spring.testing.model.dirties.class.mode.error.message=Establecer el modo de clase en un método de prueba anotado no tiene sentido. Para el control a nivel de método, use methodMode en su lugar.
spring.testing.model.dirties.hierarchy.mode.error.message=Se requiere hierarchyMode cuando el contexto se configura como parte de la jerarquía mediante @ContextHierarchy
spring.testing.model.dirties.method.mode.error.message=Configurar el modo de método en una clase de prueba anotada no tiene sentido. Para el control a nivel de clase, use classMode en su lugar.
spring.testing.sql.inspection.display.name=Configuraciones @Sql y @SqlGroup no válidas
spring.testing.transactional.inspection.display.name=Declaración de método de ciclo de vida transaccional no válida
spring.testing.transactional.void.method.return.type.error.message=El tipo de retorno del método esperado es 'void'
spring.testing.transactional.wrong.number.of.arguments.error.message=Número de argumentos incorrecto
spring.transaction.inspection.display.name=Declaración de 'PlatformTransactionManager' no válida en el componente @Transactional
spring.transactional.method.calls.inspection.display.name=Llamadas a métodos de autoinvocación @Transactional
spring.transactional.self.method.calls=La autollamada @Transactional (en efecto, un método dentro del objeto de destino que llama a otro método del mismo objeto) no genera una transacción real en tiempo de ejecución
static.members.autowiring=No autocablear miembros estáticos
timeout.parsing.bean=El análisis del bean personalizado tardó demasiado tiempo
try.parsing.custom.beans=Intentar analizar beans personalizados
unmapped.configuration.autodetected.context.found.for=Se ha encontrado un contexto detectado automáticamente para {0}.\nCompruebe y configure el contexto manual adicional (si es necesario).
unmapped.configuration.configure.facet=Por favor, configure la faceta de Spring.
unmapped.configuration.create.default.context=Crear contexto predeterminado
unmapped.configuration.files.count={0, choice, 1#1 archivo|1<{0, number} archivos}
unmapped.configuration.files.found=Se han encontrado archivos de configuración de Spring sin mapear.
unmapped.configuration.files.full={0, choice, 1#Archivo de configuración de Spring no asignado|1<{0, number} archivos de configuración de Spring no asignados}:<br/>{1}
unmapped.configuration.files.not.found=No se encontraron archivos de configuración de Spring no mapeados.
unmapped.configuration.files.short={0, choice, 1#Archivo de configuración de Spring no mapeado|1<{0, number} archivos de configuración de Spring no mapeados}
unmapped.configuration.fix.instruction=Por favor, configure el facet de Spring o utilice ''{0}'' para añadir uno que incluya todos los archivos no mapeados.
unmapped.configuration.is.not.available.during.index.update=''{0}'' no está disponible, analizando el proyecto…
unmapped.configuration.open.facet.configuration=Abrir la configuración de facetas
unmapped.configuration.spring.configuration=Configuración de Spring
unparsed.custom.bean.inspection=Beans de Spring personalizados no analizados
unparsed.custom.bean.message=Este bean de Spring personalizado aún no se ha analizado
update.schema.intention=Convertir a esquema XML de Spring
use.existing.quick.fixes.add.dependency.to.context=Añadir dependencia al contexto ''{0}''
use.existing.quick.fixes.add.import.action=Añadir <import> para ''{0}''
use.existing.quick.fixes.add.spring.xml.to.fileset.action=Añadir ''{0}'' al contexto ''{1}''
use.existing.quick.fixes.choose.fix.for=Seleccionar corrección para ''{0}''
use.existing.quick.fixes.open.spring.facet.settings=Abrir la configuración de facetas de Spring…
use.existing.quick.fixes.use.existing.bean.family.name=Usar bean existente
use.existing.quick.fixes.use.existing.bean.from.context=Usar bean existente del contexto ''{0}''…
use.p.namespace=Convertir a p-namespace
util.required.class.message=La clase debe ser heredera de ''{0}''
util.schema.inspection.name=Beans del esquema 'util' configurados incorrectamente definidos en el contexto de aplicación XML
xml.schema.update.is.required=Se requiere la actualización del esquema XML
xml.schema.will.be.updated=El esquema XML se actualizará a spring-beans.xsd. \n¿Desea continuar?
