0.already.contains.field.1={0} ya contiene el campo {1}
0.already.contains.inner.class.named.1={0} ya contiene una clase interna llamada {1}
0.is.not.initialized.in.declaration.such.fields.are.not.allowed.in.interfaces={0} no se ha inicializado en la declaración. No se permiten tales campos en las interfaces.
0.is.not.static.it.cannot.be.moved.to.the.interface={0} no es estático. No se puede mover a la interfaz.
accessible.name.icon.bookmark.0=icono: marcador {0}
action.DeleteBookmarkAction.delete.text=Eliminar
action.bookmark.delete=Eliminar marcador
action.bookmark.edit.description=Editar descripción
action.bookmark.edit.description.description=Asigne una descripción corta al marcador para que se muestre junto con el nombre del archivo
action.bookmark.edit.description.dialog.message=Introduzca una breve descripción del marcador
action.bookmark.edit.description.dialog.title=Descripción del marcador
action.bookmark.move.down=Mover marcador hacia abajo
action.bookmark.move.up=Mover marcador hacia arriba
action.bookmark.toggle=Alternar marcador(_B)
action.bookmark.toggle.mnemonic=Alternar marcador con mnemónico
action.bookmark.toggle.sort=Ordenar marcadores por mnemónico, archivo y línea
action.clear.bookmark.text=Borrar marcador
action.close=Cerrar
action.create.new.class=Nueva clase Java
action.delete.current.bookmark.description=Eliminar el marcador actual
action.presentation.ToggleBookmarkWithMnemonicAction.text=Establecer marcador con mnemónico
action.rerun=Volver a ejecutar
action.set.bookmark.text=Establecer marcador
action.sort.alphabetically=Ordenar alfabéticamente
action.structureview.group.methods.by.defining.type=Agrupar métodos por tipo de definición
action.structureview.show.fields=Mostrar campos
action.structureview.show.inherited=Mostrar heredados
action.structureview.show.non.public=Mostrar no públicos
action.structureview.sort.by.visibility=Ordenar por visibilidad
action.synchronize.file=Sincronizar ''{0}''
action.synchronize.selected.files=Sincronizar archivos seleccionados
alphabetical.mode.is.on.warning=El orden alfabético de las pestañas está activado. ¿Desea desactivarlo?
analyze.and.replace.usages=Analizar y reemplazar usos
anonymous.class.text=Clase anónima
bookmark.file.X.line.Y={0}, línea {1}
button.add.blank=Añadir en blanco
button.edit=&Editar…
button.reset=&Restablecer
cannot.introduce.variable.in.super.constructor.call=No se puede extraer la variable en una llamada al constructor super
change.color.command.text=Cambiar color
changeSignature.no.return.type=No se ha especificado el tipo de retorno
changeSignature.no.type.for.parameter=Especifique el tipo {0} para el parámetro ''{1}''
changeSignature.wrong.return.type=Tipo de retorno incorrecto: ''{0}''
changeSignature.wrong.type.for.parameter=Tipo incorrecto: ''{0}'' para el parámetro ''{1}''
checkbox.after.description=Después de la descripción
checkbox.after.parameter.descriptions=Después de las descripciones de los parámetros
checkbox.after.return.tag=Después de la etiqueta de retorno
checkbox.collapse.generic.constructor.parameters=Parámetros genéricos de constructores y métodos
checkbox.collapse.inner.classes=Clases internas
checkbox.collapse.simple.property.accessors=Accesores de propiedades simples
checkbox.enable.leading.asterisks=Habilitar asteriscos iniciales
checkbox.include.non.project.files=Incluir archivos &ajenos al &&{0}
checkbox.remember.password=&Recordar
class.0.already.exists=La clase {0} ya existe
class.0.not.found=Clase {0} no encontrada.
class.has.been.successfully.created=La clase {0} se ha creado correctamente
class.is.subclassed.by.header=Es heredada por<br>
command.create.new.subdirectory=Crear nuevo subdirectorio
command.find.next=Buscar siguiente
command.name.surround.with.runtime.cast=Rodear con cast en tiempo de ejecución
configuration.action.chooser.title=Seleccionar configuración para ejecutar
copy.class.copy.0.1=Copiar {0} {1}
copy.handler.copy.class=Copiar clase
coverage.button.add.package=Añadir paquete
coverage.pattern.filter.editor.choose.package.title=Seleccionar paquete
current.class=clase actual
declare.static.checkbox=Declarar &estático
declare.static.pass.fields.checkbox=Declarar &estático (pasar campos como parámetros)
default.junit.config.name.all.in.module=Todo en {0}
default.package.presentable.name=<predeterminado>
default.visibility.border.title=Visibilidad predeterminada
description.select.project.file.directory=El archivo {0} se guardará en este directorio
destination.package=&Paquete de destino:
dialog.action.restart.cancel=Cancelar
dialog.action.restart.yes=Reiniciar
dialog.create.class.destination.package.label=Paquete de destino:
dialog.create.class.label=Crear {0}:
dialog.create.class.name=Crear {0} {1}
dialog.create.class.package.chooser.title=Seleccionar paquete de destino
dialog.import.on.paste.title=Seleccionar clases para importar
dialog.import.on.paste.title2=Seleccionar elementos para importar
dialog.options.do.not.ask=&Recordar, no volver a preguntar
dialog.options.do.not.show=No volver a mostrar este diálogo en el futuro
dialog.paste.on.import.text=<html>El fragmento de código que ha pegado utiliza clases que no son accesibles mediante importaciones en el nuevo contexto.<br/>Seleccione las clases que desea importar al nuevo archivo.</html>
dialog.paste.on.import.text2=<html>El fragmento de código que ha pegado utiliza elementos que no son accesibles mediante importaciones en el nuevo contexto.<br/>Seleccione los elementos que desea importar al nuevo archivo.</html>
dialog.title.cannot.open.file=No se puede abrir el archivo
directory.project.file.directory=El directorio {0}\n
edit.custom.settings.confirm=El archivo \n''{0}''\n no existe. ¿Desea crearlo?
edit.custom.settings.failed=No se puede escribir en el archivo ''{0}'': {1}
edit.migration.entry.title=Editar descripción de migración de clase/paquete
edit.migration.map.title=Editar mapa de migración
entity.name.inheritor=Heredero
entity.name.variable=Variable
error.cannot.resolve.default.message=No se puede resolver el símbolo ''{0}''
error.connection.failed.redirects=Error de conexión: demasiadas redirecciones
exception.directory.can.not.create=No se puede crear el directorio {0}
extract.subclass.command=Extraer subclase
extractSuper.rename.original.class.to=&Renombrar clase original a:
extractSuperInterface.javadoc=JavaDoc
factory.method.name.label=Nombre del método de fábrica:
file.location.should.be.absolute=La ruta de ubicación {0} debe ser absoluta
file.structure.toggle.show.inherited=Miembros heredados
filetype.description.xml=XML
functional.interface.broken=La expresión funcional requiere que la interfaz funcional tenga exactamente un método
generate.constructor.super.constructor.chooser.title=Elegir constructor de la superclase
generate.equals.and.hashcode.already.defined.title=Generar equals() y hashCode()
generate.equals.and.hashcode.already.defined.warning=Los métodos ''boolean equals(Object)'' e ''int hashCode()'' ya están definidos\npara la clase {0}. ¿Desea eliminarlos y continuar?
generate.equals.and.hashcode.already.defined.warning.anonymous=Los métodos 'boolean equals(Object)' e 'int hashCode()' ya están definidos\npara esta clase anónima. ¿Desea eliminarlos y continuar?
generate.equals.hashcode.accept.sublcasses=Aceptar &subclases como parámetro del método equals()
generate.equals.hashcode.accept.sublcasses.explanation=<html><body>Aunque generalmente no cumple con la especificación de Object.equals(), aceptar<br>subclases puede ser necesario para que el método generado funcione correctamente<br>con frameworks que generan subclases Proxy como Hibernate.</body></html>
generate.equals.hashcode.equals.fields.chooser.title=Seleccionar &campos para incluir en equals()
generate.equals.hashcode.hashcode.fields.chooser.title=Seleccionar los &campos que se incluirán en hashCode()
generate.equals.hashcode.internal.error=Error interno
generate.equals.hashcode.template=&Plantilla:
generate.equals.hashcode.warning.hashcode.for.arrays.is.not.supported=No se admite hashCode () para arreglos
generate.equals.hashcode.wizard.title=Generar equals() y hashCode()
generate.equals.warning.equals.for.nested.arrays.not.supported=No se admite equals() para arrays anidados
generate.equals.warning.generated.equals.could.be.incorrect=El equals() generado para Object[] puede ser incorrecto
generate.getter.template=Plantilla de &getter:
generate.setter.template=Plantilla del &setter:
go.to.file.toolwindow.title=Archivos que coinciden con el patrón
goto.super.class.chooser.title=Seleccionar superclase o interfaz
inner.class.0.is.already.defined.in.class.1=La clase interna {0} ya está definida en la clase {1}.\n¿Continuar de todos modos?
inner.class.exists=La clase interna llamada ''{0}'' ya está definida\nen la clase ''{1}''
inspection.invalid.resource.bundle.reference=Referencia de paquete de recursos no válida ''{0}''
inspection.unresolved.property.key.reference.message=El literal de cadena ''{0}'' no parece ser una clave de propiedad válida
inspection.unresolved.property.key.reference.name=Clave de propiedad no válida
instantiating.tests.progress.text=Instanciando pruebas…
intention.add.annotation.family=Añadir anotación
intention.create.test.dialog.class.name=Nombre de la clase:
intention.create.test.dialog.java=Java
intention.create.test.dialog.select.methods=Generar &métodos de prueba para:
intention.error.cannot.create.class.message=No se puede crear la clase ''{0}''
intention.error.cannot.create.class.title=Error al crear la clase
intention.implement.abstract.method.command.name=Implementar método
intention.implement.abstract.method.searching.for.descendants.progress=Buscando descendientes…
intention.introduce.variable.text=Introducir variable local
interface.0.does.not.have.inheritors=La interfaz {0} no tiene herederos
interface.has.been.successfully.created=La interfaz {0} se ha creado correctamente
interface.is.implemented.by.header=Implementada por<br>
interface.is.implemented.too.many=Tiene implementaciones
interface.member.dependency.required.by.interfaces=requerido por {0,choice,1#interfaz|2#interfaces}
invalid.target.package.name.specified=Se ha especificado un nombre de paquete de destino no válido
invocations.to.be.inlined=Invocaciones para integrar en línea {0}
java.terms.class=clase
java.terms.constructor=constructor
java.terms.enum=enumeración
java.terms.exception=excepción
java.terms.field=campo
java.terms.interface=interfaz
java.terms.method=método
java.terms.of.class={0} de la clase {1}
java.terms.of.enum={0} del enum {1}
java.terms.of.interface={0} de la interfaz {1}
java.terms.package=paquete
java.terms.parameter=parámetro
java.terms.variable=variable
java.terms.variable.of.method={0} de {1}
javadoc.candidates.not.found=<html>No se encontraron candidatos para la llamada al método <b>{0}</b>.</html>
javadoc.constructor.candidates=<html>Los candidatos para el nuevo <b>{0}</b>() son:<br>{1}</html>
javadoc.documentation.not.found.message=No se encontró la documentación para este elemento.\nPor favor, añada todas las rutas necesarias a la documentación de la API en la Configuración del proyecto.
javadoc.documentation.not.found.title=Documentación no encontrada
javadoc.for.abstracts=JavaDoc para abstractos
javadoc.info.title=Documentación de {0}
junit.all.tests.passed.label=Todas las pruebas superadas
junit.runing.info.tests.in.progress.done.tree.node=Pruebas en curso: Finalizadas
junit.runing.info.tests.in.progress.terminated.tre.node=Pruebas en curso: Terminadas
junit.runing.info.time.sec.message={0} s
junit.running.info.status.completed.from.total={0} de {1}
junit.running.info.status.completed.from.total.failed={0} de {1}    Fallos: {2}
junit.running.info.status.done.count=Finalizado: {0}
junit.running.info.status.running.number.with.name=Ejecutando: {0}      {1}
junit.running.info.status.terminated.count=Terminados: {0}
junit.tests.in.progress.label=Pruebas en curso
label.missed.libraries.text=No se encontró la biblioteca ''{0}'' en la lista de dependencias del módulo
label.no.matches.found.in.project=No se encontraron coincidencias en {0}
label.project.jdk=SDK del proyecto:
library.attach.sources.action=Adjuntar fuentes
library.attach.sources.action.busy.text=Adjuntando…
library.attach.sources.description=Seleccione archivos JAR/ZIP o directorios en los que se encuentran las fuentes de la biblioteca
library.java.attach.files.description=Seleccione archivos o directorios en los que se encuentran las clases, fuentes, documentación o bibliotecas nativas de la biblioteca
library.sources.node=Fuentes
listbox.import.all.other.imports=<todas las demás importaciones>
livetemplate.description.geti=Inserta el método singleton getInstance
livetemplate.description.if.not.null=Inserta la sentencia 'if not null'
livetemplate.description.if.null=Inserta la sentencia 'if null'
livetemplate.description.inst=Comprueba el tipo de objeto con instanceof y realiza un casting descendente
livetemplate.description.iop=Imprime una cadena mediante el paquete IO
livetemplate.description.ior=Lee una cadena utilizando el paquete IO
livetemplate.description.itar=Iterar elementos de un array
livetemplate.description.itco=Iterar elementos de java.util.Collection
livetemplate.description.iten=Iterar java.util.Enumeration
livetemplate.description.iter=Iterar sobre un Iterable o un array
livetemplate.description.itit=Iterar java.util.Iterator
livetemplate.description.itli=Iterar los elementos de java.util.List
livetemplate.description.itm=Iterar las claves y los valores de java.util.Map
livetemplate.description.ittok=Iterar tokens de String
livetemplate.description.lazy=Realiza la inicialización diferida
livetemplate.description.lst=Obtiene el último elemento de un array
livetemplate.description.mn=Asigna el valor menor a una variable
livetemplate.description.mx=Asigna el valor mayor a una variable
livetemplate.description.prsf=privado estático final
livetemplate.description.psf=público estático final
livetemplate.description.psfi=public static final int
livetemplate.description.psfs=public static final String
livetemplate.description.psvm=Declaración del método main()
livetemplate.description.ritar=Iterar los elementos de un array en orden inverso
livetemplate.description.serr=Imprime una cadena en System.err
livetemplate.description.short.psvm=void main()
livetemplate.description.short.psvma=void main(String[] args)
livetemplate.description.short.static.psvm=static void main()
livetemplate.description.short.static.psvma=static void main(String[] args)
livetemplate.description.souf=Imprime una cadena con formato en System.out
livetemplate.description.sout=Imprime una cadena en System.out
livetemplate.description.soutm=Imprime los nombres de la clase y el método actuales en System.out
livetemplate.description.soutp=Imprime los nombres y valores de los parámetros del método en System.out
livetemplate.description.soutv=Imprime un valor en System.out
livetemplate.description.st=String
livetemplate.description.surround.with.callable=Envolver con Callable
livetemplate.description.surround.with.read.lock=Envolver con ReadWriteLock.readLock
livetemplate.description.surround.with.write.lock=Envolver con ReadWriteLock.writeLock
livetemplate.description.thr=lanzar nueva
livetemplate.description.toar=Almacena elementos de java.util.Collection en un array
macro.classname=className()
macro.component.type.of.array=tipoDeComponenteDe(Array)
macro.current.package=paqueteActual()
macro.expression.type=tipoDeExpresión(Expresión)
macro.iterable.component.type=tipoComponenteIterable(ArrayOIterable)
macro.method.parameters=parámetrosDelMétodo()
macro.methodname=nombreDelMétodo()
macro.qualified.class.name=qualifiedClassName()
macro.suggest.variable.name=sugerirNombreDeVariable()
maven.repository.presentable.name=Repositorio Maven
message.files={0,choice, 0# archivos|1# archivo|2# archivos}
message.matches={0,choice, 0# coincidencias|1# coincidencia|2# coincidencias}
message.open.file.is.project={0} es un archivo de proyecto.\n¿Desea abrir el proyecto?
message.open.file.is.project.open.as.file=Abrir como &archivo
message.open.file.is.project.open.as.project=Abrir como &proyecto
message.this.action.isn.t.supported.on.the.current.platform=Esta acción no es compatible con la plataforma actual
migration.class=Clase
migration.entry.class=Clase
migration.entry.new.name=Nuevo nombre:
migration.entry.old.name=Nombre anterior:
migration.map.description.label=Descripción del mapa:
migration.map.name.prompt=Nombre del mapa:
migration.new.name.column.header=Nuevo nombre
migration.no.usages.found.in.the.project=No se encontraron usos en el proyecto
migration.old.name.column.header=Nombre anterior
migration.title=Migración
migration.type.column.header=Tipo
module.libraries.attach.sources.button=&Adjuntar fuentes…
module.paths.exclude.output.checkbox=Excluir rutas de salida
module.paths.output.label=Ruta de salida:
module.paths.output.title=Seleccionar ruta de salida
module.paths.test.output.label=Ruta de salida de pruebas:
module.paths.test.output.title=Seleccionar ruta de salida de pruebas
module.sdk.not.defined=SDK del módulo no definido
no.class.name.specified=No se ha especificado el nombre de la clase
no.parameter.name.specified=No se ha especificado el nombre del parámetro
no.test.class.specified.error.text=No se ha especificado ninguna clase de prueba
node.call.hierarchy.unknown.jsp=jsp desconocido
occurences.string=({0,choice,1#1 ocurrencia|2#{0,number} ocurrencias})
output.tab.title=Salida
override.implement.broken.file.template.message=Por favor, corrija la plantilla "Cuerpo del método sobrescrito/implementado"
override.implement.broken.file.template.title=Error de plantilla de archivo
package.does.not.exist.error.message=El paquete ''{0}'' no existe
popup.title.bookmark.mnemonic=Mnemónico del marcador
popup.title.bookmarks=Marcadores
press.the.do.migrate.button=Presione el botón "Do Migrate" en la parte inferior del panel de resultados de búsqueda\npara migrar utilizando el mapa de migración "{0}"\n
process.duplicates.title=Procesar duplicados
process.methods.duplicates.title=Duplicado del método de proceso {2} ({0} de {1})
progress.creating.class=Creando la clase {0}
project.import.default.name=ImportadoDe{0}
project.import.default.name.dotIdea=Importado desde {0}
project.import.open.existing=Hay {0} en ''{1}''.\n¿Desea abrir el proyecto existente o eliminarlo e importar ''{2}''?
project.import.open.existing.openExisting=Abrir proyecto existente
project.import.open.existing.reimport=Eliminar proyecto existente e importar
project.inherit.compile.output.path=Heredar la ruta de salida de compilación del proyecto
project.module.compile.output.path=Usar la ruta de salida de compilación del módulo
project.new.wizard.module.identification=módulo
project.new.wizard.project.identification=proyecto
project.roots.no.jdk.on.project.message=¿Configurar el SDK creado en el proyecto?
project.roots.no.jdk.on.project.title=Crear SDK
project.roots.output.compiler.title=Salida del compilador
project.roots.path.tab.title=Rutas
project.sdk.not.defined=El SDK del proyecto no está definido
prompt.enter.new.class.name=Introduzca un nuevo nombre de clase:
prompt.enter.project.file.location=Introduzca la ubicación del archivo {0}
prompt.new.project.file.name=Introduzca un nombre de archivo para crear un nuevo {0} {1}
prompt.overwrite.project.file=El archivo {1} \n''{0}''\nya existe.\n¿Desea sobrescribirlo?
prompt.overwrite.settings.file=¿Sobrescribir ''{0}''?
property.has.more.parameters.than.passed=La propiedad ''{0}'' esperaba {1} {1, choice, 1#parámetro|2#parámetros}, se pasaron {2}
quickdoc.tooltip.font.size.by.wheel=El deslizador o Ctrl+Rueda cambian el tamaño de la fuente
refactoring.is.not.supported.in.the.current.context=La refactorización {0} no está soportada en el contexto actual
references.in.code.to.elements.from.migration.map=Referencias en el código a elementos del mapa de migración "{0}" {1}
reformat.and.optimize.progress.common.text=Preparando importaciones…
rename.inheritors.with.the.following.names.to=Renombrar herederos con los siguientes nombres a:
rename.overloads=Renombrar &sobrecargas
rename.variables=Renombrar &variables
rename.variables.title=Renombrar variables
rename.variables.with.the.following.names.to=Renombrar variables con los siguientes nombres a:
replace.constructor.with.factory.target.fq.name=En (nombre cualificado completo):
run.configuration.error.executable.not.specified=No se ha especificado el ejecutable
run.configuration.error.working.directory.does.not.exist=No se puede iniciar el proceso, el directorio de trabajo ''{0}'' no existe
run.configuration.error.working.directory.not.directory=No se puede iniciar el proceso, el directorio de trabajo ''{0}'' no es un directorio
sdk.configure.classpath.tab=Classpath
sdk.configure.editor.title=Editor de SDK
sdk.configure.sourcepath.tab=Ruta de fuentes
search.popup.search.for.label=Buscar:
selected.block.contains.invocation.of.another.class.constructor=El bloque seleccionado contiene la invocación del constructor de otra clase
starting.jvm.progress.text=Iniciando JVM…
status.text.no.bookmarks=No hay marcadores
superclass.cannot.be.extracted.from.an.enum=No se puede extraer la superclase de una enumeración
surround.with.try.catch.finally.template=try / catch / finally
surround.with.try.catch.template=try / catch
terms.file=archivo
terms.property=propiedad
there.are.multiple.output.values.for.the.selected.code.fragment=Hay múltiples valores de salida para el fragmento de código seleccionado:
title.new.class=Nueva clase
title.no.jdk.specified=SDK no especificado
tooltip.bookmarked=Marcado
use.super.references.prompt=En este punto {0} puede analizar los usos de {1} \ny reemplazarlos por usos de {2} donde sea posible.\n¿Desea continuar?
vfs.broken.link=Enlace roto