0.already.contains.field.1={0} ya contiene el campo {1}
0.already.contains.inner.class.named.1={0} ya contiene una clase interna llamada {1}
0.already.has.parameter.named.1.use.this.name.anyway={0} ya tiene un parámetro llamado ''{1}''.\n¿Usar este nombre de todos modos?
0.contains.call.with.null.argument.for.parameter.1={0} contiene una llamada con un argumento null para el parámetro {1}
0.implements.1={0} implementa {1}.
0.is.1.and.will.not.be.accessible.from.2.in.the.target.class={0} es {1} y no será accesible desde {2}.
0.is.a.part.of.method.hierarchy.do.you.want.to.delete.multiple.parameters={0} forma parte de la jerarquía de métodos. ¿Desea eliminar múltiples parámetros?
0.is.a.part.of.method.hierarchy.do.you.want.to.delete.multiple.type.parameters={0} es parte de la jerarquía de métodos. ¿Desea eliminar varios parámetros de tipo?
0.is.an.interface.method.implementation.will.be.added.to.all.directly.implementing.classes={0} es una interfaz. \nLa implementación del método se añadirá a todas las clases que la implementan directamente.\n ¿Continuar?
0.is.an.interface.that.has.no.implementing.classes={0} es una interfaz que no tiene clases de implementación
0.is.not.a.legal.java.identifier=''{0}'' no es un identificador Java válido
0.is.not.accessible.from.1.value.for.introduced.parameter.in.that.method.call.will.be.incorrect={0} no es accesible desde {1}. El valor del parámetro introducido en esa llamada al método será incorrecto.
0.is.not.initialized.in.declaration.such.fields.are.not.allowed.in.interfaces={0} no está inicializado en la declaración. Dichos campos no están permitidos en las interfaces.
0.is.not.static.it.cannot.be.moved.to.the.interface={0} no es estático. No se puede mover a la interfaz.
0.is.not.visible.to.members.of.1={0} no es visible para los miembros de {1}
0.is.used.for.writing.in.1={0} se utiliza para escribir en {1}
0.refactoring.is.supported.only.for.final.fields=La refactorización {0} solo es compatible con campos final
0.upcasts.an.instance.of.1.to.2={0} realiza una conversión ascendente de una instancia de {1} a {2}
0.uses.1.of.an.instance.of.a.2={0} usa {1} de una instancia de {2}
0.uses.1.which.needs.class.instance={0} utiliza {1}, que requiere una instancia de clase
0.uses.a.package.local.1={0} utiliza {1} con visibilidad de paquete
0.uses.non.static.1.which.is.not.passed.as.a.parameter={0} utiliza {1} no estático, que no se pasa como parámetro
0.will.be.inaccessible.from.1={0} será inaccesible desde {1}
0.will.become.inaccessible.from.1={0} dejará de ser accesible desde {1}
0.will.hide.renamed.1={0} ocultará {1} renombrado
0.will.no.longer.be.canonical.constructor=El constructor ya no será canónico
0.will.no.longer.be.record.component.accessor={0} ya no será el getter de {1}
0.will.no.longer.override.1={0} ya no sobrescribirá {1}
0.will.not.be.accessible.from.1.after.inlining={0} no será accesible desde {1} después del inlining
0.will.override.renamed.1={0} sobrescribirá a {1} renombrado
a.package.local.class.0.will.no.longer.be.accessible.from.1=La clase local al paquete {0} ya no será accesible desde {1}
accept.signature.change=Aceptar cambio de firma
add.object.as.a.parameter.to.constructors.with.name=Añadir el &objeto como parámetro a los constructores con el nombre:
add.parameters.for.fields=Agregar parámetros para &campos:
add.parameters.for.fields.to.constructors=Añadir parámetros de &campos a los constructores:
all.candidate.variables.have.types.not.in.project=Todas las variables candidatas (parámetros de método y campos de la clase contenedora) tienen tipos que no están en el proyecto
all.candidate.variables.have.unknown.types=Todas las variables candidatas (parámetros del método y campos de la clase contenedora) tienen tipos desconocidos
all.invocations.and.remove.the.method=Incorporar &todos los usos y eliminar el método
all.invocations.in.project=Inline de todos los usos en el proyecto(&A)
all.invocations.keep.the.method=Incorporar todos los usos y mant&ener el método
all.references.and.remove.super.class=Poner en línea &todas las referencias y eliminar la clase
all.references.and.remove.the.class=Inline &todas las referencias y eliminar la clase
all.references.and.remove.the.field=Incorporar tod&as las referencias y eliminar el campo
all.references.keep.field=Incorporar todos los usos y mant&ener el campo
all.these.directories.will.be.moved.and.all.references.to.0.will.be.changed=Todos estos directorios se moverán y todas las referencias a {0} \nse cambiarán.
analyze.and.replace.usages=Analizar y reemplazar usos
analyze.module.conflicts=Analizar conflictos de módulos…
annotate.field.as.nonnls.checkbox=Anotar &campo como @NonNls
anonymous.class.description=Clase anónima derivada de {0}
anonymous.class.text=Clase anónima
anonymous.to.inner.enum.constant.cannot.refactor.message=No se puede convertir la constante de enumeración en una clase interna
anonymousToInner.class.name.label.text=Nombre de la clase:
anonymousToInner.make.class.static.checkbox.text=Hacer la clase &static
anonymousToInner.no.inner.class.name=Se debe especificar el nombre de la clase
anonymousToInner.parameters.panel.border.title=Parámetros del constructor
anonymousToInner.refactoring.name=Convertir anónima en interna
auto.rename.module.dialog.description=Renombrar los módulos Java con los siguientes nombres a:
auto.rename.module.dialog.title=Renombrar módulos Java
auto.rename.module.entity=Módulo Java
automatic.overload.renamer.entity.name=Sobrecarga
automatic.parameter.renamer.entity.name=Parámetro
boolean.method.result=Resultado del método booleano
can.t.restore.context.for.method.extraction=No se puede restaurar el contexto para la extracción del método
cannot.find.or.create.destination.directory=No se puede encontrar o crear el directorio de destino
cannot.introduce.field.in.interface=No se permiten campos no constantes en una interfaz.
cannot.move=No se puede mover
cannot.move.inner.class.0.into.itself=No se puede mover la clase interna {0} a sí misma
cannot.move.package.into.itself=No se puede mover el paquete a sí mismo
caret.position.warning.message=El cursor debe estar situado sobre el tipo de campo, variable, método o parámetro de método a refactorizar
change.method.signature.action.name=Cambiar la firma del método
change.signature.default.value.missing.warning.message=Falta el valor predeterminado. Las llamadas al método contendrán espacios en blanco en lugar del nuevo valor del parámetro.
change.signature.use.any.checkbox=&Usar cualquier variable
changeClassSignature.Type.parameter.can.not.be.primitive=El parámetro de tipo no puede ser primitivo
changeClassSignature.already.contains.type.parameter='{0}'' ya contiene el parámetro de tipo ''{1}'
changeClassSignature.bad.value=Valor {0} incorrecto: ''{1}'' para el parámetro ''{2}''
changeClassSignature.class.label.text=Cambiar la firma de <code>{0}</code>.
changeClassSignature.no.type.parameters=La clase no puede tener parámetros de tipo
changeClassSignature.parameters.panel.border.title=Parámetros:
changeClassSignature.refactoring.name=Cambiar firma de la clase
changeSignature.bound.value.column=Valor vinculado
changeSignature.cannot.resolve.return.type=No se puede resolver el tipo de retorno ''{0}''.\n¿Desea continuar?
changeSignature.contract.converter.can.not.update.annotation=La anotación @Contract no se puede actualizar automáticamente: {0}
changeSignature.contract.converter.definition.error=Error en la definición del contrato: {0}
changeSignature.contract.converter.external.annotations=No se admite la actualización automática de anotaciones externas
changeSignature.contract.converter.inherited.annotation=La anotación se hereda del método base
changeSignature.contract.converter.invalid.clause=Cláusula de contrato no válida ''{0}''
changeSignature.contract.converter.invalid.return.reference=Referencia no válida en el valor de retorno: {0}
changeSignature.contract.converter.mutation.contract=La anotación contiene un contrato de mutación
changeSignature.contract.converter.parameter.removed=El parámetro ''{0}'' se ha eliminado, pero la cláusula de contrato ''{1}'' depende de él
changeSignature.contract.converter.return.parameter.removed=Se ha eliminado el parámetro ''{0}'', pero la cláusula de contrato ''{1}'' lo devuelve
changeSignature.default.value.column=Valor predeterminado
changeSignature.empty.callee.method.text=Aquí se mostrará el texto del método llamado
changeSignature.empty.caller.method.text=Aquí se mostrará el texto del método llamador con la llamada al método llamado resaltada
changeSignature.exception.caller.chooser=Seleccionar métodos para propagar nuevas excepciones
changeSignature.exceptions.panel.border.title=Excepciones
changeSignature.exceptions.wont.propagate=No se realizará la propagación recursiva de los cambios en las excepciones.
changeSignature.no.return.type=No se ha especificado el tipo de retorno
changeSignature.no.type.for.exception=Especificar el tipo de la excepción
changeSignature.no.type.for.parameter=Especifique el tipo {0} para el parámetro ''{1}''
changeSignature.not.throwable.type=Tipo incorrecto ''{0}'' para la excepción, debe extender java.lang.Throwable
changeSignature.processing.changes.title=Procesando cambios…
changeSignature.propagate.exceptions.title=Propagar e&xcepciones…
changeSignature.use.any.var=Usar cualquier variable.
changeSignature.validating.title=Validando…
changeSignature.vararg.not.last=El parámetro vararg debe ser el último en la firma del método
changeSignature.wrong.return.type=Tipo de retorno incorrecto: ''{0}''
changeSignature.wrong.type.for.exception=Tipo incorrecto: ''{0}'' para la excepción
changeSignature.wrong.type.for.parameter=Tipo incorrecto: ''{0}'' para el parámetro ''{1}''
checking.conflicts=Comprobando conflictos…
choose.the.ones.you.want.to.be.deleted=Selecciona los que deseas eliminar
class.0.already.exists=La clase {0} ya existe
class.0.is.not.accessible.from.target.1=La clase {0} no es accesible desde el destino {1}
class.0.not.found=No se encontró la clase {0}.
class.body.description=Cuerpo de clase de {0}
class.description={1, choice, 0#clase|1#clase local} {0}
class.does.not.exist.in.the.project=La clase no existe en el proyecto. ¿Desea crearla?
class.does.not.have.base.classes.or.interfaces=La clase {0} no tiene clases base ni interfaces
class.does.not.have.implicit.default.constructor=La clase {0} no tiene un constructor predeterminado implícito
class.has.been.successfully.created=La clase {0} se ha creado correctamente
class.initializer.description=Inicializador {0, choice, 0#estático|1#de instancia}
class.is.abstract={0} es abstracto.
class.is.anonymous.warning.message=No se puede realizar la refactorización porque las clases anónimas no pueden tener subclases.
class.is.final.warning.message=No se puede realizar la refactorización porque la clase es final
class.is.interface={0} es una interfaz.
class.is.never.used=La clase no se usa nunca
class.name.prompt=Nombre de la clase (&N):
collect.overloads=Recopilar sobrecargas…
comments.elements.header=Coincidencias encontradas en comentarios, cadenas y archivos que no son de código {0}
constructor.being.refactored.is.used.in.initializer.of.0=El constructor que se está refactorizando se utiliza en el inicializador de {0}. La fábrica no estática de la clase interna {1} no se puede utilizar en este contexto. El código resultante no compilará.
constructor.description=Constructor {0}
constructor.with.builder.new.setter.prefix.dialog.message=Nuevo prefijo de setter:
constructor.with.builder.parameters.to.pass.to.the.builder.title=Parámetros para pasar al Builder
constructor.with.builder.rename.setters.prefix.action.name=Renombrar prefijo de los setters
convert.anonymous.or.local.to.inner.fix.name=Convertir clase anónima o local en interna
convert.anonymous.to.inner.action.name=Convertir anónima en interna…
convert.anonymous.to.inner.fix.name=Convertir clase anónima en clase interna
convert.local.to.field.title=Convertir local a campo
convert.local.to.inner.action.name=Convertir local en interna…
convert.local.to.inner.fix.name=Convertir clase local en clase interna
convert.to.instance.method.title=Convertir a método de instancia
convert.to.record.accessor.more.accessible={0} es {1}. La conversión a un registro hará que el método de acceso implícito correspondiente sea {2}.
convert.to.record.ctor.more.accessible={0} es {1}. La conversión a un record hará que el constructor de record canónico implícito correspondiente sea {2}.
convert.to.record.title=Convertir a clase Record
convertToInstanceMethod.all.reference.type.parameters.are.not.in.project=No se encontró la clase de destino para el método de instancia: no se encontró ningún parámetro del método con un tipo que haga referencia a una clase del proyecto.
convertToInstanceMethod.all.reference.type.parameters.have.unknown.types=No se ha encontrado la clase de destino para el método de instancia: los tipos de los parámetros del método son desconocidos.
convertToInstanceMethod.method.is.not.static=El método {0} no es estático
convertToInstanceMethod.no.default.ctor=Además, la clase contenedora no tiene un constructor predeterminado.
convertToInstanceMethod.no.parameters.with.reference.type=No hay parámetros que tengan un tipo de referencia.
copy.class.clone.0.1=Clonar {0} {1}
copy.class.copy.0.1=Copiar {0} {1}
copy.handler.clone.class=Clonar clase
copy.handler.copy.class=Copiar clase
copy.handler.copy.class.with.dialog=Copiar clase…
copy.handler.copy.classes.with.dialog=Copiar clases…
current.class=Clase actual
dataflow.to.here.expand.progress=Expandiendo todos los nodos… {0}
dataflow.to.here.group.by.leaf.action.description=Determinar si null puede fluir hacia esta expresión
dataflow.to.here.group.by.leaf.action.text=Agrupar por nulabilidad de la expresión hoja{0, choice, 1#|2# (Análisis en curso)}
dataflow.to.here.variable.dereferenced.tooltip=Variable desreferenciada
declare.final=Declarar &final
declare.generated.annotations=&Generar anotaciones
declare.static.checkbox=Declarar &static
declare.static.pass.fields.checkbox=Declarar &static (pasar campos como parámetros)
declare.var.type=Declarar el tipo de &var
declare.varargs.checkbox=Declarar v&arargs
default.visibility.border.title=Visibilidad predeterminada
delete.variable.declaration=&Eliminar declaración de variable
destination.directory.does.not.correspond.to.any.package=El directorio de destino no corresponde a ningún paquete
destination.package=&Paquete de destino:
dialog.message.0.would.hide.which.1.used.by.moved.2={0} ocultaría a {1}, el cual es utilizado por el {2} movido.
dialog.message.caret.should.be.inside.method.or.constant=El cursor debe estar situado dentro de un método o constante
dialog.message.confirmation.to.process.only.implementation=Se ha encontrado una implementación de un método abstracto:<br><br><b>{0}</b><br><br>¿Desea aplicar inline a esta implementación?
dialog.message.enum.constant.0.won.t.be.compilable.in.1={0} no podrá compilarse al moverlo a {1}.
dialog.message.field.doesnt.have.initializer=El campo {0} no tiene un inicializador
dialog.message.moving.directories.to=Moviendo directorios a ''{0}''
dialog.message.non.constant.will.not.be.compilable.in.interface=El {0} no constante no se podrá compilar al moverlo a una interfaz.
dialog.message.overriding.methods.with.weaken.visibility=¿Desea reducir también la visibilidad de los métodos de sobreescritura a ''{0}''?
dialog.message.replace.duplicates.works.with.constants.only=Reemplazar duplicados solo funciona con constantes
dialog.message.static.class.initializers.are.not.allowed.in.interfaces=No se permiten inicializadores de clase estáticos en las interfaces.
dialog.title.analyze.code.fragment.to.extract=Analizar código para extraer…
dialog.title.confirm.move=Confirmar movimiento
dialog.title.move.directory.to.source.root=Mover directorio a la raíz de fuentes
dialog.title.resolving.method.implementation=Resolviendo implementación de método
different.name.expected=Se esperaba un nombre diferente
directory.0.already.contains.1.named.2=El directorio {0} \nya contiene un {1} llamado ''{2}''
directory.0.already.contains.a.file.named.1=El directorio {0} \nya contiene un archivo llamado ''{1}''
do.not.replace=&No reemplazar
do.not.show.this.message.in.the.future=&No volver a mostrar este mensaje en el futuro
do.you.want.to.process.overriding.methods.with.covariant.return.type=¿Desea procesar los métodos sobrescritos\ncon un tipo de retorno covariante?
edit.migration.entry.title=Editar regla de migración de clase/paquete
edit.migration.map.ok.button=Guardar
edit.migration.map.title.existing=Editar mapa de migración
edit.migration.map.title.new=Nuevo mapa de migración
element.will.no.longer.be.accessible={0} ya no será accesible desde {1}
encapsulate.fields..encapsulated.fields.visibility.border.title=Visibilidad de los campos encapsulados
encapsulate.fields..package.local.radio=Local del paquete(&C)
encapsulate.fields.accessors.visibility.border.title=Visibilidad de los accesores
encapsulate.fields.command.name=Encapsulando campos en {0}
encapsulate.fields.encapsulate.border.title=Encapsular
encapsulate.fields.existed.accessor.hidden=Ya existe un {0} que sería ocultado por el accesor generado
encapsulate.fields.existed.accessor.hides.generated=Ya existe un {0} que ocultaría el accesor generado para {1}
encapsulate.fields.expression.type.is.used=No se puede continuar con la expresión postfija/prefija cuando se utiliza su tipo de resultado
encapsulate.fields.field.column.name=Campo
encapsulate.fields.fields.to.be.encapsulated=Campos a encapsular
encapsulate.fields.fields.to.encapsulate.border.title=Campos a encapsular
encapsulate.fields.get.access.checkbox=Acceso &get
encapsulate.fields.getter.column.name=Getter
encapsulate.fields.getter.exists=Ya existe el método {0} que difiere del getter {1} únicamente por el tipo de retorno
encapsulate.fields.no.target=No se encontró nada para encapsular
encapsulate.fields.nothing.todo.warning.message=La clase no tiene campos para encapsular
encapsulate.fields.private.radio=Pr&ivado
encapsulate.fields.protected.radio=Pro&tegido
encapsulate.fields.refactoring.cannot.be.applied.to.interface=La refactorización de encapsulamiento de campos no se puede aplicar a una interfaz.
encapsulate.fields.set.access.checkbox=&Establecer acceso
encapsulate.fields.setter.column.name=Setter
encapsulate.fields.setter.exists=Ya existe el método {0} que solo se diferencia del setter {1} en el tipo de retorno
encapsulate.fields.title=Encapsular campos
encapsulate.fields.use.accessors.even.when.field.is.accessible.checkbox=&Usar accesores incluso cuando el campo es accesible
entity.name.accessor=Accesor
entity.name.constructor.parameter=Parámetro
entity.name.inheritor=Heredero
entity.name.test=Prueba
entity.name.variable=Variable
enum.constant.description=Constante de enumeración {0}
enum.description={1, choice, 0#|1#local }enumeración {0}
error.cannot.resolve=No se puede resolver {0}
error.incorrect.data=Datos incorrectos
error.not.supported.for.jsp=La refactorización {0} no es compatible con JSP
error.not.supported.for.local=Una clase que extiende una clase local no se puede convertir en una clase interna
error.not.supported.for.package.info=La refactorización {0} no es compatible con package-info.java
error.wrong.caret.position.anonymous=El cursor debe estar situado dentro de la clase anónima o local que se va a refactorizar
error.wrong.caret.position.constructor=El caret debe estar posicionado dentro del constructor para ser refactorizado
error.wrong.caret.position.local.or.expression.name=El cursor debe situarse en el nombre de la variable local o expresión que se va a refactorizar.
error.wrong.caret.position.method=El caret debe estar situado dentro del método a refactorizar
error.wrong.name.input=Nombre incorrecto: {0}
expand.method.reference.warning=El método se utiliza en una o más referencias de método. Al continuar, estas referencias de método se convertirán en expresiones lambda.
expression.result=Resultado de la expresión
extract.chained.constructor.checkbox=Extraer &constructor encadenado
extract.delegate.as.enum.checkbox=Extraer como enum
extract.delegate.create.nested.checkbox=Crear clase anidada
extract.delegate.generate.accessors.checkbox=&Generar descriptores de acceso
extract.delegate.unable.create.warning.message=No se puede crear la clase con el nombre especificado
extract.method.checkbox.annotate=Anotar
extract.method.checkbox.make.static=Hacer static
extract.method.checkbox.make.static.and.pass.fields=Hacer static y pasar campos
extract.method.conflict.parameter=Nombre de parámetro en conflicto: {0}
extract.method.conflict.variable=La variable con el nombre {0} ya está definida en el ámbito seleccionado
extract.method.control.flow.analysis.failed=El código contiene errores de sintaxis. No se puede realizar el análisis necesario.
extract.method.dialog.separator.parameters=&Parámetros
extract.method.error.annotation.value=No se puede extraer el método del valor de la anotación
extract.method.error.class.not.found=El bloque seleccionado debe ser parte de una clase Java.
extract.method.error.class.outside.defined=La clase local está definida fuera del bloque seleccionado.
extract.method.error.class.outside.used=La clase local se utiliza fuera del bloque seleccionado.
extract.method.error.exception=El comportamiento será diferente cuando se lance una excepción.
extract.method.error.local.class.defined.outside=No se puede extraer el método porque el fragmento de código seleccionado utiliza clases locales definidas fuera del fragmento
extract.method.error.local.class.used.outside=No se puede extraer el método porque el fragmento de código seleccionado define clases locales que se utilizan fuera del fragmento
extract.method.error.local.class.variable.used.outside=No se puede extraer el método porque el fragmento de código seleccionado define una variable de un tipo de clase local que se utiliza fuera del fragmento
extract.method.error.make.static=No se pudo convertir en estático
extract.method.error.many.exits=Hay múltiples puntos de salida.
extract.method.error.many.finals=Hay una asignación al campo final.
extract.method.error.many.outputs=Hay múltiples variables para devolver.
extract.method.error.method.conflict=Ya existe un método con la misma firma
extract.method.error.prefix=No se pudo extraer el método.
extract.method.error.variable.in.expression=Hay una variable para devolver dentro de la expresión seleccionada.
extract.method.error.wrap.many.outputs=Hay varias variables de salida en el bloque de código seleccionado.\nEl método puede extraerse si se agrupan en {0}.
extract.method.error.wrap.many.outputs.class=Un solo objeto
extract.method.error.wrap.many.outputs.record=Un nuevo registro
extract.method.gotit.navigation.header=¿Desea cambiar la firma del método?
extract.method.gotit.navigation.message=Ir a la declaración del método para hacerlo:<br/>{0} el nombre del método o presiona {1}.
extract.method.gotit.signature.header=Cambiar la firma del método
extract.method.gotit.signature.message=<html><p style=''margin-bottom:3px;''>1. Edite la firma</p><p style=''margin-bottom:3px;''>2. Actualice los usos: haga clic en el icono del margen o pulse {0}</p><p><font color=gray>Para reordenar los parámetros, use {1} o {2}.</font></p></html>
extract.method.link.label.more.options=Más opciones
extract.method.object=Extraer objeto de método
extract.method.object.anonymous.make.varargs.option=Convertir en &varargs
extract.method.object.class.name=Nombre de la &clase:
extract.method.object.create.anonymous.class=Crear clase &anónima
extract.method.object.create.inner.class=Crear clase &interna
extract.method.object.inner.class.visibility=Visibilidad:
extract.method.object.inner.make.static.option=Hacer &estático
extract.method.object.inner.make.varargs.option=Convertir en &varargs
extract.method.object.inner.visibility.package.local=Local de pa&quete
extract.method.object.inner.visibility.private=Pri&vado
extract.method.object.inner.visibility.protected=Pr&otegido
extract.method.object.inner.visibility.public=Pú&blico
extract.method.object.method.name=Nombre del &método:
extract.method.object.parameters=Parámetros
extract.method.object.signature.preview=Vista previa de la firma
extract.method.object.suggestion=¿Desea extraer el objeto de método?
extract.method.preview.node.invalid.prefix=No válido
extract.method.progress.replace.duplicates=Reemplazando duplicados
extract.method.progress.search.duplicates=Buscando duplicados
extract.parameters.to.replace.duplicates=Extraer parámetros para reemplazar duplicados
extract.subclass.command=Extraer subclase
extractSuper.rename.original.class.to=&Renombrar clase original a:
extractSuperInterface.javadoc=JavaDoc
factory.method.name.label=Nombre del método de fábrica:
failed.to.re.run.refactoring=No se pudo volver a ejecutar la refactorización
field.0.is.already.defined.in.the.1=El campo {0} ya está definido en {1}
field.0.is.never.used=El campo {0} nunca se utiliza
field.0.is.not.accessible=El campo {0} no es accesible desde {1}
field.0.will.hide.field.1.of.the.base.class=El campo {0} ocultará \nun campo {1} de la base {2}
field.0.won.t.be.initialized.already.in.class.initializer=El campo ''{0}'' no se inicializará dentro del inicializador de clase
field.declaration.radio=&Declaración de campo
field.description=Campo {0}
field.name=&Nombre del campo:
fields.to.be.refactored.should.belong.to.the.same.class=Los campos a refactorizar deben pertenecer a la misma clase.
functional.interface.broken=La expresión funcional requiere que la interfaz funcional tenga exactamente un método
generate.getter.for.delegated.component=Generar &getter para el componente delegado
generate.module.descriptors.analysing.message=Analizando dependencias
generate.module.descriptors.build.required.message=No se pudieron generar los descriptores de módulo porque el proyecto aún no se ha compilado
generate.module.descriptors.collecting.message=Recopilando dependencias
generate.module.descriptors.command.title=Generar descriptores module-info
generate.module.descriptors.io.exceptions.message=Problema al leer los archivos del módulo {0}
generate.module.descriptors.no.suitable.modules.message=No se han encontrado módulos que puedan contener module-info
generate.module.descriptors.preparing.message=Preparando código
generate.module.descriptors.rebuild.message=Es necesario compilar el proyecto para mejorar la precisión del cálculo de dependencias. \n¿Desea iniciar la compilación antes de generar los descriptores module-info?
generate.module.descriptors.scanning.message=Escaneando la salida del compilador
generate.module.descriptors.title=Generar descriptores de módulo
getter.and.setter.methods.found.for.the.field.0=Se encontraron métodos getter y setter para el campo {0}. \n¿Desea {1} también?
getter.method.found.for.the.field.0=Se ha encontrado el método getter para el campo {0}. \n¿Desea {1} también el getter?
idea.has.not.found.any.code.that.can.be.replaced.with.method.call={0} no ha encontrado ningún código que se pueda reemplazar con una llamada a un método
ignore.button=Ignorar
implicit.last.parameter.warning=El último parámetro implícito no debe eliminarse
infer.class.type.args.warning=No se pueden inferir los argumentos de tipo de clase. Al continuar, se creará un {0} de tipo raw
information.title=Información
initializer.for.variable.cannot.be.a.constant.initializer=El inicializador de la variable {0} no puede ser un inicializador constante
inline.action.name=Inline
inline.anonymous.conflict.progress=Buscando herederos de la clase "{0}"…
inline.class.elements.header=Clase a integrar
inline.conflicts.progress=Comprobando si es posible realizar el inline…
inline.constant.field.not.supported.for.enum.constants={0} no se admite para constantes de enumeración
inline.element.unknown.header=Elemento desconocido
inline.field.action.name=Inline de campo…
inline.field.command=Poner campo {0} en línea
inline.field.elements.header=Campo a integrar
inline.field.field.name.label=Incrustar campo ''{0}'':
inline.field.field.occurrences=Incrustar el campo ''{0}'' con {1} {1, choice, 1#uso|2#usos}:
inline.field.initializer.is.not.accessible=El inicializador de campo hace referencia a {0}, que no es accesible en {1}
inline.field.title=Incorporar campo
inline.field.used.in.javadoc=El campo integrado se utiliza en javadoc
inline.field.used.in.reflection=El campo insertado se utiliza mediante reflexión
inline.local.unable.try.catch.warning.message=No se puede inlinear fuera de una sentencia try/catch
inline.local.used.as.resource.cannot.refactor.message=La variable se utiliza como referencia de recurso
inline.local.variable.declared.outside.cannot.refactor.message=La variable está declarada fuera de un bloque de código
inline.method.calls.not.accessible.in=El método insertado llama a {0}, que no será accesible en {1}
inline.method.calls.not.accessible.on.qualifier=El método insertado llama a {0}, que no será accesible en el calificador {1}
inline.method.checking.tail.calls.progress=Comprobando usos de llamadas de cola
inline.method.elements.header=Método para integrar
inline.method.method.label=Método en línea ''{0}'':
inline.method.method.occurrences=Incorporar el método ''{0}'' con {1} {1, choice, 1#uso|2#usos}:
inline.method.multiline.method.in.ctor.call=No se puede aplicar la inserción directa a un método de varias líneas en una llamada al constructor
inline.method.multiline.method.in.loop.condition=No se puede aplicar la incrustación a un método multilínea en una condición de bucle
inline.method.object.action.name=Inline objeto
inline.method.object.suggestion.message=¿Desea insertar en línea el objeto y la llamada subsiguiente?
inline.method.qualifier.usage.side.effect=El método insertado se usa en una referencia a método con efectos secundarios en el calificador
inline.method.used.in.javadoc=El método insertado se utiliza en javadoc
inline.method.used.in.reflection=El método insertado se utiliza mediante reflexión
inline.object.command.name=Insertar objeto en línea
inline.parameter.action.name=Incorporar parámetro…
inline.parameter.cannot.find.initializer.warning.message=No se puede encontrar el inicializador constante para el parámetro
inline.parameter.confirmation=¿Integrar el parámetro ''{0}'' con el inicializador ''{1}''?
inline.parameter.dependency.unavailable.in.parameter.method=El inicializador del parámetro depende de {0}, que no es accesible dentro del método del parámetro
inline.parameter.dependency.unavailable.in.static.method=El inicializador del parámetro depende de {0} que no está disponible en el método estático
inline.parameter.depends.on.caller.parameter=El inicializador del parámetro depende de {0} del llamador
inline.parameter.depends.on.non.static=El inicializador del parámetro depende de {0} no estático y no hay una instancia disponible dentro del método del parámetro
inline.parameter.depends.on.non.static.class=El inicializador del parámetro depende de {0} no estático, el cual no es accesible dentro del método del parámetro
inline.parameter.depends.on.this.inside.static.method=El inicializador del parámetro depende de esto, que no está disponible dentro del método estático
inline.parameter.depends.on.unavailable.element.inside.method=El inicializador de parámetro depende de {0} que no está disponible dentro del método y no puede estar en línea
inline.parameter.depends.on.unavailable.value=El inicializador del parámetro depende de un valor que no está disponible dentro del método
inline.parameter.error.hierarchy=Inlinear parámetros no es compatible cuando el método forma parte de una jerarquía de herencia
inline.parameter.error.non.project.method=No se admite la incorporación para métodos que no pertenecen al proyecto
inline.parameter.error.varargs=No se admite la inserción inline para parámetros varargs
inline.parameter.initializer.depends.on.inaccessible.value=El acceso de escritura al inicializador del parámetro no se puede integrar en línea
inline.parameter.method.usages.progress=Buscando usos del método
inline.parameter.no.usages.warning.message=El método no tiene usos
inline.parameter.not.accessible.warning.message=El inicializador de la constante no es accesible en el cuerpo del método
inline.parameter.refactoring=Inline de parámetro
inline.parameter.replace.with.local.checkbox=R&eemplazar por una variable local
inline.parameter.write.usages.warning.message=No se admite la incorporación de parámetros con usos de escritura
inline.pattern.variable.title=Incorporar variable de patrón
inline.popup.highlight=Resaltar {0} {0, choice, 1#escritura|2#escrituras} en conflicto
inline.popup.ignore.conflicts=Ignorar escrituras y continuar
inline.super.class=Insertar superclase
inline.super.class.action.name=Superclase en línea…
inline.super.class.label=Clase {0}
inline.super.ctor.can.be.replaced=El constructor {0} se puede reemplazar por cualquiera de {1}
inline.super.doc.panel.title=JavaDoc para miembros insertados
inline.super.expr.can.be.replaced={0} se puede reemplazar por cualquiera de {1}
inline.super.no.anonymous.class=No se puede realizar inline en una clase anónima.
inline.super.no.ctor=No se encontró un constructor que coincida con super
inline.super.no.inheritors.warning.message=No se puede inlinear la clase sin herederos
inline.super.no.inner.class=No se puede realizar el inline en la clase interna. Mueva ''{0}'' al nivel superior.
inline.super.no.return.in.super.ctor=No se admite la refactorización cuando la sentencia return interrumpe el flujo de ejecución del superconstructor
inline.super.no.substitution=No se encontró una sustitución consistente para {0}. Se esperaba ''{1}'' pero se encontró ''{2}''.
inline.super.non.project.class.warning.message=No se puede inlinear una clase que no pertenece al proyecto
inline.super.static.import.can.be.replaced=La importación estática puede sustituirse por cualquiera de {0}
inline.super.target.instead.of.super.class=La instancia del tipo de destino se pasa a un lugar donde se espera la superclase.
inline.super.type.element.can.be.replaced={0} se puede reemplazar por cualquiera de {1}
inline.super.type.params.differ=Los parámetros de tipo no coinciden en {0}. Se esperaba {1} pero se encontró {2}
inline.super.unknown.type=Tipo desconocido
inline.superclass.foreign.language.conflict.message=No se puede aplicar inline a {0}
inline.to.anonymous.border.title=Inline
inline.to.anonymous.command.name=Incorporar clase {0}
inline.to.anonymous.name.label=Clase {0}
inline.to.anonymous.no.abstract=Las clases abstractas no se pueden insertar en línea
inline.to.anonymous.no.ctor.calls=La clase no se puede poner en línea porque llama a su propio constructor
inline.to.anonymous.no.get.class.calls=El resultado de la invocación a getClass() se verá modificado
inline.to.anonymous.no.method.calls=La clase no se puede inlinear porque accede a sus propios miembros en otra instancia
inline.to.anonymous.no.multiple.interfaces=Las clases que implementan múltiples interfaces no se pueden integrar en línea
inline.to.anonymous.no.superclass.and.interface=Las clases que tienen una superclase e implementan una interfaz no se pueden integrar
inline.to.anonymous.refactoring=Insertar en línea en clase anónima
inline.vars.elements.header=Variable a inlinear
inline.warning.variables.used.in.initializer.are.updated=Inline no seguro: las variables utilizadas en el inicializador se actualizan
inlined.method.implements.method.from.0=El método insertado en línea implementa el método de {0}
inlined.method.overrides.method.from.0=El método insertado sobrescribe el método de {0}
inlined.method.will.be.transformed.to.single.return.form=El método insertado se transformará al formato de retorno único
inner.class.0.is.already.defined.in.class.1=La clase interna {0} ya está definida en la clase {1}.\n¿Continuar de todos modos?
inner.class.0.is.not.static=La clase interna {0} no es estática.\nLa refactorización {1} solo es compatible con miembros estáticos.
inner.class.exists=La clase interna llamada ''{0}'' ya está definida\nen la clase ''{1}''
inner.class.name=Nombre de la clase &interna:
instance.initializer.description=Inicializador de instancia de {0}
instances.casted.to.java.lang.object=Instancias convertidas a java.lang.Object
instances.of.0.upcasted.to.1.were.found=Se encontraron instancias de {0} con upcasting a {1}. Si continúa, se mostrarán en una pestaña de búsqueda independiente.
instances.upcasted.to.java.lang.object.found=Se encontraron instancias con upcasting a java.lang.Object
instances.upcasted.to.object=Instancias con upcast a Object
interface.0.does.not.have.inheritors=La interfaz {0} no tiene herederos
interface.description=interfaz{1, choice, 0#|1# local} {0}
interface.does.not.have.base.interfaces=La interfaz {0} no tiene interfaces base
interface.has.been.successfully.created=La interfaz {0} se ha creado correctamente
introduce.constant.enum.cb=Extraer como constante de &enumeración
introduce.constant.field.of.type=Constante (campo static final) de tipo &T:
introduce.constant.introduce.to.class=Extraer a la &clase (nombre completo):
introduce.constant.move.to.another.class.checkbox=&Mover a otra clase
introduce.field.field.of.type=Campo de &tipo:
introduce.field.static.field.of.type=Campo estático de &tipo:
introduce.functional.variable.pass.fields.checkbox=Pasar &campos como parámetros
introduce.local.variable.to.reassign.title=Seleccionar variable para reasignar
introduce.parameter.command=Extrayendo parámetro a {0}
introduce.parameter.convert.lambda=&Convertir a expresión funcional
introduce.parameter.duplicates.progress=Buscando duplicados del método…
introduce.parameter.elements.header=Añadiendo parámetro a un método
introduce.parameter.object.create.inner.class=Crear clase &interna
introduce.parameter.object.create.new.class=&Crear nueva clase
introduce.parameter.object.error.class.does.not.exist=''{0}'' no existe
introduce.parameter.object.error.created.class.wont.be.accessible=La clase creada no será accesible
introduce.parameter.object.error.existing.class.misses.compatible.constructor=No hay un constructor compatible en la clase existente
introduce.parameter.object.error.file.already.exits=El archivo ya existe: {0}
introduce.parameter.object.error.inner.class.already.exist=Ya existe una clase interna con el nombre ''{0}''
introduce.parameter.object.error.invalid.inner.class.name=''{0}'' no es un nombre de clase interna válido
introduce.parameter.object.error.invalid.parameter.class.name=''{0}'' no es un nombre de clase de parámetro válido
introduce.parameter.object.error.invalid.parameter.class.package.name=''{0}'' es un nombre de paquete de clase de parámetro no válido
introduce.parameter.object.error.invalid.qualified.parameter.class.name=''{0}'' es un nombre de clase de parámetro calificado no válido
introduce.parameter.object.error.no.field.associated.found=No se encontró ningún campo asociado a {0}
introduce.parameter.object.escalate.visibility.option=&Escalar visibilidad
introduce.parameter.object.existing.class.name=&Nombre
introduce.parameter.object.generate.accessors.option=&Generar métodos de acceso
introduce.parameter.object.inner.class.name=&Nombre
introduce.parameter.object.new.class.name=&Nombre
introduce.parameter.object.new.class.package.name=Nombre del &paquete
introduce.parameter.object.use.existing.class=&Utilizar clase existente
introduce.parameter.super.method.checkbox=Refactorizar s&úper método
introduce.variable.message.cannot.extract.in.implicit.class=No se puede extraer en una clase declarada implícitamente
introduce.variable.message.cannot.extract.variable.in.interface=No se puede extraer la variable en una interfaz.
introduce.variable.message.change.semantics.warning=Extraer la expresión seleccionada cambiará la semántica de las expresiones circundantes.
introduce.variable.message.expression.refers.to.pattern.variable.declared.outside=La expresión hace referencia a la variable de patrón ''{0}'' declarada fuera
introduce.variable.no.matching.occurrences=No hay coincidencias
introduced.variable.will.conflict.with.0=La variable introducida entrará en conflicto con {0}
introducing.variable.may.break.code.logic=La introducción de una variable puede romper la lógica del código
invalid.expression.context=Contexto de expresión no válido.
invalid.package.name=Nombre de paquete no válido: {0}
invalid.target.package.name.specified=Nombre de paquete de destino especificado no válido
invert.boolean.foreach=No se puede invertir el inicializador del parámetro foreach
invert.boolean.wrong.type=El tipo de retorno del método o el tipo de la variable a refactorizar debe ser booleano
invocations.to.be.inlined=Invocaciones para integrar en línea {0}
is.modified.in.loop.body={0} se modifica en el cuerpo del bucle
java.safe.delete.caller.text=Aquí se mostrará el texto del llamador con el elemento llamado resaltado
java.safe.delete.empty.callee.text=El texto de la función llamada se mostrará aquí
javadoc.for.abstracts=JavaDoc para elementos abstractos
keep.original.signature=Mantener firma original
lambda.to.reference.side.effect.warning.message=Se han detectado posibles efectos secundarios en el calificador de la referencia de método.\n¿Introducir variable local?
local.variable.description=Variable local {0}
local.will.be.hidden.renamed.description=El campo renombrado ocultará {0}
localToInner.refactoring.name=Convertir clase local en clase interna
locate.caret.inside.a.method=Ubicar el cursor dentro de un miembro
locate.duplicates.action.name=Localizar duplicados
make.0.static=Hacer {0} estático
make.method.static.title=Hacer método static
make.static.command=Hacer {0} estático
make.static.description.label=Hacer {0} {1} estático
make.static.elements.header={0} que se convertirán en static
make.static.method.references.progress=Buscar referencias a métodos
make.static.methods.to.propagate.dialog.title=Seleccionar métodos para propagar static
members.to.form.interface.title=Miembros para formar la interfaz
members.to.form.superclass.title=Miembros para formar superclase
method.0.is.overridden.by.1=El método {0} es sobrescrito por {1}
method.0.will.hide.method.of.the.base.class=El método {0} ocultará \nel método de la clase base {1}
method.0.will.implement.method.of.the.base.class=El método {0} implementará \nun método de la clase base {1}
method.0.will.override.a.method.of.the.base.class=El método {0} sobrescribirá \nun método de la clase base {1}
method.call.would.be.linked.to.0.after.rename=La llamada al método se vincularía a "{0}" después de cambiar el nombre
method.column=Método
method.description=Método {0}
method.does.not.have.a.body=El método {0} no tiene cuerpo
method.duplicates.found.message={0, choice, 1#1 fragmento de código encontrado|2#{0,number} fragmentos de código encontrados}
method.has.an.empty.body=El método {0} tiene un cuerpo vacío.
method.is.not.a.constructor=El método no es un constructor
method.reference.will.be.converted.to.lambda.expression.warning=La referencia a método se convertirá en una expresión lambda
method.with.the.same.erasure=Método con el mismo borrado
migration.class=Clase
migration.dialog.alert.delete=Eliminar
migration.dialog.alert.name=Eliminar mapa de migración
migration.dialog.alert.text=¿Eliminar la migración ''{0}''?
migration.dialog.link.delete=Eliminar
migration.dialog.link.duplicate=Duplicar y editar…
migration.dialog.link.edit=Editar…
migration.dialog.ok.button.text=Ejecutar
migration.dialog.scope.label=Ámbito:
migration.dialog.scope.whole.project=Todo el proyecto
migration.dialog.title=Migración de paquetes y clases
migration.edit.copy.existing=Copiar uno existente
migration.edit.duplicated.migration.name={0} copia
migration.edit.empty.name=El nombre de la migración no puede estar vacío.
migration.edit.empty.table=La tabla de migración no puede estar vacía.
migration.edit.existing.name=Ya existe una migración con el mismo nombre.
migration.entry.class=Clase
migration.entry.new.name=Nuevo nombre:
migration.entry.old.name=Nombre anterior:
migration.entry.package=Paquete
migration.map.description.label=Descripción del mapa:
migration.map.name.prompt=Nombre del mapa:
migration.new.name.column.header=Nuevo nombre
migration.no.usages.found.in.the.project=No se encontraron usos en el proyecto
migration.old.name.column.header=Nombre anterior
migration.package=Paquete
migration.package.with.subpackages=Paquete con subpaquetes
migration.title=Migración
migration.type.column.header=Tipo
move.class=Mover clase…
move.class.or.package.build.directories=Construyendo la lista de directorios
move.class.refactoring.cannot.be.applied.to.anonymous.classes=La refactorización Mover clase no se puede aplicar a clases anónimas
move.class.to.inner.command.name=Mover {0, choice, 1#clase|2#clases} {1} a {2}
move.class.to.inner.find.target.class.progress=Buscando la clase de destino…
move.class.to.inner.move.to.self.error=No está permitido mover una clase a sí misma
move.class.to.inner.nonstatic.error=No se permite mover una clase a una clase interna no estática
move.class.to.new.file.or.make.inner.class.preview=Mueva la clase ''{0}'' a un nuevo archivo en un paquete de su elección o conviértala en una clase interna de una existente.
move.classes=Mover clases…
move.classes.and.packages=Mover clases y paquetes…
move.classes.command=Moviendo {0} al paquete {1}
move.classes.destination.make.inner=&Convertir en clase interna de
move.classes.destination.package.prompt=Al paquete:
move.classes.destination.to.package=Al &paquete
move.classes.invalid.package.name.warning.message=Nombre de paquete no válido
move.classes.or.packages.different.modules.exports.conflict=Mover {0} del módulo {1} al módulo {2} puede ocultar el acceso al mismo
move.classes.or.packages.new.module.exports.conflict=Cambiar las declaraciones exports/opens del paquete {0} otorga acceso a otros tipos y a sus miembros en el mismo paquete
move.classes.or.packages.title=Mover
move.classes.or.packages.unused.exports.action.name=Eliminar exports/opens no utilizados
move.classes.or.packages.unused.exports.command.name=Eliminando exports/opens no utilizados
move.classes.or.packages.unused.exports.notification.title=Se encontraron exports/opens no utilizados<br>\nen el {0,choice, 1#descriptor|2#descriptores} de módulo
move.enum.constant.cb=Mover como constantes &enum si es posible
move.files.regrouping.command.name=Regrupando…
move.files.to.new.directory.prompt=Al directorio:
move.inner.class.action.name=Mover clase interna…
move.inner.class.command=Moviendo clase interna {0}
move.inner.class.to.another.class=&Mover la clase interna {0} a otra clase
move.inner.class.to.be.moved=Clase a mover
move.inner.class.to.upper.level=Mover la clase &interna {0} al nivel superior
move.inner.class.to.upper.level.action.name=Mover clase interna al nivel superior…
move.inner.class.to.upper.level.or.another.class.preview=Mueva la clase interna ''{0}'' al nivel superior de un paquete de su elección o a otra clase.
move.inner.class.to.upper.level.preview=Mover la clase interna ''{0}'' al nivel superior de un paquete de su elección.
move.instance.method.delegate.title=Mover método de instancia…
move.instance.method.elements.header=Mover método de instancia
move.instance.method.handler.make.method.static=¿Desea convertir el método ''{0}'' en static y luego moverlo?
move.label.text=Mover:
move.member.write.access.in.interface.conflict=Se está escribiendo en {0}, pero una interfaz solo puede contener constantes.
move.members.action.name=Mover miembros…
move.method.enter.a.valid.name.for.parameter=Introduzca un nombre válido para el parámetro
move.method.is.not.supported.for.0=Mover método de instancia no es compatible con {0}
move.method.is.not.supported.for.constructors=Mover método no es compatible con los constructores
move.method.is.not.supported.for.generic.classes=El método Move no es compatible con clases genéricas
move.method.is.not.supported.for.non.project.methods=Mover método no es compatible con métodos que no pertenecen al proyecto
move.method.this.parameter.label=Seleccione un nombre para el parámetro ''{0}.this''
move.methods.panel.title=&Métodos para mover a la clase extraída
move.methods.used.in.extracted.block.only=Mover métodos usados solo en el bloque extraído
move.nonstatic.class.from.jsp.not.supported=No se admite mover clases no estáticas desde una página JSP
move.package.or.directory=Mover paquete o directorio…
move.package.refactoring.cannot.be.applied.to.default.package=La refactorización Mover paquete no se puede aplicar al paquete predeterminado
move.packages.or.directories=Mover paquetes o directorios…
move.single.class.or.package.name.label=Mover {0} {1}
move.specified.classes=Mover las clases especificadas
move.specified.packages=Mover los paquetes especificados
move.to.inner.duplicate.inner.class=La clase {0} ya contiene una clase interna llamada {1}
moving.local.classes.is.not.supported=No se admite mover clases locales
no.class.name.specified=No se ha especificado el nombre de la clase
no.exact.method.duplicates.were.found=<html><b>{0,choice, 0#No se encontraron duplicados|1#Se encontró un duplicado|2#Se encontraron {0} duplicados} de método exactos</b>, aunque el método modificado que se muestra a continuación tiene {1} {1,choice, 1#duplicado|2#duplicados} más</html>
no.initializer.present.for.the.field=No hay un inicializador presente para el campo
no.parameter.name.specified=No se ha especificado el nombre del parámetro
no.usages.can.be.replaced=Ningún uso de {0} \npuede reemplazarse por usos de {1}
occurrences.to.be.migrated=Coincidencias a migrar {0}
ok.button=Aceptar
only.fields.variables.of.methods.of.valid.type.can.be.considered=Solo se pueden considerar campos, variables, parámetros de método o métodos de tipo válido.
package.description=Paquete {0}
package.does.not.exist=El paquete {0} no existe.\n¿Desea crearlo?
package.does.not.exist.preview=El paquete {0} no existe.\nLa refactorización lo creará más adelante.
package.name.prompt=Nombre del pa&quete:
parameter.description=Parámetro {0}
parameter.initializer.contains.0.but.not.all.calls.to.method.are.in.its.class=El inicializador del parámetro contiene {0}, pero no todas las llamadas al método están en su clase
parameter.name.prompt=Nombre del pará&metro:
parameter.of.type=Parámetro de &tipo:
parameter.type.table.column.title=Tipo
parameter.used.in.method.body.warning={0} se utiliza en el cuerpo del método
pass.outer.class.instance.as.parameter=Pasar la instancia de la clase e&xterna como parámetro
pattern.variable.description=Variable de patrón {0}
please.enter.a.valid.target.package.name=Por favor, introduzca un nombre de paquete de destino válido
popup.title.choose.class.to.introduce.constant=Seleccionar clase para introducir la constante
popup.title.choose.class.to.introduce.field=Seleccionar clase para introducir el campo
press.the.do.migrate.button=Pulse el botón "Ejecutar migración" en la parte inferior del panel de resultados de búsqueda\npara realizar la migración mediante el mapa de migración "{0}"\n
preview.usages.to.be.changed=&Vista previa de los usos que se cambiarán
process.duplicates.change.signature.promt=Para reemplazar todas las apariciones, se cambiará la firma del método. ¿Desea continuar?
process.duplicates.title=Procesar duplicados
process.methods.duplicates.title=Procesar duplicado del método {2} ({0} de {1})
processing.progress.text=Procesando {0}
progress.title.collect.hierarchy=Recopilar la jerarquía de ''{0}''
project.files.have.been.changed=Se han modificado los archivos del proyecto.\n¿Desea volver a ejecutar la refactorización?
push.down.delete.warning.text={0}Al bajar los miembros, estos se eliminarán. ¿Desea continuar?
push.down.enum.no.constants.warning.text=La enumeración {0} no tiene constantes para realizar la operación inline.
push.down.no.inheritors.class.warning.text=La clase {0} no tiene herederos.
push.down.no.inheritors.final.class.warning.text=La clase final {0} no tiene herederos.
push.down.unrelated.defaults.conflict={0} heredará valores predeterminados no relacionados de {1} y {2}
push.up.abstract.accessibility.in.subclass.conflict={0} utiliza {1}, que no será accesible desde la subclase.
push.up.abstract.accessible.from.the.subclass.conflict=No se puede definir {0} como abstracto, ya que no será accesible desde la subclase.
push.up.super.class.signature.conflict={0} en la superclase entraría en conflicto con un método {2} de {1}
re.run.refactoring=Volver a ejecutar refactorización
record.component.used.in.method.body.warning=El componente del registro ''{0}'' se utiliza
record.description=Registro{1, choice, 0#|1# local} {0}
refactor.base.method.choice=Refactorizar {0, choice, 0#métodos|1#método} base
refactor.only.current.method.choice=Refactorizar solo el método actual
refactoring.cannot.be.applied.no.sources.attached=No se puede aplicar la refactorización {0}: no se han adjuntado las fuentes
refactoring.cannot.be.applied.to.abstract.methods=La refactorización {0} no se puede aplicar a métodos abstractos
refactoring.cannot.be.applied.to.inline.non.chaining.constructors=La refactorización {0} no se puede aplicar para integrar constructores no encadenados
refactoring.cannot.be.applied.to.native.methods=La refactorización {0} no se puede aplicar a métodos nativos
refactoring.cannot.be.applied.to.vararg.constructors={0} La refactorización no puede aplicarse a constructores vararg
refactoring.extract.method.dialog.duplicates.count={0,choice, 1#Un|2#{0,number}} {0,choice, 1#fragmento|2#fragmentos} de código duplicado se puede reemplazar con la llamada al método extraído
refactoring.extract.method.dialog.duplicates.pending=Buscando duplicados…
refactoring.extract.method.dialog.duplicates.progress=Buscando duplicados
refactoring.extract.method.inner.class.defined=La clase interna {0} ya está definida en la clase {1}.
refactoring.extract.method.preview.button.refactor=&Refactorizar
refactoring.extract.method.preview.button.rerun=Volver a &ejecutar refactorización
refactoring.extract.method.preview.failed=Error al extraer el método
refactoring.extract.method.preview.group.duplicates=Fragmentos de código duplicados
refactoring.extract.method.preview.group.method=Método a extraer
refactoring.extract.method.preview.group.original=Fragmento de código original
refactoring.extract.method.preview.preparing=Preparando diferencias
refactoring.extract.method.preview.updating=Actualizando diff
refactoring.extract.method.reference.to.change=Referencias a cambiar
refactoring.introduce.variable.enum.in.label.message=No se puede extraer la constante de enumeración en la etiqueta switch
refactoring.is.not.supported.for.jsp.classes=No se admite la refactorización para clases JSP
refactoring.is.not.supported.in.the.current.context=La refactorización {0} no es compatible en el contexto actual
references.in.code.to.elements.from.migration.map=Referencias en el código a elementos del mapa de migración "{0}" {1}
references.to.0.to.be.replaced.with.references.to.1=Referencias a ''{0}'' que se sustituirán por referencias a ''{1}''{2}
remove.parameter.0.no.longer.used=Eliminar el parámetro ''{0}'' que ya no se utiliza
removing.redundant.imports.progress.title=Eliminando importaciones redundantes
rename.accessors=Renombrar &accesores
rename.accessors.title=Renombrar getters/setters
rename.accessors.with.the.following.names.to=Renombrar los accesores con los siguientes nombres a:
rename.constructor.parameters.title=Renombrar parámetros del constructor
rename.constructor.parameters.with.the.following.names.to=Renombrar parámetros con los siguientes nombres a:
rename.inheritors.with.the.following.names.to.title=Renombrar los herederos con los siguientes nombres a:
rename.module.already.exists=El módulo ''{0}'' ya existe en el proyecto
rename.module.directory.command=Renombrar el módulo y el directorio a ''{0}''
rename.module.directory.title=Renombr&ar módulo y directorio
rename.overloads=Renombrar s&obrecargas
rename.overloads.dialog.title=Renombrar sobrecargas
rename.overloads.to.dialog.description=Renombrar sobrecargas a:
rename.parameter.in.hierarchy.to.dialog.description=Renombrar el parámetro en la jerarquía a:
rename.parameters.dialog.title=Renombrar parámetros
rename.test.method=Renombrar método de prueba
rename.test.method.description=Renombrar los métodos de prueba con los siguientes nombres a:
rename.test.method.entity.name=Método de prueba
rename.test.method.title=Renombrar métodos de prueba
rename.tests=Renombrar pru&ebas
rename.tests.title=Renombrar pruebas
rename.tests.with.the.following.names.to=Renombrar las pruebas con los siguientes nombres a:
rename.variables=Renombrar &variables
rename.variables.title=Renombrar variables
renamed.class.will.hide.0.in.1=La clase renombrada ocultará {0} en {1}
renaming.method.will.override.final.0=Renombrar el método sobrescribirá el final {0} de super {1}
replace.all.and.extract=Reemplazar las {0} ocurrencias y extraer como la operación ''{1}''
replace.all.fields=&Reemplazar todos los campos
replace.all.occurrences.changes.semantics=Reemplazar las {0} ocurrencias (¡cambiará la semántica!)
replace.all.occurrences.of.expression.0.occurrences=Reemplazar &todas las coincidencias ({0})
replace.all.read.and.write=Reemplazar ocurrencias de lectura y escritura (¡cambiará la semántica!)
replace.as.separate.operation=Extraer como operación ''{0}''
replace.constructor.0.with.a.factory.method=Reemplazar el constructor {0} por un método de fábrica
replace.constructor.builder.create.new=&Crear nuevo
replace.constructor.builder.default.value.table.title=Valor por defecto
replace.constructor.builder.error.builder.class.cannot.be.the.same=La clase {0} no puede ser su propia clase builder.
replace.constructor.builder.error.caret.position=El cursor debe estar situado dentro de una clase cuyos constructores se vayan a reemplazar por un builder.
replace.constructor.builder.error.class.with.chosen.name.already.exist=La clase {0} ya existe en el paquete {1}.
replace.constructor.builder.error.identifier.invalid=El identificador ''{0}'' no es válido
replace.constructor.builder.error.invalid.builder.class.name=''{0}'' no es un nombre de clase válido
replace.constructor.builder.error.invalid.builder.package.name=''{0}'' no es un nombre de paquete válido
replace.constructor.builder.error.invalid.builder.qualified.class.name=''{0}'' no es un nombre de clase totalmente calificado válido
replace.constructor.builder.error.invalid.field.name=''{0}'' no es un nombre de campo válido
replace.constructor.builder.error.invalid.setter.name=''{0}'' no es un nombre de setter válido
replace.constructor.builder.error.no.constructor.chain=Los constructores de {0} no forman una cadena simple.
replace.constructor.builder.error.no.constructors=La clase actual no tiene constructores para reemplazar por un builder.
replace.constructor.builder.error.selected.class.was.not.found=No se encontró la clase builder existente {0}.
replace.constructor.builder.field.name.table.title=Nombre del campo
replace.constructor.builder.optional.setter.table.title=Setter opcional
replace.constructor.builder.parameter.table.title=Parámetro
replace.constructor.builder.select.builder.class.chooser.title=Seleccionar clase Builder
replace.constructor.builder.setter.name.table.title=Nombre del setter
replace.constructor.builder.use.existing=&Usar existente
replace.constructor.existing.builder.fqn=Nombre de la clase &Builder (completamente calificado)
replace.constructor.factory.error.factory.method.already.exists=El método de fábrica {0} ya existe y se utilizará en lugar del recién creado.
replace.constructor.factory.error.invalid.factory.method.name=''{0}'' no es un nombre de método de fábrica válido
replace.constructor.new.builder.class.name=&Nombre de la clase Builder
replace.constructor.new.builder.package=&Paquete para el nuevo builder
replace.constructor.with.builder=Reemplazar constructor con Builder
replace.constructor.with.builder.text=Reemplazar constructor por builder
replace.constructor.with.factory.method=Reemplazar constructor por método de fábrica
replace.constructor.with.factory.method.title=Reemplazar constructor por método de fábrica
replace.constructor.with.factory.target.fq.name=En (nombre totalmente calificado):
replace.default.constructor.of.0.with.a.factory.method=Reemplazar el constructor predeterminado de {0} con un método de fábrica
replace.default.constructor.with.factory.method=Reemplazar el constructor por defecto con un método de fábrica
replace.fields.inaccessible.in.usage.context=Reemplazar campos &inaccesibles en el contexto de uso
replace.fields.used.in.expressions.with.their.getters=Reemplazar campos &usados en expresiones con sus getters
replace.inheritance.from=&Reemplazar la herencia por delegación de:
replace.inheritance.with.delegation.command=Reemplazando herencia por delegación en {0}
replace.inheritance.with.delegation.delegate.members.title=Delegar miembros
replace.inheritance.with.delegation.elements.header=Reemplazar herencia por delegación
replace.inheritance.with.delegation.invalid.field=''{0}'' no es un nombre de campo válido para la delegación
replace.inheritance.with.delegation.invalid.inner.class=''{0}'' es un nombre de campo no válido para la delegación
replace.inheritance.with.delegation.title=Reemplazar herencia por delegación
replace.inside.current.lambda=Crear variable dentro de la lambda actual
replace.instance.qualifiers.with.class.references=Reemplazar calificadores de instancia con referencias de clase
replace.lambda.chain.detected=Se ha detectado una cadena lambda
replace.method.code.duplicates.title=Reemplazar duplicados de código
replace.method.duplicates.scope.chooser.message=Ámbito de análisis
replace.method.duplicates.scope.chooser.title=Especificar el ámbito de {0}
replace.occurrences.inside.statement=Reemplazar {0} coincidencias en el bloque{2, choice, 1#|2# exterior} ''{1}''
replace.this.code.fragment.and.change.signature=\nLa firma del método se cambiará a \n{0}
replace.this.code.fragment.and.make.method.static=(El método pasará a ser estático)
replace.this.code.fragment.and.make.method.static.visible=(El método se convertirá en estático y {0})
replace.this.code.fragment.and.make.method.visible=(El método pasará a ser {0})
replace.with.method.call.does.not.work.for.constructors=Reemplazar por llamada a método no funciona para constructores
replace.write.access.occurrences=Reemp&lazar las apariciones de acceso de escritura
replacing.inheritance.with.delegation=Reemplazando la herencia por delegación
safe.delete.parameter.usage.warning={0} tiene un uso en el punto de llamada que no es seguro eliminar.
safe.delete.search.for.caller.method.usages.progress=Buscando usos del método de llamada…
safe.delete.select.members.to.propagate.dialog.title=Seleccionar miembros para propagar la eliminación segura
safe.delete.select.methods.to.propagate.delete.parameters.dialog.title=Seleccionar métodos para propagar la eliminación de parámetros
select.source.root.chooser.title=Seleccionar raíz de fuentes
selected.block.contains.invocation.of.another.class.constructor=El bloque seleccionado contiene la invocación de un constructor de otra clase
selected.block.contains.statement.outside.of.class=El bloque seleccionado contiene una sentencia fuera de una clase
selected.block.should.represent.an.expression=El bloque seleccionado debe representar una expresión
selected.expression.cannot.be.a.constant.initializer=La expresión seleccionada no puede ser un inicializador de constante
selected.expression.cannot.be.extracted=No se puede extraer la expresión seleccionada
selected.expression.has.void.type=La expresión seleccionada tiene el tipo 'void'
selected.expression.introduces.pattern.variable=La expresión seleccionada introduce la variable de patrón ''{0}''
setter.method.found.for.the.field.0=Se ha encontrado el método setter para el campo {0}. \n¿Desea {1} también el setter?
side.effects.detected.title=Efectos secundarios detectados
source.folder.0.has.package.prefix.1=La carpeta de fuentes {0} tiene el prefijo de paquete ''{1}''\nEl paquete ''{2}'' no se puede crear allí.
static.initializer.description=Inicializador estático de {0}
suggest.signature.preview.after.title=Después
suggest.signature.preview.method.call.prefix=Llamada a método:
suggest.signature.preview.title.before=Antes
superclass.cannot.be.accessed.in.subclass=La superclase no será accesible en la subclase
superclass.cannot.be.extracted.from.a.record=No se puede extraer la superclase de un registro
superclass.cannot.be.extracted.from.an.enum=No se puede extraer la superclase de una enumeración
synthetic.jsp.class.is.referenced.in.the.method=La clase JSP sintética se referencia en el método
target.0.is.not.accessible.from.1=El destino {0} no es accesible desde {1}
template.error.class.already.defined=Ya se ha definido una clase llamada ''{0}'' en el ámbito
template.error.invalid.identifier.name=Nombre de identificador no válido
template.error.variable.already.defined=Ya se ha definido una variable con ese nombre
there.are.going.to.be.multiple.destination.files.with.the.same.name=Habrá varios archivos de destino con el mismo nombre.
there.are.multiple.exit.points.in.the.selected.code.fragment=Hay múltiples puntos de salida en el fragmento de código seleccionado
there.are.multiple.output.values.for.the.selected.code.fragment=Existen múltiples valores de salida para el fragmento de código seleccionado:
there.are.no.variables.that.have.reference.type=No hay parámetros de método ni campos de la clase contenedora que tengan tipo de referencia
there.are.unused.methods.that.override.methods.you.delete=<html>Hay métodos sin usar que sobrescriben los métodos que se van a eliminar. Elija también los métodos de sobrescritura sin usar que desea eliminar:</html>
there.is.already.a.0.in.1=Ya existe un {0} en {1}
there.is.already.a.0.it.will.conflict.with.an.introduced.parameter=Ya existe un {0}. Entrará en conflicto con el parámetro introducido
there.is.already.a.0.it.will.conflict.with.the.renamed.1=Ya existe un {0} con el mismo nombre
there.is.already.a.0.it.will.conflict.with.the.renamed.short=La variable ''{0}'' ya existe
there.is.already.type.parameter.in.0.with.name.1=Ya existe un parámetro de tipo en {0} con el nombre {1}
this.invocation.only.and.keep.the.method=Poner en línea solo este uso y &mantener el método
this.method=Este método
this.reference.only.and.keep.super.class=Integrar solo esta referencia y &mantener la superclase
this.reference.only.and.keep.the.class=Sustituir solo esta referencia y &mantener la clase
this.reference.only.and.keep.the.field=Inline solo esta referencia y &mantener el campo
title.rename.variables.with.the.following.names.to=Renombrar las variables con los siguientes nombres a:
tooltip.cannot.inline.pattern.variable=No se puede inlinear la variable de patrón
turn.refs.to.super.command=Reemplazando usos de {0} por {1}
turnRefsToSuper.change.usages.to=&Cambiar los usos de {0} a:
turnRefsToSuper.use.superclass.in.instanceof=&Usar interfaz/superclase en instanceof
type.migration.action.name=Migración de tipos
type.migration.choose.scope.title=Seleccionar el alcance donde puede producirse el cambio de firma
type.migration.class.type.argument.label=Migrar el argumento de tipo de clase {0} a
type.migration.conflicts.found=Conflictos de migración encontrados
type.migration.error.hint.title=Migración de tipos
type.migration.exclude.action.text=&Excluir
type.migration.include.action.text=&Incluir
type.migration.migrate.button.text=&Migrar
type.migration.no.conflicts.found=No se encontraron conflictos de migración
type.migration.no.scope.warning.message=No se ha seleccionado el ámbito
type.migration.reasons.to.migrate=Se encontraron motivos para migrar
type.migration.rerun.button.text=&Reejecutar migración de tipos
type.migration.return.type.of.method.label=Migrar el tipo de retorno {0} del método {1} a导
type.migration.select.suggestion=Seleccione la raíz para encontrar los motivos para migrar
type.migration.type.of.field.label=Migrar el tipo {0} del campo {1} a
type.migration.type.of.parameter.label=Migrar el tipo {0} del parámetro {1} a
type.migration.type.of.pattern.variable.label=Migrar el tipo {0} de la variable de patrón {1} a
type.migration.type.of.record.component.label=Migrar el tipo {0} del componente de registro {1} a
type.migration.type.of.variable.label=Migrar el tipo {0} de la variable {1} a
type.of.the.selected.expression.cannot.be.determined=No se puede determinar el tipo de la expresión seleccionada.
unable.to.start.type.migration=No se puede iniciar la migración de tipos
unknown.expression.type=Tipo de expresión desconocido.
unused.overriding.methods.title=Métodos de sobreescritura no utilizados
use.interface.where.possible.title=Usar interfaz donde sea posible
use.super.references.prompt=En esta etapa, {0} puede analizar los usos de {1} \ny reemplazarlos por usos de {2} donde sea posible.\n¿Desea continuar?
use.variable.initializer.to.initialize.parameter=Usar el &inicializador de variable para inicializar el parámetro
variable.0.is.changed.before.last.access=La variable ''{0}'' se cambia antes del último acceso a la variable ''{1}''.
variable.does.not.have.an.initializer=La variable {0} no tiene un inicializador.
variable.is.accessed.for.writing=Se accede a la variable ''{0}'' para escritura
variable.is.never.used.before.modification=La variable {0} nunca se utiliza antes de su modificación
variable.of.type=Variable de &tipo:
variable.type.unknown=El tipo de variable es desconocido
would.you.like.to.replace.default.constructor.of.0.with.factory.method=¿Desea reemplazar el constructor por defecto de {0} por un método de fábrica?
wrap.return.value.create.inner.class=Crear clase &interna
wrap.return.value.create.new.class=&Crear nueva clase
wrap.return.value.existing.class.name=Nombre
wrap.return.value.inner.class.name=No&mbre
wrap.return.value.new.class.name=&Nombre
wrap.return.value.new.class.package.name=Nombre del &paquete
wrap.return.value.use.existing.class=&Usar clase existente
wrap.return.value.wrapper.field=Campo del wrapper (&F)
