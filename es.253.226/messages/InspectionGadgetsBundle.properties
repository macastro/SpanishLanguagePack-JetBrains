0.will.no.longer.be.overridable.by.1={0} ya no podrá ser sobrescrito por {1}
absolute.alignment.in.user.interface.display.name=Alineación absoluta en código AWT/Swing
absolute.alignment.in.user.interface.fix.family.name=Reemplazar por constante
absolute.alignment.in.user.interface.problem.descriptor=Se utilizó la constante de alineación absoluta <code>{0}.#ref</code> #loc
abstract.class.extends.concrete.class.display.name=Clase abstracta extiende una clase concreta
abstract.class.extends.concrete.class.problem.descriptor=La clase <code>#ref</code> está declarada como 'abstract' y extiende una clase concreta #loc
abstract.class.naming.convention.element.description=Clase abstracta
abstract.class.never.implemented.display.name=Clase abstracta que no tiene ninguna subclase concreta
abstract.class.never.implemented.problem.descriptor=La clase abstracta <code>#ref</code> no tiene subclases concretas #loc
abstract.class.with.only.one.direct.inheritor.display.name=Clase abstracta con un único heredero directo
abstract.class.with.only.one.direct.inheritor.problem.descriptor=La clase abstracta <code>#ref</code> tiene solo un heredero directo #loc
abstract.class.without.abstract.methods.display.name=Clase abstracta sin métodos 'abstract'
abstract.class.without.abstract.methods.ignore.utility.class.option=Ignorar clases de utilidad
abstract.class.without.abstract.methods.problem.descriptor=La clase <code>#ref</code> está declarada como 'abstract' y no tiene métodos 'abstract' #loc
abstract.method.call.in.constructor.display.name=Llamada a un método abstracto durante la construcción del objeto
abstract.method.call.in.constructor.problem.descriptor=Llamada al método 'abstract' <code>#ref()</code> durante la construcción del objeto #loc
abstract.method.overrides.abstract.method.display.name=Método abstracto sobrescribe un método abstracto
abstract.method.overrides.abstract.method.ignore.different.javadoc.option=Ignorar métodos con un Javadoc diferente al de sus supermétodos
abstract.method.overrides.abstract.method.problem.descriptor=El método abstracto <code>#ref()</code> sobrescribe el método abstracto #loc
abstract.method.overrides.abstract.method.remove.quickfix=Eliminar declaración de método abstracto redundante
abstract.method.overrides.concrete.method.display.name=Método abstracto sobrescribe un método concreto
abstract.method.overrides.concrete.method.problem.descriptor=El método abstracto <code>#ref()</code> sobrescribe el método concreto #loc
abstract.method.with.missing.implementations.display.name=Método abstracto con implementaciones faltantes
abstract.method.with.missing.implementations.problem.descriptor=El método abstracto <code>#ref()</code> no está implementado en todas las subclases #loc
access.to.non.thread.safe.static.field.from.instance.class.chooser.title=Seleccionar clase no segura para subprocesos
access.to.non.thread.safe.static.field.from.instance.display.name=Acceso a campo 'static' no seguro para hilos
access.to.non.thread.safe.static.field.from.instance.field.problem.descriptor=Acceso al campo estático no seguro para hilos <code>#ref</code> de tipo ''{0}'' #loc
access.to.non.thread.safe.static.field.from.instance.option.title=Clases no seguras para hilos:
access.to.static.field.locked.on.instance.display.name=Acceso al campo 'static' bloqueado en los datos de la instancia
access.to.static.field.locked.on.instance.fix.name=Ignorar campos estáticos con tipo ''{0}''
access.to.static.field.locked.on.instance.problem.descriptor=Acceso al campo estático <code>#ref</code> bloqueado en los datos de la instancia #loc
accessing.non.public.field.of.another.object.display.name=Acceso a un campo no público de otro objeto
accessing.non.public.field.of.another.object.problem.descriptor=Acceso directo al campo no público <code>#ref</code> de otro objeto #loc
add.0.to.ignore.if.annotated.by.list.quickfix=Añadir ''{0}'' a la lista ''Ignorar si está anotado por''
add.catch.section.fix.family.name=Añadir cláusula 'catch'
add.read.write.object.methods.fix.family.name=Añadir los métodos 'readObject()' y 'writeObject()' que siempre lancen una excepción
add.read.write.object.methods.fix.text=Añadir el método 'writeObject()' que siempre lanza una excepción
add.read.write.object.methods.fix.text2=Añadir el método 'readObject()' que siempre lanza una excepción
add.serialversionuidfield.quickfix=Añadir campo 'serialVersionUID'
add.this.qualifier.quickfix=Añadir el calificador 'this'
add.throws.clause.fix.family.name=Corregir la cláusula 'throws'
all.levels.option=Todos los niveles de registro
allow.resource.to.be.opened.inside.a.try.block=Permitir que el recurso se abra dentro de un bloque 'try'
ambiguous.field.access.display.name=El acceso al campo heredado parece un acceso a un elemento del código circundante
ambiguous.field.access.hides.field.problem.descriptor=El acceso al campo <code>#ref</code> de la superclase ''{0}'' parece el acceso a un campo de la clase circundante #loc
ambiguous.field.access.hides.local.variable.problem.descriptor=El acceso al campo <code>#ref</code> de la superclase ''{0}'' parece un acceso a la variable local #loc
ambiguous.field.access.hides.parameter.problem.descriptor=El acceso al campo <code>#ref</code> de la superclase ''{0}'' parece un acceso al parámetro #loc
ambiguous.field.access.navigate.quickfix=Navegar a {0, choice, 1#la variable local|2#el parámetro|3#el campo} aparentemente accedido
ambiguous.field.access.quickfix=Añadir el calificador 'super' al acceso al campo
ambiguous.method.call.display.name=La llamada al método heredado parece una llamada a un método local
ambiguous.method.call.problem.descriptor=La llamada al método <code>#ref()</code> de la superclase ''{0}'' parece una llamada al método de la clase ''{1}'' #loc
ambiguous.method.call.quickfix=Añadir el calificador 'super' a la llamada al método
annotation.class.display.name=Interfaz de anotación
annotation.class.problem.descriptor=Interfaz de anotación <code>#ref</code> #loc
annotation.display.name=Anotación
annotation.naming.convention.element.description=Interfaz de anotación
annotation.problem.descriptor=Anotación <code>#ref</code> #loc
anonymous.class.field.hides.containing.method.variable.problem.descriptor=El campo <code>#ref</code> de la clase anónima oculta la variable del método contenedor #loc
anonymous.class.parameter.hides.containing.method.variable.problem.descriptor=El parámetro de la clase anónima <code>#ref</code> oculta la variable en el método contenedor #loc
anonymous.class.variable.hides.containing.method.variable.display.name=La variable de clase anónima oculta la variable del método contenedor
anonymous.class.variable.hides.containing.method.variable.problem.descriptor=La variable local de la clase anónima <code>#ref</code> oculta la variable en el método contenedor #loc
anonymous.extends.concrete.collection.problem.descriptor=La clase anónima extiende explícitamente ''{0}'' #loc
anonymous.extends.thread.problem.descriptor=La clase anónima extiende directamente 'java.lang.Thread' #loc
anonymous.extends.throwable.problem.descriptor=La clase anónima extiende directamente 'java.lang.Throwable' #loc
anonymous.inner.class.display.name=La clase anónima se puede reemplazar por una clase interna
anonymous.inner.class.problem.descriptor=Clase anónima <code>#ref</code> #loc
anonymous.inner.class.with.too.many.methods.display.name=Clase anónima con demasiados métodos
anonymous.inner.class.with.too.many.methods.problem.descriptor=Clase anónima con demasiados métodos (recuento de métodos = {0}) #loc
anonymous.inner.may.be.named.static.inner.class.display.name=La clase anónima puede ser una clase interna 'static' con nombre
anonymous.inner.may.be.named.static.inner.class.problem.descriptor=La clase anónima <code>#ref</code> puede ser una clase interna 'static' con nombre #loc
anonymous.inner.may.be.named.static.inner.class.quickfix=Convertir en clase interna 'static' con nombre
any.method.may.close.resource.argument=Cualquier método puede cerrar el argumento del recurso
array.allocation.zero.length.display.name=Asignación de array de longitud cero
array.allocation.zero.length.problem.descriptor=Asignación de un array de longitud cero #loc
array.can.be.replaced.with.enum.values=El array se puede reemplazar por valores de enumeración
array.can.be.replaced.with.enum.values.family.quickfix=Reemplazar array con EnumType.values()
array.can.be.replaced.with.enum.values.quickfix=Reemplazar array con {0}.values()
array.comparison.display.name=Comparación de arrays mediante '==' en lugar de 'Arrays.equals()'
array.comparison.problem.descriptor=Los objetos de array se comparan mediante <code>#ref</code> en lugar de 'Arrays.equals()' #loc
array.creation.without.new.keyword.family.quickfix=Añadir expresión 'new'
array.creation.without.new.keyword.name=Creación de array sin la expresión 'new'
array.creation.without.new.keyword.quickfix=Añadir ''new {0}''
array.equals.problem.descriptor=La comparación de arrays probablemente debería realizarse utilizando ''{0}''
array.hash.code.display.name=Llamada a 'hashCode()' en un array
array.hash.code.fix.family.name=Reemplazar con la llamada a 'Arrays.hashCode()'
array.hash.code.problem.descriptor=La llamada a <code>#ref()</code> en un array probablemente debería ser 'Arrays.hashCode()' #loc
array.hashcode.problem.descriptor=El cálculo del código hash del array probablemente debería realizarse mediante ''{0}''
array.length.in.loop.condition.display.name=Array.length en la condición de bucle
array.length.in.loop.condition.problem.descriptor=Comprobación del arreglo <code>#ref</code> en la condición del bucle #loc
array.objects.equals.display.name=Uso de métodos superficiales o de 'Objects' con arrays
arrays.as.list.with.one.argument.problem.descriptor=Llamada a <code>#ref()</code> con un solo argumento #loc
arrays.as.list.with.zero.arguments.problem.descriptor=Llamada a <code>#ref()</code> para crear una lista vacía #loc
arrays.as.list.with.zero.or.one.argument.display.name=Llamada a 'Arrays.asList()' con muy pocos argumentos
assert.can.be.if.quickfix=Reemplazar 'assert' por la sentencia 'if'
assert.keyword.is.considered.an.assertion=La palabra clave 'assert' se considera una aserción
assert.message.not.string.display.name=El mensaje de 'assert' no es una cadena
assert.message.not.string.only.warn.boolean.option=Advertir solo cuando el mensaje de 'assert' sea 'boolean' o 'java.lang.Boolean'
assert.message.of.type.boolean.problem.descriptor=Mensaje ''assert'' de tipo ''{0}'' #loc
assert.statement.display.name=Sentencia 'assert'
assert.with.side.effects.call.mutates.expression=La llamada a ''{0}()'' muta ''{1}''
assert.with.side.effects.call.mutates.field=La llamada a ''{0}()'' muta el campo ''{1}''
assert.with.side.effects.call.performs.io=La llamada a ''{0}()'' realiza una operación de entrada/salida
assert.with.side.effects.display.name=Sentencia 'assert' con efectos secundarios
assert.with.side.effects.problem.descriptor=<code>#ref</code> tiene efectos secundarios: {0} #loc
assert.without.message.problem.descriptor=<code>#ref()</code> sin mensaje #loc
assert.without.message.quick.fix.family.name=Añadir mensaje de error
assertion.can.be.if.name=La aserción se puede reemplazar con una sentencia 'if'
asserts.without.messages.display.name=Falta el mensaje en la aserción
assignment.and.return.of.mutable.record.component={0, choice, 1#Asignación|2#Retorno|3#Asignación y retorno} implícitos del componente de registro {1} <code>#ref</code> #loc
assignment.of.field.with.mutable.type.problem.descriptor=Asignación al campo {0} ''{1}'' desde el parámetro <code>#ref</code> #loc
assignment.or.return.of.field.with.mutable.type.display.name=Asignación o retorno de campo con tipo mutable
assignment.replaceable.with.operator.assignment.display.name=La asignación puede reemplazarse con una asignación con operador
assignment.replaceable.with.operator.assignment.ignore.conditional.operators.option=Ignorar operadores condicionales
assignment.replaceable.with.operator.assignment.ignore.obscure.operators.option=Ignorar los operadores poco comunes ^ y %
assignment.replaceable.with.operator.assignment.problem.descriptor=<code>#ref</code> se puede simplificar a ''{0}'' #loc
assignment.to.catch.block.parameter.display.name=Asignación al parámetro del bloque 'catch'
assignment.to.catch.block.parameter.problem.descriptor=Asignación al parámetro del bloque 'catch' <code>#ref</code> #loc
assignment.to.for.loop.parameter.check.foreach.option=Comprobar los parámetros del bucle 'for' mejorado
assignment.to.for.loop.parameter.display.name=Asignación al parámetro del bucle 'for'
assignment.to.for.loop.parameter.problem.descriptor=Asignación al parámetro del bucle for <code>#ref</code> #loc
assignment.to.lambda.parameter.display.name=Asignación a parámetro lambda
assignment.to.lambda.parameter.problem.descriptor=Asignación al parámetro lambda <code>#ref</code> #loc
assignment.to.method.parameter.display.name=Asignación a parámetro del método
assignment.to.method.parameter.ignore.transformation.option=<html>Ignorar si la asignación es una transformación del parámetro original</html>
assignment.to.method.parameter.problem.descriptor=Asignación al parámetro del método <code>#ref</code> #loc
assignment.to.null.display.name=Asignación de 'null'
assignment.to.null.option=Ignorar asignaciones a campos
assignment.to.null.problem.descriptor='null' asignado a la variable <code>#ref</code> #loc
assignment.to.static.field.from.instance.method.display.name=Asignación a un campo estático desde un contexto de instancia
assignment.to.static.field.from.instance.method.problem.descriptor=Asignación al campo estático <code>#ref</code> desde un contexto de instancia #loc
assignment.to.superclass.field.display.name=El constructor asigna un valor a un campo definido en la superclase
assignment.to.superclass.field.problem.descriptor=Asignación al campo ''{0}'' definido en la superclase ''{1}'' #loc
assignment.used.as.condition.display.name=Asignación utilizada como condición
assignment.used.as.condition.problem.descriptor=Asignación <code>#ref</code> utilizada como condición #loc
atomic.field.updater.issues.display.name=Declaración de 'AtomicFieldUpdater' inconsistente
atomic.field.updater.not.static.final.display.name=Campo 'AtomicFieldUpdater' no declarado 'static final'
atomic.field.updater.not.static.final.problem.descriptor=El campo {0} <code>#ref</code> no está declarado como ''static final'' #loc
auto.boxing.display.name=Autoboxing
auto.boxing.ignore.added.to.collection.option=Ignorar las expresiones añadidas a una colección
auto.boxing.make.boxing.explicit.quickfix=Hacer que el boxing sea explícito
auto.boxing.problem.descriptor=Autoboxing <code>#ref</code> #loc
auto.closeable.resource.display.name=AutoCloseable usado sin 'try'-with-resources
auto.closeable.resource.problem.descriptor=''{0}'' se utiliza sin la sentencia ''try''-with-resources #loc
auto.closeable.resource.quickfix=Ignorar 'AutoCloseable' devuelto por este método
auto.closeable.resource.quickfix.preview=Añadir el método <code>{0}</code> a la lista de métodos ignorados
auto.closeable.resource.returned.option=Ignorar instancias AutoCloseable devueltas por todas las llamadas a métodos
auto.unboxing.display.name=Unboxing automático
auto.unboxing.make.unboxing.explicit.quickfix=Hacer explícito el unboxing
auto.unboxing.problem.descriptor=Unboxing automático <code>#ref</code> #loc
await.not.in.loop.display.name='await()' no se llama en un bucle
await.not.in.loop.problem.descriptor=La llamada a <code>#ref()</code> no está en un bucle #loc
await.without.corresponding.signal.display.name='await()' sin el 'signal()' correspondiente
await.without.corresponding.signal.problem.descriptor=Llamada a <code>#ref()</code> sin el correspondiente <code>signal()</code> o <code>signalAll()</code> #loc
bad.exception.caught.display.name='Exception' prohibida capturada
bad.exception.caught.problem.descriptor=Excepción prohibida <code>#ref</code> capturada #loc
bad.exception.declared.display.name=Excepción prohibida declarada
bad.exception.declared.problem.descriptor=Excepción prohibida <code>#ref</code> declarada #loc
bad.exception.thrown.display.name=Excepción prohibida lanzada
bad.exception.thrown.problem.descriptor=Excepción prohibida ''{0}'' lanzada #loc
bad.oddness.display.name=Comprobación de imparidad sospechosa
bad.oddness.problem.descriptor=La comprobación de imparidad fallará con valores negativos #loc
big.decimal.equals.display.name=Llamada a 'equals()' en 'BigDecimal'
big.decimal.equals.problem.descriptor=<code>#ref()</code> entre valores BigDecimal probablemente debería ser 'compareTo()' #loc
big.decimal.method.without.rounding.called.display.name=Llamada al método 'BigDecimal' sin un argumento de modo de redondeo
big.decimal.method.without.rounding.called.problem.descriptor=Se ha llamado a 'BigDecimal.#ref()' sin un argumento de modo de redondeo
bigdecimal.legacy.method.display.name=Llamada a un método heredado de 'BigDecimal'
bigdecimal.legacy.method.problem.descriptor=La llamada a 'BigDecimal.#ref()' puede utilizar una constante de enumeración 'RoundingMode'
bigdecimal.legacy.method.quickfix=Usar la constante de enumeración 'RoundingMode'
boolean.constructor.display.name=Llamada al constructor Boolean
boolean.constructor.problem.descriptor=Llamada al constructor de Boolean #loc
boolean.constructor.simplify.quickfix=Simplificar
boolean.expression.can.be.simplified.problem.descriptor=<code>#ref</code> se puede simplificar a ''{0}'' #loc
boolean.expression.does.not.modify.problem.descriptor=<code>#ref</code> no modifica el valor de ''{0}'' #loc
boolean.expression.may.be.conditional.display.name=La expresión booleana se puede reemplazar con una expresión condicional
boolean.expression.remove.compound.assignment.quickfix=Eliminar la asignación compuesta inútil
boolean.field.always.inverted.problem.descriptor=El campo booleano <code>#ref</code> siempre está invertido #loc
boolean.method.name.must.start.with.question.display.name=El nombre del método booleano debe comenzar con una palabra interrogativa
boolean.method.name.must.start.with.question.problem.descriptor=El nombre del método booleano <code>#ref</code> no comienza con una palabra interrogativa #loc
boolean.method.name.must.start.with.question.table.label=Prefijos de nombres de métodos booleanos:
boolean.parameter.constructor.problem.descriptor=Constructor 'public' <code>#ref()</code> con parámetro 'boolean' #loc
boolean.parameter.display.name=Método 'public' con parámetro 'boolean'
boolean.parameter.only.report.multiple.option=Solo informar de métodos con varios parámetros booleanos
boolean.parameter.problem.descriptor=Método 'public' <code>#ref()</code> con parámetro 'boolean' #loc
boolean.parameters.constructor.problem.descriptor=Constructor 'public' <code>#ref()</code> con parámetros 'boolean' #loc
boolean.parameters.problem.descriptor=Método 'public' <code>#ref()</code> con parámetros 'boolean' #loc
boolean.variable.always.inverted.display.name=La variable booleana siempre está invertida
boolean.variable.always.inverted.problem.descriptor=La variable booleana <code>#ref</code> siempre está invertida #loc
bounded.wildcard.contravariant.descriptor=Se puede generalizar a <code>? super #ref</code> #loc
bounded.wildcard.covariant.descriptor=Se puede generalizar a <code>? extends #ref</code> #loc
bounded.wildcard.display.name=Se puede usar un comodín acotado
bounded.wildcard.report.instance.option=Informar métodos de instancia
bounded.wildcard.report.invariant.option=Informar sobre clases invariantes
bounded.wildcard.report.private.option=Informar de métodos privados
boxing.boxed.value.display.name=Boxing de un valor ya boxeado
boxing.boxed.value.problem.descriptor=Boxing de <code>#ref</code> que ya ha pasado por boxing #loc
boxing.boxed.value.quickfix=Eliminar boxing innecesario
break.statement.display.name=Sentencia 'break'
break.statement.with.label.display.name=Sentencia 'break' con etiqueta
break.statement.with.label.problem.descriptor=Sentencia <code>#ref</code> con etiqueta #loc
busy.wait.display.name=Espera activa
busy.wait.problem.descriptor=Llamada a <code>Thread.#ref()</code> en un bucle, probablemente en espera activa #loc
c.style.array.declaration.display.name=Declaración de array al estilo C
c.style.array.declaration.replace.quickfix=Reemplazar con la declaración de array al estilo Java
cached.number.constructor.call.display.name=Llamada al constructor Number con un argumento primitivo
cached.number.constructor.call.ignore.string.arguments.option=Ignorar nuevas expresiones numéricas con un argumento de cadena
cached.number.constructor.call.problem.descriptor=Llamada al constructor Number con un argumento primitivo #loc
cached.number.constructor.call.report.only.deprecated=Informar solo cuando el constructor sea @Deprecated
call.to.date.tostring.display.name=Llamada a 'Date.toString()'
call.to.date.tostring.problem.descriptor=<code>Date.#ref()</code> usado en un contexto internacionalizado #loc
call.to.native.method.while.locked.display.name=Llamada a un método 'native' mientras está bloqueado
call.to.native.method.while.locked.problem.descriptor=Llamada al método nativo <code>#ref()</code> en un contexto sincronizado #loc
call.to.numeric.tostring.display.name=Llamada a 'Number.toString()'
call.to.numeric.tostring.problem.descriptor=<code>Number.#ref()</code> llamado en un contexto internacionalizado #loc
call.to.private.setter.in.class.option=Informar solo cuando el setter sea 'private'
call.to.private.simple.getter.in.class.option=Solo informar cuando el getter sea 'private'
call.to.simple.getter.in.class.display.name=Llamada a un getter simple desde dentro de la clase
call.to.simple.getter.in.class.ignore.option=Ignorar llamadas a getters en otros objetos
call.to.simple.getter.in.class.inline.quickfix=Inlinear llamada al getter
call.to.simple.getter.in.class.problem.descriptor=Llamada al getter simple <code>#ref()</code> desde la clase #loc
call.to.simple.setter.in.class.display.name=Llamada a un setter simple desde el interior de la clase
call.to.simple.setter.in.class.ignore.option=Ignorar llamadas a setters en otros objetos
call.to.simple.setter.in.class.inline.quickfix=Inlinear llamada al setter
call.to.simple.setter.in.class.problem.descriptor=Llamada al setter simple <code>#ref()</code> desde la propia clase #loc
call.to.string.concat.can.be.replaced.by.operator.display.name=La llamada a 'String.concat()' se puede reemplazar por '+'
call.to.string.concat.can.be.replaced.by.operator.problem.descriptor=La llamada a <code>#ref()</code> se puede reemplazar por la expresión '+' #loc
call.to.string.concat.can.be.replaced.by.operator.quickfix=Reemplazar la llamada a 'concat()' por '+'
call.to.suspicious.string.method.display.name=Llamada a un método de 'String' sospechoso
call.to.suspicious.string.method.problem.descriptor=<code>String.#ref()</code> llamado en un contexto internacionalizado #loc
cast.conflicts.with.instanceof.display.name=El cast entra en conflicto con 'instanceof'
cast.conflicts.with.instanceof.problem.descriptor=La conversión al tipo ''{0}'' entra en conflicto con la comprobación ''instanceof {1}'' anterior
cast.conflicts.with.instanceof.quickfix1=Reemplazar ''{0}'' por ''{1}'' en la conversión
cast.conflicts.with.instanceof.quickfix2=Reemplazar ''{0}'' por ''{1}'' en instanceof
cast.that.loses.precision.display.name=Conversión numérica que pierde precisión
cast.that.loses.precision.negative.problem.descriptor=La conversión de ''{0}'' a <code>#ref</code> puede dar lugar a una pérdida de precisión para un argumento negativo #loc
cast.that.loses.precision.option=Ignorar conversiones de int a char
cast.that.loses.precision.problem.descriptor=La conversión de ''{0}'' a <code>#ref</code> puede dar lugar a una pérdida de precisión #loc
cast.to.concrete.class.problem.descriptor=Conversión a la clase concreta <code>{0}</code> #loc
casting.to.incompatible.interface.display.name=Conversión a un tipo incompatible
casting.to.incompatible.interface.problem.descriptor=Conversión de expresión con tipo ''{1}'' a {0, choice, 1#interfaz|2#clase} incompatible <code>#ref</code> #loc
caught.exception.immediately.rethrown.display.name=La excepción capturada se vuelve a lanzar inmediatamente
caught.exception.immediately.rethrown.problem.descriptor=La excepción capturada <code>#ref</code> se vuelve a lanzar inmediatamente #loc
chain.of.class.equality.checks.problem.descriptor=La cadena de comprobaciones de igualdad de clases indica un fallo de abstracción #loc
chain.of.instanceof.checks.display.name=Cadena de comprobaciones 'instanceof'
chain.of.instanceof.checks.problem.descriptor=La cadena de comprobaciones 'instanceof' indica un fallo de abstracción #loc
chained.equality.comparisons.display.name=Comparaciones de igualdad encadenadas
chained.equality.comparisons.problem.descriptor=Comparación de igualdad encadenada <code>#ref</code> #loc
chained.method.call.display.name=Llamadas a métodos encadenados
chained.method.call.ignore.option=Ignorar las llamadas a métodos encadenados en los inicializadores de campos
chained.method.call.ignore.self.types.option=Ignorar llamadas a métodos que devuelven el mismo tipo que su clase contenedora
chained.method.call.problem.descriptor=Llamada a métodos encadenados <code>#ref()</code> #loc
change.modifier.fix.family.name=Cambiar modificador
change.modifier.package.private.quickfix=Hacer package-private
change.modifier.quickfix=Hacer ''{0}''
channel.opened.not.closed.display.name='Channel' abierto pero no cerrado de forma segura
char.used.in.arithmetic.content.cast.fix.family.name=Insertar cast
char.used.in.arithmetic.context.cast.quickfix=Insertar conversión a {0}
char.used.in.arithmetic.context.display.name=Expresión 'char' utilizada en un contexto aritmético
char.used.in.arithmetic.context.problem.descriptor='char' utilizado en un contexto aritmético #loc
char.used.in.arithmetic.context.quickfix=Convertir a literal de cadena
character.comparison.display.name=Comparación de caracteres
character.comparison.problem.descriptor=Comparación de caracteres <code>#ref</code> en un contexto internacionalizado #loc
checkbox.ignore.null.on.wrong.side=Ignorar 'null' en el lado incorrecto
checked.exception.class.display.name=Clase de excepción verificada
checked.exception.class.problem.descriptor=Clase de excepción comprobada <code>#ref</code> #loc
choose.autocloseable.type.to.ignore.title=Seleccionar tipo de recurso AutoCloseable para ignorar
choose.class=Seleccionar clase
choose.class.hierarchy.to.ignore.title=Seleccionar jerarquía de clases para ignorar
choose.class.type.to.ignore=Seleccionar clase a ignorar
choose.exception.class=Seleccionar clase de excepción
choose.exception.label=Excepciones prohibidas:
choose.io.resource.type.to.ignore=Seleccionar tipo de recurso de E/S para ignorar
choose.logger.class=Seleccionar clase de logger
class.escapes.defined.scope.display.module.option=Informar de las clases no exportadas expuestas en la API del módulo (Java 9+)
class.escapes.defined.scope.display.name=La clase se expone fuera de su ámbito de visibilidad
class.escapes.defined.scope.display.package.option=Informar de clases privadas expuestas en la API local del paquete
class.escapes.defined.scope.display.public.option=Informar sobre clases no accesibles expuestas en la API pública
class.escapes.defined.scope.java9.modules.descriptor=La clase <code>#ref</code> no se exporta desde el módulo ''{0}''
class.escapes.defined.scope.problem.descriptor=La clase <code>#ref</code> está expuesta fuera de su ámbito de visibilidad definido #loc
class.extends.utility.class.display.name=La clase extiende una clase de utilidad
class.extends.utility.class.ignore.utility.class.option=Ignorar si la clase que sobrescribe es una clase de utilidad
class.extends.utility.class.problem.descriptor=La clase <code>#ref</code> extiende la clase de utilidad ''{0}'' #loc
class.independent.of.module.display.name=Clase independiente de su módulo
class.independent.of.module.problem.descriptor=La clase <code>#ref</code> no tiene dependencias ni dependientes en su módulo #loc
class.initializer.display.name=Inicializador no 'static'
class.initializer.may.be.static.display.name=El inicializador de instancia puede ser 'static'
class.initializer.may.be.static.problem.descriptor=El inicializador de clase puede ser 'static' #loc
class.initializer.move.code.to.constructor.quickfix=Mover el código del inicializador al constructor
class.initializer.option=Advertir solo cuando la clase tenga uno o más constructores
class.initializer.problem.descriptor=Inicializador no 'static' #loc
class.loader.instantiation.display.name=Instanciación de 'ClassLoader'
class.loader.instantiation.problem.descriptor=La instanciación de <code>#ref</code> puede plantear problemas de seguridad #loc
class.may.be.interface.convert.quickfix=Convertir clase en interfaz
class.may.be.interface.display.name=Class' abstracta puede ser 'interface
class.may.be.interface.java8.option=Informar sobre las clases que contienen métodos no abstractos al usar Java 8
class.may.be.interface.problem.descriptor=La clase abstracta <code>#ref</code> puede ser una interfaz #loc
class.name=Nombre de la clase
class.name.differs.from.file.name.display.name=El nombre de la clase difiere del nombre del archivo
class.name.differs.from.file.name.problem.descriptor=El nombre de la clase <code>#ref</code> difiere del nombre del archivo #loc
class.name.prefixed.with.package.name.display.name=Nombre de clase con prefijo del nombre del paquete
class.name.prefixed.with.package.name.problem.descriptor=El nombre de la clase <code>#ref</code> comienza con el nombre de su paquete #loc
class.name.same.as.ancestor.name.display.name=Nombre de clase igual al del ancestro
class.name.same.as.ancestor.name.problem.descriptor=El nombre de la clase <code>#ref</code> es igual al de una de sus superclases #loc
class.naming.convention.display.name=Convención de nomenclatura de clases
class.naming.convention.element.description=Clase
class.new.instance.display.name=Llamada insegura a 'Class.newInstance()'
class.new.instance.problem.descriptor=La llamada a <code>#ref()</code> puede lanzar excepciones comprobadas no declaradas #loc
class.only.used.in.one.module.display.name=Clase usada solo desde otro módulo
class.only.used.in.one.module.problem.descriptor=La clase <code>#ref</code> solo tiene dependencias y/o dependientes en el módulo ''{0}'' #loc
class.only.used.in.one.package.display.name=Clase utilizada únicamente desde otro paquete
class.only.used.in.one.package.problem.descriptor=La clase <code>#ref</code> solo tiene dependencias y/o dependientes en el paquete ''{0}'' #loc
class.references.subclass.display.name=La clase hace referencia a una de sus subclases
class.references.subclass.problem.descriptor=La clase ''{0}'' hace referencia a la subclase <code>#ref</code> #loc
class.references.subclass.problem.descriptor.anonymous=La clase anónima hace referencia a la subclase <code>#ref</code> #loc
class.too.deep.display.name=Clase demasiado profunda en el árbol de herencia
class.too.deep.inheritance.depth.limit.option=Límite de profundidad de herencia:
class.too.deep.problem.descriptor=<code>#ref</code> está a demasiada profundidad en el árbol de herencia (profundidad de herencia = {0}) #loc
class.unconnected.to.package.display.name=Clase independiente de su paquete
class.unconnected.to.package.problem.descriptor=La clase <code>#ref</code> no tiene dependencias ni dependientes en su paquete
class.with.only.private.constructors.display.name=La clase con solo constructores 'private' debe declararse 'final'
class.with.only.private.constructors.problem.descriptor=La clase <code>#ref</code> con solo constructores 'private' debería declararse 'final'
class.with.too.many.dependencies.display.name=Clase con demasiadas dependencias
class.with.too.many.dependencies.max.option=Número máximo de dependencias
class.with.too.many.dependencies.problem.descriptor=La clase ''{0}'' tiene demasiadas dependencias ({1} > {2})
class.with.too.many.dependents.display.name=Clase con demasiados dependientes
class.with.too.many.dependents.max.option=Número máximo de dependientes
class.with.too.many.dependents.problem.descriptor=La clase ''{0}'' tiene demasiados dependientes ({1} > {2})
class.with.too.many.transitive.dependencies.display.name=Clase con demasiadas dependencias transitivas
class.with.too.many.transitive.dependencies.max.option=Número máximo de dependencias transitivas
class.with.too.many.transitive.dependencies.problem.descriptor=La clase ''{0}'' tiene demasiadas dependencias transitivas ({1} > {2})
class.with.too.many.transitive.dependents.display.name=Clase con demasiados dependientes transitivos
class.with.too.many.transitive.dependents.max.option=Número máximo de dependientes transitivos
class.with.too.many.transitive.dependents.problem.descriptor=La clase ''{0}'' tiene demasiadas dependencias transitivas ({1} > {2})
class.without.constructor.create.quickfix=Generar constructor vacío
class.without.constructor.display.name=Clase sin constructor
class.without.constructor.problem.descriptor=La clase <code>#ref</code> no tiene constructor #loc
class.without.logger.annotations.tab=Anotaciones
class.without.logger.loggers.tab=Registradores
class.without.no.arg.constructor.display.name=Clase sin constructor sin argumentos
class.without.no.arg.constructor.ignore.option=Ignorar si la clase tiene un constructor predeterminado
class.without.no.arg.constructor.problem.descriptor=La clase <code>#ref</code> no tiene un constructor sin argumentos #loc
clone.doesnt.declare.clonenotsupportedexception.declare.quickfix=Añadir 'CloneNotSupportedException' a la cláusula throws
clone.doesnt.declare.clonenotsupportedexception.display.name=Clone()' no declara 'CloneNotSupportedException
clone.doesnt.declare.clonenotsupportedexception.problem.descriptor=<code>#ref()</code> #loc no declara 'CloneNotSupportedException'
clone.instantiates.new.array.problem.descriptor=''clone()'' crea un nuevo array de {0} #loc
clone.instantiates.objects.with.constructor.display.name='clone()' instancia objetos con el constructor
clone.instantiates.objects.with.constructor.problem.descriptor='clone()' crea nuevas instancias de <code>#ref</code> #loc
clone.method.in.non.cloneable.anonymous.class.problem.descriptor=<code>#ref()</code> definido en una clase anónima no Cloneable derivada de ''{0}'' #loc
clone.method.in.non.cloneable.class.display.name=Método 'clone()' en una clase no Cloneable
clone.method.in.non.cloneable.class.problem.descriptor=<code>#ref()</code> definido en la clase no Cloneable ''{0}'' #loc
clone.method.in.non.cloneable.interface.problem.descriptor=<code>#ref()</code> definido en la interfaz no Cloneable ''{0}'' #loc
clone.returns.class.type.display.name='clone()' debe tener un tipo de retorno igual a la clase que lo contiene
clone.returns.class.type.family.quickfix=Cambiar el tipo de retorno a tipo de clase
clone.returns.class.type.problem.descriptor=''clone()'' debe tener el tipo de retorno ''{0}'' #loc
clone.returns.class.type.quickfix=Cambiar el tipo de retorno a ''{0}''
cloneable.class.in.secure.context.display.name=Clase Cloneable en contexto seguro
cloneable.class.in.secure.context.problem.descriptor=La clase <code>#ref</code> puede ser clonada, comprometiendo la seguridad #loc
cloneable.class.in.secure.context.quickfix=Generar el método 'clone()' que siempre lanza una excepción
cloneable.class.without.clone.display.name=Clase Cloneable sin el método 'clone()'
cloneable.class.without.clone.ignore.option=Ignorar las clases clonables por herencia
cloneable.class.without.clone.ignore.when.clone.called.option=Ignorar si Cloneable es necesario para llamar al método clone() de una superclase
cloneable.class.without.clone.problem.descriptor=<code>#ref</code> es 'Cloneable' pero no define el método 'clone()' #loc
cloneable.class.without.clone.quickfix=Generar el método 'clone()'
cloneable.class.without.clone.todo.message=TODO: copiar el estado mutable aquí, para que el clon no pueda cambiar los elementos internos del original
collection.added.to.self.display.name=Colección añadida a sí misma
collection.added.to.self.problem.descriptor=Se ha llamado a ''{0}()'' en la colección <code>#ref</code> con ella misma como argumento #loc
collection.declared.by.class.display.name=Colección declarada por una clase, no por una interfaz
collection.declared.by.class.ignore.locals.option=Ignorar variables locales
collection.declared.by.class.ignore.private.members.option=Ignorar campos y métodos 'private'
collection.declared.by.class.problem.descriptor=La declaración de <code>#ref</code> probablemente debería debilitarse a ''{0}'' #loc
collections.field.access.replaceable.by.method.call.display.name=La referencia a un campo de colección vacía se puede reemplazar por una llamada a un método
collections.field.access.replaceable.by.method.call.fix.family.name=Reemplazar Collections.EMPTY_* con una llamada
collections.field.access.replaceable.by.method.call.problem.descriptor=<code>#ref</code> puede reemplazarse por ''Collections.{0}'' #loc
collections.must.have.initial.capacity.display.name=Colección sin capacidad inicial
collections.must.have.initial.capacity.problem.descriptor=<code>new #ref()</code> sin capacidad inicial #loc
commented.out.code.delete.quickfix=Eliminar comentario
commented.out.code.uncomment.quickfix=Descomentar código
comments.as.content.option=Los comentarios cuentan como contenido
comparable.implemented.but.equals.not.overridden.display.name='Comparable' implementado pero 'equals()' no sobrescrito
comparable.implemented.but.equals.not.overridden.fix.add.note.name=Añadir nota JavaDoc 'ordering inconsistent with equals'
comparable.implemented.but.equals.not.overridden.fix.generate.equals.name=Generar el método 'equals()'
comparable.implemented.but.equals.not.overridden.problem.descriptor=La clase <code>#ref</code> implementa 'java.lang.Comparable' pero no sobrescribe 'equals()' #loc
comparator.not.serializable.display.name=La clase 'Comparator' no está declarada como 'Serializable'
comparator.not.serializable.problem.descriptor=La clase Comparator <code>#ref</code> no está declarada como Serializable #loc
comparison.of.short.and.char.display.name=Comparación de valores 'short' y 'char'
comparison.of.short.and.char.problem.descriptor=Comparación de igualdad <code>#ref</code> de valores short y char #loc
comparison.to.nan.display.name=Comparación con 'Double.NaN' o 'Float.NaN'
comparison.to.nan.problem.descriptor1=La comparación con <code>#ref</code> siempre es false #loc
comparison.to.nan.problem.descriptor2=La comparación con <code>#ref</code> siempre es true #loc
concrete.class.method.parameter.problem.descriptor=Parámetro ''{0}'' de la clase concreta <code>#ref</code> #loc
concrete.class.use.display.name=Uso de clase concreta
condition.signal.display.name=Llamada a 'signal()' en lugar de 'signalAll()'
condition.signal.problem.descriptor=<code>#ref</code> probablemente debería reemplazarse por 'signalAll()' #loc
conditional.can.be.pushed.inside.expression.display.name=El condicional se puede mover al interior de la expresión de bifurcación
conditional.can.be.pushed.inside.expression.option=Ignorar cuando el condicional sea el único argumento de una llamada a un método
conditional.can.be.pushed.inside.expression.problem.descriptor=La expresión condicional se puede mover al interior de la rama #loc
conditional.can.be.pushed.inside.expression.quickfix=Mover expresión condicional al interior de la rama
conditional.expression.display.name=Expresión condicional
conditional.expression.expression.context.option=Ignorar lugares donde no sea posible usar una sentencia if
conditional.expression.option=Ignorar para asignaciones y retornos simples
conditional.expression.problem.descriptor=Expresión condicional <code>#ref</code> #loc
conditional.expression.quickfix=Reemplazar con la sentencia 'if'
conditional.expression.with.identical.branches.collapse.quickfix=Contraer expresión condicional
conditional.expression.with.identical.branches.display.name=Expresión condicional con ramas idénticas
conditional.expression.with.identical.branches.problem.descriptor=Expresión condicional <code>#ref</code> con ramas idénticas #loc
confusing.else.option=Informar cuando no haya más sentencias después de la sentencia 'if'
confusing.floating.point.literal.change.quickfix=Cambiar a la forma canónica
confusing.floating.point.literal.display.name=Literal de punto flotante confuso
confusing.floating.point.literal.option=Ignorar literales de punto flotante en notación científica
confusing.floating.point.literal.problem.descriptor=Literal de punto flotante confuso <code>#ref</code> #loc
confusing.main.method.display.name=Método 'main()' confuso
confusing.main.method.problem.descriptor=El método <code>#ref()</code> no tiene la signatura 'public static void main(String[])' #loc
confusing.octal.escape.sequence.display.name=Secuencia de escape octal confusa
confusing.octal.escape.sequence.problem.descriptor=Secuencia de escape octal <code>#ref</code> seguida inmediatamente por un dígito #loc
connection.opened.not.safely.closed.display.name=Conexión abierta pero no cerrada de forma segura
consider.static.final.fields.constant.option=Considerar campos 'static final' como constantes
constant.assert.condition.display.name=Condición constante en la sentencia 'assert'
constant.assert.condition.problem.descriptor=La condición de aserción <code>#ref</code> es constante #loc
constant.conditional.expression.display.name=Expresión condicional constante
constant.conditional.expression.problem.descriptor=<code>#ref</code> se puede simplificar a ''{0}'' #loc
constant.conditional.expression.simplify.quickfix=Simplificar
constant.conditional.expression.simplify.quickfix.sideEffect=Extraer efectos secundarios y simplificar
constant.declared.in.abstract.class.display.name=Constante declarada en la clase 'abstract'
constant.declared.in.abstract.class.problem.descriptor=Constante <code>#ref</code> declarada en la clase abstracta #loc
constant.declared.in.interface.display.name=Constante declarada en la interfaz
constant.declared.in.interface.problem.descriptor=Constante <code>#ref</code> declarada en la interfaz #loc
constant.for.zero.length.array.display.name=Uso innecesario de arrays de longitud cero
constant.for.zero.length.array.problem.descriptor=El array de longitud cero se puede cambiar por una constante #loc
constant.for.zero.length.array.quickfix.family=Reemplazar con constante
constant.junit.assert.argument.display.name=Argumento de aserción constante
constant.junit.assert.argument.problem.descriptor=El argumento <code>#ref</code> es constante #loc
constant.math.call.display.name=Llamada constante a 'Math'
constant.math.call.problem.descriptor=La llamada constante a <code>#ref()</code> se puede simplificar #loc
constant.naming.convention.element.description=Constante
constant.on.lhs.of.comparison.options.item.left=Izquierda
constant.on.lhs.of.comparison.options.item.right=Derecha
constant.on.lhs.of.comparison.problem.descriptor=Constante <code>#ref</code> en el lado izquierdo de la comparación #loc
constant.on.rhs.of.comparison.problem.descriptor=Constante <code>#ref</code> en el lado derecho de la comparación #loc
constant.on.side.of.comparison.display.name=Constante en el lado incorrecto de la comparación
constant.value.variable.use.display.name=Uso de una variable cuyo valor se sabe que es constante
constant.value.variable.use.problem.descriptor=Se sabe que el valor de <code>#ref</code> es constante #loc
constant.with.mutable.field.naming.convention.element.description=Constante con tipo mutable
constructor.visibility.option=Ignorar constructores con visibilidad:
continue.or.break.from.finally.block.display.name=Continue' o 'break' dentro del bloque 'finally
continue.or.break.from.finally.block.problem.descriptor=<code>#ref</code> dentro del bloque 'finally' #loc
continue.statement.display.name=Sentencia 'continue'
continue.statement.with.label.display.name=Sentencia 'continue' con etiqueta
continue.statement.with.label.problem.descriptor=Sentencia <code>#ref</code> con etiqueta #loc
control.flow.statement.without.braces.add.quickfix=Añadir llaves a la sentencia
control.flow.statement.without.braces.display.name=Sentencia de flujo de control sin llaves
control.flow.statement.without.braces.message=Añadir llaves a la sentencia ''{0}''
control.flow.statement.without.braces.problem.descriptor=<code>{0}</code> sin llaves #loc
convert.double.unary.quickfix=Reemplazar por ''{0}{1}''
convert.empty.anonymous.to.new.fix.family.name=Eliminar '{}'
convert.octal.literal.to.decimal.literal.quickfix=Convertir literal octal en literal decimal
convert.octal.literals.to.decimal.literals.quickfix=Convertir literales octales a literales decimales
convert.system.out.to.log.call.family.name=Convertir la llamada a 'System.out' en una llamada al log
convert.system.out.to.log.call.name=Convertir la llamada a ''System.out'' en una llamada a ''{0}''
convert.to.variable.arity.method.quickfix=Convertir en método varargs
copy.constructor.misses.field.display.name=El constructor de copia omite un campo
copy.constructor.misses.field.problem.descriptor.1=El constructor de copia no copia el campo ''{0}''
copy.constructor.misses.field.problem.descriptor.2=El constructor de copia no copia los campos ''{0}'' y ''{1}''
copy.constructor.misses.field.problem.descriptor.3=El constructor de copia no copia los campos ''{0}'', ''{1}'' y ''{2}''
copy.constructor.misses.field.problem.descriptor.many=El constructor de copia no copia {0} campos
covariant.equals.display.name='equals()' covariante
covariant.equals.problem.descriptor=<code>#ref()</code> debe recibir 'Object' como su argumento #loc
create.default.branch.fix.family.name=Crear rama 'default'
create.missing.boolean.switch.branches.fix.family.name=Crear las ramas faltantes del switch booleano
create.missing.branches.with.null.branch.fix.family.name=Crear ramas faltantes y 'null'
create.missing.enum.switch.branches.fix.family.name=Crear las ramas de switch de enum faltantes
create.missing.record.deconstructions.switch.branches.fix.family.name=Crear ramas de switch de descomposición de registros faltantes
create.missing.sealed.class.switch.branches.fix.family.name=Crear las ramas de switch faltantes de la clase sellada
create.missing.switch.branch=Crear rama faltante {0}
create.missing.switch.branches=Crear ramas faltantes {0}
create.null.branch.fix.family.name=Crear rama 'null'
create.package.info.java.family.name=Crear 'package-info.java'
cstyle.array.method.declaration.problem.descriptor=El método <code>{0}()</code> tiene una declaración de tipo de retorno de array de estilo C #loc
cstyle.array.variable.declaration.problem.descriptor={0, choice, 1#Campo|2#Parámetro|3#Componente de registro|4#Variable local} <code>{1}</code> tiene una declaración de tipo de array de estilo C #loc
custom.classloader.display.name=Se ha declarado un 'ClassLoader' personalizado
custom.classloader.problem.descriptor=Clase ClassLoader personalizada <code>#ref</code> #loc
custom.security.manager.display.name='SecurityManager' personalizado
custom.security.manager.problem.descriptor=Clase SecurityManager personalizada <code>#ref</code> #loc
cyclic.class.dependency.1.problem.descriptor=La clase ''{0}'' depende cíclicamente de la clase ''{1}''
cyclic.class.dependency.2.problem.descriptor=La clase ''{0}'' depende cíclicamente de las clases ''{1}'' y ''{2}''
cyclic.class.dependency.display.name=Dependencia cíclica de clases
cyclic.class.dependency.ignore.in.same.file=Ignorar ciclos entre clases ubicadas en el mismo archivo
cyclic.class.dependency.problem.descriptor=La clase ''{0}'' tiene una dependencia cíclica de otras {1} clases
cyclic.package.dependency.1.problem.descriptor=El paquete ''{0}'' tiene una dependencia cíclica con el paquete ''{1}''
cyclic.package.dependency.2.problem.descriptor=El paquete ''{0}'' depende cíclicamente de los paquetes ''{1}'' y ''{2}''
cyclic.package.dependency.display.name=Dependencia de paquete cíclica
cyclic.package.dependency.problem.descriptor=El paquete ''{0}'' depende cíclicamente de otros {1} paquetes
cyclomatic.complexity.display.name=Método excesivamente complejo
cyclomatic.complexity.limit.option=Límite de complejidad ciclomática:
cyclomatic.complexity.problem.descriptor=Método excesivamente complejo <code>#ref()</code> (complejidad ciclomática = {0}) #loc
dangling.javadoc.convert.line.comment.quickfix=Reemplazar con comentarios de línea
dangling.javadoc.convert.quickfix=Reemplazar con comentario de bloque
dangling.javadoc.delete.quickfix=Eliminar comentario colgante
dangling.javadoc.display.name=Comentario Javadoc suelto
dangling.javadoc.ignore.copyright.option=Ignorar el comentario de encabezado de archivo en formato JavaDoc
dangling.javadoc.problem.descriptor=Comentario Javadoc colgante #loc
debug.level.and.lower.option=Nivel de depuración e inferior
declare.collection.as.interface.fix.family.name=Debilitar tipo
declare.collection.as.interface.quickfix=Debilitar a ''{0}''
default.not.last.case.in.switch.display.name=Default' no es el último caso en 'switch
default.not.last.case.in.switch.problem.descriptor=La rama ''default'' no es el último case en ''switch'' {0} #loc
default.tostring.call.display.name=Llamada al 'toString()' predeterminado
default.tostring.call.problem.descriptor=Llamada al 'toString()' predeterminado en <code>#ref</code> #loc
delete.catch.section.fix.family.name=Eliminar sentencia catch
delete.catch.section.quickfix=Eliminar la sección 'catch'
delete.import.quickfix=Eliminar importación innecesaria
delete.unnecessary.statement.fix.family.name=Eliminar sentencia redundante
deserializable.class.in.secure.context.problem.descriptor=La clase <code>#ref</code> puede ser deserializada, lo que compromete la seguridad #loc
design.for.extension.display.name=Diseño para la extensión
design.for.extension.problem.descriptor=El método <code>#ref()</code> puede ser sobrescrito y su funcionalidad ignorada #loc
diamond.can.be.replaced.with.explicit.type.arguments.name=El diamante se puede reemplazar con argumentos de tipo explícitos
diamond.can.be.replaced.with.explicit.type.arguments.quickfix=Reemplazar '<>' por argumentos de tipo explícitos
disjoint.package.display.name=Paquete con grafo de dependencias disjunto
disjoint.package.problem.descriptor=El paquete {0} puede descomponerse en {1} paquetes independientes
divide.by.zero.display.name=División por cero
divide.by.zero.problem.descriptor=División por cero #loc
dollar.sign.in.name.display.name=Uso de '$' en el identificador
dollar.sign.in.name.problem.descriptor=El identificador <code>#ref</code> contiene '$' #loc
double.brace.initialization.display.name=Inicialización con doble llave
double.brace.initialization.quickfix=Reemplazar por una inicialización convencional
double.checked.locking.display.name=Bloqueo de doble comprobación
double.checked.locking.fix.family.name=Hacer que el campo sea volatile
double.checked.locking.problem.descriptor=Bloqueo de doble comprobación #loc
double.checked.locking.quickfix=Hacer ''{0}'' volatile
double.literal.may.be.float.literal.display.name=La conversión a 'float' puede ser un literal 'float'
double.negation.display.name=Doble negación
double.negation.problem.descriptor=Doble negación en <code>#ref</code> #loc
double.negation.quickfix=Eliminar doble negación
drivermanager.call.display.name=Uso de 'DriverManager' para obtener la conexión JDBC
drivermanager.call.problem.descriptor=Llamada a <code>DriverManager.#ref()</code> #loc
dumpstack.call.display.name=Llamada a 'Thread.dumpStack()'
dumpstack.call.problem.descriptor=La llamada a <code>Thread.#ref()</code> probablemente debería reemplazarse por un registro más robusto #loc
duplicate.condition.display.name=Condición duplicada
duplicate.condition.ignore.method.calls.option=Ignorar condiciones con posibles efectos secundarios
duplicate.condition.ignore.method.calls.option.description=Si se selecciona, no se informarán las condiciones con posibles efectos secundarios (por ejemplo, llamadas a métodos desconocidos). Los métodos que se sabe que producen efectos secundarios no se informarán en ningún caso.
duplicate.condition.problem.descriptor=Condición duplicada <code>#ref</code> #loc
dynamic.regex.replaceable.by.compiled.pattern.display.name=La expresión regular dinámica puede reemplazarse por un 'Pattern' compilado
dynamic.regex.replaceable.by.compiled.pattern.problem.descriptor=<code>#ref()</code> se puede reemplazar por la construcción compilada 'java.util.regex.Pattern' #loc
dynamic.regex.replaceable.by.compiled.pattern.quickfix=Reemplazar por una llamada al método de la constante 'Pattern' compilada
empty.anonymous.class.problem.descriptor=La clase anónima está vacía #loc
empty.class.display.name=Clase vacía
empty.class.file.without.class.problem.descriptor=El archivo Java no declara ninguna clase #loc
empty.class.ignore.parameterization.option=Ignorar la clase si es una parametrización de un supertipo
empty.class.initializer.delete.quickfix=Eliminar el inicializador de clase vacío
empty.class.initializer.display.name=Inicializador de clase vacío
empty.class.initializer.problem.descriptor=Inicializador de clase vacío #loc
empty.class.problem.descriptor=La clase <code>#ref</code> está vacía #loc
empty.enum.problem.descriptor=La enumeración <code>#ref</code> está vacía #loc
empty.finally.block.display.name=Bloque 'finally' vacío
empty.finally.block.problem.descriptor=Bloque <code>#ref</code> vacío #loc
empty.synchronized.statement.display.name=Sentencia 'synchronized' vacía
empty.synchronized.statement.problem.descriptor=Sentencia <code>#ref</code> vacía #loc
empty.try.block.display.name=Bloque 'try' vacío
empty.try.block.problem.descriptor=Bloque <code>#ref</code> vacío #loc
encapsulate.variable.fix.family.name=Encapsular campo
encapsulate.variable.quickfix=Encapsular campo ''{0}''
enum.singleton.problem.descriptor=El enum <code>#ref</code> es un singleton #loc
enum.switch.statement.which.misses.cases.display.name=Sentencia 'switch' de enumeración a la que le faltan casos
enum.switch.statement.which.misses.cases.option=Ignorar las sentencias switch con una rama default
enum.switch.statement.which.misses.cases.problem.descriptor=La sentencia <code>#ref</code> en el tipo enum ''{0}'' omite los casos {1} #loc
enum.switch.statement.which.misses.cases.problem.descriptor.single=La sentencia <code>#ref</code> del tipo enum ''{0}'' omite el caso ''{1}'' #loc
enumerated.class.display.name=Clase enumerada
enumerated.class.naming.convention.element.description=Clase de enumeración
enumerated.class.problem.descriptor=Clase enumerada <code>#ref</code> #loc
enumerated.constant.naming.convention.element.description=Constante de enumeración
enumeration.can.be.iteration.display.name=Enumeration puede ser iteración
enumeration.can.be.iteration.problem.descriptor=<code>#ref()</code> se puede reemplazar con la estructura ''{0}'' #loc
enumeration.can.be.iteration.quickfix=Reemplazar con el constructo 'Iterator'
equality.to.safe.equals.quickfix=Reemplazar '==' por un 'equals()' seguro frente a nulos
equals.between.inconvertible.types.display.name='equals()' entre objetos de tipos no convertibles
equals.between.inconvertible.types.mutual.subclass.option=Advertir si no se encuentra ninguna subclase mutua
equals.between.inconvertible.types.no.mutual.subclass.problem.descriptor=No se ha encontrado ninguna clase que sea subtipo de ''{0}'' y ''{1}'' #loc
equals.between.inconvertible.types.problem.descriptor=<code>#ref</code> entre objetos de tipos no convertibles ''{0}'' y ''{1}'' #loc
equals.called.on.array.display.name='equals()' llamado en un array
equals.called.on.array.problem.descriptor=<code>#ref()</code> entre arrays probablemente debería ser 'Arrays.equals()' #loc
equals.called.on.enum.constant.display.name='equals()' llamado en un valor de enumeración
equals.called.on.enum.constant.problem.descriptor=<code>#ref()</code> se ha llamado en un valor de enumeración #loc
equals.called.on.suspicious.object.display.name='equals()' llamado en clases que no lo sobrescriben
equals.called.on.suspicious.object.fix.family.name=Reemplazar con una comparación de valores representativos
equals.called.on.suspicious.object.fix.name=Reemplazar con una comparación de los resultados de la llamada a ''{0}()''
equals.called.on.suspicious.object.problem.descriptor=Llamada sospechosa a ''equals()'' en el objeto ''{0}''
equals.doesnt.check.class.parameter.display.name=Método 'equals()' que no comprueba la clase de su parámetro
equals.doesnt.check.class.parameter.problem.descriptor=<code>#ref()</code> debería verificar la clase de su parámetro #loc
equals.replaceable.by.objects.call.display.name=Expresión 'equals()' reemplazable por la expresión 'Objects.equals()'
equals.replaceable.by.objects.call.problem.descriptor=<code>#ref</code> puede reemplazarse por la expresión 'Objects.equals()' #loc
equals.replaceable.by.objects.check.not.null.option=Resaltar expresiones como 'a != null && a.equals(b)'
equals.with.itself.display.name=Llamada a 'equals()' sobre sí mismo
equals.with.itself.option=Ignorar posibles pruebas de contrato
equals.with.itself.option.description=Si se selecciona, no se informarán algunos casos como <code>assertEquals(myObj, myObj)</code>, para evitar advertencias en las pruebas que comprueban la corrección del método <code>equals()</code>.
equals.with.itself.problem.descriptor=<code>#ref()</code> llamado sobre sí mismo
error.rethrown.display.name='Error' no relanzado
error.rethrown.problem.descriptor=Error <code>#ref</code> no relanzado #loc
exception.from.catch.which.doesnt.wrap.display.name='throw' dentro de un bloque 'catch' que ignora la excepción capturada
exception.from.catch.which.doesnt.wrap.problem.descriptor=<code>#ref</code> dentro del bloque 'catch' ignora la excepción capturada #loc
exception.from.catch.which.doesntwrap.ignore.cant.wrap.option=Ignorar si la excepción lanzada no puede envolver una excepción
exception.from.catch.which.doesntwrap.ignore.option=Ignorar si se utiliza el resultado de la llamada al método de la excepción
exception.name.doesnt.end.with.exception.display.name=El nombre de la clase de excepción no termina en 'Exception'
exception.name.doesnt.end.with.exception.problem.descriptor=El nombre de la clase de excepción <code>#ref</code> no termina en 'Exception' #loc
exception.package.display.name=Paquete de excepciones
exception.package.problem.descriptor=El paquete ''{0}'' solo contiene clases de excepción
explicit.array.to.string.problem.descriptor=Llamada a '#ref()' en el array #loc
expression.can.be.replaced.no.quotes.problem.descriptor={0} se puede reemplazar por {1}
expression.can.be.replaced.problem.descriptor=<code>#ref</code> se puede reemplazar por ''{0}'' #loc
expression.may.be.factorized.display.name=La expresión se puede factorizar
extend.exception.fix.family.name=Hacer que la clase extienda 'Exception'
extended.for.statement.display.name=Sentencia 'for' mejorada
extended.for.statement.problem.descriptor=Sentencia <code>#ref</code> extendida #loc
extended.for.statement.replace.quickfix=Reemplazar con la sentencia 'for' de estilo antiguo
extends.annotation.display.name=La clase extiende una interfaz de anotación
extends.annotation.interface.problem.descriptor=La interfaz ''{0}'' extiende la interfaz de anotación <code>#ref</code> #loc
extends.annotation.problem.descriptor=La clase ''{0}'' implementa la interfaz de anotación <code>#ref</code> #loc
extends.concrete.collection.display.name=La clase extiende explícitamente una clase 'Collection'
extends.concrete.collection.problem.descriptor=La clase <code>#ref</code> extiende explícitamente a ''{0}'' #loc
extends.object.display.name=La clase extiende 'Object' explícitamente
extends.object.problem.descriptor=La clase <code>#ref</code> extiende explícitamente 'java.lang.Object' #loc
extends.object.remove.quickfix=Eliminar 'extends Object' redundante
extends.thread.display.name=La clase extiende directamente 'Thread'
extends.thread.problem.descriptor=La clase <code>#ref</code> extiende directamente 'java.lang.Thread' #loc
extends.throwable.display.name=La clase extiende directamente 'Throwable'
extends.throwable.problem.descriptor=La clase <code>#ref</code> extiende directamente 'java.lang.Throwable' #loc
externalizable.with.serialization.methods.display.name=Clase Externalizable con 'readObject()' o 'writeObject()'
externalizable.with.serialization.methods.problem.descriptor.both={0, choice, 1#La clase|2#La interfaz|3#La clase anónima derivada de|4#El tipo de anotación|5#El enum|6#El record} Externalizable <code>#ref</code> define ''readObject()'' y ''writeObject()'' #loc
externalizable.with.serialization.methods.problem.descriptor.read={0, choice, 1#La clase|2#La interfaz|3#La clase anónima derivada de|4#El tipo de anotación|5#La enumeración|6#El registro} Externalizable <code>#ref</code> define ''readObject()'' #loc
externalizable.with.serialization.methods.problem.descriptor.write={0, choice, 1#La clase|2#La interfaz|3#La clase anónima derivada de|4#El tipo de anotación|5#La enumeración|6#El registro} Externalizable <code>#ref</code> define ''writeObject()'' #loc
externalizable.without.public.no.arg.constructor.display.name=Clase 'Externalizable' sin constructor 'public' sin argumentos
externalizable.without.public.no.arg.constructor.problem.descriptor=La clase Externalizable <code>#ref</code> no tiene un constructor 'public' sin argumentos #loc
extract.method.quickfix=Extraer método
extract.parameter.as.local.variable.quickfix=Extraer parámetro como variable local
fallthru.in.switch.statement.display.name=Paso directo en la instrucción 'switch'
fallthru.in.switch.statement.problem.descriptor='Fallthrough' en la sentencia 'switch' #loc
fallthru.in.switch.statement.quickfix=Añadir ''{0}''
feature.envy.display.name=Envidia de características
feature.envy.problem.descriptor=Clase ''{0}'' accedida repetidamente en el método <code>#ref()</code> #loc
field.accessed.synchronized.and.unsynchronized.display.name=Campo accedido tanto en contextos 'synchronized' como no sincronizados
field.accessed.synchronized.and.unsynchronized.option=Los getters y setters simples también se consideran accesos a campos
field.accessed.synchronized.and.unsynchronized.problem.descriptor=Se accede al campo <code>#ref</code> tanto en contextos sincronizados como no sincronizados #loc
field.count.inspection.include.constant.fields.in.count.checkbox=Incluir campos constantes en el conteo
field.count.inspection.include.enum.constants.in.count=Incluir constantes de enumeración en el recuento
field.count.inspection.static.final.fields.count.as.constant.checkbox=Contar campos 'static final' como constantes
field.has.setter.but.no.getter.display.name=El campo tiene setter pero no tiene getter
field.has.setter.but.no.getter.problem.descriptor=El campo <code>#ref</code> tiene setter pero no tiene getter #loc
field.has.static.modifier.problem.descriptor=El campo ''{0}'' tiene el modificador ''static''
field.incorrect.type.problem.descriptor=El campo ''{0}'' no tiene el tipo ''{1}''
field.may.be.final.display.name=El campo puede ser 'final'
field.may.be.final.problem.descriptor=El campo <code>#ref</code> puede ser 'final' #loc
field.may.be.static.display.name=El campo puede ser 'static'
field.may.be.static.problem.descriptor=El campo <code>#ref</code> puede ser 'static' #loc
field.missing.volatile.modifier.problem.descriptor=El campo ''{0}'' no tiene el modificador ''volatile''
field.name.hides.in.superclass.display.name=El campo de la subclase oculta el campo de la superclase
field.name.hides.in.superclass.ignore.option=Ignorar campos no accesibles
field.name.hides.in.superclass.ignore.static.field.option=Ignorar campos estáticos que ocultan campos estáticos
field.name.hides.in.superclass.problem.descriptor=El campo <code>#ref</code> oculta un campo en la superclase #loc
field.naming.convention.display.name=Convención de nomenclatura de campos
field.not.found.in.class.problem.descriptor=No se encontró ningún campo llamado ''{0}'' en la clase ''{1}''
final.class.display.name=La clase está cerrada a la herencia
final.class.problem.descriptor=Clase ''{0}'' declarada como <code>#ref</code> #loc
final.method.display.name=El método no se puede sobrescribir
final.method.in.final.class.display.name=Método 'final' en clase 'final'
final.method.in.final.class.problem.descriptor=Método declarado <code>#ref</code> en la clase 'final' #loc
final.method.problem.descriptor=Método declarado como <code>#ref</code> #loc
final.private.method.display.name=Método 'private' declarado 'final'
final.private.method.problem.descriptor=Método 'private' declarado como <code>#ref</code> #loc
final.static.method.display.name=Método 'static' declarado como 'final'
final.static.method.problem.descriptor=Método 'static' declarado como <code>#ref</code> #loc
finalize.called.explicitly.display.name=Llamada explícita a 'finalize()'
finalize.called.explicitly.problem.descriptor=<code>#ref()</code> se llama explícitamente #loc
finalize.declaration.display.name='finalize()' no debería sobrescribirse
finalize.declaration.problem.descriptor='finalize()' no debería sobrescribirse #loc
finalize.not.declared.protected.display.name='finalize()' debería ser protected, no public
finalize.not.declared.protected.problem.descriptor='finalize()' debe tener acceso protected, no public #loc
finally.block.cannot.complete.normally.display.name=Bloque 'finally' que no puede completarse normalmente
finally.block.cannot.complete.normally.problem.descriptor=El bloque <code>#ref</code> no puede completarse normalmente #loc
fix.add.argument.family.name=Añadir argumento
fix.add.argument.name=Añadir argumento ''{0}''
fix.eliminate.folded.if.present.description=Se puede eliminar la llamada a 'ifPresent()' plegada
fix.eliminate.folded.if.present.name=Eliminar llamada 'ifPresent()' plegada
fix.replace.map.with.flat.map.description=Map()' puede reemplazarse por 'flatMap()
flip.comparison.quickfix=Invertir comparación
floating.point.equality.display.name=Comparación de igualdad de punto flotante
floating.point.equality.problem.descriptor=<code>#ref</code>: valores de punto flotante comparados para igualdad exacta #loc
for.can.be.foreach.display.name=El bucle 'for' se puede reemplazar por un bucle 'for' mejorado
for.can.be.foreach.fix.no.indexed=No informar sobre bucles 'java.util.List' indexados
for.can.be.foreach.option=Informar sobre bucles 'java.util.List' indexados
for.can.be.foreach.option2=No informar de las iteraciones en colecciones sin tipo
for.can.be.foreach.problem.descriptor=El bucle <code>#ref</code> puede reemplazarse por un 'for' mejorado #loc
for.loop.replaceable.by.while.display.name=El bucle 'for' puede reemplazarse por un bucle 'while'
for.loop.replaceable.by.while.ignore.option=Ignorar bucles 'for' infinitos sin condiciones
for.loop.replaceable.by.while.problem.descriptor=La sentencia de bucle <code>#ref</code> puede reemplazarse por un bucle 'while' #loc
for.loop.with.missing.component.collection.loop.option=Ignorar iteraciones de colección
for.loop.with.missing.component.display.name=Bucle 'for' con componentes faltantes
for.loop.with.missing.component.problem.descriptor1=La sentencia <code>#ref</code> carece de inicializador #loc
for.loop.with.missing.component.problem.descriptor2=La sentencia <code>#ref</code> carece de condición #loc
for.loop.with.missing.component.problem.descriptor3=La sentencia <code>#ref</code> carece de actualización #loc
for.loop.with.missing.component.problem.descriptor4=La sentencia <code>#ref</code> carece de inicializador y condición #loc
for.loop.with.missing.component.problem.descriptor5=La sentencia <code>#ref</code> carece de inicializador y actualización #loc
for.loop.with.missing.component.problem.descriptor6=La sentencia <code>#ref</code> carece de condición y actualización #loc
for.loop.with.missing.component.problem.descriptor7=La sentencia <code>#ref</code> carece de inicializador, condición y actualización #loc
foreach.replace.quickfix=Reemplazar por 'for' mejorado
format.string.error.duplicate.flag=Indicador duplicado ''{0}'' en ''{1}''
format.string.error.flags.not.allowed={2, choice, 1#indicador|1<indicadores} ''{0}'' no permitido en ''{1}''
format.string.error.illegal.flag.combination=Combinación ilegal de indicadores ''{0}'' y ''{1}'' en ''{2}''
format.string.error.illegal.position.specifier=Especificador de posición no válido ''{0}'' en ''{1}''
format.string.error.invalid.precision=Precisión no válida especificada en ''{0}''
format.string.error.left.justify.no.width=Se ha utilizado el indicador de alineación a la izquierda ''-'' pero no se ha especificado el ancho en ''{0}''
format.string.error.precision.not.allowed=Precisión (''{0}'') no permitida en ''{1}''
format.string.error.previous.element.not.found=Se ha utilizado el indicador anterior ''<'' pero no se ha encontrado un especificador de formato previo para ''{0}''
format.string.error.unexpected.flag=Carácter inesperado ''{0}'' en ''{1}''
format.string.error.unknown.conversion=Conversión desconocida en ''{0}''
format.string.error.unnecessary.position.specifier=Especificador de posición de argumento innecesario ''{0}'' en ''{1}''
format.string.error.width.not.allowed=No se permite el ancho (''{0}'') en ''{1}''
format.string.error.zero.padding.no.width=Se ha utilizado el indicador de relleno de ceros ''0'', pero no se ha especificado el ancho en ''{0}''
gc.call.display.name=Llamada a 'System.gc()' o 'Runtime.gc()'
gc.call.problem.descriptor=<code>#ref</code> no debe llamarse en el código de producción #loc
generate.to.string.quick.fix.family.name=Generar
generate.to.string.quick.fix.text=Generar toString()
groups.of.modules.loaded.together.description=Cada línea especifica una lista de nombres de módulos separados por comas que se sabe que son cargados por el mismo classloader.\nNo se debe informar del acceso a miembros con visibilidad de paquete (package-private) entre dichos módulos.
groups.of.modules.loaded.together.label=Grupos de módulos que se cargan juntos:
hardcoded.file.separator.display.name=Separador de archivos hardcoded
hardcoded.file.separator.ignore.methods.option=Ignorar argumentos de los siguientes métodos:
hardcoded.file.separator.include.option=Incluir 'example/*' en los tipos de medios MIME reconocidos
hardcoded.file.separator.problem.descriptor=Separador de archivos codificado de forma rígida <code>#ref</code> #loc
hardcoded.line.separator.display.name=Separador de línea hardcoded
hardcoded.line.separator.problem.descriptor=Separador de línea codificado de forma rígida <code>#ref</code> #loc
hibernate.resource.opened.not.closed.display.name=Recurso de Hibernate abierto pero no cerrado de forma segura
html.tag.can.be.javadoc.tag.display.name=<code>…</code>' puede reemplazarse por '{@code …}
html.tag.can.be.javadoc.tag.problem.descriptor=<code>#ref…&lt;/code&gt;</code> puede reemplazarse por '{@code …}' #loc
i.o.resource.opened.not.closed.display.name=Recurso de E/S abierto pero no cerrado de forma segura
if.can.be.assertion.name=La sentencia puede sustituirse por 'assert' o 'Objects.requireNonNull'
if.can.be.assertion.replace.with.assertion.quickfix=Reemplazar la sentencia con una sentencia 'assert'
if.can.be.assertion.replace.with.objects.requirenonnull.quickfix=Reemplazar la sentencia con 'Objects.requireNonNull()'
if.can.be.switch.display.name=If' puede reemplazarse por 'switch
if.can.be.switch.enum.option=Sugerir switch para enumeraciones
if.can.be.switch.int.option=Sugerir switch para números
if.can.be.switch.minimum.branch.option=Número mínimo de ramas de condición 'if':
if.can.be.switch.null.safe.option=Sugerir solo en expresiones null-safe
if.can.be.switch.problem.descriptor=La sentencia <code>#ref</code> puede ser reemplazada por una sentencia 'switch' #loc
if.may.be.conditional.problem.descriptor=<code>#ref</code> puede reemplazarse por una expresión condicional #loc
if.may.be.conditional.quickfix=Reemplazar con expresión condicional
if.may.be.factorized.problem.descriptor=<code>#ref</code> puede factorizarse #loc
if.may.be.factorized.quickfix=Reemplazar con una expresión factorizada
if.statement.with.identical.branches.display.name=Sentencia 'if' con ramas idénticas o partes comunes
if.statement.with.too.many.branches.display.name=Sentencia 'if' con demasiadas ramas
if.statement.with.too.many.branches.max.option=Número máximo de ramas:
if.statement.with.too.many.branches.problem.descriptor=<code>#ref</code> tiene demasiadas ramas ({0}) #loc
ignore.accesses.from.equals.method=Ignorar accesos desde el método 'equals()'
ignore.accesses.from.the.same.class=Ignorar accesos desde la misma clase
ignore.anonymous.inner.classes=Ignorar clases anónimas
ignore.boolean.methods.in.an.interface.option=Ignorar métodos booleanos en una @&interface
ignore.branches.of.switch.statements=Ignorar las ramas de las sentencias 'switch'
ignore.calls.to.property.getters=Ignorar llamadas a los getters de propiedad
ignore.calls.to.static.methods=Ignorar llamadas a métodos estáticos
ignore.classes.annotated.by=Ignorar clases anotadas por:
ignore.classes.in.hierarchy.column.name=Ignorar subclases de:
ignore.cloneable.option=Ignorar 'java.lang.Cloneable'
ignore.constructor.method.references=Ignorar las referencias a métodos de constructor que producen AutoCloseable
ignore.enhanced.for.loop.statements=Ignorar bucles for mejorados
ignore.equals.hashcode.and.tostring=Ignorar los métodos 'equals()', 'hashCode()' y 'toString()'
ignore.exceptions.declared.on.library.override.option=Ignorar las excepciones declaradas en los métodos que sobrescriben un método de la &biblioteca
ignore.for.equals.methods.option=Ignorar para métodos '&equals()'
ignore.getters.returning.resource=Ignorar getters que devuelven recursos
ignore.guard.clauses.option=Ignorar cláusulas de &guarda
ignore.if.annotated.by=Ignorar si está anotado por:
ignore.in.module.statements.option=Ignorar en las sentencias de módulos Java 9
ignore.instanceof.on.library.classes=Ignorar instanceof en clases de biblioteca
ignore.methods.in.anonymous.classes=Ignorar métodos en clases anónimas
ignore.methods.overriding.super.method=Ignorar métodos que &sobrescriben/implementan un supermétodo
ignore.methods.with.boolean.return.type.option=Ignorar métodos con tipo de retorno 'java.lang.Boolean' (&B)
ignore.overflowing.byte.casts.option=Ignorar casts de int 128-255 a byte
ignore.parentheses.around.single.no.formal.type.lambda.parameter=Ignorar los paréntesis alrededor de un único parámetro lambda sin tipo formal
ignore.private.methods.option=Ignorar asignaciones y retornos de métodos privados
ignore.serializable.option=Ignorar 'java.io.Serializable'
ignore.single.field.static.imports.option=Ignorar importaciones estáticas de un solo &campo
ignore.single.method.static.imports.option=Ignorar importaciones estáticas de un solo &método
ignore.trivial.finalizers.option=Ignorar en implementaciones triviales de 'finalize()'
ignored.autocloseable.types.label=Tipos de recursos AutoCloseable ignorados:
ignored.class.hierarchies.border.title=Ignorar subclases de:
ignored.class.label=Clases ignoradas (incluyendo subclases):
ignored.class.names=Ignorar clases (incluyendo subclases)
ignored.io.resource.types.label=Tipos de recursos de I/O ignorados:
implicit.array.to.string.display.name=Llamada a 'toString()' en un array
implicit.array.to.string.fix.family.name=Hacer que Array.toString() sea implícito
implicit.array.to.string.method.call.problem.descriptor=Llamada implícita a 'toString()' en un array devuelto por la llamada a <code>#ref</code> #loc
implicit.array.to.string.problem.descriptor=Llamada implícita a 'toString()' en el array <code>#ref</code> #loc
implicit.array.to.string.quickfix=Envolver con la expresión ''{0}''
implicit.call.to.super.display.name=Llamada implícita a 'super()'
implicit.call.to.super.ignore.option=Ignorar para subclases directas de 'java.lang.Object'
implicit.call.to.super.make.explicit.quickfix=Hacer explícita la llamada a 'super()'
implicit.call.to.super.problem.descriptor=Llamada implícita a 'super()' #loc
implicit.default.charset.usage.constructor.problem.descriptor=La llamada <code>new #ref()</code> utiliza el juego de caracteres predeterminado de la plataforma
implicit.default.charset.usage.display.name=Juego de caracteres predeterminado de la plataforma implícito
implicit.default.charset.usage.fix.family.name=Especificar juego de caracteres UTF-8
implicit.default.charset.usage.problem.descriptor=La llamada a <code>#ref()</code> utiliza el juego de caracteres predeterminado de la plataforma
implicit.numeric.conversion.assignment.problem.descriptor=Conversión numérica implícita del valor del resultado de ''{0}'' a ''{1}'' #loc
implicit.numeric.conversion.display.name=Conversión numérica implícita
implicit.numeric.conversion.ignore.char.conversion.option=Ignorar conversiones desde y hacia 'char'
implicit.numeric.conversion.ignore.constant.conversion.option=Ignorar conversiones de constantes y literales
implicit.numeric.conversion.ignore.widening.conversion.option=Ignorar conversiones de ampliación
implicit.numeric.conversion.make.explicit.quickfix=Hacer explícita la conversión
implicit.numeric.conversion.problem.descriptor=Conversión numérica implícita de <code>#ref</code> de ''{0}'' a ''{1}'' #loc
import.display.name='*' importar
import.from.same.package.display.name=Importación innecesaria del mismo paquete
import.from.same.package.problem.descriptor=Importación innecesaria del mismo paquete <code>#ref</code> #loc
import.problem.descriptor=Importación de paquete <code>#ref</code> #loc
include.java.system.classes.option=Incluir acoplamientos a las clases del sistema Java
include.library.classes.option=Incluir acoplamientos a clases de biblioteca
incompatible.mask.operation.display.name=Operación de máscara de bits incompatible
incompatible.mask.operation.problem.descriptor.always.false=<code>#ref</code> siempre es falso #loc
incompatible.mask.operation.problem.descriptor.always.true=<code>#ref</code> siempre es true #loc
incorrect.date.format.fix.family.name=Corregir formato de fecha incorrecto
increment.decrement.display.name=Resultado de '++' o '--' utilizado
increment.decrement.used.as.expression.fix.family.name=Extraer a una sentencia separada
increment.decrement.used.as.expression.quickfix=Extraer ''{0}'' a una sentencia independiente
inequality.to.safe.not.equals.quickfix=Reemplazar '!=' con '!equals()' seguro para nulos
infinite.loop.statement.display.name=Sentencia de bucle infinito
infinite.loop.statement.problem.descriptor=La sentencia <code>#ref</code> no puede completarse sin lanzar una excepción #loc
infinite.recursion.display.name=Recursión infinita
infinite.recursion.problem.descriptor=El método <code>#ref()</code> realiza una recursión infinita y solo puede terminar lanzando una excepción #loc
info.level.and.lower.option=Nivel informativo e inferiores
inline.call.quickfix=Llamada inline
inline.variable.quickfix=Inline de variable
inner.class.field.hides.outer.display.name=Campo de clase interna oculta campo de clase externa
inner.class.field.hides.outer.ignore.option=Ignorar campos externos no visibles desde la clase interna
inner.class.field.hides.outer.problem.descriptor=El campo de la clase interna <code>#ref</code> oculta el campo de la clase externa #loc
inner.class.may.be.static.display.name=La clase interna puede ser 'static'
inner.class.may.be.static.problem.descriptor=La clase interna <code>#ref</code> puede ser 'static' #loc
inner.class.on.interface.display.name=Clase interna de la interfaz
inner.class.on.interface.ignore.option=Ignorar interfaces internas de interfaces
inner.class.on.interface.problem.descriptor=La interfaz ''{0}'' tiene la clase interna <code>#ref</code> #loc
inner.class.referenced.via.subclass.display.name=Clase interna referenciada mediante una subclase
inner.class.referenced.via.subclass.problem.descriptor=Clase interna <code>#ref</code> declarada en la clase ''{0}'' pero referenciada a través de la subclase ''{1}'' #loc
inner.class.referenced.via.subclass.quickfix=Racionalizar el acceso a la clase interna
inner.class.too.deeply.nested.display.name=Clase interna anidada demasiado profundamente
inner.class.too.deeply.nested.nesting.limit.option=Límite de anidamiento:
inner.class.too.deeply.nested.problem.descriptor=<code>#ref</code> está demasiado anidada (nivel de anidamiento = {0}) #loc
inspection.autocloseable.resource.ignored.methods.title=Ignorar las instancias de AutoCloseable devueltas por estos métodos:
inspection.byte.array.output.stream.to.string.message=Conversión ineficiente desde ByteArrayOutputStream
inspection.case.mismatch.display.name=Mayúsculas y minúsculas no coincidentes en la operación 'String'
inspection.case.mismatch.message.arg.is.lower=El método ''{0}()'' siempre devuelve {1}: el argumento contiene un símbolo en minúscula mientras que el calificador no contiene símbolos en minúscula
inspection.case.mismatch.message.arg.is.upper=El método ''{0}()'' siempre devuelve {1}: el argumento contiene un símbolo en mayúscula mientras que el calificador no contiene símbolos en mayúscula
inspection.case.mismatch.message.label.is.lower=La rama del switch es inalcanzable: la etiqueta contiene un símbolo en minúscula mientras que el selector es solo de mayúsculas
inspection.case.mismatch.message.label.is.upper=La rama del switch es inalcanzable: la etiqueta contiene un símbolo en mayúscula mientras que el selector es solo de minúsculas
inspection.cast.can.be.replaced.with.variable.display.name=La conversión se puede reemplazar con una variable
inspection.cast.can.be.replaced.with.variable.family.name=Reemplazar la conversión con una variable
inspection.cast.can.be.replaced.with.variable.message=La variable ''{0}'' se puede utilizar en lugar de ''{1}''
inspection.catch.ignores.exception.display.name=El bloque catch puede ignorar la excepción
inspection.catch.ignores.exception.empty.message=Bloque <code>#ref</code> vacío #loc
inspection.catch.ignores.exception.option.comments=No advertir si el bloque 'catch' contiene un comentario
inspection.catch.ignores.exception.option.ignored.used=No advertir cuando la excepción llamada 'ignore(d)' no se ignore realmente
inspection.catch.ignores.exception.option.nonempty=No advertir cuando el bloque 'catch' no esté vacío
inspection.catch.ignores.exception.unused.message=Parámetro 'catch' no utilizado <code>#ref</code> #loc
inspection.catch.ignores.exception.used.message=El parámetro 'catch' con nombre <code>#ref</code> se utiliza #loc
inspection.catch.ignores.exception.vm.ignored.message=Una excepción inesperada de la VM como ''{0}'' podría ignorarse en un bloque <code>#ref</code> #loc
inspection.collection.must.have.initial.capacity.initializers.option=No informar sobre inicializadores de campo
inspection.commented.out.code.disable.short.fragments=No informar sobre fragmentos tan cortos
inspection.commented.out.code.display.name=Código comentado
inspection.commented.out.code.min.lines.options=Mínimo de líneas de código
inspection.commented.out.code.problem.descriptor=Código comentado ({0} {0, choice, 1#línea|1<líneas})
inspection.common.if.parts.description.complete.duplicate=La sentencia ''if'' se puede contraer{0}
inspection.common.if.parts.description.complete.duplicate.side.effect=La sentencia 'if' se puede colapsar con extracción de efectos secundarios
inspection.common.if.parts.description.variables.only=Se pueden extraer variables de ''if''{0}
inspection.common.if.parts.description.whole.branch=Se puede extraer la parte común eliminando la rama {0}
inspection.common.if.parts.description.with.variables.extract=Se pueden extraer partes comunes con variables de ''if''{0}
inspection.common.if.parts.description.without.variables.extract=Se puede extraer la parte común de ''if''{0}
inspection.common.if.parts.message.complete.duplicate=Contraer sentencia ''if''{0}
inspection.common.if.parts.message.complete.duplicate.side.effect=Contraer la sentencia 'if' y extraer el efecto secundario
inspection.common.if.parts.message.variables.only=Extraer variables de ''if''{0}
inspection.common.if.parts.message.whole.branch=Extraer la parte común eliminando la rama {0}
inspection.common.if.parts.message.with.variables.extract=Extraer parte común con variables de ''if''{0}
inspection.common.if.parts.message.without.variables.extract=Extraer parte común de ''if''{0}
inspection.common.subexpression.in.switch.display.name=Se puede extraer la subexpresión común de 'switch'
inspection.common.subexpression.in.switch.fix.family.name=Mover expresión 'switch' hacia abajo
inspection.comparator.combinators.description=Se puede reemplazar por una cadena de 'Comparator'
inspection.comparator.combinators.description2=Puede reemplazarse por ''{0}''
inspection.comparator.combinators.fix.chain=Reemplazar con una cadena de 'Comparator'
inspection.condition.covered.by.further.condition.descr=Condición ''{0}'' cubierta por {1, choice, 1#la condición posterior ''''{2}''''|2#condiciones posteriores}
inspection.constant.expression.display.name=Se puede evaluar la expresión constante
inspection.constant.expression.fix.family.name=Calcular valor constante
inspection.constant.expression.fix.name=Calcular el valor constante de ''{0}''
inspection.constant.expression.fix.name.short=Reemplazar por el valor constante
inspection.constant.expression.message=La expresión constante se puede evaluar como ''{0}''
inspection.constant.expression.report.compile.time=Informar solo constantes en tiempo de compilación
inspection.constant.expression.report.compile.time.description=De forma predeterminada, la inspección puede evaluar algunas constantes que involucran llamadas a métodos de biblioteca o incluso deducir el valor de la constante basándose en el código circundante. Marque esta opción para informar solo sobre las constantes de tiempo de compilación, de acuerdo con la especificación del lenguaje Java.
inspection.constant.expression.skip.non.literal=No informar expresiones que contengan referencias a constantes definidas
inspection.constant.expression.skip.non.literal.description=Ignorar expresiones que contienen referencias a operandos no literales, como campos y variables.
inspection.deconstruction.can.be.used.display.name=Se puede usar el patrón de registro
inspection.deconstruction.can.be.used.fix.family.name=Reemplazar por un patrón de registro
inspection.deconstruction.can.be.used.message=Puede reemplazarse por un patrón de registro
inspection.empty.catch.block.generate.body=Generar el cuerpo de 'catch' desde la plantilla
inspection.empty.class.ignore.subclasses.option=Ignorar subclases de {0}
inspection.enhanced.for.with.record.pattern.can.be.used.components.option=Número máximo de componentes de registro a desestructurar:
inspection.enhanced.for.with.record.pattern.can.be.used.display.name=Se puede usar un 'for' mejorado con un patrón de registro
inspection.enhanced.for.with.record.pattern.can.be.used.fix.family.name=Reemplazar con un patrón de record
inspection.enhanced.for.with.record.pattern.can.be.used.level.option=Límite de profundidad de anidamiento:
inspection.enhanced.for.with.record.pattern.can.be.used.maximum.depth.disabled=No sugerir para patrones con {0} o más patrones anidados
inspection.enhanced.for.with.record.pattern.can.be.used.maximum.number.disabled=No sugerir para registros con {0} o más componentes
inspection.enhanced.for.with.record.pattern.can.be.used.message=Se puede reemplazar por un 'for' mejorado con un patrón de record
inspection.enhanced.for.with.record.pattern.can.be.used.not.used.option=Número máximo de componentes de registro no utilizados:
inspection.excessive.range.check.fix.family.name=Simplificar la comprobación de rango excesiva
inspection.excessive.range.check.message=Puede reemplazarse con ''{0}''
inspection.explicit.chrono.field.display.name=Las llamadas a métodos 'java.time' con argumentos 'ChronoField' o 'ChronoUnit' explícitos pueden simplificarse
inspection.explicit.chrono.field.family.name=Simplifique las llamadas con los argumentos explícitos 'ChronoField' o 'ChronoUnit'
inspection.explicit.chrono.field.problem.descriptor=Las llamadas con argumentos explícitos 'ChronoField' o 'ChronoUnit' pueden simplificarse
inspection.if.statement.missing.break.in.loop.description=El bucle puede terminarse después de que se cumpla la condición
inspection.if.statement.missing.break.in.loop.name=Salida temprana del bucle en la condición 'if'
inspection.if.statement.missing.break.in.loop.quickfix=Añadir 'break'
inspection.incorrect.date.format.display.name=Patrón 'DateTimeFormat' incorrecto
inspection.incorrect.date.format.message.literal=Comilla simple de apertura ({0}) sin la correspondiente comilla simple de cierre
inspection.incorrect.date.format.message.padding=Modificador de relleno ''{0}'' sin letras de patrón consecutivas
inspection.incorrect.date.format.message.reserved.character=Uso del carácter reservado ''{0}''
inspection.incorrect.date.format.message.unpaired=Cierre de <code>#ref</code> sin el ''{0}'' de apertura previo
inspection.incorrect.date.format.message.unsupported=Carácter de patrón no válido ''{0}''
inspection.incorrect.date.format.too.few.letters=Muy pocas letras de patrón consecutivas ''{0}''; mínimo: {1}; especificado: {2}
inspection.incorrect.date.format.too.many.letters=Demasiadas letras de patrón consecutivas ''{0}''; máximo: {1}; especificado: {2}
inspection.incorrect.date.format.wrong.number.of.letters=Número incorrecto de letras de patrón consecutivas ''{0}''; permitido: {1}; especificado: {2}
inspection.incorrect.message.custom.classes.methods=Métodos MessageFormat personalizados:
inspection.incorrect.message.format.choice.limit.incorrect=El límite inferior ''{0}'' en el patrón de elección es incorrecto
inspection.incorrect.message.format.choice.limit.not.found=Límite inferior vacío en el patrón 'choice'
inspection.incorrect.message.format.display.name=Patrón 'MessageFormat' incorrecto
inspection.incorrect.message.format.incorrect.index=Índice ''{0}'' incorrecto
inspection.incorrect.message.format.incorrect.order.choice=Los límites inferiores no están en orden ascendente en el patrón choice
inspection.incorrect.message.format.incorrect.quotes.number=Probablemente el número de comillas es incorrecto, se imprimirá más de una comilla
inspection.incorrect.message.format.not.found.argument=No hay ningún argumento para el índice ''{0}''
inspection.incorrect.message.format.not.found.arguments=No hay argumentos para los índices: {0}
inspection.incorrect.message.format.not.used.argument=El argumento con el índice ''{0}'' no se utiliza en el patrón
inspection.incorrect.message.format.pattern={0} en el patrón de formato de mensaje ''{1}''
inspection.incorrect.message.format.quotes.around.parameter=El marcador de posición ''{0}'' no se sustituirá porque está entre comillas
inspection.incorrect.message.format.unclosed.brace=Llave sin cerrar
inspection.incorrect.message.format.unknown.format.type=Tipo de formato desconocido ''{0}''
inspection.incorrect.message.format.unmatched.brace=Llave no coincidente
inspection.incorrect.message.format.unpaired.quote=Comilla sin par en el patrón de mensaje
inspection.list.remove.in.loop.display.name=Llamada a 'List.remove()' en un bucle
inspection.list.remove.in.loop.message=Se puede reemplazar por 'List.subList().clear()'
inspection.lossy.conversion.compound.assignment.display.name=La conversión implícita de ''{0}'' a ''{1}'' en la asignación compuesta puede tener pérdida de datos
inspection.lossy.conversion.compound.assignment.name=Posible conversión implícita con pérdida en asignación compuesta
inspection.meta.annotation.without.runtime.description={0} debe tener @Retention(RetentionPolicy.RUNTIME)
inspection.method.call.in.loop.ignore.known.methods.option=Ignorar métodos conocidos con efectos secundarios
inspection.new.object.equality.display.name=Nuevo objeto comparado mediante '=='
inspection.new.object.equality.message=El nuevo objeto se compara mediante ''{0}''
inspection.non.strict.comparison.equality.display.name=La desigualdad no estricta '>=' o '<=' puede reemplazarse por '=='
inspection.non.strict.comparison.equality.message=Puede reemplazarse por una igualdad
inspection.note.may.change.semantics=Puede cambiar la semántica
inspection.only.one.element.used.array=Solo se utiliza un elemento del array
inspection.only.one.element.used.display.name=Solo se utiliza un elemento
inspection.only.one.element.used.fix.family=Reemplazar por el elemento accedido
inspection.only.one.element.used.list=Solo se utiliza un elemento de la lista
inspection.only.one.element.used.string=Solo se utiliza un carácter de cadena
inspection.option.ignore.as.initial.capacity=Ignorar la capacidad inicial para StringBuilders y Collections
inspection.option.ignore.assert=Ignorar para argumentos de descripción de la sentencia assert
inspection.option.ignore.constant.initializers=Ignorar inicializadores de campos constantes
inspection.option.ignore.exceptions=Ignorar para los argumentos de constructor de las subclases de Throwable
inspection.option.ignore.in.annotations=Ignorar en las anotaciones
inspection.option.ignore.in.hashcode=Ignorar constantes en métodos 'hashCode()'
inspection.option.ignore.in.tostring=Ignorar dentro de los métodos toString()
inspection.option.ignore.nonnls=Ignorar cuando se anota mediante @NonNls
inspection.option.ignore.system.err=Ignorar para los argumentos de 'System.err.print'
inspection.option.ignore.system.out=Ignorar para los argumentos de 'System.out.print'
inspection.pattern.variable.can.be.used.display.name=Se puede usar una variable de patrón
inspection.pattern.variable.can.be.used.existing.cast.message=La variable de patrón existente ''{0}'' puede utilizarse en lugar de la expresión de conversión (cast)
inspection.pattern.variable.can.be.used.existing.fix.family.name=Reemplazar por la variable de patrón existente
inspection.pattern.variable.can.be.used.existing.fix.name=Reemplazar ''{0}'' con la variable de patrón existente ''{1}''
inspection.pattern.variable.can.be.used.existing.message=La variable de patrón existente ''{0}'' se puede utilizar en lugar de ''{1}''
inspection.pattern.variable.can.be.used.fix.family.name=Reemplazar con variable de patrón
inspection.pattern.variable.can.be.used.fix.name=Reemplazar ''{0}'' con una variable de patrón
inspection.pattern.variable.can.be.used.instead.of.cast.message=La expresión de conversión puede reemplazarse por una variable de patrón
inspection.pattern.variable.can.be.used.message=La variable ''{0}'' se puede reemplazar por una variable de patrón
inspection.pattern.variable.can.be.used.report.cast.only=Informar sobre expresiones de conversión que pueden reemplazarse por las nuevas variables de patrón introducidas
inspection.pattern.variable.instead.of.cast.can.be.used.existing.fix.name=Reemplazar la expresión de conversión por la variable de patrón existente ''{0}''
inspection.pattern.variable.instead.of.cast.can.be.used.fix.family.name=Reemplazar expresiones de conversión con una variable de patrón
inspection.redundant.arguments.message=Argumentos innecesarios
inspection.redundant.class.call.display.name=Llamada redundante a 'isInstance()' o 'cast()'
inspection.redundant.collection.operation.display.name=Operación 'Collection' redundante
inspection.redundant.collection.operation.fix.family.name=Simplificar la operación de colección
inspection.redundant.collection.operation.problem.arraycopy=Se ha creado una colección innecesaria para copiar un array
inspection.redundant.collection.removal.by.index.fix=Usar la eliminación por objeto
inspection.redundant.collection.removal.by.index.problem=La eliminación por índice puede reemplazarse por la eliminación por objeto
inspection.redundant.collection.unnecessary.contains.fix=Eliminar la comprobación ''{0}()''
inspection.redundant.collection.unnecessary.contains.problem=Comprobación ''{0}()'' innecesaria
inspection.redundant.compare.call.display.name=Llamada redundante al método 'compare()'
inspection.redundant.compare.call.fix.name=Insertar en línea la llamada a 'compare()'
inspection.redundant.embedded.expression.display.name=Expresión incrustada redundante en plantilla de cadena
inspection.redundant.embedded.expression.fix.family.name=Poner en línea la expresión incrustada
inspection.redundant.embedded.expression.message.empty=Expresión incrustada vacía redundante
inspection.redundant.embedded.expression.message.literal=Literal embebido redundante
inspection.redundant.empty.string.argument.message=Argumento de cadena vacía innecesario
inspection.redundant.explicit.variable.type.description=Se puede omitir el tipo explícito de la variable local
inspection.redundant.java.time.operation.compare.java.time.family.name=Simplificar expresión con la llamada a 'compareTo()' de 'java.time'
inspection.redundant.java.time.operation.compare.java.time.problem.descriptor=La expresión con la llamada <code>#ref()</code> de 'java.time' se puede simplificar
inspection.redundant.java.time.operation.creation.java.time.error.message=Creación redundante del objeto ''{0}''
inspection.redundant.java.time.operation.creation.java.time.error.remove.fix.message=Eliminar llamada a ''{0}''
inspection.redundant.java.time.operation.creation.java.time.error.replace.fix.message=Reemplazar con la llamada a ''{0}''
inspection.redundant.java.time.operation.creation.java.time.family.name=Simplificar la creación de objetos 'java.time'
inspection.redundant.java.time.operation.creation.java.time.redundant.call.message=Llamada a ''{0}'' redundante
inspection.redundant.java.time.operation.creation.java.time.remove.family.name=Eliminar llamada innecesaria
inspection.redundant.java.time.operation.display.name=Operación redundante en el objeto 'java.time'
inspection.redundant.java.time.operation.explicit.chrono.field.family.name=Simplificar las llamadas con argumentos explícitos 'ChronoField' o 'ChronoUnit'
inspection.redundant.java.time.operation.explicit.chrono.field.problem.descriptor=Las llamadas con argumentos 'ChronoField' o 'ChronoUnit' explícitos se pueden simplificar
inspection.redundant.length.check.display.name=Comprobación de longitud de array redundante
inspection.redundant.string.call.message=La llamada a <code>#ref()</code> es redundante #loc
inspection.redundant.string.constructor.message=<code>new #ref()</code> es redundante #loc
inspection.redundant.string.fix.family.name=Eliminar llamada redundante
inspection.redundant.string.fix.remove.str.processor.description=La plantilla de cadena se puede convertir en un literal de cadena simple
inspection.redundant.string.intern.on.constant.message=La llamada a <code>#ref()</code> en una constante de tiempo de compilación es innecesaria #loc
inspection.redundant.string.length.argument.message=Argumento de longitud de cadena innecesario
inspection.redundant.string.new.array.message=<code>#ref</code> es redundante #loc
inspection.redundant.string.operation.display.name=Operación de 'String' redundante
inspection.redundant.string.option.do.not.report.single.argument.substring=No informar llamadas redundantes a substring() con un solo argumento
inspection.redundant.string.option.do.not.report.string.constructors=No informar llamadas al constructor de String
inspection.redundant.string.remove.argument.fix.name=Eliminar argumento
inspection.redundant.string.remove.fix.name=Eliminar llamada redundante ''{0}()''
inspection.redundant.string.replace.with.arg.fix.name=Reemplazar con el argumento
inspection.redundant.string.replace.with.empty.fix.name=Reemplazar por una cadena vacía
inspection.redundant.zero.argument.message=Argumento cero innecesario
inspection.refused.bequest.super.annotated.option=Informar solo cuando el supermétodo esté anotado por:
inspection.remove.redundant.call.fix.name=Eliminar la llamada redundante a ''{0}()''
inspection.replace.on.literal.display.name=La operación de reemplazo no tiene efecto
inspection.simplifiable.compare.java.time.display.name=La expresión con una llamada a "compareTo()" de "java.time" puede simplificarse
inspection.simplifiable.compare.java.time.family.name=Simplifica expresión con llamada 'compareTo()' de 'java.time'
inspection.simplifiable.compare.java.time.problem.descriptor=La expresión con la llamada a <code>#ref()</code> de 'java.time' se puede simplificar
inspection.simplifiable.if.statement.display.name=La sentencia 'if' se puede reemplazar por una expresión condicional o booleana
inspection.simplifiable.if.statement.fix.family.name=Reemplazar 'if else' con una expresión condicional
inspection.simplifiable.if.statement.fix.name=Reemplazar ''if else'' por ''{0}''
inspection.simplifiable.if.statement.message=La sentencia 'if' puede reemplazarse por ''{0}''
inspection.simplifiable.if.statement.option.dont.warn.on.ternary=No sugerir el operador '?:'
inspection.suspicious.date.format.display.name=Patrón de formato de fecha sospechoso
inspection.suspicious.date.format.message.lower=Se utiliza el patrón ''{0}'' ({1}) en minúsculas: probablemente se pretendía usar ''{2}'' ({3})
inspection.suspicious.date.format.message.upper=Se utiliza el patrón en mayúsculas ''{0}'' ({1}): probablemente la intención era usar ''{2}'' ({3})
inspection.suspicious.package.private.access.description={0} es {1}, pero se ha declarado en un módulo diferente ''{2}''
inspection.suspicious.package.private.access.from.tests.description={0} es {1} y se utiliza en pruebas, pero se declara en el código fuente de producción
inspection.suspicious.package.private.access.from.tests.problem={0} en las pruebas sobrescribe el método package-private de {1} declarado en las fuentes de producción
inspection.suspicious.package.private.access.problem={0} sobrescribe un método package-private de {1} que está declarado en un módulo diferente ''{2}''
inspection.test.method.without.assertion.list.name=Métodos de aserción:
inspection.test.method.without.assertions.exceptions.option=Ignorar métodos de prueba que declaran excepciones
inspection.trivial.functional.expression.usage.description=Se puede simplificar la llamada al método
inspection.type.may.be.weakened.add.stop.class.family=Añadir clase de parada
inspection.type.may.be.weakened.add.stop.class.selection.popup=Seleccionar clase de parada
inspection.type.may.be.weakened.add.stop.class.selection.table=Clases de parada
inspection.type.may.be.weakened.add.stop.class.selection.table.label=Clases de parada:
inspection.type.may.be.weakened.add.stopper=Añadir como clase de detención para el debilitamiento
inspection.type.may.be.weakened.add.stopper.preview=La clase de detención se añadirá a la lista de clases de detención para esta inspección.
inspection.type.may.be.weakened.add.stopper.single=Agregar {0} como clase de parada para el debilitamiento
inspection.type.may.be.weakened.display.name=El tipo puede ser debilitado
inspection.type.may.be.weakened.do.not.weaken.inferred.variable.type=No sugerir debilitar variables declaradas como 'var'
inspection.type.may.be.weakened.field.problem.descriptor=El tipo del campo <code>#ref</code> se puede debilitar a {0} #loc
inspection.type.may.be.weakened.method.problem.descriptor=El tipo de retorno del método <code>#ref()</code> puede debilitarse a {0} #loc
inspection.type.may.be.weakened.only.weaken.to.an.interface=Solo debilitar a una interfaz
inspection.type.may.be.weakened.parameter.problem.descriptor=El tipo de parámetro <code>#ref</code> puede debilitarse a {0} #loc
inspection.type.may.be.weakened.problem.descriptor=El tipo de la variable <code>#ref</code> puede debilitarse a {0} #loc
inspection.type.may.be.weakened.quickfix=Debilitar el tipo a ''{0}''
inspection.type.may.be.weakened.weaken.type.family=Debilitar tipo
inspection.unnecessary.string.escape.report.char.literals.option=Reportar literales de caracteres
inspection.unsupported.chrono.field.unit.call.display.name=Llamada a métodos con 'java.time.temporal.ChronoUnit' y 'java.time.temporal.ChronoField' no compatibles
inspection.unsupported.chrono.value.message=Valor de argumento no admitido: {0}
inspection.unsupported.chrono.values.message=Valores de argumento no compatibles: {0}
inspection.use.of.private.field.inner.classes.option=Ignorar los accesos desde clases internas
inspection.use.of.slash.s.display.name=Uso no terminal de la secuencia de escape 's'
inspection.use.of.slash.s.fix.family=Reemplazar secuencias 's' con espacios
inspection.use.of.slash.s.message=Uso de la secuencia de escape 's' como un espacio que no está al final
inspection.use.of.slash.s.non.text.block.message=Uso de la secuencia de escape 's' fuera de bloques de texto
inspection.while.can.be.replaced.with.do.while.display.name=while' se puede reemplazar por 'do while
inspection.while.can.be.replaced.with.do.while.family.name=Reemplazar 'while' por 'do while'
inspection.while.can.be.replaced.with.do.while.message=Reemplazar 'while' por 'do while'
inspection.x.call.can.be.replaced.with.y=La llamada <code>#ref()</code> puede reemplazarse por ''{0}()''
instance.Variable.may.not.be.initialized.problem.descriptor.junit=El campo de instancia <code>#ref</code> podría no estar inicializado durante la construcción del objeto o la llamada a 'setUp()' #loc
instance.method.naming.convention.element.description=Método de instancia
instance.variable.may.not.be.initialized.display.name=El campo de instancia podría no estar inicializado
instance.variable.may.not.be.initialized.problem.descriptor=El campo de instancia <code>#ref</code> puede no estar inicializado durante la construcción del objeto #loc
instance.variable.naming.convention.element.description=Campo de instancia
instance.variable.of.concrete.class.problem.descriptor=Campo de instancia ''{0}'' de la clase concreta <code>#ref</code> #loc
instance.variable.used.before.initialized.display.name=Campo de instancia usado antes de la inicialización
instance.variable.used.before.initialized.problem.descriptor=Campo de instancia <code>#ref</code> usado antes de ser inicializado #loc
instanceof.catch.parameter.display.name=Instanceof' en el parámetro 'catch
instanceof.catch.parameter.problem.descriptor='instanceof' en el parámetro 'catch' <code>#ref</code> #loc
instanceof.check.for.this.display.name=Comprobación 'instanceof' para 'this'
instanceof.check.for.this.equality.problem.descriptor=Comparación de clases para 'this' #loc
instanceof.check.for.this.problem.descriptor=Comprobación 'instanceof' para <code>#ref</code> #loc
instanceof.concrete.class.equality.problem.descriptor=Comparación de clase con la clase concreta <code>#ref</code> #loc
instanceof.concrete.class.pattern.problem.descriptor=Prueba de patrón contra una clase concreta <code>#ref</code> #loc
instanceof.concrete.class.problem.descriptor='instanceof' de la clase concreta <code>#ref</code> #loc
instanceof.with.incompatible.interface.display.name='instanceof' con tipo incompatible
instanceof.with.incompatible.interface.problem.descriptor=''instanceof'' de una expresión con tipo ''{1}'' con {0, choice, 1#interfaz|2#clase} incompatible <code>#ref</code> #loc
instantiating.datetimeformatter.without.locale.problem.descriptor=Llamada a <code>DateTimeFormatter.#ref()</code> sin especificar un Locale en un contexto internacionalizado #loc
instantiating.object.to.get.class.object.display.name=Instanciando objeto para obtener el objeto 'Class'
instantiating.object.to.get.class.object.problem.descriptor=Instanciación de un objeto para obtener el objeto Class #loc
instantiating.object.to.get.class.object.replace.quickfix=Reemplazar con acceso directo al objeto de clase
instantiating.simpledateformat.without.locale.display.name='SimpleDateFormat' sin configuración regional
instantiating.simpledateformat.without.locale.problem.descriptor=Instanciación de un <code>#ref</code> sin especificar un Locale en un contexto internacionalizado #loc
instantiation.utility.class.display.name=Instanciación de una clase de utilidad
instantiation.utility.class.problem.descriptor=Instanciación de la clase de utilidad <code>#ref</code> #loc
int.literal.may.be.long.literal.display.name=La conversión a 'long' puede ser un literal 'long'
int.literal.may.be.long.literal.problem.descriptor=<code>#ref</code> puede reemplazarse por ''{0}'' #loc
integer.division.in.floating.point.context.display.name=División entera en contexto de punto flotante
integer.division.in.floating.point.context.fix.family.name=Convertir el numerador a un tipo de punto flotante
integer.division.in.floating.point.context.fix.name=Convertir el numerador a ''{0}''
integer.division.in.floating.point.context.problem.descriptor=<code>#ref</code>: división entera en un contexto de punto flotante #loc
integer.multiplication.implicit.cast.to.long.display.name=Multiplicación o desplazamiento de enteros convertidos implícitamente a 'long'
integer.multiplication.implicit.cast.to.long.option=<html>Ignorar las expresiones en las que se demuestre estáticamente que el desbordamiento es imposible</html>
integer.multiplication.implicit.cast.to.long.problem.descriptor=#ref: multiplicación de enteros convertida implícitamente a long #loc
integer.multiplication.implicit.cast.to.long.quickfix=Convertir a long
integer.shift.implicit.cast.to.long.problem.descriptor=#ref: Desplazamiento de enteros convertido implícitamente a long #loc
interface.clashes.with.object.class.display.name=El método de la interfaz entra en conflicto con un método en 'Object'
interface.clashes.with.object.class.problem.descriptor=<code>#ref()</code> entra en conflicto con un método en 'java.lang.Object'
interface.may.be.annotated.functional.display.name=La interfaz puede anotarse como '@FunctionalInterface'
interface.may.be.annotated.functional.problem.descriptor=La interfaz <code>#ref</code> puede anotarse con @FunctionalInterface
interface.naming.convention.element.description=Interfaz
interface.never.implemented.display.name=Interfaz que no tiene subclases concretas
interface.never.implemented.option=Ignorar interfaces que solo declaran constantes
interface.never.implemented.problem.descriptor=La interfaz <code>#ref</code> no tiene ninguna subclase concreta #loc
interface.one.inheritor.display.name=Interfaz con un único heredero directo
interface.one.inheritor.problem.descriptor=La interfaz <code>#ref</code> tiene solo un heredero directo #loc
introduce.holder.class.quickfix=Introducir clase holder
introduce.variable.may.change.semantics.quickfix=Introducir variable (puede cambiar la semántica)
introduce.variable.quickfix=Introducir variable
invert.method.quickfix=Invertir método
invert.quickfix=Invertir ''{0}''
invert.quickfix.family.name=Invertir booleano
iterator.hasnext.which.calls.next.display.name=Iterator.hasNext()' que llama a 'next()
iterator.hasnext.which.calls.next.problem.descriptor=<code>Iterator.{0}()</code> contiene una llamada a ''#ref()'' #loc
iterator.next.does.not.throw.nosuchelementexception.display.name=Iterator.next()' que no puede lanzar 'NoSuchElementException
iterator.next.does.not.throw.nosuchelementexception.problem.descriptor=<code>Iterator.#ref()</code> que no puede lanzar 'NoSuchElementException' #loc
java.lang.import.display.name=Importación innecesaria del paquete 'java.lang'
java.lang.import.problem.descriptor=Importación innecesaria del paquete 'java.lang' #loc
jdbc.execute.with.non.constant.string.display.name=Llamada a 'Statement.execute()' con una cadena no constante
jdbc.execute.with.non.constant.string.problem.descriptor=Llamada a <code>Statement.#ref()</code> con un argumento no constante #loc
jdbc.prepare.statement.with.non.constant.string.display.name=Llamada a 'Connection.prepare*()' con una cadena no constante
jdbc.prepare.statement.with.non.constant.string.problem.descriptor=Llamada a <code>Connection.#ref()</code> con un argumento no constante #loc
jdbc.resource.opened.not.closed.display.name=Recurso JDBC abierto pero no cerrado de forma segura
jndi.resource.opened.not.closed.display.name=Recurso JNDI abierto pero no cerrado de forma segura
junit.abstract.test.class.naming.convention.element.description=Clase de prueba abstracta
junit.test.class.naming.convention.element.description=Clase de prueba
junit.test.suite.naming.convention.element.description=Suite de pruebas
junit3.method.naming.convention.element.description=Método de prueba JUnit 3
junit4.method.naming.convention.element.description=Método de prueba JUnit 4+
key.set.iteration.may.use.entry.set.display.name=La iteración sobre 'keySet()' se puede optimizar
key.set.iteration.may.use.entry.set.problem.descriptor=La iteración sobre <code>#ref</code> puede reemplazarse por una iteración ''{0}'' #loc
key.set.iteration.may.use.entry.set.quickfix=Optimizar la iteración de Map
labeled.statement.display.name=Sentencia etiquetada
labeled.statement.problem.descriptor=Sentencia con etiqueta <code>#ref:</code> #loc
lambda.body.can.be.code.block.name=El cuerpo de la lambda puede ser un bloque de código
lambda.body.can.be.code.block.quickfix=Expandir el cuerpo de la lambda a {…}
lambda.can.be.replaced.with.anonymous.name=La lambda se puede reemplazar por una clase anónima
lambda.can.be.replaced.with.anonymous.quickfix=Reemplazar lambda con clase anónima
lambda.parameter.hides.member.variable.display.name=El parámetro lambda oculta un campo
lambda.parameter.hides.member.variable.ignore.invisible.option=Ignorar campos que no son realmente visibles desde la lambda
lambda.parameter.hides.member.variable.problem.descriptor=El parámetro lambda <code>#ref</code> oculta un campo en la clase ''{0}'' #loc
lambda.parameter.naming.convention.display.name=Convención de nomenclatura de parámetros lambda
lambda.parameter.naming.convention.element.description=Parámetro lambda
lambda.parameter.type.can.be.specified.descriptor=Los tipos de parámetros lambda pueden expandirse a {0}
lambda.parameter.type.can.be.specified.family.quickfix=Especificar el tipo de parámetro lambda
lambda.parameter.type.can.be.specified.name=Se puede especificar el tipo del parámetro lambda
lambda.parameter.type.can.be.specified.quickfix=Expandir los tipos de parámetros a {0}
lambda.unfriendly.constructor.overload.problem.descriptor=Sobrecarga del constructor <code>#ref()</code> no amigable para lambdas
lambda.unfriendly.method.overload.display.name=Sobrecarga de métodos no amigable con lambdas
lambda.unfriendly.method.overload.problem.descriptor=Sobrecarga del método <code>#ref()</code> poco amigable con lambdas
large.array.allocation.no.outofmemoryerror.display.name=Asignación de un array grande sin comprobación de OutOfMemoryError
large.array.allocation.no.outofmemoryerror.maximum.number.of.elements.option=Número máximo de elementos:
large.array.allocation.no.outofmemoryerror.problem.descriptor=Asignación de un array de gran tamaño sin comprobación de la condición de falta de memoria #loc
large.initializer.primitive.type.array.display.name=Inicializador excesivamente grande para un array de tipo primitivo
large.initializer.primitive.type.array.maximum.number.of.elements.option=Número máximo de elementos:
large.initializer.primitive.type.array.problem.descriptor=Inicializador de array primitivo con demasiados elementos ({0}) #loc
law.of.demeter.display.name=Ley de Demeter
law.of.demeter.field.problem.descriptor=El acceso a <code>#ref</code> viola la Ley de Demeter #loc
law.of.demeter.ignore.library.calls.option=Ignorar llamadas a métodos de biblioteca y acceso a campos de biblioteca
law.of.demeter.problem.descriptor=La llamada a <code>#ref()</code> viola la Ley de Demeter #loc
length.one.string.in.indexof.display.name=Argumento de cadena de un solo carácter en la llamada a 'String.indexOf()'
length.one.strings.in.concatenation.display.name=Concatenación de cadenas de un solo carácter
length.one.strings.in.concatenation.replace.quickfix=Reemplazar por carácter
limited.scope.inner.class.display.name=Clase local
limited.scope.inner.class.problem.descriptor=Clase local <code>#ref</code> #loc
list.indexof.replaceable.by.contains.display.name=La expresión 'List.indexOf()' se puede reemplazar por 'contains()'
listener.may.use.adapter.display.name=La clase puede extender el adaptador en lugar de implementar el listener
listener.may.use.adapter.emtpy.methods.option=&Solo advertir cuando se encuentren métodos de implementación vacíos
listener.may.use.adapter.fix.family.name=Reemplazar con adaptador
listener.may.use.adapter.problem.descriptor=La clase ''{0}'' puede extender ''{1}'' en lugar de implementar <code>#ref</code> #loc
literal.as.arg.to.string.equals.display.name=El literal de cadena puede ser el calificador de 'equals()'
literal.as.arg.to.string.equals.flip.quickfix=Invertir ''{0}()''
literal.as.arg.to.string.equals.problem.descriptor=El literal #ref es el argumento de ''{0}()'', en lugar de su calificador #loc
load.library.with.non.constant.string.display.name=Llamada a 'System.loadLibrary()' con una cadena no constante
load.library.with.non.constant.string.problem.descriptor=Llamada a <code>{0}.#ref()</code> con un argumento no constante #loc
local.variable.hides.member.variable.display.name=La variable local oculta el campo
local.variable.hides.member.variable.ignore.option=Ignorar variables locales en un contexto estático que oculten campos no estáticos
local.variable.hides.member.variable.problem.descriptor=La variable local <code>#ref</code> oculta el campo en la clase ''{0}'' #loc
local.variable.naming.convention.display.name=Convención de nomenclatura de variables locales
local.variable.naming.convention.element.description=Variable local
local.variable.naming.convention.ignore.catch.option=Ignorar parámetros del bloque 'catch'
local.variable.naming.convention.ignore.option=Ignorar parámetros del bucle for
local.variable.of.concrete.class.problem.descriptor=Variable local ''{0}'' de la clase concreta <code>#ref</code> #loc
log.condition.text=Texto de la condición de registro
log.method.name=Registrar nombre del método
log.statement.guarded.by.log.condition.display.name=Llamada de registro no protegida por una condición de log
log.statement.guarded.by.log.condition.flag.all.unguarded.option=Marcar todas las llamadas de registro no protegidas
log.statement.guarded.by.log.condition.problem.descriptor=Llamadas de registro <code>#ref()</code> no protegidas por una condición de registro #loc
log.statement.guarded.by.log.condition.quickfix=Envolver con una condición de log
log4j.use.parameterized.logger=Para Log4j 2, use las mismas correcciones que para el registrador parametrizado
log4j.use.parameterized.logger.description=Para Log4j 2, utiliza las correcciones como para el registrador parametrizado si el tipo no se puede inferir; de lo contrario, no se propondrán correcciones
logger.class.name=Nombres de clases de logger:
logger.factory.class.name=Nombre de la clase de la fábrica de registradores
logger.factory.method.name=Nombre del método de la fábrica de loggers
logger.initialized.with.foreign.class.display.name=Logger inicializado con una clase externa
logger.initialized.with.foreign.class.fix.family.name=Reemplazar clase externa
logger.initialized.with.foreign.class.ignore.non.public.classes.option=Ignorar loggers en clases no públicas
logger.initialized.with.foreign.class.ignore.not.final.field=Ignorar los registradores no inicializados en un campo final
logger.initialized.with.foreign.class.ignore.super.class.option=Ignorar loggers inicializados con una superclase
logger.initialized.with.foreign.class.problem.descriptor=Logger inicializado con una clase externa <code>#ref</code> #loc
logger.name.option=Nombre de la &clase del logger:
long.literals.ending.with.lowercase.l.display.name=Literal 'long' que termina con 'l' en lugar de 'L'
long.literals.ending.with.lowercase.l.problem.descriptor=El literal 'long' <code>#ref</code> termina con una 'l' minúscula #loc
loop.condition.not.updated.inside.loop.display.name=Variable de bucle no actualizada dentro del bucle
loop.condition.not.updated.inside.loop.problem.descriptor=La condición '#ref' no se actualiza dentro del bucle #loc
loop.statements.that.dont.loop.display.name=Sentencia de bucle que no itera
loop.statements.that.dont.loop.problem.descriptor=La sentencia <code>#ref</code> no itera #loc
loop.variable.not.updated.inside.loop.option.nonlocal=Ignorar posibles cambios no locales
loop.variable.not.updated.inside.loop.problem.descriptor=La variable '#ref' no se actualiza dentro del bucle #loc
loop.with.implicit.termination.condition.display.name=Bucle con condición de terminación implícita
loop.with.implicit.termination.condition.dowhile.problem.descriptor=Bucle <code>#ref-while</code> con condición de terminación implícita #loc
loop.with.implicit.termination.condition.problem.descriptor=Bucle <code>#ref</code> con condición de terminación implícita #loc
loop.with.implicit.termination.condition.quickfix=Hacer la condición explícita
magic.character.display.name=Carácter mágico
magic.character.problem.descriptor=Carácter mágico <code>#ref</code> en un contexto internacionalizado #loc
magic.number.display.name=Número mágico
magic.number.problem.descriptor=Número mágico <code>#ref</code> #loc
make.class.final.fix.family.name=Hacer clase final
make.class.final.fix.name=Hacer que la clase ''{0}'' sea ''final''
make.constructor.public=Hacer que el constructor sea 'public'
make.field.final.fix.family.name=Hacer final
make.field.final.quickfix=Hacer que ''{0}'' sea ''final''
make.field.static.final.fix.family.name=Hacer static final
make.initialization.explicit.quickfix=Hacer la inicialización explícita
make.method.ctr.quickfix=Convertir método en constructor
make.method.final.fix.family.name=Hacer que el método sea 'final'
make.method.final.fix.name=Hacer el método ''{0}()'' ''final''
make.package.private.fix.family.name=Hacer package-private
make.static.final.quickfix=Hacer ''{0}'' static final
make.static.quickfix=Hacer 'static'
malformed.format.string.display.name=Cadena de formato mal formada
malformed.format.string.problem.descriptor.arguments.do.not.match.type=El tipo de argumento ''{0}'' no coincide con el tipo del especificador de formato ''{1}'' #loc
malformed.format.string.problem.descriptor.at.least.too.few.arguments=Muy pocos argumentos para la cadena de formato (encontrados: {0}, se esperaban al menos: {1}) #loc
malformed.format.string.problem.descriptor.illegal=Especificador de cadena de formato no válido: {0} #loc
malformed.format.string.problem.descriptor.malformed=La cadena de formato <code>#ref</code> está mal formada #loc
malformed.format.string.problem.descriptor.too.few.arguments=Muy pocos argumentos para la cadena de formato (encontrados: {0}, esperados: {1}) #loc
malformed.format.string.problem.descriptor.too.many.arguments=Demasiados argumentos para la cadena de formato (encontrados: {0}, esperados: {1}) #loc
manual.array.copy.display.name=Copia manual de array
manual.array.copy.problem.descriptor=Copia manual de array #loc
manual.array.to.collection.copy.display.name=Copia manual de array a colección
manual.array.to.collection.copy.problem.descriptor=Copia manual de array a colección #loc
map.replaceable.by.enum.map.display.name=Map' puede reemplazarse por 'EnumMap
map.replaceable.by.enum.map.problem.descriptor=<code>#ref</code> se puede reemplazar por 'EnumMap' #loc
mark.modules.as.loaded.together.fix.family.name=Marcar módulos como cargados juntos
mark.modules.as.loaded.together.fix.text=Marcar los módulos ''{0}'' y ''{1}'' como cargados juntos
markdown.documentation.comments.migration.display.name=El comentario Javadoc puede ser un comentario de documentación Markdown
markdown.documentation.comments.migration.fix=Convertir a comentario de documentación Markdown
marker.interface.display.name=Interfaz marcadora
marker.interface.problem.descriptor=Interfaz marcadora <code>#ref</code> #loc
masked.assertion.display.name=Aserción suprimida por 'catch'
masked.assertion.problem.description=''{0}'' no puede fallar ya que está suprimido por un ''catch'' circundante
math.random.cast.to.int.display.name=Math.random()' convertido a 'int
math.random.cast.to.int.problem.descriptor=<code>#ref</code> convertido a ''{0}'' siempre se redondea hacia abajo a ''0'' #loc
math.random.cast.to.int.quickfix=Añadir paréntesis para realizar la multiplicación antes de la conversión
math.rounding.with.int.argument.display.name=Llamar al redondeo de Math con un argumento 'int'
math.rounding.with.int.argument.family.name=Simplificar las llamadas de redondeo
math.rounding.with.int.argument.problem.descriptor=<code>#ref()</code> con un argumento de tipo 'int' #loc
math.rounding.with.int.argument.quickfix=Simplificar la llamada a ''{0}()''
meta.annotation.without.runtime.retention=Anotación de prueba sin la anotación '@Retention(RUNTIME)'
method.call.in.loop.condition.display.name=Llamada a método en la condición del bucle
method.call.in.loop.condition.problem.descriptor=Llamada al método <code>#ref()</code> en la condición del bucle #loc
method.can.be.variable.arity.method.display.name=El método puede tener un parámetro varargs
method.can.be.variable.arity.method.ignore.all.primitive.arrays.option=Ignorar todos los tipos de arrays primitivos
method.can.be.variable.arity.method.ignore.byte.short.option=Ignorar parámetros con tipo byte[] o short[]
method.can.be.variable.arity.method.ignore.multidimensional.arrays.option=Ignorar parámetros de arreglos multidimensionales
method.can.be.variable.arity.method.ignore.multiple.arrays.option=Ignorar métodos con múltiples parámetros de array
method.can.be.variable.arity.method.problem.descriptor=<code>#ref()</code> se puede convertir en un método varargs #loc
method.complexity.limit.option=Límite de complejidad del método:
method.count.ignore.getters.setters.option=&Ignorar métodos getter y setter simples
method.count.limit.option=Límite de número de métodos:
method.coupling.display.name=Método excesivamente acoplado
method.coupling.limit.option=Límite de acoplamiento del método:
method.coupling.problem.descriptor=<code>#ref</code> está excesivamente acoplado (n.º de clases referenciadas = {0}) #loc
method.may.be.static.display.name=El método puede ser 'static'
method.may.be.static.empty.option=Ignorar métodos vacíos
method.may.be.static.ignore.default.methods.option=Ignorar métodos 'default'
method.may.be.static.only.option=Solo comprobar métodos 'private' o 'final'
method.may.be.static.problem.descriptor=El método <code>#ref()</code> puede ser 'static' #loc
method.may.be.static.replaces.qualifiers.with.class.references.option=La corrección rápida reemplaza los calificadores de instancia por referencias de clase
method.may.be.synchronized.display.name=El método con un único bloque 'synchronized' puede reemplazarse por un método 'synchronized'
method.may.be.synchronized.problem.descriptor=El método <code>#ref()</code> con un bloque synchronized puede ser un método synchronized #loc
method.may.be.synchronized.quickfix=Sincronizar el método y eliminar el bloque synchronized
method.name.regex=Expresión regular del nombre del método
method.name.same.as.class.name.display.name=Nombre de método igual al nombre de la clase
method.name.same.as.class.name.problem.descriptor=El nombre del método <code>#ref</code> es el mismo que el de su clase #loc
method.name.same.as.parent.name.display.name=Nombre del método igual al nombre de la clase padre
method.name.same.as.parent.name.problem.descriptor=El nombre del método <code>#ref</code> es el mismo que el de su clase padre #loc
method.names.differ.only.by.case.display.name=Nombres de métodos que solo se diferencian en mayúsculas y minúsculas
method.names.differ.only.by.case.problem.descriptor=El nombre del método <code>#ref</code> y el nombre del método ''{0}'' solo se diferencian en las mayúsculas y minúsculas #loc
method.only.used.from.inner.class.display.name=Método privado usado solo desde la clase interna
method.only.used.from.inner.class.ignore.option=Ignorar métodos llamados desde una clase &anónima o local
method.only.used.from.inner.class.problem.descriptor=El método <code>#ref()</code>#loc solo se utiliza desde {1, choice, 1#la clase|2#la interfaz|3#una clase anónima derivada de|4#el tipo de anotación|5#la enumeración|6#el registro}{0, choice, 1# interna|2# local|3#} ''{2}'' #loc
method.overloads.display.name=Sobrecarga posiblemente no intencionada de un método de la superclase
method.overloads.problem.descriptor=El método <code>#ref()</code> sobrecarga un método compatible de una superclase cuando es posible que se pretendiera sobrescribirlo #loc
method.overloads.report.incompatible.option=Informar incluso si los tipos de parámetros no son compatibles
method.overrides.inaccessible.method.display.name=El método sobrescribe un método inaccesible de la superclase
method.overrides.package.local.method.problem.descriptor=El método <code>#ref()</code> sobrescribe un método package-private de una superclase ubicada en otro paquete #loc
method.overrides.private.display.name.problem.descriptor=El método <code>#ref()</code> sobrescribe un método 'private' de una superclase #loc
method.overrides.static.display.name=El método intenta sobrescribir un método 'static' de la superclase
method.overrides.static.problem.descriptor=El método <code>#ref()</code> intenta sobrescribir un método estático de una superclase #loc
method.ref.can.be.replaced.with.lambda.name=La referencia a método se puede reemplazar por lambda
method.ref.can.be.replaced.with.lambda.quickfix=Reemplazar referencia de método con lambda
method.ref.can.be.replaced.with.lambda.quickfix.no.side.effects=Mantener los posibles efectos secundarios dentro de la lambda
method.ref.can.be.replaced.with.lambda.quickfix.side.effects=Extraer posibles efectos secundarios a variables
method.return.always.constant.display.name=El método devuelve una constante por clase
method.return.always.constant.problem.descriptor=El método <code>#ref()</code> y todos sus derivados siempre devuelven constantes
method.return.concrete.class.problem.descriptor=El método devuelve una clase concreta <code>#ref</code> #loc
method.with.multiple.loops.display.name=Método con múltiples bucles
method.with.multiple.loops.problem.descriptor=<code>#ref</code> contiene {0} bucles #loc
mismatched.read.write.array.display.name=Lectura y escritura de array no coincidentes
mismatched.read.write.array.problem.descriptor.read.not.write=El contenido del array <code>#ref</code> se lee, pero nunca se escribe #loc
mismatched.read.write.array.problem.descriptor.write.not.read=El contenido del array <code>#ref</code> se escribe, pero nunca se lee #loc
mismatched.string.builder.queried.problem.descriptor=El contenido de <code>{0} #ref</code> se consulta, pero nunca se actualiza #loc
mismatched.string.builder.query.update.display.name=Consulta y actualización de 'StringBuilder' no coincidentes
mismatched.string.builder.updated.problem.descriptor=El contenido de <code>{0} #ref</code> se actualiza, pero nunca se consulta #loc
mismatched.update.collection.display.name=Consulta y actualización de colección no coincidentes
mismatched.update.collection.problem.description.no.effect.updates=Las operaciones de actualización en la colección vacía <code>#ref</code> no tienen efecto #loc
mismatched.update.collection.problem.description.queried.empty=Se consulta el contenido de la colección vacía <code>#ref</code>, pero nunca se rellena #loc
mismatched.update.collection.problem.description.queried.not.updated=Se consulta el contenido de la colección <code>#ref</code>, pero nunca se actualiza #loc
mismatched.update.collection.problem.description.updated.not.queried=El contenido de la colección <code>#ref</code> se actualiza, pero nunca se consulta #loc
mismatched.update.collection.problem.descriptor.updated.not.queried=El contenido de la colección #ref está actualizado, pero nunca se ha consultado. #loc
misordered.assert.equals.arguments.display.name=Argumentos de 'assertEquals()' en orden incorrecto
misordered.assert.equals.arguments.flip.quickfix=Intercambiar argumentos comparados
misordered.assert.equals.arguments.problem.descriptor=Argumentos de <code>#ref()</code> en orden incorrecto #loc
missing.add.deprecated.javadoc.tag.quickfix=Añadir explicación de la etiqueta Javadoc '@deprecated'
missing.deprecated.annotation.add.quickfix=Añadir la anotación '@Deprecated'
missing.deprecated.annotation.display.name=Falta la anotación '@Deprecated'
missing.deprecated.annotation.problem.descriptor=Falta la anotación '@Deprecated' #loc
missing.deprecated.tag.option=Advertir sobre la falta de explicación de la etiqueta Javadoc @deprecated
missing.deprecated.tag.problem.descriptor=Falta la explicación de la etiqueta Javadoc '@deprecated' #loc
missing.override.annotation.display.name=Falta la anotación '@Override'
missing.override.annotation.in.overriding.problem.descriptor=Los métodos que sobrescriben no están anotados con '@Override'
missing.override.annotation.problem.descriptor=Falta la anotación '@Override' en <code>#ref()</code> #loc
missing.override.warn.on.super.option=Destacar el método cuando no todos sus métodos de sobrescritura tengan la anotación '@Override'
missing.package.html.problem.descriptor=Al paquete ''{0}'' le falta un archivo <code>package.html</code>
missing.package.info.display.name=Falta 'package-info.java'
missing.package.info.problem.descriptor=Al paquete ''{0}'' le falta el archivo <code>package-info.java</code>
missing.serial.annotation.display.name=Se puede utilizar la anotación '@Serial'
missing.serial.annotation.on.field.problem.descriptor=<code>#ref</code> se puede anotar con la anotación '@Serial'
missing.serial.annotation.on.method.problem.descriptor=<code>#ref()</code> se puede anotar con la anotación '@Serial'
missorted.modifiers.allowed.place=Las anotaciones TYPE_USE siguen las opciones de generación
missorted.modifiers.allowed.place.description=Cuando se activa esta opción, se informa de las anotaciones TYPE_USE de destino si no están situadas de acuerdo con la opción <pre>{0}</pre> en <pre>Ajustes | Editor | Estilo de código | Java | Generación de código.</pre>Cuando se desactiva esta opción, las anotaciones TYPE_USE de destino se permiten tanto directamente antes del tipo como antes de las palabras clave de los modificadores.
missorted.modifiers.display.name=Modificadores mal ordenados
missorted.modifiers.problem.descriptor=Modificadores mal ordenados <code>{0}</code> #loc
missorted.modifiers.require.option=Comprobar el orden de las anotaciones
missorted.modifiers.require.option.description=Use esta opción para informar de las anotaciones en la posición incorrecta: anotaciones con <code>ElementType.TYPE_USE</code> que <em>no</em> estén directamente antes del tipo y después de las palabras clave de los modificadores, u otras anotaciones que <em>no</em> estén antes de las palabras clave de los modificadores. Cuando esta opción está desactivada, se permiten las anotaciones tanto antes como después de las palabras clave de los modificadores. Las anotaciones situadas entre las palabras clave de los modificadores siempre se informarán.
missorted.modifiers.sort.quickfix=Ordenar modificadores
misspelled.equals.display.name=Equal()' en lugar de 'equals()
misspelled.equals.problem.descriptor=El método <code>#ref()</code> probablemente debería ser 'equals()' #loc
module.with.too.few.classes.display.name=Módulo con muy pocas clases
module.with.too.few.classes.min.option=Número mínimo de clases:
module.with.too.few.classes.problem.descriptor=El módulo ''{0}'' contiene muy pocas clases ({1} < {2})
module.with.too.many.classes.display.name=Módulo con demasiadas clases
module.with.too.many.classes.max.option=Número máximo de clases:
module.with.too.many.classes.problem.descriptor=El módulo ''{0}'' contiene demasiadas clases ({1} > {2})
move.anonymous.to.inner.quickfix=Convertir a clase interna con nombre
move.class.quickfix=Mover clase
move.exception.to.javadoc.fix.family.name=Mover a Javadoc '@throws'
move.local.to.inner.quickfix=Convertir en clase interna
multi.catch.can.be.split.name=Multi-catch se puede dividir en bloques catch separados
multi.catch.can.be.split.quickfix=Dividir multi-catch en bloques 'catch' separados
multiple.declaration.array.only.option=Advertir solo sobre diferentes dimensiones de array en una única declaración
multiple.declaration.display.name=Múltiples variables en una declaración
multiple.declaration.ignore.for.option=Ignorar las declaraciones de bucles 'for'
multiple.declaration.problem.descriptor=Múltiples variables en una sola declaración #loc
multiple.loggers.display.name=Clase con múltiples loggers
multiple.loggers.problem.descriptor=La clase <code>#ref</code> declara varios loggers #loc
multiple.return.points.per.method.display.name=Método con múltiples puntos de retorno
multiple.return.points.per.method.problem.descriptor=<code>#ref</code> tiene {0} puntos de retorno #loc
multiple.top.level.classes.in.file.display.name=Múltiples clases de nivel superior en un solo archivo
multiple.top.level.classes.in.file.problem.descriptor=Múltiples clases de nivel superior en el archivo
multiple.typed.declaration.problem.descriptor=Variables con diferentes dimensiones de array en una sola declaración #loc
multiply.or.divide.by.power.of.two.display.name=Multiplicación o división por una potencia de dos
multiply.or.divide.by.power.of.two.divide.option=Comprobar también las divisiones por una potencia de dos
multiply.or.divide.by.power.of.two.replace.quickfix=Reemplazar por desplazamiento
naked.notify.display.name='notify()' o 'notifyAll()' sin el cambio de estado correspondiente
naked.notify.problem.descriptor=Llamada a <code>#ref()</code> sin el cambio de estado correspondiente #loc
naming.convention.problem.descriptor.long=El nombre de {0} <code>#ref</code> es demasiado largo ({1} > {2}) #loc
naming.convention.problem.descriptor.regex.mismatch=El nombre de {0} <code>#ref</code> no coincide con la expresión regular ''{1}'' #loc
naming.convention.problem.descriptor.short=El nombre de {0} <code>#ref</code> es demasiado corto ({1} < {2}) #loc
native.method.display.name=Método nativo
native.method.naming.convention.element.description=Método 'native'
native.method.problem.descriptor=Los métodos declarados <code>#ref</code> no son portables #loc
negated.conditional.display.name=Expresión condicional con condición negada
negated.conditional.expression.display.name=Expresión condicional negada
negated.conditional.expression.problem.descriptor=Negación de expresión condicional #loc
negated.conditional.expression.quickfix=Eliminar negación
negated.conditional.invert.quickfix=Invertir condición
negated.conditional.problem.descriptor=Expresión condicional con condición negada #loc
negated.equality.expression.display.name=Expresión de igualdad negada
negated.equality.expression.problem.descriptor=Negando ''{0}'' #loc
negated.equality.expression.quickfix=Eliminar negación
negated.if.else.display.name=Sentencia 'if' con condición negada
negated.if.else.ignore.negated.null.option=Ignorar comparaciones '!= null'
negated.if.else.ignore.negated.zero.option=Ignorar comparaciones '!= 0'
negated.if.else.invert.quickfix=Invertir condición 'if'
negated.if.else.problem.descriptor=Sentencia <code>#ref</code> con condición negada #loc
negative.int.constant.in.long.context.display.name=Constante hexadecimal int negativa en un contexto long
negative.int.constant.in.long.context.fix.add.suffix=Añadir el sufijo 'L' (cambia la semántica)
negative.int.constant.in.long.context.fix.convert=Convertir a constante long (preserva la semántica)
negatively.named.boolean.variable.display.name=Variable booleana con nombre negativo
negatively.named.boolean.variable.problem.descriptor=La variable booleana <code>#ref</code> tiene un nombre negativo #loc
nested.assignment.display.name=Asignación anidada
nested.assignment.problem.descriptor=Resultado de la expresión de asignación utilizado #loc
nested.conditional.expression.display.name=Expresión condicional anidada
nested.conditional.expression.problem.descriptor=Expresión condicional anidada <code>#ref</code> #loc
nested.method.call.display.name=Llamada a método anidada
nested.method.call.ignore.option=Ignorar llamadas a métodos anidados en los inicializadores de campos
nested.method.call.problem.descriptor=Llamada a método anidada <code>#ref()</code> #loc
nested.switch.statement.display.name=Sentencia 'switch' anidada
nested.switch.statement.problem.descriptor=<code>#ref</code> {0} anidado #loc
nested.synchronized.statement.display.name=Sentencia 'synchronized' anidada
nested.synchronized.statement.problem.descriptor=Sentencia <code>#ref</code> anidada #loc
nested.try.statement.display.name=Sentencia 'try' anidada
nested.try.statement.problem.descriptor=Sentencia <code>#ref</code> anidada #loc
nesting.depth.display.name=Método con anidamiento excesivo
nesting.depth.limit.option=Límite de profundidad de anidamiento:
nesting.depth.problem.descriptor=<code>#ref</code> está excesivamente anidado (profundidad máxima de anidamiento = {0}) #loc
new.exception.without.arguments.display.name=Constructor de excepciones llamado sin argumentos
new.exception.without.arguments.problem.descriptor=<code>new #ref()</code> sin argumentos #loc
new.method.naming.convention.display.name=Convención de nomenclatura de métodos
new.string.buffer.replaceable.by.string.problem.descriptor=<code>#ref</code> puede reemplazarse por 'String' #loc
new.string.buffer.with.char.argument.display.name=Llamada al constructor StringBuilder con argumento 'char'
new.string.buffer.with.char.argument.problem.descriptor=<code>new #ref()</code> con argumento de tipo 'char' #loc
new.string.buffer.with.char.argument.quickfix=Reemplazar el argumento char por un literal String
no.logger.display.name=Clase sin logger
no.logger.problem.descriptor=La clase <code>#ref</code> no declara un logger #loc
non.atomic.operation.on.volatile.field.display.name=Operación no atómica en un campo 'volatile'
non.atomic.operation.on.volatile.field.problem.descriptor=Operación no atómica en el campo volatile <code>#ref</code> #loc
non.boolean.method.name.must.not.start.with.question.display.name=El nombre de un método no booleano no debe comenzar con una palabra interrogativa
non.boolean.method.name.must.not.start.with.question.problem.descriptor=El nombre de método no booleano <code>#ref</code> comienza con una palabra interrogativa #loc
non.comment.source.statements.display.name=Método demasiado largo
non.comment.source.statements.limit.option=Límite de sentencias de código fuente sin comentarios:
non.comment.source.statements.problem.descriptor=<code>#ref</code> es demasiado largo (n.º de sentencias de código sin comentarios = {0}) #loc
non.constant.logger.display.name=Registrador no constante
non.constant.logger.problem.descriptor=Campo de registrador no constante <code>#ref</code> #loc
non.exception.name.ends.with.exception.display.name=Nombre de clase que no es una excepción termina en 'Exception'
non.exception.name.ends.with.exception.problem.descriptor=Nombre de clase que no es una excepción <code>#ref</code> termina en 'Exception' #loc
non.exception.name.ends.with.exception.quickfix=Hacer que ''{0}'' extienda ''java.lang.Exception''
non.final.clone.display.name='clone()' no final en un contexto seguro
non.final.clone.problem.descriptor=Método <code>#ref()</code> no final, comprometiendo la seguridad #loc
non.final.field.compareto.display.name=Campo no final referenciado en 'compareTo()'
non.final.field.compareto.problem.descriptor=Campo no final <code>#ref</code> accedido en 'compareTo()' #loc
non.final.field.in.enum.display.name=Campo no final en 'enum'
non.final.field.in.enum.problem.descriptor=Campo no final <code>#ref</code> en el enum ''{0}'' #loc
non.final.field.in.enum.quickfix.option=Ignorar los campos que no pueden ser 'final'
non.final.field.in.equals.display.name=Campo no final referenciado en 'equals()'
non.final.field.in.equals.problem.descriptor=Campo no final <code>#ref</code> accedido en 'equals()' #loc
non.final.field.in.hashcode.display.name=Campo no final referenciado en 'hashCode()'
non.final.field.in.hashcode.problem.descriptor=Campo no final <code>#ref</code> accedido en 'hashCode()' #loc
non.final.field.of.exception.display.name=Campo no final de la clase 'Exception'
non.final.field.of.exception.problem.descriptor=Campo no final <code>#ref</code> de la clase de excepción #loc
non.final.static.variable.initialization.display.name=Se utiliza un campo estático no final durante la inicialización de la clase
non.final.static.variable.initialization.problem.descriptor=Campo static no final <code>#ref</code> utilizado durante la inicialización de la clase #loc
non.final.utility.class.display.name=Clase de utilidad no es 'final'
non.final.utility.class.problem.descriptor=La clase de utilidad <code>#ref</code> no es 'final' #loc
non.protected.constructor.in.abstract.class.display.name=Constructor público en clase abstracta
non.protected.constructor.in.abstract.class.ignore.option=Ignorar para clases no públicas
non.protected.constructor.in.abstract.class.problem.descriptor=El constructor <code>#ref()</code> de una clase abstracta no debe declararse 'public' #loc
non.public.clone.display.name=El método 'clone()' no es 'public'
non.public.clone.problem.descriptor=El método <code>#ref()</code> no es 'public' #loc
non.reproducible.math.call.display.name=Llamada no reproducible a 'Math'
non.reproducible.math.call.problem.descriptor=<code>Math.#ref()</code> puede producir resultados no reproducibles #loc
non.reproducible.math.call.replace.quickfix=Reemplazar con la llamada a 'StrictMath'
non.serializable.@interface.with.serialversionuid.problem.descriptor=La @interface no serializable <code>#ref</code> define un campo 'serialVersionUID' #loc
non.serializable.anonymous.with.serialversionuid.problem.descriptor=La clase anónima no serializable derivada de <code>#ref</code> define un campo 'serialVersionUID' #loc
non.serializable.class.with.readwriteobject.display.name=Clase no serializable con 'readObject()' o 'writeObject()'
non.serializable.class.with.readwriteobject.problem.descriptor.both={0, choice, 1#clase|2#interfaz|3#clase anónima derivada de|4#tipo de anotación|5#enumeración|6#registro} no serializable <code>#ref</code> define ''readObject()'' y ''writeObject()'' #loc
non.serializable.class.with.readwriteobject.problem.descriptor.read={0, choice, 1#La clase|2#La interfaz|3#La clase anónima derivada de|4#El tipo de anotación|5#La enumeración|6#El registro} <code>#ref</code> no serializable define ''readObject()'' #loc
non.serializable.class.with.readwriteobject.problem.descriptor.write={0, choice, 1#La clase|2#La interfaz|3#La clase anónima derivada de|4#El tipo de anotación|5#La enumeración|6#El record} no serializable <code>#ref</code> define ''writeObject()'' #loc
non.serializable.class.with.serialversionuid.problem.descriptor=La clase no serializable <code>#ref</code> define un campo 'serialVersionUID' #loc
non.serializable.component.in.serializable.record.problem.descriptor=Componente no serializable '#ref' en el registro serializable #loc
non.serializable.field.in.serializable.class.display.name=Campo no serializable en una clase 'Serializable'
non.serializable.field.in.serializable.class.problem.descriptor=Campo no serializable '#ref' en clase Serializable #loc
non.serializable.interface.with.serialversionuid.problem.descriptor=La interfaz no serializable <code>#ref</code> define un campo 'serialVersionUID' #loc
non.serializable.object.bound.to.http.session.display.name=Objeto no serializable vinculado a 'HttpSession'
non.serializable.object.bound.to.http.session.problem.descriptor=Objeto no serializable vinculado a HttpSession #loc
non.serializable.object.passed.to.object.stream.display.name=Objeto no serializable pasado a 'ObjectOutputStream'
non.serializable.object.passed.to.object.stream.problem.descriptor=Objeto no serializable pasado a ObjectOutputStream #loc
non.serializable.with.serialversionuid.display.name=Clase no serializable con 'serialVersionUID'
non.short.circuit.boolean.expression.display.name=Expresión booleana sin cortocircuito
non.short.circuit.boolean.expression.problem.descriptor=Expresión booleana sin cortocircuito <code>#ref</code> #loc
non.short.circuit.boolean.expression.replace.quickfix=Reemplazar con expresión de cortocircuito
non.synchronized.method.overrides.synchronized.method.display.name=Un método no sincronizado sobrescribe un método 'synchronized'
non.synchronized.method.overrides.synchronized.method.problem.descriptor=El método no sincronizado <code>#ref()</code> sobrescribe el método sincronizado #loc
non.thread.safe.lazy.initialization.display.name=Inicialización perezosa no segura del campo 'static'
non.thread.safe.lazy.initialization.problem.descriptor=La inicialización diferida del campo 'static' <code>#ref</code> no es segura para subprocesos #loc
none=Ninguno
noop.method.in.abstract.class.display.name=Método sin operaciones en clase 'abstract'
noop.method.in.abstract.class.problem.descriptor=El método sin operación <code>#ref()</code> debería ser abstract #loc
normalize.declaration.quickfix=Dividir en declaraciones separadas
not.object.equals.can.be.equality.problem.descriptor=<code>!#ref()</code> se puede reemplazar con '!='
notify.called.on.condition.display.name=Notify()' o 'notifyAll()' llamado en un objeto 'java.util.concurrent.locks.Condition
notify.called.on.condition.problem.descriptor=Llamada a <code>#ref()</code> en un objeto Condition #loc
notify.without.corresponding.wait.display.name=Notify()' sin el correspondiente 'wait()
notify.without.corresponding.wait.problem.descriptor=Llamada a <code>#ref()</code> sin el <code>wait()</code> correspondiente #loc
null.argument.to.var.arg.method.display.name=Argumento confuso para un método varargs
null.argument.to.var.arg.method.problem.descriptor=Argumento <code>#ref</code> confuso, no está claro si se desea una llamada con varargs o sin varargs #loc
null.thrown.display.name='null' lanzado
null.thrown.problem.descriptor=<code>#ref</code> lanzada #loc
number.comparison.display.name=Comparación de números usando '==', en lugar de 'equals()'
number.comparison.problem.descriptor=Los objetos Number se comparan mediante <code>#ref</code> en lugar de 'equals()' #loc
object.allocation.in.loop.display.name=Asignación de objetos en un bucle
object.allocation.in.loop.new.descriptor=Asignación de objeto <code>new #ref()</code> en bucle #loc
object.allocation.in.loop.problem.array.initializer.descriptor=Asignación de array en un bucle #loc
object.allocation.in.loop.problem.call.descriptor=Asignación de objeto mediante la llamada <code>#ref()</code> en un bucle #loc
object.allocation.in.loop.problem.lambda.descriptor=Asignación de objetos mediante captura de lambda en un bucle #loc
object.allocation.in.loop.problem.methodref.descriptor=Asignación de objetos mediante una referencia a un método vinculada a la instancia <code>#ref()</code> en el bucle #loc
object.allocation.in.loop.problem.string.concat=Asignación de objetos mediante concatenación de cadenas en un bucle #loc
object.comparison.display.name=Comparación de objetos mediante '==' en lugar de 'equals()'
object.comparison.enumerated.ignore.option=Ignorar '==' entre variables de tipo enum
object.comparison.klass.ignore.option=Ignorar '==' entre tipos de clases final sin implementación de 'equals()'
object.comparison.problem.description=Los valores de los objetos se comparan mediante <code>#ref</code>, no 'equals()' #loc
object.equality.ignore.between.objects.of.a.type.with.only.private.constructors.option=Ignorar '==' entre objetos de un tipo con solo constructores 'private'
object.equals.can.be.equality.display.name=La llamada a 'equals()' se puede reemplazar por '=='
object.equals.can.be.equality.problem.descriptor=<code>#ref()</code> se puede reemplazar por '=='
object.instantiation.inside.equals.or.hashcode.display.name=Instanciación de objetos dentro de 'equals()' o 'hashCode()'
object.instantiation.inside.equals.or.hashcode.problem.descriptor=Instanciación de objetos dentro de ''{0}()'' #loc
object.instantiation.inside.equals.or.hashcode.problem.descriptor2=Instanciación de objetos dentro de ''{0}()'' ({1})#loc
object.notify.display.name=Llamada a 'notify()' en lugar de 'notifyAll()'
object.notify.problem.descriptor=<code>#ref</code> probablemente debería reemplazarse por 'notifyAll()' #loc
objects.hash.fix.family.name=Envolver con 'Arrays.hashCode()'
objects.hash.problem.descriptor=El array pasado a 'Objects.hash()' debe envolverse en 'Arrays.hashcode()'
octal.and.decimal.integers.in.same.array.display.name=Enteros octales y decimales en el mismo array
octal.and.decimal.integers.in.same.array.problem.descriptor=Enteros octales y decimales en el mismo inicializador de arreglo #loc
octal.literal.display.name=Entero octal
octal.literal.problem.descriptor=Entero octal <code>#ref</code> #loc
only.report.public.methods.option=Informar solo métodos 'public'
only.report.qualified.static.usages.option=Solo informar los accesos estáticos cualificados desde un contexto estático
only.report.static.methods=Informar solo de los métodos 'static'(&O)
only.warn.on.protected.clone.methods=Solo advertir sobre métodos clone 'protected'
only.warn.on.public.clone.methods=Solo advertir sobre métodos clone 'public'
optional.contains.array.problem.descriptor='Optional' contiene el array <code>#ref</code>
optional.contains.collection.display.name='Optional' contiene un array o colección
optional.contains.collection.problem.descriptor='Optional' contiene la colección <code>#ref</code>
optional.used.as.field.or.parameter.type.display.name='Optional' usado como tipo de campo o parámetro
optional.used.as.field.type.problem.descriptor=<code>#ref</code> se usa como tipo para el campo ''{0}''
optional.used.as.parameter.type.problem.descriptor=<code>#ref</code> se utiliza como tipo para el parámetro ''{0}''
options.label.ignored.classes=Clases ignoradas:
options.title.ignored.classes=Clases ignoradas
overloaded.methods.with.same.number.parameters.display.name=Métodos sobrecargados con el mismo número de parámetros
overloaded.methods.with.same.number.parameters.option=<html>Ignorar métodos sobrecargados cuyos tipos de parámetros son definitivamente incompatibles</html>
overloaded.methods.with.same.number.parameters.problem.descriptor=Múltiples métodos denominados <code>#ref</code> con el mismo número de parámetros #loc
overloaded.vararg.constructor.problem.descriptor=Constructor varargs sobrecargado <code>#ref()</code> #loc
overloaded.vararg.method.display.name=Método varargs sobrecargado
overloaded.vararg.method.problem.descriptor=Método varargs sobrecargado <code>#ref()</code> #loc
overloaded.vararg.method.problem.option=Ignorar los métodos sobrecargados cuyos tipos de parámetros sean definitivamente incompatibles
overly.broad.throws.clause.display.name=Cláusula 'throws' demasiado amplia
overly.broad.throws.clause.ignore.thrown.option=Ignorar las excepciones que ocultan a otras pero que son lanzadas (&H)
overly.broad.throws.clause.problem.descriptor1=<code>throws #ref</code> es demasiado amplio, enmascarando la excepción ''{0}'' #loc
overly.broad.throws.clause.problem.descriptor2=<code>throws #ref</code> es demasiado amplia, ocultando las excepciones ''{0}'' y ''{1}'' #loc
overly.broad.throws.clause.quickfix1=Añadir excepciones específicas
overly.broad.throws.clause.quickfix2=Reemplazar por excepciones específicas
overly.broad.throws.clause.threshold.option=Número máximo de excepciones ocultas a informar:
overly.complex.anonymous.inner.class.display.name=Clase anónima demasiado compleja
overly.complex.anonymous.inner.class.problem.descriptor=Clase anónima excesivamente compleja (complejidad ciclomática = {0}) #loc
overly.complex.arithmetic.expression.display.name=Expresión aritmética excesivamente compleja
overly.complex.arithmetic.expression.max.number.option=Número máximo de términos:
overly.complex.arithmetic.expression.problem.descriptor=Expresión aritmética excesivamente compleja #loc
overly.complex.boolean.expression.display.name=Expresión booleana excesivamente compleja
overly.complex.boolean.expression.ignore.option=Ignorar conjunciones y disyunciones puras
overly.complex.boolean.expression.max.terms.option=Número máximo de términos:
overly.complex.boolean.expression.problem.descriptor=Expresión booleana excesivamente compleja ({0} términos) #loc
overly.complex.class.display.name=Clase excesivamente compleja
overly.complex.class.problem.descriptor=Clase excesivamente compleja <code>#ref</code> (complejidad ciclomática = {0}) #loc
overly.coupled.class.class.coupling.limit.option=Límite de acoplamiento de clases:
overly.coupled.class.display.name=Clase excesivamente acoplada
overly.coupled.class.problem.descriptor=<code>#ref</code> está excesivamente acoplada (dependencias = {0}) #loc
overly.long.lambda.display.name=Expresión lambda excesivamente larga
overly.long.lambda.problem.descriptor=La expresión lambda es demasiado larga (n.º de sentencias de código fuente sin comentarios = {0}) #loc
overly.strong.type.cast.display.name=Conversión de tipo demasiado fuerte
overly.strong.type.cast.ignore.in.matching.instanceof.option=Ignorar conversiones con una expresión instanceof coincidente
overly.strong.type.cast.problem.descriptor=La conversión a <code>#ref</code> se puede debilitar a ''{0}'' #loc
overly.strong.type.cast.weaken.quickfix=Debilitar la conversión de tipo demasiado fuerte
overridable.method.call.in.constructor.display.name=Método sobreescribible llamado durante la construcción del objeto
overridable.method.call.in.constructor.problem.descriptor=Llamada al método sobrescribible <code>#ref()</code> durante la construcción del objeto #loc
overridden.method.call.in.constructor.display.name=Llamada a un método sobreescrito durante la construcción del objeto
overridden.method.call.in.constructor.problem.descriptor=Llamada al método sobreescrito <code>#ref()</code> durante la construcción del objeto #loc
package.dot.html.may.be.package.info.convert.quickfix=Convertir a 'package-info.java'
package.dot.html.may.be.package.info.delete.quickfix=Eliminar 'package.html'
package.dot.html.may.be.package.info.display.name=package.html' puede convertirse a 'package-info.java
package.dot.html.may.be.package.info.exists.problem.descriptor=<code>package.html</code> se ignora porque existe <code>package-info.java</code>
package.dot.html.may.be.package.info.problem.descriptor=<code>package.html</code> puede convertirse en <code>package-info.java</code>
package.in.multiple.modules.display.name=Paquete con clases en múltiples módulos
package.in.multiple.modules.problem.descriptor.many=El paquete ''{0}'' tiene clases en los módulos ''{1}'', ''{2}'' y otros ''{3}'' módulos
package.in.multiple.modules.problem.descriptor2=El paquete ''{0}'' tiene clases en los módulos ''{1}'' y ''{2}''
package.in.multiple.modules.problem.descriptor3=El paquete ''{0}'' tiene clases en los módulos ''{1}'', ''{2}'' y ''{3}''
package.info.java.without.package.display.name=Package-info.java' sin la sentencia 'package
package.info.without.package.family.quickfix=Añadir sentencia package
package.info.without.package.problem.descriptor=Package-info.java' no tiene una sentencia 'package
package.info.without.package.quickfix=Añadir ''package {0};''
package.local.field.not.accessible=El campo package-private ''{0}'' no es accesible desde aquí
package.local.private=package-private & privado
package.naming.convention.display.name=Convención de nomenclatura de paquetes
package.naming.convention.problem.descriptor.long=El nombre del paquete <code>{0}</code> es demasiado largo
package.naming.convention.problem.descriptor.regex.mismatch=El nombre del paquete <code>{0}</code> no coincide con la expresión regular ''{1}''
package.naming.convention.problem.descriptor.short=El nombre del paquete <code>{0}</code> es demasiado corto
package.visible.field.display.name=Campo visible en el paquete
package.visible.field.problem.descriptor=Campo con visibilidad de paquete <code>#ref</code> #loc
package.visible.inner.class.display.name=Clase anidada visible para el paquete
package.visible.inner.class.ignore.enum.option=Ignorar enumeraciones internas con visibilidad de paquete
package.visible.inner.class.ignore.interface.option=Ignorar interfaces internas con visibilidad de paquete
package.visible.inner.class.problem.descriptor=Clase anidada con visibilidad de paquete <code>#ref</code> #loc
package.with.too.few.classes.display.name=Paquete con muy pocas clases
package.with.too.few.classes.min.option=Número mínimo de clases:
package.with.too.few.classes.problem.descriptor=El paquete ''{0}'' contiene muy pocas clases ({1} < {2})
package.with.too.many.classes.display.name=Paquete con demasiadas clases
package.with.too.many.classes.max.option=Número máximo de clases:
package.with.too.many.classes.problem.descriptor=El paquete ''{0}'' contiene demasiadas clases ({1} > {2})
parameter.hides.member.variable.display.name=El parámetro oculta el campo
parameter.hides.member.variable.ignore.abstract.methods.option=Ignorar para métodos abstractos
parameter.hides.member.variable.ignore.constructors.option=Ignorar en constructores
parameter.hides.member.variable.ignore.setters.option=Ignorar para setters de propiedades
parameter.hides.member.variable.ignore.static.parameters.option=Ignorar para parámetros de métodos estáticos que ocultan campos de instancia
parameter.hides.member.variable.ignore.superclass.option=Ignorar campos de la superclase no visibles desde la subclase
parameter.hides.member.variable.problem.descriptor=El parámetro <code>#ref</code> oculta el campo en la clase ''{0}'' #loc
parameter.limit.option=Límite de parámetros:
parameter.name.differs.from.overridden.parameter.display.name=El nombre del parámetro difiere del parámetro en el método sobrescrito o sobrecargado
parameter.name.differs.from.overridden.parameter.ignore.character.option=Ignorar si el parámetro sobrescrito contiene solo un carácter
parameter.name.differs.from.overridden.parameter.ignore.library.option=Ignorar si el parámetro sobrescrito proviene de una biblioteca
parameter.name.differs.from.overridden.parameter.problem.descriptor=El nombre del parámetro <code>#ref</code> es diferente del parámetro ''{0}'' en el {1, choice, 1#supermétodo|2#método sobrecargado|3#superconstructor|4#constructor sobrecargado} #loc
parameter.naming.convention.display.name=Convención de nomenclatura de parámetros de método
parameter.naming.convention.element.description=Parámetro
parameter.type.prevents.overriding.display.name=El tipo de parámetro impide la sobrescritura
parameter.type.prevents.overriding.family.quickfix=Cambiar el tipo de parámetro
parameter.type.prevents.overriding.problem.descriptor=El tipo de parámetro <code>#ref</code> se encuentra en ''{0}'' mientras que el tipo de parámetro del supermétodo se encuentra en ''{1}'', lo que impide la sobrescritura #loc
parameter.type.prevents.overriding.quickfix=Cambiar el tipo del parámetro a ''{0}''
parameters.per.constructor.display.name=Constructor con demasiados parámetros
parameters.per.constructor.problem.descriptor=<code>#ref()</code> tiene demasiados parámetros (número de parámetros = {0}) #loc
parameters.per.method.display.name=Método con demasiados parámetros
parameters.per.method.problem.descriptor=<code>#ref()</code> tiene demasiados parámetros (número de parámetros = {0}) #loc
pattern.variable.hides.field.display.name=La variable de patrón oculta un campo
pattern.variable.hides.field.problem.descriptor=La variable de patrón <code>#ref</code> oculta un campo en la clase ''{0}'' #loc
pointless.arithmetic.expression.display.name=Expresión aritmética inútil
pointless.bitwise.expression.display.name=Expresión bit a bit innecesaria
pointless.bitwise.expression.simplify.quickfix=Simplificar
pointless.boolean.expression.display.name=Expresión booleana inútil
pointless.boolean.expression.ignore.option=Ignorar constantes con nombre al determinar expresiones sin sentido
pointless.indexof.comparison.always.false.problem.descriptor=<code>#ref</code> siempre es falso #loc
pointless.indexof.comparison.always.true.problem.descriptor=<code>#ref</code> siempre es true #loc
pointless.indexof.comparison.display.name=Comparación de 'indexOf()' sin sentido
pointless.nullcheck.display.name=Comprobación de 'null' innecesaria antes de la llamada al método
pointless.nullcheck.problem.descriptor.call=Comprobación de ''null'' innecesaria antes de la llamada a ''{0}()''
possible.throw.from.finally.block.problem.descriptor=<code>{0}</code> podría lanzarse dentro del bloque ''finally'' #loc
prefer.empty.array.options.mode.always=Siempre
prefer.empty.array.options.mode.always.never=Nunca (preferir un array con tamaño predefinido)
prefer.empty.array.options.mode.by.level=Según el nivel del lenguaje
prefer.empty.array.options.title=Preferir array vacío:
prefix.operation.quickfix.family.name=Reemplazar con operador de prefijo
press.escape.to.remove.highlighting.message=Presione Esc para quitar el resaltado
primitive.array.argument.to.var.arg.method.display.name=Argumento de array primitivo confuso para un método con varargs
primitive.array.argument.to.var.arg.method.problem.descriptor=Argumento de arreglo primitivo confuso para el método varargs #loc
primitive.fields.ignore.option=Ignorar campos primitivos
printstacktrace.call.display.name=Llamada a 'printStackTrace()'
printstacktrace.call.problem.descriptor=La llamada a <code>#ref()</code> probablemente debería reemplazarse por un registro más robusto #loc
private=Privado
private.field.not.accessible.problem.descriptor=El campo ''private'' ''{0}'' no es accesible desde aquí
private.member.access.between.outer.and.inner.classes.display.name=Llamada a descriptor de acceso sintético
private.member.access.between.outer.and.inner.classes.make.constructor.package.local.quickfix=Hacer que el constructor ''{0}'' sea package-private
private.member.access.between.outer.and.inner.classes.make.local.quickfix=Hacer ''{0}'' package-private
private.member.access.between.outer.and.inner.classes.problem.descriptor=El acceso al miembro ''private'' de la clase ''{0}'' requiere un accesor sintético #loc
problematic.varargs.method.display.name=Método que no es varargs sobrescribe un método varargs
problematic.varargs.method.override.problem.descriptor=El método no varargs <code>#ref()</code> sobrescribe el método varargs #loc
progress.text.analyzing.package.0=Analizando el paquete {0}
properties.object.as.hashtable.display.name=Uso del objeto 'Properties' como 'Hashtable'
properties.object.as.hashtable.problem.descriptor=Llamada a <code>Hashtable.#ref()</code> en el objeto de propiedades #loc
property.value.set.to.itself.display.name=Valor de la propiedad establecido en sí mismo
protected.field.display.name=Campo protegido
protected.field.not.accessible.problem.descriptor=El campo ''protected'' ''{0}'' no es accesible desde aquí
protected.field.problem.descriptor=Campo protegido <code>#ref</code> #loc
protected.inner.class.display.name=Clase anidada protected
protected.inner.class.ignore.enum.option=Ignorar enums internos 'protected'
protected.inner.class.ignore.interface.option=Ignorar interfaces internas 'protected'
protected.inner.class.problem.descriptor=Clase anidada protegida <code>#ref</code> #loc
protected.member.in.final.class.display.name=Miembro 'protected' en una clase 'final'
protected.member.in.final.class.problem.descriptor=Miembro de clase declarado <code>#ref</code> en una clase 'final' #loc
protected.package.local.private=protected, package-private y private
public.constructor.display.name=El constructor 'public' puede reemplazarse por un método de fábrica
public.constructor.in.non.public.class.display.name=Constructor 'public' en una clase no pública
public.constructor.in.non.public.class.problem.descriptor=El constructor está declarado como <code>#ref</code> en la clase no pública ''{0}'' #loc
public.constructor.in.non.public.class.quickfix=Hacer que el constructor sea private
public.constructor.problem.descriptor=Constructor público <code>#ref()</code> #loc
public.constructor.quickfix=Reemplazar el constructor por un método de fábrica
public.default.constructor.problem.descriptor=La clase <code>#ref</code> tiene un constructor predeterminado 'public'
public.field.accessed.in.synchronized.context.display.name=Campo no privado accedido en un contexto 'synchronized'
public.field.accessed.in.synchronized.context.problem.descriptor=Campo no privado <code>#ref</code> accedido en un contexto sincronizado #loc
public.field.display.name=Campo 'public'
public.field.ignore.enum.type.fields.option=Ignorar campos 'public final' de un tipo de enumeración
public.field.problem.descriptor=Campo 'public' <code>#ref</code> #loc
public.inner.class.display.name=Clase anidada 'public'
public.inner.class.ignore.enum.option=Ignorar las enumeraciones internas 'public'
public.inner.class.ignore.interface.option=Ignorar las interfaces internas 'public'
public.inner.class.problem.descriptor=Clase anidada 'public' <code>#ref</code> #loc
public.method.not.in.interface.display.name=Método 'public' no expuesto en la interfaz
public.method.not.in.interface.option=<html>Ignorar si la clase contenedora no implementa una interfaz que no sea de biblioteca</html>
public.method.not.in.interface.problem.descriptor=El método 'public' <code>#ref()</code> no se expone a través de una interfaz #loc
public.method.without.logging.display.name=Método 'public' sin registro
public.method.without.logging.problem.descriptor=El método 'public' <code>#ref()</code> no tiene ninguna llamada de registro #loc
public.static.array.field.display.name=Campo de array 'public static'
public.static.array.field.problem.descriptor=Campo de array 'public static' <code>#ref</code>, que compromete la seguridad #loc
public.static.collection.field.display.name='public static' campo de colección
public.static.collection.field.problem.descriptor=Campo de colección 'public static' <code>#ref</code>, lo que compromete la seguridad #loc
qualify.call.fix.family.name=Calificar llamada
query.label=Los nombres de consulta comienzan con:
questionable.name.display.name=Nombre cuestionable
questionable.name.list.label=Nombres reportados:
questionable.name.problem.descriptor=Nombre cuestionable <code>#ref</code> #loc
random.double.for.random.integer.display.name=Uso de 'Random.nextDouble()' para obtener un entero aleatorio
random.double.for.random.integer.problem.descriptor=Uso de <code>Random.#ref</code> para crear un entero aleatorio #loc
raw.use.of.parameterized.type.display.name=Uso de clase parametrizada sin procesar
readobject.initialization.display.name=El campo de instancia podría no estar inicializado por 'readObject()'
readobject.initialization.problem.descriptor=El campo de instancia <code>#ref</code> podría no estar inicializado durante la llamada a 'readObject()' #loc
readresolve.writereplace.protected.display.name=ReadResolve()' o 'writeReplace()' no declarados como 'protected
readresolve.writereplace.protected.problem.descriptor=<code>#ref()</code> no se ha declarado como 'protected' #loc
readwriteobject.private.display.name=ReadObject()' o 'writeObject()' no declarados como 'private
readwriteobject.private.problem.descriptor=<code>#ref</code> no se ha declarado como 'private' #loc
recordstore.opened.not.safely.closed.display.name='RecordStore' se abrió pero no se cerró de forma segura
redundant.as.list.for.iteration.fix.name=Desenvolver
redundant.as.list.for.iteration.problem=Llamada a 'Arrays.asList()' innecesaria
redundant.call.problem.descriptor=Llamada redundante a <code>#ref()</code> #loc
redundant.else.display.name='else' redundante
redundant.else.problem.descriptor=La rama <code>#ref</code> puede desenvolverse, ya que la rama 'if' nunca termina normalmente #loc
redundant.else.unwrap.quickfix=Eliminar 'else' redundante
redundant.escape.in.regex.replacement.display.name=Escape redundante en la cadena de reemplazo de expresiones regulares
redundant.escape.in.regex.replacement.problem.descriptor=Escape redundante de ''{0}''
redundant.escape.in.regex.replacement.quickfix=Eliminar escape redundante
redundant.explicit.var.type.display.name=El tipo de variable local se puede omitir
redundant.field.initialization.display.name=Inicialización de campo redundante
redundant.field.initialization.problem.descriptor=La inicialización del campo a <code>#ref</code> es redundante #loc
redundant.field.initialization.remove.quickfix=Eliminar inicializador
redundant.implements.display.name=Declaración de interfaz redundante
redundant.implements.problem.descriptor=Declaración de interfaz redundante <code>#ref</code> #loc
redundant.implements.remove.quickfix=Eliminar declaración de interfaz redundante
redundant.local.variable.annotation.option=Ignorar variables que tienen una anotación
redundant.local.variable.display.name=Variable local redundante
redundant.local.variable.ignore.option=Ignorar variables devueltas o lanzadas inmediatamente
redundant.method.override.delegate.quickfix=Reemplazar método por una delegación a super
redundant.method.override.delegates.to.super.problem.descriptor=El método <code>#ref()</code> solo delega en su supermétodo #loc
redundant.method.override.display.name=El método es idéntico a su supermétodo
redundant.method.override.option.check.library.methods=Comprobar métodos que sobrescriben métodos de biblioteca
redundant.method.override.option.ignore.delegates=Ignorar delegaciones a métodos super
redundant.method.override.problem.descriptor=El método <code>#ref()</code> es idéntico a su supermétodo #loc
redundant.method.override.quickfix=Eliminar método redundante
redundant.string.format.call.display.name=Llamada redundante a 'String.format()'
redundant.string.format.call.quickfix=Eliminar llamada redundante a 'String.format()'
redundant.string.formatted.call.quickfix=Eliminar la llamada redundante a 'String.formatted()'
referencing.subclass.0.from.superclass.1.initializer.might.lead.to.class.loading.deadlock=Hacer referencia a la subclase {0} desde el inicializador de la superclase {1} podría provocar un interbloqueo de carga de clases
reflection.for.unavailable.annotation.display.name=Acceso mediante reflexión a una anotación de solo código fuente
reflection.for.unavailable.annotation.problem.descriptor=La anotación '#ref' no se conserva para el acceso por reflexión #loc
refused.bequest.display.name=El método no llama al supermétodo
refused.bequest.fix.family.name=Insertar llamada al método super
refused.bequest.ignore.default.super.methods.option=Ignorar métodos super 'default'
refused.bequest.ignore.empty.super.methods.option=Ignorar supermétodos vacíos
refused.bequest.problem.descriptor=El método <code>#ref()</code> no llama a 'super.#ref()' #loc
remove.annotation.parameter.0.fix.name=Eliminar el parámetro de anotación ''{0}''
remove.call.fix.family.name=Eliminar llamada
remove.cloneable.quickfix=Eliminar 'Cloneable' de la cláusula 'implements'
remove.finally.block.quickfix=Eliminar el bloque 'finally'
remove.leading.zero.to.make.decimal.quickfix=Quitar el cero inicial para convertir en decimal
remove.leading.zeroes.to.make.decimals.quickfix=Eliminar los ceros a la izquierda para convertirlos en decimales
remove.loop.fix.family.name=Eliminar bucle
remove.modifier.fix.family.name=Eliminar modificador
remove.modifier.quickfix=Eliminar el modificador ''{0}''
remove.redundant.polyadic.operand.fix.family.name=Eliminar condición innecesaria
remove.redundant.polyadic.operand.fix.name=Eliminar condición ''{0}'' innecesaria
remove.redundant.string.fix.text=Usar ''{0}()'' y eliminar la llamada redundante a ''{1}()''
remove.redundant.substring.fix.family.name=Eliminar llamada a 'substring()' redundante
remove.try.finally.block.quickfix=Eliminar bloque 'try-finally'
remove.unnecessary.0.call.quickfix=Eliminar llamada innecesaria a ''{0}()''
rename.quickfix=Renombrar
renameto.quickfix=Renombrar a ''{0}''
replace.all.dot.display.name=Argumento de expresión regular sospechoso
replace.all.dot.problem.descriptor=Expresión regular sospechosa #ref en la llamada a ''{0}()'' #loc
replace.all.dot.quickfix=Escapar metacaracter de expresión regular
replace.all.file.separator.problem.descriptor=File.separator se utiliza como expresión regular; no funcionará en Windows
replace.anonymous.with.lambda.body.fix.family.name=Reemplazar llamada por el cuerpo del método
replace.case.default.null.with.null.default=Reemplazar 'case default, null' por 'case null, default'
replace.case.default.with.default=Reemplazar 'case default' por 'default'
replace.cast.fix.family.name=Reemplazar tipo de cast
replace.casted.literal.with.just.literal.fix.family.name=Reemplazar con el literal {0}
replace.field.reference.fix.family.name=Reemplazar referencia de campo
replace.field.reference.fix.text=Reemplazar la referencia de campo por ''{0}''
replace.inheritance.with.delegation.quickfix=Reemplazar herencia por delegación
replace.instanceof.fix.family.name=Reemplazar tipo de instanceOf
replace.method.call.fix.family.name=Reemplazar llamada a método
replace.method.call.fix.text=Reemplazar llamada al método con ''{0}''
replace.method.ref.with.qualifier.fix.family.name=Reemplazar con calificador
replace.method.ref.with.qualifier.problem.lambda=La lambda puede reemplazarse por el calificador de llamada
replace.method.ref.with.qualifier.problem.method=La referencia a método se puede reemplazar con un calificador
replace.with.cast.fix.family.name=Reemplazar con cast
replace.with.catch.clause.for.runtime.exception.quickfix=Reemplazar con la cláusula 'catch' para 'RuntimeException'
replace.with.comparator.fix.family.name=Simplificar el comparador mediante métodos estáticos de 'Comparator'
replace.with.lambda.body.fix.family.name=Reemplazar la llamada al método en la lambda por el cuerpo de la lambda
replace.with.method.ref.fix.family.name=Reemplazar lambda con referencia de método
replace.with.method.ref.fix.name.may.change.semantics=Reemplazar lambda con referencia a método (puede cambiar la semántica)
replace.with.method.reference.fix.family.name=Reemplazar la llamada al método en la referencia de método por la llamada al método correspondiente
replace.with.var.fix.family.name=Reemplazar tipo explícito por 'var'
resource.opened.not.closed.problem.descriptor=''{0}'' debe abrirse antes de un bloque ''try'' y cerrarse en el bloque ''finally'' correspondiente #loc
result.of.method.call.ignored.class.column.title=Nombre de la clase
result.of.method.call.ignored.display.name=Resultado de la llamada al método ignorado
result.of.method.call.ignored.non.library.option=Informar de todas las llamadas fuera de biblioteca ignoradas
result.of.method.call.ignored.problem.descriptor=El resultado de <code>{0}.#ref()</code> se ignora #loc
result.of.object.allocation.fix.name=Ignorar asignaciones de objetos de tipo ''{0}''
result.of.object.allocation.ignored.display.name=Resultado de la asignación de objeto ignorado
result.of.object.allocation.ignored.options.chooserTitle=Seleccionar la clase para la cual se puede ignorar la asignación de objetos
result.of.object.allocation.ignored.problem.descriptor=Se ignora el resultado de <code>new #ref()</code> #loc
result.of.object.allocation.ignored.problem.descriptor.methodRef=El objeto asignado dentro de <code>#ref</code> se descarta #loc
return.from.finally.block.display.name=Return' dentro del bloque 'finally
return.from.finally.block.problem.descriptor='return' dentro del bloque 'finally' #loc
return.of.anonymous.class.problem.descriptor=Retorno de una instancia de una clase anónima #loc
return.of.collection.field.fix.family.name=Hacer que la colección devuelta sea 'unmodifiable'
return.of.field.with.mutable.type.problem.descriptor=Retorno del campo {0} <code>#ref</code> #loc
return.of.inner.class.display.name=Retorno de instancia de clase anónima, local o interna
return.of.inner.class.ignore.non.public.option=Ignorar los valores devueltos de métodos no públicos
return.of.inner.class.problem.descriptor=Retorno de instancia de la clase interna no estática <code>{0}</code> #loc
return.of.local.class.problem.descriptor=Retorno de una instancia de la clase local <code>{0}</code> #loc
return.of.null.arrays.option=Informar sobre los métodos que devuelven arreglos
return.of.null.collections.option=Informar sobre los métodos que devuelven objetos de colección
return.of.null.display.name=Retorno de 'null'
return.of.null.ignore.private.option=Ignorar métodos 'private', clases anónimas y lambdas
return.of.null.objects.option=Reportar métodos que devuelven objetos
return.of.null.problem.descriptor=Retorno de <code>#ref</code> #loc
return.point.limit.option=Límite de punto de &retorno:
return.this.display.name=Retorno de 'this'
return.this.problem.descriptor=Retorno de <code>#ref</code> #loc
reuse.of.local.variable.display.name=Reutilización de variable local
reuse.of.local.variable.problem.descriptor=Reutilización de la variable local <code>#ref</code> #loc
reuse.of.local.variable.split.quickfix=Dividir variable local
runtime.exec.call.display.name=Llamada a 'Runtime.exec()'
runtime.exec.call.problem.descriptor=La llamada a <code>Runtime.#ref()</code> no es portable #loc
runtime.exec.with.non.constant.string.display.name=Llamada a 'Runtime.exec()' con una cadena no constante
runtime.exec.with.non.constant.string.problem.descriptor=Llamada a <code>Runtime.#ref()</code> con un argumento no constante #loc
safe.lock.display.name=Bloqueo adquirido pero no liberado de forma segura
safe.lock.problem.descriptor=''{0}'' debe bloquearse antes de un bloque ''try'' y desbloquearse en el bloque ''finally'' correspondiente #loc
sequenced.collection.method.can.be.used.ignore.option=Ignorar constantes con nombre usadas como argumentos
serial.annotation.used.on.wrong.member.display.name=Anotación '@Serial' usada en un miembro incorrecto
serial.annotation.used.on.wrong.member.problem.descriptor=El miembro anotado no forma parte del mecanismo de serialización
serializable.anonymous.class.stores.non.serializable.problem.descriptor=La clase anónima Serializable almacena implícitamente un objeto no Serializable de tipo ''{0}''
serializable.class.in.secure.context.display.name=Clase serializable en un contexto seguro
serializable.class.in.secure.context.problem.descriptor=La clase <code>#ref</code> puede ser serializada, lo que compromete la seguridad #loc
serializable.deserializable.class.in.secure.context.problem.descriptor=La clase <code>#ref</code> puede ser serializada y deserializada, lo que compromete la seguridad #loc
serializable.has.serialization.methods.display.name=Clase Serializable sin 'readObject()' y 'writeObject()'
serializable.has.serialization.methods.ignore.option=Ignorar clases que no definen campos de instancia
serializable.has.serialization.methods.problem.descriptor=La clase Serializable <code>#ref</code> no define 'readObject()' o 'writeObject()' #loc
serializable.has.serialization.methods.problem.descriptor1=La clase Serializable <code>#ref</code> no define 'writeObject()' #loc
serializable.has.serialization.methods.problem.descriptor2=La clase Serializable <code>#ref</code> no define 'readObject()' #loc
serializable.inner.class.has.serial.version.uid.field.display.name=Clase interna no estática serializable sin 'serialVersionUID'
serializable.inner.class.has.serial.version.uid.field.problem.descriptor=La clase interna <code>#ref</code> no define un campo 'serialVersionUID' #loc
serializable.inner.class.with.non.serializable.outer.class.display.name=Clase interna serializable no 'static' con una clase externa no serializable
serializable.inner.class.with.non.serializable.outer.class.problem.descriptor=La clase interna <code>#ref</code> es serializable mientras que su clase externa no lo es #loc
serializable.lambda.stores.non.serializable.problem.descriptor=La lambda serializable almacena implícitamente un objeto no serializable de tipo ''{0}''
serializable.local.class.stores.non.serializable.problem.descriptor=La clase local serializable ''{1}'' almacena implícitamente un objeto no serializable de tipo ''{0}''
serializable.record.contains.ignored.field.problem.descriptor=<code>#ref</code> se ignorará durante la serialización del registro
serializable.record.contains.ignored.members.display.name='record' contiene miembros ignorados
serializable.record.contains.ignored.method.problem.descriptor=<code>#ref()</code> se ignorará durante la serialización del registro
serializable.stores.non.serializable.display.name=El objeto 'Serializable' almacena implícitamente un objeto no 'Serializable'
serializable.with.unconstructable.ancestor.display.name=Clase serializable con un ancestro no construible
serializable.with.unconstructable.ancestor.problem.descriptor=<code>#ref</code> tiene un ancestro no serializable ''{0}'' sin constructor sin argumentos #loc
serialpersistentfields.with.wrong.signature.display.name=El campo 'serialPersistentFields' no se ha declarado como 'private static final ObjectStreamField[]'
serialpersistentfields.with.wrong.signature.problem.descriptor=El campo <code>#ref</code> de una clase Serializable no está declarado como 'private static final ObjectStreamField[]' #loc
serialversionuid.private.static.final.long.display.name=El campo 'serialVersionUID' no se ha declarado como 'private static final long'
serialversionuid.private.static.final.long.problem.descriptor=El campo <code>#ref</code> de una clase Serializable no está declarado como 'private static final long' #loc
serialversionuid.private.static.final.long.quickfix=Hacer que serialVersionUID sea 'private static final'
set.annotation.parameter.0.1.fix.name=Establecer el parámetro de anotación {0} = "{1}"
set.replaceable.by.enum.set.display.name=Set' se puede reemplazar con 'EnumSet
set.replaceable.by.enum.set.problem.descriptor=<code>#ref</code> se puede reemplazar por 'EnumSet' #loc
shared.thread.local.random.display.name=La instancia de 'ThreadLocalRandom' podría estar compartida
shared.thread.local.random.problem.descriptor=La instancia de 'ThreadLocalRandom' podría compartirse entre hilos
shift.operation.by.inappropriate.constant.display.name=Operación de desplazamiento por una constante inadecuada
shift.operation.by.inappropriate.constant.problem.descriptor.negative=Operación de desplazamiento <code>#ref</code> por el valor constante negativo {0} #loc
shift.operation.by.inappropriate.constant.problem.descriptor.out.of.bounds=Operación de desplazamiento <code>#ref</code> por un valor fuera de rango {0}#loc
shift.operation.by.inappropriate.constant.problem.descriptor.too.large=Operación de desplazamiento <code>#ref</code> por un valor constante excesivamente grande {0} #loc
shift.out.of.range.fix.family.name=Corregir valor de desplazamiento
side.effects.method.ref.to.lambda.fix.family.name={0} (efectos secundarios)
signal.without.corresponding.await.display.name=Signal()' sin el correspondiente 'await()
signal.without.corresponding.await.problem.descriptor=Llamada a <code>#ref()</code> sin el <code>await()</code> correspondiente #loc
simplifiable.annotation.braces.problem.descriptor=Llaves innecesarias alrededor de <code>{0}</code> en la anotación #loc
simplifiable.annotation.display.name=Anotación simplificable
simplifiable.annotation.problem.descriptor=<code>#ref</code> innecesario en la anotación #loc
simplifiable.annotation.quickfix=Simplificar anotación
simplifiable.annotation.whitespace.problem.descriptor=Espacio en blanco innecesario en la anotación #loc
simplifiable.boolean.expression.display.name=Expresión booleana simplificable
simplifiable.conditional.expression.display.name=Expresión condicional simplificable
simplifiable.conditional.expression.problem.descriptor=<code>{1}</code> se puede simplificar a ''{0}'' #loc
simplifiable.equals.expression.display.name=Comprobación de 'null' innecesaria antes de la llamada a 'equals()'
simplifiable.equals.expression.option.non.constant=Informar de equals con un argumento no constante y no nulo
simplifiable.equals.expression.problem.descriptor=Verificación de ''null'' innecesaria antes de la llamada a ''{0}()'' #loc
simplifiable.equals.expression.quickfix=Invertir ''.{0}()'' y eliminar la comprobación de ''null'' innecesaria
simplifiable.junit.assertion.display.name=Aserción simplificable
simplifiable.junit.assertion.problem.descriptor=<code>#ref()</code> se puede simplificar a ''{0}'' #loc
simplify.junit.assertion.simplify.quickfix=Simplificar aserción
single.character.startswith.display.name=Carácter único en 'startsWith()' o 'endsWith()'
single.character.startswith.problem.descriptor=El carácter único <code>#ref()</code> se puede reemplazar por la expresión 'charAt()' #loc
single.character.startswith.quickfix=Reemplazar por la expresión 'charAt()'
single.class.import.display.name=Importación de clase única
single.class.import.problem.descriptor=Importación de clase única <code>#ref</code> #loc
single.element.annotation.family.quickfix=Expandir anotación a la forma normal
single.element.annotation.name=Anotación no normalizada
single.element.annotation.quickfix=Añadir 'value='
single.statement.in.block.descriptor=''{0}'' contiene una única sentencia
single.statement.in.block.family.quickfix=Eliminar llaves de la sentencia
single.statement.in.block.name=El bloque de código contiene una única sentencia
single.statement.in.block.quickfix=Eliminar llaves de la sentencia ''{0}''
singleton.display.name=Singleton
singleton.problem.descriptor=La clase <code>#ref</code> es un singleton #loc
size.replaceable.by.isempty.display.name=Size() == 0' se puede reemplazar por 'isEmpty()
size.replaceable.by.isempty.fix.ignore.calls=Ignorar las llamadas a ''.{0}()'' en el tipo ''{1}''
size.replaceable.by.isempty.negation.ignore.option=Ignorar expresiones que serían reemplazadas por '!isEmpty()'
sleep.while.holding.lock.display.name=Llamada a 'Thread.sleep()' mientras se está sincronizado
sleep.while.holding.lock.problem.descriptor=Llamada a <code>Thread.#ref()</code> durante la sincronización #loc
smth.unnecessary.remove.quickfix=Eliminar ''{0}'' innecesario
socket.opened.not.closed.display.name=Socket abierto pero no cerrado de forma segura
standard.variable.names.display.name=Nombres de variables estándar
standard.variable.names.ignore.override.option=Ignorar para nombres de parámetros idénticos a los parámetros del método super profesional.
standard.variable.names.problem.descriptor=La variable llamada <code>#ref</code> no tiene el tipo ''{0}'' #loc
standard.variable.names.problem.descriptor2=La variable llamada <code>#ref</code> no tiene el tipo ''{0}'' o ''{1}'' #loc
statement.problem.descriptor=Sentencia <code>#ref</code> #loc
statement.with.empty.body.display.name=Sentencia con cuerpo vacío
statement.with.empty.body.include.option=Incluir cuerpos de sentencia que sean bloques de código vacíos
statement.with.empty.body.problem.descriptor=La sentencia <code>#ref</code> tiene un cuerpo vacío #loc
static.collection.display.name=Colección estática
static.collection.ignore.option=Ignorar colecciones o mapas estáticos débiles
static.collection.problem.descriptor=Colección estática <code>#ref</code> #loc
static.field.via.subclass.display.name=Campo estático referenciado a través de una subclase
static.field.via.subclass.problem.descriptor=Campo estático <code>#ref</code> declarado en la clase ''{0}'' pero referenciado a través de la subclase ''{1}'' #loc
static.field.via.subclass.rationalize.quickfix=Racionalizar el acceso a campos estáticos
static.import.display.name=Importación estática
static.import.fix.ignore.class=Permitir importaciones estáticas para la clase ''{0}''
static.import.options.border.title=Clases importables estáticamente:
static.import.options.chooserTitle=Seleccionar clase importable estáticamente
static.import.problem.descriptor=Importación estática <code>#ref</code>  #loc
static.import.replace.quickfix=Reemplazar con una importación no estática
static.inheritance.display.name=Herencia estática
static.inheritance.fix.family.name=Reemplazar herencia por referencia calificada
static.inheritance.problem.descriptor=La interfaz <code>#ref</code> se implementa solo por sus constantes estáticas #loc
static.inheritance.replace.quickfix=Reemplazar la herencia con referencias calificadas en {0}
static.initializer.references.subclass.display.name=El inicializador estático hace referencia a una subclase
static.method.naming.convention.element.description=Método 'static'
static.method.only.used.in.one.anonymous.class.problem.descriptor={0, choice, 1#El método|2#El campo} estático <code>#ref{0, choice, 1#()|2#}</code> solo se utiliza en una clase anónima derivada de ''{1}'' #loc
static.method.only.used.in.one.class.display.name=Miembro estático solo utilizado desde otra clase
static.method.only.used.in.one.class.ignore.anonymous.option=Ignorar cuando solo se usa desde una clase anónima
static.method.only.used.in.one.class.ignore.on.conflicts=Ignorar cuando el método no se puede mover sin conflictos
static.method.only.used.in.one.class.ignore.test.option=Ignorar si solo se utiliza desde una clase de prueba
static.method.only.used.in.one.class.ignore.utility.classes=Ignorar miembros situados en clases de utilidad
static.method.only.used.in.one.class.problem.descriptor={0, choice, 1#El método estático|2#El campo estático} <code>#ref{0, choice, 1#()|2#}</code> solo se utiliza en la clase ''{1}'' #loc
static.method.only.used.in.one.class.quickfix=Mover {0} a la clase de uso
static.method.only.used.in.one.class.quickfix.preview=Mueve el miembro estático a la clase donde se utiliza.
static.method.via.subclass.display.name=Método estático referenciado a través de una subclase
static.method.via.subclass.problem.descriptor=Método estático <code>#ref()</code> declarado en la clase ''{0}'' pero referenciado a través de la subclase ''{1}'' #loc
static.method.via.subclass.rationalize.quickfix=Racionalizar llamada a método estático
static.non.final.field.display.name=Campo 'static' no 'final'
static.non.final.field.option=Informar solo de campos 'public'
static.non.final.field.problem.descriptor=Campo 'static' no 'final' <code>#ref</code> #loc
static.variable.may.not.be.initialized.display.name=El campo estático podría no estar inicializado
static.variable.may.not.be.initialized.problem.descriptor=El campo estático <code>#ref</code> podría no inicializarse durante la inicialización de la clase #loc
static.variable.naming.convention.element.description=Campo 'static'
static.variable.of.concrete.class.problem.descriptor=Campo estático ''{0}'' de la clase concreta <code>#ref</code> #loc
static.variable.used.before.initialization.display.name=Campo estático usado antes de la inicialización
static.variable.used.before.initialization.problem.descriptor=Campo estático <code>#ref</code> usado antes de la inicialización #loc
string.buffer.must.have.initial.capacity.display.name='StringBuilder' sin capacidad inicial
string.buffer.must.have.initial.capacity.problem.descriptor=<code>new #ref()</code> sin capacidad inicial #loc
string.buffer.replaceable.by.string.builder.display.name=StringBuffer' puede reemplazarse por 'StringBuilder
string.buffer.replaceable.by.string.builder.problem.descriptor=<code>StringBuffer #ref</code> puede declararse como 'StringBuilder' #loc
string.buffer.replaceable.by.string.display.name=StringBuilder' puede reemplazarse por 'String
string.buffer.replaceable.by.string.problem.descriptor=<code>{0} #ref</code> puede reemplazarse por ''String'' #loc
string.comparison.display.name=Comparación de cadenas mediante '==' en lugar de 'equals()'
string.comparison.problem.descriptor=Los valores de cadena se comparan mediante <code>#ref</code> en lugar de 'equals()' #loc
string.concatenation.argument.to.log.call.display.name=Concatenación de cadenas no constante como argumento en una llamada de registro
string.concatenation.argument.to.log.call.problem.descriptor=Cadena no constante como argumento de la llamada de registro <code>#ref()</code> #loc
string.concatenation.argument.to.log.call.quickfix=Reemplazar la concatenación por un mensaje de registro parametrizado
string.concatenation.argument.to.log.message.format.call.quickfix=Reemplazar 'Message.format()' por un mensaje de registro parametrizado
string.concatenation.argument.to.log.string.format.call.quickfix=Reemplazar 'String.format()' por un mensaje de registro parametrizado
string.concatenation.display.name=Concatenación de cadenas
string.concatenation.in.format.call.display.name=Concatenación de cadenas como argumento de la llamada a 'format()'
string.concatenation.in.format.call.fix.family.name=Reemplazar concatenación con argumento
string.concatenation.in.format.call.problem.descriptor=La llamada a ''{0}()'' tiene un argumento de concatenación de cadenas
string.concatenation.in.format.call.quickfix=Reemplazar la concatenación por un argumento separado
string.concatenation.in.loops.display.name=Concatenación de cadenas en bucles
string.concatenation.in.loops.problem.descriptor=Concatenación de cadenas <code>#ref</code> en un bucle #loc
string.concatenation.in.message.format.call.display.name=Concatenación de cadenas como argumento de la llamada a 'MessageFormat.format()'
string.concatenation.in.message.format.call.problem.descriptor=Concatenación de cadenas como argumento en una llamada a 'MessageFormat.format()' #loc
string.concatenation.inside.string.buffer.append.display.name=Concatenación de cadenas como argumento de la llamada a 'StringBuilder.append()'
string.concatenation.inside.string.buffer.append.problem.descriptor=Concatenación de cadenas como argumento de la llamada a <code>{0}.#ref()</code> #loc
string.concatenation.inside.string.buffer.append.replace.quickfix=Reemplazar con llamadas a 'append()' encadenadas
string.concatenation.introduce.fix=Introducir StringBuilder
string.concatenation.introduce.fix.name=Introducir un nuevo {1} para actualizar la variable ''{0}''
string.concatenation.introduce.fix.name.null.safe=Introducir un nuevo {1} para actualizar la variable ''{0}'' (null-safe)
string.concatenation.missing.whitespace.display.name=Es posible que falte un espacio en blanco en la concatenación de cadenas
string.concatenation.missing.whitespace.option=Ignorar concatenaciones con cadenas variables
string.concatenation.missing.whitespace.problem.descriptor=Es posible que falte un espacio en blanco en la concatenación de cadenas #loc
string.concatenation.problem.descriptor=Concatenación de cadenas <code>#ref</code> en un contexto internacionalizado #loc
string.concatenation.replace.fix=Reemplazar con StringBuilder
string.concatenation.replace.fix.name=Convertir la variable ''{0}'' de String a {1}
string.concatenation.replace.fix.name.null.safe=Convertir la variable ''{0}'' de String a {1} (null-safe)
string.equals.char.sequence.display.name=String.equals()' llamado con un argumento 'CharSequence
string.equals.char.sequence.problem.descriptor=<code>String.equals()</code> se llama con el argumento ''{0}'' #loc
string.equals.empty.string.display.name=String.equals()' puede reemplazarse por 'String.isEmpty()
string.equals.empty.string.fix.family.name=Simplificar la comprobación de cadena vacía
string.equals.empty.string.is.empty.problem.descriptor=<code>#ref("")</code> puede reemplazarse por 'isEmpty()' #loc
string.equals.empty.string.option.do.not.add.null.check=No informar cuando la comprobación de nulos sea necesaria
string.equals.empty.string.problem.descriptor=<code>#ref("")</code> puede reemplazarse por 'length()==0' #loc
string.format.choose.class=Seleccionar clase de formateador
string.format.class.label=Clases de formateador adicionales:
string.format.class.method.label=Métodos adicionales del formateador:
string.indexof.replaceable.by.contains.display.name=La expresión 'String.indexOf()' se puede reemplazar por 'contains()'
string.replace.quickfix=Eliminar el operando de cadena vacía
string.replaceable.by.string.buffer.display.name=String' no constante puede reemplazarse por 'StringBuilder
string.replaceable.by.string.buffer.in.loop.option=Advertir solo al añadir en un bucle
string.replaceable.by.string.buffer.problem.descriptor=La cadena no constante <code>#ref</code> probablemente debería declararse como 'StringBuilder' #loc
string.touppercase.tolowercase.without.locale.display.name=Llamada a 'String.toUpperCase()' o 'toLowerCase()' sin configuración regional
string.touppercase.tolowercase.without.locale.problem.descriptor=Se ha llamado a <code>String.#ref()</code> sin especificar un Locale al usar cadenas internacionalizadas #loc
stringbuffer.field.display.name=campo 'StringBuilder'
stringbuffer.field.problem.descriptor=''{0}'' campo <code>#ref</code> #loc
subtraction.in.compareto.display.name=Resta en 'compareTo()'
subtraction.in.compareto.problem.descriptor=La resta <code>#ref</code> en 'compareTo()' puede dar lugar a un desbordamiento o una pérdida de precisión #loc
super.class.logger.option=Ignorar cuando la superclase tiene un registrador accesible
suppress.for.tests.scope.quickfix=Suprimir para el ámbito 'Tests'
suspicious.array.cast.display.name=Conversión de array sospechosa
suspicious.array.cast.problem.descriptor=Conversión sospechosa a <code>#ref</code> #loc
suspicious.comparator.compare.descriptor.min.value=Se desaconseja devolver Integer.MIN_VALUE desde una función de comparación
suspicious.comparator.compare.descriptor.non.negative=El comparador nunca devuelve valores negativos
suspicious.comparator.compare.descriptor.non.positive=El comparador nunca devuelve valores positivos
suspicious.comparator.compare.descriptor.non.reflexive=El comparador no devuelve 0 para elementos iguales
suspicious.comparator.compare.descriptor.parameter.not.used=El parámetro <code>#ref</code> de ''{0}()'' no se utiliza #loc
suspicious.comparator.compare.display.name=Implementación de 'Comparator.compare()' sospechosa
suspicious.getter.problem.descriptor=El getter <code>#ref()</code> devuelve el campo ''{0}'' #loc
suspicious.getter.setter.display.name=Getter/setter sospechoso
suspicious.indent.after.control.statement.display.name=Sangría sospechosa después de una sentencia de control sin llaves
suspicious.indent.after.control.statement.problem.descriptor=Sangría sospechosa después de la sentencia ''{0}'' #loc
suspicious.integer.div.assignment.display.name=Asignación de división entera sospechosa
suspicious.integer.div.assignment.problem.descriptor=El resultado de la división se trunca a un entero
suspicious.integer.div.assignment.quickfix=Convertir a double
suspicious.literal.underscore.display.name=Guion bajo sospechoso en literal numérico
suspicious.literal.underscore.problem.descriptor=El grupo en el literal numérico con guiones bajos no tiene longitud 3 #loc
suspicious.package.private.access.display.name=Acceso package-private sospechoso
suspicious.setter.problem.descriptor=El setter <code>#ref()</code> asigna el campo ''{0}'' #loc
suspicious.system.arraycopy.display.name=Llamada sospechosa a 'System.arraycopy()'
suspicious.system.arraycopy.problem.descriptor.length.bigger.dest=La longitud siempre es mayor que ''dest.length - destPos'' {0}
suspicious.system.arraycopy.problem.descriptor.length.bigger.src=La longitud siempre es mayor que ''src.length - srcPos'' {0}
suspicious.system.arraycopy.problem.descriptor.ranges.intersect=Copiando al mismo array con rangos que se intersecan
suspicious.system.arraycopy.problem.descriptor4=<code>#ref</code> no es de tipo array #loc
suspicious.system.arraycopy.problem.descriptor5=<code>#ref</code> no es de tipo array #loc
suspicious.system.arraycopy.problem.descriptor6=El tipo de parámetro de origen ''{0}'' no se puede asignar al parámetro de destino <code>#ref</code> de tipo ''{1}'' #loc
suspicious.to.array.call.display.name=Llamada a 'Collection.toArray()' sospechosa
suspicious.to.array.call.fix.family.name=Reemplazar por el array adecuado
suspicious.to.array.call.problem.descriptor=Se esperaba un array de tipo ''{0}[]'', se encontró ''{1}[]'' #loc
swap.equals.fix.family.name=Invertir llamada a método
switch.expression.with.single.default.message=La expresión 'switch' solo tiene el caso 'default'
switch.expression.with.too.few.branches.problem.descriptor=La expresión ''switch'' tiene muy pocas etiquetas case ({0}) y probablemente debería reemplazarse por una sentencia ''if'' o un operador condicional #loc
switch.statement.density.display.name=Sentencia 'switch' con una densidad de ramas demasiado baja
switch.statement.density.min.option=Densidad mínima de ramas: %
switch.statement.density.problem.descriptor=La densidad de bifurcaciones de <code>#ref</code> es demasiado baja ({0}%) #loc
switch.statement.display.name=sentencia 'switch'
switch.statement.with.confusing.declaration.display.name=Variable local usada y declarada en diferentes ramas de 'switch'
switch.statement.with.confusing.declaration.problem.descriptor=Variable local <code>#ref</code> declarada en una rama 'switch' y utilizada en otra #loc
switch.statement.with.single.default.message=La sentencia 'switch' solo tiene el caso 'default'
switch.statement.with.too.few.branches.display.name=Mínimo de ramas 'switch'
switch.statement.with.too.few.branches.ignore.pattern.option=No informar sentencias switch de patrón
switch.statement.with.too.few.branches.min.option=Número mínimo de ramas:
switch.statement.with.too.few.branches.problem.descriptor=La sentencia ''switch'' tiene muy pocas etiquetas case ({0}) y probablemente debería reemplazarse por una sentencia ''if'' #loc
switch.statement.with.too.many.branches.display.name=Máximo de ramas 'switch'
switch.statement.without.default.ignore.option=Ignorar sentencias switch exhaustivas
switch.statements.without.default.display.name=Sentencia 'switch' sin rama 'default'
switch.statements.without.default.problem.descriptor=Sentencia <code>#ref</code> sin rama 'default' #loc
synchronization.on.get.class.display.name=Sincronización sobre 'getClass()'
synchronization.on.get.class.problem.descriptor=Sincronización en <code>#ref()</code> #loc
synchronization.on.local.variable.or.method.parameter.display.name=Sincronización en una variable local o parámetro de método
synchronization.on.local.variable.problem.descriptor=Sincronización en la variable local <code>#ref</code> #loc
synchronization.on.method.parameter.problem.descriptor=Sincronización en el parámetro del método <code>#ref</code> #loc
synchronization.on.static.field.display.name=Sincronización en un campo 'static'
synchronization.on.static.field.problem.descriptor=Sincronización en el campo 'static' <code>#ref</code> #loc
synchronize.on.class.problem.descriptor=Las operaciones de bloqueo en una clase pueden tener efectos secundarios imprevistos #loc
synchronize.on.lock.display.name=Sincronización en un objeto 'Lock'
synchronize.on.lock.problem.descriptor=Es poco probable que la sincronización en un objeto ''{0}'' sea intencionada #loc
synchronize.on.non.final.field.display.name=Sincronización en un campo no final
synchronize.on.non.final.field.problem.descriptor=Sincronización en un campo no final <code>#ref</code> #loc
synchronize.on.this.display.name=Sincronización en 'this'
synchronize.on.this.problem.descriptor=Las operaciones de bloqueo en 'this' pueden tener efectos secundarios imprevistos #loc
synchronized.method.display.name=Método 'synchronized'
synchronized.method.ignore.synchronized.super.option=Ignorar los métodos que sobrescriben un método sincronizado
synchronized.method.include.option=Incluir métodos nativos
synchronized.method.move.quickfix=Mover la sincronización al método
synchronized.method.problem.descriptor=Método ''{0}()'' declarado como <code>#ref</code> #loc
synchronized.on.direct.literal.object.problem.descriptor=Sincronización en el literal {0} <code>#ref</code> #loc
synchronized.on.literal.object.name=Sincronización en un objeto inicializado con un literal
synchronized.on.literal.object.problem.descriptor=Sincronización en {0} <code>#ref</code> inicializado mediante un literal #loc
synchronized.on.literal.object.warn.on.all.option=Advertir sobre todos los literales posibles
synchronized.on.possibly.literal.object.problem.descriptor=Sincronización sobre {0} <code>#ref</code> #loc
system.exit.call.display.name=Llamada a 'System.exit()' o métodos relacionados
system.exit.call.ignore.option=Ignorar en el método main
system.exit.call.problem.descriptor=La llamada a <code>{0}.#ref()</code> no es portable #loc
system.getenv.call.display.name=Llamada a 'System.getenv()'
system.getenv.call.problem.descriptor=La llamada a <code>System.#ref()</code> no es portable #loc
system.properties.display.name=Acceso a las propiedades del sistema
system.properties.problem.descriptor=La llamada a <code>Integer.#ref()</code> puede suponer problemas de seguridad #loc
system.properties.problem.descriptor1=La llamada a <code>Boolean.#ref()</code> puede plantear problemas de seguridad #loc
system.run.finalizers.on.exit.display.name=Llamada a 'System.runFinalizersOnExit()'
system.run.finalizers.on.exit.problem.descriptor=Llamada a <code>System.#ref()</code> #loc
system.set.problem.descriptor=La llamada a <code>System.#ref()</code> puede plantear problemas de seguridad #loc
system.set.security.manager.display.name=Llamada a 'System.setSecurityManager()'
system.set.security.manager.problem.descriptor=La llamada a <code>System.#ref()</code> puede plantear problemas de seguridad #loc
tail.recursion.display.name=Recursión de cola
tail.recursion.problem.descriptor=Llamada recursiva de cola <code>#ref()</code> #loc
tail.recursion.replace.quickfix=Reemplazar recursión de cola por iteración
text.label.in.switch.statement.display.name=Etiqueta de texto en la sentencia 'switch'
text.label.in.switch.statement.problem.descriptor=Etiqueta de texto <code>#ref:</code> en ''switch'' {0, choice, 1#sentencia|2#expresión} #loc
the.whole.project=Todo el proyecto
this.class=Esta clase
this.reference.escaped.in.construction.display.name=Referencia 'this' escapada en la construcción del objeto
this.reference.escaped.in.construction.problem.descriptor=Escape de <code>#ref</code> durante la construcción del objeto #loc
thread.death.rethrown.display.name='ThreadDeath' no relanzado
thread.death.rethrown.problem.descriptor=ThreadDeath <code>#ref</code> no se vuelve a lanzar #loc
thread.local.not.static.final.display.name=Campo 'ThreadLocal' no declarado como 'static final'
thread.local.not.static.final.problem.descriptor=ThreadLocal <code>#ref</code> no está declarado como 'static final' #loc
thread.local.set.with.null.display.name='ThreadLocal.set()' con null como argumento
thread.local.set.with.null.problem.descriptor='ThreadLocal.set()' con null como argumento puede causar una fuga de memoria
thread.local.set.with.null.quickfix=Reemplazar por la llamada a 'ThreadLocal.remove()'
thread.priority.display.name=Llamada a 'Thread.setPriority()'
thread.priority.problem.descriptor=Llamada a <code>Thread.#ref()</code> #loc
thread.run.problem.descriptor=Las llamadas a <code>#ref()</code> probablemente deberían reemplazarse por 'start()' #loc
thread.start.in.construction.display.name=Llamada a 'Thread.start()' durante la construcción del objeto
thread.start.in.construction.problem.descriptor=Llamada a <code>#ref()</code> durante la construcción del objeto #loc
thread.stop.suspend.resume.display.name=Llamada a 'Thread.stop()', 'suspend()' o 'resume()'
thread.stop.suspend.resume.problem.descriptor=Llamada a <code>Thread.#ref()</code> #loc
thread.with.default.run.method.display.name=Instanciación de un 'Thread' con el método 'run()' predeterminado
thread.with.default.run.method.problem.descriptor=Instanciando <code>#ref</code> con el método 'run()' por defecto #loc
thread.yield.display.name=Llamada a 'Thread.yield()'
thread.yield.problem.descriptor=Llamada a <code>Thread.#ref()</code> #loc
three.negations.per.method.display.name=Método con más de tres negaciones
three.negations.per.method.ignore.assert.option=Ignorar negaciones en sentencias 'assert'
three.negations.per.method.ignore.option=Ignorar negaciones en los métodos 'equals()'
three.negations.per.method.problem.descriptor=<code>#ref</code> contiene {0} negaciones #loc
throw,from.finally.block.everywhere.option=Advertir en todos los lugares donde se puedan lanzar excepciones declaradas
throw.caught.locally.display.name='throw' capturado por la sentencia 'try' que lo contiene
throw.caught.locally.ignore.option=Ignorar excepciones relanzadas
throw.caught.locally.problem.descriptor=<code>#ref</code> capturada por la instrucción 'try' que la contiene #loc
throw.from.finally.block.display.name=Throw' dentro del bloque 'finally
throw.from.finally.block.problem.descriptor=<code>#ref</code> dentro del bloque 'finally' #loc
throwable.instance.never.thrown.checked.exception.problem.descriptor=La instancia de la excepción comprobada <code>#ref</code> no se lanza #loc
throwable.instance.never.thrown.error.problem.descriptor=La instancia de error <code>#ref</code> no se ha lanzado #loc
throwable.instance.never.thrown.problem.descriptor=La instancia de Throwable <code>#ref</code> no se lanza #loc
throwable.instance.never.thrown.runtime.exception.problem.descriptor=La instancia de la excepción de tiempo de ejecución <code>new #ref()</code> no se lanza #loc
throwable.not.thrown.display.name='Throwable' no lanzado
throwable.printed.to.system.out.display.name=Throwable' impreso en 'System.out
throwable.printed.to.system.out.problem.descriptor=Argumento ''Throwable'' <code>#ref</code> en la llamada a ''System.{0}.{1}()''
throwable.printed.to.system.out.problem.fix.level.option=Método de registro para la corrección:
throwable.result.of.method.call.ignored.problem.descriptor=El resultado de <code>#ref()</code> no se ha lanzado #loc
throwable.supplier.only.throw.exception.name=El proveedor de Throwable nunca devuelve un valor
throwable.supplier.only.throw.exception.problem.descriptor=El proveedor de Throwable no devuelve ninguna excepción
throwable.supplier.only.throw.exception.quickfix=Reemplazar 'throw' por 'return' en lambda
thrown.exceptions.per.method.display.name=Método con demasiadas excepciones declaradas
thrown.exceptions.per.method.limit.option=Límite de excepciones lanzadas:
thrown.exceptions.per.method.problem.descriptor=<code>#ref</code> tiene demasiadas excepciones declaradas (núm. de excepciones = {0}) #loc
throws.runtime.exception.display.name=Excepción no comprobada declarada en la cláusula 'throws'
throws.runtime.exception.fix.family.name=Quitar de la cláusula 'throws'
throws.runtime.exception.move.quickfix=Mover ''{0}'' a la etiqueta Javadoc ''@throws''
throws.runtime.exception.problem.descriptor=Excepción no comprobada <code>#ref</code> declarada en la cláusula 'throws' #loc
throws.runtime.exception.quickfix=Eliminar ''{0}'' de la cláusula ''throws''
time.tostring.call.display.name=Llamada a 'Time.toString()'
time.tostring.call.problem.descriptor=<code>Time.#ref()</code> en un contexto internacionalizado #loc
to.array.call.style.display.name=Estilo de llamada 'Collection.toArray()'
to.array.call.style.problem.descriptor.presized=Llamada a <code>#ref()</code> con el argumento de array de tamaño predefinido ''{0}'' #loc
to.array.call.style.problem.descriptor.zero=Llamada a <code>#ref()</code> con un argumento de array vacío ''{0}'' #loc
to.array.call.style.quickfix.family.name=Corregir el tamaño del array pasado a la llamada 'toArray()'
to.array.call.style.quickfix.make.presized=Reemplazar el argumento con un array de tamaño predefinido
to.array.call.style.quickfix.make.zero=Reemplazar el argumento con un array vacío
too.broad.catch.display.name=Bloque 'catch' demasiado amplio
too.broad.catch.option=&Solo advertir sobre RuntimeException, Exception, Error o Throwable
too.broad.catch.problem.descriptor=''catch'' de <code>#ref</code> es demasiado amplio, enmascara la excepción ''{0}'' #loc
too.broad.catch.problem.descriptor1=El ''catch'' de <code>#ref</code> es demasiado amplio, enmascarando las excepciones ''{0}'' y ''{1}'' #loc
too.broad.catch.quickfix=Agregar la cláusula ''catch'' para ''{0}''
too.broad.scope.allow.option=<html>Informar sobre variables con una expresión 'new' como inicializador<br>(potencialmente inseguro)</html>
too.broad.scope.display.name=El ámbito de la variable es demasiado amplio
too.broad.scope.inspection.fix.family.name=Reducir el alcance
too.broad.scope.narrow.quickfix=Mover la declaración de ''{0}'' más cerca de sus usos
too.broad.scope.only.blocks.option=Informar solo sobre las variables que pueden moverse a bloques internos
too.broad.scope.problem.descriptor=El ámbito de la variable <code>#ref</code> es demasiado amplio #loc
too.many.constructors.count.limit.option=Límite de número de constructores:
too.many.constructors.display.name=Clase con demasiados constructores
too.many.constructors.ignore.deprecated.option=Ignorar constructores obsoletos
too.many.constructors.problem.descriptor=<code>#ref</code> tiene demasiados constructores (número de constructores = {0}) #loc
too.many.fields.count.limit.option=Límite del número de campos:
too.many.fields.display.name=Clase con demasiados campos
too.many.fields.problem.descriptor=<code>#ref</code> tiene demasiados campos (número de campos = {0}) #loc
too.many.methods.display.name=Clase con demasiados métodos
too.many.methods.problem.descriptor=<code>#ref</code> tiene demasiados métodos (número de métodos = {0}) #loc
trace.level.option=Nivel de traza
transient.field.in.non.serializable.class.display.name=Campo transient en clase no serializable
transient.field.in.non.serializable.class.problem.descriptor=El campo ''{0}'' está marcado como <code>#ref</code> en una clase no serializable #loc
transient.field.not.initialized.display.name=El campo transient no se inicializa durante la deserialización
transient.field.not.initialized.problem.descriptor=Campo transient <code>#ref</code> no inicializado en la deserialización #loc
trivial.if.display.name=Sentencia 'if' redundante
trivial.if.fix.family.name=Simplificar 'if else'
trivial.if.option.ignore.assert.statements=Ignorar sentencias 'if' con 'assert' triviales
trivial.if.option.ignore.chained=Ignorar sentencias 'if' encadenadas
trivial.if.problem.descriptor=La sentencia <code>#ref</code> se puede simplificar #loc
trivial.string.concatenation.display.name=Concatenación con una cadena vacía
trivial.string.concatenation.option.only.necessary=Informar solo si se pueden eliminar las cadenas vacías sin otros cambios
trivial.string.concatenation.problem.descriptor=Cadena vacía en la concatenación
try.finally.can.be.try.with.resources.display.name='try finally' se puede reemplazar con 'try' con recursos
try.finally.can.be.try.with.resources.problem.descriptor=<code>#ref</code> puede utilizar la gestión automática de recursos #loc
try.finally.can.be.try.with.resources.quickfix=Reemplazar con 'try-with-resources'
try.statement.with.multiple.resources.name=La sentencia 'try' con múltiples recursos se puede dividir
try.statement.with.multiple.resources.quickfix=Dividir la sentencia 'try' con múltiples recursos
try.with.identical.catches.checkbox.different.comments=No informar de bloques catch con comentarios diferentes
try.with.identical.catches.display.name=Ramas 'catch' idénticas en la instrucción 'try'
try.with.identical.catches.problem.descriptor=Rama ''catch'' idéntica a la rama ''{0}'' #loc
try.with.identical.catches.quickfix=Contraer bloques 'catch'
type.parameter.extends.enum.type.parameter.problem.descriptor=El parámetro de tipo <code>#ref</code> extiende la enumeración implícitamente final ''{0}'' #loc
type.parameter.extends.enum.wildcard.problem.descriptor=El argumento de tipo comodín <code>#ref</code> extiende la enumeración implícitamente final ''{0}'' #loc
type.parameter.extends.final.class.display.name=El parámetro de tipo extiende la clase 'final'
type.parameter.extends.final.class.quickfix=Reemplazar el parámetro de tipo por la clase real
type.parameter.extends.final.class.type.parameter.problem.descriptor=El parámetro de tipo <code>#ref</code> extiende la clase ''final'' ''{0}'' #loc
type.parameter.extends.final.class.wildcard.problem.descriptor=El argumento de tipo comodín <code>#ref</code> extiende la clase ''final'' ''{0}'' #loc
type.parameter.extends.object.display.name=El parámetro de tipo extiende explícitamente 'Object'
type.parameter.extends.object.ignore.annotated=Ignorar cuando java.lang.Object está anotado
type.parameter.extends.object.problem.descriptor1=El parámetro de tipo <code>#ref</code> extiende explícitamente 'java.lang.Object' #loc
type.parameter.extends.object.problem.descriptor2=El argumento de tipo comodín <code>#ref</code> extiende explícitamente a 'java.lang.Object' #loc
type.parameter.hides.type.parameter.problem.descriptor=El parámetro de tipo <code>#ref</code> oculta el parámetro de tipo ''{0}'' #loc
type.parameter.hides.visible.type.display.name=El parámetro de tipo oculta un tipo visible
type.parameter.hides.visible.type.problem.descriptor=El parámetro de tipo <code>#ref</code> oculta el tipo visible ''{0}'' #loc
type.parameter.naming.convention.element.description=Parámetro de tipo
unary.plus.display.name=Más unario
unary.plus.problem.descriptor=Operador unario <code>#ref</code> #loc
unary.plus.quickfix=Eliminar '+' unario
unchecked.exception.class.display.name=Clase 'Exception' no comprobada
unchecked.exception.class.problem.descriptor=Clase de excepción no comprobada <code>#ref</code> #loc
unclear.binary.expression.display.name=Múltiples operadores con distinta precedencia
unclear.binary.expression.problem.descriptor=La expresión podría usar paréntesis aclaratorios #loc
unclear.binary.expression.quickfix=Añadir paréntesis aclaratorios
unconditional.wait.display.name=Llamada a 'wait()' incondicional
unconditional.wait.problem.descriptor=Llamada incondicional a <code>#ref()</code> #loc
unnecessarily.qualified.inner.class.access.display.name=Acceso a clase interna calificado innecesariamente
unnecessarily.qualified.inner.class.access.option=Ignorar las referencias que requieran una importación
unnecessarily.qualified.inner.class.access.problem.descriptor=''{0}'' está calificado innecesariamente con <code>#ref</code> #loc
unnecessarily.qualified.inner.class.access.quickfix=Eliminar calificador
unnecessarily.qualified.static.usage.display.name=Acceso estático calificado innecesariamente
unnecessarily.qualified.static.usage.ignore.field.option=Ignorar accesos a campos calificados innecesariamente
unnecessarily.qualified.static.usage.ignore.method.option=Ignorar llamadas a métodos calificadas innecesariamente
unnecessarily.qualified.static.usage.problem.descriptor=Llamada innecesariamente calificada al método estático <code>{0}()</code> #loc
unnecessarily.qualified.static.usage.problem.descriptor1=Acceso calificado innecesariamente al campo estático <code>{0}</code> #loc
unnecessarily.qualified.statically.imported.element.display.name=Elemento importado estáticamente calificado innecesariamente
unnecessarily.qualified.statically.imported.element.problem.descriptor=El elemento importado estáticamente ''{0}'' está calificado innecesariamente con <code>#ref</code> #loc
unnecessarily.qualified.statically.imported.element.quickfix=Eliminar calificador innecesario
unnecessary.block.statement.problem.descriptor=Las llaves que rodean esta instrucción son innecesarias #loc
unnecessary.boxing.display.name=Boxing innecesario
unnecessary.boxing.inside.value.of.problem.descriptor=Boxing redundante, se puede utilizar la llamada a <code>{0}.{1}()</code> en su lugar #loc
unnecessary.boxing.problem.descriptor=Boxing innecesario #loc
unnecessary.boxing.remove.quickfix=Eliminar boxing
unnecessary.boxing.superfluous.option=Informar solo sobre expresiones de boxing verdaderamente superfluas
unnecessary.break.display.name=Sentencia 'break' innecesaria
unnecessary.break.problem.descriptor=La sentencia <code>#ref</code> es innecesaria #loc
unnecessary.code.block.display.name=Bloque de código innecesario
unnecessary.code.block.unwrap.quickfix=Desenvolver bloque
unnecessary.constant.array.creation.expression.display.name=Expresión 'new' redundante en la creación de un array constante
unnecessary.constant.array.creation.expression.family.quickfix=Eliminar la especificación de tipo de la expresión de nuevo array
unnecessary.constant.array.creation.expression.problem.descriptor=Se puede eliminar <code>#ref</code> de la expresión del nuevo array #loc
unnecessary.constructor.annotation.option=Ignorar constructores con una anotación
unnecessary.constructor.display.name=Constructor sin argumentos redundante
unnecessary.constructor.problem.descriptor=El constructor sin argumentos <code>#ref()</code> es redundante #loc
unnecessary.constructor.remove.quickfix=Eliminar constructor redundante
unnecessary.continue.display.name=Sentencia 'continue' innecesaria
unnecessary.continue.problem.descriptor=<code>#ref</code> es innecesario como última sentencia de un bucle #loc
unnecessary.conversion.to.string.display.name=Conversión innecesaria a 'String'
unnecessary.default.display.name='default' innecesario para la instrucción 'switch' de enum
unnecessary.default.expressions.option=Informar solo de expresiones switch
unnecessary.default.problem.descriptor=La rama <code>#ref</code> es innecesaria #loc
unnecessary.default.quickfix=Eliminar la rama 'default'
unnecessary.enum.constructor.modifier.problem.descriptor=El modificador <code>#ref</code> es redundante para los constructores de enumeraciones #loc
unnecessary.explicit.numeric.cast.display.name=Conversión numérica explícita innecesaria
unnecessary.explicit.numeric.cast.problem.descriptor=''{0}'' se ha convertido innecesariamente a <code>#ref</code> #loc
unnecessary.explicit.numeric.cast.quickfix=Eliminar conversión
unnecessary.final.on.local.variable.or.parameter.display.name='final' innecesario en variable local o parámetro
unnecessary.final.on.local.variable.problem.descriptor=<code>#ref</code> innecesario en la variable ''{0}'' #loc
unnecessary.final.on.parameter.only.interface.option=Advertir solo en métodos abstractos o de interfaz
unnecessary.final.on.parameter.problem.descriptor=<code>#ref</code> innecesario en el parámetro ''{0}'' #loc
unnecessary.final.report.local.variables.option=Reportar variables locales
unnecessary.final.report.parameters.option=Parametros de reporte
unnecessary.final.report.pattern.variables.option=Informar variables de patrón
unnecessary.fully.qualified.name.display.name=Nombre plenamente cualificado innecesario
unnecessary.fully.qualified.name.fix.family.name=Reemplazar el nombre totalmente cualificado
unnecessary.fully.qualified.name.problem.descriptor1=El calificador <code>#ref</code> es innecesario y puede reemplazarse por un import #loc
unnecessary.fully.qualified.name.problem.descriptor2=El calificador <code>#ref</code> es innecesario y puede eliminarse #loc
unnecessary.fully.qualified.name.remove.quickfix=Eliminar calificación innecesaria
unnecessary.fully.qualified.name.replace.quickfix=Reemplazar el nombre cualificado por una importación
unnecessary.inherit.doc.class.invalid.problem.descriptor=<code>#ref</code> no es válido en clases #loc
unnecessary.inherit.doc.constructor.invalid.problem.descriptor=<code>#ref</code> no es válido en constructores #loc
unnecessary.inherit.doc.constructor.no.super.problem.descriptor=No se encontró un supermétodo del cual heredar Javadoc #loc
unnecessary.inherit.doc.display.name=Comentario Javadoc '{@inheritDoc}' innecesario
unnecessary.inherit.doc.field.invalid.problem.descriptor=<code>#ref</code> no es válido en campos #loc
unnecessary.inherit.doc.module.invalid.problem.descriptor=<code>#ref</code> no es válido en las declaraciones de módulo #loc
unnecessary.inherit.doc.problem.descriptor=El comentario Javadoc que solo contiene <code>#ref</code> es innecesario #loc
unnecessary.inherit.doc.quickfix=Eliminar {@inheritDoc} innecesario
unnecessary.initcause.display.name=Llamada innecesaria a 'Throwable.initCause()'
unnecessary.initcause.problem.descriptor=Llamada innecesaria a <code>Throwable.#ref()</code>
unnecessary.initcause.quickfix=Eliminar la llamada a 'Throwable.initCause()'
unnecessary.inner.enum.modifier.problem.descriptor=El modificador <code>#ref</code> es redundante para las enumeraciones internas #loc
unnecessary.inner.interface.modifier.problem.descriptor=El modificador <code>#ref</code> es redundante para las interfaces internas #loc
unnecessary.inner.record.modifier.problem.descriptor=El modificador <code>#ref</code> es redundante para los registros internos
unnecessary.interface.field.modifier.problem.descriptor=El modificador <code>#ref</code> es redundante para los campos de interfaz #loc
unnecessary.interface.inner.class.modifier.problem.descriptor=El modificador <code>#ref</code> es redundante para las clases internas de interfaces #loc
unnecessary.interface.member.modifier.problem.descriptor=El modificador <code>#ref</code> es redundante para los miembros de la interfaz #loc
unnecessary.interface.method.modifier.problem.descriptor=El modificador <code>#ref</code> es redundante para los métodos de interfaz #loc
unnecessary.interface.modifier.problem.descriptor=El modificador <code>#ref</code> es redundante para las interfaces #loc
unnecessary.java.doc.link.fix.family.name=Eliminar etiqueta redundante
unnecessary.javadoc.link.display.name=Enlace de Javadoc innecesario
unnecessary.javadoc.link.option=Ignorar enlaces inline a los supermétodos
unnecessary.javadoc.link.quickfix=Eliminar ''{0}'' innecesario
unnecessary.javadoc.link.super.method.problem.descriptor=<code>#ref</code> apuntando al supermétodo es innecesario #loc
unnecessary.javadoc.link.this.class.problem.descriptor=<code>#ref</code> que apunta a la clase contenedora es innecesario #loc
unnecessary.javadoc.link.this.method.problem.descriptor=El <code>#ref</code> que apunta a este método es innecesario #loc
unnecessary.label.on.break.statement.display.name=Etiqueta innecesaria en la sentencia 'break'
unnecessary.label.on.break.statement.problem.descriptor=Etiqueta innecesaria <code>#ref</code> en la instrucción break #loc
unnecessary.label.on.continue.statement.display.name=Etiqueta innecesaria en la sentencia 'continue'
unnecessary.label.on.continue.statement.problem.descriptor=Etiqueta <code>#ref</code> innecesaria en la sentencia continue #loc
unnecessary.label.remove.quickfix=Eliminar etiqueta
unnecessary.local.variable.problem.descriptor=La variable local <code>#ref</code> es redundante #loc
unnecessary.main.modifier.problem.descriptor=El modificador <code>#ref</code> es redundante para el método ''main'' de Java {0} #loc
unnecessary.modifier.display.name=Modificador innecesario
unnecessary.parentheses.conditional.option=Ignorar los paréntesis alrededor de la condición de expresiones condicionales
unnecessary.parentheses.display.name=Paréntesis innecesarios
unnecessary.parentheses.option=Ignorar paréntesis aclaratorios
unnecessary.parentheses.problem.descriptor=Los paréntesis alrededor de <code>#ref</code> son innecesarios #loc
unnecessary.parentheses.remove.quickfix=Eliminar paréntesis innecesarios
unnecessary.qualifier.for.super.problem.descriptor=El calificador <code>#ref</code> en 'super' es innecesario en este contexto #loc
unnecessary.qualifier.for.this.display.name=Calificador innecesario para 'this' o 'super'
unnecessary.qualifier.for.this.problem.descriptor=El calificador <code>#ref</code> en 'this' es innecesario en este contexto #loc
unnecessary.qualifier.for.this.remove.quickfix=Eliminar calificador innecesario
unnecessary.record.modifier.problem.descriptor=El modificador <code>#ref</code> es redundante para los records
unnecessary.return.constructor.problem.descriptor=<code>#ref</code> es innecesario como última sentencia en un constructor #loc
unnecessary.return.display.name=Sentencia 'return' innecesaria
unnecessary.return.option=Ignorar en la rama 'then' de la sentencia 'if' con rama 'else'
unnecessary.return.problem.descriptor=<code>#ref</code> es innecesario como la última sentencia en un método 'void' #loc
unnecessary.semicolon.display.name=Punto y coma innecesario
unnecessary.semicolon.ignore.after.enum.constants.option=Ignorar los puntos y coma innecesarios después de las constantes de enumeración
unnecessary.semicolon.problem.descriptor=Punto y coma innecesario <code>#ref</code> #loc
unnecessary.semicolon.remove.quickfix=Eliminar punto y coma innecesario
unnecessary.strictfp.modifier.problem.descriptor=El modificador <code>#ref</code> es redundante en Java 17 y versiones posteriores
unnecessary.string.escape.display.name=Carácter escapado innecesariamente
unnecessary.string.escape.problem.descriptor=<code>{0}</code> está escapado innecesariamente
unnecessary.string.escape.quickfix=Eliminar escape innecesario
unnecessary.super.constructor.display.name=Llamada innecesaria a 'super()'
unnecessary.super.constructor.problem.descriptor=<code>#ref</code> es innecesario #loc
unnecessary.super.constructor.remove.quickfix=Eliminar 'super()' innecesario
unnecessary.super.qualifier.display.name=Calificador 'super' innecesario
unnecessary.super.qualifier.problem.descriptor=El calificador <code>#ref</code> es innecesario en este contexto #loc
unnecessary.super.qualifier.quickfix=Eliminar el calificador 'super' innecesario
unnecessary.temporary.object.fix.family.name=Reemplazar concatenación
unnecessary.temporary.on.conversion.from.string.display.name=Objeto temporal innecesario en la conversión desde 'String'
unnecessary.temporary.on.conversion.to.string.display.name=Objeto temporal innecesario en la conversión a 'String'
unnecessary.this.display.name=Calificador 'this' innecesario
unnecessary.this.ignore.assignments.option=Ignorar las asignaciones de campos
unnecessary.this.problem.descriptor=<code>#ref</code> es innecesario en este contexto #loc
unnecessary.this.remove.quickfix=Eliminar el calificador 'this' innecesario
unnecessary.tostring.call.display.name=Llamada innecesaria a 'toString()'
unnecessary.tostring.call.option.report.with.empty.string=Informar sobre las llamadas que pueden sustituirse por una concatenación con la cadena vacía
unnecessary.tostring.call.problem.descriptor=Llamada a <code>#ref()</code> innecesaria #loc
unnecessary.tostring.call.problem.empty.string.descriptor=Puede reemplazarse con una concatenación con una cadena vacía
unnecessary.transient.modifier.problem.descriptor=El modificador <code>#ref</code> es redundante para un campo 'static'
unnecessary.unary.minus.display.name=Menos unario innecesario
unnecessary.unary.minus.problem.descriptor=Operador unario <code>#ref</code> innecesario #loc
unnecessary.unary.minus.quickfix=Eliminar el menos unario e invertir el signo de la operación padre
unnecessary.unary.minus.remove.quickfix=Eliminar doble menos unario
unnecessary.unboxing.display.name=Unboxing innecesario
unnecessary.unboxing.problem.descriptor=Unboxing innecesario #loc
unnecessary.unboxing.remove.quickfix=Eliminar unboxing
unnecessary.unboxing.superfluous.option=Informar solo sobre expresiones de unboxing verdaderamente superfluas
unnecessary.unicode.escape.display.name=Secuencia de escape Unicode innecesaria
unnecessary.unicode.escape.fix.family.name=Reemplazar por carácter
unnecessary.unicode.escape.fix.text=Reemplazar con el carácter {0, choice, 1#de salto de línea|2#tabulador|3#de espacio}
unnecessary.unicode.escape.problem.descriptor=La secuencia de escape Unicode <code>#ref</code> puede reemplazarse por ''{0}'' #loc
unnecessary.unicode.escape.problem.newline.descriptor=La secuencia de escape Unicode <code>#ref</code> se puede reemplazar con un carácter de salto de línea #loc
unpredictable.big.decimal.constructor.call.display.name=Llamada al constructor 'BigDecimal' impredecible
unpredictable.big.decimal.constructor.call.ignore.complex.literals.option=Ignorar llamadas al constructor con múltiples literales (p. ej. 0.1 + 0.2)
unpredictable.big.decimal.constructor.call.ignore.references.option=Ignorar llamadas al constructor con argumentos de variables o llamadas a métodos
unpredictable.big.decimal.constructor.call.problem.descriptor=Llamada a <code>new #ref()</code> impredecible #loc
unqualified,static.usage.only.report.static.usages.option=Solo informar el acceso estático desde un contexto no estático
unqualified.field.access.display.name=Acceso a campo de instancia no calificado con 'this'
unqualified.field.access.problem.descriptor=El acceso al campo de instancia <code>#ref</code> no está calificado con 'this' #loc
unqualified.inner.class.access.display.name=Acceso a clase interna no calificada
unqualified.inner.class.access.option=Ignorar las referencias a clases internas locales
unqualified.inner.class.access.problem.descriptor=<code>#ref</code> no está calificada con la clase externa #loc
unqualified.inner.class.access.quickfix=Calificar con la clase externa
unqualified.method.access.display.name=Llamada a método de instancia no calificada con 'this'
unqualified.method.access.problem.descriptor=La llamada al método de instancia <code>#ref()</code> no está calificada con 'this' #loc
unqualified.static.access.fix.family.name=Calificar el acceso estático
unqualified.static.usage.display.name=Acceso estático no calificado
unqualified.static.usage.ignore.field.option=Ignorar accesos a campos no calificados
unqualified.static.usage.ignore.method.option=Ignorar llamadas a métodos no calificados
unqualified.static.usage.problem.descriptor=Llamada a método estático no calificada <code>#ref()</code> #loc
unqualified.static.usage.problem.descriptor1=Acceso a campo estático <code>#ref</code> no calificado #loc
unqualified.static.usage.qualify.field.quickfix=Calificar el acceso al campo estático
unqualified.static.usage.qualify.method.quickfix=Calificar llamada a método estático
unrunnable.main.method.problem.descriptor=El método <code>#ref()</code> no se puede ejecutar porque la clase contenedora no tiene un nombre calificado completo
unsecure.random.number.generation.display.name=Generación de números aleatorios insegura
unsecure.random.number.generation.problem.descriptor1=Por motivos de seguridad, utilice 'java.security.SecureRandom' en lugar de <code>java.lang.Math.#ref()</code> #loc
unsecure.random.number.generation.problem.descriptor2=Por motivos de seguridad, utilice 'java.security.SecureRandom' en lugar de <code>java.util.#ref</code> #loc
unsecure.random.number.generation.problem.descriptor3=Por motivos de seguridad, utilice 'java.security.SecureRandom' en lugar de <code>#ref</code> #loc
unused.import.problem.descriptor=Importación no utilizada <code>#ref</code> #loc
unused.label.display.name=Etiqueta no utilizada
unused.label.problem.descriptor=Etiqueta no utilizada <code>#ref</code> #loc
unused.label.remove.quickfix=Eliminar etiqueta no utilizada
update.label=Actualizar nombres que empiezan por:
upper.case.field.name.not.constant.display.name=Campo no constante con nombre en mayúsculas
upper.case.field.name.not.constant.problem.descriptor=Campo no constante <code>#ref</code> con nombre de estilo constante #loc
use.0index.in.jdbc.prepared.statement.problem.descriptor=Uso del índice '0' en JDBC PreparedStatement #loc
use.0index.in.jdbc.resultset.display.name=Uso del índice 0 en JDBC ResultSet
use.0index.in.jdbc.resultset.problem.descriptor=Uso del índice '0' en un ResultSet de JDBC #loc
use.contentequals=Usar 'contentEquals()' para la comparación con 'AbstractStringBuilder'
use.equalsignorecase.for.case.insensitive.comparison=Usar 'equalsIgnoreCase()' para comparaciones que no distinguen entre mayúsculas y minúsculas
use.isblank.to.check.if.string.is.whitespace.or.empty=Use 'isBlank()' para comprobar si una cadena está vacía o solo contiene espacios en blanco
use.obsolete.collection.type.display.name=Uso de tipos de colección obsoletos
use.obsolete.collection.type.ignore.library.arguments.option=Ignorar tipos de colección obsoletos donde sean requeridos
use.obsolete.collection.type.problem.descriptor=Tipo de colección obsoleto <code>#ref</code> utilizado #loc
use.of.awt.peer.class.display.name=Uso de la clase peer de AWT
use.of.awt.peer.class.problem.descriptor=El uso de la clase peer de AWT <code>#ref</code> no es portable #loc
use.of.clone.call.method.problem.descriptor=Implementación de <code>#ref()</code>
use.of.clone.call.problem.descriptor=Llamada a <code>#ref()</code>
use.of.clone.display.name=Uso de 'clone()' o 'Cloneable'
use.of.clone.reference.problem.descriptor=Uso de <code>#ref</code>
use.of.concrete.class.option.ignore.abstract=Ignorar tipos de clase abstracta
use.of.concrete.class.option.ignore.records=Ignorar registros de Java
use.of.concrete.class.option.report.cast=Informar sobre el tipo utilizado en la expresión de conversión
use.of.concrete.class.option.report.instance.fields=Informar tipos de campos de instancia
use.of.concrete.class.option.report.instanceof=Informar del tipo utilizado en comparaciones instanceof, patrones o getClass()
use.of.concrete.class.option.report.local.variable=Reportar tipo de variable local
use.of.concrete.class.option.report.method.returns=Informar tipo de retorno del método
use.of.concrete.class.option.report.parameter=Informar tipo de parámetro del método
use.of.concrete.class.option.report.static.fields=Informar tipo de campo estático
use.of.concrete.jdbc.driver.class.display.name=Uso de una clase de controlador JDBC concreta
use.of.concrete.jdbc.driver.class.problem.descriptor=El uso de la clase de controlador JDBC concreta <code>#ref</code> no es portable #loc
use.of.obsolete.date.time.api.display.name=Uso de API de fecha y hora obsoleta
use.of.obsolete.date.time.api.problem.descriptor=Se utiliza el tipo de fecha y hora obsoleto <code>#ref</code> #loc
use.of.properties.as.hashtable.fix.family.name=Corregir acceso a propiedades
use.processbuilder.class.display.name=Uso de la clase 'java.lang.ProcessBuilder'
use.processbuilder.class.problem.descriptor=El uso de <code>#ref</code> no es portable #loc
use.stringtokenizer.display.name=Uso de 'StringTokenizer'
use.stringtokenizer.problem.descriptor=<code>#ref</code> en un contexto internacionalizado #loc
use.sun.classes.display.name=Uso de clases 'sun.*'
use.sun.classes.problem.descriptor=El uso de la clase proporcionada por Sun <code>#ref</code> no es portable #loc
use.system.out.err.display.name=Uso de 'System.out' o 'System.err'
use.system.out.err.problem.descriptor=Los usos de <code>#ref</code> probablemente deberían reemplazarse por un registro más robusto #loc
use.system.out.err.problem.fix.err.option=Método de registro para 'System.err':
use.system.out.err.problem.fix.out.option=Método de registro para 'System.out':
utility.class.can.be.enum.display.name=La clase de utilidad puede ser 'enum'
utility.class.code.can.be.enum.problem.descriptor=La clase de utilidad <code>#ref</code> puede ser 'enum' #loc
utility.class.code.can.be.enum.quickfix=Convertir a 'enum'
utility.class.display.name=Clase de utilidad
utility.class.problem.descriptor=La clase <code>#ref</code> solo tiene miembros 'static', lo que indica una construcción procedimental #loc
utility.class.with.public.constructor.display.name=Clase de utilidad con constructor 'public'
utility.class.with.public.constructor.fix.family.name=Hacer que los constructores no sean públicos
utility.class.with.public.constructor.make.private.quickfix=Hacer {0, choice, 1#el constructor|2#los constructores} ''private''
utility.class.with.public.constructor.make.protected.quickfix=Hacer {0, choice, 1#el constructor|2#los constructores} ''protected''
utility.class.with.public.constructor.problem.descriptor=La clase <code>#ref</code> solo tiene miembros 'static' y un constructor 'public' #loc
utility.class.without.private.constructor.cant.generate.constructor.message=La clase de utilidad tiene instanciaciones, no se creará el constructor privado
utility.class.without.private.constructor.create.quickfix=Generar constructor 'private' vacío
utility.class.without.private.constructor.display.name=Clase de utilidad sin constructor 'private'
utility.class.without.private.constructor.make.quickfix=Hacer que el constructor sea 'private'
utility.class.without.private.constructor.option=Ignorar clases que solo tienen un método main
utility.class.without.private.constructor.problem.descriptor=La clase <code>#ref</code> solo tiene miembros 'static' y carece de un constructor 'private' #loc
value.of.post.decrement.problem.descriptor=Se utiliza el valor de la expresión de post-decremento <code>#ref</code> #loc
value.of.post.increment.problem.descriptor=Se utiliza el valor de la expresión de post-incremento <code>#ref</code> #loc
value.of.pre.decrement.problem.descriptor=Se utiliza el valor de la expresión de pre-decremento <code>#ref</code> #loc
value.of.pre.increment.problem.descriptor=El valor de la expresión de pre-incremento <code>#ref</code> se utiliza #loc
variable.argument.method.display.name=Método varargs
variable.argument.method.problem.descriptor=Método varargs <code>#ref()</code> #loc
variable.argument.method.quickfix=Convertir el parámetro varargs a un array
variable.not.used.inside.conditional.problem.descriptor=<code>#ref</code> comprobado para 'null' no se utiliza dentro del condicional #loc
variable.not.used.inside.if.display.name=Referencia verificada para 'null' no utilizada dentro de 'if'
variable.not.used.inside.if.problem.descriptor=<code>#ref</code> verificado como 'null' no se utiliza dentro de 'if' #loc
variable.type.can.be.explicit.display.name=El tipo de variable puede ser explícito
volatile.array.field.display.name=Campo de array volátil
volatile.field.problem.descriptor=Campo volátil <code>#ref</code> de tipo ''{0}'' #loc
wait.called.on.condition.display.name=Llamada a 'wait()' en un objeto 'java.util.concurrent.locks.Condition'
wait.called.on.condition.problem.descriptor=Llamada a <code>#ref()</code> en el objeto Condition #loc
wait.not.in.loop.display.name='wait()' no llamado en un bucle
wait.not.in.loop.problem.descriptor=La llamada a <code>#ref()</code> no está dentro de un bucle #loc
wait.notify.not.in.synchronized.context.display.name='wait()' o 'notify()' no está en un contexto sincronizado
wait.notify.while.not.synchronized.on.problem.descriptor=Llamada a <code>#ref</code> sin estar sincronizado en ''{0}'' #loc
wait.or.await.without.timeout.display.name='wait()' o 'await()' sin tiempo de espera
wait.or.await.without.timeout.problem.descriptor=<code>#ref</code> sin tiempo de espera #loc
wait.while.holding.two.locks.display.name='wait()' mientras se mantienen dos bloqueos
wait.while.holding.two.locks.problem.descriptor=Se realiza una llamada a <code>#ref()</code> mientras se mantienen dos bloqueos #loc
wait.without.corresponding.notify.display.name=Wait()' sin el correspondiente 'notify()
wait.without.corresponding.notify.problem.descriptor=Llamada a <code>#ref()</code> sin el correspondiente <code>notify()</code> o <code>notifyAll()</code> #loc
warn.level.and.lower.option=Nivel de advertencia e inferiores
warn.on.label=Advertir sobre:
weaken.visibility.quickfix=Debilitar visibilidad
while.can.be.foreach.display.name=El bucle 'while' puede reemplazarse por un bucle 'for' mejorado
while.can.be.foreach.problem.descriptor=El bucle <code>#ref</code> puede reemplazarse por un 'for' mejorado #loc
while.loop.spins.on.field.display.name=Bucle 'while' gira sobre un campo
while.loop.spins.on.field.fix.family.name=Corregir bucle de espera activa
while.loop.spins.on.field.fix.spinwait=Añadir Thread.onSpinWait()
while.loop.spins.on.field.fix.volatile=Hacer ''{0}'' volatile
while.loop.spins.on.field.fix.volatile.spinwait=Hacer ''{0}'' volatile y añadir Thread.onSpinWait()
while.loop.spins.on.field.ignore.non.empty.loops.option=Advertir solo si el bucle está vacío
while.loop.spins.on.field.problem.descriptor=El bucle <code>#ref</code> gira sobre el campo #loc
wrap.with.arrays.hash.code.quickfix=Envolver con ''{0}''
write.only.object.display.name=Objeto de solo escritura
write.only.object.option.ignore.impure.constructors=Ignorar constructores impuros
