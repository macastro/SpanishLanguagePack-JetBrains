class.both.ejb.and.interceptor=La clase ''{0}'' no debe definirse simultáneamente como clase EJB y clase interceptora
class.is.not.RMI.IIOP.compatible=La clase ''{0}'' no es compatible con RMI/IIOP
class.should.be.both.abstract.and.not.abstract=La clase ''{0}'' debe ser tanto abstracta como no abstracta debido a un conflicto de EJB
class.should.extend=La clase ''{0}'' debe extender ''{1}''
class.should.implement=La clase ''{0}'' debe implementar ''{1}''
class.should.not.extend=La clase ''{0}'' no debe extender ''{1}''
class.should.not.implement=La clase ''{0}'' no debe implementar ''{1}''
cmp.field.getter.is.not.defined=El getter del campo CMP ''{0}'' no está definido
cmp.field.setter.is.not.defined=El setter del campo CMP ''{0}'' no está definido
cmp1.entity.beans.not.authorized.to.define.method=Los beans de entidad CMP 1.1 no tienen autorización para definir el método ''{0}''
cmr.field.getter.is.not.defined=El getter del campo CMR ''{0}'' no está definido
cmr.field.setter.is.not.defined=El setter para el campo CMR ''{0}'' no está definido
cmr.field.setter.should.have.parameter=El setter del campo CMR debe tener un parámetro de tipo ''{0}''
ejb.class.should.implement.interface.methods=La clase de bean EJB ''{0}'' debe implementar ''{1}''
ejb.class.should.not.be.exposed=La clase EJB ''{0}'' no debe exponerse a través de la interfaz ''{1}''
ejb.class.should.not.define.method=La clase EJB no debería definir el método ''{0}''
ejb.enterprise.java.beans=EJB: Enterprise Java Beans
ejb.field.popup.tooltip.navigate.to.field.declaration=Navegar a la declaración del campo en XML
ejb.interfaces.should.not.be.exposed=La interfaz EJB ''{0}'' no debe exponerse a través de la interfaz de punto final de servicio ''{1}''
ejb.label.name=<ejb-name>(&N):
ejb.library.not.linked=La clase ''{0}'' no está disponible. No es posible realizar el desarrollo de EJB.
ejb.local.interfaces.should.not.be.exposed=La interfaz EJB local ''{0}'' no debe exponerse a través de la interfaz ''{1}''
ejb.reference.bad.beanname=EJB ''{0}'' referenciado por ''{1}''
ejb.reference.beaninterface.parameter.should.be.specified=Referencia EJB ambigua, se debe especificar 'beanName' o un 'beanInterface' más preciso
ejb.reference.ejb.interface.not.found=El EJB ''{0}'' no tiene la interfaz ''{1}''
ejb.reference.no.interface.view.wrong.type=La vista sin interfaz solo se puede usar para beans de sesión
ejb.reference.no.interface.view.wrong.version=La vista sin interfaz no se puede utilizar en la versión {0}.
ejb.reference.not.found=No se encontró el EJB ''{0}'' con la interfaz de componente ''{1}''
ejb.references.popup.title.choose.ejb.class=Seleccionar clase EJB
ejb.references.popup.title.choose.query=Seleccionar consulta
ejb.references.popup.title.choose.resource=Seleccionar recurso
error.message.cmp.field.lowercase=El nombre del campo CMP en un bean de entidad CMP 2.x debe comenzar con una letra minúscula
error.message.cmr.field.lowercase=El nombre del campo CMR debe comenzar con una letra minúscula
error.text.duplicate.query.method=Ya se ha definido una consulta con este método.
error.text.ejb.does.not.have.component.interface=El EJB ''{0}'' no tiene la interfaz de componente ''{1}''
error.text.no.cmp.fields.for.bmp.bean=Un Bean BMP no debe contener campos CMP
error.text.no.cmp.version.for.bmp.bean=Un Bean BMP no debe tener una versión CMP
error.text.no.primkey.for.bmp.bean=Se debe definir una clase prim-key-class para el Bean BMP
error.text.no.primkeyfield.defined=Se debe definir el campo primkey-field
error.text.no.primkeyfield.or.primkeyclass.defined=Se debe definir primkey-field o prim-key-class para la entidad CMP
error.text.primary.key.field.type.should.be.equal.to.primary.key.class=El tipo de campo de la clave primaria debe ser igual a la clase de la clave primaria
field.should.have.modifier=El campo ''{0}'' debe ser {1}
field.should.not.have.modifier=El campo ''{0}'' no debe ser {1}
finder.recursive.panel.unknown=<Desconocido>
home.interface.should.define.create.method=La interfaz ''{0}'' debe definir al menos un método de creación.
home.interface.should.define.findbyprimarykey.method=La interfaz ''{0}'' debe definir exactamente un método ''findByPrimaryKey''.
injected.property.invalid.type=El tipo de recurso inyectado ''{0}'' no es válido
injected.property.method.should.be.setter=El objetivo inyectado ''{0}'' debe ser un campo o un método setter
inspection.name.ejb.class=Inspección básica de clases EJB
inspection.name.ejb.class.entity=Inspección de clase EJB de entidad
inspection.name.ejb.class.warnings=Advertencias de clase EJB
inspection.name.entity.home.interface=Inspección de la interfaz home de entidad
inspection.name.entity.interface=Inspección de interfaz de EJB de entidad
inspection.name.environment.problems=Inspección del entorno EJB
inspection.name.interceptor=Inspección de interceptores EJB
inspection.name.interceptor.warnings=Inspección de nombres de métodos de interceptor
inspection.name.interface.method.signature=Inspección de la signatura del método de interfaz EJB
inspection.name.interface.signature=Inspección de firma de interfaz EJB
inspection.name.prohibited.package.usage=Uso de paquetes prohibidos
inspection.name.remote.requirements=Inspección de requisitos de distribución RMI
inspection.name.session.home.interface=Inspección de la interfaz Home de sesión
inspection.name.static.access=Inspección de acceso estático
inspection.name.this.reference=Inspección de uso de 'this'
intention.family.ejb.reference.type.fix=Corregir interfaz de referencia EJB
intention.family.ejb.reference.type.fix.0=Generar interfaz de referencia EJB ''{0}''
intention.family.generate.interceptor.methods=Generar métodos de interceptor
intention.family.remove.dependency.injection.settings=Eliminar ajustes de inyección de dependencias
intention.family.remove.interceptor.method.metadata=Eliminar metadatos del método interceptor
interceptor.class.has.no.annotated.methods=La clase de interceptor ''{0}'' no tiene métodos de interceptor
interceptor.method.name.should.be.standard=El método del interceptor ''{0}'' debe llamarse ''{1}''
interface.should.extend=La interfaz ''{0}'' debe extender ''{1}''
interface.should.not.extend=La interfaz ''{0}'' no debe extender ''{1}''
method.name.conflict=El nombre del método ''{0}'' no debe entrar en conflicto con los nombres definidos por la arquitectura EJB
method.parameter.of.type.expected=El método ''{0}'' solo debe aceptar parámetros de tipo ''{1}''
method.should.be.both.abstract.and.not.abstract=El método ''{0}'' debe ser tanto abstracto como no abstracto debido a un conflicto de EJB
method.should.have.modifier=El método ''{0}'' debe ser {1}
method.should.not.be.final.or.static=No se permiten métodos 'final' o 'static' aquí.
method.should.not.have.modifier=El método ''{0}'' no debe ser {1}
method.should.not.throw=El método ''{0}'' no debería lanzar ''{1}''
method.should.return=El método ''{0}'' debe devolver {1}
method.should.return.one.of=El método ''{0}'' debe devolver uno de {1}
method.should.throw=El método ''{0}'' debe lanzar ''{1}''
method.too.many.parameters=El método ''{0}'' solo debe tener {1} parámetros
more.than.one.dependency.injection.configured.for.field=Se ha configurado más de una inyección de dependencias para el campo ''{0}''
more.than.one.dependency.injection.configured.for.method=Se ha configurado más de una inyección de dependencias para el método ''{0}''
more.than.one.method.defined.for.interceptor.method.type=Se ha definido más de un método para el tipo de método interceptor ''{0}'' en la clase ''{1}''
prohibited.package.usage=No se permite el uso de ''{0}'' en EJB
prohibited.static.field.access=EJB no debe escribir en el campo estático ''{0}''
public.no.args.constructor.required=La clase EJB debe proporcionar un constructor público sin argumentos.
service.endpoint.interface.cannot.have.fields=La interfaz de punto final de servicio EJB no puede tener declaraciones de constantes.
session.home.should.not.define.finder.methods=La interfaz home de un bean de sesión no debe definir ningún método finder.
several.ranged.variable.declarations.are.not.supported=No se admiten varias declaraciones de variables de rango. Utilice declaraciones de miembros de colección en su lugar (por ejemplo, 'IN(o.lineItems) l').
stateless.session.bean.class.should.define.exactly.one.ejbcreate.method=La clase de bean de sesión sin estado debe definir exactamente un método ejbCreate().
stateless.session.bean.home.interface.should.define.exactly.one.create.method=La interfaz home del bean de sesión sin estado debe definir exactamente un método create().
static.fields.only.recommended=Se recomienda usar solo campos static final
text.queries=Consultas
text.references=Referencias
text.remove.0=Eliminar ''{0}''
there.should.be.no.method.params.for.*.method=El método * no debe tener {0}
this.escaped.passed=EJB no debe pasar 'this' como argumento de método
this.escaped.returned=EJB no debe devolver 'this' como resultado de un método
warning.text.abstract.schema.name.should.not.be.empty=El nombre del esquema abstracto no debe estar vacío
warning.text.cmp.field.list.for.cmp.bean.should.not.be.empty=La lista de campos CMP para el EJB de entidad CMP no debe estar vacía
warning.text.primary.key.class.is.not.rmi.iiop.compatible=La clase de clave primaria no es compatible con RMI/IIOP
