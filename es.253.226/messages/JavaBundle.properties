abstract.class.not.allowed=No se permite una clase abstracta
access.static.via.instance=Acceso a miembro estático a través de una referencia de instancia
accessible.name.change.modifier=Cambiar modificador
action.GotoSuperClass.MainMenu.text=Superclase o interfaz(_U)
action.GotoSuperClass.description=Navegar a la declaración de la clase que la clase actual extiende o implementa
action.GotoSuperClass.text=Ir a la superclase o interfaz(_U)
action.InsertAnnotationAction.text=Insertar anotación(es)
action.ToggleExternalAnnotationsAction.text=Alternar anotaciones externas
action.ToggleInferredAnnotationsAction.text=Alternar anotaciones inferidas
action.analyzing.cyclic.dependencies.in.scope=Dependencias cíclicas de {0}
action.create.new.class=Nueva clase de Java
action.create.new.class.description=Crear nueva clase Java
action.create.new.module-info.description=Crear nuevo module-info.java
action.create.new.module-info.title=Module-info.java
action.create.new.package-info.description=Crear un nuevo archivo package-info.java
action.create.new.package-info.title=package-info.java
action.cyclic.dependency.title=Análisis de dependencias cíclicas
action.description.copy.whole.thread.dump.to.clipboard=Copiar el volcado de hilos completo al portapapeles
action.description.group.by.scope=Agrupar por tipo de ámbito (producción, pruebas, bibliotecas)
action.description.group.threads.with.identical.stacktraces=Agrupar hilos con rastro de pila idéntico
action.description.infer.nullity.annotations=Inferir anotaciones de nulidad
action.description.mark.directory.as.a.0.for.generated.files=Marcar el directorio como {0} para los archivos generados
action.description.mark.directory.as.an.ordinary.0=Marcar directorio como {0} normal
action.description.show.only.threads.containing.a.specific.string=Mostrar solo hilos que contengan una cadena específica
action.dfa.from.stacktrace.text=Buscar por qué ''{0}'' podría ser {1}
action.expand.static.import.text=Expandir importación estática
action.find.similar.stack.call.diverged=Es probable que los números de línea hayan divergido. Intente encontrar la ubicación actual dentro de ''{0}.{1}()''
action.find.similar.stack.call.location.not.found=No hay ninguna ubicación similar dentro de ''{0}.{1}()''
action.find.similar.stack.call.methods=Métodos similares a ''{0}.{1}()''
action.find.similar.stack.call.methods.not.found=No se encontraron métodos similares a ''{0}.{1}()''
action.find.similar.stack.call.similar.calls=Ubicaciones posibles dentro de ''{0}.{1}()''
action.go.to.functional.implementation.text=Buscar implementaciones de la interfaz funcional
action.go.to.implementation.text=Ir a la(s) implementación(es)
action.go.to.overriding.methods.text=Ir a los métodos sobrescritos
action.go.to.subclass.text=Ir a subclase(s)
action.go.to.super.method.text=Ir al supermétodo
action.group.by.package=Paquete
action.group.by.scope.type=Agrupar por tipo de ámbito
action.implement.method=Implementar método
action.implement.methods=Implementar métodos
action.override.method=Sobrescribir método
action.override.methods=Sobrescribir métodos
action.sort.by.percent.classes.which.overrides.method.description=Ordenar por porcentaje de subclases que sobrescriben el método
action.sort.by.percent.classes.which.overrides.method.text=Ordenar por porcentaje de subclases que sobrescriben el método
action.text.0.on.parameter.1={0} en el parámetro ''{1}''
action.text.choose.class.in.0=Seleccionar clase en {0}…
action.text.copy.to.clipboard=Copiar al portapapeles
action.text.edit.template=Editar plantilla
action.text.enter.class.name=Introducir nombre de la clase…
action.text.generated.root.0={0} generado
action.text.merge.identical.stacktraces=Fusionar Stacktraces Identicos
action.text.show.methods.to.implement=Mostrar métodos a implementar
action.text.unmark.generated.0=Desmarcar {0} generado
action.title.infer.nullity.annotations=Inferir anotaciones de nulidad
add.methods.dialog.or=o
add.to.permits.list=Añadir ''{0}'' a la lista de permits de la clase sellada ''{1}''
add.to.permits.list.family.name=Añadir clase a la lista permits
adds.ext.library.preview=Añade la biblioteca ''{0}'' al módulo ''{1}''
adds.ext.library.preview.import=Añade la biblioteca ''{0}'' a las dependencias del módulo ''{1}'' e importa ''{2}''
adds.library.preview=Agrega {0, choice, 1#la biblioteca ''''{1}''''|2#una de {2}} a las dependencias del módulo ''{3}'' e importa ''{4}'' no resuelto
adds.library.preview.no.import=Agrega {0, choice, 1#la biblioteca ''''{1}''''|2#una de {2}} a las dependencias del módulo ''{3}''
adds.module.dependencies.preview=Añade {0, choice, 1#el módulo ''''{1}''''|2#uno de {2}} a las dependencias del módulo ''{3}'' e importa las clases sin resolver
advanced.setting.code.vision.java.minimal.usages=Code Vision: Cantidad mínima de usos para mostrar sugerencias incrustadas
advanced.setting.compiler.automake.allow.when.app.running=Permitir que auto-make se inicie incluso si la aplicación desarrollada se está ejecutando actualmente
advanced.setting.compiler.automake.allow.when.app.running.description=La ejecución automática de make podría acabar eliminando algunas clases necesarias para la aplicación.
advanced.setting.compiler.inMemoryLogger=Recopilar un informe detallado del registro de depuración en caso de fallos de compilación
advanced.setting.compiler.inMemoryLogger.description=Guarda registros detallados de las compilaciones fallidas para ayudar en la depuración y resolución de problemas. Los registros se almacenan junto con otros registros de compilación.
advanced.setting.compiler.lower.process.priority=Ejecutar la compilación con prioridad más baja
advanced.setting.compiler.lower.process.priority.description=Ejecutar el proceso JPS externo con prioridad IDLE en Windows y nivel nice 10 en Linux/macOS
advanced.setting.compiler.unified.ic.implementation=Habilitar la implementación de compilación incremental unificada de Java/Kotlin
advanced.setting.compiler.unified.ic.implementation.description=El proceso JPS externo utilizará una nueva implementación de compilación incremental capaz de procesar el bytecode generado tanto por Java como por Kotlin.
advanced.setting.java.completion.qualifier.as.argument=Habilitar el completado para métodos estáticos que utilizan el calificador como primer argumento
advanced.setting.java.sdkmanrc.watcher=Comenzar a escuchar los cambios en los archivos de configuración ('.sdkmanrc', '.tool-versions', …) al abrir el proyecto
advanced.setting.java.show.irrelevant.templates.in.source.roots=Mostrar plantillas de "Nuevo archivo" irrelevantes en las raíces de código fuente de Java
advanced.settings.group.compiler=Compilador
advanced.settings.group.java=Java
align.types.in.multi.catch=Alinear tipos en multi-catch
annotate.intention.chooser.title=Seleccionar anotación para añadir
annotation.types.cannot.be.inlined=Los tipos de anotación no se pueden insertar en línea
annotations.new.line.record.component=Nueva línea para las anotaciones
arch.checker.notification.content=El JDK ''{0}'' ({1}) no coincide con la arquitectura del sistema ({2}).
arch.checker.notification.project.structure=Configurar JDK
arch.checker.notification.title=El JDK seleccionado puede causar compilaciones lentas
assignment.array.element.to.itself.problem.descriptor=El elemento del array se asigna a sí mismo
assignment.to.declared.variable.problem.descriptor=La variable ''{0}'' se inicializa con una autoasignación
assignment.to.itself.problem.descriptor=La variable ''{0}'' se asigna a sí misma
auto.static.import.class=Clase o miembros estáticos
auto.static.import.comment=Agregue una clase o un miembro de clase para incluir en la importación automática y el completado
auto.static.import.completion.group=Incluir la importación automática de miembros estáticos en el autocompletado:
auto.static.import.example=Ejemplos: 'java.util.Objects' o 'java.util.Objects.requireNonNull'
auto.static.import.scope=Ámbito
auto.test.on=Prueba automática activada
base.package.parameter.wizard.label=&Paquete base:
base.package.project.wizard.error.x.not.valid.package={0} no es un nombre de paquete válido
bean.property=Propiedad de Bean
boolean.method.is.always.inverted.display.name=El método booleano siempre está invertido
boolean.method.is.always.inverted.problem.descriptor=Las llamadas al método booleano '#ref()' siempre se invierten
button.add=Añadir…
button.add.blank=Añadir en blanco
button.add.class=Añadir clase…
button.add.dependency=Añadir dependencia
button.add.package=Añadir paquete…
button.add.pattern=Añadir patrón…
button.annotations=Anotaciones…
button.base.method=Método &base
button.code.patterns=Patrones de código…
button.current.method=Método a&ctual
button.text.settings=Configuración…
button.to.another.directory=Al &directorio
button.to.another.source.root=A la raíz de &fuentes
caller.chooser.referenced.code.title=Código referenciado
cast.expression=Insertar expresión de conversión
cast.to.0=Convertir a ''{0}''
change.color.command.text=Cambiar color
change.signature.from.usage.short.name=<html>Cambiar la firma de {0}({1})</html>
change.uid.action.name=Cambiar aleatoriamente el inicializador de 'serialVersionUID'
checkbox.after.description=Después de la descripción
checkbox.after.parameter.descriptions=Después de las descripciones de los parámetros
checkbox.after.return.tag=Después de la etiqueta return
checkbox.align.parameter.descriptions=Alinear descripciones de los parámetros
checkbox.align.thrown.exception.descriptions=Alinear las descripciones de las excepciones lanzadas
checkbox.annotate.local.variables=Anotar variables locales
checkbox.check.for.jdk.updates=Buscar actualizaciones de JDK
checkbox.collapse.annotations=Anotaciones
checkbox.collapse.anonymous.classes=Clases anónimas
checkbox.collapse.closures="Closures" (clases anónimas que implementan un método, antes de Java 8)
checkbox.collapse.end.of.line.comments=Secuencia de comentarios al final de la línea
checkbox.collapse.generic.constructor.parameters=Parámetros de métodos y constructores genéricos
checkbox.collapse.i18n.messages=Cadenas I18n
checkbox.collapse.inferred.type=Reemplazar 'var' con el tipo inferido
checkbox.collapse.inner.classes=Clases internas
checkbox.collapse.multiline.comments=Comentarios multilínea
checkbox.collapse.one.line.methods=Métodos de una sola línea
checkbox.collapse.simple.property.accessors=Accesores de propiedades simples
checkbox.collapse.suppress.warnings=@SuppressWarnings
checkbox.declare.var.type=Usar 'var' para la declaración de variables locales
checkbox.deprecated.members=Miembros obsoletos
checkbox.do.not.indent.top.level.class.members=No sangrar los miembros de clase de nivel superior
checkbox.do.not.wrap.after.single.annotation=No ajustar línea después de una sola anotación
checkbox.do.not.wrap.one.line.comments=No ajustar comentarios de una sola línea
checkbox.don.t.warn.in.case.of.multiline.lambda=No advertir si el parámetro de 'List.replaceAll()' es una lambda de varias líneas
checkbox.enable.javadoc.formatting=Habilitar el formato de JavaDoc
checkbox.enable.leading.asterisks=Habilitar asteriscos iniciales
checkbox.generate.p.on.empty.lines=Generar "<p>" en líneas vacías
checkbox.html.report.inaccessible.symbols=<html>Informar sobre símbolos inaccesibles<br>(es posible que la herramienta javadoc no pueda crear el hipervínculo)
checkbox.ignore.chains=Ignorar métodos encadenables
checkbox.ignore.fields.used.in.multiple.methods=Ignorar campos utilizados en varios métodos
checkbox.insert.imports.for.inner.classes=Insertar importaciones para clases internas
checkbox.iterate.unknown.stream.sources.via.stream.iterator=Iterar fuentes de Stream desconocidas mediante Stream.iterator()
checkbox.keep.empty.lines=Mantener líneas vacías
checkbox.keep.empty.param.tags=Mantener @param vacío
checkbox.keep.empty.return.tags=Mantener etiquetas @return vacías
checkbox.keep.empty.throws.tags=Mantener etiquetas @throws vacías
checkbox.keep.invalid.tags=Mantener etiquetas no válidas
checkbox.make.generated.local.variables.final=Hacer que las variables locales generadas sean final
checkbox.make.generated.parameters.final=Hacer que los parámetros generados sean final
checkbox.param.description.on.new.line=Descripciones de parámetros en una nueva línea
checkbox.param.indent.on.continuation=Indentar líneas de continuación
checkbox.prefer.longer.names=Preferir nombres más largos
checkbox.preserve.line.feeds=Preservar saltos de línea
checkbox.preserve.module.import=Preservar las importaciones de módulos
checkbox.spaces.around.annotation.eq=Alrededor de '=' en el par de valor de anotación
checkbox.spaces.before.colon.in.foreach=Espacios antes de los dos puntos en foreach
checkbox.spaces.before.deconstruction.list=Lista de desconstrucción
checkbox.spaces.inside.block.braces.when.body.is.present=Dentro de las llaves de bloque cuando el cuerpo esté presente
checkbox.spaces.inside.one.line.enum=Dentro de las llaves de enum en una sola línea
checkbox.spaces.record.header=Encabezado de registro
checkbox.spaces.within.deconstruction.list=Lista de desconstrucción
checkbox.suggest.conversion.to.map.computeifabsent=Sugerir conversión a Map.computeIfAbsent
checkbox.suggest.conversion.to.map.getordefault=Sugerir conversión a Map.getOrDefault
checkbox.suggest.conversion.to.map.merge=Sugerir conversión a Map.merge
checkbox.suggest.conversion.to.map.putifabsent=Sugerir conversión a Map.putIfAbsent
checkbox.suggest.conversion.to.map.replaceall=Sugerir la conversión a Map.replaceAll
checkbox.suggest.replacement.even.if.lambda.may.have.side.effects=Sugerir reemplazo incluso si la expresión lambda puede tener efectos secundarios
checkbox.suppress.with.suppresswarnings=Suprimir con @SuppressWarnings
checkbox.treat.get.k.null.the.same.as.containskey.k.may.change.semantics=Tratar 'get(k) != null' igual que 'containsKey(k)' (puede cambiar la semántica)
checkbox.use.fully.qualified.class.names=Usar nombres de clase totalmente calificados
checkbox.use.single.class.import=Usar importación de clase única
checkbox.use.throws.rather.than.exception=Usar @throws en lugar de @exception
checkbox.warn.if.only.foreach.replacement.is.available=Advertir si solo está disponible el reemplazo 'forEach'
checkbox.warn.if.the.loop.is.trivial=Advertir si el bucle es trivial
checkbox.wrap.at.right.margin=Ajustar al margen derecho
choose.class=Seleccionar clase
choose.super.class.popup.title=Seleccionar superclase
chooser.text.choose.where.to.save.0=Elegir donde guardar ''{0}''
chooser.title.select.path.to.save.jar=Seleccionar ruta para guardar JAR
class.can.be.record.conversion.make.member.more.accessible=Si los miembros se vuelven más accesibles:
class.can.be.record.conversion.strategy.convert.silently=Convertir silenciosamente
class.can.be.record.conversion.strategy.do.not.convert=No sugerir conversión
class.can.be.record.conversion.strategy.show.members=Mostrar vista de conflictos
class.can.be.record.display.name=La clase puede ser una clase record
class.can.be.record.quick.fix=Convertir en clase de registro
class.can.be.record.record.highlight.when.semantics.change=No informar si los miembros se vuelven más accesibles
class.can.be.record.record.highlight.when.semantics.change.description=Las correcciones rápidas seguirán estando disponibles.
class.can.be.record.suggest.renaming.accessors=Sugerir el cambio de nombre de los métodos de acceso
class.can.be.record.suppress.conversion.if.annotated=Suprimir conversión si la clase está anotada con:
class.can.be.record.suppress.conversion.if.annotated.fix.name=Suprimir la conversión a record si está anotado con ''{0}''
class.cannot.be.inlined.because.a.call.to.its.constructor.is.unresolved=La clase no se puede aplicar inline porque una llamada a su constructor no se ha resuelto
class.cannot.be.inlined.because.an.interface.implemented.by.it.cannot.be.resolved=La clase no se puede integrar en línea porque no se puede resolver una interfaz implementada por ella
class.cannot.be.inlined.because.it.has.static.fields.with.non.constant.initializers=La clase no se puede integrar porque tiene campos estáticos con inicializadores no constantes
class.cannot.be.inlined.because.it.has.static.initializers=La clase no se puede insertar en línea porque tiene inicializadores estáticos
class.cannot.be.inlined.because.it.has.static.inner.classes=La clase no se puede incluir en línea porque tiene clases internas estáticas
class.cannot.be.inlined.because.it.has.static.methods=La clase no se puede incluir en línea porque tiene métodos estáticos
class.cannot.be.inlined.because.it.has.static.non.final.fields=No se puede realizar el inline de la clase porque tiene campos static no final
class.cannot.be.inlined.because.it.has.usages.of.fields.not.inherited.from.its.superclass=No se puede aplicar inline a la clase porque tiene usos de campos no heredados de su superclase
class.cannot.be.inlined.because.it.has.usages.of.its.class.literal=No se puede insertar la clase en línea porque tiene usos de su literal de clase
class.cannot.be.inlined.because.it.has.usages.of.its.inner.classes=No se puede integrar la clase porque tiene usos de sus clases internas
class.cannot.be.inlined.because.it.is.used.as.a.this.qualifier=La clase no se puede integrar en línea porque se utiliza como calificador 'this'
class.cannot.be.inlined.because.it.is.used.in.a.catch.clause=La clase no se puede incluir en línea porque se utiliza en una cláusula 'catch'
class.cannot.be.inlined.because.it.is.used.in.a.throws.clause=No se puede aplicar inline a la clase porque se utiliza en una cláusula 'throws'
class.cannot.be.inlined.because.its.constructor.contains.return.statements=No se puede aplicar inline a la clase porque su constructor contiene sentencias 'return'
class.cannot.be.inlined.because.its.superclass.cannot.be.resolved=No se puede integrar la clase porque no se puede resolver su superclase
class.cannot.be.inlined.because.there.are.usages.of.its.methods.not.inherited.from.its.superclass.or.interface=No se puede realizar el inline de la clase porque hay usos de sus métodos no heredados de su superclase o interfaz
class.decorator.or.has.default.constructor='{0}'' debe tener un constructor predeterminado o implementar el patrón ''Decorator'
class.filter.editor.add.dialog.title=Nuevo filtro
class.filter.editor.choose.class.title=Seleccionar clase
class.filter.editor.table.model.column.name.isActive=Activo
class.filter.editor.table.model.column.name.pattern=Patrón
class.has.no.default.constructor=''{0}'' no tiene un constructor predeterminado
class.is.not.a.subclass='{0}'' no es asignable a ''{1}'
class.is.not.concrete=''{0}'' no es una clase concreta
class.is.not.public=''{0}'' no es público
class.not.found.error.message=No se encontró la clase ''{0}''
class.patterns.error.class.pattern.0.must.be.a.valid.java.qualifier=El patrón debe ser un nombre calificado de Java válido, solo se aceptan '*' como marcadores de posición
class.patterns.error.method.pattern.0.must.be.a.valid.java.identifier=El patrón de método ''{0}'' debe ser un identificador java válido, solo se aceptan ''*'' como marcadores de posición
class.patterns.panel.add.class=Añadir clase
class.patterns.separator.mark.code.as.entry.point.if.qualified.name.matches=Marcar código como punto de entrada si el nombre calificado coincide
code.style.generation.override.method.signature=Sobrescribir la firma del método
code.style.generation.repeat.synchronized.modifier=Repetir el modificador &synchronized
code.style.generation.replace.null.check=Reemplazar la verificación de nulos con Objects::nonNull u Objects::isNull
code.style.generation.settings.error.not.valid.identifier.part.in.prefix=Parte de identificador Java no válida en el prefijo ''{0}''
code.style.generation.settings.error.not.valid.identifier.part.in.suffix=No es una parte válida de un identificador Java en el sufijo ''{0}''
code.style.generation.use.class.isInstance=Usar Class::isInstance y Class::cast cuando sea posible
code.style.generation.use.integer.sum=Usar Integer::sum, etc. cuando sea posible
code.style.settings.angle.spacing.brackets=Paréntesis angulares
code.style.settings.spacing.after.closing.angle.bracket=Después del ángulo de cierre
code.style.settings.spacing.around.type.bounds=Alrededor de los límites de tipo
code.vision.implementations.hint={0, choice, 1#1 implementación|2#{0,number} implementaciones}
code.vision.inheritors.hint={0, choice, 1#1 heredero|2#{0,number} herederos}
code.vision.overrides.hint={0, choice, 1#1 sobrescritura|2#{0,number} sobrescrituras}
column.name.class.entry.point=Clase
column.name.method.entry.point=Método
column.name.with.subclasses.entry.point=Con subclases
combobox.paste.insert.imports=&Insertar imports al pegar:
command.completion.delete.element.text=Eliminar elemento
command.completion.generate.getter=Generar 'Getter'
command.completion.generate.getter.setter=Generar 'Getter' y 'Setter'
command.completion.generate.setter=Generar 'Setter'
command.completion.getters.and.setters.text=getters y setters
command.completion.getters.text=getter
command.completion.inline.text=En línea
command.completion.setters.text=setter
command.create.class.from.template=Crear clase desde plantilla
command.create.new.subdirectory=Crear nuevo subdirectorio
command.name.delegate.detected.change=Delegar
command.name.generate.tostring=Generar toString()
command.name.insert.block.statement=Insertar sentencia de bloque
command.name.replace.type=Reemplazar tipo
command.name.updating.package.statement=Actualizando la declaración de paquete
comment.the.class.will.be.created.in.the.package.0=La clase se creará en el paquete ''{0}''
compiler.options=Opciones del compilador
completion.class.name.hint.2=Pulse {0} una vez más para ignorar las dependencias de los módulos durante la búsqueda
completion.generate.via.wizard=(generar mediante asistente)
completion.inner.scope=interno
completion.inner.scope.tail.text=(del bloque {0})
completion.no.suggestions.of.type=No hay sugerencias de tipo {0}
completion.override.implement.methods=Sobrescribir/implementar métodos…
completion.provider.method.declaration.type=Declaración del método provider()
completion.smart.aslist.hint=Pulse {0} una vez más para buscar arrays de {1}
completion.smart.chain.hint=Pulse {0} una vez más para buscar a través de llamadas a métodos encadenados
completion.smart.hint=Pulse {0} para mostrar solo variantes adecuadas según el tipo
completion.smart.toar.hint=Presione {0} una vez más para buscar colecciones de {1}
completion.smart.type.generate.anonymous.body=Generar cuerpo anónimo
completion.unknown.type=Tipo desconocido {0}
configurable.EqualsHashCodeTemplatesPanel.display.name=Plantillas
configurable.GenerateToStringConfigurable.display.name=Configuración
configurable.TemplatesPanel.display.name=Plantillas
configure.annotations.option=Configurar anotaciones…
conflict.message.method.will.override.method.base.class=El {0} renombrado sobrescribirá el método de la clase base {1}
convert.compareto.expression.to.equals.call=Convertir la expresión 'compareTo()' en una llamada a 'equals()'
convert.compareto.expression.to.equals.call.may.change.semantics=Convertir la expresión 'compareTo()' en una llamada a 'equals()' (puede cambiar la semántica)
convert.number.binary=Binario
convert.number.decimal=Decimal
convert.number.hex=Hexadecimal
convert.number.octal=Octal
convert.number.plain.format=formato simple
convert.number.scientific.format=Formato científico
copy.abstract.method.intention.name=Usar la implementación existente de ''{0}''
copy.abstract.method.no.existing.implementations.found=No se encontraron implementaciones existentes
copy.abstract.method.popup.title=Seleccionar implementación para copiar
copy.abstract.method.title=Usar implementación de método abstracto
copy.paste.reference.notification=<html>{0} {0, choice, 1#importación añadida|2#importaciones añadidas}<p><span><a href=''show''>Revisar las importaciones añadidas…</a></span></html>
create.class.mapping.dialog.title=Seleccionar clase {0}
cyclic.dependencies.progress.text=Construyendo el grafo de dependencias
cyclic.dependencies.scope.dialog.module.button={0} &módulo ''{1}''
cyclic.dependencies.scope.dialog.project.button={0} todo el &proyecto
cyclic.dependencies.scope.dialog.title=Especificar el ámbito {0}
cyclic.dependencies.scope.include.test.sources.option=Incluir fuentes de &prueba
cyclic.dependencies.tree.cycle.node.text=Ciclo
cyclic.dependencies.usage.view.initial.text=Seleccione el paquete para analizar en el árbol de la izquierda
cyclic.dependencies.usage.view.root.node.text=Usos del paquete ''{0}'' en el paquete ''{1}''
dataflow.from.here=Flujo de datos desde aquí
dataflow.to.here=Flujo de datos hasta aquí
deannotate.intention.action.family.name=Eliminar anotación
deannotate.intention.action.several.text=Eliminar anotaciones…
deannotate.intention.action.text=Eliminar anotación de {0}
deannotate.intention.chooser.title=Seleccionar anotación para eliminar
default.package.presentable.name=<predeterminado>
default.param.value.warning={0} ya existe
delete.assignment.completely=Eliminar la asignación por completo
delete.initializer.completely=Eliminar el inicializador por completo
dependant.sdk.unsatisfied.dependency.message=Debe configurar primero un SDK de Java
dependencies.libraries.node.text=Bibliotecas
dependencies.tree.node.default.package.abbreviation=<paquete predeterminado>
destination.combo.source.root.not.expected.conflict=Se ha seleccionado la raíz de fuentes, pero se esperaba la raíz de pruebas
destination.combo.test.root.not.expected.conflict=Se ha seleccionado la raíz de prueba, pero se esperaba la raíz de código fuente
dfa.constraint.0.not.null={0} (no nulo)
dfa.constraint.not.null=No nulo
dfa.constraint.null.or.0=Null o {0}
dialog.create.class.destination.package.label=Paquete de destino:
dialog.create.class.label=Crear {0}:
dialog.create.class.name=Crear {0} {1}
dialog.create.class.package.chooser.title=Seleccionar paquete de destino
dialog.edit.template.checkbox.smart.type.completion=C&ompletado con coincidencia de tipos
dialog.edit.template.checkbox.use.static.import=Usar &importación estática si es posible
dialog.import.on.paste.title=Seleccionar clases para importar
dialog.import.on.paste.title2=Seleccionar elementos para importar
dialog.import.on.paste.title3=Seleccionar importaciones para eliminar
dialog.message.0.update.existing.class={0}. ¿Actualizar la clase existente?
dialog.message.class.not.found=No se encontró la clase de plantilla ''{0}''
dialog.message.create.test.in.the.same.source.root=¿Crear la prueba en la misma raíz de fuentes?
dialog.message.infer.nullity.annotations.requires.the.project.language.level=La inferencia de anotaciones de nulidad requiere que el nivel de lenguaje del proyecto sea 1.5 o superior.
dialog.message.jetbrains.annotations.library.is.missing=Falta la biblioteca de anotaciones de JetBrains.\nSin la biblioteca, IntelliJ IDEA no puede ejecutar el análisis. ¿Desea añadirla?
dialog.message.modules.dont.refer.to.existing.annotations.library={0, choice, 0#El módulo|2#Los módulos} {1} {0, choice, 0#no hace referencia|2#no hacen referencia} a la biblioteca ''{2}'' existente con anotaciones de nulidad de IntelliJ IDEA. ¿Desea añadir {0, choice, 0#la dependencia|2#las dependencias} ahora?
dialog.message.no.places.found.to.infer.nullable.notnull=No se han encontrado ubicaciones para inferir @Nullable/@NotNull
dialog.message.parameter.has.write.usages.inline.not.supported=El parámetro tiene usos de escritura. No se admite la integración.
dialog.message.template.not.applicable=La plantilla no es aplicable
dialog.message.template.not.found=No se encontró la plantilla
dialog.paste.on.import.text=<html>El fragmento de código pegado utiliza clases que no son accesibles mediante importaciones en el nuevo contexto.<br/>Seleccione las clases que desea importar al nuevo archivo.</html>
dialog.paste.on.import.text2=<html>El fragmento de código que ha pegado utiliza elementos que no son accesibles mediante importaciones en el nuevo contexto.<br/>Seleccione los elementos que desea importar al nuevo archivo.</html>
dialog.paste.on.import.text3=<html>El fragmento de código que ha pegado ha introducido nuevas importaciones en el contexto actual.<br/>Seleccione las importaciones que desea eliminar.</html>
dialog.title.check.configuration=Comprobar configuración…
dialog.title.check.functional.interface.candidates=Comprobar candidatos de interfaz funcional…
dialog.title.choose.0.parameters=Seleccionar {0} parámetros
dialog.title.choose.annotation=Seleccionar anotación {0}
dialog.title.choose.class=Seleccionar clase
dialog.title.choose.logger=Seleccionar registrador
dialog.title.configure.annotations=Configurar anotaciones
dialog.title.configure.code.patterns=Configurar patrones de código
dialog.title.copy.template=Copiar plantilla
dialog.title.create.class.in.package=Crear clase en el paquete
dialog.title.create.missing.tests=Crear pruebas faltantes
dialog.title.create.new.template=Crear nueva plantilla
dialog.title.edit.method.contract=Editar contrato del método
dialog.title.edit.range=Editar el rango de ''{0}''
dialog.title.infer.nullity=Inferir nulidad
dialog.title.infer.nullity.results=Resultados de la inferencia de nulidad
dialog.title.move.directory=Mover directorio
dialog.title.no.test.roots.found=No se encontraron raíces de prueba
dialog.title.process.duplicates=Procesar duplicados
dialog.title.super.method.found=Supermétodo encontrado
dialog.title.testdatapath.file.generate=Generar archivos desde la clase a @TestDataPath
dialog.title.testdatapath.method.generate=Generar métodos desde @TestDataPath
disable.auto.test=Desactivar prueba automática
disable.report.inaccessible.symbols.fix=No reportar símbolos inaccesibles
do.not.import.inner.classes.for=Excluye clases internas por nombre corto:
do.not.import.inner.classes.no.classes=No se han definido clases internas
edit.contract.dialog.checkbox.impure.method=El método puede producir efectos &secundarios
edit.contract.dialog.hint=<html>Por favor, especifique el texto del contrato<p>Ejemplo: <code>_, null -> false</code><br><small>Consulte la descripción de la acción de intención para obtener más detalles</small></html>
edit.contract.dialog.mutates.hint=Especifique los elementos separados por comas que se pueden mutar<p>Ejemplo: <code>this,param1</code><p>Deje vacío para efectos secundarios no especificados.
edit.range.dialog.message=Dejar vacío si no hay restricciones
edit.range.error.invalid.value=Valor no válido
edit.range.should.not.be.greater.than.to=No debe ser mayor que 'to'
edit.range.should.not.be.less.than.from=No debe ser menor que 'from'
edit.range.value.should.be.bigger.than=No debe ser mayor que {0}
edit.range.value.should.be.less.than=No debe ser menor que {0}
editbox.blank.lines.field.in.interface=Antes de un campo en la interfaz
editbox.blank.lines.field.with.annotations=Antes de campo con anotaciones:
editbox.blank.lines.field.without.annotations=Antes del campo sin anotaciones:
editbox.blank.lines.record.components=Entre componentes de registro:
editbox.blanklines.around.initializer=Alrededor del inicializador:
editbox.class.count.to.use.import.with.star=Número de clases para usar la importación con '*':
editbox.names.count.to.use.static.import.with.star=Cantidad de nombres para usar importación estática con '*':
empty.title=Vacío
encapsulate.fields.dialog.javadoc.title=Javadoc
enum.constant.ordinal=Ordinal de la constante de enumeración:
enum.not.allowed=No se permiten enumeraciones
enums.cannot.be.inlined=Las enumeraciones no se pueden incluir en línea
environment.key.description.project.jdk=Ruta absoluta al JDK del proyecto
environment.key.description.project.jdk.name=Nombre del JDK del proyecto visible en el IDE.
error.attempt.to.generate.constructor.for.anonymous.class=No se puede añadir un constructor a una clase anónima
error.attempt.to.generate.constructor.for.implicit.class=No se puede añadir un constructor a una clase declarada implícitamente.
error.hint.no.expression.found=No se encontró ninguna expresión
error.message.ide.does.not.support.starting.processes.using.old.java=El IDE no admite el inicio de procesos Java con Java {0}; la versión mínima admitida es la 8. Cambie la configuración de ejecución para usar una versión de Java más reciente.
error.no.annotation.class.found=No se encontró ninguna clase de anotación
error.package.already.contains.package-info='package-info.java'' ya existe para el paquete ''{0}'
error.package.already.contains.package.html=El paquete ''{0}'' ya tiene un archivo ''package.html''. ¿Desea crear ''package-info.java'' de todos modos?
error.package.html.found.title=Se encontró 'package.html'
error.text.this.is.not.a.valid.java.class.name=Este no es un nombre de clase Java válido
exclude.0.from.auto.import=Excluir ''{0}'' de la importación automática
exclude.0.from.completion=Excluir ''{0}'' del completado
exclude.accessors=Excluir accesores(&E)
exclude.from.completion.group=Excluir de la importación automática y el completado:
exclude.from.imports.no.exclusions=Añada una clase, paquete o miembro para excluir de la importación automática y el completado
exclude.from.imports.no.exclusions.2=para excluir de la importación y finalización automáticas
exclude.import.wildcard.comment=Utilice el comodín * para excluir todos los miembros de una clase o paquete especificado
exclude.table.mask=Clase, paquete o miembro
exclude.table.scope.column=Ámbito
export.to.html.generate.hyperlinks.checkbox=Generar &hipervínculos a clases
external.annotation.place=Seleccionar ubicación de almacenamiento de anotaciones
external.annotation.place.external=En un archivo XML externo…
external.annotation.place.in.code=Directamente en el código fuente
external.annotation.prompt=Aviso de anotación externa
external.annotations.external.option=Añadir &externamente
external.annotations.in.code.option=Agregar en el &código
external.annotations.no.package=No se encontró el paquete del propietario de la anotación
external.annotations.open.file=Abrir archivo de anotaciones
external.annotations.problem.parse.error=Archivo: {0}<br>Problema: {1}
external.annotations.problem.title=No se pueden leer las anotaciones externas
external.annotations.root.chooser=Carpeta raíz de anotaciones externas
external.annotations.root.chooser.description=Las anotaciones externas se guardan en la carpeta de componentes externos
external.annotations.root.chooser.error=No se encontró la carpeta: {0}
external.annotations.root.chooser.title=Seleccionar la raíz de anotaciones externas para {0}
external.annotations.roots=Raíces de anotaciones
external.annotations.suggestion.message=<html><body>Si no desea anotaciones en su código, puede utilizar el almacenamiento externo.<br> Para configurar anotaciones externas, especifique el directorio raíz donde se ubicarán los archivos con anotaciones.</body></html>
extract.interface.command.name=Extraer interfaz
extract.superclass.command.name=Extraer superclase
extracted.class.should.have.unique.name=La clase extraída debe tener un nombre único. El nombre ''{0}'' ya está en uso por una de las clases internas
filetype.spi.description=Interfaz de proveedor de servicios
find.field.accessors.prompt=¿Buscar accesores del campo ''{0}''?
find.field.accessors.title=Accesores de campos encontrados
find.jar.hint.text.no.libraries.found.for.fqn=No se encontraron bibliotecas para ''{0}''
find.options.include.accessors.base.checkbox=B&uscar métodos base de accessors
find.options.include.accessors.base.checkbox.comment=Usar por defecto métodos de jerarquía de nivel superior como objetivos de búsqueda de uso
find.options.include.accessors.checkbox=Buscar &accesores
find.options.include.overloaded.methods.checkbox=Métodos sobre&cargados
find.options.search.overriding.methods.checkbox=Buscar en mét&odos que sobrescriben
find.what.derived.classes.checkbox=Clases &derivadas
find.what.derived.interfaces.checkbox=Interfaces &derivadas
find.what.fields.usages.checkbox=Usos de &campos
find.what.implementing.classes.checkbox=Clases de &implementación
find.what.implementing.methods.checkbox=&Implementación de métodos
find.what.implicit.to.string.checkbox=Llamadas i&mplícitas
find.what.methods.usages.checkbox=Usos de &métodos
find.what.overriding.methods.checkbox=Métodos de sob&rescritura
find.what.search.for.base.methods.checkbox=&Buscar usos de métodos base
find.what.search.for.base.methods.checkbox.comment=Utilizar métodos de la jerarquía de nivel superior como objetivos de búsqueda de usos de forma predeterminada
find.what.usages.checkbox=&Usos
find.what.usages.of.classes.and.interfaces=Usos de &clases e interfaces
fix.move.to.source.root=Mover a la raíz de fuentes
generate.button.title=Generar
generate.constructor.already.exists=El constructor ya existe
generate.constructor.fields.chooser.title=Seleccionar campos para inicializar mediante el constructor
generate.constructor.super.constructor.chooser.title=Seleccionar constructor de la superclase
generate.delegate.target.chooser.title=Seleccionar destino para generar delegados
generate.equals.and.hashcode.already.defined.title=Generar equals() y hashCode()
generate.equals.and.hashcode.already.defined.warning=Los métodos ''boolean equals(Object)'' e ''int hashCode()'' ya están definidos\npara la clase {0}. ¿Desea eliminarlos y continuar?
generate.equals.and.hashcode.already.defined.warning.anonymous=Los métodos 'boolean equals(Object)' e 'int hashCode()' ya están definidos\npara esta clase anónima. ¿Desea eliminarlos y continuar?
generate.equals.hashcode.accept.sublcasses=Aceptar &subclases como parámetro del método equals()
generate.equals.hashcode.accept.sublcasses.explanation=<html><body>Aunque generalmente no cumple con el contrato de Object.equals(),<br>aceptar subclases puede ser necesario para que el método generado funcione correctamente<br>con frameworks que generan subclases Proxy, como Hibernate.</body></html>
generate.equals.hashcode.comparison.table=<html><table><tr><th><th>instanceof<th>getClass()<tr><td>Permite que las instancias de las subclases sean iguales a las instancias de la superclase<td align=center>sí<td align=center>no<tr><td>Permite que las instancias de diferentes subclases sean iguales entre sí<td align=center>sí<td align=center>no<tr><td>Sobrescribir el método equals() generado no rompe su contrato<td align=center>no<td align=center>sí<tr><td>Evita una comprobación de nulo adicional<td align=center>sí<td align=center>no<tr><td>CumpleelprincipiodesustitucióndeLiskov<td align=center>sí<td align=center>no</table></html>
generate.equals.hashcode.equals.fields.chooser.title=Seleccionar &campos para incluir en equals()
generate.equals.hashcode.getclass.type.comparison=Expresión de comparación de get&Class()
generate.equals.hashcode.hashcode.fields.chooser.title=Seleccionar &campos que se incluirán en hashCode()
generate.equals.hashcode.instanceof.type.comparison=Expresión &instanceof
generate.equals.hashcode.internal.error=Error interno
generate.equals.hashcode.non.null.fields.chooser.title=Seleccionar todos los campos no nulos (&F)
generate.equals.hashcode.template=&Plantilla:
generate.equals.hashcode.type.comparison.label=Para la comparación del tipo de clase en el método equals(), generar:
generate.equals.hashcode.use.getters=Usar &getters cuando estén disponibles
generate.equals.hashcode.warning.hashcode.for.arrays.is.not.supported=No se admite hashCode() para arrays
generate.equals.hashcode.wizard.title=Generar equals() y hashCode()
generate.equals.no.fields.for.generation=No se han encontrado campos para incluir en equals/hashCode
generate.equals.template.title=Plantilla de Equals:
generate.equals.warning.equals.for.nested.arrays.not.supported=Equals() no es compatible con arrays anidados
generate.equals.warning.generated.equals.could.be.incorrect=El equals() generado para Object[] podría ser incorrecto
generate.equals.wizard.title=Generar equals()
generate.file.extension.text=Introduzca la extensión del archivo: .php, .java, .kt, .cpp ….
generate.file.extension.validation.error=La extensión de archivo ''{0}'' no es válida. Debe comenzar con ''.'', no puede contener espacios ni estar en blanco
generate.getter.and.setter.error.no.fields=No se han encontrado campos para los que generar getters/setters
generate.getter.and.setter.error.no.fields.without.getters.and.setters=No se encontraron campos sin getter/setter
generate.getter.and.setter.error.setters.for.read.only.not.generated=No se generaron setters para los campos de solo lectura
generate.getter.error.no.fields=No se han encontrado campos para generar getters
generate.getter.error.no.fields.without.getters=No se encontraron campos sin getter
generate.getter.fields.chooser.title=Seleccionar campos para generar getters
generate.getter.setter.generate.all.annotations=Copiar &todas las anotaciones
generate.getter.setter.generate.all.annotations.tooltip=Copia todas las anotaciones aplicables de los campos. De lo contrario, solo se copiarán las anotaciones de nulabilidad.
generate.getter.setter.header.visibility.hint.=La visibilidad se aplica según Archivo | Ajustes | Editor | Estilo de código | Java | Generación de código
generate.getter.setter.title=Seleccionar campos para generar getters y setters
generate.getter.template=Plantilla de &getter:
generate.hashcode.template.title=Plantilla de HashCode:
generate.hashcode.wizard.title=Generar hashCode()
generate.logger.no.place.found.dialog.message=No se pudieron encontrar lugares para insertar el logger
generate.logger.no.place.found.dialog.title=No se encontraron ubicaciones
generate.logger.specify.place.popup.title=Seleccionar ubicación
generate.members.implement.command=Implementar
generate.members.nothing.to.insert=No se encontró nada para insertar
generate.method.nofiles.warn=No se encontraron métodos de prueba en la clase {0}
generate.method.nosuites.warn=No se encontraron suites de pruebas en @TestDataPath("{0}")
generate.missed.tests.action.error.no.tests.found=No se encontraron pruebas.
generate.missed.tests.action.failed.to.detect.framework=No se pudo detectar el framework de pruebas para {0}
generate.quickfix.files=Crear escenarios QF (con el sufijo '.after')
generate.record.constructor.title=Generar constructor de registro
generate.select.default.modifier.text=Seleccionar modificador
generate.setter.fields.chooser.title=Seleccionar campos para generar setters
generate.setter.template=Plantilla de &setter:
generate.setters.no.fields=No se han encontrado campos para los que generar setters
generate.setters.no.fields.without.setters=No se encontraron campos sin setter
generate.test.support.method.error.cannot.generate.method=No se puede generar el método: {0}
generate.test.support.method.error.method.already.exists=El método {0} ya existe
generate.test.support.method.error.no.template.found.for.framework=No se encontró ninguna plantilla para {0}:{1}
generate.tostring.already.exist.border=Cuando el método ya existe
generate.tostring.available.implicit.variables.label=Variables implícitas disponibles:<br/>{0}
generate.tostring.exclude..transient=Excluir campos transient
generate.tostring.exclude.by.field.name=Excluir campos por nombre (exp. reg.)
generate.tostring.exclude.by.field.type=Excluir campos por nombre de tipo (expr. reg.)
generate.tostring.exclude.by.name=Excluir métodos por nombre (exp. reg.)
generate.tostring.exclude.by.return.type=Excluir métodos por nombre del tipo de retorno (exp. reg.)
generate.tostring.exclude.constant.fields=Excluir campos constantes
generate.tostring.exclude.enum.fields=Excluir campos enum
generate.tostring.exclude.logger=Excluir campos de logger (Log4j, JDK Logging, Jakarta Commons Logging)
generate.tostring.exclude.static.fields=Excluir campos estáticos
generate.tostring.fully.qualified.class.name=Usar el nombre de clase totalmente cualificado en el toString() generado ($classname)
generate.tostring.getters.in.generated.code=Usar getters en el toString() generado cuando estén disponibles ($methods)
generate.tostring.handle.exception.error.message=Se ha producido una excepción irrecuperable al realizar la acción; consulte el registro de IDEA para obtener más detalles (el seguimiento de la pila debería estar en idea.log):\n{0}
generate.tostring.handle.exception.plugin.warning.message=Se lanzó una PluginException al realizar la acción; consulte el registro de IDEA para obtener más detalles (el rastreo de la pila debería estar en idea.log):\n{0}
generate.tostring.handle.exception.velocity.error.message=Error de Velocity al generar código: consulte el log de IDEA para obtener más detalles (el seguimiento de la pila debería estar en idea.log):\n{0}
generate.tostring.insert.border=¿Dónde insertar?
generate.tostring.method.already.exists.dialog.me=Ssage=Reemplazar el método {0} existente
generate.tostring.method.already.exists.dialog.title=El método ya existe
generate.tostring.move.to.generated.checkbox=Mover el cursor al método generado
generate.tostring.settings=Configuración
generate.tostring.sort.ascending=Ascendente
generate.tostring.sort.checkbox=Ordenar elementos
generate.tostring.sort.descending=Descendente
generate.tostring.sort.super=Miembros de la superclase primero
generate.tostring.tab.title=Configuración de generación de toString()
generate.tostring.template.label=&Plantilla:
generate.tostring.title=Generar toString()
generate.type.use.before.type=Colocar las anotaciones generadas con target TYPE_USE entre los modificadores y el tipo
generate.type.use.before.type.description=<html>Las anotaciones con destino TYPE_USE se colocarán después de cualquier modificador y directamente<br>antes del tipo. Cuando esta opción está desactivada, se colocarán antes de cualquier modificador.</html>
goto.super.class.chooser.title=Seleccionar superclase o interfaz
group.javadoc.alignment=Alineación
group.javadoc.blank.lines=Líneas en blanco
group.javadoc.invalid.tags=Etiquetas no válidas
group.javadoc.other=Otros
gutter.implemented.method=Método implementado
gutter.implementing.method=Implementando método
gutter.overridden.method=Método sobrescrito
gutter.overriding.method=Método que sobrescribe
gutter.service=Servicio
gutter.sibling.inherited.method=Método heredado hermano
header.method.to.be.converted=Método a convertir
hide.out.of.cyclic.packages.action.description=Ocultar paquetes sin dependencias cíclicas
hide.out.of.cyclic.packages.action.text=Ocultar paquetes sin dependencias cíclicas
highlight.exceptions.thrown.chooser.title=Seleccionar clases de excepción para resaltar
highlight.imported.classes.chooser.title=Seleccionar clases importadas para resaltar
highlight.imported.members.chooser.title=Seleccionar miembros importados para resaltar
highlight.overridden.classes.chooser.title=Seleccionar clases para resaltar métodos sobrescritos
highlight.suppressed.warnings.choose.inspections=Seleccionar inspecciones para resaltar problemas suprimidos de
highlight.throws.class.name=Resaltar lanzamientos de {0}
highlight.throws.popup.throwing.places=Lugares que lanzan {0}
highlight.throws.popup.usages=Usos de {0}
hint.text.added.imports=, se han añadido {0} {1, choice, 0#importación|1#importaciones}
hint.text.not.valid.java.identifier=No es un identificador Java válido
hint.text.occurrences.were.inlined=Se han incorporado {0} apariciones
hint.text.press.to.go.through.inlined.occurrences=Presione {0} para recorrer las {1} apariciones insertadas
hint.text.rearranged.imports=Importaciones reordenadas
hint.text.removed.imports=Se han eliminado {0} {1, choice, 0#importación|1#importaciones}
hint.text.tostring.method.could.not.be.created.from.template=No se pudo crear el método ''toString()'' a partir de la plantilla ''{0}''
hint.text.tostring.template.invalid=La plantilla toString() ''{0}'' no es válida
icon.preview=Vista previa del icono
ignore.imports.and.formatting=Ignorar importaciones y formato
illegal.name.validation.info=Nombre no válido: {0}
implement.abstract.method.potential.implementations.with.weaker.access=Se han encontrado posibles implementaciones con privilegios de acceso más débiles: {0}
implement.method.no.methods.to.implement=No se han encontrado métodos para implementar.
import.layout.on.demand.import.from.same.package.first=Colocar la importación bajo demanda antes de las importaciones de clase única del mismo paquete
import.layout.panel.all.other.imports=Todas las demás importaciones
import.layout.panel.blank.line.entry=<línea en blanco>
import.layout.panel.down.button=Abajo
import.layout.panel.module.imports=Importaciones de módulos
import.layout.panel.up.button=Subir
import.layout.static.imports.separately=Organizar las importaciones estáticas por separado
import.statically=Importar estáticamente
include.accessors=&Incluir accesores
increase.language.level.preview.description=El nivel de lenguaje del módulo ''{0}'' se cambiará a ''{1}''
infer.nullity.progress=Post-procesando resultados…
inlay.MethodChainsInlayProvider.description=Tipos de retorno de métodos en cadenas de llamadas.
inlay.annotation.hints.external.annotations=Anotaciones que se almacenan fuera del código fuente.<br>Estas anotaciones son útiles cuando necesita una anotación, pero añadirla al código fuente no es una opción (por ejemplo, al trabajar con el código de una biblioteca).<br><br><a href='https://www.jetbrains.com/help/idea/external-annotations.html'>Documentación</a>
inlay.annotation.hints.inferred.annotations=Anotaciones que IntelliJ IDEA genera al escanear las bibliotecas y el código del proyecto. Estas anotaciones ayudan a comprender los contratos de código y mejoran las capacidades del análisis estático. Incluyen: <br> @Contract <br> @Nullable <br> @NotNull <br> @Unmodifiable <br>@UnmodifiableView <br><br><a href='https://www.jetbrains.com/help/idea/inferring-nullity.html#inferred-annotations'>Documentación</a>
inlay.parameters.java.build.like.method=Métodos que devuelven una instancia de la clase sobre la que operan; por ejemplo, llamadas en cadenas de StringBuilder u operaciones intermedias en la API Stream de Java 8.
inlay.parameters.java.clear.expression.type=Llamadas a métodos que usan una expresión compleja como argumento, por ejemplo, el operador ternario o una sentencia switch de Java 13.
inlay.parameters.java.enums=Declaraciones de constantes de enumeración que usan un constructor parametrizado.
inlay.parameters.java.method.name.contains.parameter.name=Métodos que aceptan un único argumento cuando el argumento esperado se deduce claramente del nombre del método, como en los métodos de acceso.
inlay.parameters.java.multiple.params.same.type=Llamadas a métodos con más de un argumento no literal del mismo tipo.
inlay.parameters.java.new.expr=Llamadas a constructores parametrizados.
inlay.parameters.java.simple.sequentially.numbered=Métodos que aceptan múltiples parámetros cuyos nombres consisten en una letra seguida de un número.
insert.override.annotation=Insertar anotación @&Override
inspection.anonymous.2.method.ref.display.name=El tipo anónimo se puede reemplazar con una referencia a método
inspection.assert.quickfix=Afirmar ''{0}''
inspection.auto.add.module.requirements.quickfix=Completar dependencias de módulo
inspection.bulk.file.attributes.read.description=Se puede utilizar una llamada masiva a 'Files.readAttributes()'
inspection.bulk.file.attributes.read.message=Múltiples llamadas a atributos de archivo pueden reemplazarse por una única llamada a 'Files.readAttributes()'
inspection.call.message=Llamada redundante a ''{0}()''
inspection.capturing.cleaner=El Runnable pasado a Cleaner.register() captura la referencia ''{0}''
inspection.capturing.cleaner.description=Cleaner captura la referencia del objeto
inspection.cast.can.be.removed.narrowing.variable.type.fix.family.name=Cambiar el tipo de variable y eliminar la conversión
inspection.cast.can.be.removed.narrowing.variable.type.fix.name=Cambiar el tipo de ''{0}'' a ''{1}'' y eliminar la conversión de tipo
inspection.cast.can.be.removed.narrowing.variable.type.message=La conversión puede eliminarse cambiando el tipo de ''{0}'' a ''{1}''
inspection.cast.can.be.removed.narrowing.variable.type.name=El tipo de variable demasiado débil provoca una conversión innecesaria
inspection.charset.object.can.be.used.display.name=Se puede utilizar el objeto 'Charset' estándar
inspection.charset.object.can.be.used.fix.family.name=Usar constante Charset
inspection.charset.object.can.be.used.message=Se puede utilizar {0} en su lugar
inspection.collection.add.all.can.be.replaced.with.constructor.display.name=Llamada redundante a 'Collection.addAll()'
inspection.collection.factories.fix.family.name=Reemplazar con llamada a fábrica de colecciones
inspection.collection.factories.fix.name=Reemplazar con la llamada a ''{0}.{1}()''
inspection.collection.factories.message=Puede reemplazarse con la llamada a ''{0}.{1}()''
inspection.collection.factories.option.ignore.non.constant=Informar solo cuando el contenido sea constante
inspection.collection.factories.option.suggest.ofentries=Sugerir 'Map.ofEntries()'
inspection.collection.used.as.vararg.display.name=Iterable se utiliza como vararg
inspection.collection.used.as.vararg.message=Se ha pasado un Iterable como vararg: probablemente se esperaba un array
inspection.comparator.combinators.display.name=Se puede utilizar el combinador 'Comparator'
inspection.comparator.result.comparison.display.name=Uso sospechoso del método compare
inspection.comparator.result.comparison.fix.family.name=Corregir comparación del resultado del comparador
inspection.comparator.result.comparison.problem.display.name=Comparación del resultado del método compare con una constante específica
inspection.condition.covered.by.further.condition.display.name=La condición está cubierta por una condición posterior
inspection.conditional.break.in.infinite.loop=Mover la condición al bucle
inspection.conditional.break.in.infinite.loop.allow.condition.fusion=Permitir la fusión con la condición de bucle existente
inspection.conditional.break.in.infinite.loop.description=Interrupción condicional dentro del bucle
inspection.conditional.break.in.infinite.loop.no.conversion.with.do.while=No sugerir reemplazar con 'do while'
inspection.conditional.break.in.infinite.loop.suggest.conversion.when.if.is.single.stmt.in.loop=Sugerir conversión cuando 'if' sea la única sentencia en el bucle
inspection.conditional.can.be.optional.display.name=El condicional se puede reemplazar con Optional
inspection.convert.2.method.ref.display.name=La expresión lambda puede ser reemplazada por una referencia a un método
inspection.convert.2.streamapi.display.name=El bucle se puede simplificar con la API Stream
inspection.convert.to.local.quickfix=Convertir en variable local
inspection.data.flow.constant.values.display.name=Valores constantes
inspection.data.flow.display.name=Problemas de nulabilidad y flujo de datos
inspection.data.flow.filter.notnull.quickfix=Insertar el paso 'filter(Objects::nonNull)'
inspection.data.flow.ignore.assert.statements=Ignorar sentencias assert
inspection.data.flow.nullable.quickfix.option=Sugerir la anotación @Nullable para métodos/campos/parámetros donde se utilicen valores que pueden ser nulos
inspection.data.flow.optional.of.nullable.misuse.display.name=Uso de Optional.ofNullable con un argumento null o no null
inspection.data.flow.report.not.null.required.parameter.with.null.literal.argument.usages=Informar de usos de parámetros obligatorios no nulos con argumentos de literal null
inspection.data.flow.report.nullable.methods.that.always.return.a.non.null.value=Informar de métodos que admiten valores nulos y que siempre devuelven un valor no nulo
inspection.data.flow.report.problems.that.happen.only.on.some.code.paths=Informar problemas que ocurren solo en algunas rutas de código
inspection.data.flow.treat.non.annotated.members.and.parameters.as.nullable=Tratar los miembros y parámetros no anotados como @Nullable
inspection.data.flow.true.asserts.option=No informar de las aserciones cuya condición se demuestre estáticamente que siempre es verdadera
inspection.data.flow.unreachable.code.display.name=Código inalcanzable
inspection.data.flow.unreachable.code.option.ignore.trivial.description=No informar sobre sentencias inalcanzables como <code>return 0</code>, <code>break</code>, etc., ya que podrían ser necesarias para cumplir con las reglas de flujo de control de Java.
inspection.data.flow.unreachable.code.option.ignore.trivial.name=Ignorar sentencias de salida triviales
inspection.data.flow.unreachable.code.option.respect.suppression.description=Intenta evitar informar sobre código inalcanzable si es causado por una condición constante en la que se haya suprimido la advertencia correspondiente.
inspection.data.flow.unreachable.code.option.respect.suppression.name=Respetar las supresiones de la inspección 'Valor constante'
inspection.data.flow.use.computeifpresent.quickfix=Reemplazar 'compute' por 'computeIfPresent'
inspection.dead.code.option.applet=Applets
inspection.dead.code.option.external=Clases con usos en archivos no Java
inspection.dead.code.option.main=<html>métodos <code>void main(String args[])</code></html>
inspection.dead.code.option.servlet=Servlets
inspection.default.annotation.param=Valor predeterminado del parámetro de anotación
inspection.duplicate.branches.in.switch.default.message=La rama en 'switch' es un duplicado de la rama 'default'
inspection.duplicate.branches.in.switch.delete.fix.family.name=Eliminar ramas de 'switch' redundantes
inspection.duplicate.branches.in.switch.delete.fix.name=Eliminar rama 'switch' redundante
inspection.duplicate.branches.in.switch.display.name=Ramas duplicadas en 'switch'
inspection.duplicate.branches.in.switch.merge.fix.family.name=Fusionar ramas duplicadas en 'switch'
inspection.duplicate.branches.in.switch.merge.fix.name=Fusionar con ''{0}''
inspection.duplicate.branches.in.switch.merge.with.default.fix.name=Fusionar con la rama 'switch' por defecto
inspection.duplicate.branches.in.switch.message=Rama duplicada en 'switch'
inspection.duplicate.expressions.complexity.threshold=Umbral de complejidad de las expresiones
inspection.duplicate.expressions.display.name=Múltiples apariciones de la misma expresión
inspection.duplicate.expressions.introduce.variable.fix.family.name=Introducir variable
inspection.duplicate.expressions.introduce.variable.fix.name=Introducir variable para ''{0}''
inspection.duplicate.expressions.message=Múltiples apariciones de <code>#ref</code> #loc
inspection.duplicate.expressions.replace.other.occurrences.fix.family.name=Reemplazar otras apariciones de la expresión con una variable
inspection.duplicate.expressions.replace.other.occurrences.fix.name=Reemplazar otras apariciones de ''{1}'' por ''{0}''
inspection.duplicate.expressions.reuse.variable.fix.family.name=Reutilizar variable
inspection.duplicate.expressions.reuse.variable.fix.name=Reutilizar la variable ''{0}'' para ''{1}''
inspection.empty.module.info.file=Archivo 'module-info.java' vacío
inspection.endless.stream.description=Una operación sin cortocircuito consume un flujo infinito
inspection.equals.hashcode.display.name='equals()' y 'hashCode()' no están emparejados
inspection.equals.hashcode.generate.equals.quickfix=Generar 'equals()'
inspection.equals.hashcode.generate.equals.quickfix.preview=Abre un diálogo para configurar la generación de 'equals()'.
inspection.equals.hashcode.generate.hashcode.quickfix=Generar 'hashCode()'
inspection.equals.hashcode.generate.hashcode.quickfix.preview=Abre un cuadro de diálogo para configurar la generación de 'hashCode()'.
inspection.excessive.lambda.fix.family.name=Reemplazar lambda por constante
inspection.excessive.lambda.fix.name=Usar el método ''{0}'' sin lambda
inspection.excessive.lambda.message=Uso excesivo de lambdas
inspection.excessive.lambda.usage.display.name=Uso excesivo de lambdas
inspection.excessive.range.check.display.name=Comprobación de rango excesiva
inspection.explicit.argument.can.be.lambda.display.name=El argumento explícito puede ser lambda
inspection.explicit.argument.can.be.lambda.fix.family.name=Reemplazar argumento explícito por una función
inspection.explicit.argument.can.be.lambda.fix.name=Usar el método ''{0}'' con un argumento funcional
inspection.explicit.argument.can.be.lambda.message=El argumento explícito se puede convertir en lambda
inspection.explicit.array.filling.description=Puede reemplazarse por una única llamada al método ''Arrays.{0}()''
inspection.explicit.array.filling.display.name=Relleno explícito de arreglos
inspection.explicit.array.filling.fix.family.name=Reemplazar bucle por la llamada al método ''Arrays.{0}()''
inspection.explicit.array.filling.no.suggestion.for.set.all=No sugerir el uso de 'Arrays.setAll()'
inspection.explicit.array.filling.redundant.loop.description=Inicialización redundante de un array recién creado
inspection.explicit.array.filling.suggest.set.all=Sugerir 'Arrays.setAll()'
inspection.explicit.to.implicit.class.migration.fix.name=Convertir en una clase declarada implícitamente
inspection.explicit.to.implicit.class.migration.name=La declaración de clase explícita puede convertirse en una clase declarada implícitamente
inspection.explicit.to.implicit.move.to.root.delete.package=No mover, eliminar solo la sentencia package
inspection.explicit.to.implicit.move.to.root.move=Mover a la raíz del proyecto
inspection.explicit.to.implicit.move.to.root.title=Mover archivos de origen simples
inspection.export.results.callees=Cadena de llamadas
inspection.export.results.implicit.constructor=Constructor implícito de
inspection.export.results.overrides.library.methods=Sobrescribe métodos de biblioteca
inspection.export.results.package=Paquete
inspection.export.results.type.references=Los siguientes utilizan este tipo
inspection.field.can.be.local.display.name=El campo puede ser una variable local
inspection.field.can.be.local.problem.descriptor=El campo puede convertirse en una variable local
inspection.field.can.be.local.quickfix.constructor=Convertir campo en una variable local en el constructor
inspection.field.can.be.local.quickfix.initializer=Convertir campo a variable local en la sección del inicializador
inspection.field.can.be.local.quickfix.one.method=Convertir el campo en una variable local en el método ''{0}''
inspection.fill.permits.list.display.name=Faltan subclases del mismo archivo en la cláusula permits de una clase sellada
inspection.fill.permits.list.fix.name=Añadir las subclases faltantes a la cláusula 'permits'
inspection.fill.permits.list.no.missing.inheritors=La clase sellada no tiene herederos faltantes
inspection.fold.expression.fix.family.name=Plegar expresión
inspection.fold.expression.into.stream.display.name=La expresión se puede plegar en una cadena Stream
inspection.fold.expression.into.stream.fix.name=Plegar expresión en una cadena de Stream
inspection.fold.expression.into.string.display.name=La expresión se puede plegar en 'String.join'
inspection.fold.expression.into.string.fix.name=Plegar expresión en 'String.join'
inspection.forward.compatibility.name=Compatibilidad hacia adelante
inspection.frequently.used.inheritor.inspection.display.name=La clase puede extender una clase base de uso común
inspection.functional.expression.can.be.folded.display.name=Se puede plegar la expresión funcional
inspection.fuse.stream.operations.display.name=Los pasos posteriores pueden fusionarse en la cadena de la API de Stream
inspection.fuse.stream.operations.fix.family.name=Fusionar más sentencias en la cadena de la API Stream
inspection.fuse.stream.operations.fix.name=Fusionar {0} en la cadena de la API Stream
inspection.fuse.stream.operations.message=El stream se puede extender reemplazando {0}
inspection.fuse.stream.operations.option.strict.mode=No sugerir los colectores 'toList()' o 'toSet()'
inspection.handle.signature.change.type.fix.name=Cambiar el tipo a ''{0}''
inspection.handle.signature.field.cannot.resolve=No se puede resolver el campo ''{0}''
inspection.handle.signature.field.not.static=El campo ''{0}'' no es estático
inspection.handle.signature.field.static=El campo ''{0}'' es estático
inspection.handle.signature.field.type=El tipo del campo ''{0}'' es ''{1}''
inspection.handle.signature.method.abstract=El método ''{0}'' es abstracto en ''{1}''
inspection.handle.signature.method.not.static=El método ''{0}'' no es estático
inspection.handle.signature.method.static=El método ''{0}'' es estático
inspection.handle.signature.name=Desajuste de tipos de MethodHandle/VarHandle
inspection.handle.signature.not.subclass=La clase llamadora ''{0}'' debe ser una subclase de ''{1}''
inspection.handle.signature.use.constructor.fix.family.name=Usar una de las sobrecargas del constructor
inspection.handle.signature.use.constructor.fix.name=Usar constructor ''{0}''
inspection.handle.signature.use.method.fix.family.name=Usar una de las sobrecargas de método
inspection.handle.signature.use.method.fix.name=Usar el método ''{0}''
inspection.idempotent.loop.body=Cuerpo de bucle idempotente
inspection.illegal.character=Carácter no válido
inspection.implicit.to.explicit.class.backward.migration.fix.name=Convertir clase declarada implícitamente en clase convencional
inspection.implicit.to.explicit.class.backward.migration.name=La clase declarada implícitamente se puede reemplazar por una clase ordinaria
inspection.inconsistent.text.block.indent.message=La sangría del bloque de texto contiene tabulaciones y espacios
inspection.inconsistent.text.block.indent.name=Sangría de espacios en blanco inconsistente en el bloque de texto
inspection.inconsistent.text.block.indent.spaces=Usar solo espacios para la sangría del bloque de texto
inspection.inconsistent.text.block.indent.spaces.to.tabs.many.to.one.fix=Reemplazar espacios con tabulaciones ({0} espacios = 1 tabulación)
inspection.inconsistent.text.block.indent.spaces.to.tabs.one.to.one.fix=Reemplazar espacios por tabuladores (1 espacio = 1 tabulador)
inspection.inconsistent.text.block.indent.tabs=Utilizar solo tabuladores para la sangría de bloques de texto
inspection.inconsistent.text.block.indent.tabs.to.spaces.one.to.many.fix=Reemplazar tabulaciones con espacios (1 tabulación = {0} espacios)
inspection.inconsistent.text.block.indent.tabs.to.spaces.one.to.one.fix=Reemplazar las tabulaciones por espacios (1 tabulación = 1 espacio)
inspection.input.stream.constructor.message=InputStream' se puede construir utilizando 'Files.newInputStream()
inspection.insert.literal.underscores.display.name=Literal numérico ilegible
inspection.insert.literal.underscores.family.name=Insertar guiones bajos en literales numéricos
inspection.io.stream.constructor.description=InputStream' y 'OutputStream' pueden construirse utilizando métodos de 'Files
inspection.java.8.collection.remove.if.display.name=El bucle puede reemplazarse con 'Collection.removeIf()'
inspection.java.8.list.replace.all.display.name=El bucle puede reemplazarse por 'List.replaceAll()'
inspection.java.8.map.api.display.name=Operaciones de 'Map' simplificables
inspection.java.9.collection.factory.display.name=La creación de una colección inmutable se puede reemplazar por una llamada a la fábrica de colecciones
inspection.javadoc.additional.tags=Etiquetas Javadoc adicionales:
inspection.javadoc.additional.tags.description=Lista de etiquetas no estándar conocidas
inspection.javadoc.blank.lines.display.name=La línea en blanco debe reemplazarse por <p> para separar líneas
inspection.javadoc.blank.lines.fix.family.name=Reemplazar líneas en blanco por <p>
inspection.javadoc.blank.lines.fix.name=Insertar <p>
inspection.javadoc.blank.lines.message=Se ignorará la línea en blanco
inspection.javadoc.label.text=Etiquetas Javadoc adicionales:
inspection.javadoc.link.as.plain.text.display.name=Enlace especificado como texto plano
inspection.javadoc.link.as.plain.text.message=Enlace especificado como texto plano
inspection.javadoc.lint.display.name=Problemas de HTML en Javadoc (DocLint)
inspection.javadoc.method.problem.missing.param.tag=Falta la etiqueta obligatoria <code>@param</code> para el parámetro {0}
inspection.javadoc.method.problem.missing.tag.description=Falta la descripción de la etiqueta {0}
inspection.javadoc.option.ignore.deprecated=Ignorar los elementos marcados como @deprecated
inspection.javadoc.option.ignore.deprecated.description=No informar de problemas en el Javadoc que describa clases o miembros en desuso
inspection.javadoc.option.ignore.period=Ignorar problemas de punto
inspection.javadoc.option.ignore.period.description=No informar problemas relacionados con la ausencia o incompletitud de la primera oración de la descripción.
inspection.javadoc.option.ignore.self.ref=Ignorar Javadoc que apunta a sí mismo
inspection.javadoc.option.ignore.self.ref.description=No informar sobre las referencias en Javadoc que apuntan al mismo elemento
inspection.javadoc.option.ignore.simple=Ignorar accesores de propiedades simples
inspection.javadoc.option.ignore.syntax.errors=Ignorar errores de sintaxis de Javadoc
inspection.javadoc.option.ignore.syntax.errors.description=No informar sobre errores de análisis de Javadoc, como las referencias con formato incorrecto
inspection.javadoc.option.ignore.throws=Ignorar etiquetas 'throws' duplicadas
inspection.javadoc.option.ignore.throws.description=No informar sobre etiquetas <code>@throws</code> repetidas que describen la misma excepción
inspection.javadoc.option.tab.title=Clase
inspection.javadoc.option.tab.title.field=Campo
inspection.javadoc.option.tab.title.inner.class=Clase interna
inspection.javadoc.option.tab.title.method=Método
inspection.javadoc.option.tab.title.module=Módulo
inspection.javadoc.option.tab.title.package=Paquete
inspection.javadoc.problem.add.param.tag=Añadir etiqueta @param para el parámetro ''{0}''
inspection.javadoc.problem.add.param.tag.family=Añadir etiqueta param de Javadoc faltante
inspection.javadoc.problem.add.tag=Añadir etiqueta @{0} {1}
inspection.javadoc.problem.add.tag.family=Añadir la etiqueta Javadoc que falta
inspection.javadoc.problem.cannot.resolve=No se puede resolver el símbolo {0}
inspection.javadoc.problem.descriptor=Falta el Javadoc requerido
inspection.javadoc.problem.descriptor1=Falta el punto en la documentación. La herramienta Javadoc utiliza el punto para generar el comentario de la página de descripción general.
inspection.javadoc.problem.disallowed.tag=La etiqueta {0} no está permitida aquí
inspection.javadoc.problem.duplicate.param=Etiqueta @param duplicada para el parámetro ''{0}''
inspection.javadoc.problem.duplicate.tag=Etiqueta @{0} duplicada
inspection.javadoc.problem.duplicate.throws=Etiqueta @throws o @exception duplicada para la excepción ''{0}''
inspection.javadoc.problem.inaccessible=El símbolo {0} no es accesible desde aquí
inspection.javadoc.problem.missing.tag=Falta la etiqueta obligatoria {0}
inspection.javadoc.problem.missing.tag.description=Falta {0} después de la etiqueta @{1}
inspection.javadoc.problem.name.expected=Se esperaba un nombre
inspection.javadoc.problem.pointing.to.itself=Javadoc que apunta a sí mismo
inspection.javadoc.problem.see.tag.expecting.ref=Se espera una referencia a clase/método, texto entre comillas o un enlace HTML después de la etiqueta @see
inspection.javadoc.problem.snippet.tag.is.not.available=La etiqueta '@snippet' no está disponible en este nivel de lenguaje
inspection.javadoc.problem.wrong.tag=Etiqueta incorrecta {0}
inspection.javadoc.ref.display.name=La declaración tiene problemas en las referencias de Javadoc
inspection.javadocDeclaration.display.name=Problemas de declaración de Javadoc
inspection.join.declaration.and.assignment.display.name=La asignación se puede unir a la declaración
inspection.join.declaration.and.assignment.fix.family.name=Unir declaración y asignación
inspection.join.declaration.and.assignment.fix.title=Combinar declaración y asignación
inspection.join.declaration.and.assignment.message=La asignación puede combinarse con la declaración de ''{0}''
inspection.labeled.switch.rule.redundant.code.block.display.name=La regla de switch con etiqueta tiene un bloque de código redundante
inspection.labeled.switch.rule.redundant.code.block.message=El bloque de código de la regla etiquetada es redundante
inspection.labeled.switch.rule.redundant.code.fix.name=Deshacer el bloque de código de la regla etiquetada
inspection.lambda.can.be.method.call.display.name=La lambda se puede reemplazar por una llamada a un método
inspection.lambda.to.method.call.fix.family.name=Reemplazar expresión lambda con llamada a método
inspection.lambda.to.method.call.fix.name=Reemplazar la expresión lambda por ''{0}''
inspection.magic.constant.display.name=Constante mágica
inspection.magic.constants.should.be.one.of.values=Debe ser uno de: {0}{1,choice,0#|1# o su combinación}
inspection.manual.min.max.calculation.description=Puede sustituirse por una llamada a ''Math.{0}()''
inspection.manual.min.max.calculation.disable.for.non.integral=Deshabilitar para float y double
inspection.manual.min.max.calculation.display.name=Cálculo manual de mín/máx
inspection.map.foreach.display.name=Se puede usar Map.forEach()
inspection.map.foreach.option.no.loops=No informar bucles
inspection.mapping.before.count.family.name=Llamada de mapeo antes de count()
inspection.mapping.before.count.message=La llamada ''{0}()'' no cambia el recuento final y podría eliminarse mediante optimización.
inspection.meaningless.record.annotation.description=Anotación de registro sin sentido
inspection.meaningless.record.annotation.message.method=La anotación no tiene efecto: su destino es METHOD, pero el descriptor de acceso correspondiente se ha declarado explícitamente
inspection.meaningless.record.annotation.message.method.and.parameter=La anotación no tiene efecto: sus destinos son METHOD y PARAMETER, pero tanto el accesor como el constructor canónico están declarados explícitamente
inspection.meaningless.record.annotation.message.parameter=La anotación no tiene efecto: su destino es PARAMETER, pero el constructor canónico está declarado explícitamente
inspection.message.anonymous.ref.loc.can.be.replaced.with.method.reference=El #ref #loc anónimo puede reemplazarse por una referencia a método
inspection.message.can.be.replaced.with.0.constructor=Puede reemplazarse con el constructor ''{0}''
inspection.message.can.be.replaced.with.files.readstring=Se puede reemplazar con 'Files.readString()'
inspection.message.can.be.replaced.with.files.writestring=Puede reemplazarse con 'Files.writeString()'
inspection.message.can.be.replaced.with.optional.of.nullable=Puede reemplazarse por Optional.ofNullable()
inspection.message.can.be.replaced.with.single.expression.in.functional.style=Se puede reemplazar con una sola expresión en estilo funcional
inspection.message.can.be.replaced.with.string.repeat=Puede reemplazarse por 'String.repeat()'
inspection.message.external.snippet.differs.from.inline.snippet=El fragmento externo difiere del fragmento en línea
inspection.message.filter.is.present.chain.can.be.replaced.with.anymatch=La cadena ''filter().{0}().isPresent()'' se puede reemplazar por ''anyMatch()''
inspection.message.full.description=Descripción completa
inspection.message.lambda.parameter.type.is.redundant=El tipo de parámetro lambda es redundante
inspection.message.pattern.variables.can.be.replaced.with.cast=Uso de 'instanceof' con patrones
inspection.message.pattern.variables.can.be.replaced.with.cast.family.name=Reemplazar sin patrones
inspection.message.pattern.variables.can.be.replaced.with.cast.fix.name=Reemplazar ''{0}'' por casts
inspection.message.pattern.variables.can.be.replaced.with.cast.preserve.option=Intentar preservar las variables no utilizadas de los patrones durante la corrección rápida
inspection.message.pseudo.functional.style.code=Código de estilo pseudofuncional
inspection.message.record.can.be.converted.to.class=El record puede convertirse en una clase
inspection.message.redundant.default.parameter.value.assignment=Asignación redundante del valor por defecto del parámetro
inspection.message.replace.optional.with.if.statements=Reemplazar Optional por sentencias if
inspection.message.snippet.file.not.found=No se encuentra el archivo de fragmento ''{0}''
inspection.message.snippet.region.not.found=No se encontró la región
inspection.missingJavadoc.display.name=Falta Javadoc
inspection.missingJavadoc.label.minimalVisibility=Visibilidad mínima:
inspection.missingJavadoc.label.requiredTags=Etiquetas requeridas:
inspection.move.field.assignment.to.initializer.display.name=La asignación de campo se puede mover al inicializador
inspection.no.jdk.error.message=El JDK no está configurado correctamente para este proyecto. La inspección no puede continuar.
inspection.no.modules.error.message=Este proyecto no contiene módulos. La inspección no puede continuar.
inspection.notnull.field.not.initialized.display.name=Campo @NotNull no inicializado
inspection.notnull.field.not.initialized.message=Los campos {0} deben inicializarse
inspection.notnull.field.not.initialized.option.implicit=Ignorar campos que pueden inicializarse implícitamente
inspection.notnull.field.not.initialized.option.implicit.description=Si se marca, no se informarán los campos que se sabe que se inicializan implícitamente (p. ej., mediante inyección de dependencias)
inspection.notnull.field.not.initialized.option.setup=Ignorar campos inicializados en el método setUp()
inspection.notnull.field.not.initialized.option.setup.description=Si se selecciona, no se informarán los campos de las clases de casos de prueba que se inicializan en métodos de configuración (por ejemplo, anotados mediante <code>@Before</code> o <code>@BeforeEach</code>).
inspection.null.value.for.optional.assigned.ignore.fix.name=No advertir al comparar Optional con null
inspection.null.value.for.optional.assigned.message=El valor de Optional se compara con null
inspection.null.value.for.optional.context.assignment=Asignación
inspection.null.value.for.optional.context.declaration=Declaración
inspection.null.value.for.optional.context.lambda=Expresión lambda
inspection.null.value.for.optional.context.parameter=Parámetro
inspection.null.value.for.optional.context.return=Sentencia return
inspection.null.value.for.optional.fix.family.name=Reemplazar por el método Optional vacío
inspection.null.value.for.optional.message=Se utiliza null para el tipo ''Optional'' en {0}
inspection.null.value.for.optional.option.comparisons=Informar de la comparación de Optional con null
inspection.nullable.problems.display.name=Problemas de @NotNull/@Nullable
inspection.nullable.problems.ignore.external.notnull=&Ignorar @NotNull externo
inspection.nullable.problems.method.overrides.notnull.option=Informar sobre los &parámetros @NotNull que sobrescriben @Nullable y viceversa
inspection.nullable.problems.method.overrides.option=Informar sobre parámetros o métodos no &anotados que sobrescriben @NotNull
inspection.nullable.problems.not.annotated.getters.for.annotated.fields=Informar de parámetros &setter o getters no anotados de campos anotados
inspection.nullable.problems.notnull.overrides.option=Informar de &parámetros @NotNull que sobrescriben elementos no anotados
inspection.nullable.problems.notnull.parameters.with.null.literal.option=Informar sobre parámetros @NotNull con usos de argumentos de literal null
inspection.obvious.null.check.display.name=El método de comprobación de nulos se llama con un argumento claramente no nulo
inspection.optional.assigned.to.null.display.name=Valor nulo para el tipo Optional
inspection.optional.get.without.is.present.display.name=Se llama a Optional.get() sin comprobación isPresent()
inspection.optional.get.without.is.present.message=<code>{0}.#ref()</code> sin comprobación ''isPresent()''
inspection.optional.get.without.is.present.method.reference.message=<code>#ref</code> sin comprobación 'isPresent()'
inspection.optional.is.present.display.name=Uso de 'Optional.isPresent()' con un estilo no funcional
inspection.optional.to.if.display.name=Optional' se puede reemplazar por una secuencia de sentencias 'if
inspection.output.stream.constructor.message=OutputStream' se puede construir mediante 'Files.newOutputStream()
inspection.overflowing.loop.index.inspection.description=El bucle se ejecuta cero o miles de millones de veces
inspection.overflowing.loop.index.inspection.name=El bucle se ejecuta cero o miles de millones de veces
inspection.overwritten.key.array.message=Elemento de matriz sobrescrito
inspection.overwritten.key.display.name=Elemento de Map, Set o array sobrescrito
inspection.overwritten.key.map.message=Clave de Map duplicada
inspection.overwritten.key.set.message=Elemento de Set duplicado
inspection.parameter.can.be.local.display.name=Valor pasado como parámetro que nunca se lee
inspection.parameter.can.be.local.problem.descriptor=El parámetro puede convertirse en una variable local
inspection.preview.feature=Advertencia de funcionalidad en vista previa
inspection.preview.feature.0.is.preview.api.message={0} es una API en modo preview que puede eliminarse en una futura versión
inspection.quickfix.assert.family=Assert
inspection.raw.use.of.parameterized.type.problem.descriptor=Uso de tipo crudo de la clase parametrizada <code>#ref</code> #loc
inspection.read.write.string.can.be.used.display.name=Se puede utilizar 'Files.readString()' o 'Files.writeString()'
inspection.redundant.array.creation.display.name=Creación de array redundante
inspection.redundant.array.creation.for.varargs.call.descriptor=Creación de array redundante para llamar a un método varargs
inspection.redundant.array.creation.quickfix=Eliminar creación explícita de array
inspection.redundant.explicit.close='close()' redundante
inspection.redundant.file.creation.description=<code>#ref</code> es redundante #loc
inspection.redundant.file.creation.display.name=Creación redundante de instancias de 'File'
inspection.redundant.file.creation.quickfix=Reemplazar con el nombre del archivo
inspection.redundant.lambda.parameter.type.display.name=Tipos de parámetros lambda redundantes
inspection.redundant.null.check.always.fail.message=La comprobación de null siempre fallará: {0} nunca es null
inspection.redundant.null.check.fix.family.name=Eliminar comprobación de null redundante
inspection.redundant.null.check.fix.notnull.family.name=Eliminar '!= null' erróneo
inspection.redundant.null.check.message=Comprobación de null redundante: {0} nunca es null
inspection.redundant.operation.on.empty.array.message=El array <code>#ref</code> siempre está vacío
inspection.redundant.operation.on.empty.collection.message=La colección <code>#ref</code> siempre está vacía
inspection.redundant.operation.on.empty.container.display.name=Operación redundante en un contenedor vacío
inspection.redundant.operation.on.empty.map.message=El mapa <code>#ref</code> siempre está vacío
inspection.redundant.record.constructor.can.be.compact.message=El constructor canónico se puede convertir a la forma compacta
inspection.redundant.record.constructor.canonical.message=Constructor canónico redundante
inspection.redundant.record.constructor.compact.message=Constructor compacto redundante
inspection.redundant.record.constructor.description=Constructor de record redundante
inspection.redundant.record.constructor.fix.family.name=Convertir el constructor canónico a la forma compacta
inspection.redundant.record.constructor.statement.message=Asignación de campo redundante en el constructor compacto
inspection.redundant.stream.optional.call.display.name=Paso redundante en la cadena de llamadas de 'Stream' u 'Optional'
inspection.redundant.stream.optional.call.explanation.at.most.one=El stream contiene como máximo un elemento
inspection.redundant.stream.optional.call.explanation.distinct=Hay una llamada 'distinct()' previa en la cadena
inspection.redundant.stream.optional.call.explanation.distinct.set=Los elementos serán distintos de todos modos al recolectarse en un Set
inspection.redundant.stream.optional.call.explanation.filter=El predicado siempre es 'true'
inspection.redundant.stream.optional.call.explanation.map.flatMap=La llamada a 'map()' anterior puede reemplazar el paso 'flatMap()'
inspection.redundant.stream.optional.call.explanation.parallel=Hay una llamada ''{0}()'' posterior que sobrescribe esta llamada
inspection.redundant.stream.optional.call.explanation.parallel.single=El stream creado a partir de un solo elemento no se paralelizará
inspection.redundant.stream.optional.call.explanation.parallel.source=El stream se creó mediante 'parallelStream()', por lo que ya es paralelo
inspection.redundant.stream.optional.call.explanation.sequential.source=El flujo se creó mediante 'stream()', por lo que ya es secuencial
inspection.redundant.stream.optional.call.explanation.sorted=La llamada posterior ''{0}()'' no depende del orden de ordenación
inspection.redundant.stream.optional.call.explanation.sorted.parallel=La operación posterior ''{0}()'' no depende del orden de clasificación para flujos paralelos
inspection.redundant.stream.optional.call.explanation.sorted.twice=Hay una llamada posterior a 'sorted()' en la cadena
inspection.redundant.stream.optional.call.explanation.unordered=Hay una llamada 'unordered()' previa en la cadena
inspection.redundant.stream.optional.call.fix.bind.name=Fusionar el paso ''{0}()'' con el paso anterior ''{1}()''
inspection.redundant.stream.optional.call.fix.collect.to.ordered.family.name=Recolectar en 'LinkedHashSet'
inspection.redundant.stream.optional.call.fix.family.name=Eliminar llamada en cadena redundante
inspection.redundant.stream.optional.call.fix.name=Eliminar llamada a ''{0}()''
inspection.redundant.stream.optional.call.fix.replace.terminal=Reemplazar la operación terminal
inspection.redundant.stream.optional.call.fix.replace.terminal.text=Reemplazar la operación terminal por ''{0}()''
inspection.redundant.stream.optional.call.message=Llamada redundante ''{0}()''
inspection.redundant.stream.optional.call.message.with.explanation=Llamada redundante a ''{0}()'': {1}
inspection.redundant.stream.optional.call.option.streamboxing=Informar sobre el boxing redundante en Stream.map()
inspection.redundant.unmodifiable.call.description=Uso redundante de envoltorios de colecciones inmodificables
inspection.redundant.unmodifiable.call.display.name=Uso redundante del wrapper ''{0}''
inspection.redundant.unmodifiable.call.unwrap.argument.quickfix=Desempaquetar argumento
inspection.reflect.handle.invocation.argument.not.array=El argumento no es de tipo array
inspection.reflect.handle.invocation.argument.not.exact=El tipo de argumento debe ser exactamente ''{0}''
inspection.reflect.handle.invocation.primitive.argument.null=El argumento de tipo ''{0}'' no puede ser ''null''
inspection.reflect.handle.invocation.receiver.incompatible=El tipo del receptor de la llamada es incompatible: se espera ''{0}''
inspection.reflect.handle.invocation.receiver.null=El receptor de la llamada es 'null'
inspection.reflect.handle.invocation.result.not.assignable=Debe convertirse a ''{0}'' o a su superclase
inspection.reflect.handle.invocation.result.not.exact=Debe convertirse a ''{0}''
inspection.reflect.handle.invocation.result.null=El valor devuelto siempre es 'null'
inspection.reflect.handle.invocation.result.void=El tipo de retorno es 'void'
inspection.reflection.invocation.argument.count={0,choice,0#No se esperan argumentos|1#Se espera 1 argumento|1<Se esperan {0} argumentos}
inspection.reflection.invocation.argument.not.assignable=El argumento no es asignable a ''{0}''
inspection.reflection.invocation.array.not.assignable=Array {0,choice,1#tiene un elemento con un tipo|1<tiene elementos con tipos} {0,choice,1#incompatible|1<incompatibles}
inspection.reflection.invocation.item.count={0,choice,0#Se espera un array vacío|1#Se espera un array de un solo elemento|1<Se esperan {0} elementos de array}
inspection.reflection.invocation.item.not.assignable=No se puede asignar el elemento del array a ''{0}''
inspection.reflection.invocation.name=Desajuste de argumentos en la invocación por reflexión
inspection.reflection.invocation.reflective.argument.count=El método invocado mediante reflexión requiere {0,choice,0#ningún argumento|1#un argumento|1<{0} argumentos}
inspection.reflection.member.access.cannot.resolve.constructor.arguments=No se puede resolver el constructor con los tipos de argumento especificados
inspection.reflection.member.access.cannot.resolve.field=No se puede resolver el campo ''{0}''
inspection.reflection.member.access.cannot.resolve.method=No se puede resolver el método ''{0}''
inspection.reflection.member.access.cannot.resolve.method.arguments=No se puede resolver el método ''{0}'' con los tipos de argumentos especificados
inspection.reflection.member.access.check.exists=Comprobar que el campo/método existe en clases no finales
inspection.reflection.member.access.check.exists.exclude.chooser=Clase a excluir
inspection.reflection.member.access.check.exists.exclude.label=Excluir clases:
inspection.reflection.member.access.constructor.not.public=El constructor no es público
inspection.reflection.member.access.field.not.in.class=El campo ''{0}'' no está declarado en la clase ''{1}''
inspection.reflection.member.access.field.not.public=El campo ''{0}'' no es público
inspection.reflection.member.access.fix.family.name=Usar un método de reflexión apropiado
inspection.reflection.member.access.method.not.in.class=El método ''{0}'' no está declarado en la clase ''{1}''
inspection.reflection.member.access.method.not.public=El método ''{0}'' no es público
inspection.reflection.member.access.name=Acceso reflexivo a un miembro de clase inexistente o no visible
inspection.reflection.visibility.name=Problemas de acceso por reflexión entre módulos
inspection.remove.literal.underscores.display.name=Guiones bajos en literales numéricos
inspection.remove.literal.underscores.family.name=Eliminar guiones bajos de literales numéricos
inspection.replace.inefficient.stream.count.display.name=Cadenas de llamadas de la API Stream ineficientes que terminan en count()
inspection.replace.javadoc.display.name=Comentario reemplazable por Javadoc
inspection.replace.methodref.ternary.quickfix=Reemplazar con una lambda con comprobación de nulos
inspection.replace.ternary.quickfix=Reemplazar con ''{0} != null ?:''
inspection.replace.with.bulk.file.attributes.read.fix.family.name=Reemplazar con una llamada 'Files.readAttributes()' por lotes
inspection.replace.with.bulk.fix.family.name=Reemplazar con llamada a método en bloque
inspection.replace.with.bulk.fix.name=Reemplazar la iteración por una llamada masiva a ''{0}()''
inspection.replace.with.bulk.message=La iteración puede reemplazarse por una llamada masiva ''{0}()''
inspection.replace.with.bulk.wrap.arrays=Usar 'Arrays.asList()' para envolver arrays
inspection.replace.with.enhanced.switch.statement.fix.name=Reemplazar por la sentencia 'switch' mejorada
inspection.replace.with.javadoc=Reemplazar con un comentario Javadoc
inspection.replace.with.javadoc.comment=El comentario puede convertirse en Javadoc
inspection.replace.with.old.style.switch.statement.fix.name=Reemplazar con la sentencia 'switch' de estilo antiguo
inspection.replace.with.regular.string.literal.fix=Reemplazar con un literal de cadena estándar
inspection.replace.with.string.concatenation.fix=Reemplazar con concatenación de cadenas
inspection.replace.with.string.template.fix=Reemplazar por plantilla de cadena
inspection.replace.with.switch.expression.fix.family.name=Migrar a switch mejorado
inspection.replace.with.switch.expression.fix.name=Reemplazar con la expresión 'switch'
inspection.replace.with.switch.rule.expression.fix.family.name=Migrar a switch mejorado con reglas
inspection.replace.with.text.block.fix=Reemplazar con bloque de texto
inspection.replace.with.trivial.lambda.fix.family.name=Reemplazar con lambda trivial
inspection.replace.with.trivial.lambda.fix.name=Reemplazar con una expresión lambda que devuelva ''{0}''
inspection.require.non.null=Reemplazar la comprobación de null con una llamada estática a Objects/Stream
inspection.require.non.null.description=La comprobación de nulos puede reemplazarse por una llamada a un método
inspection.require.non.null.message={0, choice, 1#La sentencia ''if''|2#La expresión condicional} puede reemplazarse con una llamada a ''{1}()''
inspection.require.non.null.no.warning.replacement.bigger=No advertir si el reemplazo es más largo que el original
inspection.require.non.null.quickfix=Reemplazar {0, choice, 1#la sentencia ''if''|2#la expresión condicional} con la llamada a ''{1}()''
inspection.return.separated.from.computation.descriptor=Retorno separado del cálculo del valor de ''{0}''
inspection.return.separated.from.computation.family.quickfix=Mover 'return' más cerca del cálculo del resultado
inspection.return.separated.from.computation.name='return' separado del cálculo del resultado
inspection.return.separated.from.computation.quickfix=Mover ''return'' más cerca del cálculo del valor de ''{0}''
inspection.same.parameter.display.name=El parámetro del método siempre tiene el mismo valor
inspection.same.parameter.fix.family.name=Incorporar parámetro como valor constante
inspection.same.parameter.fix.name=Inlinear el valor ''{1}'' para el parámetro ''{0}''
inspection.same.parameter.problem.descriptor=El valor del parámetro <code>#ref</code> siempre es ''{0}''
inspection.simplifiable.comparator.comparing.message=Llamada innecesaria a ''{0}()''
inspection.simplifiable.comparator.display.name=El método Comparator puede simplificarse
inspection.simplifiable.comparator.entry.comparator.message=Se puede utilizar ''{0}'' en su lugar
inspection.simplifiable.comparator.fix.comparing.family.name=Eliminar llamada redundante
inspection.simplifiable.comparator.fix.entry.comparator.family.name=Usar el comparador 'Map.Entry' predefinido
inspection.simplifiable.comparator.fix.remove.name=Eliminar la llamada a ''{0}()''
inspection.simplifiable.comparator.fix.replace.name=Eliminar la llamada a ''{0}()'' y utilizar ''{1}()''
inspection.simplifiable.comparator.fix.reversed.family.name=Simplificar el método del comparador reemplazando 'max' por 'min'
inspection.simplifiable.comparator.fix.reversed.name=Reemplazar con ''{0}'' simplificando el comparador
inspection.simplifiable.comparator.reversed.message=El método del comparador se puede simplificar si la llamada a ''{0}()'' se reemplaza por ''{1}()''
inspection.simplify.collector.display.name=Colector simplificable
inspection.simplify.collector.fix.family.name=Simplificar colector en cascada
inspection.simplify.collector.fix.name=Usar el colector ''Collectors.{0}()''
inspection.simplify.collector.message=Se puede simplificar utilizando el colector ''{0}()''
inspection.simplify.for.each.extract.intermediate.operations=Extraer operaciones intermedias
inspection.simplify.foreach.display.name=Llamada forEach() simplificable
inspection.simplify.optional.call.chains.display.name=La cadena de llamadas de Optional se puede simplificar
inspection.simplify.stream.api.call.chains.display.name=La cadena de llamadas de la API Stream puede simplificarse
inspection.slow.abstract.set.remove.all.description=La llamada a 'set.removeAll(list)' puede ser lenta
inspection.slow.abstract.set.remove.all.fix.family.name=Usar 'Set.remove' en lugar de 'Set.removeAll'
inspection.slow.list.contains.all.description=La llamada a 'list.containsAll(collection)' puede tener un rendimiento deficiente
inspection.slow.list.contains.all.fix.family.name=Envolver en el constructor de 'HashSet'
inspection.slow.list.contains.all.fix.name=Envolver ''{0}'' en el constructor de ''HashSet''
inspection.sorted.collection.with.non.comparable.keys.display.name=Colección ordenada con elementos no comparables
inspection.sorted.collection.with.non.comparable.keys.message=Construcción de una colección ordenada con elementos no comparables
inspection.sorted.collection.with.non.comparable.keys.option.type.parameters=No informar sobre parámetros de tipo no comparables
inspection.static.import.can.be.used.display.name=Se puede usar la importación estática según la tabla de importación automática
inspection.static.import.can.be.used.fix.name=Añadir importación estática
inspection.static.pseudo.functional.style.method.display.name=La llamada pseudo-funcional de Guava se puede convertir en una llamada a la API Stream
inspection.stream.api.migration.can.be.replaced.with.call=Puede reemplazarse con la llamada a ''{0}''
inspection.stream.to.loop.display.name=La cadena de llamadas de la API Stream puede reemplazarse por un bucle
inspection.string.repeat.can.be.used.display.name=Se puede usar String.repeat()
inspection.string.template.migration.concatenation.message=La concatenación se puede reemplazar por una plantilla de cadena
inspection.string.template.migration.name=Se puede utilizar una plantilla de cadena
inspection.string.template.migration.string.message=La cadena se puede reemplazar con una plantilla
inspection.string.template.reverse.migration.name=La plantilla de cadena puede ser una cadena concatenada
inspection.string.template.reverse.migration.string.message=La plantilla de cadena puede reemplazarse por concatenación de cadenas
inspection.surround.if.family=Envolver con if
inspection.surround.if.quickfix=Envolver con ''if ({0}{1})''
inspection.suspicious.list.remove.display.name='List.remove()' sospechoso en un bucle
inspection.suspicious.return.byte.input.stream.convert.to.unsigned=Convertir a un byte sin signo
inspection.suspicious.return.byte.input.stream.name=Valor de byte sospechoso devuelto por 'InputStream.read()'
inspection.suspicious.ternary.in.varargs.description=El operador ternario en una llamada a varargs contiene ramas de tipo array y de tipo no array
inspection.suspicious.ternary.in.varargs.display.name=Operador ternario sospechoso en llamada a método varargs
inspection.suspicious.ternary.in.varargs.quickfix=Envolver en un inicializador de array
inspection.switch.expression.backward.expression.migration.inspection.name=La expresión 'switch' puede reemplazarse por una sentencia 'switch' de estilo antiguo
inspection.switch.expression.backward.migration.inspection.name='switch' mejorado
inspection.switch.expression.backward.statement.migration.inspection.name=La sentencia 'switch' puede reemplazarse por una sentencia 'switch' de estilo antiguo
inspection.switch.expression.migration.expression.max.statements=Número máximo de sentencias en una rama para convertir a una expresión switch
inspection.switch.expression.migration.inspection.name=La sentencia se puede reemplazar por un 'switch' mejorado
inspection.switch.expression.migration.inspection.switch.description=La sentencia 'switch' puede reemplazarse con un 'switch' mejorado
inspection.switch.expression.migration.inspection.switch.expression.description=La expresión switch se puede reemplazar por un 'switch' mejorado con reglas
inspection.switch.expression.migration.option.expression.max.statements=No informar sobre switches que tengan más de {0} {0, choice, 1#sentencia|2#sentencias} en una sola rama
inspection.switch.expression.migration.warn.only.on.expression=Mostrar advertencia solo si la conversión a expresión es posible
inspection.switch.labeled.rule.can.be.code.block.display.name=La regla switch con etiqueta puede tener un bloque de código
inspection.switch.labeled.rule.can.be.code.block.expression.message=La expresión de resultado de la regla etiquetada se puede envolver en un bloque de código
inspection.switch.labeled.rule.can.be.code.block.fix.expression.name=Envolver la expresión de resultado de la regla etiquetada en un bloque de código
inspection.switch.labeled.rule.can.be.code.block.fix.statement.name=Envolver la sentencia de la regla etiquetada con un bloque de código
inspection.switch.labeled.rule.can.be.code.block.statement.message=La sentencia de la regla con etiqueta se puede envolver en un bloque de código
inspection.testframework.assert.quickfix=Realizar aserción con {0} ''{1}''
inspection.text.block.backward.migration.message=El bloque de texto puede convertirse en un literal de cadena convencional
inspection.text.block.backward.migration.name=El bloque de texto se puede reemplazar por un literal de cadena normal
inspection.text.block.migration.concatenation.message=La concatenación se puede reemplazar por un bloque de texto
inspection.text.block.migration.name=Se puede usar un bloque de texto
inspection.text.block.migration.string.message=La cadena se puede reemplazar con un bloque de texto
inspection.text.block.migration.suggest.literal.replacement=Informar sobre literales de cadena única
inspection.trailing.whitespaces.in.text.block.message=Caracteres de espacio en blanco al final dentro de un bloque de texto
inspection.trailing.whitespaces.in.text.block.name=Espacios en blanco al final en un bloque de texto
inspection.trailing.whitespaces.in.text.block.remove.whitespaces=Eliminar los caracteres de espacio en blanco al final
inspection.trailing.whitespaces.in.text.block.replaces.whitespaces.with.escapes=Escapar caracteres de espacio en blanco al final
inspection.trivial.functional.expression.usage.display.name=Uso trivial de expresión funcional
inspection.unchecked.warning.display.name=Advertencia de falta de comprobación
inspection.undeclared.service.usage.message=El uso del servicio ''{0}'' no está declarado en module-info
inspection.undeclared.service.usage.name=Uso de un servicio no declarado en 'module-info'
inspection.unresolved.module.dependencies.problem.descriptor=Dependencias de módulo sin resolver
inspection.unused.assignment.display.name=Asignación no utilizada
inspection.unused.assignment.option=Informar sobre expresiones de prefijo que pueden reemplazarse por una expresión binaria
inspection.unused.assignment.option1=Informar sobre expresiones de postfijo en las que no se utiliza el valor modificado
inspection.unused.assignment.option2=Informar sobre inicializadores redundantes
inspection.unused.assignment.option3=Informar sobre variables de patrón cuyos valores nunca se utilizan
inspection.unused.assignment.option4=Informar sobre los parámetros de iteración cuyos valores nunca se utilizan
inspection.unused.assignment.problem.descriptor1=La variable <code>#ref</code> #loc nunca se utiliza
inspection.unused.assignment.problem.descriptor2=El inicializador <code>#ref</code> #loc de la variable <code>{0}</code> es redundante
inspection.unused.assignment.problem.descriptor3=El valor <code>{0}</code> asignado a <code>#ref</code> #loc nunca se utiliza
inspection.unused.assignment.problem.descriptor4=El valor cambiado en <code>#ref</code> #loc nunca se utiliza
inspection.unused.assignment.problem.descriptor5=El valor de la variable de patrón <code>#ref</code> #loc nunca se utiliza
inspection.unused.assignment.problem.descriptor6=El valor del parámetro de iteración foreach <code>#ref</code> #loc nunca se utiliza
inspection.unused.assignment.remove.assignment.quickfix=Eliminar asignación redundante
inspection.unused.assignment.remove.assignment.quickfix.title=Eliminar asignación redundante
inspection.unused.assignment.remove.initializer.quickfix=Eliminar inicializador redundante
inspection.unused.assignment.remove.initializer.quickfix.title=Eliminar inicializador redundante
inspection.unused.display.name=Declaración no utilizada
inspection.unused.parameter.composer=El parámetro <code>#ref</code> no se utiliza en ninguna implementación
inspection.unused.parameter.composer1=El parámetro <code>#ref</code> no se utiliza en este método ni en ninguno de sus métodos que lo sobrescriben
inspection.unused.parameter.delete.family=Eliminación segura de parámetros no utilizados
inspection.unused.parameter.delete.quickfix=Eliminar de forma segura el parámetro no utilizado ''{0}''
inspection.unused.parameter.problem.descriptor=El parámetro <code>#ref</code> no se utiliza
inspection.unused.return.value.display.name=El método puede convertirse en 'void'
inspection.unused.return.value.make.void.quickfix=Convertir el método a 'void'
inspection.unused.return.value.problem.descriptor=El valor de retorno del método nunca se utiliza
inspection.unused.symbol.check.accessors=Getters/setters
inspection.unused.symbol.check.classes=Clases:
inspection.unused.symbol.check.fields=Campos:
inspection.unused.symbol.check.inner.classes=Clases internas:
inspection.unused.symbol.check.localvars=Variables locales
inspection.unused.symbol.check.methods=Métodos:
inspection.unused.symbol.check.parameters=Parámetros en
inspection.unused.symbol.check.parameters.excluding.hierarchy=Excluir jerarquía
inspection.use.bulk.operation.display.name=Se puede usar una operación masiva en lugar de una iteración
inspection.value.based.warnings=Advertencias basadas en valores
inspection.value.based.warnings.synchronization=Sincronización en una instancia de una clase basada en valores
inspection.variable.assigned.to.itself.display.name=La variable se asigna a sí misma
inspection.wrapper.type.may.be.primitive.display.name=El tipo wrapper puede ser primitivo
inspection.wrapper.type.may.be.primitive.fix.name=Convertir tipo de envoltorio a primitivo
inspection.wrapper.type.may.be.primitive.name=El tipo puede ser primitivo
intention.add.explicit.type.arguments.family=Añadir argumentos de tipo explícitos
intention.add.on.demand.static.import.family=Añadir importación estática bajo demanda
intention.add.on.demand.static.import.text=Añadir importación estática bajo demanda para ''{0}''
intention.add.on.demand.static.import.to.auto.import.family=Añadir importación estática bajo demanda a la importación automática
intention.add.on.demand.static.import.to.auto.import.text=Añadir la importación estática bajo demanda ''{0}'' a la autoimportación
intention.add.single.member.import.text=Añadir importación para ''{0}''
intention.add.single.member.static.import.family=Añadir importación estática de un solo miembro
intention.add.single.member.static.import.text=Añadir importación estática para ''{0}''
intention.assign.field.from.parameter.family=Asignar parámetro al campo
intention.assign.field.from.parameter.text=Asignar parámetro al campo ''{0}''
intention.bind.fields.from.parameters.family=Vincular parámetros a campos
intention.bind.fields.from.parameters.text=Vincular {0} parámetros a campos
intention.break.string.on.line.breaks.text=Dividir cadena en '\n'
intention.category.annotations=Java/Anotaciones
intention.category.collections=Java/Colecciones
intention.category.comments=Java/Comentarios
intention.category.concurrency=Java/Concurrencia
intention.category.conditional.operator=Java/Condiciones
intention.category.control.flow=Java/Flujo de control
intention.category.declaration=Java/Declaración
intention.category.expressions=Java/Expresiones
intention.category.i18n=Java/Internacionalización
intention.category.imports=Java/Importaciones
intention.category.junit=Java/JUnit
intention.category.other=Java/Otros
intention.category.refactorings=Java/Refactorizaciones
intention.category.streams=Java/Streams
intention.category.strings=Java/Cadenas
intention.category.try.statements=Java/Sentencias try
intention.compose.function.family=Reemplazar llamada a función anidada por composición
intention.compose.function.text=Reemplazar llamada a función anidada por llamada a andThen
intention.convert.color.representation.family=Convertir representación de color
intention.convert.color.representation.text=Convertir a ''new Color{0}''
intention.convert.compact.constructor.to.canonical=Convertir constructor compacto en canónico
intention.convert.to.single.return.command.text=Transformar el cuerpo a un formato de punto de salida único
intention.convert.to.single.return.name=Convertir el cuerpo a una forma con un único punto de salida
intention.convert.to.single.return.progress.title=Transformar el cuerpo a una forma de punto de salida único
intention.create.annotation.method.from.usage=Crear método de @interface ''{0}()''
intention.create.field.from.parameter.family=Crear campo para el parámetro
intention.create.field.from.parameter.text=Crear campo para el parámetro ''{0}''
intention.create.switch.statement=Crear sentencia switch
intention.create.test.dialog.choose.super.class=Seleccionar superclase
intention.create.test.dialog.class.name=Nombre de la clase:
intention.create.test.dialog.fix.library=Corregir
intention.create.test.dialog.generate=Generar:
intention.create.test.dialog.java=Java
intention.create.test.dialog.library.not.found=No se encontró la biblioteca {0} en el módulo
intention.create.test.dialog.select.methods=Generar &métodos de prueba para:
intention.create.test.dialog.setUp=set&Up/@Before
intention.create.test.dialog.show.inherited=Mostrar métodos &heredados
intention.create.test.dialog.super.class=Superclase:
intention.create.test.dialog.tearDown=tear&Down/@After
intention.create.test.dialog.testing.library=&Biblioteca de pruebas:
intention.encapsulate.field.text=Encapsular campo
intention.error.cannot.create.class.message=No se puede crear la clase ''{0}''
intention.error.cannot.create.class.title=Error al crear la clase
intention.error.make.sealed.class.different.modules=Algunos de los herederos están en módulos diferentes
intention.error.make.sealed.class.different.packages=El módulo no tiene nombre y algunos de los herederos se encuentran en un paquete diferente
intention.error.make.sealed.class.has.anonymous.or.local.inheritors=Algunos de los herederos son anónimos o locales
intention.error.make.sealed.class.inheritors.not.in.java.file=Algunos de los herederos no están en archivos Java
intention.error.make.sealed.class.interface.has.no.inheritors=La interfaz no tiene herederos
intention.error.make.sealed.class.is.used.in.functional.expression=La clase se utiliza en una expresión funcional
intention.extract.if.condition.family=Extraer condición 'if'
intention.extract.if.condition.text=Extraer if ({0})
intention.extract.map.step.family=Extraer a un método de mapeo independiente
intention.extract.map.step.text=Extraer la variable ''{0}'' a la operación ''{1}''
intention.extract.method.text=Extraer método
intention.extract.set.from.comparison.chain.family=Extraer Set de la cadena de comparación
intention.extract.set.from.comparison.chain.popup.title=Extraer Set de la cadena de comparación
intention.extract.set.from.comparison.chain.replace.all=Reemplazar todas las apariciones
intention.extract.set.from.comparison.chain.replace.only.this=Reemplazar solo esta ocurrencia
intention.family.add.javadoc=Añadir Javadoc
intention.family.copy.abstract.method.implementation=Copiar implementación de método abstracto
intention.family.create.a.class.in.package=Crear una clase en el paquete
intention.family.edit.method.contract=Editar contrato del método
intention.family.edit.range=Editar rango
intention.family.expand.static.import=Expandir importación estática
intention.family.fix.bounded.wildcards=Corregir comodines limitados
intention.family.make.external.annotations.explicit=Hacer explícitas las anotaciones externas
intention.family.make.inferred.annotations.explicit=Hacer explícitas las anotaciones inferidas
intention.family.move.it=Mover
intention.family.name.add.main.method=Añadir método 'main'
intention.family.name.box.primitive.in.conditional.branch=Realizar boxing de valor primitivo en bifurcación condicional
intention.family.name.convert.record.to.class=Convertir registro a clase
intention.family.name.delete.possible.side.effects=Eliminar posibles efectos secundarios
intention.family.name.delete.private.method=Eliminar método privado
intention.family.name.dismiss=Descartar
intention.family.name.extract.possible.side.effects=Extraer posibles efectos secundarios
intention.family.name.ignore.project=No volver a mostrar en este proyecto
intention.family.name.make.sealed=Sellar clase
intention.family.name.move.class.to.test.root=Mover clase a la raíz de pruebas
intention.family.name.rename.to.ignored=Renombrar a ignored
intention.family.name.set.explicit.variable.type=Establecer tipo de variable explícito
intention.family.name.synchronize.inline.snippet=Sincronizar fragmento en línea
intention.family.name.upgrade.jdk=Actualizar JDK
intention.family.put.arguments.on.one.line=Poner los argumentos en una sola línea
intention.family.put.arguments.on.separate.lines=Colocar argumentos en líneas separadas
intention.family.put.parameters.on.one.line=Poner los parámetros en una sola línea
intention.family.put.parameters.on.separate.lines=Colocar los parámetros en líneas separadas
intention.family.put.record.components.on.one.line=Poner los componentes del record en una sola línea
intention.family.put.record.components.on.separate.lines=Colocar componentes de registro en líneas separadas
intention.family.replace.optional.ispresent.condition.with.functional.style.expression=Reemplazar la condición de presencia de Optional por una expresión de estilo funcional
intention.family.sort.content=Ordenar contenido
intention.family.swap.if.statements=Intercambiar sentencias 'if'
intention.family.unimplement.interface.class=Dejar de implementar interfaz/clase
intention.family.variable.access.from.inner.class=Mover al objeto anónimo
intention.implement.abstract.class.default.text=Implementar clase abstracta
intention.implement.abstract.class.family=Implementar clase abstracta o interfaz
intention.implement.abstract.method.command.name=Implementar método
intention.implement.abstract.method.error.no.classes.message=No se han encontrado clases donde se pueda implementar este método
intention.implement.abstract.method.error.no.classes.title=No se encontraron clases
intention.implement.abstract.method.family=Implementar método abstracto
intention.implement.abstract.method.searching.for.descendants.progress=Buscando descendientes…
intention.implement.abstract.method.text=Implementar método ''{0}''
intention.inline.map.family=Inlinear método de mapeo de flujo
intention.inline.map.inline.text=Insertar en línea el cuerpo de ''{0}()'' en la siguiente llamada a ''{1}()''
intention.inline.map.merge.text=Fusionar la llamada ''{0}()'' y la llamada ''{1}()''
intention.introduce.variable.text=Introducir variable local
intention.invert.if.condition=Invertir la condición 'if'
intention.make.final.fixer.if=Hacer que ''{0}'' sea efectivamente final moviendo el inicializador a la sentencia ''if''
intention.make.final.fixer.stream=Hacer que ''{0}'' sea efectivamente final mediante la API de stream
intention.merge.filter.family=Combinar filtros
intention.merge.filter.text=Fusionar cadena de filtros
intention.move.field.assignment.to.declaration=Mover asignación a la declaración de campo
intention.move.initializer.to.constructor=Mover inicializador al constructor
intention.move.initializer.to.set.up=Mover el inicializador al método setUp
intention.name.collapse.into.loop=Contraer en un bucle
intention.name.copy.to.final.temp.variable=Copiar ''{0}'' a la variable temporal {1, choice, 0#|1#efectivamente }final
intention.name.delete.method=Eliminar el método ''{0}()''
intention.name.delete.method.only=… y nada más
intention.name.delete.method.title=Eliminar método ''{0}()''
intention.name.delete.method.with.callees=… junto con otros métodos privados utilizados solo allí
intention.name.extract.method.to.new.interface=Extraer el método ''{0}'' a una interfaz nueva
intention.name.iterate.over=Iterar sobre {0}
intention.name.make.variable.final=Hacer {1, choice, 0#''''{0}''''|1#las variables} final
intention.name.move.class.to.test.root=Mover ''{0}'' a la raíz de prueba
intention.name.move.into.if.branches=Mover hacia arriba a las ramas de la sentencia 'if'
intention.name.pull.method.up=Subir el método ''{0}''
intention.name.pull.method.up.and.make.it.abstract.conditionally=Subir el método ''{0}'' a ''{1}''{2, choice, 0# y hacerlo abstracto|1# injection}
intention.name.pull.method.up.make.it.abstract=Subir el método ''{0}'' y hacerlo abstracto
intention.name.set.variable.type=Establecer el tipo de variable a ''{0}''
intention.name.transform.variables.into.final.one.element.array=Transformar {1, choice, 0#''''{0}''''|1#las variables} en un array final de un solo elemento
intention.name.upgrade.jdk.to=Actualizar JDK a {0}+
intention.override.method.text=Sobrescribir el método ''{0}''
intention.replace.concatenation.with.formatted.output.family=Reemplazar concatenación con salida formateada
intention.replace.concatenation.with.formatted.output.text=Reemplazar '+' con 'java.text.MessageFormat.format()'
intention.sequenced.collection.can.be.used.display.name=Se puede utilizar el método SequencedCollection
intention.sequenced.collection.can.be.used.fix.name=Reemplazar con una llamada al método de SequencedCollection
intention.split.declaration.assignment.text=Dividir en declaración y asignación
intention.split.declaration.family=Dividir declaración
intention.split.filter.family=Dividir filtro
intention.split.filter.text=Dividir en cadena de filtros
intention.split.if.family=Dividir 'if'
intention.split.if.text=Dividir en 2 sentencias 'if'
intention.split.switch.branch.with.several.case.values.copy.text=Copiar rama 'switch'
intention.split.switch.branch.with.several.case.values.family=Dividir la rama del switch con varios valores case en ramas de 'switch' individuales
intention.split.switch.branch.with.several.case.values.split.text=Dividir valores de la rama 'switch'
intention.surround.resource.with.ARM.block=Rodear con bloque try-with-resources
intention.surround.with.ARM.block.template=try-with-resources
intention.text.add.method.contract.to.0=Agregar contrato del método a ''{0}()''…
intention.text.add.range.to.0=Agregar rango a ''{0}''…
intention.text.annotate.externally=Anotar externamente
intention.text.collapse.repeating.annotations=Contraer anotaciones repetidas
intention.text.create.a.class.in.0=Crear una clase en ''{0}''
intention.text.create.a.class.in.package.preview=Abre un cuadro de diálogo para crear una clase en el paquete ''{0}''
intention.text.edit.method.contract.of.0=Editar contrato del método de ''{0}()''…
intention.text.edit.range.of.0=Editar el rango de ''{0}''…
intention.text.fix.method.0.parameters.with.bounded.wildcards=Corregir los parámetros del método ''{0}'' con comodines acotados
intention.text.generate.missing.test.methods=Generar métodos de prueba faltantes
intention.text.implements.list.remove.others=Eliminar otras referencias a ''{0}''
intention.text.replace.all.delete.import=Reemplazar todo y eliminar la importación
intention.text.replace.implements.with.static.import=Reemplazar implements por importación estática
intention.text.replace.static.import.with.qualified.access.to.0=Reemplazar importación estática por acceso calificado a {0}
intention.text.replace.this.occurrence.keep.import=Reemplazar esta aparición y mantener la importación
intention.text.unimplement.0=Desimplementar {0}
intention.unroll.loop.family=Desenrollar bucle
intention.unwrap.else.branch=Desenvolver rama 'else'
intention.unwrap.else.branch.changes.semantics=Desglosar la rama 'else' (cambia la semántica)
intention.use.single.member.static.import.text=Usar importación estática para ''{0}''
intention.wrap.with.unmodifiable=Envolver con una colección o un mapa inmodificable
intention.wrap.with.unmodifiable.list=Envolver con una lista inmodificable
intention.wrap.with.unmodifiable.map=Envolver con un mapa inmodificable
intention.wrap.with.unmodifiable.set=Envolver con un conjunto inmodificable
interface.not.allowed=No se permite la interfaz
interfaces.cannot.be.inlined=No se pueden inlinear las interfaces
introduce.functional.variable.accessibility.conflict=La variable {0} no es efectivamente final y no será accesible dentro de la expresión funcional
introduce.functional.variable.interface.chooser.title=Seleccionar interfaz funcional aplicable: {0} -> {1}
introduce.functional.variable.nothing.found.message=No se encontraron interfaces funcionales aplicables
introduce.parameter.advertisement.text=Presione {0} para delegar mediante un método de sobrecarga o {1} para mostrar más opciones
introduce.parameter.inlay.title.delegate=Delegar
introduce.parameter.inlay.tooltip.delegate=Delegar mediante un método de sobrecarga
introduce.parameter.object.no.accessor.conflict.message=Se requiere {0, choice, 0#el getter|1#el setter} para el campo ''{1}''
introduce.variable.change.semantics.warning=Extraer la expresión seleccionada cambiaría la semántica de toda la expresión.
introduce.variable.change.type.adv=Presione {0} para cambiar el tipo
introduce.variable.reassign.adv=Presione {0} para reasignar la variable existente
invalid.extracted.class.name=''{0}'' no es un nombre de clase extraída válido
invert.quickfix.preview=Abre un cuadro de diálogo para invertir el booleano seleccionado y elegir su nuevo nombre.
java.completion.tag={0, choice, 1#Etiqueta:|2#Etiquetas:}
java.configurable.logger.identifier.long=El identificador es demasiado largo
java.configurable.logger.not.found=No se encontró el logger dentro del proyecto
java.configurable.logger.unspecified=Sin especificar
java.implicit.types.inlay.provider.name=Tipos implícitos
java.implicit.types.lambda.inlay.provider.name=Tipos de parámetros lambda
java.implicit.types.local.inlay.provider.name=Tipos implícitos
java.line.markers=Marcadores de línea de Java
java.method.chains.inlay.provider.name=Cadenas de métodos
java.platform.module.system.name=Sistema de módulos de la plataforma Java
java.preview.features.accept.notification.link=Aceptar
java.preview.features.alert.title=Alerta de función experimental
java.preview.features.legal.notice=Debe aceptar los términos del aviso legal de la especificación beta de Java para habilitar el soporte para "{0}".<br/><br/><b>La implementación de un borrador inicial de la especificación desarrollada bajo el Java Community Process (JCP) se ofrece únicamente con fines de prueba y evaluación y no es compatible con ninguna especificación del JCP.</b>{1}
java.preview.features.notification.title=Funciones de vista previa de Java
java.preview.features.unsupported=El nivel de lenguaje Java <b>{0} (Preview)</b> utilizado en este proyecto ya no es compatible. El análisis de código para las funciones en vista previa puede no funcionar correctamente.<br>Se recomienda encarecidamente migrar a una versión de Java más reciente o dejar de utilizar las funciones en vista previa.
java.preview.features.unsupported.title=Funciones de vista previa de Java no compatibles
java.preview.features.warning=Las versiones más recientes del IDE podrían dejar de admitir las funciones de vista previa de Java. Cuando se lance Java {0}, es posible que se retire el soporte para el nivel de lenguaje {1} (Preview).
java.preview.level={0} (vista previa)
java.terms.exception=Excepción
java.terms.instance.initializer=Inicializador de instancia
java.terms.of.annotation.type={0} del tipo de anotación {1}
java.terms.of.anonymous.class={0} de la clase anónima
java.terms.of.class={0} de la clase {1}
java.terms.of.enum={0} de la enumeración {1}
java.terms.of.interface={0} de la interfaz {1}
java.terms.region=Región
java.terms.static.initializer=Inicializador estático
java.terms.type.parameter=Parámetro de tipo
java.terms.variable.of.method={0} de {1}
java.test.overall.time=Tiempo total: {0}
java.test.sum.time=Tiempo total: {0}
java.test.use.wall.time=Usar tiempo de reloj
javadoc.apiNote=Nota de la API:
javadoc.author=Autor:
javadoc.candidates.not.found=<html>No se han encontrado candidatos para la llamada al método <b>{0}</b>.</html>
javadoc.constructor.candidates=<html>Los candidatos para el nuevo <b>{0}</b>() son:<br>{1}</html>
javadoc.deprecated=Obsoleto
javadoc.description.copied.from.class=Desde la clase:
javadoc.description.copied.from.field=Desde el campo:
javadoc.description.copied.from.interface=Desde la interfaz:
javadoc.description.inferred.annotation.hint=i
javadoc.documentation.url.checked=Se {0, choice, 1#ha comprobado la siguiente URL|2#han comprobado las siguientes URL} de documentación:
javadoc.edit.api.docs.paths=Editar rutas de documentación de la API
javadoc.gen.error.module.source.path.is.not.evaluated=IDEA no puede generar Javadoc porque no se puede evaluar module-source-path
javadoc.gen.error.modules.without.module.info=IDEA no puede generar Javadoc ya que los módulos {0} no contienen el archivo module-info.java
javadoc.generate.arguments=Argumentos de la línea de comandos:
javadoc.generate.exited=\n"javadoc" finalizó con el código de salida $EXIT_CODE$
javadoc.generate.heap.size=Tamaño &máximo del heap:
javadoc.generate.include.jdk.library.sources.in.sourcepath.option=Incluir fuentes del JDK y de librerías en -sourcepath
javadoc.generate.link.to.jdk.documentation.option=Enlace a la documentación del JDK (usar la opción -link)
javadoc.generate.locale=Configuración regiona&l:
javadoc.generate.no.classes.in.selected.packages.error=No se encontraron fuentes de Java en el ámbito seleccionado
javadoc.generate.no.javadoc.tool=No se puede generar JavaDoc: no se encontró la herramienta javadoc en {0} o {1}. Especifique un Java SDK válido en Ajustes | Estructura del proyecto.
javadoc.generate.no.jdk=No se puede generar JavaDoc - no hay ningún SDK de Java configurado para el proyecto. Especifique un SDK de Java en Configuración | Estructura del proyecto.
javadoc.generate.ok=Generar
javadoc.generate.open.in.browser=Abrir la documentación &generada en el navegador
javadoc.generate.options.hierarchy=Generar árbol de jerarquía
javadoc.generate.options.index=Generar índice
javadoc.generate.options.index.per.letter=Separar índice por letra
javadoc.generate.options.navigator=Generar barra de navegación
javadoc.generate.options.separator=Opciones de JavaDoc
javadoc.generate.output.directory=&Directorio de salida:
javadoc.generate.output.directory.browse=Explorar el directorio de salida
javadoc.generate.scope.row=Nivel de visibilidad:
javadoc.generate.sources.progress=Buscando fuentes para generar Javadoc
javadoc.generate.tag.list.deprecated=Lista de elementos obsoletos
javadoc.generate.temp.file.does.not.exist=El archivo temporal no existe o no se puede abrir
javadoc.generate.temp.file.error=No se puede crear el archivo temporal
javadoc.generate.title=Generar JavaDoc
javadoc.generate.validation.error=Especifique el directorio de salida.
javadoc.implNote=Nota de<br>implementación:
javadoc.implSpec=Requisitos de<br>implementación:
javadoc.method.in.class={0} en la clase {1}
javadoc.method.in.interface={0} en la interfaz {1}
javadoc.method.overrides=Sobrescribe:
javadoc.method.specified.by=Especificado por:
javadoc.option.automatically.insert.closing.tag.javadoc=Insertar automáticamente la etiqueta de cierre en JavaDoc
javadoc.option.javadoc.title=JavaDoc
javadoc.see.also=Véase también:
javadoc.settings.title=Javadoc
javadoc.since=Desde:
javadoc.snippet.error.both.substring.and.regex=@{0}: debe especificarse una expresión regular o una subcadena, pero no ambas
javadoc.snippet.error.duplicate.attribute=@{0}: atributo duplicado: ''{1}''
javadoc.snippet.error.malformed.regular.expression=@{0}: expresión regular mal formada: {1}
javadoc.snippet.error.malformed.replacement=@{0}: reemplazo de expresión regular mal formado ''{1}'': {2}
javadoc.snippet.error.markup.tag.expected=Se esperaba una etiqueta de marcado o un atributo
javadoc.snippet.error.missing.required.attribute=@{0}: falta el atributo ''{1}''
javadoc.snippet.error.regex.too.complex=@{0}: expresión regular ''{1}'' demasiado compleja
javadoc.snippet.error.unknown.enum.value=@{0}: {1} ''{2}'' desconocido; solo se admiten {3}
javadoc.snippet.error.unsupported.attribute=@{0}: atributo no admitido: ''{1}''
javadoc.snippet.not.found=Fragmento no encontrado: {0}
javadoc.snippet.region.not.found=Región no encontrada: {0}
javadoc.type.parameters=Parámetros de tipo:
javadoc.version=Versión:
jrt.node.short=[JRT]
jvm.logging.configurable.display.name=Registro de la JVM
jvm.logging.configurable.id=jvm.logging
jvm.logging.configurable.java.group.display.name=Java
label.add.math.max.0.count.to.avoid.possible.semantics.change=Añadir Math.max(0, count) para evitar un posible cambio de semántica
label.canonical.constructor=Constructor canónico
label.class.filter.editor.add.dialog.filter.pattern=Introduzca el patrón de filtro:
label.class.pattern.syntax.explanation=Deje el método en blanco para representar constructores\nCualquier * coincidirá con uno o más caracteres en el nombre calificado (incluyendo puntos)
label.compact.constructor=Constructor compacto
label.configurable.logger.generation.variable.name=Nombre de la variable:
label.configurable.logger.type=Logger:
label.contract=&Contrato:
label.enter.fully.qualified.class.name=Introduzca el nombre de clase completamente cualificado
label.entry.points=Puntos de entrada:
label.forbid.api.usages=Prohibir el uso de API más recientes que
label.forbid.api.usages.project=(según la configuración del proyecto)
label.from.inclusive=&Desde (inclusive):
label.ignore.complicated.fix=Ignorar cuando no se pueda proporcionar una corrección rápida
label.ignored.exceptions=Excepciones ignoradas:
label.implementation=Implementación:
label.implements.method.of_class_or_interface.name=Implementa el método de {0, choice, 0#la interfaz|1#la clase} ''{1}''.
label.implements.method.of_interfaces=Implementa los métodos de las siguientes clases/interfaces:
label.jvm.class.name=Nombre de la clase JVM
label.jvm.field.name=Nombre del campo JVM
label.jvm.method.name=Nombre del método JVM
label.maximal.reported.method.visibility=Visibilidad máxima del método:
label.method=Método ''{0}''
label.minimal.reported.method.usage.count=Número mínimo de usos del método para reportar el parámetro:
label.mutates=&Mutaciones:
label.name.prefix=Prefijo de nombre:
label.name.suffix=Sufijo del nombre:
label.naming.field=Campo:
label.naming.local.variable=Variable local:
label.naming.parameter=Parámetro:
label.naming.static.field=Campo estático:
label.naming.subclass=Subclase:
label.naming.test.class=Clase de prueba:
label.new.template.name=Nuevo nombre de plantilla:
label.overrides.method.of_class_or_interface.name=Sobrescribe el método de la {0, choice, 0#interfaz|1#clase} ''{1}''.
label.show.import.popup.for=Mostrar sugerencia de importación automática para:
label.to.inclusive=&Hasta (inclusive):
label.unused.declaration.reachable.from.tests.option=Cuando los puntos de entrada están en las fuentes de prueba, marcar los elementos llamados como:
lambda.tree.node.presentation=Lambda
leave.in.same.source.root.item=Mantener en la misma raíz de fuentes
library.classes.cannot.be.inlined=Las clases de biblioteca no se pueden insertar en línea
line.marker.recursive.call=Llamada recursiva
line.marker.type.external.annotations=Anotaciones externas
line.marker.type.inferred.contract.annotations=Anotaciones de contrato inferidas
line.marker.type.inferred.nullability.annotations=Anotaciones de nulabilidad inferidas
link.configurable.logger.generator.display.name=<a href='link'>Configuración</a>
link.configure.classes.excluded.from.completion=Configurar clases excluidas del completado
list.item.configuration=[configuración] {0}
list.item.suite=[suite] {0}
listbox.import.package=Paquete
listbox.import.static=Estático
listbox.import.with.subpackages=Con subpaquetes
live.template.context.consumer.function=Función consumer
live.template.context.declaration=Declaración
live.template.context.else=Posición de 'else'
live.template.context.expression=Expresión
live.template.context.implicit.class.declaration=Declaración en archivos de código fuente compactos
live.template.context.normal.class.after.instance.main.declaration=Declaración dentro de una clase normal que contiene un método 'main' de instancia
live.template.context.normal.class.before.instance.main.declaration=Declaración dentro de una clase normal sin un método 'main' de instancia
live.template.context.statement=Sentencia
loading.additional.annotations=Cargando anotaciones adicionales…
macro.array.variable=VariableDeArreglo()
macro.class.name=Nombre de clase
macro.classpath.entry=Entrada en el classpath a la que pertenece el elemento
macro.component.type.of.array=TipoDeComponenteDe(Matriz)
macro.descendant.classes.enum=DescendantClassesEnum(String)
macro.expression.type=TipoDeExpresión(Expresión)
macro.file.fully.qualified.package=Paquete totalmente calificado del archivo
macro.file.package=Paquete de archivos
macro.guess.element.type.of.container=GuessElementType(Contenedor)
macro.iterable.component.type=iterableComponentType(Array o Iterable)
macro.iterable.variable=VariableIterable()
macro.javadoc.output.directory=Directorio de salida de JavaDoc
macro.project.classpath=Classpath del proyecto
macro.variable.of.type=VariableOfType(Tipo)
megabytes.unit=megabytes
methods.to.implement.chooser.title=Seleccionar métodos para implementar
methods.to.override.chooser.title=Seleccionar métodos para sobrescribir
methods.to.override.generate.javadoc=Generar JavaDoc faltante
methods.to.override.implement.chooser.title=Seleccionar métodos para sobrescribir/implementar
module.not.in.requirements=El módulo ''{0}'' no incluye el módulo ''{1}'' en sus requisitos
module.package.not.exported=El módulo ''{0}'' no exporta el paquete ''{1}'' al módulo ''{2}''
module.package.not.open=El módulo ''{0}'' no abre el paquete ''{1}'' al módulo ''{2}''
module.type.java.description=Los módulos Java se utilizan para desarrollar aplicaciones de escritorio y web <b>basadas en JVM</b>, incluyendo aplicaciones que utilizan <b>Java EE</b> y otros frameworks de desarrollo empresarial.
module.type.java.name=Módulo Java
move.class.import.from.default.package.conflict={0} no será accesible desde el paquete predeterminado
move.classes.destination.class.not.found.message=No se encontró la clase de destino
move.classes.invalid.destination.package.name.message=''{0}'' no es un nombre de paquete de destino válido
move.inner.select.target.package.title=Seleccionar paquete de destino
move.member.enum.conflict=El tipo enum no es aplicable en el contexto actual
move.member.final.initializer.conflict=El inicializador de final {0} se dejará atrás.
multiple.usages.of.static.import.found=Se han encontrado múltiples usos de la importación estática
navigate.to.duplicate.fix=Navegar al duplicado
new.line.when.body.is.presented=Nueva línea cuando se presenta el cuerpo
no.jre.description=<sin JRE>
no.methods.overriding.0.are.found=No se han encontrado métodos que sobrescriban {0, choice, 0#|1# ''''{1}''''|2#estas clases}
no.patterns=No se han configurado patrones de clase
node.call.hierarchy.unknown.jsp=Jsp desconocido
node.hierarchy.java.lang.object=Todas las clases derivan de java.lang.Object
non.code.annotations.explanation.external.and.inferred.available=Anotaciones externas e <i>inferidas</i> disponibles.
non.code.annotations.explanation.external.available=Anotaciones externas disponibles.
non.code.annotations.explanation.full.signature=Firma completa:
non.code.annotations.explanation.inferred.available=Anotaciones <i>inferidas</i> disponibles.
notification.content.added.annotations=Se han agregado {0} {0, choice, 1#anotación|2#anotaciones}
notification.content.change.jdk=Cambiar JDK
notification.content.was.set.up=Se ha configurado el JDK ''{0}'' para el proyecto
notification.group.arch.checker=Las arquitecturas del JDK y del sistema son diferentes
notification.group.jdk.resolve.problems=No se pudo resolver el JDK
notification.group.jshell=Ocurrió un problema con JShell
notification.group.language.level=El nivel de lenguaje Java de vista previa requiere aceptar la licencia
notification.group.legacy.library=La biblioteca heredada depende de la instalación del IDE
notification.group.preview.features=El nivel de lenguaje Java de vista previa podría ser discontinuado
notification.group.redundant.exports=Se pueden eliminar las exportaciones/aperturas redundantes
notification.group.repository=Archivos JAR sincronizados con el repositorio
notification.group.setup.external.annotations=Error al cargar las anotaciones externas
notification.group.setup.jdk=JDK configurado
notification.group.setup.sdk=SDK JDK configurado
notification.group.source.searcher=No se han encontrado las fuentes del archivo JAR
notification.group.testintegration=No se pudieron generar las pruebas para @TestDataPath
notification.group.unsupported.jdk=JDK no soportado
notification.navigation.to.overriding.classes=No se puede navegar a las clases que sobrescriben durante la actualización del índice
notification.navigation.to.overriding.methods=La navegación a los métodos de sobreescritura no es posible durante la actualización del índice
notification.text.full.thread.dump.was.successfully.copied.to.clipboard=Se ha copiado correctamente al portapapeles el volcado de hilos completo (thread dump)
null.check.surrounder.description=if (expr != null) {…}
nullable.notnull.annotation.used.label=Anotación utilizada para la generación de código:
nullable.notnull.annotations.panel.title=Anotaciones {0}:
nullable.notnull.annotations.runtime.instrumentation.tooltip=Añadir aserciones en tiempo de ejecución para métodos y parámetros anotados con notnull
nullable.notnull.configuration.dialog.title=Configuración de Nullable/NotNull
nullable.stuff.inspection.navigate.null.argument.usages.fix.family.name=Navegar a los usos de argumentos 'null'
nullable.stuff.inspection.navigate.null.argument.usages.fix.family.preview=Muestra una lista de usos donde se pasa 'null' como argumento.
nullable.stuff.inspection.navigate.null.argument.usages.view.name=Usos de argumentos ''null'' para el parámetro {0}
offline.inspections.jdk.not.found=No se encontró {0}
offline.inspections.library.urls.were.not.resolved=No se resolvieron las raíces {0} de la biblioteca ''{1}'' del módulo ''{2}''
offline.inspections.library.was.not.resolved=Por favor, configure la biblioteca ''{0}'' que se utiliza en el módulo ''{1}''
offline.inspections.no.source.roots=No se han detectado raíces de código fuente para el módulo ''{0}''
open.settings.dialog.for.module.preview.text=Abrir el diálogo de configuración para el módulo ''{0}''
options.java.attribute.descriptor.abstract.class=Clases e Interfaces//Clase abstracta
options.java.attribute.descriptor.abstract.method=Métodos//Método abstracto
options.java.attribute.descriptor.annotation.attribute.name=Anotaciones//Nombre del atributo de anotación
options.java.attribute.descriptor.annotation.name=Anotaciones//Nombre de la anotación
options.java.attribute.descriptor.anonymous.class=Clases e Interfaces//Clase anónima
options.java.attribute.descriptor.class=Clases e Interfaces//Clase
options.java.attribute.descriptor.constructor.call=Métodos//Llamada al constructor
options.java.attribute.descriptor.constructor.declaration=Métodos//Declaración constructor
options.java.attribute.descriptor.enum=Clases e Interfaces//Enum
options.java.attribute.descriptor.implicit.anonymous.parameter=Parámetros//Parámetro implícito de clase anónima
options.java.attribute.descriptor.inherited.method=Métodos//Método heredado
options.java.attribute.descriptor.instance.field=Campos de clase//Campo de instancia
options.java.attribute.descriptor.instance.final.field=Campos de clases//Campos finales de la instancia
options.java.attribute.descriptor.interface=Clases e interfaces//Interfaz
options.java.attribute.descriptor.javadoc.comment=Comentarios//JavaDoc//Texto
options.java.attribute.descriptor.javadoc.markup=Comentarios//JavaDoc//Marcado
options.java.attribute.descriptor.javadoc.tag=Comentarios//JavaDoc//Etiqueta
options.java.attribute.descriptor.lambda.parameter=Parámetros//Parámetro lambda
options.java.attribute.descriptor.method.call=Métodos//Llamada a método
options.java.attribute.descriptor.method.declaration=Métodos//Declaración de método
options.java.attribute.descriptor.method.imported.call=Métodos//Llamada a método importado estático
options.java.attribute.descriptor.package.private=Visibilidad//Privado de paquete
options.java.attribute.descriptor.private=Visibilidad//Privado
options.java.attribute.descriptor.protected=Visibilidad//Protegido
options.java.attribute.descriptor.public=Visibilidad//Público
options.java.attribute.descriptor.reassigned.local.variable=Variables//Variable local reasignada
options.java.attribute.descriptor.reassigned.parameter=Parámetros//Parámetro reasignado
options.java.attribute.descriptor.static.field=Campos de clase//Campo estático
options.java.attribute.descriptor.static.final.field=Campos de clase//Constante (campo static final)
options.java.attribute.descriptor.static.final.imported.field=Campos de clase//Constante (campo importado static final)
options.java.attribute.descriptor.static.imported.field=Campos de clase//Campo estático importado
options.java.attribute.descriptor.static.method=Métodos//Método estático
options.java.attribute.descriptor.type.parameter=Parámetros de tipo
options.java.display.name=Java
override.implement.broken.file.template.message=Por favor, corrija la plantilla "Cuerpo del método sobrescrito/implementado"
override.implement.broken.file.template.title=Error de plantilla de archivo
override.methods.error.no.methods=No se han encontrado métodos para sobrescribir
package.chooser.modal.progress.title=Buscando paquetes…
package.classes=Clases del paquete:
package.dependencies.production.node.text=Clases de producción
package.dependencies.test.node.text=Clases de prueba
package.pattern.provider.hint.label=Use <b>*.txt</b> para coincidir con todos los archivos 'txt' del proyecto, <b>file:path_in_project//*</b> para coincidir con todos los archivos de un directorio de forma recursiva, <b>src:foo..*</b> para coincidir con todas las clases de un paquete de forma recursiva.
packaging.jlink.artifact.name=JLink
packaging.jlink.artifact.title=Imagen de tiempo de ejecución (JLink)
packaging.jlink.compression.first.level=Uso compartido de cadenas
packaging.jlink.compression.level=Nivel de compresión
packaging.jlink.compression.second.level=Zip
packaging.jlink.compression.zero.level=Sin compresión
packaging.jlink.verbose.tracing=Habilitar seguimiento detallado
paste.class.command.name=Pegar clase ''{0}''
please.report.a.bug=Por favor, informe de un error
popup.content.tests.were.not.found.in.module=No se encontraron pruebas en el módulo ''{0}''.\n
popup.content.tests.were.not.found.in.module.search.in.dependencies=Buscar en las dependencias del módulo en su lugar
popup.content.tests.were.not.found.in.module.use.instead=Use {0, choice, 0#el módulo {1} |1#uno de\n{2}\n} en su lugar
popup.title.choose.framework=Seleccionar framework
popup.title.choose.target.class=Seleccionar clase de destino
popup.title.choose.test=Elegir prueba
popup.title.debug.recent.tests=Depurar pruebas recientes
popup.title.remove.unused.variable=Eliminar variable no utilizada
popup.title.select.a.jar.file=Seleccionar un archivo JAR
popup.title.select.qualified.name=Seleccionar nombre completo
popup.title.select.target.code.block=Seleccionar bloque de código de destino
postfix.template.condition.array.name=Array
postfix.template.condition.array.reference.name=Array de tipos no primitivos
postfix.template.condition.boolean.name=booleano
postfix.template.condition.non.void.name=No void
postfix.template.condition.not.primitive.type.name=Tipo no primitivo
postfix.template.condition.number.name=Número
postfix.template.condition.void.name=Void
postfix.template.editor.choose.class.title=Seleccionar clase
postfix.template.language.level.title=Nivel mínimo de lenguaje:
postfix.template.provider.name=Java
presentable.text.anonymous.class=Clase anónima
presentable.text.code.display=Código
presentable.text.code.from.context=Código de {0}
presentable.text.invalid.element.name=INVÁLIDO
press.0.to.see.inheritors.of.1=Presione {0} para ver los herederos de {1}
press.0.to.see.non.imported.classes=Presione {0} para ver las clases no importadas
pressing.0.twice.without.a.class.qualifier=Pulsar {0} dos veces sin un calificador de clase mostraría todos los métodos estáticos accesibles
preview.api.usage={0} es una API de vista previa y podría eliminarse en una versión futura
preview.api.usage.reflective={0} es una API de vista previa de reflexión y puede que se elimine en una versión futura
progress.creating.class=Creando la clase {0}
progress.title.calculate.applicable.types=Calculando tipos aplicables…
progress.title.check.applicability=Comprobando aplicabilidad…
progress.title.checking.if.class.exists=Comprobando si la clase de destino ''{0}'' existe
progress.title.collect.method.overriders=Recopilando sobrescritores de métodos…
progress.title.detect.overridden.methods=Comprobar métodos de sobrescritura
progress.title.detecting.jdk=Detectando JDK
progress.title.download.library.descriptor=Descargar descriptor de librería
progress.title.find.references.in.implement.extends.lists=Buscando referencias en las listas de implements/extends…
progress.title.finding.cause=Buscando la causa
progress.title.looking.for.jdk=Buscando JDK…
progress.title.looking.for.libraries=Buscando librerías
progress.title.optimize.imports=Optimizar importaciones…
progress.title.preprocess.usages=Preprocesar usos
progress.title.restore.references=Restaurando referencias
progress.title.search.for.overriding.methods=Buscando métodos de sobrescritura…
progress.title.searching.for.sub.classes=Buscando subclases
progress.title.searching.references=Buscando referencias…
project.problems.fix.description=Se encontraron problemas relacionados con ''{0}''
project.problems.fix.text=Mostrar problemas relacionados
project.problems.hint.text={0} {0, choice, 0#problema relacionado|2#problemas relacionados}
project.problems.title=Problemas relacionados
project.problems.window.title=Problemas relacionados con {0}
prompt.choose.base.class.of.the.hierarchy=Seleccione la clase base de la jerarquía en la que buscar
prompt.create.non.existing.package=El paquete {0} no existe.\n¿Desea crearlo?
prompt.delete.class={0,choice,1#clase|2#clases}
prompt.delete.field={0,choice,1#campo|2#campos}
prompt.delete.interface={0,choice,1#interfaz|2#interfaces}
prompt.delete.method={0,choice,1#método|2#métodos}
prompt.delete.package={0,choice,1#paquete|2#paquetes}
prompt.delete.type.parameter={0,choice,1#parámetro de tipo|2#parámetros de tipo}
prompt.do.you.want.to.action_verb.the.method.from_class=¿Desea {1} {0,choice,1#el método|2#los métodos} base en su lugar?
psi.error.incorrect.class.template.message=No se puede crear {0} - plantilla de {1} incorrecta.
psi.search.overriding.progress=Buscando métodos de sobrescritura…
pull.members.up.fix.name=Subir miembros
pull.up.accessible.conflict={0} no será accesible
pull.up.accessible.conflict.1={0} no será accesible desde {1}
pull.up.concrete.inherit.abstract.method.conflict={0} concreto heredará un nuevo método abstracto
pull.up.members.usage.view.description.code.references.node=Clase para subir miembros a "{0}"
pull.up.members.usage.view.description.processed.elements.node=Subir miembros de la clase {0}
push.down.anonymous.conflict=No se pueden mover las implementaciones a una clase anónima
push.down.missed.implementation.conflict={0} no abstracto carecerá de la implementación de {1}
push.down.static.nonstatic.conflict=No se puede bajar el {0} estático al {1} no estático
push.down.super.method.call.changed.conflict=La llamada al supermétodo se resolverá en otro método
push.method.down.command.name=Bajar método…
qualify.static.access.command.name=Calificar acceso estático
qualify.static.call.fix.text=Calificar llamada estática
qualify.static.constant.access=Calificar el acceso a constantes estáticas
quickfix.add.variable.family.name=Inicializar variable
quickfix.add.variable.text=Inicializar variable ''{0}''
quickfix.family.avoid.mutation.using.stream.api=Evitar la mutación mediante Stream API
quickfix.family.change.javadoc.to=Cambiar a…
quickfix.family.find.cause=Buscar la causa
quickfix.family.remove.javadoc.tag=Eliminar etiqueta
quickfix.family.remove.redundant.parameter=Eliminar parámetro redundante
quickfix.family.remove.redundant.parameter.types=Eliminar tipos de parámetros redundantes
quickfix.family.replace.cast.type=Reemplazar el tipo de conversión
quickfix.family.replace.inefficient.stream.count=Reemplazar Stream.count() ineficiente
quickfix.family.replace.optional.chain.with.if.statements=Reemplazar la cadena de Optional por sentencias if
quickfix.family.replace.stream.api.chain.with.loop=Reemplazar cadena de la API Stream por bucle
quickfix.family.replace.with.java.stream.api.pipeline=Reemplazar con el pipeline de Java Stream API
quickfix.family.replace.with.magic.constant=Reemplazar por una constante mágica
quickfix.family.replace.with.method.reference=Reemplazar con referencia de método
quickfix.family.replace.with.optional.of.nullable.chain=Reemplazar con una cadena de Optional.ofNullable()
quickfix.family.replace.with.stream.api.equivalent=Reemplazar con el equivalente de Stream API
quickfix.family.simplify.foreach.lambda=Simplificar lambda forEach
quickfix.family.simplify.stream.call.chain=Simplificar la cadena de llamadas del stream
quickfix.family.use.flatmap=Usar 'flatMap'
quickfix.family.wrap.with.mutable.collection=Envolver con colección mutable
quickfix.find.cause.description=Intenta resaltar los elementos de código que provocaron esta advertencia y explicar exactamente cómo contribuyen.
quickfix.name.find.jar.on.web=Buscar JAR en la web
quickfix.text.0.may.not.work.before.jdk.11.0.2={0} (puede que no funcione antes de JDK 11.0.2)
quickfix.text.avoid.mutation.using.stream.api.0.operation=Evitar la mutación usando la operación ''{0}()'' de la API Stream
quickfix.text.remove.javadoc.0=Eliminar la etiqueta ''@{0}''
quickfix.text.remove.javadoc.0.1=Eliminar @{0} {1}
quickfix.text.remove.not.null.annotation=Eliminar anotación de no nulo
quickfix.text.replace.0.stream.with.1.2=Reemplazar {0}.stream() con {1}.{2}()
quickfix.text.replace.collect.0.with.1.2=Reemplazar ''collect({0}())'' por ''{1}''{2}
quickfix.text.replace.filter.0.is.present.with.any.match=Reemplazar ''filter().{0}().isPresent()'' por ''anyMatch()''
quickfix.text.replace.stream.0.with.1.2=Reemplazar ''stream().{0}()'' por ''{1}()''{2}
quickfix.text.replace.url.with.html=Reemplazar URL con enlace HTML
quickfix.text.replace.url.with.link=Reemplazar URL por un enlace
quickfix.text.suffix.may.change.semantics=(puede cambiar la semántica)
quickfix.text.wrap.0.with.1=Envolver ''{0}'' con ''{1}''
radio.button.subclass.of.0=Subclase de ''{0}''
radio.button.unused.declaration.unused.option=No utilizado
radio.button.unused.declaration.used.option=Usado
radio.button.with.provider.method=Con el método 'provider()'
radio.use.fully.qualified.class.names.in.javadoc=Usar nombres de clase completamente calificados en JavaDoc:
radio.use.fully.qualified.class.names.in.javadoc.always=Siempre
radio.use.fully.qualified.class.names.in.javadoc.if.not.imported=Si aún no se ha importado
radio.use.fully.qualified.class.names.in.javadoc.never=Nunca, usa nombre corto y añade import
raw.use.of.parameterized.type.ignore.new.objects.option=Ignorar la construcción de nuevos objetos
raw.use.of.parameterized.type.ignore.overridden.parameter.option=Ignorar tipos de parámetros de métodos que sobrescriben
raw.use.of.parameterized.type.ignore.quickfix.not.available.option=Ignorar cuando la corrección rápida automática no esté disponible
raw.use.of.parameterized.type.ignore.type.casts.option=Ignorar conversiones de tipo
raw.use.of.parameterized.type.ignore.uncompilable.option=Ignorar donde un parámetro de tipo no compilaría
raw.variable.type.can.be.generic.cast.quickfix=Cambiar tipo de conversión a {0}
raw.variable.type.can.be.generic.cast.quickfix.family=Parametrizar tipo de conversión
raw.variable.type.can.be.generic.family.quickfix=Añadir parámetros genéricos al tipo
raw.variable.type.can.be.generic.quickfix=Cambiar el tipo de {0} a {1}
records.cannot.be.inlined=Las clases record no se pueden insertar en línea
refactoring.method.reference.to.lambda.conflict=La referencia a método se convertirá en lambda
remove.var.keyword.text=Eliminar 'var'
rename.package.class.already.exist.conflict=Ya existe una clase con el nombre calificado ''{0}''
rename.package.command.name=Renombrar paquete
rename.package.ignored.name.warning=Intentando crear un paquete con un nombre ignorado, el resultado no será visible
rename.package.invalid.name.error=Nombre de paquete no válido
rename.super.base.chooser.popup.title={0}{1, choice, 0# implementa|1# sobrescribe} el método de {2}
rename.super.methods.chooser.popup.title={0} tiene supermétodos
replace.implements.with.static.import.field.usages.progress=Buscando usos de campo constante...
scheduled.thread.pool.executor.with.zero.core.threads.description='ScheduledThreadPoolExecutor' no debe tener cero hilos de núcleo
scheduled.thread.pool.executor.with.zero.core.threads.display.name='ScheduledThreadPoolExecutor' con cero hilos de núcleo
scope.hierarchy=Jerarquía de {0}
sdk.cannot.create=No se puede crear el SDK
sdk.configured=''{0}'' se ha establecido como el JDK del proyecto.
sdk.configured.external.config.title=JDK configurado ({0})
sdk.configured.notification.title=JDK configurado
sdk.configured.sdkmanrc=''{0}'' se configura como JDK del proyecto.
sdk.configured.sdkmanrc.title=JDK está configurado (.sdkmanrc)
sdk.java.no.classes=No se pueden encontrar las clases del JDK en ''{0}''
section.title.inspection.suspicious.names.ignore.methods=Ignorar métodos:
separator.annotations.to.copy=Anotaciones para copiar
separator.mark.as.entry.point.if.annotated.by=Marcar como punto de entrada si está anotado por:
separator.mark.field.as.implicitly.written.if.annotated.by=Marcar campo como escrito implícitamente si está anotado por:
set.language.level=Establecer nivel de lenguaje
set.language.level.to.0=Establecer el nivel de lenguaje en {0}
settings.completion.ml.java.display.name=Java
settings.inlay.java.annotations=Anotaciones
settings.inlay.java.builder.like.methods=Métodos de tipo builder
settings.inlay.java.complex.expressions.binary.functional.array.access.and.other=Expresiones complejas como argumentos
settings.inlay.java.enum.constants=Constantes de enumeración
settings.inlay.java.external.annotations=Anotaciones externas
settings.inlay.java.implicit.types=Tipos implícitos
settings.inlay.java.implicit.types.description=Variables locales declaradas con la palabra clave `var` cuando el tipo inferido no se puede obtener de la parte derecha de la asignación, por ejemplo, cuando se usa un método de fábrica.
settings.inlay.java.implicit.types.lambda=Tipos de lambda
settings.inlay.java.implicit.types.lambda.description=Mostrar pistas integradas para los tipos de parámetros lambda.
settings.inlay.java.implicit.types.local=Tipos implícitos
settings.inlay.java.implicit.types.local.description=Variables locales declaradas con la palabra clave var cuando el tipo inferido puede no estar claro a partir de la parte derecha de la asignación, por ejemplo, al usar un método de fábrica.
settings.inlay.java.inferred.annotations=Anotaciones inferidas
settings.inlay.java.inheritors=Herederos
settings.inlay.java.insert.annotation=Insertar anotación
settings.inlay.java.methods.with.same.named.numbered.parameters=Métodos con parámetros numerados con el mismo nombre
settings.inlay.java.new.expressions=Expresiones 'new'
settings.inlay.java.non.literals.in.case.of.multiple.parameters.with.the.same.type=No literales en caso de múltiples parámetros con el mismo tipo
settings.inlay.java.parameters.with.names.that.are.contained.in.the.method.name=Parámetros con nombres contenidos en el nombre del método
settings.inlay.java.show.hints.for=Mostrar sugerencias para:
settings.inlay.java.show.parameter.hints.for=Mostrar sugerencias de parámetros para:
settings.inlay.java.show.parameter.hints.when.expression.type.is.clear.description=Expresiones de inicializador de array, switch, condicional, referencia, instance of, asignación, llamada, calificada, conversión de tipo y acceso a objetos de clase.
settings.inlay.java.turn.off.external.annotations=Desactivar anotaciones externas
settings.inlay.java.turn.off.inferred.annotations=Desactivar anotaciones inferidas
settings.inlay.java.turn.off.showExternal.annotations=Desactivar anotaciones externas
settings.inlay.java.turn.off.showInferred.annotations=Desactivar anotaciones inferidas
settings.inlay.java.turn.on.showExternal.annotations=Activar anotaciones externas
settings.inlay.java.turn.on.showInferred.annotations=Activar anotaciones inferidas
settings.inlay.java.usages=Usos
show.import.popup.for.classes=&Clases
show.import.popup.for.static.methods.and.fields=Métodos y campos e&státicos
show.siblings.choose.super.class.title=Seleccionar superclase o interfaz
show.siblings.find.usages.class.title=Superclases/interfaces
show.siblings.find.usages.method.title=Supermétodos
side.effects.expression.presentation=Expresión ''{0}''
simplify.optional.chain.inspection.fix.description.optional.chain.can.be.eliminated=La cadena Optional se puede eliminar
simplify.optional.chain.inspection.fix.description.replace.with.value.of.description=La cadena de Optional se puede reemplazar con 'String.valueOf()'
simplify.optional.chain.inspection.fix.description.replace.with.value.of.name=Reemplazar con 'String.valueOf()'
simplify.optional.chain.inspection.fix.name.remove.redundant.optional.chain=Eliminar cadena Optional redundante
simplify.optional.chain.inspection.map.or.else.description=La cadena Optional se puede simplificar
simplify.optional.chain.inspection.optional.rewrapping.description=Reempaquetado innecesario de Optional
simplify.optional.chain.inspection.optional.rewrapping.name=Desempaquetar
simplify.optional.chain.inspection.or.else.non.null.fix.description=La comprobación de nulos se puede eliminar con 'ifPresent'
simplify.optional.chain.inspection.or.else.non.null.fix.name=Reemplazar la comprobación de null con ifPresent()
simplify.optional.chain.inspection.or.else.return.fix.description=Se puede eliminar la comprobación de null
simplify.optional.chain.inspection.or.else.return.fix.name=Reemplazar la comprobación de null por {0}({1})
simplify.optional.chain.inspection.remove.redundant.steps.from.optional.chain=Eliminar pasos redundantes de la cadena opcional
simplify.optional.chain.inspection.to.x=Simplificar encadenamiento opcional a ''{0}''
simplify.stream.collection.creation.fix.name=Reemplazar con el constructor ''{0}''
simplify.stream.inspection.iterate.take.while.fix.message=Puede reemplazarse por 'iterate()' de tres argumentos
simplify.stream.inspection.iterate.take.while.fix.name=Reemplazar con 'iterate()' de tres argumentos
simplify.stream.inspection.message.can.be.replaced='{0}'' se puede reemplazar por ''{1}'
simplify.stream.inspection.message.can.be.replaced.may.change.semantics=''{0}'' se puede reemplazar por ''{1}'' (puede cambiar la semántica)
simplify.stream.match.negation.fix.name=Reemplazar {0} con {1}(…)
simplify.stream.remove.boolean.identity.fix.message=Se puede combinar con la llamada a 'map()' anterior
simplify.stream.remove.boolean.identity.fix.name=Combinar con la llamada anterior a 'map()'
simplify.stream.replace.support.with.collection.fix.message=Se puede reemplazar por la llamada a ''{0}.{1}()''
simplify.stream.replace.support.with.collection.fix.name=Reemplazar por la llamada a ''{0}.{1}()''
simplify.stream.replace.with.element.iteration.fix.message=Puede reemplazarse por la iteración de elementos
simplify.stream.simple.stream.of.fix.name.use.stream.element.explicitly=Usar el elemento Stream explícitamente
simplify.stream.simple.stream.of.message=Stream de un solo elemento innecesario
simplify.stream.swap.filter.and.map.fix.message='filter()' y 'map()' se pueden intercambiar
simplify.stream.swap.filter.and.map.fix.name=Intercambiar 'filter()' y 'map()'
slice.filter.parse.error.enum.constant.not.found=No se encontró la constante de enumeración: {0}
slice.filter.parse.error.expression.must.evaluate.to.constant=La expresión debe evaluarse como una constante: {0}
slice.filter.parse.error.incorrect.constant.expected.number=Constante incorrecta (se esperaba un número): {0}
slice.filter.parse.error.incorrect.constant.type=Tipo de constante incorrecto (se requiere: {0})
slice.filter.parse.error.incorrect.expression=Expresión incorrecta: {0}
slice.filter.parse.error.not.null.filter.not.applicable.for.primitive.type=El filtro ''!null'' no es aplicable al tipo primitivo {0}
slice.filter.parse.error.null.filter.not.applicable.for.primitive.type=El filtro ''null'' no es aplicable al tipo primitivo {0}
slice.usage.message.assertion.violated=(¡aserción violada!)
slice.usage.message.in.file.stopped.here=(en el archivo {0} - se detuvo aquí)
slice.usage.message.location=En {0}
slice.usage.message.tracking.container.contents=(Rastreando el contenido del contenedor ''{0}{1}'')
sort.threads.by.interest.level=Ordenar hilos por nivel de interés
sort.threads.by.name=Ordenar hilos por nombre
sort.threads.by.type=Ordenar hilos por tipo
special.annotations.annotations.list=Anotaciones especiales adicionales:
special.annotations.annotations.preview=Añade ''@{0}'' a una lista de anotaciones que serán ignoradas por esta inspección
special.annotations.list.add.annotation.class=Añadir clase de anotación
special.annotations.list.annotation.class=Clase de anotación
special.annotations.list.annotation.pattern=Añadir patrón de anotaciones
special.annotations.list.annotation.pattern.message=Añadir patrón de anotaciones
special.annotations.list.remove.pattern=Eliminar
spi.extension.error.message=La extensión registrada debe implementar {0}
spi.no.provider.error.message=No se encontró el proveedor de servicios "{0}"
status.bar.overridden.methods.highlighted.message={0} {0, choice, 1#método sobrescrito encontrado|2#métodos sobrescritos encontrados} (presione {1} de nuevo para quitar el resaltado, Escape para quitar todo el resaltado)
stream.to.loop.inspection.message.replace.foreach.call.with.loop=Reemplazar la llamada a 'forEach()' por un bucle
stream.to.loop.inspection.message.replace.stream.api.chain.with.loop=Reemplazar la cadena de la API Stream con un bucle
surround.with.cast=Envolver con conversión de tipo
surround.with.dowhile.template=do / while
surround.with.for.template=for
surround.with.ifelse.expression.template=if (expr) {…} else {…}
surround.with.not.instanceof.template=!(expr instanceof Tipo)
surround.with.runnable.template=Runnable
surround.with.synchronized.template=synchronized
surround.with.try.catch.finally.template=try / catch / finally
surround.with.try.catch.incorrect.template.message=Plantilla de archivo no válida para el cuerpo del catch
surround.with.try.catch.template=try / catch
switch.stmt.template.description=switch (expr) {…}
tab.title.entry.points=Puntos de entrada
tab.title.infer.nullity.preview=Vista previa de inferencia de nulidad
tab.title.members.to.report=Miembros a reportar
tab.title.slices.grouped.by.nullness=(Agrupado por nulidad)
table.cell.constructors=Constructores
target.code.block.presentable.text=Bloque contenedor
title.cannot.create.class=No se puede crear la clase
title.code.vision=Visión de código
title.code.vision.inlay.hints=Visión de código
title.import.layout=Importar diseño:
title.javadoc=JavaDoc
title.naming=Nomenclatura
title.naming.final.modifier=Declaración de variable
title.naming.functional.expressions=Cuerpo de lambda
title.naming.variable=Variable
title.package.not.found=Paquete no encontrado
title.packages=Paquetes
title.packages.to.use.import.with=Paquetes para usar importación con '*':
title.related.problems.inlay.hints=Problemas relacionados
to.import.a.method.statically.press.0=Para importar un método estáticamente, presione {0}
todo.index.not.available=N/D
tooltip.anonymous=Anónimo
tooltip.has.several.functional.implementations=Tiene varias implementaciones funcionales
tooltip.implements.method=Implementa el método
tooltip.implements.method.in=Implementa el método en
tooltip.incorrect.file.template=Plantilla de archivo ''{0}'' incorrecta
tooltip.is.functionally.implemented.in=Implementado funcionalmente en
tooltip.is.implemented.by=Implementado por
tooltip.is.implemented.by.several.subclasses=Implementado por varias subclases
tooltip.is.implemented.in=Se implementa en
tooltip.is.implemented.in.several.subclasses=Se implementa en varias subclases
tooltip.is.overridden.by.several.subclasses=Sobrescrito por varias subclases
tooltip.is.overridden.in=Sobrescrito en
tooltip.is.overridden.in.several.subclasses=Se ha sobrescrito en varias subclases
tooltip.is.subclassed.by=Subclaseado por
tooltip.overrides.method=Sobrescribe el método
tooltip.overrides.method.in=Sobrescribe el método en
tooltip.reassigned.local.variable=Variable local reasignada
tooltip.reassigned.parameter=Parámetro reasignado
tooltip.recursive.call=Llamada recursiva
tooltip.variable.used=La variable ''{0}'' está en uso
tooltip.via.subclass=Vía subclase
type.information.constraints=Restricciones
type.information.local.object=Objeto local
type.information.locality=Localidad
type.information.mutability=Mutabilidad
type.information.not.equal.to=No es igual a
type.information.nullability=Nulabilidad
type.information.range=Rango
type.information.type=Tipo
type.information.value=Valor
type.migration.cannot.convert.message=No se puede convertir el tipo de la expresión <b>{0}</b>{3, choice, 0#|1# de '<'b'>'{1}'<'/b'>'} a <b>{2}</b>
type.migration.cannot.convert.tooltip=No se puede convertir el tipo de la expresión de {0} a {1}
type.migration.cannot.convert.vararg.message=No se puede convertir la llamada <b>{0}</b> de vararg a no vararg
type.migration.cannot.convert.vararg.tooltip=No se puede convertir la llamada de vararg a no vararg
type.migration.command.name=Migración de tipos
type.migration.dialog.message.disjunction.type.not.applicable=Solo se puede migrar un parámetro de bloque catch a un tipo de unión
type.migration.dialog.message.invalid.type=''{0}'' no es un tipo válido
type.migration.dialog.message.vararg.type.not.applicable=Solo el último parámetro de un método puede migrarse a un tipo vararg
type.migration.dialog.message.void.not.applicable=Solo los tipos de retorno de los métodos pueden migrarse a 'void'
type.migration.getter.rename.suggestion.always.migrate.method.names=Migrar siempre los nombres de los métodos
type.migration.getter.rename.suggestion.never.migrate.method.names=No migrar nunca los nombres de los métodos
type.migration.getter.rename.suggestion.text=¿Renombrar el getter de ''{0}'' a ''{1}'' ya que el tipo de retorno se ha migrado a ''{2}''?
type.migration.multi.root.toolwindow.title=Migrar tipo de {0}
type.migration.processed.elements.header=Raíz para la migración de tipos
type.migration.replaced.notification=Reemplazado por {0}
type.migration.single.root.toolwindow.title=Migrar el tipo de {0} de ''{1}'' a ''{2}''
type.parameters.cannot.be.inlined=Los parámetros de tipo no se pueden insertar en línea
unchecked.warning.inspection.message.unchecked.generics.array.creation.for.varargs.parameter=Creación de un array de genéricos no verificada para el parámetro varargs
unchecked.warning.inspection.reason.expr.has.raw.type.so.result.erased=. Razón: ''{0}'' tiene un tipo raw, por lo que el resultado de {1} se borra
unchecked.warning.inspection.settings.ignore.unchecked.assignment=Ignorar asignación no comprobada
unchecked.warning.inspection.settings.ignore.unchecked.call.as.member.of.raw.type=Ignorar la llamada no verificada como miembro de un tipo raw
unchecked.warning.inspection.settings.ignore.unchecked.cast=Ignorar conversión no comprobada
unchecked.warning.inspection.settings.ignore.unchecked.generics.array.creation.for.vararg.parameter=Ignorar la creación de arrays genéricos no comprobados para el parámetro vararg
unchecked.warning.inspection.settings.ignore.unchecked.overriding=Ignorar la sobrescritura no comprobada
unknown.library=Biblioteca desconocida
unscramble.detect.analyze.threaddump.from.clipboard.item=Detectar y analizar automáticamente los volcados de hilos copiados al portapapeles fuera de IntelliJ IDEA
unscramble.log.path.label=Archivo de &log:
unscramble.no.unscrambler.item=<Ningún descodificador instalado>
unscramble.normalize.button=&Normalizar
unscramble.stacktrace.caption=Introduzca una traza de pila o un volcado de hilos completo aquí:
unscramble.unscrambled.deadlock.tab=<Interbloqueo>
unscramble.unscrambled.stacktrace.tab=<Traza de pila>
unscramble.unscrambled.threaddump.tab=<Hilos>
unscramble.unscrambler.combobox=De&scifrador:
unscramble.use.unscrambler.checkbox=&Descodificar traza de la pila
unsupported.jdk.notification.content=El soporte extendido de Oracle para Java 7 finalizó en 2022. El uso de ''{0}'' puede causar problemas de seguridad.
unsupported.jdk.notification.title=JDK no compatible
unwrap.anonymous=Quitar envoltorio de 'anonymous…'
unwrap.array.initializer=Desenvolver inicializador de array
unwrap.conditional=Deshacer 'f ? a : b'
unwrap.lambda=Quitar 'lambda…'
unwrap.switch.expression=Desenvolver expresión 'switch'
unwrap.switch.statement=Quitar sentencia 'switch'
unwrap.synchronized=Quitar 'synchronized…'
update.external.annotations=Actualizar anotaciones externas
usage.target.exception=Excepción
usage.target.package.in.directory={0} (en {1})
usages.telescope={0,choice, 0#0 usos|1#1 uso|2#{0,number} usos}
use.external.annotations=Usar anotaciones &externas
validator.text.class.not.found=Clase no encontrada
validator.text.directory.not.found=Directorio no encontrado
validator.text.no.annotation=Debe ser una anotación
validator.text.not.directory=No es un directorio
validator.text.not.valid.class.name=Nombre de clase no válido
validator.text.wrong.superclass=Superclase incorrecta
vm.option.description.category=Categoría:
vm.option.description.default.value=Valor predeterminado:
vm.option.description.description=Descripción:
vm.option.description.diagnostic=Diagnóstico
vm.option.description.experimental=Experimental
vm.option.description.option=Opción:
vm.option.description.product=Producto
vm.option.description.requires=(requiere {0})
vm.option.description.standard=Estándar
vm.option.description.type=Tipo:
warning.java.file.outside.source.root=El archivo Java se encuentra fuera de la raíz de fuentes del módulo, por lo que no se compilará
where.do.you.want.to.move.directory.prompt={0}\n\n¿Desea mover el directorio a otra raíz de fuentes u otro directorio?
wrap.return.value.anonymous.class.presentation={0} anónima
wrap.return.value.created.class.not.accessible.conflict=La clase creada no será accesible desde el lugar de llamada
wrap.return.value.existing.class.does.not.have.appropriate.constructor.conflict=La clase existente no tiene un constructor adecuado
wrap.return.value.existing.class.does.not.have.getter.conflict=La clase existente no tiene un getter para el campo seleccionado
wrapping.annotation.enums=Anotaciones de campos enum
wrapping.annotation.parameters=Parámetros de anotación
wrapping.deconstruction.patterns=Patrón de desestructuración
wrapping.multi.catch.types=Tipos en multi-catch
wrapping.record.components=Componentes de registro
wrapping.semicolon.after.call.chain=Mover ';' a una línea nueva
wrapping.switch.statement.or.expression=Sentencia/expresión 'switch'
wrapping.text.blocks=Bloques de texto
wrong.package.statement=Declaración de paquete incorrecta
