0.field.is.always.initialized.not.null=El campo @{0} siempre se inicializa como no nulo
access.can.be.0=El acceso puede ser ''{0}''
access.can.be.package.private=El acceso puede ser package-private
access.to.field.code.ref.code.outside.of.declared.guards.loc=Acceso al campo <code>#ref</code> fuera de las guardas declaradas #loc
add.explicit.type.arguments=Añadir argumentos de tipo explícitos
add.explicit.type.arguments.else=Añadir argumentos de tipo explícitos a la llamada de la rama else
add.explicit.type.arguments.then=Añadir argumentos de tipo explícitos a la llamada de la rama then
annotate.as.safevarargs=Anotar como '@SafeVarargs'
annotate.overridden.methods.parameters=Anotar los parámetros de los métodos que sobrescriben como ''@{0}''
annotate.overridden.methods.parameters.family.name=Anotar parámetros de los métodos que sobrescriben
annotation.target.ANNOTATION_TYPE=tipo de anotación
annotation.target.CONSTRUCTOR=constructor
annotation.target.FIELD=campo
annotation.target.LOCAL_VARIABLE=variable local
annotation.target.METHOD=Método
annotation.target.MODULE=módulo
annotation.target.PACKAGE=paquete
annotation.target.PARAMETER=parámetro
annotation.target.RECORD_COMPONENT=componente de registro
annotation.target.TYPE=tipo
annotation.target.TYPE_PARAMETER=parámetro de tipo
annotation.target.TYPE_USE=uso de tipo
anonymous.ref.loc.can.be.replaced.with.0=#ref #loc anónimo se puede reemplazar por {0}
anonymous.ref.loc.can.be.replaced.with.lambda=#ref #loc anónimo puede reemplazarse por lambda
arguments.count.mismatch=Se esperaba {0, choice, 0#ningún argumento|1#1 argumento|1<{0} argumentos}, pero se encontraron {1}
assigning.a.collection.of.nullable.elements=Asignación de una colección de elementos que pueden ser nulos a una colección de elementos que no admiten valores nulos
call.to.method.code.ref.code.outside.of.declared.guards.loc=Llamada al método <code>#ref()</code> fuera de las guardas declaradas #loc
change.type.arguments=Cambiar argumentos de tipo
change.type.arguments.to.0=Cambiar los argumentos de tipo a <{0}>
change.visibility.level=Hacer {0} {1}
chooser.popup.title.select.class.to.move.members.to=Seleccionar clase de destino
comparision.between.object.and.primitive=La comparación entre objeto y primitivo es ilegal y solo se acepta en Java 7
contract.return.validator.incompatible.return.parameter.type=El tipo de retorno ''{0}'' debe ser convertible desde el tipo de parámetro ''{1}''
contract.return.validator.method.return.incompatible.with.method.containing.class=El tipo de retorno del método debe ser compatible con la clase que contiene el método
contract.return.validator.not.applicable.for.constructor=No aplicable al constructor
contract.return.validator.not.applicable.primitive=No aplicable al tipo de retorno primitivo ''{0}''
contract.return.validator.not.applicable.static=No es aplicable a métodos estáticos
contract.return.validator.return.type.must.be.boolean=El tipo de retorno del método debe ser 'boolean'
contract.return.validator.too.few.parameters=No es aplicable a un método que tiene {0, choice, 0#ningún parámetro|1#un parámetro|2#{0} parámetros}
contract.return.value.validation.prefix=Valor de retorno del contrato ''{0}'':
custom.exception.class.should.have.a.constructor=La clase de excepción personalizada debe tener un constructor con un solo parámetro de mensaje de tipo String
dataflow.message.array.index.out.of.bounds=Índice del array fuera de límites
dataflow.message.arraystore=Almacenar un elemento de tipo <code>{0}</code> en un array de elementos <code>{1}</code> producirá una <code>ArrayStoreException</code>
dataflow.message.assigning.null=<code>null</code> se asigna a una variable anotada con @NotNull
dataflow.message.assigning.null.notannotated=Asignando un valor <code>null</code> a un campo no anotado
dataflow.message.assigning.nullable=La expresión <code>#ref</code> puede evaluarse como null, pero se asigna a una variable anotada con @NotNull
dataflow.message.assigning.nullable.notannotated=La expresión <code>#ref</code> #loc puede ser null, pero se asigna a un campo no anotado
dataflow.message.cce=La conversión de <code>{0}</code> a <code>#ref</code> #loc puede producir <code>ClassCastException</code>
dataflow.message.cce.always=La conversión de <code>{0}</code> a <code>#ref</code> #loc producirá una <code>ClassCastException</code> para cualquier valor no nulo
dataflow.message.constant.condition=La condición <code>#ref</code> #loc es siempre <code>{0, choice, 0#false|1#true}</code>
dataflow.message.constant.condition.when.reached=La condición <code>#ref</code> #loc siempre es <code>{0, choice, 0#falso|1#verdadero}</code> al alcanzarse
dataflow.message.constant.expression=El resultado de <code>#ref</code> #loc siempre es ''{0}''
dataflow.message.constant.method.reference=El resultado de la referencia al método siempre es ''{0}''
dataflow.message.constant.no.ref=La condición siempre es {0, choice, 0#falsa|1#verdadera}
dataflow.message.constant.value=El valor <code>#ref</code> #loc es siempre ''{0}''
dataflow.message.contract.fail=La llamada a '#ref' siempre falla, según los contratos de su método
dataflow.message.contract.fail.index=La llamada a '#ref' siempre falla debido a que un argumento está fuera de los límites
dataflow.message.fail=La llamada a '#ref' siempre falla con una excepción
dataflow.message.immutable.modified=El objeto inmutable ha sido modificado
dataflow.message.immutable.passed=Se pasa un objeto inmutable donde se espera uno mutable
dataflow.message.negative.array.size=Tamaño de array negativo
dataflow.message.npe.array.access=El acceso al array <code>#ref</code> #loc puede producir <code>NullPointerException</code>
dataflow.message.npe.array.access.sure=El acceso al array <code>#ref</code> #loc producirá <code>NullPointerException</code>
dataflow.message.npe.field.access=La desreferencia de <code>#ref</code> #loc puede producir <code>NullPointerException</code>
dataflow.message.npe.field.access.sure=La desreferencia de <code>#ref</code> #loc producirá <code>NullPointerException</code>
dataflow.message.npe.inner.class.construction=La construcción de una clase interna puede producir <code>NullPointerException</code>
dataflow.message.npe.inner.class.construction.sure=La construcción de la clase interna producirá <code>NullPointerException</code>
dataflow.message.npe.method.invocation=La invocación del método <code>#ref</code> #loc puede producir una <code>NullPointerException</code>
dataflow.message.npe.method.invocation.sure=La invocación del método <code>#ref</code> #loc producirá <code>NullPointerException</code>
dataflow.message.npe.methodref.invocation=La invocación de referencia a método <code>#ref</code> #loc puede producir <code>NullPointerException</code>
dataflow.message.npe.template.invocation=La invocación del procesador de plantillas puede producir <code>NullPointerException</code>
dataflow.message.npe.template.invocation.sure=La invocación del procesador de plantillas producirá <code>NullPointerException</code>
dataflow.message.only.switch.label=La etiqueta switch <code>#ref</code> #loc es la única alcanzable en todo el switch
dataflow.message.passing.non.null.argument.to.optional=Optional.ofNullable()' con un argumento no nulo debe reemplazarse por 'Optional.of()
dataflow.message.passing.null.argument=Pasando el argumento <code>null</code> al parámetro anotado como @NotNull
dataflow.message.passing.null.argument.nonannotated=Pasando un argumento <code>null</code> a un parámetro no anotado
dataflow.message.passing.null.argument.to.optional=Optional.ofNullable()' con un argumento null debe reemplazarse por 'Optional.empty()
dataflow.message.passing.nullable.argument=El argumento <code>#ref</code> #loc puede ser nulo
dataflow.message.passing.nullable.argument.methodref=El argumento de la referencia a método puede ser null
dataflow.message.passing.nullable.argument.methodref.nonannotated=El argumento de referencia de método podría ser nulo, pero se pasa a un parámetro no anotado
dataflow.message.passing.nullable.argument.nonannotated=El argumento <code>#ref</code> #loc puede ser nulo, pero se pasa a un parámetro no anotado
dataflow.message.pointless.assignment.expression=La condición <code>#ref</code> #loc en el lado izquierdo de la expresión de asignación es siempre <code>{0}</code>. Se puede simplificar.
dataflow.message.pointless.same.argument.and.result=El resultado de ''#ref'' es el mismo que el {0,choice,1#primer|2#segundo} argumento, lo que hace que la llamada carezca de sentido
dataflow.message.pointless.same.arguments=Los argumentos de '#ref' son iguales. Llamar a este método con los mismos argumentos no tiene sentido
dataflow.message.redundant.assignment=La variable ya tiene asignado este valor
dataflow.message.redundant.instanceof=La condición <code>#ref</code> #loc es redundante y puede sustituirse por <code>!= null</code>
dataflow.message.redundant.update=La actualización de la variable no hace nada
dataflow.message.return.notnull.from.nullable=El método @{0} ''{1}'' siempre devuelve un valor no nulo
dataflow.message.return.null.from.notnull=<code>null</code> es devuelto por el método declarado como @{0}
dataflow.message.return.null.from.notnullable=El método devuelve <code>null</code> y no está declarado como @{0}
dataflow.message.return.nullable.from.notnull=La expresión <code>#ref</code> puede evaluarse como null, pero es devuelta por el método declarado como @{0}
dataflow.message.return.nullable.from.notnull.function=La función puede devolver null, pero no se permite aquí
dataflow.message.return.nullable.from.notnullable=La expresión <code>#ref</code> podría evaluarse como null, pero es devuelta por el método que no está declarado como @{0}
dataflow.message.storing.array.null=<code>null</code> se almacena en un array de elementos @NotNull
dataflow.message.storing.array.nullable=La expresión <code>#ref</code> puede evaluarse como null, pero se almacena en una matriz de elementos @NotNull
dataflow.message.stream.consumed=El flujo podría haber sido ya vinculado o consumido
dataflow.message.stream.consumed.always=El flujo ya ha sido vinculado o consumido
dataflow.message.unboxing=El desempaquetado de <code>#ref</code> #loc puede producir <code>NullPointerException</code>
dataflow.message.unboxing.method.reference=El uso de <code>#ref</code> #loc requeriría unboxing, lo cual puede producir una <code>NullPointerException</code>
dataflow.message.unboxing.nullable.argument.methodref=Pasar un argumento a la referencia de método requiere un unboxing que puede producir <code>NullPointerException</code>
dataflow.message.unknown.nullability=(nulabilidad desconocida)
dataflow.message.unreachable.switch.label=La etiqueta de switch <code>#ref</code> #loc es inalcanzable
dataflow.method.fails.with.null.argument=El método lanzará una excepción cuando el parámetro sea null
dataflow.not.precise={0} es complejo: los resultados del flujo de datos podrían ser imprecisos
dataflow.too.complex={0} es demasiado complejo para analizar mediante el algoritmo de flujo de datos
delete.repeated.0=Eliminar ''{0}'' repetido
delete.repeated.interface=Eliminar interfaz repetida
delimiters.argument.contains.duplicated.characters=El argumento 'delimiters' de StringTokenizer contiene caracteres duplicados
deprecated.class.usage.group.xml=XML
deprecated.member.0.is.still.used=El miembro obsoleto ''{0}'' todavía se utiliza
detach.library.quickfix.name=Desvincular biblioteca
detach.library.roots.quickfix.name=Desvincular raíces de biblioteca no utilizadas
dfa.find.cause.an.execution.might.exist.where=Puede existir una ejecución donde:
dfa.find.cause.and.another=Y {0}
dfa.find.cause.array.length.is.always.non.negative=La longitud del array siempre es no negativa
dfa.find.cause.call.always.fails=La llamada siempre falla
dfa.find.cause.cast.may.fail=La conversión de tipo puede fallar
dfa.find.cause.collection.size.is.always.non.negative=El tamaño de la colección siempre es no negativo
dfa.find.cause.comparison.arguments.are.different.constants=Los argumentos de comparación son constantes diferentes
dfa.find.cause.comparison.arguments.are.the.same=Los argumentos de comparación son iguales
dfa.find.cause.compile.time.constant=Es una constante de tiempo de compilación que se evalúa como ''{0}''
dfa.find.cause.condition.is.known.from.place=Se sabe que ''{0}'' de __PLACE___(_P)
dfa.find.cause.condition.was.checked.before=La condición ''{0}'' se comprobó antes
dfa.find.cause.condition.was.deduced=La condición ''{0}'' fue deducida
dfa.find.cause.contract.kind.explicit=Contrato
dfa.find.cause.contract.kind.hard.coded=Contrato codificado de forma rígida
dfa.find.cause.contract.kind.inferred=Contrato inferido
dfa.find.cause.contract.returns.on.condition=Según {0}, {1} ''{2}'' devuelve ''{3}'' cuando {4}
dfa.find.cause.contract.throws.on.condition=Según {0}, {1} ''{2}'' lanza una excepción cuando {3}
dfa.find.cause.contract.trivial=Según {0}, {1} ''{2}'' siempre devuelve el valor ''{3}''
dfa.find.cause.equality.established.from.condition=''{0}'' se estableció a partir de la condición
dfa.find.cause.field.assigned.nullability=Se sabe que el campo ''{0}'' siempre se inicializa con el valor ''{1}''
dfa.find.cause.field.initializer.nullability=El campo ''{0}'' se inicializa con el valor ''{1}''
dfa.find.cause.instanceof.implies.non.nullity=La comprobación 'instanceof' implica que no es nulo
dfa.find.cause.left.operand.range.template=El operando izquierdo es %s
dfa.find.cause.may.be.null=Puede ser null
dfa.find.cause.nonnull.expression.kind.concatenation=Concatenación
dfa.find.cause.nonnull.expression.kind.literal=literal
dfa.find.cause.nonnull.expression.kind.newly.created.object=Objeto recién creado
dfa.find.cause.nonnull.expression.kind.primitive.type=Un valor de tipo primitivo ''{0}''
dfa.find.cause.nonnull.expression.kind.this.object=objeto 'this'
dfa.find.cause.nullability.explicitly.annotated={0} ''{1}'' está anotado como ''{2}''
dfa.find.cause.nullability.externally.annotated={0} ''{1}'' está anotado externamente como ''{2}''
dfa.find.cause.nullability.inferred={0} ''{1}'' se infirió como ''{2}''
dfa.find.cause.nullability.inherited.from.class={0} ''{1}'' hereda la anotación de la clase {2}, por lo tanto ''{3}''
dfa.find.cause.nullability.inherited.from.container={0} ''{1}'' hereda la anotación del contenedor, por lo tanto ''{2}''
dfa.find.cause.nullability.inherited.from.named.element={0} ''{1}'' hereda de {2}, por lo tanto ''{3}''
dfa.find.cause.nullability.inherited.from.package={0} ''{1}'' hereda la anotación del paquete {2}, por lo tanto ''{3}''
dfa.find.cause.numeric.cast.operand.template=El operando de conversión es %s
dfa.find.cause.numeric.range.generic.template=El valor es %s
dfa.find.cause.object.kind.expression=Una expresión
dfa.find.cause.object.kind.generic=Un objeto
dfa.find.cause.object.kind.method.return=Retorno del método
dfa.find.cause.obviously.non.null.expression=La expresión no puede ser null ya que es {0}
dfa.find.cause.one.of.the.following.happens=Ocurre una de las siguientes situaciones:
dfa.find.cause.operand.of.boolean.expression.is.the.same=El operando #{0} de la cadena {1, choice, 0#y|1#o} es {2}
dfa.find.cause.or.another=O {0}
dfa.find.cause.place.here=Aquí
dfa.find.cause.place.line.number=Línea #{0}
dfa.find.cause.primitive.boxed=El valor primitivo fue convertido mediante boxing
dfa.find.cause.range.is.known.from.place=El rango se conoce a partir de __PLACE___(_P)
dfa.find.cause.range.is.specified.by.annotation=El rango de ''{0}'' está especificado por anotación como {1}
dfa.find.cause.result.of.numeric.operation.template=El resultado de ''{0}'' es %s
dfa.find.cause.result.of.primitive.cast.template=El resultado de la conversión a ''({0})'' es %s
dfa.find.cause.right.operand.range.template=El operando derecho es %s
dfa.find.cause.size.is.always.zero=El tamaño siempre es cero
dfa.find.cause.special.field.of.something={0} de {1}
dfa.find.cause.string.length.is.always.non.negative=La longitud de la cadena siempre es no negativa
dfa.find.cause.type.is.known.from.place=El tipo de ''{0}'' se conoce a partir de __PLACE___(_P)
dfa.find.cause.type.known=El tipo de {0} es {1}
dfa.find.cause.unable=No se puede encontrar la causa
dfa.find.cause.value.is.always.the.same=El valor siempre es {0}
dfa.find.cause.value.is.known.from.place=Se sabe que ''{0}'' es ''{1}'' por __PLACE___(_P)
dfa.find.cause.value.x.is.always.the.same=El valor ''{0}'' siempre es ''{1}''
dfa.find.cause.values.cannot.be.equal.because=Los valores no pueden ser iguales porque {0}
dfa.find.cause.variable.is.initialized={0} ''{1}'' se inicializa a {2}
dfa.find.cause.was.assigned=''{0}'' fue asignado
dfa.find.cause.was.assigned.to='{0}'' se asignó a ''{1}'
dfa.find.cause.was.dereferenced=''{0}'' fue desreferenciado
dfa.find.cause.was.passed.as.non.null.parameter=''{0}'' se pasó como argumento a un método que acepta un parámetro no nulo
dftype.presentation.empty.optional=Optional vacío
dftype.presentation.present.optional=Optional presente
don.t.report.unused.jars.inside.used.library=No informar sobre archivos JAR no utilizados dentro de una biblioteca utilizada
duplication.policy.ask=Preguntar
duplication.policy.generate.duplicate=Generar método duplicado
duplication.policy.replace=Reemplazar existente
element.kind.keys=claves
element.kind.objects=Objetos
element.kind.values=Valores
error.class.not.found=No se encontró la clase {0}
error.message.invalid.java.type=Tipo Java no válido
error.unnamed.field.not.allowed=El campo sin nombre no está permitido
error.unnamed.method.parameter.not.allowed=No se permiten parámetros de método sin nombre
error.unnamed.variable.brackets=No se permiten corchetes después de la declaración de variable sin nombre
error.unnamed.variable.not.allowed.in.this.context=Las declaraciones de variables sin nombre no son permitidas en este contexto
error.unnamed.variable.without.initializer=La declaración de una variable sin nombre debe tener un inicializador
exception.handler.will.become.unreachable=La sección catch será inalcanzable
explicit.type.argument.ref.loc.can.be.replaced.with=El argumento de tipo explícito #ref #loc se puede reemplazar por <>
exports.to.itself.delete.module.ref.fix=Eliminar referencia al módulo ''{0}''
exports.to.itself.delete.statement.fix=Eliminar directiva
find.searching.for.references.to.class.progress=Buscando referencias a la clase {0}…
find.usages.panel.title.base.methods=Usos del método base
find.usages.panel.title.base.methods.cap=Usos del método base
find.usages.panel.title.derived.classes=Clases derivadas
find.usages.panel.title.derived.classes.cap=Clases derivadas
find.usages.panel.title.derived.interfaces=Interfaces derivadas
find.usages.panel.title.derived.interfaces.cap=Interfaces derivadas
find.usages.panel.title.implementing.classes=Clases de implementación
find.usages.panel.title.implementing.classes.cap=Clases de implementación
find.usages.panel.title.implementing.methods=Métodos de implementación
find.usages.panel.title.implementing.methods.cap=Métodos de implementación
find.usages.panel.title.overloaded.methods.usages=Métodos sobrecargados
find.usages.panel.title.overloaded.methods.usages.cap=Métodos sobrecargados
find.usages.panel.title.overriding.methods=Métodos que sobrescriben
find.usages.panel.title.overriding.methods.cap=Métodos que sobrescriben
generate.members.position.after.equals.and.hashcode=Después de equals() y hashCode()
generate.members.position.at.caret=En el cursor
generate.members.position.at.the.end.of.class=Al final de la clase
highlighting.try.blocks=Resaltando bloques try…
html.classes.exposed.with.code.module.info.code.html=<html>Clases expuestas con <code>module-info</code></html>
html.ignore.overrides.of.deprecated.abstract.methods=<html>Ignorar sobrescrituras de métodos abstractos obsoletos de superclases no obsoletas</html>
ignore.casts.in.suspicious.collections.method.calls=Ignorar casts de clarificación
ignore.exceptions.thrown.by.entry.points.methods=Ignorar excepciones lanzadas por los métodos de punto de entrada
ignore.in.the.same.outermost.class=Ignorar en la misma clase más externa
ignore.in.the.same.project=Ignorar API declarada en este proyecto
ignore.inside.deprecated.members=Ignorar dentro de miembros en desuso
ignore.inside.non.static.imports=Ignorar dentro de importaciones no estáticas
ignore.members.of.deprecated.classes=Ignorar miembros de clases obsoletas
ignore.operation.which.results.in.negative.value=Ignorar la operación '<<' que resulta en un valor negativo
inspection.annotate.method.quickfix.family.name=Anotar método
inspection.annotate.method.quickfix.name=Anotar el método con ''@{0}''
inspection.annotate.overridden.method.and.self.quickfix.family.name=Anotar los métodos que sobrescriben y a sí mismo
inspection.annotate.overridden.method.and.self.quickfix.name=Anotar los métodos que sobrescriben y a sí mismo con ''@{0}''
inspection.annotate.overridden.method.nullable.quickfix.name=Anotar los métodos que sobrescriben como ''@{0}''
inspection.annotate.overridden.method.quickfix.family.name=Anotar métodos que sobrescriben
inspection.annotate.overridden.method.quickfix.name=Anotar los métodos que sobrescriben con ''@{0}''
inspection.anonymous.has.lambda.alternative.display.name=El tipo anónimo tiene una alternativa lambda más corta
inspection.block.marker.comments.display.name=Comentario de marcador de bloque
inspection.c.style.array.declarations.option=Ignorar declaraciones de estilo C en variables
inspection.can.be.final.accept.quickfix=Hacer final
inspection.can.be.final.display.name=La declaración puede tener el modificador 'final'
inspection.can.be.final.option=Reportar clases
inspection.can.be.final.option1=Reportar métodos
inspection.can.be.final.option2=Informar sobre campos
inspection.can.be.local.parameter.problem.descriptor=El parámetro <code>#ref</code> puede tener el modificador <code>final</code>
inspection.can.be.local.variable.problem.descriptor=La variable <code>#ref</code> puede tener el modificador <code>final</code>
inspection.can.be.replaced.with.message=Puede reemplazarse por ''{0}''
inspection.class.getclass.display.name=Llamada sospechosa a 'Class.getClass()'
inspection.class.getclass.fix.remove.name=Eliminar llamada a 'getClass()'
inspection.class.getclass.fix.replace.name=Reemplazar con 'Class.class'
inspection.class.getclass.message=Se llama a 'getClass()' en una instancia de Class
inspection.class.has.no.to.string.method.description=La clase ''{0}'' no sobrescribe el método ''toString()''
inspection.class.has.no.to.string.method.display.name=La clase no sobrescribe el método 'toString()'
inspection.class.has.no.to.string.method.exclude.classes.reg.exp.option=Excluir clases (exp. reg.):
inspection.class.has.no.to.string.method.ignore.abstract.classes.option=Ignorar clases abstractas
inspection.class.has.no.to.string.method.ignore.deprecated.classes.option=Ignorar clases en desuso
inspection.class.has.no.to.string.method.ignore.enum.classes.option=Ignorar clases enum
inspection.class.has.no.to.string.method.ignore.exception.classes.option=Ignorar clases de excepción
inspection.class.has.no.to.string.method.ignore.inner.classes.option=Ignorar clases internas
inspection.class.has.no.to.string.method.ignore.records.option=Ignorar registros
inspection.class.has.no.to.string.method.ignore.test.classes.option=Ignorar clases de prueba
inspection.common.if.parts.disable.highlight.tail.call=No resaltar las partes comunes si la instrucción final es una llamada
inspection.common.if.parts.family=Extraer partes comunes de la sentencia 'if'
inspection.common.if.parts.family.else.if=Combinar sentencia 'else if'
inspection.common.if.parts.family.else.if.description=Se puede combinar 'else if'
inspection.common.if.parts.family.else.if.invert=Combinar la sentencia 'else if' invirtiendo la segunda condición
inspection.common.if.parts.settings.highlight.else.if=Resaltar cadenas else-if que pueden simplificarse
inspection.common.if.parts.settings.highlight.when.tail.call=Resaltar cuando la última sentencia común sea una llamada
inspection.compiler.javac.quirks.anno.array.comma.fix=Eliminar coma final
inspection.compiler.javac.quirks.anno.array.comma.problem=La coma final en los inicializadores de arrays de anotaciones puede causar errores de compilación al usar versiones de javac anteriores (por ejemplo, JDK 5 y JDK 6)
inspection.compiler.javac.quirks.illegal.forward.reference=Las referencias hacia adelante pueden causar errores de compilación al usar versiones de javac antiguas (por ejemplo, JDK 5 y JDK 6)
inspection.compiler.javac.quirks.name=Peculiaridades de Javac
inspection.compiler.javac.quirks.qualifier.type.args.fix=Eliminar parámetro genérico
inspection.compiler.javac.quirks.qualifier.type.args.problem=Los genéricos en las referencias de calificador pueden causar errores de compilación al usar versiones de javac más antiguas (por ejemplo, JDK 5 y JDK 6)
inspection.constant.on.wrong.side.of.a.comparison.side.option=La constante debe estar en el lado|de una comparación
inspection.contract.checker.boolean.condition.for.nonboolean.parameter=El parámetro ''{0}'' es de tipo ''{1}'' (se esperaba un booleano)
inspection.contract.checker.clause.syntax=Una cláusula de contrato debe tener la forma arg1, …, argN -> valor-de-retorno
inspection.contract.checker.contract.clause.never.satisfied=La cláusula del contrato ''{0}'' nunca se cumple, ya que sus condiciones están cubiertas por contratos anteriores
inspection.contract.checker.contract.violated=Se ha violado la cláusula del contrato ''{0}''
inspection.contract.checker.empty.constraint=La restricción no debe estar vacía
inspection.contract.checker.inferred.notnull.parameter.notnull=El parámetro ''{0}'' se infiere como no nulo, por lo que ''!null'' siempre se cumple
inspection.contract.checker.inferred.notnull.parameter.null=El parámetro ''{0}'' se infiere como no nulo, por lo que ''null'' no es aplicable
inspection.contract.checker.method.always.fails.nontrivial=El valor de retorno de la cláusula ''{0}'' se puede reemplazar por ''fail'', ya que el método siempre falla en este caso
inspection.contract.checker.method.always.fails.trivial=El valor de retorno de la cláusula ''{0}'' podría sustituirse por ''fail'' ya que el método siempre falla
inspection.contract.checker.no.exception.thrown=Se infringe la cláusula del contrato ''{0}'': no se lanza ninguna excepción
inspection.contract.checker.notnull.parameter.notnull=El parámetro ''{0}'' está anotado como no nulo, por lo que siempre se cumple ''!null''
inspection.contract.checker.notnull.parameter.null=El parámetro ''{0}'' está anotado como no nulo, por lo que ''null'' no es aplicable
inspection.contract.checker.parameter.count.mismatch=El método recibe {0} parámetros, mientras que la cláusula de contrato ''{1}'' espera {2}
inspection.contract.checker.primitive.parameter.nullability=El parámetro ''{0}'' tiene el tipo primitivo ''{1}'', por lo que ''{2}'' no es aplicable
inspection.contract.checker.pure.method.mutation.contract=Un método puro no puede tener un contrato de mutación
inspection.contract.checker.unknown.constraint=La restricción debe ser una de las siguientes: {0}. Se encontró: {1}
inspection.contract.checker.unknown.return.value=El valor de retorno debe ser uno de: {0}. Se encontró: {1}
inspection.contract.checker.unreachable.contract.clause=La cláusula de contrato ''{0}'' es inalcanzable: los contratos anteriores cubren todos los casos posibles
inspection.contract.display.name=Problemas de contrato
inspection.convert.2.diamond.display.name=El tipo explícito se puede reemplazar con '<>'
inspection.convert.2.lambda.display.name=El tipo anónimo se puede reemplazar por lambda
inspection.data.flow.redundant.instanceof.quickfix=Sustituir por una comprobación de null
inspection.data.flow.simplify.boolean.expression.quickfix=Simplificar expresión booleana
inspection.data.flow.simplify.to.assignment.quickfix.name=Simplificar a asignación normal
inspection.data.flow.turn.off.constant.references.quickfix=No informar valores que se garantiza que son constantes
inspection.data.flow.turn.off.nullable.returning.notnull.quickfix=No informar sobre métodos que admiten valores nulos que siempre devuelven un valor no nulo
inspection.data.flow.turn.off.true.asserts.quickfix=No informar aserciones siempre verdaderas
inspection.data.flow.warn.when.reading.a.value.guaranteed.to.be.constant=Advertir cuando se almacena una constante en una variable
inspection.depends.on.the.java.feature=Esta inspección depende de la característica de Java ''{0}'', que está disponible desde Java {1}.
inspection.depends.on.the.java.features=Esta inspección depende de las siguientes características de Java:
inspection.depends.on.the.java.features.minimal.version=Estas funciones están disponibles desde Java {0}.
inspection.deprecated.class.usage.inspection.display.name=Uso de API obsoletas en XML
inspection.deprecated.is.still.used.display.name=Se sigue utilizando un miembro obsoleto
inspection.duplicate.throws.display.name='throws' duplicados
inspection.duplicate.throws.ignore.subclassing.option=Ignorar excepciones que heredan de otras
inspection.duplicate.throws.more.general.problem=Ya existe una excepción más general, ''{0}'', en la lista throws.
inspection.duplicate.throws.problem=throws duplicado
inspection.equals.hashcode.only.one.defined.problem.descriptor=La clase tiene {0} definido, pero no define {1}
inspection.export.results.can.be.final.description=La declaración puede tener el modificador final
inspection.expression.can.be.replaced.with.message=La expresión puede reemplazarse por ''{0}''
inspection.extract.method.dont.suggest.length=No sugerir la extracción de métodos tan cortos como este
inspection.extract.method.dont.suggest.parameters=No sugerir la extracción de métodos con {0} o más parámetros
inspection.extract.method.inspection.name=Se puede extraer el método
inspection.extract.method.message=Es posible extraer un método que devuelve ''{0}'' a partir de un método circundante largo
inspection.extract.method.nothing=Nada
inspection.extract.method.option.max.parameters=Número máximo de parámetros:
inspection.extract.method.option.min.length=Longitud mínima de código para extraer:|símbolos
inspection.extract.method.preview.html=Extraer {0} sentencias a un método que acepta {1} y devuelve <b>{2}</b>
inspection.field.access.not.guarded.display.name=Acceso a campo o llamada a método no protegidos
inspection.field.not.used.in.to.string.description=El método ''{0}'' no se utiliza en el método ''toString()''
inspection.field.not.used.in.to.string.description2=El campo ''{0}'' no se utiliza en el método ''toString()''
inspection.field.not.used.in.to.string.display.name=Campo no utilizado en el método 'toString()'
inspection.fix.name.remove.scheduled.for.removal.annotation.by.attribute=Reemplazar @ScheduledForRemoval por el atributo 'forRemoval' en la anotación @Deprecated
inspection.i18n.quickfix.annotate=Anotar…
inspection.i18n.quickfix.annotate.as=Anotar como ''@{0}''
inspection.i18n.quickfix.annotate.element=Anotar {0} ''{1}''…
inspection.i18n.quickfix.annotate.element.as=Anotar {0} ''{1}'' como ''@{2}''
inspection.implicit.subclass.display.forClass=La clase ''{0}'' podría ser subclaseada implícitamente y no debe ser final
inspection.implicit.subclass.display.name=La declaración final no se puede sobrescribir en tiempo de ejecución
inspection.implicit.subclass.extendable=Hacer que ''{0}'' sea sobrescribible
inspection.implicit.subclass.make.class.extendable=Hacer que la clase ''{0}'' {1,choice,0#sea extensible|1#y el método {2} sean extensibles|1<y los {1} métodos requeridos sean extensibles}
inspection.inconsistent.language.level.display.name=Configuraciones de nivel de lenguaje inconsistentes
inspection.infinite.loop.option=Ignorar cuando se encuentre en Thread.run
inspection.instance.guarded.by.static.display.name=Miembro de instancia protegido por un campo estático
inspection.invalid.comparator.method.reference.display.name=Referencia a método no válida para 'Comparator'
inspection.java.8.list.sort.display.name=Collections.sort()' puede reemplazarse por 'List.sort()
inspection.java.9.redundant.requires.statement.display.name=Directiva 'requires' redundante en module-info
inspection.java.module.definition=Problemas de definición de módulos Java
inspection.java.module.naming=El nombre del módulo Java contradice la convención
inspection.java.module.naming.terminal.digits=El nombre del módulo ''{0}'' no debería utilizar dígitos finales para codificar información de versión
inspection.local.can.be.final.display.name=La variable local o el parámetro pueden ser 'final'
inspection.local.can.be.final.option=Informar sobre variables locales
inspection.local.can.be.final.option1=Informar sobre los parámetros del método
inspection.local.can.be.final.option2=Informar sobre parámetros catch
inspection.local.can.be.final.option3=Informar parámetros foreach
inspection.local.can.be.final.option4=<html>Informar sobre variables que son implícitamente final<br/>(parámetros multi-catch o try-with-resources)</html>
inspection.local.can.be.final.option5=Reportar variables de patrón
inspection.message.code.generation.different.nullability.annotation.will.be.used=El código generado utilizará ''@{1}'' en lugar de ''@{0}''
inspection.message.expression.compared.to.itself.description=La expresión se compara consigo misma
inspection.message.javac.quick.intersection.type.problem=El tipo de intersección ''{0}'' no se puede instanciar porque ''{1}'' es final
inspection.message.non.annotated.method.implements.non.null.method=El método sin anotar ''{0}'' de ''{1}'' implementa un método no nulo de ''{2}''
inspection.message.non.annotated.parameter.should.not.override.non.null.parameter=El parámetro sin anotar ''{0}'' del método ''{1}'' en ''{2}'' no debe sobrescribir el parámetro no nulo de ''{3}''
inspection.message.non.null.parameter.should.not.override.non.annotated.parameter=El parámetro no nulo ''{0}'' en el método ''{1}'' de ''{2}'' no debería sobrescribir el parámetro sin anotaciones de ''{3}''
inspection.message.non.null.parameter.should.not.override.nullable.parameter=El parámetro no nulo ''{0}'' en el método ''{1}'' de ''{2}'' no debería sobrescribir el parámetro que admite nulos de ''{3}''
inspection.message.nullable.method.implements.non.null.method=El método que admite nulos ''{0}'' de ''{1}'' implementa un método que no admite nulos de ''{2}''
inspection.message.scheduled.for.removal.annotation.can.be.removed=Se puede eliminar la anotación @ScheduledForRemoval
inspection.message.scheduled.for.removal.annotation.can.be.replaced.by.attribute=La anotación @ScheduledForRemoval se puede reemplazar con el atributo 'forRemoval' en la anotación @Deprecated
inspection.module.exports.package.to.itself=Módulo exporta/abre el paquete a sí mismo
inspection.name.can.be.replaced.with.long.hashcode=Se puede utilizar el método 'hashCode()' estándar
inspection.name.redundant.scheduled.for.removal.annotation=Anotación @ScheduledForRemoval redundante
inspection.non.final.field.in.immutable.display.name=Campo no final en la clase '@Immutable'
inspection.non.final.guard.display.name=Campo '@GuardedBy' no final
inspection.nullable.problems.NotNull.parameter.overrides.Nullable=El parámetro anotado con @{0} no debe sobrescribir un parámetro @{1}
inspection.nullable.problems.NotNull.parameter.overrides.not.annotated=El parámetro anotado con @{0} no debe sobrescribir un parámetro no anotado
inspection.nullable.problems.NotNull.parameter.receives.null.literal=El parámetro anotado con @{0} no debería recibir ''null'' como argumento
inspection.nullable.problems.Nullable.NotNull.conflict=No se puede anotar con @{0} y @{1} al mismo tiempo
inspection.nullable.problems.Nullable.method.overrides.NotNull=El método anotado con @{0} no debe sobrescribir un método @{1}
inspection.nullable.problems.annotated.field.constructor.parameter.not.annotated=El parámetro del constructor para el campo @{0} podría estar anotado con @{0}
inspection.nullable.problems.annotated.field.getter.conflict=El getter del campo @{0} está anotado como @{1}
inspection.nullable.problems.annotated.field.getter.not.annotated=El getter para el campo @{0} podría estar anotado con @{0} mismo
inspection.nullable.problems.annotated.field.setter.parameter.conflict=El parámetro del setter para el campo @{0} está anotado con @{1}
inspection.nullable.problems.annotated.field.setter.parameter.not.annotated=El parámetro del setter para el campo @{0} podría anotarse con @{0} mismo
inspection.nullable.problems.applied.to.package=La anotación en el nombre totalmente cualificado debe colocarse antes del último componente
inspection.nullable.problems.at.class=La anotación de nulabilidad no es aplicable a las clases
inspection.nullable.problems.at.constructor=La anotación de nulabilidad no es aplicable a los constructores
inspection.nullable.problems.at.enum.constant=La anotación de nulabilidad no es aplicable a constantes de enumeración
inspection.nullable.problems.at.local.variable=La anotación de nulabilidad no es aplicable a variables locales
inspection.nullable.problems.at.reference.list=La anotación de nulidad no es aplicable a la cláusula extends/implements
inspection.nullable.problems.at.type.parameter=La anotación de nulabilidad no es aplicable a los parámetros de tipo
inspection.nullable.problems.at.wildcard=La anotación de nulidad no es aplicable a un tipo comodín
inspection.nullable.problems.constructor.not.compatible.non.null.type.argument=El constructor no es compatible con el argumento de tipo no nulo
inspection.nullable.problems.method.overrides.NotNull=El método no anotado sobrescribe un método anotado con @{0}
inspection.nullable.problems.nullable.instantiation.of.notnull=El parámetro de tipo no nulo ''{0}'' no se puede instanciar con el tipo @{1}
inspection.nullable.problems.nullable.instantiation.of.notnull.container=El parámetro de tipo no nulo ''{0}'' no se puede instanciar bajo @{1}
inspection.nullable.problems.outer.type=El tipo externo es intrínsecamente no nulo
inspection.nullable.problems.parameter.overrides.NotNull=El parámetro sin anotar sobrescribe al parámetro @{0}
inspection.nullable.problems.primitive.type.annotation=No se pueden anotar los miembros de tipo primitivo
inspection.nullable.problems.receiver.annotation=El parámetro receptor es inherentemente no nulo
inspection.nullable.problems.redundant.annotation.under.container=Anotación de nulabilidad redundante dentro del ámbito de @{0}
inspection.numeric.overflow.display.name=Desbordamiento numérico
inspection.objects.equals.can.be.simplified.display.name=Objects.equals()' puede reemplazarse por 'equals()
inspection.quirk.method.reference.return.type.message=El tipo de retorno del método de destino hace referencia a la clase inaccesible {0}, lo que causará un IllegalAccessError en tiempo de ejecución
inspection.redundant.cast.display.name=Conversión de tipo redundante
inspection.redundant.cast.methodref.descriptor=La conversión es redundante
inspection.redundant.cast.problem.descriptor=El casting de <code>{0}</code> a <code>#ref</code> #loc es redundante
inspection.redundant.cast.remove.quickfix=Eliminar conversión(es) redundante(s)
inspection.redundant.field.initialization.option=Solo advertir al inicializar a null
inspection.redundant.requires.statement.description=Directiva redundante ''requires {0}''.
inspection.redundant.requires.statement.fix.family=Eliminar directiva 'requires' redundante
inspection.redundant.requires.statement.fix.name=Eliminar la directiva ''requires {0}''
inspection.redundant.requires.statement.message.java.base.implicitly.required='java.base' se requiere de forma implícita.
inspection.redundant.requires.statement.message.module.unused=No se encontraron usos de los paquetes del módulo.
inspection.redundant.requires.statement.message.transitive.dependencies.on.can.be.used.directly=Las dependencias transitivas de ''{0}'' se pueden utilizar directamente.
inspection.redundant.throws.display.name=Cláusula 'throws' redundante
inspection.redundant.throws.problem.descriptor=La excepción declarada <code>#ref</code> nunca se lanza en ninguna implementación de método
inspection.redundant.throws.problem.descriptor1=La excepción declarada <code>#ref</code> nunca se lanza en este método ni en sus métodos de sobreescritura
inspection.redundant.throws.problem.descriptor2=La excepción declarada <code>#ref</code> nunca se lanza
inspection.redundant.throws.remove.quickfix=Eliminar declaraciones 'throws' innecesarias
inspection.redundant.tostring.option.notnull.qualifier=Informar solo cuando se sepa que el calificador no es null
inspection.redundant.type.display.name=Argumentos de tipo redundantes
inspection.redundant.type.no.generics.method.reference.problem.descriptor=Los argumentos de tipo son redundantes para la referencia a un método no genérico
inspection.redundant.type.no.generics.problem.descriptor=Los argumentos de tipo son redundantes para la llamada al método no genérico
inspection.redundant.type.problem.descriptor=Se pueden inferir los argumentos de tipo explícitos
inspection.redundant.type.remove.quickfix=Eliminar argumentos de tipo
inspection.reference.anonymous.class=Clase anónima
inspection.reference.anonymous.name=Anónimo ({0})
inspection.reference.default.lambda.name=Lambda
inspection.reference.default.method.reference.name=Referencia a método
inspection.reference.default.package=<predeterminado>
inspection.reference.implicit.class=Clase implícita en el archivo ''{0}''
inspection.reference.implicit.constructor.name=Constructor implícito de {0}
inspection.reference.jsp.holder.method.anonymous.name=<% contenido de la página %>
inspection.reference.lambda.name=Lambda ({0})
inspection.reference.method.reference.name=Referencia a método ({0})
inspection.requires.auto.module=Dependencias de módulos automáticos
inspection.requires.auto.module.message=Directiva 'requires' para un módulo automático
inspection.requires.auto.module.option=Resaltar solo las dependencias transitivas
inspection.requires.auto.module.transitive=Directiva 'requires transitive' para un módulo automático
inspection.safe.varargs.detector.display.name=Posible contaminación de montículo a causa de un tipo vararg parametrizado
inspection.same.return.value.display.name=El método siempre devuelve el mismo valor
inspection.same.return.value.problem.descriptor=El método <code>#ref()</code> siempre devuelve <code>{0}</code>
inspection.same.return.value.problem.descriptor1=El método <code>#ref()</code> y todos sus métodos de sobrescritura siempre devuelven <code>{0}</code>
inspection.same.return.value.problem.descriptor2=Todas las implementaciones del método <code>#ref()</code> siempre devuelven <code>{0}</code>
inspection.static.guarded.by.instance.display.name=Miembro estático protegido por un campo de instancia o this
inspection.string.tokenizer.delimiter.display.name=Delimitadores duplicados en 'StringTokenizer'
inspection.surround.requirenonnull.quickfix=Reemplazar con ''Objects.requireNonNull({0})''
inspection.suspicious.array.method.call.display.name=Llamada a método de 'Arrays' sospechosa
inspection.suspicious.array.method.call.problem.arrays=Los tipos de array son incompatibles: los arrays siempre son diferentes
inspection.suspicious.array.method.call.problem.element=El tipo de elemento no es compatible con el tipo de array
inspection.suspicious.collections.method.calls.display.name=Llamada a método de colección sospechosa
inspection.suspicious.collections.method.calls.problem.descriptor='{0}'' puede que no contenga {2} de tipo ''{1}'
inspection.suspicious.collections.method.calls.problem.descriptor1=Llamada sospechosa a ''{0}''
inspection.suspicious.getter.setter.field.option=Solo advertir cuando exista un campo que coincida con el nombre del getter/setter
inspection.suspicious.integer.div.assignment.option=Informar divisiones sospechosas pero posiblemente exactas
inspection.unary.plus.unary.binary.option=Solo informar en contextos de expresiones binarias o unarias confusas
inspection.unknown.guard.display.name=Campo '@GuardedBy' desconocido
inspection.unnecessary.super.qualifier.option=Ignorar calificador 'super' de aclaración
inspection.unreachable.catch.message=Sección inalcanzable: {1, choice, 0#la excepción|2#las excepciones} ''{0}'' {1, choice, 0#ya ha sido capturada|2#ya han sido capturadas}
inspection.unreachable.catch.name=Sección catch inalcanzable
inspection.unsatisfied.range.display.name=El valor de retorno está fuera del rango declarado
inspection.unsatisfied.range.message=El rango del valor de retorno ''{0}'' está fuera del rango declarado ''{1}''
inspection.unsatisfied.range.message.value=El valor de retorno ''{0}'' está fuera del rango declarado ''{1}''
inspection.use.compare.method.display.name=El método 'compare()' se puede usar para comparar números
inspection.use.compare.method.fix.family.name=Reemplazar con un único método de comparación
inspection.use.compare.method.option.double=Sugerir 'Double.compare()' y 'Float.compare()'
inspection.use.compare.method.turn.off.double=No sugerir los métodos Double.compare() y Float.compare()
inspection.visibility.accept.quickfix=Aceptar el nivel de acceso sugerido
inspection.visibility.compose.suggestion=Puede ser {0}
inspection.visibility.option.constants=Sugerir visibilidad más débil para las constantes
inspection.visibility.option.package.private.members=Sugerir nivel de visibilidad package-private para miembros de clase
inspection.visibility.package.private.top.level.classes=Sugerir el nivel de visibilidad package-private para las clases de nivel superior
inspection.visibility.private.inner.members=Sugerir 'private' para miembros de clases internas cuando se referencian solo desde la clase externa
inspection.weaker.access.display.name=El acceso a la declaración puede ser más restrictivo
instance.member.guarded.by.static.0.loc=Miembro de instancia protegido por el elemento static "{0}" #loc
instance.member.guarded.by.static.ref.loc=Miembro de instancia protegido por static #ref #loc
intention.add.annotation.family=Añadir anotación
intention.add.type.annotation.family=Añadir anotación de tipo
intention.family.name.move.annotation.to.array=Mover anotación al array
intention.family.name.move.annotation.to.upper.bound=Mover anotación al límite superior
intention.family.name.move.members.into.class=Mover miembros a la clase
intention.family.name.move.members.to=Mover miembros a {0}
intention.family.name.remove.new.family.name=Eliminar 'new'
intention.family.name.remove.repeating.call=Eliminar llamada repetida
intention.family.name.replace.with.expression=Reemplazar por expresión
intention.family.name.replace.with.unnamed.pattern=Reemplazar con un patrón sin nombre
intention.name.do.not.report.conditions.with.possible.side.effect=No informar condiciones con posibles efectos secundarios
intention.name.ignore.exception=Ignorar la excepción ''{0}''
intention.name.make.variable.effectively.final=Hacer que la variable sea efectivamente final
intention.name.move.members.into.class=Mover {0, choice, 1#miembro|2#miembros} a la clase
intention.name.qualify.expression=Calificar la expresión {0} con ''{1}''
intention.name.remove.repeating.call=Eliminar la llamada repetida ''{0}()''
intention.text.remove.annotation=Eliminar
make.0.default.annotation=Establecer "{0}" como anotación predeterminada
make.default.the.last.case.family.name=Hacer que 'default' sea el último case
make.final.and.annotate.as.safevarargs=Hacer final y anotar como '@SafeVarargs'
message.class.inaccessible=La clase ''{0}'' no es accesible aquí
message.class.inaccessible.from.module=La clase ''{0}'' no es accesible desde el módulo ''{1}''
method.reference.mapped.to.comparator=La referencia a método mapeada a la interfaz 'Comparator' no cumple con el contrato de 'Comparator'
missorted.imports.inspection.display.name=Importaciones mal ordenadas
module.0.with.language.level.1.depends.on.module.2.with.language.level.3=El módulo {0} con nivel de lenguaje {1} depende del módulo {2} con nivel de lenguaje {3}
module.ambiguous=Referencia de módulo ambigua: {0}
module.service.unused=Se proporciona la interfaz de servicio, pero no se exporta ni se utiliza
move.0.to.the.beginning=Mover ''{0}'' al principio
move.annotations.to.package.info.file.family.name=Mover anotaciones a 'package-info.java'
move.to.front=Mover al frente
mutability.modifiable=Modificable
mutability.must.not.modify=Parámetro de entrada que no debe modificarse
mutability.unknown=Desconocido
mutability.unmodifiable=Inmodificable
mutability.unmodifiable.view=Vista inmodificable
mutation.signature.problem.invalid.token=Token no válido: {0}; los admitidos son ''this'', ''io'', ''param1'', ''param2'', etc.
mutation.signature.problem.parameter.has.immutable.type=El parámetro #{0} tiene el tipo inmutable ''{1}''
mutation.signature.problem.reference.to.parameter.invalid=La referencia al parámetro #{0} no es válida
mutation.signature.problem.static.method.cannot.mutate.this=El método estático no puede mutar 'this'
navigate.to.overridden.methods.title=Métodos que sobrescriben {0}
non.final.field.code.ref.code.in.immutable.class.loc=Campo no final <code>#ref</code> en la clase @Immutable #loc
non.final.guarded.by.field.0.loc=Campo @GuardedBy no final "{0}" #loc
non.final.guarded.by.field.ref.loc=Campo @GuardedBy no final #ref #loc
non.null.type.argument.is.expected=Se espera un argumento de tipo no nulo
notification.content.cannot.move.file=No se puede mover ''{0}'' a ''{1}'': {2}
notification.file.system.issue=Problema de operación de archivos
nullability.non.null=No nulo
nullability.null=Nulo
nullability.nullable=anulable
nullable.stuff.error.overriding.notnull.with.nullable=Sobrescribiendo una colección de elementos no nulos con una colección de elementos que admiten nulos
nullable.stuff.error.overriding.nullable.with.notnull=Sobrescribiendo una colección de elementos que admiten valores nulos con una colección de elementos que no admiten valores nulos
nullable.stuff.problems.overridden.method.parameters.are.not.annotated=Los parámetros del método que sobrescribe no están anotados
nullable.stuff.problems.overridden.methods.are.not.annotated=Los métodos que sobrescriben no están anotados
parameter.can.be.null=El parámetro puede ser null
parameter.is.always.not.null=El parámetro siempre es no nulo
possible.heap.pollution.from.parameterized.vararg.type.loc=Posible contaminación del heap por un tipo vararg parametrizado #loc
processing.method.usages=Procesando usos de métodos…
progress.title.searching.for.overridden.methods=Buscando métodos sobrescritos
provided.type=Proporcionado
qualify.0=Calificar {0}
qualify.with.0.this=Calificar con {0}.this
reassign.variable.display.name=Variable reasignada
redundant.block.marker=Marcador de bloque redundante
remove.annotation=Eliminar anotación
remove.block.marker.comments=Eliminar comentarios de marcador de bloque
remove.dependency=Eliminar dependencia
remove.left.side.of.assignment=Eliminar el lado izquierdo de la asignación
remove.switch.branch.0=Eliminar la rama switch ''{0}''
remove.switch.label=Eliminar etiqueta switch
remove.switch.label.0=Eliminar etiqueta switch ''{0}''
replace.0.with=Reemplazar ''''{0}'''' por ''''=''''
replace.anonymous.class.with.lambda.alternative=Reemplazar clase anónima por alternativa lambda
replace.get.class.with.class.literal=Reemplazar getClass() con el literal .class
replace.operator.assignment.with.assignment=Reemplazar asignación con operador por asignación
replace.stringtokenizer.delimiters.parameter.with.unique.symbols=Eliminar duplicados del argumento 'delimiters'
replace.var.with.explicit.type=Reemplazar 'var' por el tipo explícito
replace.with.0=Reemplazar con {0}
replace.with.boolean.equals=Reemplazar con Boolean.equals
replace.with.comparator=Reemplazar con comparador
replace.with.constant.value=Reemplazar por valor constante
replace.with.constant.value.title=Reemplazar por un valor constante
replace.with.expression.lambda=Reemplazar con expresión lambda
replace.with.lambda=Reemplazar con lambda
replace.with.stream.api.fix=Colapsar bucle con el stream ''{0}()''
report.suspicious.but.possibly.correct.method.calls=&Informar de llamadas a métodos sospechosas pero posiblemente correctas
report.when.interface.is.not.annotated.with.functional.interface=Informar cuando la interfaz no esté anotada con @FunctionalInterface
required.type=Tipo requerido
safe.varargs.not.suppress.potentially.unsafe.operations=@SafeVarargs no suprime las operaciones potencialmente inseguras
safe.varargs.on.reifiable.type=@SafeVarargs no es aplicable a tipos reificables
scope.package=Paquete {0}
searching.for.overriding.methods=Buscando métodos de sobreescritura
service.click.to.navigate=Haga clic para navegar
service.provides=Proporciona servicio
service.uses=Utiliza el servicio
special.field.array.length=Longitud del array
special.field.collection.size=Tamaño
special.field.consumed.stream=Flujo vinculado o consumido
special.field.enum.ordinal=Ordinal de enumeración
special.field.instantiable.class=Clase instanciable
special.field.optional.value=Valor opcional
special.field.string.length=Longitud de cadena
special.field.unboxed.value=Valor desempaquetado
statement.lambda.can.be.replaced.with.expression.lambda=La lambda de sentencia puede reemplazarse por una lambda de expresión
static.inheritrance.fix.replace.progress=Reemplazando usos de {0}
static.member.guarded.by.instance.0.loc=Miembro estático protegido por la instancia "{0}" #loc
static.member.guarded.by.instance.ref.loc=Miembro estático protegido por la instancia #ref #loc
subclasses.search.progress.title=Buscando métodos sobrescritos
suggest.package.private.visibility.level.for.classes.in.exported.packages.java.9=Sugerir nivel de visibilidad package-private para clases en paquetes exportados (Java 9+)
suppress.all.for.class=Suprimir todas las inspecciones para la clase
suppress.for.parameter=Suprimir para el parámetro
suppress.for.statement.with.comment=Suprimir para la sentencia con comentario
suppress.inspection.class=Suprimir para la clase
suppress.inspection.field=Suprimir para el campo
suppress.inspection.member=Suprimir para el miembro
suppress.inspection.method=Suprimir para el método
suppress.inspection.module=Suprimir para la declaración del módulo
suspected.module.dependency.problem.descriptor=El módulo ''{0}'' no depende del módulo ''{1}''. Sin embargo, no se inspeccionó ''{1}'' en busca de las dependencias exportadas necesarias para el alcance ''{2}''
suspicious.invocation.handler.implementation.display.name=Implementación de 'InvocationHandler' sospechosa
suspicious.invocation.handler.implementation.method.unused.message=El método nunca se utiliza en 'invoke()': es poco probable que 'hashCode()', 'equals()' y 'toString()' estén implementados correctamente
suspicious.invocation.handler.implementation.null.returned.for.toString.message=Es posible que se devuelva null al crear un proxy del método 'toString()': esto no se recomienda
suspicious.invocation.handler.implementation.null.returned.message=Se podría devolver null al realizar el proxy del método ''{0}()'': esto puede causar una NullPointerException
suspicious.invocation.handler.implementation.type.mismatch.message=Es posible que se devuelva un tipo incompatible al crear el proxy del método ''{0}()'': requerido: {1}; obtenido: {2}
text.raw.ctor.reference.with.type.parameters=Referencia a constructor raw con parámetros de tipo explícitos para el constructor
text.shebang.mechanism.in.java.files.not.permitted=El mecanismo Shebang en archivos .java no está permitido
text.unused.import.in.template=Importación no utilizada (especificada en la plantilla)
type.constraint.assignability.explanation.definitely.inconvertible=Se sabe que {0} es {1}, lo cual es definitivamente incompatible con {2}
type.constraint.assignability.explanation.exact=Ya se sabe que {0} es {1}
type.constraint.assignability.explanation.exact.not.subtype=El tipo de {0} es exactamente {1}, que no es un subtipo de {2}
type.constraint.assignability.explanation.exact.subtype=El tipo de {0} es exactamente {1}, que es un subtipo de {2}
type.constraint.assignability.explanation.not.instance.of=Se sabe que {0} no es {1}
type.constraint.assignability.explanation.not.instance.of.supertype=Se sabe que {0} no es {1}, el cual es un supertipo de {2}
type.constraint.assignability.explanation.subtype.of.subtype=Ya se sabe que {0} es {1}, el cual es un subtipo de {2}
type.mismatch.reason=Razón: {0}
uast.language.display.name=Lenguajes JVM
unknown.guardedby.reference.0.loc=Referencia @GuardedBy desconocida "{0}" #loc
unknown.guardedby.reference.ref.loc=Referencia @GuardedBy desconocida #ref #loc
unnecessary.module.dependency.display.name=Dependencia de módulo innecesaria
unnecessary.module.dependency.problem.descriptor=Las fuentes del módulo ''{0}'' no dependen de las fuentes del módulo ''{1}''
unused.import.display.name=Importación no utilizada
unused.import.statement=Sentencia de importación no utilizada
unused.library.display.name=Biblioteca no utilizada
unused.library.problem.descriptor=Biblioteca no utilizada ''{0}''
unused.library.roots.problem.descriptor=Raíces {0} no utilizadas de la biblioteca ''{1}''
var.can.be.replaced.with.explicit.type='var' se puede reemplazar por un tipo explícito
vararg.method.call.with.50.poly.arguments=La llamada a un método vararg con más de 50 argumentos poly puede ralentizar la compilación y el análisis
