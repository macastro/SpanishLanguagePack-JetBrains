DFAStrings.CppDFAArrayIndexOutOfBoundsDescription=Informa sobre expresiones de acceso a variables de puntero o matriz en las que el índice puede estar fuera de los límites de una matriz o de un búfer asignado
DFAStrings.CppDFAArrayIndexOutOfBoundsTitle=Expresiones de acceso a arrays donde el índice puede estar fuera de los límites
DFAStrings.CppDFAConstantConditionsDescription=Informa sobre condiciones que siempre son true o false y expresiones cuyo valor se ha demostrado estáticamente que es constante
DFAStrings.CppDFAConstantConditionsTitle=Condiciones que siempre son true o false
DFAStrings.CppDFAConstantFunctionResultDescription=Informa sobre las funciones cuyo valor de retorno es siempre la misma constante
DFAStrings.CppDFAConstantFunctionResultTitle=Funciones cuyo valor de retorno es siempre la misma constante
DFAStrings.CppDFAConstantParameterDescription=Informa sobre los parámetros de función que siempre tienen el mismo valor
DFAStrings.CppDFAConstantParameterTitle=Parámetros de función que siempre tienen el mismo valor
DFAStrings.CppDFADeletedPointerDescription=Informa sobre los usos de punteros que hacen referencia a memoria ya eliminada mediante el operador delete o la función free(void* ptr)
DFAStrings.CppDFADeletedPointerTitle=Usos de punteros que hacen referencia a memoria eliminada
DFAStrings.CppDFAEndlessLoopDescription=Informa sobre sentencias 'for', 'while', 'do-while' y 'goto' que solo finalizan lanzando una excepción
DFAStrings.CppDFAEndlessLoopTitle=Sentencias de bucle infinito
DFAStrings.CppDFAInfiniteRecursionDescription=Informa sobre funciones que se llaman a sí mismas infinitamente a menos que se lance una excepción
DFAStrings.CppDFAInfiniteRecursionTitle=Funciones que se llaman a sí mismas infinitamente
DFAStrings.CppDFAInvalidatedMemoryDescription=Informa sobre referencias al contenido de contenedores invalidados
DFAStrings.CppDFAInvalidatedMemoryTitle=Referencias al contenido de contenedores invalidados
DFAStrings.CppDFALocalValueEscapesFunctionDescription=Informa sobre las referencias a valores locales que escapan de la función a través de retornos, asignaciones a variables globales o campos
DFAStrings.CppDFALocalValueEscapesFunctionTitle=Referencias a valores locales que escapan de la función
DFAStrings.CppDFALocalValueEscapesScopeDescription=Informa sobre variables con referencias a variables locales que escapan de su ámbito
DFAStrings.CppDFALocalValueEscapesScopeTitle=Referencias a variables locales que escapan de su ámbito
DFAStrings.CppDFALoopConditionNotUpdatedDescription=Informa sobre las condiciones de bucle que no se actualizan dentro del bucle
DFAStrings.CppDFALoopConditionNotUpdatedTitle=Condiciones de bucle que no se actualizan dentro del bucle
DFAStrings.CppDFAMemoryLeakDescription=Informa sobre las asignaciones de memoria (realizadas con 'new' o 'malloc()') que no se liberaron antes de dejar de ser accesibles
DFAStrings.CppDFAMemoryLeakTitle=Asignaciones de memoria que no fueron liberadas
DFAStrings.CppDFANotInitializedFieldDescription=Informa sobre los campos que podrían no haber sido inicializados antes de ser utilizados. La inicialización y el uso pueden ocurrir en funciones diferentes.
DFAStrings.CppDFANotInitializedFieldTitle=Campos que podrían no haber sido inicializados antes de su uso
DFAStrings.CppDFANullDereferenceDescription=Informa sobre desreferencias de punteros que pueden contener nullptr
DFAStrings.CppDFANullDereferenceTitle=Desreferenciación de punteros que pueden contener nullptr
DFAStrings.CppDFATimeOverDescription=La inspección de flujo de datos ha alcanzado el límite de tiempo o memoria y no se puede evaluar ni en modo sensible al contexto ni en modo independiente del contexto
DFAStrings.CppDFATimeOverTitle=La inspección de flujo de datos ha agotado el tiempo de espera
DFAStrings.CppDFAUnreachableCodeDescription=Informa sobre fragmentos de código que nunca se ejecutan en ningún flujo de control y que pueden eliminarse de forma segura.
DFAStrings.CppDFAUnreachableCodeTitle=Código inalcanzable
DFAStrings.CppDFAUnreachableFunctionCallDescription=Informa sobre funciones cuyas llamadas no se utilizan nunca. Dichas funciones tampoco se ejecutan nunca.
DFAStrings.CppDFAUnreachableFunctionCallTitle=Funciones cuyas llamadas nunca se utilizan
DFAStrings.CppDFAUnreadVariableDescription=Informa sobre las variables locales que se declaran pero a las que nunca se accede para lectura
DFAStrings.CppDFAUnreadVariableTitle=Variables locales declaradas pero a las que nunca se accede para lectura
DFAStrings.CppDFAUnusedValueDescription=Informa sobre los valores de las variables que nunca se utilizan tras su asignación
DFAStrings.CppDFAUnusedValueTitle=Valores de variables que no se utilizan tras su asignación
Strings.AClassDefinitionCanBeMarkedAsFinalSoItCannotBeInheritedFrom=Una definición de clase se puede marcar como final para que no se pueda heredar de ella
Strings.AClassIsNeverUsed=No se utiliza nunca una clase
Strings.ACoroutineRelatedFunctionWhichIsRequiredByTheCStandardCannotBeResolved=No se puede resolver una función relacionada con las corrutinas requerida por el estándar C++20
Strings.ADeclarationDoesNotDeclareAnything=Una declaración no declara nada
Strings.ADeclarationSpecifierIsIgnoredWhenThereAreNoDeclarators=Un especificador de declaración se ignora cuando no hay declaradores
Strings.ADeclaratorIsNeverUsed=Un declarador no se utiliza nunca
Strings.ADeclaratorIsOnlyAssignedButNeverAccessed=Un declarador solo se asigna, pero nunca se accede a él
Strings.ADeclaratorIsUsedOnlyInUnevaluatedContext=Un declarador se usa solo en un contexto no evaluado
Strings.AEnumeratorIsNeverUsed=Un enumerador nunca se utiliza
Strings.AFormatStringOfBoostFormatContainsALegacyPrintfLikeCodeTypeSpecifierIsNotTakenIntoAccount=Una cadena de formato de boost::format contiene código heredado de tipo printf; el especificador de tipo no se tiene en cuenta
Strings.AFormatStringOfBoostFormatContainsAnErroneousFormatCode=Una cadena de formato de boost::format contiene una directiva de formato errónea
Strings.AFunctionDefinitionInAHeaderFileThatWillCauseMultipleDefinitionLinkageError=Una definición de función en un archivo de cabecera que provocará un error de enlace de definición múltiple
Strings.AFunctionIsNotImplemented=Una función no está implementada
Strings.AFunctionOrALambdaWithNonVoidReturnTypeShouldReturnAValue=Una función o lambda con un tipo de retorno distinto de void debe devolver un valor
Strings.AFunctionOrALambdaWithNonVoidReturnTypeShouldReturnAValue8=Una función o una lambda con un tipo de retorno que no sea void debe devolver un valor
Strings.ALambdaCaptureIsNeverUsed=Una captura de lambda nunca se utiliza
Strings.ALocalDeclarationHidesAnotherLocalDeclaration=Una declaración local oculta otra declaración local
Strings.ALocalDeclarationInsideALambdaHidesAnUncapturedLocalDeclaration=Una declaración local dentro de una lambda oculta una declaración local no capturada
Strings.ALocalVariableMightNotBeInitialized=Es posible que una variable local no se haya inicializado
Strings.ANonOverridingVirtualFunctionInAFinalOrSealedClassCannotBeOverriddenSoThevirtualSpecifierIsRedundant=Una función virtual que no sobrescribe en una clase final o sellada no se puede sobrescribir, por lo que el especificador 'virtual' es redundante
Strings.ANumericTypeCanBeReplacedWithauto=Un tipo numérico puede reemplazarse por 'auto'
Strings.APolymorphicClassWithANonVirtualPublicDestructor=Una clase polimórfica con un destructor público no virtual
Strings.APrivateSpecialMemberFunctionShouldBeDefinedOrDeleted=Una función miembro especial privada debe definirse o eliminarse
Strings.AStandardAlgorithmAcceptingRangeIteratorsIsUsedInsteadOfTheVariantAcceptingAnIteratorAndACount=Se utiliza un algoritmo estándar que acepta iteradores de rango en lugar de la variante que acepta un iterador y un recuento
Strings.ATemplateParameterFromAnOuterScopeIsShadowedByADeclarationWithTheSameName=Un parámetro de plantilla de un ámbito externo está ocultado por una declaración con el mismo nombre
Strings.ATypeAliasIsNeverUsed=No se utiliza nunca un alias de tipo
Strings.ATypeTraitCanBeSimplifiedUsingATemplateAliasOrAVariableTemplate=Un rasgo de tipo se puede simplificar mediante un alias de plantilla o una plantilla de variable
Strings.AVariableDefinitionInAHeaderFileThatWillCauseMultipleDefinitionLinkageError=Definición de variable en un archivo de cabecera que provocará un error de enlace por definición múltiple
Strings.AVirtualFunctionIsMarkedfinalAndDoesNotOverrideABaseFunction=Una función virtual está marcada como 'final' y no sobrescribe una función base
Strings.AbstractFinalClass=Clase final abstracta
Strings.AccessSpecifierDoesNotAffectAnyDeclaration=El especificador de acceso no afecta a ninguna declaración
Strings.AccessSpecifierDoesNotChangeAccessibilityLevel=El especificador de acceso no cambia el nivel de accesibilidad
Strings.AddingCvQualifiersToReferencesHasNoEffect=Agregar calificadores cv a las referencias no tiene efecto
Strings.AddingCvQualifiersToReferencesHasNoEffect9=Añadir calificadores cv a las referencias no tiene efecto
Strings.AlgorithmAcceptingAnIteratorAndACountCanBeUsed=Se puede utilizar un algoritmo que acepte un iterador y un recuento
Strings.AlgorithmAcceptingIteratorsIsUsedInsteadOfTheCorrespondingAlgorithmFromStdRanges=Se utiliza un algoritmo que acepta iteradores en lugar del algoritmo correspondiente de std::ranges
Strings.AlgorithmOperatingOnRangesCanBeUsed=Se puede utilizar un algoritmo que opera sobre rangos
Strings.AnAbstractFinalClassIsMarkedAsfinalOrsealed=Una clase abstracta final está marcada como 'final' o 'sealed'
Strings.AnAccessSpecifierDoesNotAffectAnyDeclarationAndIsRedundant=Un especificador de acceso no afecta a ninguna declaración y es redundante
Strings.AnAccessSpecifierDoesNotChangeAccessibilityLevelAndIsRedundant=Un especificador de acceso no cambia el nivel de accesibilidad y es redundante
Strings.AnArgumentOfBoostFormatShouldContainEitherPositionalNNOrSerialsArgumentsNotBoth=Un argumento de boost::format debe contener argumentos posicionales (%N%, %|N$…|) o secuenciales (%|…|, %s), pero no ambos
Strings.AnIncompleteTypeIsUsedInsideATemplateDeclarationOrDefinition=Se utiliza un tipo incompleto dentro de una declaración o definición de plantilla
Strings.AnObjectMemberMightNotBeInitialized=Es posible que un miembro del objeto no esté inicializado
Strings.AnOverrideFunctionRedefinesADefaultParameterArgumentPreviouslyDefinedInABaseFunction=Una función de invalidación redefine un argumento de parámetro predeterminado definido previamente en una función base
Strings.AwaiterTypeIsNotAClass=El tipo de awaiter no es una clase
Strings.BackslashAndNewlineAreSeparatedBySpace=La barra invertida y el salto de línea están separados por un espacio
Strings.BackslashIsNotALineContinuatorBecauseThereIsASpaceBetweenItAndTheEndOfTheLine=La barra invertida no es un continuador de línea porque hay un espacio entre ella y el final de la línea
Strings.BadFormatCodeForBoostFormat=Directiva de formato incorrecta en boost::format
Strings.BinaryOperatorActsOnEqualOperands=El operador binario actúa sobre operandos iguales
Strings.BinaryOperatorActsOnEqualOperands40=El operador binario actúa sobre operandos iguales
Strings.BinaryOperatorActsOnIdenticalOperands=El operador binario actúa sobre operandos idénticos
Strings.BinaryOperatorActsOnIdenticalOperands39=El operador binario actúa sobre operandos idénticos
Strings.BindingRValueToLValueReferenceIsNonStandardMicrosoftCExtension=Vincular un r-value a una referencia de l-value es una extensión de Microsoft C++ no estándar
Strings.BindingRValueToLValueReferenceIsNonStandardMicrosoftCExtension2=Vincular un r-value a una referencia de l-value es una extensión de Microsoft C++ no estándar
Strings.BracesCanBeSafelyRemovedWithoutChangingCodeSemantics=Las llaves pueden eliminarse de forma segura sin cambiar la semántica del código
Strings.CStyleCastIsUsedInsteadOfACCast=Se utiliza una conversión de estilo C en lugar de una conversión de C++
Strings.CStyleCastIsUsedInsteadOfACCast1=Se utiliza una conversión de estilo C en lugar de una conversión de C++
Strings.CallOfDeletedCopyConstructorElidedDuringCopyInitializationThisIsNonStandardMicrosoftCExtension=La llamada al constructor de copia eliminado se ha omitido durante la inicialización por copia. Esta es una extensión de Microsoft C++ no estándar.
Strings.CallOfDeletedCopyConstructorElidedDuringCopyInitializationThisIsNonStandardMicrosoftCExtension5=Llamada al constructor de copia eliminado omitida durante la inicialización de copia. Esta es una extensión de Microsoft C++ no estándar.
Strings.CallToAVirtualFunctionInsideAConstructorDestructorIsResolvedAtCompileTime=La llamada a una función virtual dentro de un constructor/destructor se resuelve en tiempo de compilación
Strings.CallToAVirtualFunctionInsideAConstructorDestructorWillResultInAPureVirtualFunctionCall=La llamada a una función virtual dentro de un constructor/destructor resultará en una llamada a una función virtual pura
Strings.CallsToPureVirtualFunctionsInsideConstructorsAndDestructorsAreARuntimeError=Las llamadas a funciones virtuales puras dentro de constructores y destructores provocarán errores de tiempo de ejecución
Strings.CannotResolveARequiredCoroutineFunction=No se puede resolver una función de corrutina requerida
Strings.CastIsRedundantAndCanBeDeleted=La conversión es redundante y puede eliminarse
Strings.CastingFromNullptrToPointerTypeWithReinterpretCastIsNonStandardMicrosoftCExtension=La conversión de nullptr a un tipo de puntero con reinterpret_cast es una extensión de Microsoft C++ no estándar
Strings.CastingFromNullptrToPointerTypeWithReinterpretCastIsNonStandardMicrosoftCExtension1=La conversión de nullptr a un tipo de puntero con reinterpret_cast es una extensión de Microsoft C++ no estándar
Strings.ClassCanBeMadeFinal=La clase puede ser final
Strings.ClassConstructorDoesntInitializeAFieldExplicitlyOrImplicitly=El constructor de la clase no inicializa un campo de forma explícita o implícita
Strings.ClassIsAbstractButNotExplicitlyDeclaredAsSuch=La clase es abstracta pero no se ha declarado explícitamente como tal
Strings.ClassIsNeverUsed=La clase nunca se utiliza
Strings.ClassMemberFunctionHidesANonVirtualFunctionFromABaseClass=La función miembro de clase oculta una función no virtual de una clase base
Strings.ClassMemberFunctionHidingANonVirtualFunctionFromABaseClass=Función miembro de clase que oculta una función no virtual de una clase base
Strings.ClassShouldHaveAUserDefinedConstructorBecauseOfAnUninitializedDataMember=La clase debería tener un constructor definido por el usuario debido a un miembro de datos no inicializado.
Strings.ClassShouldHaveAUserDefinedConstructorBecauseOfAnUninitializedDataMember25=La clase debe tener un constructor definido por el usuario debido a un miembro de datos no inicializado
Strings.ComparisonOfUnsignedExpressionWith=Comparación de una expresión sin signo con 0
Strings.ComparisonOfUnsignedExpressionWith41=Comparación de una expresión sin signo con 0
Strings.CompileTimeConstantExpressionCanBeReplacedByEithertrueOrfalse=La expresión constante en tiempo de compilación puede reemplazarse por 'true' o 'false'
Strings.CompileTimeIntegralConstantExpressionOrNullptrIsConvertedToBoolAndCanBeReplacedBytrueOrfalse=La expresión constante entera en tiempo de compilación o nullptr se convierte a bool y puede reemplazarse por 'true' o 'false'
Strings.ConceptIsNeverUsed=El concepto nunca se utiliza
Strings.ConstQualificationOfParametersHasAnEffectOnlyInFunctionDefinitions=La calificación const de los parámetros solo tiene efecto en las definiciones de funciones
Strings.ConstQualifiedParameterInAFunctionDeclaration=Parámetro calificado como const en una declaración de función
Strings.ConstevalIfIsAlwaysConstantDescription=Consteval if siempre es constante
Strings.ConstevalIfIsAlwaysConstantTitle=Consteval if siempre es constante
Strings.ConstructorOfASmartPointerBoostStdSharedPtrUniquePtrIsUsedInsteadOfTheCorrespondingMakeSharedMakeUniqueMakeFunctionsAreExceptionSafeAndMoreEfficient=Se utiliza el constructor de un puntero inteligente (boost/std::shared_ptr/unique_ptr) en lugar del make_shared/make_unique correspondiente. Las funciones make son seguras frente a excepciones y más eficientes.
Strings.ConstructorOfSmartPointerIsUsedInsteadOfItsMakeFunction=Se utiliza el constructor del puntero inteligente en lugar de su función make
Strings.CppConditionalExpressionCanBeSimplifiedDescription=La expresión condicional se puede simplificar
Strings.CppConditionalExpressionCanBeSimplifiedTitle=Se puede simplificar la expresión condicional
Strings.CppEvaluationFailureDescription=El valor de la expresión o del declarador no se evaluó como una constante debido a un error durante los cálculos de 'constexpr'.
Strings.CppEvaluationFailureTitle=Fallo de evaluación en tiempo de compilación
Strings.CppEvaluationInternalFailureTitle=[INTERNAL] Fallo de evaluación en tiempo de compilación
Strings.CppRedundantComplexityInComparison=La expresión puede simplificarse
Strings.CppRedundantConditionalExpressionDescription=Expresión condicional redundante
Strings.CppRedundantConditionalExpressionTitle=Expresión condicional redundante
Strings.CppRedundantDereferencingAndTakingAddressDescription=Desreferenciación y obtención de dirección redundantes
Strings.CppRedundantDereferencingAndTakingAddressTitle=Desreferenciación y obtención de dirección redundantes
Strings.DeclarationAndAssignmentCanBeJoined=La declaración y la asignación se pueden combinar
Strings.DeclarationDoesNotDeclareAnything=La declaración no declara nada
Strings.DeclarationOfANonOverridingVirtualFunctionInAFinalOrSealedClass=Declaración de una función virtual que no sobrescribe en una clase final o sellada
Strings.DeclarationOfAVariableAndAssignmentToItCanBeJoined=La declaración de una variable y su asignación pueden combinarse
Strings.DeclarationSpecifierWithNoDeclarators=Especificador de declaración sin declaradores
Strings.DeclarationSpecifierlongCanNotBeCombinedWithfloat=El especificador de declaración 'long' no se puede combinar con 'float'
Strings.DeclaratorDisambiguatedAsAFunctionDeclaration=Declarador desambiguado como declaración de función
Strings.DeclaratorIsDisambiguatedAsAFunctionDeclarationMakeSureAVariableDefinitionIsNotIntendedInstead=El declarador se desambigua como una declaración de función. Asegúrese de que no se pretendía una definición de variable en su lugar.
Strings.DeclaratorIsNeverUsed=El declarador nunca se utiliza
Strings.DeclaratorIsOnlyAssignedButNeverAccessed=El declarador solo se asigna pero nunca se accede a él
Strings.DeclaratorIsUsedOnlyInUnevaluatedContext=El declarador se usa solo en un contexto no evaluado
Strings.DefaultCaseIsNotHandledInASwitchStatement=El caso por defecto no se maneja en una sentencia switch
Strings.DefaultCaseIsNotHandledInASwitchStatement20=El caso predeterminado no se maneja en una sentencia switch
Strings.DefaultInitializationOfAConstQualifiedObjectOfATypeWithoutAUserProvidedDefaultConstructor=Inicialización predeterminada de un objeto con calificación const de un tipo sin un constructor predeterminado proporcionado por el usuario
Strings.DefaultInitializationOfAConstQualifiedObjectOfATypeWithoutAUserProvidedDefaultConstructor3=Inicialización predeterminada de un objeto calificado como const de un tipo sin un constructor predeterminado proporcionado por el usuario
Strings.DefaultedSpecialMemberFunctionIsImplicitlyDeleted=La función miembro especial predeterminada se elimina implícitamente
Strings.DeletingAVoidPointer=Eliminación de un puntero void
Strings.DeletingAVoidPointerIsUndefinedBehavior=Eliminar un puntero void es un comportamiento indefinido
Strings.DependentTemplateWithouttemplateKeyword=Plantilla dependiente sin la palabra clave 'template'
Strings.DependentTemplateWithouttemplateKeyword24=Plantilla dependiente sin la palabra clave 'template'
Strings.DependentTypeWithouttypenameKeyword=Tipo dependiente sin la palabra clave 'typename'
Strings.DependentTypeWithouttypenameKeyword23=Tipo dependiente sin la palabra clave 'typename'
Strings.DeprecatedregisterStorageClassSpecifier=Especificador de clase de almacenamiento 'register' en desuso
Strings.DereferenceOperatorLimitIsExceeded=Se ha superado el límite del operador de desreferenciación
Strings.DereferenceOperatorLimitIsExceeded10=Se ha excedido el límite del operador de desreferencia
Strings.DetectsLeakProneResourceAcquisitionFreeingConstructs=Detecta constructos de adquisición/liberación de recursos propensos a fugas
Strings.DontIntroduceANamespaceDefinitionOnlyForClassSpecializationSpecializationCanBeDefinedUsingQualifiedClassName=No introduzca una definición de espacio de nombres solo para la especialización de clases; la especialización se puede definir mediante el nombre de clase cualificado
Strings.DontIntroduceAVariableBeforeYouNeedToUseIt=No introduzca una variable antes de que necesite usarla
Strings.ElaboratedTypeSpecifierIsRedundantAndCanBeDeleted=El especificador de tipo elaborado es redundante y puede eliminarse
Strings.EmptyParameterListInLambdaDeclaratorCanBeDeleted=Se puede eliminar la lista de parámetros vacía en el declarador lambda
Strings.EnforceBracesIndoWhileStatement=Exigir llaves en la sentencia 'do-while'
Strings.EnforceBracesInforStatement=Obligar el uso de llaves en la sentencia 'for'
Strings.EnforceBracesInifStatement=Forzar el uso de llaves en la sentencia 'if'
Strings.EnforceBracesInwhileStatement=Obligar el uso de llaves en la sentencia 'while'
Strings.EnforceFunctionDeclarationStyle=Forzar el estilo de declaración de funciones
Strings.EnforceNestedNamespacesStyle=Forzar el estilo de espacios de nombres anidados
Strings.EnforceOverridingDestructorStyle=Forzar el estilo de sobrescritura de destructores
Strings.EnforceOverridingFunctionStyle=Forzar el estilo de las funciones de sobrescritura
Strings.EnforceTheOrderOfCvQualifiers=Forzar el orden de los calificadores cv
Strings.EnforceTheOrderOfCvQualifiers_Description=Forzar el orden de los calificadores cv
Strings.EnforceThePlacementOfCvQualifiers=Forzar la colocación de los calificadores cv
Strings.EnforceThePlacementOfCvQualifiers_Description=Forzar la ubicación de los calificadores cv
Strings.EnforceTheSyntaxUsedToDefineNestedNamespaces=Exigir la sintaxis utilizada para definir espacios de nombres anidados
Strings.EnforceThevirtualAndoverrideSpecifiersOnOverridingDestructors=Exigir los especificadores 'virtual' y 'override' en los destructores que sobrescriben
Strings.EnforceThevirtualAndoverrideSpecifiersOnOverridingFunctions=Exigir los especificadores 'virtual' y 'override' en las funciones de invalidación
Strings.EnforceTypeAliasCodeStyle=Hacer cumplir el estilo de código de alias de tipo
Strings.EnforceUsageOfTheTrailingReturnTypeOrTheRegularReturnTypeSyntax=Obligar al uso de la sintaxis del tipo de retorno final o del tipo de retorno regular
Strings.EnforceUsageOfTypedefsOrTypeAliasesDependingOnTheSyntaxStyleSetting=Exigir el uso de typedefs o alias de tipo según la configuración del estilo de sintaxis
Strings.EntityIsDeprecated=La entidad está en desuso
Strings.EntityIsDeprecated37=La entidad está obsoleta
Strings.EnumeratorIsNeverUsed=El enumerador nunca se usa
Strings.ExplicitSpecializationInNonNamespaceScope=Especialización explícita en un ámbito que no es un espacio de nombres
Strings.ExplicitSpecializationsOfATemplateInNonNamespaceScope=Especializaciones explícitas de una plantilla en un ámbito que no es de espacio de nombres
Strings.ExplicitlyDefaultedSpecialMemberFunctionIsImplicitlyDeleted=La función miembro especial explícitamente predeterminada se elimina implícitamente
Strings.ExpressionWhichEvaluatesToZeroIsUsedAsANullPointerConstant=Una expresión que se evalúa como cero se utiliza como constante de puntero nulo
Strings.ExpressionWhichEvaluatesToZeroIsUsedAsANullPointerConstant27=La expresión que se evalúa como cero se utiliza como constante de puntero nulo
Strings.FinalFunctionInAFinalClass=Función final en una clase final
Strings.FinalNonOverridingVirtualFunction=Función virtual final que no sobreescribe
Strings.ForExampleWhenIteratingOnKeyValuePairsStdViewsKeysAllowsToIgnoreTheValues=Por ejemplo, al iterar sobre pares clave-valor, std::views::keys permite ignorar los valores.
Strings.ForLoopCanBeReplacedWithWhileLoop=El bucle for se puede reemplazar por un bucle while
Strings.ForLoopWithoutInitStatementAndUpdateExpressionIsEquivalentToWhileLoop=Un bucle for sin sentencia de inicialización ni expresión de actualización es equivalente a un bucle while
Strings.FormatStringContainsAPotentialError=La cadena de formato contiene un error potencial
Strings.FormatStringContainsAnInvalidPrintfFormatSpecifier=La cadena de formato contiene un especificador de formato printf no válido
Strings.ForwardEnumDeclarationWithoutUnderlyingTypeDescription=ISO C++ prohíbe las declaraciones anticipadas de una enumeración sin un tipo subyacente
Strings.ForwardEnumDeclarationWithoutUnderlyingTypeTitle=Declaración adelantada de enumeración sin tipo subyacente
Strings.FunctionIsNotImplemented=Función no implementada
Strings.FunctionParameterIsNeverUsed=El parámetro de la función nunca se utiliza
Strings.FunctionResultShouldBeUsedDescription=La función devuelve un valor de un tipo que debe manejarse en el lugar de la llamada
Strings.FunctionResultShouldBeUsedTitle=Se debe usar el resultado de la función
Strings.FunctionReturnsByConstValue=La función devuelve por valor const
Strings.FunctionalStyleCastIsUsedInsteadOfACCast=Se utiliza una conversión de estilo funcional en lugar de una conversión de C++
Strings.FunctionalStyleCastIsUsedInsteadOfACCast2=Se utiliza una conversión de estilo funcional en lugar de una conversión de C++
Strings.GuardedHeaderHasAlreadyBeenIncluded=El encabezado protegido ya ha sido incluido
Strings.GuardedHeaderHasAlreadyBeenIncluded50=El encabezado con guarda ya se ha incluido
Strings.HidingAnUncapturedLocalDeclaration=Ocultando una declaración local no capturada
Strings.HidingLocalDeclaration=Ocultando declaración local
Strings.IfStatementWithConstantConditionCanBeReplacedByifConstexpr=La sentencia 'if' con una condición constante puede reemplazarse por 'if constexpr'
Strings.IfStatementWithConstantConditionCanBeReplacedByifConstexpr14=La sentencia 'if' con condición constante se puede reemplazar por 'if constexpr'
Strings.IfStdIsConstantEvaluatedCanBeReplacedDescription=If' se puede reemplazar por 'if consteval
Strings.IfStdIsConstantEvaluatedCanBeReplacedTitle=If' se puede reemplazar por 'if consteval
Strings.ImplicitConversionToIncompatiblePointerType=Conversión implícita a un tipo de puntero incompatible
Strings.ImplicitConversionToIncompatiblePointerType32=Conversión implícita a un tipo de puntero incompatible
Strings.ImplicitConversionToLessQualifiedPointerType=Conversión implícita a tipo puntero con pérdida de calificadores
Strings.ImplicitConversionToLessQualifiedPointerType33=Conversión implícita a un tipo puntero con pérdida de calificadores
Strings.ImplicitDefaultConstructorIsNotAvailable=El constructor predeterminado implícito no está disponible
Strings.ImplicitDefaultConstructorIsNotAvailableBecauseABaseClassOrAClassMemberDoesNotHaveAnAccessibleDefaultConstructor=El constructor predeterminado implícito no está disponible porque una clase base o un miembro de clase no tiene un constructor predeterminado accesible.
Strings.ImplicitIntegerToPointerConversion=Conversión implícita de entero a puntero
Strings.ImplicitIntegerToPointerConversion30=Conversión implícita de entero a puntero
Strings.ImplicitPointerToIntegerConversion=Conversión implícita de puntero a entero
Strings.ImplicitPointerToIntegerConversion31=Conversión implícita de puntero a entero
Strings.InHLSLoutParametersMustBeAssignedBeforeExitingTheFunction=En HLSL, los parámetros 'out' deben ser asignados antes de salir de la función.
Strings.IncludeGuardIsNotFoundAtTheBeginningOfAHeaderFile=No se encuentra la guarda de inclusión al principio de un archivo de cabecera
Strings.InconsistentNaming_Description=El nombre no coincide con el estilo de nomenclatura definido para este tipo de símbolo
Strings.InconsistentNaming_Text=Nomenclatura inconsistente
Strings.IncorrectSpacing=Espaciado incorrecto
Strings.IncrementingExpressionOfTypeBool=Expresión de incremento de tipo bool
Strings.IncrementingExpressionOfTypeBoolIsDeprecatedInCAndRemovedInC=La expresión de incremento de tipo bool está en desuso en C++11 y ha sido eliminada en C++17
Strings.InvalidPrintfFormatSpecifier=Especificador de formato printf no válido
Strings.KeyworddefaultIsUsedAsIdentifier=La palabra clave 'default' se utiliza como identificador
Strings.LambdaCanBeRewrittenToUseExplicitTemplateParameters=La lambda se puede reescribir para usar parámetros de plantilla explícitos
Strings.LambdaCanBeRewrittenToUseExplicitTemplateParameters19=La expresión lambda se puede reescribir para usar parámetros de plantilla explícitos
Strings.LambdaCaptureIsNeverUsed=La captura lambda nunca se utiliza
Strings.LegacyFormatCodeForBoostFormat=Directiva de formato obsoleta en boost::format
Strings.LocalVariableCanBeMadeConst=La variable local puede ser const
Strings.LocalVariableCanBeMadeConst8=La variable local puede ser const
Strings.LocalVariableIsNeverUsedButMayHaveSideEffectsInItsDestructor=La variable local nunca se usa, pero puede tener efectos secundarios en su destructor
Strings.LocalVariableIsNeverUsedButMayHaveSideEffectsInItsDestructor4=La variable local nunca se utiliza, pero puede tener efectos secundarios en su destructor
Strings.LocalVariableMightNotBeInitialized=La variable local podría no estar inicializada
Strings.LocalVariableUsedWithoutBeingInitialized=La variable local se utiliza sin haber sido inicializada
Strings.LocalVariableUsedWithoutBeingInitialized5=La variable local se utiliza sin inicializar
Strings.MayBeMissingKeywordthrow=Puede que falte la palabra clave 'throw'
Strings.MemberFunctionCanBeMadeConst=La función miembro puede declararse como const
Strings.MemberFunctionCanBeMadeConst6=La función miembro se puede marcar como const
Strings.MemberFunctionCanBeMadeStatic=La función miembro puede ser estática
Strings.MemberFunctionCanBeMadeStatic7=La función miembro puede hacerse estática
Strings.MethodMustBePublicAndVirtualToImplementACCLIInterfaceMember=El método debe ser público y virtual para implementar un miembro de la interfaz C++/CLI
Strings.MethodMustBePublicAndVirtualToImplementACCLIInterfaceMember29=El método debe ser public y virtual para implementar un miembro de una interfaz C++/CLI
Strings.MismatchedClassTags=Etiquetas de clase no coincidentes
Strings.MissingFunctionParameterDescriptionInADocumentationComment=Falta la descripción del parámetro de la función en un comentario de documentación
Strings.MissingFunctionParameterDescriptionInADocumentationComment38=Falta la descripción del parámetro de función en un comentario de documentación
Strings.MissingIncludeGuard=Falta la guarda de inclusión
Strings.MixedSerialAndPositionalArgumentsForBoostFormat=Argumentos posicionales y no posicionales en la misma llamada a boost::format
Strings.ModulePartitionWithSeveralPartitionUnitsDescription=Según el estándar de C++, una partición de módulo no puede tener varias unidades de partición
Strings.ModulePartitionWithSeveralPartitionUnitsTitle=Partición de módulo con varias unidades de partición
Strings.MoreThanOneImplicitConversionAppliedDuringCopyInitializationThisIsNonStandardMicrosoftCExtension=Se ha aplicado más de una conversión implícita durante la inicialización de copia. Esta es una extensión de Microsoft C++ no estándar.
Strings.MoreThanOneImplicitConversionAppliedDuringCopyInitializationThisIsNonStandardMicrosoftCExtension4=Se ha aplicado más de una conversión implícita durante la inicialización de copia. Esta es una extensión de Microsoft C++ no estándar.
Strings.MultiCharacterLiteralDescription=Literal de carácter con múltiples caracteres
Strings.MultiCharacterLiteralTitle=Literal de caracteres de varios caracteres
Strings.MultiCharacterWideLiteralDescription=Literal de carácter ancho con varios caracteres
Strings.MultiCharacterWideLiteralTitle=Literal de carácter ancho multicarácter
Strings.NamespaceDefinitionContainingSingleClassSpecialization=Definición de espacio de nombres que contiene una única especialización de clase
Strings.NoCorrespondingFileWithThePrecompiledHeaderPropertySetToCreateYcIsFound=No se encontró ningún archivo correspondiente con la propiedad 'Encabezado precompilado' establecida en 'Crear' (/Yc)
Strings.NoReturnStatementInAFunctionOrALambdaReturningNonVoid=Falta la sentencia return en una función o lambda que devuelve un valor distinto de void
Strings.NoReturnStatementInAFunctionOrALambdaWithNonVoidReturnType=Falta la sentencia return en una función o lambda con un tipo de retorno distinto de void
Strings.NoTypeSpecifierFoundInADeclarationDefaultsToint=No se encontró un especificador de tipo en una declaración. Se asume 'int' por defecto.
Strings.NodiscardCannotBeAppliedToFunctionsWithoutAReturnValue=[[nodiscard]] no se puede aplicar a funciones sin un valor de retorno
Strings.NonExplicitConversionOperator=Operador de conversión no explícito
Strings.NonExplicitConversionOperator5=Operador de conversión no explícito
Strings.NonExplicitConvertingConstructor=Constructor de conversión no explícito
Strings.NonExplicitConvertingConstructor4=Constructor de conversión no explícito
Strings.NonInlineFunctionDefinitionInAHeaderFile=Definición de función no inline en un archivo de cabecera
Strings.NonInlineVariableDefinitionInAHeaderFile=Definición de variable no inline en un archivo de encabezado
Strings.NonSafeResourceAcquisition=Adquisición de recursos no segura
Strings.NonStaticDataMemberIsUninitialized=El miembro de datos no estático no está inicializado
Strings.NonStaticDataMemberIsUninitialized26=El miembro de datos no estático no está inicializado
Strings.NonVirtualClassMemberFunctionHiddenInADerivedClass=Función miembro de clase no virtual oculta en una clase derivada
Strings.NonVirtualClassMemberFunctionIsHiddenInADerivedClass=Una función miembro de clase no virtual está oculta en una clase derivada
Strings.NotAllControlPathsInsideAFunctionOrALambdaReturnAValue=No todas las rutas de control dentro de una función o una lambda devuelven un valor
Strings.NotAllControlPathsReturnAValue=No todas las rutas de control devuelven un valor
Strings.NotEnoughArgumentsInACallToBoostFormat=Argumentos insuficientes en una llamada a boost::format
Strings.NotEnoughArgumentsInACallToBoostFormat36=Argumentos insuficientes en una llamada a boost::format
Strings.NotEnoughArgumentsInACallToPrintf=Argumentos insuficientes en una llamada a printf
Strings.NotEnoughArgumentsInACallToPrintfSomeFormatCodesDoNotHaveAMatchingArgument=No hay suficientes argumentos en una llamada a printf. Algunas directivas de formato no tienen argumentos coincidentes.
Strings.NotInitializedStaticConstLocalVariableOfScalarTypeThisIsNonStandardMicrosoftCExtension=Variable local estática constante de tipo escalar no inicializada. Esta es una extensión de Microsoft C++ no estándar.
Strings.NumericTypeCanBeReplacedWithAuto=El tipo numérico se puede reemplazar por auto
Strings.ObjectMemberMightNotBeInitialized=El miembro del objeto podría no estar inicializado
Strings.ObjectOfExceptionTypeIsCreatedButIsNotThrown=Se ha creado un objeto de tipo excepción, pero no se ha lanzado
Strings.OrderOfIncludeDirectivesDoesNotMatchCodeStyleSettings=El orden de las directivas #include no coincide con los ajustes de estilo de código
Strings.OrderOfIncludeDirectivesDoesNotMatchCodeStyleSettings1=El orden de las directivas #include no coincide con la configuración de estilo de código
Strings.OrderOfMemberInitializersDoesNotMatchTheInitializationOrder=El orden de los inicializadores de miembros no coincide con el orden de inicialización
Strings.OrderOfMemberInitializersDoesNotMatchTheInitializationOrder3=El orden de los inicializadores de miembros no coincide con el orden de inicialización
Strings.OverrideFunctionRedefinesADefaultParameterArgument=La función de invalidación redefine un argumento de parámetro predeterminado
Strings.OverridenMethodIsDeprecated=El método sobreescrito está obsoleto
Strings.ParameterCanBeMadeConst=El parámetro puede ser const
Strings.ParameterCanBeMadeConst9=El parámetro puede ser const
Strings.ParameterCanBeMadePointerReferenceToConst=El parámetro puede ser un puntero/referencia a const
Strings.ParameterCanBeMadePointerReferenceToConst11=El parámetro puede ser un puntero/referencia a const
Strings.ParameterIsNeverUsed=El parámetro nunca se utiliza
Strings.ParameterNamesDifferInDifferentDeclarationsOfTheSameFunction=Los nombres de los parámetros difieren en las diferentes declaraciones de la misma función
Strings.ParameterNamesDoNotMatch=Los nombres de los parámetros no coinciden
Strings.ParenthesesDontChangeOrderOfOperationsAndCanBeDeleted=Los paréntesis no cambian el orden de las operaciones y pueden eliminarse
Strings.PassValueParameterByConstReferenceDescription=Un parámetro de un tipo cuya copia es costosa se pasa por valor, pero puede pasarse por referencia constante en su lugar.
Strings.PassValueParameterByConstReferenceTitle=Pasar parámetros de valor por referencia constante
Strings.PolymorphicClassWithNonVirtualPublicDestructor=Clase polimórfica con destructor público no virtual
Strings.PossiblyErroneousEmptyStatement=Sentencia vacía posiblemente errónea
Strings.PossiblyErroneousEmptyStatementUsedInAControlStatement=Posible sentencia vacía errónea utilizada en una sentencia de control
Strings.PossiblyErroneousExpressionWithoutSideEffects=Expresión posiblemente errónea sin efectos secundarios
Strings.PossiblyErroneousExpressionWithoutSideEffects21=Expresión posiblemente errónea sin efectos secundarios
Strings.PossiblyErroneousIncompleteSwitchStatement=Sentencia switch incompleta posiblemente errónea
Strings.PossiblyInvalidPrintfFormatSpecifier=Especificador de formato printf posiblemente no válido
Strings.PossiblyUninitializedClassMember=Miembro de clase posiblemente no inicializado
Strings.PossiblyUninitializedDependentBaseClass=Clase base dependiente posiblemente no inicializada
Strings.PossiblyUnintendedIncompatibleReferenceTypeInRangeDeclaration=Tipo de referencia incompatible posiblemente no intencionado en la declaración de rango
Strings.PossiblyUnintendedObjectSlicing=Posible recorte de objetos no intencionado
Strings.PossiblyUnintendedObjectSlicing28=Segmentación de objetos posiblemente no intencionada
Strings.PossiblyUnusedIncludeDirective=Directiva #include posiblemente no utilizada
Strings.PossiblyUnusedIncludeDirective7=Directiva #include posiblemente no utilizada
Strings.PragmaEndRegionIsMissingAMatchingEndRegionDescription=A una directiva '#pragma endregion' le falta una directiva '#pragma region' coincidente
Strings.PragmaEndRegionIsMissingAMatchingEndRegionTitle=Falta una directiva '#pragma region' coincidente
Strings.PragmaRegionIsMissingAMatchingEndRegionDescription=A una directiva '#pragma region' le falta una directiva '#pragma endregion' coincidente
Strings.PragmaRegionIsMissingAMatchingEndRegionTitle=Falta una directiva '#pragma endregion' correspondiente
Strings.PrecompiledHeaderIsNotFound=No se encontró el encabezado precompilado
Strings.PrecompiledHeaderIsNotIncluded=No se incluye el encabezado precompilado
Strings.PrecompiledHeaderMustBeIncludedAtTheTopOfSourceFile=La cabecera precompilada debe incluirse al principio del archivo fuente
Strings.PrivateSpecialMemberFunctionIsNotImplemented=La función miembro especial privada no está implementada
Strings.ProhibitsTheUseOfTabulationCharacterEverywhereInFile=Prohíbe el uso del carácter de tabulación en cualquier parte del archivo
Strings.QualifierIsRedundantADLAndCanBeDeleted=El calificador es redundante (debido a ADL) y puede eliminarse
Strings.QualifierIsRedundantAndCanBeDeleted=El calificador es redundante y puede eliminarse
Strings.RedeclarationOfATemplateParameterFromAnOuterScope=Redeclaración de un parámetro de plantilla de un ámbito externo
Strings.RedundantArgumentInConditionalExpression=Argumento redundante en expresión condicional
Strings.RedundantArgumentInConditionalExpression54=Argumento redundante en la expresión condicional
Strings.RedundantBaseClassAccessSpecifier=Especificador de acceso de clase base redundante
Strings.RedundantBaseClassAccessSpecifier53=Especificador de acceso de clase base redundante
Strings.RedundantBaseClassInitializerDescription=Inicializador de clase base redundante en una lista de inicializadores de miembros
Strings.RedundantBaseClassInitializerTitle=Inicializador de clase base redundante
Strings.RedundantCastExpression=Expresión de conversión redundante
Strings.RedundantControlFlowJumpStatement=Sentencia de salto de flujo de control redundante
Strings.RedundantControlFlowJumpStatement47=Sentencia de salto de flujo de control redundante
Strings.RedundantElaboratedTypeSpecifier=Especificador de tipo elaborado redundante
Strings.RedundantEmptyDeclaration=Declaración vacía redundante
Strings.RedundantEmptyDeclaration49=Declaración vacía redundante
Strings.RedundantEmptyStatement=Sentencia vacía redundante
Strings.RedundantEmptyStatement48=Sentencia vacía redundante
Strings.RedundantExportKeywordMessage=La palabra clave 'export' es redundante porque hay una declaración de exportación envolvente
Strings.RedundantFwdClassOrEnumSpecifier=Declaración adelantada redundante
Strings.RedundantMemberInitializerInConstructorInitializationList=Inicializador de miembro redundante en la lista de inicialización del constructor
Strings.RedundantMemberInitializerInConstructorInitializationList56=Inicializador de miembro redundante en la lista de inicialización del constructor
Strings.RedundantParameterListInLambdaDeclarator=Lista de parámetros redundante en el declarador lambda
Strings.RedundantParentheses=Paréntesis redundantes
Strings.RedundantQualifier=Calificador redundante
Strings.RedundantQualifierADL=Calificador redundante (ADL)
Strings.RedundantStaticSpecifierOnThreadLocalLocalVariableDescription=Especificador 'static' redundante en una variable local 'thread_local'
Strings.RedundantStaticSpecifierOnThreadLocalLocalVariableTitle=Especificador 'static' redundante en una variable local 'thread_local'
Strings.RedundantTemplateArguments=Argumentos de plantilla redundantes
Strings.RedundantVoidArgumentList=Lista de argumentos void redundante
Strings.RedundantVoidArgumentList55=Lista de argumentos void redundante
Strings.RedundantWhitespaceCharactersAtTheEndOfALine=Caracteres de espacio en blanco redundantes al final de una línea
Strings.RedundantWhitespacesAtTheEndOfALine=Espacios en blanco redundantes al final de la línea
Strings.RedundantZeroInitializerInAggregateInitializationMessage=Inicializador de cero redundante en la inicialización agregada
Strings.RedundantconstSpecifier=Especificador 'const' redundante
Strings.RedundantelseKeyword=Palabra clave 'else' redundante
Strings.RedundantelseKeyword45=Palabra clave 'else' redundante
Strings.RedundantelseKeywordInsideCompoundStatement=Palabra clave 'else' redundante dentro de una sentencia compuesta
Strings.RedundantelseKeywordInsideCompoundStatement46=Palabra clave 'else' redundante dentro de una sentencia compuesta
Strings.RedundantfinalSpecifierOnAFunctionInAFinalClass=Especificador 'final' redundante en una función de una clase 'final'
Strings.RedundantinlineSpecifier=Especificador 'inline' redundante
Strings.RedundantstaticSpecifierOnAMemberAllocationDeallocationFunction=Especificador 'static' redundante en una función miembro de asignación o desasignación
Strings.RedundantstaticSpecifierOnAnAnonymousNamespaceMember=Especificador 'static' redundante en un miembro de un espacio de nombres anónimo
Strings.RedundantstaticSpecifierOnAnAnonymousNamespaceMember52=Especificador 'static' redundante en un miembro de un espacio de nombres anónimo
Strings.RedundanttemplateKeyword=Palabra clave 'template' redundante
Strings.RedundanttemplateKeyword43=Palabra clave 'template' redundante
Strings.RedundanttypenameKeyword=Palabra clave 'typename' redundante
Strings.RedundanttypenameKeyword42=Palabra clave 'typename' redundante
Strings.ReferenceClassMemberWithmutableSpecifier=Miembro de clase de referencia con el especificador 'mutable'
Strings.ReferenceClassMembersCannotHavemutableSpecifier=Los miembros de una clase de referencia no pueden tener el especificador 'mutable'
Strings.ReinterpretCastIsUsedInsteadOfAStaticCast=Se utiliza reinterpret_cast en lugar de static_cast
Strings.ReinterpretCastIsUsedInsteadOfAStaticCast3=Se utiliza reinterpret_cast en lugar de static_cast
Strings.RemoveRedundantBraces=Eliminar llaves redundantes
Strings.ResultOfAPostfixOperatorIsDiscarded=Se descarta el resultado de un operador postfijo
Strings.ResultOfAPostfixOperatorIsDiscardedItMightBeMoreEfficientToUseAPrefixFormOfTheOperator=El resultado de un operador postfijo se descarta. Podría ser más eficiente utilizar la forma prefija del operador.
Strings.ResultOfAssignmentIsUsedAsCondition=El resultado de la asignación se utiliza como condición
Strings.ResultOfNodiscardFunctionIsNotUsed=No se utiliza el resultado de la función nodiscard
Strings.ResultOfNodiscardFunctionIsNotUsed22=El resultado de la función nodiscard no se utiliza
Strings.ReturningFromAFunctionByConstValueIsUsuallyNotBeneficialConsiderReturningValuesAsNonConstToTakeAdvantageOfMoveSemantics=Retornar de una función por valor const no suele ser beneficioso. Considere devolver los valores como no const para aprovechar la semántica de movimiento.
Strings.SlashSymbolUsedInIncludeDirectiveDoesntMatchCodeStyleSettings=El símbolo de barra utilizado en la directiva #include no coincide con la configuración de estilo de código
Strings.SlashSymbolUsedInIncludeDirectiveDoesntMatchCodeStyleSettings2=El símbolo de barra utilizado en la directiva #include no coincide con la configuración de estilo de código
Strings.SomeObjectMembersMightNotBeInitialized=Es posible que algunos miembros del objeto no estén inicializados
Strings.SpecialFunctionDoesntHaveAnyNoexceptSpecification=La función especial no tiene ninguna especificación noexcept
Strings.SpecialFunctionWithoutNoexceptSpecification=Función especial sin especificación noexcept
Strings.StaticAssertFailedDescription=static_assert falló
Strings.StaticAssertFailedTitle=static_assert falló
Strings.StaticDataMemberInAnAnonymousClassIsNotAllowedByTheCStandard=El estándar de C++ no permite miembros de datos estáticos en una clase anónima
Strings.StaticDataMembersAreNotAllowedInAnonymousClasses=No se permiten miembros de datos estáticos en clases anónimas
Strings.StdIsConstantEvaluatedWillAlwaysEvaluateToConstantDescription='std::is_constant_evaluated' siempre se evaluará como constante
Strings.StdIsConstantEvaluatedWillAlwaysEvaluateToConstantTitle='std::is_constant_evaluated' siempre se evaluará como constante
Strings.StdSizeCanBeUsed=Se puede utilizar std::size
Strings.StdSizeIsTypeSafeAlternativeToCIdiomForArraySizeCalculation=Std::size es una alternativa con seguridad de tipos al modismo de C para el cálculo del tamaño de arreglos
Strings.StdViewsKeysValuesCanBeUsed=Se pueden usar std::views::keys/values
Strings.StringLiteralToCharPointerConversion=Conversión de literal de cadena a puntero char
Strings.StringLiteralToCharPointerConversion34=Conversión de literal de cadena a puntero a char
Strings.StructuredBindingCanBeUsed=Se puede utilizar la vinculación estructurada
Strings.StructuredBindingCanBeUsed15=Se puede utilizar la vinculación estructurada
Strings.StructuredBindingCanBeUsedInsteadOfTie=Se puede utilizar la vinculación estructurada en lugar de tie(..)
Strings.StructuredBindingsCanBeUsed=Se pueden utilizar vinculaciones estructuradas
Strings.StructuredBindingsCanBeUsedDescription=Se pueden usar enlaces estructurados
Strings.StructuredBindingsCanBeUsedInsteadOfTie=Se pueden utilizar vinculaciones estructuradas en lugar de tie(..)
Strings.SyntaxErrorInADoxygenComment=Error de sintaxis en un comentario doxygen
Strings.SyntaxErrorInDoxygenComment=Error de sintaxis en el comentario doxygen
Strings.TabsAreProhibited=No se permiten tabulaciones
Strings.TagsOfTheDeclaredClassDoNotMatchPreviousDeclarations=Las etiquetas de la clase declarada no coinciden con las declaraciones anteriores
Strings.TakingAnAddressOfClassRValueIsNonStandardMicrosoftCExtension=Tomar la dirección de un valor r de clase es una extensión de Microsoft C++ no estándar
Strings.TakingAnAddressOfClassRValueIsNonStandardMicrosoftCExtension3=Tomar la dirección de un r-value de clase es una extensión de Microsoft C++ no estándar
Strings.TemplateArgumentsCanBeDeduced=Los argumentos de plantilla pueden deducirse
Strings.TemplateParameterIsNeverUsedDescription=Un parámetro de plantilla nunca se utiliza
Strings.TemplateParameterIsNeverUsedTitle=El parámetro de plantilla no se utiliza nunca
Strings.TheAwaiterTypeMustBeAAClassAccordingToTheCStandard=El tipo awaiter debe ser una clase según el estándar C++20
Strings.TheClassIsAbstractButNotExplicitlyDeclaredAsSuch=La clase es abstracta pero no está declarada explícitamente como tal
Strings.TheNodiscardAttributeCannotBeAppliedToFunctionsWithoutAReturnValue=El atributo [[nodiscard]] no se puede aplicar a funciones sin un valor de retorno
Strings.TheSwitchStatementDoesntCoverTheWholeRangeOfTheEnumerationUsed=La sentencia switch no cubre todo el rango de la enumeración utilizada
Strings.TheconstSpecifierOnAVariableDefinitionIsRedundant=El especificador 'const' en la definición de una variable es redundante
Strings.TheinlineSpecifierOnAFunctionDefinitionIsRedundant=El especificador 'inline' en la definición de una función es redundante
Strings.TheoutParameterMustBeAssigned=El parámetro 'out' debe ser asignado
Strings.TheregisterStorageClassSpecifierIsDeprecatedInCAndRemovedInC=El especificador de clase de almacenamiento 'register' está en desuso en C++11 y se ha eliminado en C++17
Strings.ThestaticSpecifierIsOptionalForMemberAllocationDeallocationFunctions=El especificador 'static' es opcional para las funciones miembro de asignación/liberación
Strings.ThrowExpressionCanBeReplacedWithARethrowExpression=La expresión throw puede reemplazarse por una expresión rethrow
Strings.ThrowExpressionCanBeReplacedWithARethrowExpression12=La expresión throw se puede reemplazar con una expresión rethrow
Strings.TooManyArgumentsInACallToBoostFormat=Demasiados argumentos en una llamada a boost::format
Strings.TooManyArgumentsInACallToBoostFormatSomeOfTheArgumentsAreNotUsed=Demasiados argumentos en una llamada a boost::format. Algunos de los argumentos no se utilizan.
Strings.TooManyArgumentsInACallToPrintf=Demasiados argumentos en una llamada a printf
Strings.TooManyArgumentsInACallToPrintfSomeOfTheArgumentsAreNotUsed=Demasiados argumentos en una llamada a printf. Algunos de los argumentos no se utilizan.
Strings.TypeAliasIsNeverUsed=El alias de tipo nunca se utiliza
Strings.TypeCanBeReplacedWithAuto=El tipo puede reemplazarse por auto
Strings.TypeCanBeReplacedWithauto4=El tipo se puede reemplazar por 'auto'
Strings.TypeSpecifierMissingDefaultsToInt=Falta el especificador de tipo, se asume int por defecto
Strings.TypeTraitCanBeSimplifiedUsingATemplateAliasOrAVariableTemplate=El rasgo de tipo puede simplificarse mediante un alias de plantilla o una plantilla de variable
Strings.UninitializedDependentBaseClass=Clase base dependiente no inicializada
Strings.UnionMemberOfReferenceType=Miembro de unión de tipo de referencia
Strings.UnionsCannotContainNonStaticDataMembersOfReferenceTypes=Las uniones no pueden contener miembros de datos no estáticos de tipos de referencia
Strings.UnnamedNamespaceInAHeaderFile=Espacio de nombres anónimo en un archivo de encabezado
Strings.UnnamedNamespacesShouldNotBeUsedInHeaderFiles=No se deben usar espacios de nombres anónimos en archivos de encabezado
Strings.UnresolvedReferenceInADoxygenComment=Referencia no resuelta en un comentario doxygen
Strings.UnresolvedReferenceInDoxygenComment=Referencia no resuelta en el comentario de doxygen
Strings.UseBracesToSeparatedoWhileStatementBody=Usar llaves para separar el cuerpo de la sentencia 'do-while'
Strings.UseBracesToSeparateforStatementBody=Usar llaves para separar el cuerpo de la sentencia 'for'
Strings.UseBracesToSeparateifStatementBody=Usar llaves para separar el cuerpo de la sentencia 'if'
Strings.UseBracesToSeparatewhileStatementBody=Usar llaves para separar el cuerpo de la sentencia 'while'
Strings.UseOfAnIncompleteTypeInsideATemplate=Uso de un tipo incompleto dentro de una plantilla
Strings.UsePreferredBracesStyle=Usar el estilo de llaves preferido
Strings.UsePreferredCvQualifiersStyle=Usar el estilo de calificadores cv preferido
Strings.UsePreferredDeclarationStyle=Usar el estilo de declaración preferido
Strings.UsePreferredIncludeDirectiveStyle=Usar el estilo de directiva include preferido
Strings.UsePreferredInitializationStyle=Usar el estilo de inicialización preferido
Strings.UsePreferredOverridingFunctionStyle=Usar el estilo de función de sobrescritura preferido
Strings.UsePreferredautoStyle=Usar el estilo 'auto' preferido
Strings.UserDefinedLiteralSuffixesMustStartWithAnUnderscore=Los sufijos de literales definidos por el usuario deben empezar con un guion bajo
Strings.UserDefinedLiteralSuffixesMustStartWithAnUnderscoreTheSuffixesThatDoNotBeginWithAnUnderscoreAreReservedForTheLiteralOperatorsProvidedByTheStandardLibrary=Los sufijos de literales definidos por el usuario deben comenzar con un guion bajo. Los sufijos que no comienzan con un guion bajo están reservados para los operadores de literales proporcionados por la biblioteca estándar.
Strings.UsingAnIncompatibleReferenceTypeInTheRangeDeclarationIsLikelyToCauseUnwantedObjectCopying=Es probable que el uso de un tipo de referencia incompatible en la declaración de rango cause copias de objetos no deseadas
Strings.VariableCanBeMadeConstexpr=La variable puede ser constexpr
Strings.VariableCanBeMadeConstexpr10=La variable puede ser constexpr
Strings.VariableCanBeMovedToInitStatement=La variable se puede mover a la sentencia init
Strings.VariableCanBeMovedToInnerScope=La variable puede moverse al ámbito interno
Strings.VolatileQualificationOfParametersHasAnEffectOnlyInFunctionDefinitions=La calificación volatile de los parámetros solo tiene efecto en las definiciones de funciones
Strings.VolatileQualifiedParameterInAFunctionDeclaration=Parámetro calificado como volatile en una declaración de función
Strings.WarningDirectiveDescription=Directiva de preprocesador #warning
Strings.WarningDirectiveTitle=directiva #warning
Strings.ZeroConstantCanBeReplacedWithNullptr=La constante cero se puede reemplazar con nullptr
Strings.ZeroConstantCanBeReplacedWithNullptr13=La constante cero se puede reemplazar por nullptr
Strings.ZeroInitializationCanBeUsedInsteadOfMemset=Se puede utilizar la inicialización a cero en lugar de memset
Strings.ZeroInitializationCanBeUsedInsteadOfMemset16=Se puede utilizar la inicialización a cero en lugar de memset
Strings.containsMemberFunctionCanBeUsed=Se puede utilizar la función miembro 'contains'
Strings.containsMemberFunctionCanBeUsed17=Se puede utilizar la función miembro 'contains'
Strings.defaultIsAKeywordInTheCStandardAndCannotBeUsedAsAnIdentifier='default' es una palabra reservada en el estándar de C++ y no puede utilizarse como identificador
Strings.longFloatsAreNotAllowedByTheCStandard=El estándar de C++ no permite el uso de 'long' floats
Strings.stdErasestdEraseIfCanBeUsedInsteadOfTheRemoveEraseIdiom=Se puede utilizar 'std::erase'/'std::erase_if' en lugar del modismo remove-erase
Strings.stdErasestdEraseIfCanBeUsedInsteadOfTheRemoveEraseIdiom18=Se puede utilizar 'std::erase'/'std::erase_if' en lugar del modismo remove-erase
