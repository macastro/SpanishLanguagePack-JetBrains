Field.cannot.be.final.because.replaced.variable.has.lhs.usages=La variable seleccionada se utiliza para escritura
access.to.created.field.0.will.be.overridden.by.method.1=El acceso al campo {0} será sobrescrito por {1}
all.invocations.and.remove.the.method=Internalizar &todas las invocaciones y eliminar el método
all.invocations.in.project=Inline &todos los usos en el proyecto
cannot.find.a.single.definition.to.inline.field=No hay un inicializador presente para el campo
cannot.find.a.single.definition.to.inline.local.var=No se puede encontrar una única definición para insertar la variable local en línea
cannot.inline.0.=No se puede aplicar inline a {0}
cannot.inline.reference.0=No se puede insertar en línea la referencia ''{0}''
cannot.introduce.field.in.interface=No se puede introducir un campo en una interfaz
cannot.introduce.field.in.script=No hay ninguna clase en el ámbito
cannot.process.usage.in.language.{0}=No se puede procesar el uso en {0}
cannot.rename.property.0=No se puede renombrar la propiedad <bold>''{0}''</bold> que sobrescribe el método <bold>''{1}''</bold>
cannot.rename.script.class.to.0=No se puede renombrar la clase de script ''{0}'' a ''{1}''
changeSignature.no.type.for.exception=Especifique un tipo para la excepción
changeSignature.not.throwable.type=Tipo incorrecto: ''{0}'' para la excepción, debe extender java.lang.Throwable
changeSignature.wrong.type.for.exception=Tipo incorrecto: ''{0}'' para la excepción
class.does.not.exist.in.the.module=La clase no existe en el módulo. ¿Desea crearla?
class.language.is.not.groovy=El lenguaje de la clase objetivo no es Groovy
closure.uses.external.variables=El closure usa variables externas que no son constantes
convert.to.java.can.work.only.with.groovy=La refactorización Convertir a Java solo funciona con archivos Groovy
convert.to.java.refactoring.name=Convertir a Java
converting.files.to.java=Convirtiendo archivos a Java
converting.files.to.static=Convirtiendo archivos a @CompileStatic
declare.final.checkbox=Declarar final
error.wrong.caret.position.method.name=El cursor debe estar posicionado en el nombre del método a refactorizar.
expression.contains.errors=La expresión contiene errores
extract.method.dialog.explicit.return.checkbox=Usar sentencia return e&xplícita
extract.method.title=Extraer método
field.0.is.already.defined=El campo {0} ya está definido
field.cannot.be.initialized.in.constructor(s)=No se puede inicializar el campo en el/los constructor(es)
field.cannot.be.initialized.in.field.declaration=No se puede inicializar el campo en la declaración
field.is.not.accessible.form.context.0=El campo {0} utilizado en el método insertado no es accesible desde el punto de llamada
files.to.be.converted=Archivos a convertir
final.field.cant.be.initialized.in.cur.method=El campo final no se puede inicializar en el método actual
implicit.getter.will.by.overridden.by.method=El getter implícito de la propiedad {0} será sobrescrito por el método {1}
implicit.setter.will.by.overridden.by.method=El setter implícito de la propiedad {0} será sobrescrito por el método {1}
initialize.in.border.title=Inicializar en
initialize.in.class.constructor.choice=Clase constructor(es)
initialize.in.current.method.choice=Método actual(&M)
initialize.in.field.declaration.choice=Declaración de campo(&D)
initialize.in.label=Inicializar en(&I):
initialize.in.setup.method.choice=Método setUp
inline.local.variable.prompt.0.1=¿Insertar en línea la variable local ''{0}''?
inline.method.border.title=En línea
inline.method.label=Incorporar método ''{0}''
inline.method.title=Metodo en línea
inplace.introduce.constant.move.checkbox=&Mover a otra clase
intention.converting.to.static=Aplicar conversión a @CompileStatic
intention.converting.to.static.family=Convertir a @CompileStatic
introduce.closure.parameter.elements.header=Añadiendo parámetro a una clausura
introduce.constant.class.label=Introducir en la &clase (nombre completo cualificado):
introduce.variable.title=Introducir variable
introduced.variable.conflicts.with.parameter.0=La variable introducida entrará en conflicto con el parámetro {0}
introduced.variable.conflicts.with.variable.0=La variable introducida entrará en conflicto con la variable local {0}
local.variable.is.lvalue=La variable que se va a integrar aparece como lvalue en una asignación
method.duplicate=El método con la firma {0} ya está definido en {1}
method.is.already.defined.in.class=El método {0} ya está definido en la clase {1}.
method.is.already.defined.in.script=El método {0} ya está definido en el script {1}.
method.is.not.accessible.form.context.0=No se puede acceder al método {0} utilizado en el método insertado desde el lugar de la llamada.
multiple.output.values=Hay múltiples valores de salida para el fragmento de código seleccionado
name.is.wrong=El nombre ''{0}'' es incorrecto
name.label=&Nombre:
no.occurrences.found=No se encontraron ocurrencias
only.in.groovy.files=Esta refactorización solo está disponible en archivos Groovy
press.escape.to.remove.the.highlighting=Presione Esc para quitar el resaltado
ref.0.will.not.be.resolved.outside.of.current.context=La referencia ''{0}'' no se resolverá fuera del contexto actual
refactored.method.will.cover.closure.property=El método refactorizado reemplazará la propiedad de cierre ''{0}'' en {1}
refactoring.cannot.be.applied.no.sources.attached=Refactorización no puede ser aplicada: no hay código fuente adjunto
refactoring.cannot.be.applied.to.abstract.methods=La refactorización no se puede aplicar a métodos abstractos
refactoring.cannot.be.applied.to.constructors=No se puede aplicar la refactorización a los constructores
refactoring.is.available.only.for.method.calls=El refactorizado solo está disponible para llamadas de método
refactoring.is.not.supported.in.method.parameters=La refactorización no es compatible en parámetros de cierre o método
refactoring.is.not.supported.in.parameter.initializers=La refactorización no está soportada en los inicializadores de parámetros
refactoring.is.not.supported.in.the.current.context=La refactorización no está soportada en el contexto actual
refactoring.is.not.supported.when.return.statement.interrupts.the.execution.flow=No se admite la refactorización cuando la sentencia return interrumpe el flujo de ejecución
reference.to.accessor.0.is.used=La referencia al accesor <bold>{0}<bold> no se puede aplicar inline.
remove.parameter.0.no.longer.used=Eliminar el parámetro ''{0}'' que ya no se utiliza
rename.groovy.property=Renombrar propiedad &Groovy
rename.is.not.applicable.to.implicit.elements=No se pueden renombrar los elementos implícitos.
rename.member=Renombrar {0}
rename.property=Renombrar propiedad ''{0}''
replace.all.occurrences.checkbox=Reemplazar &todas las coincidencias
replace.getter.for.property=El getter predeterminado de la propiedad ''{0}'' será sobrescrito
replace.setter.for.property=El setter predeterminado para la propiedad ''{0}'' será sobrescrito
return.type.is.wrong=El tipo de retorno es incorrecto
selected.block.contains.invocation.of.another.class.constructor=El bloque seleccionado contiene la invocación del constructor de otra clase
selected.block.should.represent.a.statement.set=El bloque seleccionado debe representar un conjunto de sentencias o una expresión
selected.block.should.represent.an.expression=El bloque seleccionado debe representar una expresión.
selected.expression.has.void.type=La expresión seleccionada es de tipo void
selected.expression.should.not.be.lvalue=La expresión seleccionada no debe estar en el lado izquierdo de una asignación
selected.variable.is.used.for.write=La variable seleccionada se utiliza para escritura
signature.preview.border.title=Vista previa de la firma
specify.default.value=Especificar el valor predeterminado o el inicializador para el parámetro ''{0}''
specify.type.label=Especificar explícitamente el tipo de retorno(&T)
super.reference.is.used=La llamada a super utilizada en el método insertado no será válida después de la inserción.
target.class.must.not.be.script=La clase de destino no debe ser un script
there.is.no.method.or.closure=No hay método o cierre contenedor
this.invocation.only.and.keep.the.method=Incorporar solo este uso y man&tener el método
type.for.parameter.is.incorrect=El tipo para el parámetro ''{0}'' es incorrecto
type.label=&Tipo:
usage.will.be.overridden.by.method=El uso {0} será sobrescrito por el método {1}
variable.conflicts.with.field.0=El nombre elegido entrará en conflicto con el campo {0}
variable.conflicts.with.parameter.0=El nombre elegido entra en conflicto con el parámetro {0}
variable.conflicts.with.variable.0=El nombre elegido entrará en conflicto con la variable local {0}
variable.is.accessed.for.writing=Se accede a la variable ''{0}'' para escritura
visibility.border.title=Visibilidad
visibility.private.choice=Pri&vado
visibility.property.choice=P&ropiedad
visibility.protected.choice=Protegido(&O)
visibility.public.choice=Pú&blico\nvisibility.public.choice=público(&B)\nvisibility.public.choice=Público(&B)
you.cannot.pass.as.parameter.0.because.you.remove.1.from.base.method=No puede pasar ''{0}'' como parámetro porque ha eliminado del método el parámetro ''{1}'' asociado. Debe desmarcar ''Eliminar el parámetro ''{0}'' que ya no se utiliza'' o desmarcar el parámetro ''{1}'' en la tabla de parámetros.
