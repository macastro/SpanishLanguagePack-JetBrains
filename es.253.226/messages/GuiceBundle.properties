GuiceClassAnnotator.popup.title=Seleccionar la expresión a la que navegar
GuiceClassAnnotator.popup.tooltip.text=Navegar a la expresión de enlace de Guice
ImplicitSubclassInspection.display.forMethod.annotated=El método @Transactional no puede ser private
binding.annotation.without.inject.display.name=Anotación de vinculación sin @Inject
binding.annotation.without.inject.problem.descriptor=Anotación de vinculación sin declarar @Inject #ref #loc
class.provided=Clase proporcionada:
conflicting.annotations.display.name=Anotaciones de Guice en conflicto
conflicting.annotations.problem.descriptor=La anotación #ref entra en conflicto con otras anotaciones declaradas #loc
delete.binding=Eliminar vinculación
group.GuiceActionGroup.description=Componentes de Google Guice
group.GuiceActionGroup.text=Google Guice
group.guice.inspections.name=Guice
guice.intentions=Guice
gutter.choose.injected.point=Seleccionar punto de inyección
gutter.navigate.to.injection.point=Navegar al punto de inyección
interception.annotation.without.runtime.retention.display.name=Anotación de intercepción sin retención en tiempo de ejecución
interception.annotation.without.runtime.retention.problem.descriptor=La anotación #ref no tiene retención en tiempo de ejecución #loc
invalid.implemented.by.display.name=Anotación @ImplementedBy no válida
invalid.implemented.by.problem.descriptor=La clase #ref no implementa la clase anotada #loc
invalid.provided.by.display.name=Anotación @ProvidedBy no válida
invalid.provided.by.problem.descriptor=La clase #ref no proporciona una clase anotada #loc
invalid.request.parameters.display.name=Tipo de parámetro @RequestParameters incorrecto
invalid.request.parameters.problem.descriptor=Las variables o parámetros etiquetados con #ref deben ser de tipo Map<String, String[]> #loc
make.injection.mandatory=Hacer obligatoria la inyección
make.injection.optional=Hacer opcional la inyección
move.binding.scope.to.class.family.name=Mover ámbito de vinculación a la clase
move.binding.scope.to.class.text=Mover el ámbito de vinculación a la clase
move.binding.to.class.family.name=Mover vinculación a la clase
move.binding.to.class.text=Mover clase de vinculación a clase
move.provider.binding.to.class.family.name=Mover vinculación de proveedor a clase
move.provider.binding.to.class.text=Mover vinculación de proveedor a la clase
multiple.binding.annotations.display.name=Múltiples anotaciones de binding en la variable
multiple.binding.annotations.problem.descriptor=La variable #ref tiene múltiples anotaciones de vinculación #loc
multiple.injected.constructors.for.class.display.name=Múltiples constructores @Inject para la clase
multiple.injected.constructors.for.class.problem.descriptor=La clase #ref tiene múltiples constructores @Inject #loc
new.guice.binding.annotation.action.name=Crear anotación de vinculación de Guice
new.guice.binding.annotation.error=No se puede crear la anotación de vinculación de Guice
new.guice.binding.annotation.name=Creando anotación de enlace de Guice: {0}.{1}
new.guice.method.interceptor.action.name=Crear interceptor de métodos de Guice
new.guice.method.interceptor.error=No se puede crear el interceptor de métodos de Guice
new.guice.method.interceptor.name=Creando interceptor de métodos Guice: {0}. {1}
new.guice.module.action.name=Crear módulo Guice
new.guice.module.error=No se pudo crear el módulo Guice
new.guice.module.name=Creando el módulo Guice: {0}. {1}
new.guice.provider=Nuevo proveedor de Guice
new.guice.provider.action.name=Crear proveedor de Guice
new.guice.provider.error=No se puede crear el proveedor de Guice
new.guice.provider.name=Creando proveedor Guice: {0}.{1}
new.guice.scope.annotation.action.name=Crear anotación de ámbito de Guice
new.guice.scope.annotation.error=No se puede crear la anotación de ámbito de Guice
pointless.binding.display.name=Vinculación sin sentido
pointless.binding.problem.descriptor=El enlace es innecesario y puede eliminarse #loc
provider.class.name=Nombre de la clase del proveedor:
redundant.scope.binding.display.name=Vinculación de ámbito redundante
redundant.scope.binding.problem.descriptor=La vinculación al ámbito #ref es redundante #loc
redundant.to.binding.display.name=Vinculación redundante
redundant.to.binding.problem.descriptor=La vinculación a la clase #ref es redundante #loc
redundant.to.provider.binding.display.name=Vinculación de proveedor redundante
redundant.to.provider.binding.problem.descriptor=La vinculación a la clase #ref es redundante #loc
select.provided.class=Seleccionar la clase que se va a proporcionar
session.scoped.injects.request.scoped.display.name=Componente @SessionScoped inyecta componente @RequestScoped
session.scoped.injects.request.scoped.problem.descriptor=@Inject de la clase @RequestScoped #ref en la clase @SessionScoped #loc
singleton.injects.scoped.display.name=El componente @Singleton inyecta un componente con ámbito
singleton.injects.scoped.problem.descriptor=@Inject de la clase con ámbito #ref desde la clase @Singleton #loc
toggle.injection.required.family.name=Alternar inyección
toggle.required=Alternar 'opcional'
uninstantiable.binding.display.name=Vinculación no instanciable
uninstantiable.binding.problem.descriptor=La clase #ref no se puede instanciar, por lo que no se puede vincular #loc
uninstantiable.implemented.by.class.display.name=Clase @ImplementedBy no instanciable
uninstantiable.implemented.by.class.problem.descriptor=La clase #ref no es instanciable, por lo que no puede ser @ImplementedBy #loc
uninstantiable.provided.by.class.display.name=Clase @ProvidedBy no instanciable
uninstantiable.provided.by.class.problem.descriptor=La clase #ref no se puede instanciar, por lo que no puede ser @ProvidedBy #loc
unnecessary.static.injection.display.name=Inyección estática innecesaria
unnecessary.static.injection.problem.descriptor=La clase #ref no tiene miembros static @Inject #loc
