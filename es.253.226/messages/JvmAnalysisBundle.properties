action.find.similar.stack.call.methods.not.found=No se han encontrado clases similares
advanced.setting.process.console.output.to.find.class.names=Procesar la salida de la terminal para buscar y resaltar nombres de clases
allow.suppressions.fix.family.name=Permitir supresiones
allow.suppressions.fix.text=Permitir estas supresiones
assertequals.between.inconvertible.types.display.name='assertEquals()' entre objetos de tipos no convertibles
can.t.build.uast.tree.for.file=No se puede construir el árbol UAST para el archivo
checkbox.comments.and.javadoc.count.as.content=Comentarios y Javadoc cuentan como contenido
current.version=Versión actual
dialog.title.choose.annotation=Seleccionar {0}
group.advanced.settings.jvm=Lenguajes de la JVM
ignored.suppressions=Supresiones ignoradas:
inspection.empty.method.delete.quickfix=Eliminar método(s) innecesario(s)
inspection.empty.method.display.name=Método vacío
inspection.empty.method.problem.descriptor=El método solo llama a su super_
inspection.empty.method.problem.descriptor1=Un método vacío sobrescribe un método vacío
inspection.empty.method.problem.descriptor2=El método está vacío
inspection.empty.method.problem.descriptor3=El método y todos sus derivados están vacíos
inspection.empty.method.problem.descriptor4=Todas las implementaciones de este método están vacías
inspection.message.illegal.dependency.module.doesn.t.export=Dependencia ilegal: el módulo ''{0}'' no exporta el paquete ''{1}''
inspection.suppression.annotation.display.name=Anotación de supresión de inspección
inspection.suppression.annotation.problem.descriptor=La anotación suprime {0} #loc
inspection.suppression.comment.problem.descriptor=El comentario suprime {0} #loc
jvm.class.filter.choose.calls=Llamadas de registro similares:
jvm.inspection.log.guarded.display.name=Llamadas de registro protegidas por una condición de registro
jvm.inspection.log.guarded.fix.family.name=Quitar el envoltorio de la condición de guarda del log
jvm.inspection.log.guarded.problem.descriptor=Llamada de registro protegida por una condición de log #loc
jvm.inspection.log.guarded.warn.if.fix.possible=Advertir solo si hay una corrección disponible
jvm.inspection.log.statement.not.guarded.all.levels.option=Todos los niveles de registro
jvm.inspection.log.statement.not.guarded.debug.level.and.lower.option=Nivel de depuración e inferiores
jvm.inspection.log.statement.not.guarded.display.name=Llamada de registro no protegida por una condición de registro
jvm.inspection.log.statement.not.guarded.info.level.and.lower.option=nivel info e inferior
jvm.inspection.log.statement.not.guarded.log.fix.family.name=Rodear con una condición de registro
jvm.inspection.log.statement.not.guarded.log.problem.descriptor=La llamada de registro no está protegida por una condición de registro #loc
jvm.inspection.log.statement.not.guarded.trace.level.option=Nivel de traza
jvm.inspection.log.statement.not.guarded.unguarded.constant.option=Procesar llamadas de registro no protegidas con mensajes constantes
jvm.inspection.log.statement.not.guarded.unguarded.constant.option.comment=Procesar todas las llamadas de registro no protegidas, no solo aquellas con argumentos no constantes
jvm.inspection.log.statement.not.guarded.warn.level.and.lower.option=Nivel de advertencia e inferiores
jvm.inspection.log.statement.not.guarded.warn.on.label=Advertir sobre:
jvm.inspection.logging.condition.disagrees.with.log.statement.display.name=La condición de registro no coincide con la llamada de registro
jvm.inspection.logging.condition.disagrees.with.log.statement.fix.family.name=Cambiar nivel de registro
jvm.inspection.logging.condition.disagrees.with.log.statement.fix.name=Cambiar el nivel de la {0, choice, 0#condición|1#llamada}
jvm.inspection.logging.condition.disagrees.with.log.statement.problem.descriptor=El nivel de la condición ''{0}'' no coincide con el nivel de la llamada de registro ''{1}''
jvm.inspection.logging.placeholder.count.matches.argument.count.display.name=El número de marcadores de posición no coincide con el número de argumentos en la llamada de registro
jvm.inspection.logging.placeholder.count.matches.argument.count.fewer.problem.descriptor=Se han proporcionado menos argumentos ({0}) que los marcadores de posición especificados ({1}) #loc
jvm.inspection.logging.placeholder.count.matches.argument.count.fewer.problem.partial.descriptor=Se han proporcionado menos argumentos ({0}) que los marcadores de posición especificados (al menos {1}) #loc
jvm.inspection.logging.placeholder.count.matches.argument.count.incorrect.problem.descriptor=Especificador de cadena de formato no válido #loc
jvm.inspection.logging.placeholder.count.matches.argument.count.more.problem.descriptor=Se proporcionan más argumentos ({0}) que marcadores de posición especificados ({1}) #loc
jvm.inspection.logging.placeholder.count.matches.argument.count.slf4j.throwable.option=SLF4J utiliza Log4j 2 como implementación
jvm.inspection.logging.placeholder.count.matches.argument.count.slf4j.throwable.option.auto=Comprobar automáticamente
jvm.inspection.logging.placeholder.count.matches.argument.count.slf4j.throwable.option.no=No
jvm.inspection.logging.placeholder.count.matches.argument.count.slf4j.throwable.option.yes=Sí
jvm.inspection.logging.similar.message.display.name=Llamadas de registro indistinguibles
jvm.inspection.logging.similar.message.problem.descriptor=Mensajes de registro similares
jvm.inspection.logging.similar.message.problem.min.similar.length=Longitud mínima de una secuencia similar
jvm.inspection.logging.similar.message.problem.skip.on.error=No informar llamadas con nivel de registro `error`
jvm.inspection.logging.string.template.as.argument.all.levels.option=Todos los niveles de registro
jvm.inspection.logging.string.template.as.argument.debug.level.and.lower.option=Nivel de depuración e inferiores
jvm.inspection.logging.string.template.as.argument.display.name=Plantilla de cadena como argumento en una llamada de registro
jvm.inspection.logging.string.template.as.argument.info.level.and.lower.option=nivel info e inferiores
jvm.inspection.logging.string.template.as.argument.problem.descriptor=Plantilla de cadena como argumento para la llamada de registro <code>#ref()</code> #loc
jvm.inspection.logging.string.template.as.argument.quickfix.name=Reemplazar con marcadores de posición
jvm.inspection.logging.string.template.as.argument.skip.on.only.exception=No avisar cuando se llame únicamente con una excepción como argumento después del argumento del mensaje.
jvm.inspection.logging.string.template.as.argument.skip.on.primitives=No advertir cuando solo se incluyan expresiones con tipos primitivos, sus envoltorios o String
jvm.inspection.logging.string.template.as.argument.trace.level.option=Nivel de traza
jvm.inspection.logging.string.template.as.argument.warn.level.and.lower.option=Nivel de advertencia e inferiores
jvm.inspection.logging.string.template.as.argument.warn.on.label=Advertir sobre:
jvm.inspection.test.failed.line.display.name=Línea fallida en la prueba
jvm.inspections.1.5.problem.descriptor=Uso de API documentada como @since {0}+
jvm.inspections.1.7.problem.descriptor=Uso de una API convertida a genérica después de la versión 1.6 que causaría problemas de compilación con JDK {0}
jvm.inspections.1.8.problem.descriptor={0, choice, 0#|1#El método por defecto no se ha sobrescrito|2#Los métodos por defecto no se han sobrescrito}. Esto causaría problemas de compilación con JDK {1}
jvm.inspections.1.8.problem.single.descriptor=El método predeterminado ''{0}'' no se ha sobrescrito. Causará problemas de compilación con el JDK {1}
jvm.inspections.api.display.name=Usos de API no disponibles en el nivel de lenguaje configurado
jvm.inspections.api.no.extension.class.description=La clase ''{0}'' no debe ser extendida
jvm.inspections.api.no.extension.display.name=Clase, interfaz o método no deben ser extendidos
jvm.inspections.api.no.extension.interface.extend.description=La interfaz ''{0}'' no debe ser extendida
jvm.inspections.api.no.extension.interface.implement.description=La interfaz ''{0}'' no debe ser implementada
jvm.inspections.api.no.extension.method.overriding.description=El método ''{0}'' no debe sobrescribirse
jvm.inspections.api.no.extension.on.invalid.target.class.description={0} ''{1}'' está marcado con ''@ApiStatus.NonExtendable'', pero no se puede extender
jvm.inspections.api.no.extension.on.invalid.target.method.description=El método ''{0}'' está marcado con ''@ApiStatus.NonExtendable'', pero no se puede sobrescribir
jvm.inspections.api.no.extension.on.redundant.target.method.description=La anotación '@ApiStatus.NonExtendable' es redundante
jvm.inspections.api.override.only.description=El método ''{0}'' solo se puede sobrescribir
jvm.inspections.api.override.only.display.name=El método solo se puede sobrescribir
jvm.inspections.api.override.only.on.invalid.class.description={0} ''{1}'' está marcado con ''@ApiStatus.OverrideOnly'', pero no se puede extender ni se pueden sobrescribir sus métodos
jvm.inspections.api.override.only.on.invalid.method.description=El método ''{0}'' está marcado con ''@ApiStatus.OverrideOnly'', pero no se puede sobrescribir
jvm.inspections.api.override.only.on.invalid.method.redundant.description=La anotación '@ApiStatus.OverrideOnly' es redundante
jvm.inspections.assertequals.between.inconvertible.types.problem.descriptor=<code>#ref()</code> entre objetos de tipos no convertibles ''{0}'' y ''{1}'' #loc
jvm.inspections.assertnotequals.between.inconvertible.types.problem.descriptor=Aserción posiblemente redundante: se comparan tipos incompatibles ''{0}'' y ''{1}''
jvm.inspections.assertnotsame.between.inconvertible.types.problem.descriptor=Aserción redundante: se comparan tipos incompatibles ''{0}'' y ''{1}''
jvm.inspections.blocking.method.annotation.blocking=Anotaciones de bloqueo:
jvm.inspections.blocking.method.annotation.configure.add.blocking.title=Añadir anotación de bloqueo
jvm.inspections.blocking.method.annotation.configure.add.non-blocking.title=Añadir anotación no bloqueante
jvm.inspections.blocking.method.annotation.non-blocking=Anotaciones no bloqueantes:
jvm.inspections.blocking.method.consider.suspend.context.non.blocking=Considerar el contexto suspend de Kotlin como no bloqueante
jvm.inspections.blocking.method.consider.unknown.context.blocking=Considerar contextos desconocidos como bloqueantes
jvm.inspections.blocking.method.consider.unknown.context.nonblocking=Considerar los contextos desconocidos como no bloqueantes
jvm.inspections.blocking.method.display.name=Llamada posiblemente bloqueante en un contexto no bloqueante
jvm.inspections.blocking.method.in.implicit.ctr.problem.descriptor=Una llamada posiblemente bloqueante desde la llamada a un constructor implícito en un contexto no bloqueante podría provocar la inanición de hilos
jvm.inspections.blocking.method.in.implicit.ctr.problem.wildcard.descriptor=Una llamada posiblemente bloqueante desde una llamada a un constructor implícito en {0} podría provocar la inanición de hilos
jvm.inspections.blocking.method.intention.text=Activa la opción de inspección '{0}'.
jvm.inspections.blocking.method.problem.descriptor=Una llamada posiblemente bloqueante en un contexto no bloqueante podría provocar la inanición de hilos
jvm.inspections.blocking.method.problem.wildcard.descriptor=Una llamada posiblemente bloqueante en {0} podría provocar la inanición de hilos
jvm.inspections.collection.contains.url.problem.descriptor=''{0}'' puede contener objetos URL #loc
jvm.inspections.dependency.display.name=Dependencias de paquetes ilegales
jvm.inspections.dependency.edit.rules.family=Editar reglas de dependencia
jvm.inspections.dependency.edit.rules.text=Editar regla de dependencia "{0} "
jvm.inspections.dependency.intention.description=Abre un diálogo para configurar las reglas de dependencia entre ámbitos.
jvm.inspections.dependency.on.internal.display.name=Dependencia ilegal de un paquete interno
jvm.inspections.dependency.violator.problem.descriptor=Se infringe la regla de dependencia ''{0}.''
jvm.inspections.equals.hashcode.called.on.url.display.name=Llamada a 'equals()' o 'hashCode()' en un objeto 'URL'
jvm.inspections.equals.hashcode.called.on.url.problem.descriptor=Llamada a ''{0}'' en un objeto URL
jvm.inspections.group.name=Lenguajes JVM
jvm.inspections.logging.frameworks.group.name=Registro
jvm.inspections.missing.deprecated.annotation.on.scheduled.for.removal.api.description=Las API programadas para su eliminación también deben marcarse con la anotación '@Deprecated'
jvm.inspections.missing.deprecated.annotation.on.scheduled.for.removal.api.display.name=Falta la anotación '@Deprecated' en la API programada para su eliminación
jvm.inspections.must.already.be.removed.api.current.version.description=La API debe eliminarse en la versión actual {0}
jvm.inspections.must.already.be.removed.api.display.name=La API ya debe haberse eliminado
jvm.inspections.must.already.be.removed.api.earlier.version.description=La API debería haberse eliminado en la versión {0}, pero la versión actual es {1}
jvm.inspections.scheduled.for.removal.api.is.declared.in.marked.api=''{0}'' se declara en {1} ''{2}'' programado para su eliminación en {3}
jvm.inspections.scheduled.for.removal.api.is.marked.itself=''{0}'' está programado para su eliminación en {1}
jvm.inspections.scheduled.for.removal.future.version=Una versión futura
jvm.inspections.scheduled.for.removal.method.overridden.declared.in.marked.api=El método sobreescrito ''{0}'' está declarado en {1} ''{2}'' cuya eliminación está programada para {3}
jvm.inspections.scheduled.for.removal.method.overridden.marked.itself=El método sobrescrito ''{0}'' está programado para su eliminación en {1}
jvm.inspections.scheduled.for.removal.predefined.version=Versión {0}
jvm.inspections.scheduled.for.removal.scheduled.for.removal.type.is.used.in.signature.of.referenced.api=''{0}'' está programado para su eliminación porque su firma hace referencia a {1} ''{2}'' cuya eliminación está programada en {3}
jvm.inspections.serializable.class.without.serialversionuid.display.name=Clase serializable sin 'serialVersionUID'
jvm.inspections.serializable.class.without.serialversionuid.problem.descriptor=<code>#ref</code> no define un campo 'serialVersionUID' #loc
jvm.inspections.source.to.sink.flow.assigned.unknown=Se asigna una cadena desconocida a una variable segura
jvm.inspections.source.to.sink.flow.assigned.unsafe=Se asigna una cadena no segura a una variable segura
jvm.inspections.source.to.sink.flow.common.unknown=Se utiliza una cadena desconocida en un contexto seguro
jvm.inspections.source.to.sink.flow.common.unsafe=Se utiliza una cadena no segura en un contexto seguro
jvm.inspections.source.to.sink.flow.display.name=Se pasa una cadena no segura a un método seguro
jvm.inspections.source.to.sink.flow.passed.unknown=Se utiliza una cadena desconocida como parámetro seguro
jvm.inspections.source.to.sink.flow.passed.unsafe=Se utiliza una cadena no segura como parámetro seguro
jvm.inspections.source.to.sink.flow.returned.unknown=Se devuelve una cadena desconocida desde un método seguro
jvm.inspections.source.to.sink.flow.returned.unsafe=Se devuelve una cadena no segura desde un método seguro
jvm.inspections.source.to.sink.flow.too.complex=Demasiado complejo para comprobar si la cadena es segura en un contexto seguro
jvm.inspections.source.unsafe.to.sink.flow.check.private.methods=Considerar los parámetros de los métodos privados como seguros
jvm.inspections.source.unsafe.to.sink.flow.check.private.methods.comment=Si se habilita, los parámetros de los métodos privados se consideran seguros; de lo contrario, se considerarán como desconocidos.
jvm.inspections.source.unsafe.to.sink.flow.check.warn.if.complex=Informar si el caso es demasiado complejo para comprobar
jvm.inspections.source.unsafe.to.sink.flow.check.warn.if.complex.comment=Informar sobre objetos que no se pueden comprobar debido a su complejidad
jvm.inspections.source.unsafe.to.sink.flow.checked.types=Tipos comprobados:
jvm.inspections.source.unsafe.to.sink.flow.config=Se añadirá la anotación no contaminada a la configuración de la inspección para el elemento ''{0}''
jvm.inspections.source.unsafe.to.sink.flow.depth.inside=Profundidad de análisis dentro del método:
jvm.inspections.source.unsafe.to.sink.flow.impossible=La anotación ''Untainted'' no es compatible con el elemento ''{0}''. El elemento se omitirá
jvm.inspections.source.unsafe.to.sink.flow.index.parameter=Índice del parámetro
jvm.inspections.source.unsafe.to.sink.flow.mark.as.safe.command.name=Marcar como que requiere validación
jvm.inspections.source.unsafe.to.sink.flow.mark.as.safe.family=Marcar como que requiere validación
jvm.inspections.source.unsafe.to.sink.flow.mark.as.safe.text=Marcar elementos como que requieren validación
jvm.inspections.source.unsafe.to.sink.flow.not.number=No es un número
jvm.inspections.source.unsafe.to.sink.flow.place.class.column.title=Nombre de clase del contexto
jvm.inspections.source.unsafe.to.sink.flow.place.method.column.title=Expresión regular del nombre del método del contexto
jvm.inspections.source.unsafe.to.sink.flow.preview=Añadir anotación '@Untainted'
jvm.inspections.source.unsafe.to.sink.flow.preview.propagate=Mostrar árbol de propagación
jvm.inspections.source.unsafe.to.sink.flow.propagate.safe.family=Árbol de propagación
jvm.inspections.source.unsafe.to.sink.flow.propagate.safe.preview=Abre una ventana de herramientas para comprobar la propagación de la anotación segura
jvm.inspections.source.unsafe.to.sink.flow.propagate.safe.text=Mostrar el árbol de propagación desde aquí
jvm.inspections.source.unsafe.to.sink.flow.propagate.safe.toolwindow.annotate=Anotar todo excepto los excluidos
jvm.inspections.source.unsafe.to.sink.flow.propagate.safe.toolwindow.title=Miembros inseguros
jvm.inspections.source.unsafe.to.sink.flow.propagate.safe.toolwindow.unsafe.flow=Flujo no seguro
jvm.inspections.source.unsafe.to.sink.flow.qualifier.cleaner.arguments=Argumentos
jvm.inspections.source.unsafe.to.sink.flow.qualifier.cleaner.classes=Clases
jvm.inspections.source.unsafe.to.sink.flow.qualifier.cleaner.comment=Estos métodos marcan los calificadores como 'untainted' (los argumentos deben estar separados por comas)
jvm.inspections.source.unsafe.to.sink.flow.qualifier.cleaner.methods=Métodos
jvm.inspections.source.unsafe.to.sink.flow.qualifier.cleaner.table=Métodos para limpiar calificadores:
jvm.inspections.source.unsafe.to.sink.flow.safe.class=Clases seguras:
jvm.inspections.source.unsafe.to.sink.flow.safe.class.comment=Estas clases no pueden contener datos no seguros
jvm.inspections.source.unsafe.to.sink.flow.show.unknown.object=Reportar objeto desconocido
jvm.inspections.source.unsafe.to.sink.flow.show.unsafe.object=Reportar objeto no seguro
jvm.inspections.source.unsafe.to.sink.flow.tainted.annotations=Anotaciones contaminadas:
jvm.inspections.source.unsafe.to.sink.flow.tainted.annotations.comment=Estas anotaciones se utilizarán como anotaciones '@Tainted' durante el análisis
jvm.inspections.source.unsafe.to.sink.flow.tainted.methods=Métodos contaminados:
jvm.inspections.source.unsafe.to.sink.flow.tainted.methods.comment=Se considera que estos métodos devuelven únicamente objetos no seguros
jvm.inspections.source.unsafe.to.sink.flow.tainted.parameters=Parámetros contaminados:
jvm.inspections.source.unsafe.to.sink.flow.tainted.parameters.comment=Estos parámetros se consideran con la anotación '@Tainted'
jvm.inspections.source.unsafe.to.sink.flow.untainted.annotations=Anotaciones no contaminadas:
jvm.inspections.source.unsafe.to.sink.flow.untainted.annotations.comment=Estas anotaciones se utilizarán como anotaciones '@Untainted' durante el análisis. La primera anotación de esta lista se utilizará para la propagación si existe en el classpath.
jvm.inspections.source.unsafe.to.sink.flow.untainted.fields=Campos no contaminados:
jvm.inspections.source.unsafe.to.sink.flow.untainted.fields.comment=Se considera que estos campos contienen únicamente objetos seguros
jvm.inspections.source.unsafe.to.sink.flow.untainted.fields.name=Nombre del campo
jvm.inspections.source.unsafe.to.sink.flow.untainted.methods=Métodos no contaminados:
jvm.inspections.source.unsafe.to.sink.flow.untainted.methods.comment=Se considera que estos métodos solo devuelven objetos seguros.
jvm.inspections.source.unsafe.to.sink.flow.untainted.parameters=Parámetros no contaminados:
jvm.inspections.source.unsafe.to.sink.flow.untainted.parameters.comment=Se considera que estos parámetros tienen la anotación '@Untainted'
jvm.inspections.source.unsafe.to.sink.flow.untainted.process.as.qualifier.arguments=Considerar los métodos externos como no contaminados si los receptores y los argumentos no están contaminados
jvm.inspections.source.unsafe.to.sink.flow.untainted.process.as.qualifier.arguments.comment=Si está habilitado, los métodos externos fuera de la clase actual se considerarán seguros si sus receptores y argumentos son seguros. En algunos casos, no es aplicable, pero puede ser útil para clases sin estado. De lo contrario, todos los métodos externos se considerarán no seguros.
jvm.inspections.string.touppercase.tolowercase.without.locale.description=Se llamó a <code>String.{0}()</code> sin especificar un Locale usando cadenas internacionalizadas #loc
jvm.inspections.system.get.property.display.name=La llamada a 'System.getProperty(str)' podría simplificarse
jvm.inspections.system.get.property.problem.descriptor=La llamada a <code>#ref</code> puede simplificarse para ''{0}''
jvm.inspections.test.case.in.product.source.display.name=Prueba en el código fuente del producto
jvm.inspections.test.case.in.product.source.problem.descriptor=El caso de prueba <code>#ref</code> probablemente debería estar ubicado en un árbol de fuentes de prueba #loc
jvm.inspections.test.case.with.constructor.display.name=TestCase con constructores no triviales
jvm.inspections.test.case.with.constructor.problem.descriptor=Lógica de inicialización en el constructor <code>#ref()</code> en lugar del método de ciclo de vida 'setup()' #loc
jvm.inspections.test.case.with.constructor.problem.descriptor.initializer=Lógica de inicialización en el inicializador en lugar del método del ciclo de vida 'setup()'
jvm.inspections.test.case.without.test.methods.display.name=Clase de prueba sin pruebas
jvm.inspections.test.case.without.test.methods.option=Ignorar casos de prueba que tienen superclases con métodos de prueba
jvm.inspections.test.case.without.test.methods.problem.descriptor=La clase de prueba <code>#ref</code> no tiene pruebas #loc
jvm.inspections.test.frameworks.group.name=Frameworks de prueba
jvm.inspections.test.method.in.product.source.problem.descriptor=El método de prueba <code>#ref()</code> probablemente debería estar ubicado en un árbol de fuentes de prueba #loc
jvm.inspections.test.method.without.assertion.display.name=Método de prueba sin aserciones
jvm.inspections.test.method.without.assertion.problem.descriptor=El método de prueba <code>#ref()</code> no contiene aserciones #loc
jvm.inspections.testonly.class.reference=Se hace referencia a una clase exclusiva para pruebas en el código de producción
jvm.inspections.testonly.display.name=Uso de código exclusivo para pruebas en código de producción
jvm.inspections.testonly.field.reference=Se hace referencia a un campo exclusivo para pruebas en el código de producción
jvm.inspections.testonly.method.call=Se llama a un método exclusivo de pruebas en el código de producción
jvm.inspections.testonly.visiblefortesting=@VisibleForTesting tiene poco sentido en el código @TestOnly
jvm.inspections.thread.run.display.name=Llamada a 'Thread.run()'
jvm.inspections.unstable.api.usage.annotations.list=Anotaciones de API inestable:
jvm.inspections.unstable.api.usage.api.is.declared.in.unstable.api=''{0}'' se declara en el {1} inestable ''{2}'' marcado con @{3}
jvm.inspections.unstable.api.usage.api.is.marked.unstable.itself=''{0}'' está marcado como inestable con @{1}
jvm.inspections.unstable.api.usage.display.name=Uso de API inestable
jvm.inspections.unstable.api.usage.ignore.declared.inside.this.project=Ignorar API declarada en este proyecto
jvm.inspections.unstable.api.usage.ignore.inside.imports=Ignorar dentro de las importaciones
jvm.inspections.unstable.api.usage.overridden.method.is.declared.in.unstable.api=El método sobrescrito ''{0}'' está declarado en {1} inestable ''{2}'' marcado con @{3}
jvm.inspections.unstable.api.usage.overridden.method.is.marked.unstable.itself=El método sobrescrito ''{0}'' está marcado como inestable con @{1}
jvm.inspections.unstable.api.usage.unstable.type.is.used.in.signature.of.referenced.api=''{0}'' es inestable porque su firma hace referencia a {1} ''{2}'' inestable marcado con @{3}
jvm.inspections.unstable.type.used.in.class.signature.description=La clase debe marcarse con la anotación ''@{0}'' porque su declaración hace referencia al tipo inestable ''{1}''
jvm.inspections.unstable.type.used.in.field.signature.description=El campo debe marcarse con la anotación ''@{0}'' porque su tipo hace referencia al tipo inestable ''{1}''
jvm.inspections.unstable.type.used.in.method.signature.description=El método debe marcarse con la anotación ''@{0}'' porque su firma hace referencia al tipo inestable ''{1}''
jvm.inspections.unstable.type.used.in.signature.display.name=Tipo inestable utilizado en la firma
jvm.inspections.usages.of.obsolete.api.description=Se utiliza una API obsoleta
jvm.inspections.usages.of.obsolete.api.display.name=Usos de ApiStatus.@Obsolete
jvm.options.general.color.descriptor.logging.string.placeholder=Cadena de registro//Marcador de posición
propagated.from=Motivo de propagación:
propagated.to=Destino a propagar:
remove.suppress.comment.fix.family.name=Eliminar //{0}
title.uast=UAST
