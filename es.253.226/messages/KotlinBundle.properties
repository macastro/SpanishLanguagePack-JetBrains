0.1.be.lifted.out.of.2='{0}'' se puede extraer de ''{1}'
0.1.could.be.private={0} ''{1}'' podría ser private
0.1.is.never.used={0} ''{1}'' no se utiliza nunca
0.already.exists={0} ya existe
0.always.returns.non.null.type=''{0}'' siempre devuelve un tipo no nulo
0.call.could.be.simplified.to.1=La llamada {0} se podría simplificar a {1}
0.call.should.be.replaced.with.array.literal=La llamada a ''{0}'' debe reemplazarse por un literal de array […]
0.from.1={0} de {1}
0.has.detected.1.code.fragments.in.2.that.can.be.replaced.with.3={0} ha detectado {1} {1,choice,1#fragmento|2#fragmentos} de código en {2} que se {1,choice,1#puede|2#pueden} reemplazar con {3}. ¿Desea {1,choice,1#revisarlo y reemplazarlo|2#revisarlos y reemplazarlos}?
0.has.empty.body=''{0}'' tiene un cuerpo vacío
0.in.1.will.require.class.instance=''{0}'' en {1} requerirá una instancia de clase
0.interface.1={0} interfaz ''{1}''
0.is.always.non.null.type=''{0}'' siempre es de tipo no nulo
0.is.expected.to.be.used.since.kotlin.1.3=Se espera que ''{0}'' se utilice a partir de Kotlin 1.3
0.is.missing.documentation={0} no tiene documentación
0.is.overridden.by.declaration.s.in.a.subclass={0} está sobrescrito por declaración(es) en una subclase
0.may.break.code={0} (puede romper el código)
0.on.a.readonly.1.creates.a.new.1.under.the.hood=''{0}'' en un {1} de solo lectura crea un nuevo {1} internamente
0.references.type.parameters.of.the.containing.class={0} hace referencia a los parámetros de tipo de la clase contenedora
0.should.return.unit={0} debe devolver Unit
0.try.1.with.2.fails.and.3.verifications={0} [Intento {1} con {2} fallos y {3} verificaciones]
0.will.become.invisible.after.extraction={0} se volverá invisible después de la extracción
0.will.no.longer.be.accessible.after.extraction={0} ya no estará accesible después de la extracción
a.constructor.call.is.not.yet.supported=Aún no se admite la llamada al constructor
a.field.without.an.initializer.is.not.yet.supported=Aún no se admite un campo sin un inicializador
accessing.non.final.property.0.in.constructor=Acceso a la propiedad no final {0} en el constructor
action.CacheResetOnProcessCanceledToggleAction.text=Restablecer cachés en ProcessCanceledException
action.CheckComponentsUsageSearchAction.text=Verificar búsqueda de uso de funciones de componentes
action.ConfigureKotlinInProject.text=Configurar Kotlin en el proyecto
action.ConvertJavaToKotlin.text=Convertir archivo Java a archivo Kotlin
action.CopyAsDiagnosticTest.text=Copiar el archivo actual como prueba de diagnóstico
action.CopyKotlinProjectInformation.text=Copiar el resumen del proyecto Kotlin al portapapeles
action.DecompileKotlinToJava.text=Descompilar Kotlin a Java
action.DumbModeTremble.text=Modo Dumb tembloroso
action.ExtractFunction.text=Extraer función…(_F)
action.ExtractFunctionToScope.text=Extraer función al ámbito…(_S)
action.FindImplicitNothingAction.text=Buscar llamadas implícitas a Nothing
action.GotoSuperClass.MainMenu.text=Superclase(_U)
action.GotoSuperClass.text=Ir a la superclase(_U)
action.GotoSuperInterface.MainMenu.text=Superinterfaz(_U)
action.GotoSuperInterface.text=Ir a la s_úper interfaz(_U)
action.GotoSuperProperty.MainMenu.text=S_úper propiedad(_U)
action.GotoSuperProperty.description=Navega a la declaración de una propiedad que la propiedad actual sobrescribe o implementa
action.GotoSuperProperty.text=Ir a la superpropiedad(_U)
action.HighlightingBenchmarkAction.text=Resaltado de benchmark
action.InspectBreakpointApplicability.text=Inspeccionar aplicabilidad del punto de interrupción
action.IntroduceProperty.text=Introducir propiedad…(_R)
action.IntroduceTypeAlias.text=Introducir alias de tipo…(_A)
action.IntroduceTypeParameter.text=Introducir parámetro de tipo…(_Y)
action.Kotlin.ClearScratch.description=Limpiar el scratch de Kotlin
action.Kotlin.ClearScratch.text=Limpiar scratch de Kotlin
action.Kotlin.Gradle.ShowDslLogs.text=Mostrar logs del DSL de Kotlin Gradle
action.Kotlin.NewFile.description=Crea una nueva clase o archivo Kotlin
action.Kotlin.NewFile.text=Clase/archivo de Kotlin
action.Kotlin.NewScript.description=Crea un nuevo script o una hoja de trabajo de Kotlin
action.Kotlin.NewScript.text=Script de Kotlin
action.Kotlin.RunScratch.description=Ejecutar scratch de Kotlin
action.Kotlin.RunScratch.text=Ejecutar scratch de Kotlin
action.Kotlin.StopScratch.description=Detener la ejecución de scratch
action.Kotlin.StopScratch.text=Detener ejecución de scratch
action.Kotlin.XDebugger.CoroutinesDump.text=Obtener volcado de corrutinas
action.Kotlin.XDebugger.ToggleKotlinVariableView.text=Mostrar solo variables de Kotlin
action.KotlinCodeMigration.text=Ejecutar migraciones de código
action.KotlinCodeMigrationToggle.text=Habilitar detección de migraciones
action.KotlinConfigurePlugin.text=Configurar el plugin de Kotlin
action.KotlinConsoleREPL.text=Kotlin REPL (experimental)
action.KotlinFormattingSettingsStatusAction.text=Información de configuración del formateador
action.KotlinGenerateDataMethod.text=Función de parámetros
action.KotlinGenerateEqualsAndHashCode.text=Equals() y hashCode()
action.KotlinGenerateMavenCompileExecutionAction.text=Ejecución de la compilación de Kotlin
action.KotlinGenerateMavenPluginAction.text=Plugin de Kotlin
action.KotlinGenerateMavenTestCompileExecutionAction.text=Ejecución de compilación de pruebas de Kotlin
action.KotlinGenerateSecondaryConstructor.text=Constructor secundario
action.KotlinGenerateSetUpMethod.text=Función SetUp
action.KotlinGenerateTearDownMethod.text=Función TearDown
action.KotlinGenerateTestMethod.text=Función de prueba
action.KotlinGenerateToString.text=toString()
action.KotlinShellExecute.description=Ejecutar código Kotlin en la consola
action.KotlinShellExecute.text=Ejecutar código Kotlin
action.KotlinThrowException.text=Lanzar un error del plugin de Kotlin
action.LibraryToSourceDependencySupportToggleAction.text=Alternar el soporte de dependencia de biblioteca a fuente
action.LocalCompletionBenchmarkAction.text=Escenario local
action.PrintOutNotPropertyMatches.text=Buscar candidatos que no sean propiedades
action.ShowKotlinBytecode.text=Mostrar bytecode de Kotlin
action.StoredExceptionsThrowToggleAction.text=Lanzar PCE en caché
action.TestMoveRefactiringAction.text=Probar refactorización de movimiento en el proyecto abierto
action.TopLevelCompletionBenchmarkAction.text=Escenario de nivel superior
action.add.import.chooser.title=Importaciones
action.generate.equals.choose.equals=Seleccionar las propiedades que se incluirán en 'equals()'
action.generate.equals.choose.hashcode=Seleccionar las propiedades que se incluirán en 'hashCode()'
action.generate.functions.already.defined=Las funciones {0} ya están definidas para la clase {1}. ¿Desea eliminarlas y continuar?
action.generate.secondary.constructor.choose.properties=Seleccionar propiedades para inicializar mediante el constructor
action.generate.secondary.constructor.error.already.exists=El constructor ya existe
action.generate.super.type=Especificar supertipo explícitamente
action.generate.test.support.choose.framework=Elegir framework
action.generate.test.support.choose.test.name=Seleccionar nombre de la prueba:
action.generate.test.support.edit.template=Editar plantilla
action.generate.test.support.error.cant.convert.java.template=No se pudo convertir la plantilla Java a Kotlin
action.generate.test.support.error.cant.generate.method=No se puede generar el método: {0}
action.generate.test.support.error.no.template.found=No se encontró ninguna plantilla para {0}:{1}
action.generate.tostring.choose.implementation=Seleccionar implementación:
action.generate.tostring.choose.implementation.mnemonic=i
action.generate.tostring.generate.super.call=Generar llamada a super.toString()
action.generate.tostring.generate.super.call.mnemonic=s
action.generate.tostring.name=Generar 'toString()'
action.generate.tostring.template.multiple=Múltiples plantillas con concatenación
action.generate.tostring.template.multiple.with.super=Múltiples plantillas con concatenación y llamada a super
action.generate.tostring.template.single=Plantilla única
action.generate.tostring.template.single.with.super=Plantilla única con llamada a super
action.hints.settings.text=Configuración de sugerencias…
action.j2k.correction.errors.multiple=''{0}'' y otros {1} archivos Java contienen errores de sintaxis, el resultado de la conversión puede ser incorrecto
action.j2k.correction.errors.single=''{0}'' contiene errores de sintaxis, el resultado de la conversión puede ser incorrecto
action.j2k.correction.investigate=Investigar errores
action.j2k.correction.proceed=Continuar con la conversión
action.j2k.correction.required=Es posible que parte del código del resto de su proyecto requiera correcciones tras realizar esta conversión. ¿Desea buscar dicho código y corregirlo también?
action.j2k.error.cant.find.document=No se pudo encontrar el documento de ''{0}''
action.j2k.error.cant.save.result=No se pudo guardar el resultado de la conversión: {0}
action.j2k.error.nothing.to.convert=Nada que convertir:<br>No se encontraron archivos Java con permiso de escritura
action.j2k.error.read.only=El archivo ''{0}'' es de solo lectura
action.j2k.name=Convertir Java a Kotlin
action.j2k.task.name=Convertir archivos de Java a Kotlin
action.move.method=Mover método…
action.new.file.dialog.annotation.title=Anotación
action.new.file.dialog.class.title=Clase
action.new.file.dialog.data.class.title=Clase de datos
action.new.file.dialog.enum.title=Clase enum
action.new.file.dialog.file.title=Archivo
action.new.file.dialog.interface.title=Interfaz
action.new.file.dialog.object.title=Objeto
action.new.file.dialog.sealed.class.title=Clase sellada
action.new.file.dialog.sealed.interface.title=Interfaz sellada
action.new.file.dialog.title=Nueva clase/archivo de Kotlin
action.new.file.error.empty.name=El nombre no puede estar vacío
action.new.file.error.empty.name.part=El nombre no puede tener partes vacías
action.new.script.dialog.script=Nuevo script de Kotlin
action.new.script.dialog.title=Nuevo archivo de script de Kotlin
action.new.script.name=Script de Kotlin
action.new.worksheet.name=Hoja de cálculo Kotlin
action.text.append=Anexar
action.text.cancel=Cancelar
action.text.continue=Continuar
action.text.install=Instalar
action.text.overwrite=Sobrescribir
action.usage.update.command=Actualización de usos
add.0.constructor.to.1=Añadir constructor {0} a ''{1}''
add.0.library=Añadir la biblioteca ''{0}''
add.0.to.argument=Añadir ''{0} ='' al argumento
add.an.opt.in.requirement.marker.compiler.argument=Añadir un argumento del compilador para el marcador de requisito de inclusión voluntaria
add.braces=Añadir llaves
add.braces.to.0.statement=Añadir llaves a la sentencia ''{0}''
add.braces.to.all.branches=Añadir llaves a todas las ramas
add.braces.to.if.all.statements=Añadir llaves a todas las sentencias 'if'
add.braces.to.when.all.entries=Añadir llaves a todas las entradas 'when'
add.braces.to.when.entry=Añadir llaves a la entrada 'when'
add.call.or.unwrap.type.fix.text=Añadir ''.{0}()'' al resultado de la función (¡rompe los sitios de uso!)
add.call.or.unwrap.type.fix.text1=Desempaquetar el tipo de retorno ''{0}'' (¡rompe los puntos de uso!)
add.clarifying.braces.to.nested.else.statement=Añadir llaves aclaratorias a la sentencia 'else' anidada
add.constructor.keyword=Añadir la palabra clave 'constructor'
add.constructor.parameters.from.0.1=Agregar parámetros del constructor desde {0}{1}
add.constructor.parameters.from.superclass=Añadir parámetros del constructor de la superclase
add.documentation.fix.text=Añadir documentación
add.empty.argument.list=Agregar lista de argumentos vacía
add.empty.brackets.after.primary.constructor=Añadir corchetes vacíos después del constructor primario
add.explicit.parameter.to.outer.lambda.fix.text=Añadir nombre de parámetro explícito a la lambda exterior
add.explicit.type.arguments=Añadir argumentos de tipo explícitos
add.external.keyword=Añadir palabra clave external
add.full.qualifier=Añadir calificador completo
add.fun.modifier.to.0=Añadir el modificador ''fun'' a ''{0}''
add.import.for.0=Añadir importación para ''{0}''
add.import.for.member=Añadir importación para el miembro
add.indices.to.for.loop=Añadir índices al bucle 'for'
add.initializer=Añadir inicializador
add.interpolation.prefix=Añadir prefijo de interpolación
add.jvminline.annotation=Añadir la anotación '@JvmInline'
add.jvmoverloads.annotation=Añadir anotación '@JvmOverloads'
add.jvmoverloads.annotation.to.0=Añadir la anotación ''@JvmOverloads'' a {0}
add.jvmstatic.annotation=Añadir la anotación '@JvmStatic'
add.kotlin.coroutines=Añadir biblioteca de corrutinas de Kotlin
add.kotlin.coroutines.description=Añadir la biblioteca Kotlin Coroutines
add.labeled.return.to.last.expression.in.a.lambda=Añadir un return con etiqueta a la última expresión en una lambda
add.method=Añadir método
add.method.0.to.1=Añadir el método ''{0}'' a ''{1}''
add.missing.class.keyword=Añadir la palabra clave 'class' faltante
add.missing.component=Añadir el componente de desestructuración faltante
add.modifier=Añadir modificador
add.name.to.argument=Añadir nombre al argumento
add.names.in.comment.to.call.arguments=Añadir nombres en comentarios a los argumentos de la llamada
add.names.to.call.arguments=Agregar nombres a los argumentos de llamada
add.names.to.this.argument.and.following.arguments=Agregar nombres a este argumento y a todos los argumentos siguientes
add.operator.modifier=Añadir el modificador 'operator'
add.qualifier=Añadir calificador de enlace
add.qualifier.command=Agregar calificador de enlace
add.remaining.branches=Añadir las ramas restantes
add.replacewith.argument.to.specify.replacement.pattern=Añadir el argumento 'replaceWith' para especificar el patrón de reemplazo
add.return.at.0=Añadir ''return@{0}''
add.return.expression=Añadir expresión 'return'
add.source.retention=Añadir retención de ORIGEN
add.throws.annotation=Añadir anotación '@Throws'
add.underscores=Añadir guiones bajos
add.use.site.target=Añadir destino de sitio de uso
add.val.to.parameter.0=Añadir ''val'' al parámetro ''{0}''
add.val.var.to.parameter.0=Añadir ''val'' o ''var'' al parámetro ''{0}''
add.val.var.to.primary.constructor.parameter=Añadir 'val' o 'var' al parámetro del constructor primario
add.variance.fix.family.name=Agregar varianza
add.variance.fix.text=Agregar varianza ''{0}''
advanced.setting.kotlin.mpp.experimental=Habilitar funciones experimentales de IDE multiplataforma
advanced.setting.kotlin.mpp.experimental.description=Requiere reiniciar el IDE
all.expected.and.actual.classes.must.be.sealed.classes=Todas las clases esperadas y reales deben ser clases selladas.\n
all.inheritors.must.be.nested.objects.of.the.class.itself.and.may.not.inherit.from.other.classes.or.interfaces=Todos los herederos deben ser objetos anidados de la propia clase y no pueden heredar de otras clases o interfaces.\n
ambiguous.actuals.for.0={0} tiene múltiples declaraciones actual compatibles en el módulo {1}
ambiguous.coroutinecontext.due.to.coroutinescope.receiver.of.suspend.function=CoroutineContext ambiguo debido al receptor CoroutineScope de la función suspendida
ambiguous.non.local.break.or.continue=''{0}'' no local ambiguo (''{1}'' vs ''{2}''). Use etiquetas aclaratorias o añada el contrato ''callsInPlace''.
ambiguous.non.local.break.or.continue.display.name='break' o 'continue' no locales ambiguos
ambiguous.non.local.break.or.continue.use.label=''{0}'' no local ambiguo (''{1}'' vs ''{2}''). Use una etiqueta explícita.
ambiguous.non.local.break.or.continue.use.label.or.contract=''{0}'' no local ambiguo (''{1}'' frente a ''{2}''). Use una etiqueta explícita o añada un contrato ''callsInPlace'' a ''{3}''.
analyzed.0.classes.no.difference.found=Se han analizado {0} clases. No se encontraron diferencias.
analyzing.functions=Analizando funciones…
analyzing.members=Analizando miembros…
and.delete.initializer=Y eliminar el inicializador
apply.also.to.internal.members=Aplicar también a los miembros internos
apply.also.to.private.members=Aplicar también a los miembros privados
apply.in.the.project.0=Aplicar en el proyecto: {0}
apply.only.to.public.or.protected.members=Aplicar solo a los miembros public o protected
applying.0=Aplicando ''{0}''
array.property.in.data.class.it.s.recommended.to.override.equals.hashcode=Propiedad de tipo 'Array' en una clase 'data': se recomienda sobrescribir 'equals()' y 'hashCode()'
assert.should.be.replaced.with.operator=La aserción debe reemplazarse por un operador
assign.backing.field.fix.text=Asignar campo de respaldo
assigned.value.is.never.read=El valor asignado nunca se lee
base.property.0=Propiedad base {0}
big.decimal.equals=Se llamó a 'equals()' en 'BigDecimal'
big.decimal.equals.problem.descriptor=<code>#ref()</code> entre valores de BigDecimal probablemente debería ser 'compareTo()' #loc
block.body=Cuerpo del bloque
boolean.literal.argument.without.parameter.name=Argumento literal booleano sin nombre de parámetro
boolean.property.in.external.interface.should.be.nullable=La propiedad booleana en la interfaz externa debe ser anulable
breadcrumbs.tooltip.indexing=Indexando…
button.add.package=Añadir paquete
button.rename.base=Renombrar base
button.rename.current=Renombrar actual
button.text.move.nested.class.0.to.another.class=&Mover la clase anidada {0} a otra clase
button.text.move.nested.class.0.to.upper.level=Mover la clase a&nidada {0} al nivel superior
call.chain.length.to.transform=Longitud de la cadena de llamadas a transformar:
call.chain.on.collection.could.be.converted.into.sequence.to.improve.performance=La cadena de llamadas en una colección podría convertirse en 'Sequence' para mejorar el rendimiento
call.chain.on.collection.type.may.be.simplified=La cadena de llamadas en un tipo de colección puede simplificarse
call.is.replaceable.with.another.scope.function=La llamada se puede reemplazar por otra función de ámbito
call.of.inline.function.with.nullable.extension.receiver.can.cause.npe.in.kotlin.1.2=La llamada a 'inline fun' con un receptor que admite valores nulos puede causar 'NPE' hasta Kotlin 1.2
call.of.java.mutator.0.on.immutable.kotlin.collection.1=Llamada al mutador de Java ''{0}'' en la colección inmutable de Kotlin ''{1}''
call.on.collection.type.may.be.reduced=La llamada en el tipo de colección puede reducirse
call.on.not.null.type.may.be.reduced=La llamada en un tipo no nulo puede reducirse
call.replaceable.with.binary.operator=La llamada puede reemplazarse por un operador binario
call.with.arguments.will.be.skipped.0=Se omitirá la llamada con argumentos: {0}
callable.reference.fix.family.name=Añadir ''{0}'' explícito
callable.reference.transformation.is.not.supported.0=No se admite la transformación de referencia invocable: {0}
calling.non.final.function.0.in.constructor=Llamada a la función no final {0} en el constructor
calls.with.explicit.extension.receiver.won.t.be.processed.0=No se procesarán las llamadas con un receptor de extensión explícito: {0}
can.be.converted.to.to=La inicialización explícita de 'Pair' puede reemplazarse por una llamada infija a 'to()'
can.be.joined.with.assignment=Se puede unir con la asignación
can.convert.argument.to.set=El argumento se puede convertir a 'Set' para mejorar el rendimiento
can.t.finish.while.indexing.is.in.progress=No se puede finalizar mientras la indexación está en curso
can.t.modify.0=No se puede modificar {0}
can.t.replace.foreign.reference.with.call.expression.0=No se puede reemplazar la referencia externa con una expresión de llamada: {0}
can.t.replace.non.kotlin.reference.with.call.expression.0=No se puede reemplazar una referencia que no sea de Kotlin por una expresión de llamada: {0}
cannot.extract.super.call=No se puede extraer la llamada a super
cannot.get.or.create.results.file=No se puede obtener o crear el archivo de resultados
cannot.get.project.root.directory=No se puede obtener el directorio raíz del proyecto
cannot.infer.type.for.this.declaration=No se puede inferir el tipo para esta declaración
cannot.inline.property.with.accessor.s.and.backing.field=No se puede realizar el inline de la propiedad con accesor(es) y campo de respaldo
cannot.introduce.parameter.of.0.type=No se puede introducir un parámetro de tipo ''{0}''
cannot.refactor.expression.has.unit.type=No se puede introducir una expresión de tipo unit
cannot.refactor.no.container=No se puede refactorizar en esta ubicación.
cannot.refactor.no.expression=No se puede realizar la refactorización sin una expresión
cannot.refactor.no.type=No se puede realizar la refactorización sin un tipo
cannot.refactor.not.expression=No se pudo encontrar una expresión para introducir
cannot.refactor.package.expression=No se puede introducir una referencia de paquete
cannot.refactor.syntax.errors=No se puede refactorizar debido a código erróneo
cannot.refactor.synthesized.function=No se puede refactorizar la función sintetizada
cascade.if.should.be.replaced.with.when=El 'if' en cascada debería reemplazarse por 'when'
cast.explicitly.fix.text=Convertir explícitamente
category.class=Kotlin/Basado en clases
category.comments=Kotlin/Comentarios, KDoc y metadatos
category.declaration=Kotlin/Declaraciones
category.expressions=Kotlin/Expresiones
category.interesting=Kotlin/Interés
category.operators=Kotlin/Operadores
change.all.usages.of.0.in.this.file.to.1=Cambiar todos los usos de ''{0}'' en este archivo a ''{1}''
change.all.usages.of.0.in.this.file.to.a.kotlin.class=Cambiar todos los usos de ''{0}'' en este archivo por una clase Kotlin
change.existent.retention.to.source=Cambiar la retención existente a SOURCE
change.main.function.return.type.to.unit.fix.text=Añadir tipo de retorno Unit explícito
change.main.function.return.type.to.unit.fix.text2=Cambiar el tipo de retorno a Unit
change.signature.conflict.text.kotlin.default.parameter.in.non.kotlin.files=Es posible que el parámetro predeterminado no sea compatible con otros lenguajes
change.signature.conflict.text.kotlin.default.value.in.non.kotlin.files=El valor de llamada predeterminado de Kotlin puede dar lugar a código incorrecto en otros lenguajes
change.to.0=Cambiar a ''{0}''
change.to.constructor.invocation=Cambiar a invocación de constructor
change.to.correct.long.suffix.l=Cambiar al sufijo long 'L' correcto
change.to.correct.primitive.type=Cambiar al tipo primitivo correcto
change.to.kotlin.class=Cambiar a clase Kotlin
change.to.val=Cambiar a 'val'
change.to.var=Cambiar a 'var'
change.type.of.0.to.1=Cambiar el tipo de {0} a ''{1}''
change.type.to.0=Cambiar tipo a ''{0}''
change.type.to.mutable.fix.text=Cambiar tipo a mutable
change.visibility=Cambiar visibilidad
change.visibility.modifier=Cambiar modificador de visibilidad
change.visibility.popup=Cambiar visibilidad
checkbox.collapse.to.expression.body=Contraer a cuerpo de expresión
checkbox.text.declare.with.var=Declarar con &var
checkbox.text.delete.empty.source.files=&Eliminar archivos fuente vacíos
checkbox.text.extension.property=Propiedad de e&xtensión:
checkbox.text.introduce.default.value=Introducir valor por &defecto
checkbox.text.open.moved.files.in.editor=Abrir miembro movido en el editor
checkbox.text.replace.all.occurrences.0=&Reemplazar todas las ocurrencias ({0})
checkbox.text.search.references=Buscar &referencias
checkbox.text.specify.type.explicitly=Especificar &tipo explícitamente
checkbox.text.update.package.directive=Actualizar la directiva de paquete (archivos Kotlin)
checking.data.class.0.of.1=Comprobando clase de datos {0} de {1}…
checking.data.classes=Comprobando clases de datos
choose.actual.members.title=Seleccionar miembros reales
choose.actual.module=Seleccionar módulos para Actual
choose.an.appropriate.kotlin.class=Seleccionar una clase de Kotlin adecuada
choose.class.container=Seleccionar contenedor de clases
choose.target.class.or.interface=Seleccionar clase o interfaz de destino
class=Clase
class.0.already.contains.1=La clase ''{0}'' ya contiene {1}
class.name.prompt=Nombre de la clase (&N):
class.should.be.external.interface=La clase debe ser una interfaz externa
clipboard.content.copied.from.java.file.do.you.want.to.convert.it.to.kotlin.code=Se ha copiado contenido del portapapeles desde un archivo Java. ¿Desea convertirlo a código Kotlin?
code.insight.workspace.settings.title=Kotlin
codestyle.layout.import.aliases.separately=Importar alias por separado
codestyle.name.kotlin=Kotlin
column.name.context.parameter=Parámetro de contexto:
column.name.default.parameter=Parámetro predeterminado:
column.name.receiver=Receptor:
column.name.val.var=Val/Var
command.generate.test.support.generate.test.function=Generar función de prueba
command.move.declarations=Mover declaraciones
comment=Comentario
companion.object.already.contains.0=El objeto compañero ya contiene {0}
compiling.project=Compilando el proyecto…
condition.is.always.0=La condición siempre es ''{0}''
configuration.kotlin.code.style.group.name=Estilo de código oficial de Kotlin disponible
configuration.maven.group.name=Importación de proyectos Kotlin Maven
configuration.message.enter.fully.qualified.method.name=Introduzca un nombre de método completamente calificado:
configuration.migration.group.name=Kotlin: Migraciones a una versión más reciente disponibles
configuration.name.method=Método
configuration.status.text.installing=Instalando…
configuration.title.add.exclusion=Añadir exclusión
configuration.title.edit.exclusion=Editar exclusión
const.might.be.used.instead.of.jvmfield=Podría usarse 'const' en lugar de '@JvmField'
const.property=Propiedad const
constructor=Constructor
constructor.has.non.null.self.reference.parameter=El constructor tiene un parámetro de autorreferencia no nulo
constructor.parameter.is.never.used.as.a.property=El parámetro del constructor nunca se usa como propiedad
context.default=Predeterminado
context.property.getter.or.setter=Propiedad con getter/setter explícito
convert.0.to.1=Convertir ''{0}'' a ''{1}''
convert.anonymous.function.to.lambda.expression=Convertir función anónima en una expresión lambda
convert.argument.to.set.fix.text=Convertir argumento a 'Set'
convert.body.to.expression=Convertir cuerpo a expresión
convert.boolean.const.to.elvis=Convertir Boolean? == const a elvis
convert.call.chain.into.sequence.fix.text=Convertir cadena de llamadas en 'Sequence'
convert.class.0.to.kotlin=Convertir la clase ''{0}'' a Kotlin
convert.collection.constructor.to.function=Convertir el constructor de colección en función
convert.comparisons.to.range.check=Convertir comparaciones a ''{0}''
convert.concatenation.to.build.string=Convertir concatenación en una llamada a 'buildString'
convert.concatenation.to.raw.string=Convertir concatenación en cadena raw
convert.concatenation.to.template=Convertir concatenación en plantilla
convert.concatenation.to.template.before.text=La concatenación de 'String' se puede convertir en una plantilla
convert.context.parameter.to.receiver.parameter=Convertir el parámetro de contexto en receptor
convert.context.parameter.to.regular.parameter=Convertir el parámetro de contexto en un parámetro de valor
convert.expression.to.0=Convertir expresión a ''{0}''
convert.expression.to.0.by.inserting.1=Convertir la expresión a ''{0}'' insertando ''.{1}''
convert.extension.function.type.to.regular.function.type=Convertir tipo de función de extensión a tipo de función regular
convert.extension.property.initializer.to.getter=Convertir inicializador de propiedad de extensión a getter
convert.from.class.to.kclass=Convertir 'KClass' a 'Class'
convert.function.to.property=Convertir función en propiedad
convert.function.type.parameter.to.receiver=Convertir parámetro de tipo de función a receptor
convert.function.type.receiver.to.parameter=Convertir el receptor de tipo de función en parámetro
convert.lambda.expression.to.anonymous.function=Convertir expresión lambda en función anónima
convert.lambda.to.reference=Convertir lambda a referencia
convert.lambda.to.reference.before.text=La expresión lambda puede convertirse en una referencia
convert.left.hand.side.to.0=Convertir el lado izquierdo a ''{0}''
convert.member.to.extension=Convertir miembro en extensión
convert.na.n.equality.quick.fix.text=Reemplazar por 'isNaN()'
convert.object.literal.to.class=Convertir literal de objeto a clase
convert.object.literal.to.lambda=Convertir literal de objeto a lambda
convert.pair.constructor.to.to.fix.text=Reemplazar con 'to' infijo
convert.parameter.to.receiver=Convertir parámetro en receptor
convert.property.getter.to.initializer=Convertir el getter de la propiedad en inicializador
convert.property.initializer.to.getter=Convertir inicializador de propiedad en getter
convert.property.to.function=Convertir propiedad en función
convert.put.to.assignment=Convertir put en asignación
convert.receiver.parameter.to.context.parameter=Convertir el parámetro receptor en un parámetro de contexto
convert.receiver.to.parameter=Convertir receptor en parámetro
convert.reference.to.lambda=Convertir referencia a lambda
convert.reference.to.lambda.before.text=La referencia puede convertirse en una lambda
convert.right.hand.side.to.0=Convertir el lado derecho a ''{0}''
convert.scope.function.fix.family.name=Convertir a ''{0}''
convert.sealed.subclass.to.object.fix.family.name=Convertir subclase sellada en objeto
convert.string.template.to.build.string=Convertir a una llamada a 'buildString'
convert.string.to.character.literal=Convertir cadena a literal de carácter
convert.supertype.to.0=Convertir supertipo a ''{0}''
convert.template.to.concatenated.string=Convertir plantilla en cadena concatenada
convert.to.0=Convertir a {0}
convert.to.0.as.1=Convertir a ''{0} as {1}''
convert.to.0.unsafecast.1=Convertir a ''{0}.unsafeCast<{1}>()''
convert.to.a.range.check=Convertir a una comprobación de rango
convert.to.anonymous.function=Convertir a función anónima
convert.to.anonymous.object=Convertir en objeto anónimo
convert.to.array.parameter=Convertir a parámetro de array
convert.to.assignment.expression=Convierte la sentencia de asignación en una expresión
convert.to.block.body=Convertir a cuerpo de bloque
convert.to.comparisons=Convertir a comparaciones
convert.to.concatenated.string.statement.analyzing.entry.type=Analizando tipo de entrada…
convert.to.data.object=Convertir a 'data object'
convert.to.enum.class=Convertir en clase enum
convert.to.expression.body.fix.text=Convertir a cuerpo de expresión
convert.to.indexed.function.call=Convertir a llamada a función indexada
convert.to.lambda=Convertir a lambda
convert.to.lambda.expression=Convertir a una expresión lambda
convert.to.lateinit.var=Convertir a lateinit var
convert.to.lazy.property=Convertir en propiedad lazy
convert.to.multi.dollar.string=Convertir a cadena con múltiples signos de dólar
convert.to.notnull.delegate=Convertir a delegado notNull
convert.to.nullable.type=Convertir a tipo que admite valores nulos
convert.to.nullable.type.fix.text=Convertir a tipo anulable
convert.to.nullable.var=Convertir a var que admite valores nulos
convert.to.object.declaration=Convertir a declaración de objeto
convert.to.ordinary.property=Convertir en propiedad ordinaria
convert.to.ordinary.string.literal=Convertir a literal de cadena ordinario
convert.to.primary.constructor=Convertir a constructor primario
convert.to.primary.constructor.before.text=El constructor secundario debe convertirse en un constructor primario
convert.to.raw.string.literal=Convertir a literal de cadena sin procesar
convert.to.sealed.class=Convertir a clase sellada
convert.to.secondary.constructor=Convertir en constructor secundario
convert.to.trim.indent=Convertir a llamada 'trimIndent()'
convert.to.trim.margin=Convertir en llamada a 'trimMargin()'
convert.to.unicode.escape=Convertir a escape Unicode
convert.to.unsafe.cast=Convertir a una conversión no segura
convert.to.unsafecast.call=Convertir a llamada a unsafeCast()
convert.to.vararg.parameter=Convertir a parámetro vararg
convert.too.long.character.literal.to.string=Convertir literal de carácter demasiado largo a cadena
convert.try.finally.to.use=Reemplazar 'try-finally' por 'use()'
convert.try.finally.to.use.before.text=try-finally se puede reemplazar por 'use()'
convert.value.parameter.to.context.parameter=Convertir parámetro de valor en parámetro de contexto
copy.concatenation.text.to.clipboard=Copiar texto de concatenación al portapapeles
copy.method.of.data.class.is.called.without.named.arguments=Se deben especificar los nombres de los parámetros explícitamente para la llamada al método 'copy()'
copy.paste.reference.notification={0} {0, choice, 1#importación añadida|2#importaciones añadidas}<p><span><a href=''show''>Revisar importaciones añadidas…</a></span>
copy.paste.resolve.pasted.references=Resolver referencias pegadas
copy.paste.restore.pasted.references=Restaurar referencias pegadas
copy.paste.restore.pasted.references.capitalized=Restaurar referencias pegadas
copy.paste.select.imports.to.remove.dialog=Seleccionar importaciones a eliminar
copy.paste.select.imports.to.remove.text=<html>El fragmento de código que ha pegado utiliza elementos que no son accesibles en el nuevo contexto. Se han añadido las importaciones necesarias.<br/>Seleccione cuáles de las importaciones añadidas desea eliminar del archivo.</html>
copy.text.adding.imports=Agregando importaciones...
copy.text.clipboard.content.seems.to.be.java.code.do.you.want.to.convert.it.to.kotlin=El contenido del portapapeles parece ser código Java. ¿Quieres convertirlo a Kotlin?
copy.text.convert.java.to.kotlin.title=Convertir Java a Kotlin
copy.text.copied.kotlin.code=Código Kotlin copiado
copy.text.resolving.references=Resolviendo referencias...
copy.title.convert.code.from.java=Convertir el código de Java
could.be.replaced.with.size=Podría reemplazarse por 'size'
could.be.replaced.with.unboxed.first=Se puede reemplazar por 'first' sin boxing
could.be.replaced.with.unboxed.last=Puede reemplazarse por 'last' sin boxear
create.0=Crear {0}
create.0.1=Crear {0} ''{1}''
create.0.in.1=Crear {0} en {1}
create.actual=Crear actual
create.actual.0.for.module.1.2=Crear {0} actual para el módulo {1} ({2})
create.actual.in.0=Crear actual en ''{0}''
create.actuals=Crear resultados reales faltantes…
create.expected.0.in.common.module.1=Crear {0} esperado en el módulo común {1}
create.kotlin.file=Crear archivo Kotlin
create.kotlin.subclass=Crear subclase Kotlin
create.label=Crear etiqueta
create.label.0=Crear etiqueta {0}@
create.package.0=Crear paquete ''{0}''
create.parameter.0=Crear parámetro ''{0}''
create.property.0.as.constructor.parameter=Crear la propiedad ''{0}'' como parámetro del constructor
create.subclass=Crear subclase
create.test=Crear prueba
dangerous.array.comparison=Comparación de arrays peligrosa
declaration.has.type.inferred.from.a.platform.call.which.can.lead.to.unchecked.nullability.issues=La declaración tiene un tipo inferido de una llamada a la plataforma, lo que puede causar problemas de nulabilidad no comprobados. Especifique el tipo explícitamente como nullable o no nullable.
declarations.are.used.outside.of.selected.code.fragment=Las siguientes declaraciones se utilizan fuera del fragmento de código seleccionado:
declarations.will.move.out.of.scope=Las siguientes declaraciones no estarán disponibles fuera del cuerpo de la función extraída:
deferred.result.is.never.used=El resultado de 'Deferred' no se utiliza
delegating.to.var.property.does.not.take.its.changes.into.account=Delegar en una propiedad 'var' no tiene en cuenta sus cambios
delete.0=Eliminar {0}
delete.assignment.completely=Eliminar la asignación por completo
delete.equals.and.hash.code.fix.text=Eliminar equals()/hashCode()
delete.fix.family.name=Eliminar flecha
delete.redundant.extension.property=Eliminar propiedad de extensión redundante
delete.with.usage.search=Eliminar (con búsqueda de usos)
demorgan.law=Ley de De Morgan
deprecated.annotation.without.replacewith.argument=Anotación '@Deprecated' sin un argumento 'replaceWith'
description.a.reference.to.extracted.type.parameter=Una referencia al parámetro de tipo extraído
destination.not.found.for.package.0=No se encontró el destino para el paquete ''{0}''
diagnostic.name.should.be.replaced.by.the.new.one=El nombre del diagnóstico debe reemplazarse por el nuevo name
dialog.message.incorrect.target.path.directory.not.specified=Ruta de destino incorrecta. No se ha especificado el directorio.
dialog.message.none.elements.were.selected=No se ha seleccionado ningún elemento
dialog.progress.collect.members.to.generate=Recopilando miembros…
dialog.title.build.super.types.hierarchy=Construir jerarquía de supertipos para {0}
dialog.title.resolving.inheritable.status=Resolviendo estado heredable…
difference.found.for.data.class.0.found.1.2=Se encontró una diferencia para la clase de datos {0}. Se encontraron {1} uso(s), pero se esperaban {2}
do.you.want.to.delete.expected.declaration.together.with.all.related.actual.ones=¿Desea eliminar la declaración "expected" junto con todas las declaraciones "actual" relacionadas?
do.you.want.to.delete.this.parameter.in.expected.declaration.and.all.related.actual.ones=¿Desea eliminar este parámetro en la declaración expected y en todas las declaraciones actual relacionadas?
do.you.want.to.make.new.extension.an.expected.declaration=¿Desea que la nueva extensión sea una declaración esperada?
doesn.t.match.regex.0=No coincide con la expresión regular ''{0}''
don.t.show.this.dialog.next.time=&No volver a mostrar este cuadro de diálogo
double.negation.fix.text=Eliminar negaciones redundantes
editor.checkbox.title.auto.add.val.keyword.to.data.value.class.constructor.parameters=Añadir automáticamente la palabra clave 'val' a los parámetros del constructor de clases data/value
editor.checkbox.title.convert.pasted.java.code.to.kotlin=Convertir código Java pegado a Kotlin
editor.checkbox.title.don.t.show.java.to.kotlin.conversion.dialog.on.paste=No mostrar el diálogo de conversión de Java a Kotlin al pegar
editor.title.kotlin=Kotlin
enter.package.fqname=Introduzca el FqName del paquete
enum.entry=Entrada de enumeración
equality.check.0.be.used.instead.of.elvis.for.nullable.boolean.check=Usar la comprobación de igualdad {0} en lugar de elvis para comprobaciones de booleanos que admiten valores nulos
equality.check.with.nan.should.be.replaced.with.isnan=La comprobación de igualdad con NaN debe reemplazarse por 'isNaN()'
equals.between.objects.of.inconvertible.types='equals()' entre objetos de tipos no convertibles
equals.hashcode.in.object.declaration='equals()'/'hashCode()' en la declaración de objeto
equals.should.take.any.as.its.argument='equals' debe recibir 'Any?' como su argumento
equals.text=Generar 'equals()'
error.cant.refactor.vararg.functions=No se puede refactorizar la función con argumentos variables
error.context.getter.or.setter=Este contexto es solo para propiedades con getter/setter explícitos. (establezca el tipo de archivo en Kotlin)
error.expected.an.expression=Se esperaba una expresión
error.expected.catch.or.finally=Se esperaba 'catch' o 'finally'
error.hint.cannot.modify.0.declaration.from.1.file=No se puede modificar la declaración ''{0}'' del archivo ''{1}''
error.hint.library.declarations.cannot.be.changed=Las declaraciones de la biblioteca no se pueden cambiar
error.hint.text.cannot.inline.0.from.a.decompiled.file=No se puede aplicar inline a ''{0}'' desde un archivo descompilado
error.param.can.t.be.null.at.index.0.in.1=El parámetro no puede ser null en el índice {0} en {1}.
error.text.can.t.change.signature.of.method=No se puede cambiar la firma del método {0}
error.text.can.t.copy.class.to.the.containing.file=No se puede copiar la clase al archivo que la contiene
error.text.can.t.generate.0.1=No se puede generar {0}: {1}
error.text.can.t.introduce.constant.for.this.expression=No se puede introducir una constante para esta expresión
error.text.can.t.introduce.constant.for.this.expression.because.not.constant=No se puede introducir una constante para una expresión no constante
error.text.can.t.introduce.lambda.parameter.for.this.expression=No se puede introducir un parámetro lambda para esta expresión
error.text.can.t.introduce.property.for.this.expression=No se puede introducir una propiedad para esta expresión
error.text.different.name.expected=Se esperaba un nombre diferente
error.text.expression.has.no.type=La expresión no tiene tipo
error.text.extraction.from.expect.class.is.not.yet.supported=Aún no se admite la extracción de una clase 'expect'
error.text.extraction.from.non.jvm.class.is.not.yet.supported=La extracción desde una clase que no sea JVM aún no es compatible
error.text.inline.function.is.not.supported.for.functions.with.multiple.return.statements=La función inline no es compatible con funciones con varias sentencias return.
error.text.inline.function.is.not.supported.for.functions.with.return.statements.not.at.the.end.of.the.body=No se admite la función inline para funciones con sentencias return que no estén al final del cuerpo.
error.text.interface.cannot.be.extracted.from.an.annotation.class=No se puede extraer una interfaz de una clase de anotación
error.text.introduce.parameter.is.not.available.for.default.value=Introducir parámetro no está disponible para el valor por defecto
error.text.introduce.parameter.is.not.available.inside.of.annotation.entries=Introducir parámetro no está disponible dentro de las entradas de anotación
error.text.invalid.name=Nombre no válido
error.text.invalid.parameter.name=Nombre de parámetro no válido
error.text.invalid.parameter.type=Tipo de parámetro no válido
error.text.invalid.receiver.type=Tipo de receptor no válido
error.text.invalid.return.type=Tipo de retorno no válido
error.text.no.type.to.refactor=No hay ningún tipo para refactorizar
error.text.refactoring.is.not.applicable.in.the.current.context=La refactorización no es aplicable en el contexto actual
error.text.superclass.cannot.be.extracted.from.an.annotation.class=No se puede extraer la superclase de una clase de anotación
error.text.type.reference.is.expected=Se esperaba una referencia de tipo
error.types.in.generated.function=No se puede generar la función con un tipo de retorno erróneo
error.wrong.caret.position.function.or.constructor.name=El cursor debe estar situado en el nombre de la función o del constructor que se va a refactorizar.
evaluate.compile.time.expression=Evaluar expresión en tiempo de compilación
excluded.methods=Métodos excluidos:
existing.backing.field.is.not.assigned.by.the.setter=El campo de respaldo existente no está asignado por el setter
expand.boolean.expression.to.if.else=Expandir expresión booleana a 'if else'
experimental.coroutines.usages.are.obsolete.since.1.3=Los usos de corrutinas experimentales están obsoletos desde 1.3
explicit.0.call=Llamada explícita a ''{0}''
explicit.this.expression.fix.family.name=Eliminar ''{0}'' redundante
explicit.type.arguments.can.be.inferred=Se pueden inferir los argumentos de tipo explícitos
explicitly.given.type.is.redundant.here=El tipo especificado explícitamente es redundante aquí
explicitly.ignore.return.value=Ignorar explícitamente el valor de retorno
expression=Expresión
external.interface.contains.non.nullable.property.name=La interfaz externa contiene una propiedad booleana que no acepta valores nulos
external.interface.contains.val.property.name=La interfaz externa contiene una propiedad val
extract.function=Extraer función
extract.new.parameter.name.receiver=<receptor>
extract.side.effects=Extraer efectos secundarios
failed.to.create.a.wrapper.for.inlining.to.kotlin=No se pudo crear un wrapper para realizar inlining en Kotlin
family.name.update.usages.on.declarations.cut.paste=Actualizar usos al cortar/pegar declaraciones
file.entity=Archivo
file.lines=Líneas del archivo
files.to.visit=Archivos a visitar
find.declaration.constructor.usages.checkbox=Usos del &constructor
find.declaration.derived.classes.checkbox=Clases &derivadas
find.declaration.derived.interfaces.checkbox=&Interfaces derivadas
find.declaration.functions.usages.checkbox=Usos de &funciones
find.declaration.implementing.methods.checkbox=Funciones de &implementación
find.declaration.implementing.properties.checkbox=&Implementar propiedades
find.declaration.include.overloaded.methods.checkbox=Incluir funciones sobrecargadas y extensiones (&V)
find.declaration.overriding.methods.checkbox=Funciones que sob&rescriben
find.declaration.overriding.properties.checkbox=Propiedades que sob&rescriben
find.declaration.properties.usages.checkbox=Usos de &propiedades
find.declaration.property.readers.checkbox=Lectores
find.declaration.property.writers.checkbox=Escritores
find.usages.checkbox.name.expected.classes=Clases esperadas
find.usages.checkbox.name.expected.functions=Funciones esperadas
find.usages.checkbox.name.expected.properties=Propiedades esperadas
find.usages.checkbox.text.fast.data.class.component.search=Búsqueda rápida de componentes de clase de datos
find.usages.class=Clase
find.usages.class.name.anonymous=Anónima
find.usages.companion.object=Objeto companion
find.usages.constructor=Constructor
find.usages.facade.class=Clase fachada
find.usages.for.property={0} para la propiedad
find.usages.function=Función
find.usages.getter=getter
find.usages.import.alias=Alias de importación
find.usages.interface=interfaz
find.usages.label=Etiqueta
find.usages.lambda=Lambda
find.usages.object=Objeto
find.usages.parameter=Parámetro
find.usages.prepare.dialog.progress=Preparar diálogo
find.usages.progress.text.declaration.superMethods=Resolviendo supermétodos…
find.usages.property=Propiedad
find.usages.property.accessor=Descriptor de acceso de propiedad
find.usages.setter=setter
find.usages.text.find.usages.for.data.class.components.and.destruction.declarations=<p>La búsqueda de usos para componentes de clases de datos y declaraciones de desestructuración<br/>se puede <a href="{0}">desactivar una vez</a> o <a href="{1}">desactivar para un proyecto</a>.</p>
find.usages.tool.tip.text.disable.search.for.data.class.components.and.destruction.declarations.project.wide.setting=Deshabilitar la búsqueda de componentes de clases de datos y declaraciones de desestructuración. (Configuración para todo el proyecto)
find.usages.type.alias=Alias de tipo
find.usages.type.callable.reference=Referencia invocable
find.usages.type.class.object=Clase/objeto anidado
find.usages.type.companion.object=Objeto compañero
find.usages.type.constructor.delegation.reference=Referencia a delegación de constructor
find.usages.type.delegate=Delegado
find.usages.type.extension.receiver.type=Tipo de receptor de extensión
find.usages.type.function.call=Llamada a función
find.usages.type.function.return.type=Tipos de retorno de función
find.usages.type.implicit.get='get' implícito
find.usages.type.implicit.invoke='invoke' implícito
find.usages.type.implicit.iteration=Iteración implícita
find.usages.type.implicit.set='set' implícito
find.usages.type.is=Tipo de destino de la operación 'is'
find.usages.type.named.argument=Argumento con nombre
find.usages.type.nonLocal.property.type=Tipo de propiedad de clase/objeto
find.usages.type.packageDirective=Directiva de paquete
find.usages.type.packageMemberAccess=Acceso a miembros del paquete
find.usages.type.parameter=Parámetro de tipo
find.usages.type.property.delegation=Delegación de propiedad
find.usages.type.receiver=Receptor
find.usages.type.super.type.qualifier=Calificador de tipo super
find.usages.type.superType=Supertipo
find.usages.type.type.alias=Alias de tipo
find.usages.type.type.constraint=Restricción de tipo
find.usages.type.value.parameter.type=Tipo de parámetro
find.usages.variable=Variable
fix.add.annotation.family=Añadir anotación
fix.add.annotation.target=Añadir destino de anotación
fix.add.annotation.text.constructor=Añadir la anotación ''@{0}'' al constructor
fix.add.annotation.text.containing.class=Añadir la anotación ''@{0}'' a la clase contenedora ''{1}''
fix.add.annotation.text.containing.file=Añadir la anotación ''@{0}'' al archivo contenedor ''{1}''
fix.add.annotation.text.declaration=Añadir la anotación ''@{0}'' a ''{1}''
fix.add.annotation.text.self=Añadir la anotación ''@{0}''
fix.add.annotation.with.arguments.text.copy=Copiar la anotación ''@{0}'' de ''{1}'' a ''{2}''
fix.add.argument.name.family=Agregar nombre al argumento
fix.add.argument.name.step.choose.parameter.title=Seleccionar nombre del parámetro
fix.add.argument.name.text=Agregar nombre al argumento: ''{0}''
fix.add.argument.name.text.generic=Añadir nombre al argumento…
fix.add.array.of.type.family=Añadir envoltorio 'arrayOf'
fix.add.array.of.type.text=Añadir envoltorio {0}
fix.add.constructor.parameter=Añadir parámetro ''{0}'' al constructor
fix.add.default.constructor=Agregar constructor por defecto a la clase 'expect'
fix.add.else.branch.when=Añadir rama else
fix.add.eq.eq.true=Añadir '== true'
fix.add.exception.to.throws=Añadir ''{0}''
fix.add.explicit.coroutine.scope.receiver=Añadir receptor 'this' explícito
fix.add.explicit.import=Añadir importación explícita
fix.add.explicit.receiver.family=Añadir receptor explícito
fix.add.function.body=Añadir cuerpo de la función
fix.add.function.parameters.add.parameter.constructor=Agregar el {0,number,ordinal} {1,choice,1#parámetro|2#parámetros} al constructor ''{2}''
fix.add.function.parameters.add.parameter.function=Añadir el {0,number,ordinal} {1,choice,1#parámetro|2#parámetros} a la función ''{2}''
fix.add.function.parameters.add.parameter.generic.constructor=Añadir {0,choice,1#parámetro|2#parámetros} al constructor ''{1}''
fix.add.function.parameters.add.parameter.generic.function=Añadir {0,choice,1#parámetro|2#parámetros} a la función ''{1}''
fix.add.function.parameters.change.signature.constructor=Cambiar la firma del constructor ''{0}''
fix.add.function.parameters.change.signature.function=Cambiar la firma de la función ''{0}''
fix.add.generic.upperbound.family=Agregar límite superior genérico
fix.add.generic.upperbound.text=Añadir ''{0}'' como límite superior para {1}
fix.add.is.to.when=Añadir ''is'' antes de ''{0}''
fix.add.loop.label.text=Añadir ''{0}'' a {1}
fix.add.loop.label.text.generic=Añadir etiqueta al bucle
fix.add.member.supertype.add.to=Añadir ''{0}'' a ''{1}''
fix.add.member.supertype.choose.type=Seleccionar tipo
fix.add.member.supertype.family=Agregar {0} al supertipo
fix.add.member.supertype.progress=Añadir {0} al tipo
fix.add.member.supertype.text=Añadir {0} al supertipo…
fix.add.modifier.family=Añadir modificador
fix.add.modifier.inline.function.family=Añadir 'inline' a la función
fix.add.modifier.inline.function.text=Añadir ''inline'' a la función ''{0}''
fix.add.modifier.inline.parameter.family=Añadir ''{0}'' al parámetro
fix.add.modifier.inline.parameter.text=Añadir ''{0}'' al parámetro ''{1}''
fix.add.modifier.text=Hacer {0} ''{1}''
fix.add.modifier.text.generic=Añadir el modificador ''{0}''
fix.add.new.line.after.annotations=Añadir nueva línea después de las anotaciones
fix.add.remaining.branches=Añadir las ramas restantes
fix.add.remaining.branches.with.star.import=Añadir las ramas restantes con importación *
fix.add.return.before.expression=Añadir 'return' antes de la expresión
fix.add.return.before.lambda.expression=Añadir 'run' antes de la expresión lambda
fix.add.return.last.expression=Añadir 'return' a la última expresión
fix.add.semicolon.lambda.expression=Finalizar la llamada anterior con punto y coma
fix.add.spread.operator.after.sam=Añadir un operador spread antes de un array pasado como 'vararg'
fix.add.star.projection.family=Añadir proyecciones de estrella
fix.add.star.projection.text=Añadir ''{0}''
fix.add.suspend.modifier.function=Hacer {0} suspend
fix.add.suspend.modifier.function.generic=Hacer que la función contenedora sea suspend
fix.add.suspend.modifier.receiver=Hacer que el tipo {0} sea suspend
fix.add.suspend.modifier.receiver.generic=Hacer que el tipo de receptor sea suspend
fix.add.tostring.call.family=Añadir llamada a 'toString()'
fix.add.tostring.call.text=Añadir llamada a 'toString()'
fix.add.tostring.call.text.safe=Añadir llamada segura '?.toString()'
fix.add.type.annotation.family=Añadir anotación de tipo
fix.add.type.annotation.text=Añadir el tipo ''{0}'' al parámetro ''{1}''
fix.assign.to.property=Asignar a la propiedad
fix.cast.expression.family=Expresión de conversión
fix.cast.expression.text=Convertir la expresión ''{0}'' a ''{1}''
fix.change.accessor.family=Cambiar tipo de accesor
fix.change.accessor.getter=Cambiar el tipo del getter a {0}
fix.change.accessor.setter.parameter=Cambiar el tipo de parámetro del setter a {0}
fix.change.jvm.name=Cambiar nombre de la JVM
fix.change.mutability.change.to.val=Cambiar ''{0}'' a val
fix.change.object.to.class=Cambiar 'object' por 'class'
fix.change.package.family=Cambiar el paquete del archivo para que coincida con el directorio
fix.change.package.text=Cambiar el paquete del archivo a {0}
fix.change.progress.analyzing.class.hierarchy=Analizando la jerarquía de clases…
fix.change.progress.looking.inheritors=Buscando herederos de la clase {0}…
fix.change.return.type.command.function=Cambiar el tipo del parámetro ''{0}'' de la función ''{1}'' a ''{2}''
fix.change.return.type.command.primary.constructor=Cambiar el tipo del parámetro ''{0}'' del constructor primario de la clase ''{1}'' a ''{2}''
fix.change.return.type.family=Cambiar tipo
fix.change.return.type.lambda=Cambiar el tipo de retorno de la expresión lambda a {0}
fix.change.return.type.presentation.accessed={0} accedido
fix.change.return.type.presentation.base=base {0}
fix.change.return.type.presentation.called=Llamado {0}
fix.change.return.type.presentation.called.function=Función llamada
fix.change.return.type.presentation.enclosing={0} envolvente
fix.change.return.type.presentation.enclosing.function=Función contenedora
fix.change.return.type.presentation.function=Función {0}
fix.change.return.type.presentation.property=Propiedad {0}
fix.change.return.type.remove.explicit.return.type=Eliminar el tipo de retorno especificado explícitamente
fix.change.return.type.remove.explicit.return.type.of=Eliminar el tipo de retorno especificado explícitamente de {0}
fix.change.return.type.return.type.text=Cambiar el tipo de retorno a ''{0}''
fix.change.return.type.return.type.text.of=Cambiar el tipo de retorno de {0} a ''{1}''
fix.change.return.type.text.function=Cambiar el tipo del parámetro ''{0}'' de la función ''{1}'' a ''{2}''
fix.change.return.type.text.primary.constructor=Cambiar el tipo del parámetro ''{0}'' del constructor primario de la clase ''{1}'' a ''{2}''
fix.change.return.type.type.text=Cambiar tipo a ''{0}''
fix.change.return.type.type.text.of=Cambiar el tipo de {0} a ''{1}''
fix.change.signature.error=<error>
fix.change.signature.family=Cambiar la firma de función/constructor
fix.change.signature.function.family=Cambiar la firma de la función
fix.change.signature.function.popup.title=Seleccionar firma
fix.change.signature.function.text=Cambiar la firma de la función a ''{0}''
fix.change.signature.function.text.generic=Cambiar la signatura de la función…
fix.change.signature.lambda=Cambiar la firma de la expresión lambda
fix.change.signature.lambda.command=Cambiar la firma de la expresión lambda
fix.change.signature.prepare=Preparar…
fix.change.signature.remove.parameter=Eliminar parámetro ''{0}''
fix.change.signature.remove.parameter.command=Eliminar parámetro ''{0}''
fix.change.signature.unavailable=<no disponible>
fix.change.signature.unnamed.parameter=Parámetro
fix.change.suspend.hierarchy.add=Añadir el modificador 'suspend' a todas las funciones de la jerarquía
fix.change.suspend.hierarchy.remove=Eliminar el modificador 'suspend' de todas las funciones de la jerarquía
fix.change.to.function.invocation=Cambiar a invocación de función
fix.change.to.labeled.return.family=Cambiar a return con etiqueta
fix.change.to.labeled.return.text=Cambiar a ''{0}''
fix.change.to.mutable.type=Cambiar tipo a {0}
fix.change.to.mutable.type.family=Cambiar tipo a mutable
fix.change.to.mutable.type.text=Cambiar tipo a {0}
fix.change.to.property.access.family.change=Cambiar a acceso a la propiedad
fix.change.to.property.access.family.remove=Eliminar invocación
fix.change.to.star.projection.family=Cambiar a proyección de estrella
fix.change.to.star.projection.text=Cambiar argumentos de tipo a {0}
fix.change.to.use.spread.operator.family=Cambiar para usar el operador de propagación
fix.change.to.use.spread.operator.text=Cambiar ''{0}'' por ''{1}''
fix.change.type.argument=Cambiar el argumento de tipo a {0}
fix.change.type.family=Cambiar tipo
fix.change.type.text=Cambiar el tipo de ''{0}'' a ''{1}''
fix.convert.to.is.array.of.call=Convertir a la llamada 'isArrayOf'
fix.copy.mismatched.annotation.to.actual.declaration.may.change.semantics=Copiar la anotación discordante ''{0}'' de la declaración ''expect'' a la declaración ''actual'' (puede cambiar la semántica)
fix.create.declaration.error=No se puede generar {0}: {1}
fix.create.declaration.error.inaccessible.type=Tipo inaccesible
fix.create.declaration.error.some.types.inaccessible=Algunos tipos no son accesibles:
fix.create.expect.actual=Crear declaración expect / actual
fix.create.from.usage.abstract.property=Crear propiedad abstracta ''{0}''
fix.create.from.usage.dialog.title=Crear a partir del uso
fix.create.from.usage.extension.property=Crear propiedad de extensión ''{0}''
fix.create.from.usage.family=Crear a partir del uso
fix.create.from.usage.local.variable=Crear variable local ''{0}''
fix.create.from.usage.property=Crear propiedad ''{0}''
fix.create.missing.actual.declarations=Añadir las declaraciones actual faltantes
fix.create.missing.actual.declarations.title=Añadir las declaraciones actual faltantes
fix.create.missing.actual.members=Añadir los miembros actual faltantes
fix.import=Importar
fix.import.exclude=Excluir ''{0}'' de la importación automática
fix.import.kind.0.name.1.2=Importar {0} ''{1}''{2,choice,0#|1# y {2} más}
fix.import.kind.0.name.1.and.name.2=Importar {0} ''{1}'', ''{2}''
fix.import.kind.component.functions=Funciones de componente
fix.import.kind.delegate.accessors=Accesores delegados
fix.import.question=¿Importar {0}?
fix.insert.delegation.call=Insertar llamada a ''{0}()''
fix.introduce.non.null.assertion=Añadir llamada de aserción de no nulo ({0}!!)
fix.introduce.non.null.assertion.family=Agregar llamada de aserción no nula
fix.introduce.non.null.assertion.text=Añadir llamada de aserción de no nulidad ({0}!!)
fix.make.data.class=Convertir ''{0}'' en clase de datos
fix.make.field.public=Hacer público el campo ''{0}''
fix.make.type.parameter.reified=Hacer {0} reificado y {1} inline
fix.make.upperbound.not.nullable.any.text=Agregar ''Any'' como límite superior para {0} para que no admita valores nulos
fix.make.upperbound.not.nullable.family=Hacer que el parámetro de tipo genérico sea no nulo
fix.make.upperbound.not.nullable.remove.nullability.text=Cambiar el límite superior de {0} a ''{1}'' para que {0} no admita valores nulos
fix.move.file.to.package.dir.name.text=Raíz de fuentes
fix.move.file.to.package.family=Mover archivo al directorio correspondiente al paquete
fix.move.file.to.package.text=Mover archivo a {0}
fix.move.to.sealed.family=Mover el miembro de la jerarquía al paquete/módulo de su padre sellado
fix.move.to.sealed.text=Mover {0} al paquete/módulo de {1}
fix.move.typealias.to.top.level=Mover alias de tipo al nivel superior
fix.opt_in.annotation.family=Anotar el uso de funciones opt-in
fix.opt_in.migrate.experimental.annotation.remove=Eliminar la anotación '@Experimental' en desuso
fix.opt_in.migrate.experimental.annotation.replace=Reemplazar la anotación '@Experimental' obsoleta por '@RequiresOptIn'
fix.opt_in.move.requirement.from.getter.to.property=Mover el requisito de opt-in ''{0}'' del getter a la propiedad
fix.opt_in.move.requirement.from.value.parameter.to.property=Mover el requisito de opt-in ''{0}'' del parámetro de valor a la propiedad
fix.opt_in.remove.all.forbidden.targets=Eliminar destinos de anotación opt-in prohibidos
fix.opt_in.remove.forbidden.retention=Eliminar la retención de anotación opt-in prohibida
fix.opt_in.text.propagate.constructor=Propagar el requisito opt-in ''{0}'' al constructor
fix.opt_in.text.propagate.containing.class=Propagar el requisito de opt-in ''{0}'' a la clase contenedora ''{1}''
fix.opt_in.text.propagate.containing.object=Propagar el requisito de opt-in ''{0}'' al objeto contenedor ''{1}''
fix.opt_in.text.propagate.declaration=Propagar el requisito de opt-in ''{0}'' a ''{1}''
fix.opt_in.text.use.constructor=Optar por ''{0}'' en el constructor
fix.opt_in.text.use.containing.anonymous.object=Optar por ''{0}'' en el objeto contenedor
fix.opt_in.text.use.containing.class=Optar por ''{0}'' en la clase contenedora ''{1}''
fix.opt_in.text.use.containing.file=Optar por ''{0}'' en el archivo contenedor ''{1}''
fix.opt_in.text.use.containing.object=Optar por ''{0}'' en el objeto contenedor ''{1}''
fix.opt_in.text.use.declaration=Optar por ''{0}'' en ''{1}''
fix.opt_in.text.use.module=Optar por ''{0}'' en el módulo ''{1}''
fix.opt_in.text.use.statement=Optar por ''{0}'' en la sentencia
fix.potentially.broken.inheritance.message=Este cambio podría romper potencialmente a los herederos.\n¿Desea continuar?
fix.potentially.broken.inheritance.title=Herencia potencialmente rota
fix.remove.annotation.text=Eliminar anotación
fix.remove.argument.text=Eliminar argumento
fix.remove.mismatched.annotation.from.expect.declaration.may.change.semantics=Eliminar la anotación discordante ''{0}'' de la declaración ''expect'' (puede cambiar la semántica)
fix.remove.non.null.assertion=Eliminar la aserción de no nulidad innecesaria (!!)
fix.remove.redundant.star.text=Eliminar * redundante
fix.replace.annotation.family=Reemplazar anotación
fix.replace.annotation.text=Reemplazar anotación con ''@{0}''
fix.replace.mismatched.annotation.args.on.actual.declaration.may.change.semantics=Reemplazar los argumentos de la anotación discordante ''{0}'' en la declaración ''actual'' (puede cambiar la semántica)
fix.replace.mismatched.annotation.args.on.expect.declaration.may.change.semantics=Reemplazar los argumentos de la anotación no coincidente ''{0}'' en la declaración ''expect'' (puede cambiar la semántica)
fix.replace.run.blocking.with.inline=Reemplazar 'runBlocking' por su ejecución inline
fix.replace.run.blocking.with.run=Reemplazar 'runBlocking' por 'run'
fix.replace.run.blocking.with.withContext=Reemplazar 'runBlocking' por 'withContext'
fix.replace.run.family=Reemplazar 'runBlocking' por ejecución en línea, 'withContext' o 'run'
fix.replace.with.assign.function.call=Reemplazar con la llamada a ''{0}''
fix.replace.with.declaring.java.class=Reemplazar por 'declaringJavaClass'
fix.text=Elimina punto y coma redundante
fix.unused.receiver.parameter.remove=Eliminar el parámetro receptor redundante
fix.use.fully.qualified.call=Usar llamada totalmente calificada
fix.with.asdynamic=Corregir con 'asDynamic'
flatten.when.expression=Aplanar expresión 'when'
flip.0=Voltear ''{0}''
flip.binary.expression=Invertir expresión binaria
flip.equals=Invertir 'equals'
floating.point.literal.precision.inspection=El literal de punto flotante no se puede representar con la precisión requerida
floating.point.literal.precision.inspection.display.name=El literal de punto flotante excede la precisión disponible
flow.constructed.but.not.used=El Flow se ha construido pero no se utiliza
foldable.if.then=if-then plegable
following.expression.won.t.be.processed.since.refactoring.can.t.preserve.its.semantics.0=La siguiente expresión no se procesará ya que la refactorización no puede preservar su semántica: {0}
following.problems.are.found=Se han encontrado los siguientes problemas:\n
for.0=Para ''{0}''
for.api.stability.it.s.recommended.to.specify.explicitly.declaration.types=Para la estabilidad de la API, se recomienda especificar explícitamente los tipos de declaración
for.api.stability.it.s.recommended.to.specify.explicitly.public.protected.declaration.types=Para la estabilidad de la API, se recomienda especificar explícitamente los tipos de declaración public & protected
for.loop.over.indices.could.be.replaced.with.loop.over.elements=El bucle for sobre índices podría reemplazarse por un bucle sobre elementos
formatter.button.text.use.import.with=Usar import con '*'
formatter.button.text.use.import.with.when.at.least=Usar import con '*' cuando haya al menos
formatter.button.text.use.single.name.import=Usar importación de nombre único
formatter.checkbox.text.collection.literal.expression=Expresión de literal de colección
formatter.checkbox.text.context.receiver.list=Lista de receptores de contexto
formatter.checkbox.text.destructuring.declaration=Declaración de desestructuración
formatter.checkbox.text.function.literal=Literal de función
formatter.checkbox.text.indices=Índices
formatter.checkbox.text.insert.imports.for.nested.classes=Insertar importaciones para clases anidadas
formatter.checkbox.text.type.argument.list=Lista de argumentos de tipo
formatter.checkbox.text.type.parameter.list=Lista de parámetros de tipo
formatter.checkbox.text.use.trailing.comma=Usar coma final
formatter.checkbox.text.value.argument.list=Lista de argumentos de valor
formatter.checkbox.text.value.parameter.list=Lista de parámetros de valor
formatter.checkbox.text.when.entry=Entrada 'when'
formatter.settings.title=Configuración del formateador de Kotlin
formatter.text.names.used=Nombres utilizados
formatter.text.use.defaults.from=Usar valores predeterminados de:
formatter.title.after.colon.before.declaration.type=Después de los dos puntos, antes del tipo de declaración
formatter.title.after.colon.in.new.type.definition=Después de los dos puntos en una nueva definición de tipo
formatter.title.align.when.branches.in.columns=Alinear las ramas 'when' en columnas
formatter.title.around.arrow.in=Alrededor de la flecha en la cláusula "when"
formatter.title.around.arrow.in.function.types=Alrededor de la flecha en tipos de función
formatter.title.around.when.branches.with=Alrededor de las ramas 'when' con {}
formatter.title.before.colon.after.declaration.name=Antes de los dos puntos, después del nombre de la declaración
formatter.title.before.colon.in.new.type.definition=Antes de los dos puntos en la definición de un nuevo tipo
formatter.title.before.declaration.with.comment.or.annotation=Antes de la declaración con comentario o anotación
formatter.title.before.lambda.arrow=Antes de la flecha lambda
formatter.title.chained.function.calls=Llamadas a funciones encadenadas
formatter.title.elvis.expressions=Expresiones Elvis
formatter.title.elvis.operator=Operador Elvis (?:)
formatter.title.expression.body.functions=Funciones con cuerpo de expresión
formatter.title.function.annotations=Anotaciones de función
formatter.title.function.call.arguments=Argumentos de llamada a función
formatter.title.function.declaration.parameters=Parámetros de declaración de función
formatter.title.function.parentheses=Paréntesis de función
formatter.title.in.simple.one.line.methods=En métodos simples de una sola línea
formatter.title.indent.before.arrow.on.new.line=Sangrar antes de '->' en una línea nueva
formatter.title.java.statics.and.enum.members=Miembros estáticos y de enumeración de Java
formatter.title.line.break.after.multiline.when.entry=Nueva línea después de una entrada multilínea
formatter.title.load.save=Cargar/Guardar
formatter.title.other=Otros
formatter.title.property.annotations=Anotaciones de propiedad
formatter.title.put.left.brace.on.new.line=Colocar la llave de apertura en una nueva línea
formatter.title.range.operator=Operadores de rango (.., ..<)
formatter.title.top.level.symbols=Símbolos de nivel superior
formatter.title.trailing.comma=Coma final
formatter.title.use.continuation.indent=Usar sangría de continuación
formatter.title.use.continuation.indent.in.conditions=Usar sangría de continuación en condiciones
formatter.title.when.parentheses=Paréntesis de 'when'
formatter.title.when.statements=sentencias 'when'
function=Función
function.0=Función ''{0}''
function.0.returning.1.without.the.corresponding=La función ''{0}'' devuelve ''{1}'' sin la correspondiente función ''{2}'' que devuelva ''{3}''
function.01=Función "{0}"
function.name.is.invalid=El nombre de la función no es válido
function.returning.0.with.a.name.that.does.not.end.with.1=Función que devuelve {0} con un nombre que no termina en {1}
function.should.have.operator.modifier=La función debe tener el modificador 'operator'
generate.equals.and.hashcode.fix.text=Generar equals() y hashCode()
generate.identity.equals.fix.family.name=Generar equals & hashCode por identidad
goto.related.provider.in.module.0=(en el módulo {0})
goto.super.chooser.class.title=Seleccionar superclase o interfaz
goto.super.chooser.function.title=Seleccionar superfunción
goto.super.chooser.property.title=Seleccionar superpropiedad
group.InternalKotlin.text=Acciones internas de Kotlin
group.KotlinCompletionBenchmarkGroup.text=Benchmark de completado
group.KotlinInternalGroup.text=Kotlin
group.KotlinRefactoringTesting.text=Pruebas de refactorización de Kotlin
group.KotlinToolsGroup.text=Kotlin
group.advanced.settings.kotlin=Kotlin
group.names.code.migration=Migración de código
group.names.coroutine=Inspecciones de corrutinas
group.names.gradle=Gradle
group.names.java.interop.issues=Problemas de interoperabilidad de Java
group.names.kotlin=Kotlin
group.names.logging=Registro
group.names.maven=Maven
group.names.migration=Migración
group.names.naming.conventions=Convenciones de nomenclatura
group.names.numeric.issues=Problemas numéricos
group.names.other.problems=Otros problemas
group.names.probable.bugs=Errores probables
group.names.redundant.constructs=Constructos redundantes
group.names.style.issues=Problemas de estilo
group.path.kotlin.migration=Kotlin,Migración
hash.code.text=Generar 'hashCode()'
hierarchy.legend.member.defined.in.superclass=El miembro no está definido en la clase, sino en la superclase
hierarchy.legend.member.is.defined.in.class=El miembro está definido en la clase
hierarchy.legend.member.should.be.defined=El miembro debe estar definido ya que la clase no es abstracta
hierarchy.text.anonymous=[anónimo]
hierarchy.text.in=En {0}
highlight.usages.of.receiver=Resaltar usos del receptor
highlighter.action.text.go.to.actual.declarations=Ir a las declaraciones actual
highlighter.action.text.go.to.expected.declaration=Ir a la declaración esperada
highlighter.action.text.go.to.implementations=Ir a implementaciones
highlighter.action.text.go.to.overridden.methods=Ir a los métodos sobrescritos
highlighter.action.text.go.to.overridden.properties=Ir a las propiedades sobrescritas
highlighter.action.text.go.to.subclasses=Ir a subclases
highlighter.action.text.go.to.super.method=Ir al supermétodo
highlighter.action.text.go.to.super.property=Ir a la superpropiedad
highlighter.descriptor.text.android.extensions.property=Propiedades y variables//propiedades sintéticas de Android Extensions
highlighter.descriptor.text.annotation=Anotación//Nombre de la anotación
highlighter.descriptor.text.annotation.attribute.name=Anotación
highlighter.descriptor.text.arrow=Llaves y operadores//Flecha
highlighter.descriptor.text.builtin.annotation=Palabras clave//Modificador
highlighter.descriptor.text.builtin.keyword=Palabras clave//Palabra clave
highlighter.descriptor.text.builtin.keyword.val=Palabras clave//'val'
highlighter.descriptor.text.builtin.keyword.var=Palabras clave//'var'
highlighter.descriptor.text.captured.variable=Propiedades y variables//Variables y valores capturados en una clausura
highlighter.descriptor.text.closure.braces=Llaves y operadores//Llaves y flecha de expresión lambda
highlighter.descriptor.text.colon=Llaves y operadores//Dos puntos
highlighter.descriptor.text.constructor.call=Funciones//Llamada a constructor
highlighter.descriptor.text.data.class=Clases e interfaces//Clase de datos
highlighter.descriptor.text.data.object=Clases e interfaces//Objeto de datos
highlighter.descriptor.text.double.colon=Llaves y operadores//Doble dos puntos
highlighter.descriptor.text.dynamic.fun.call=Funciones//Llamada a función dinámica
highlighter.descriptor.text.dynamic.property=Propiedades y variables//Propiedad dinámica
highlighter.descriptor.text.enum=Clases e interfaces//Enumeración
highlighter.descriptor.text.enumEntry=Clases e interfaces//Entrada de enumeración
highlighter.descriptor.text.exclexcl=Paréntesis y operadores//Aserción de no nulidad
highlighter.descriptor.text.extension.fun.call=Funciones//Llamada a función de extensión
highlighter.descriptor.text.extension.property=Propiedades y variables//Propiedad de extensión
highlighter.descriptor.text.field=Propiedades y variables//Variable de campo de respaldo
highlighter.descriptor.text.fun=Funciones//Declaración de función
highlighter.descriptor.text.fun.call=Funciones//Llamada a función
highlighter.descriptor.text.instance.property=Propiedades y variables//Propiedad de instancia
highlighter.descriptor.text.instance.property.custom.property.declaration=Propiedades y variables//Propiedad de instancia con declaraciones de propiedades personalizadas
highlighter.descriptor.text.it=Parámetros//Parámetro predeterminado de expresión lambda
highlighter.descriptor.text.kdoc.comment=Comentarios//KDoc//Comentario KDoc
highlighter.descriptor.text.kdoc.tag=Comentarios//KDoc//Etiqueta KDoc
highlighter.descriptor.text.kdoc.value=Comentarios//KDoc//Enlace en etiqueta KDoc
highlighter.descriptor.text.label=Etiqueta
highlighter.descriptor.text.local.variable=Propiedades y variables//Variable o valor local
highlighter.descriptor.text.named.argument=Argumento con nombre
highlighter.descriptor.text.object=Clases e interfaces//Objeto
highlighter.descriptor.text.package.fun.call=Funciones//Llamada a función de nivel de paquete
highlighter.descriptor.text.package.property=Propiedades y variables//Propiedad a nivel de paquete
highlighter.descriptor.text.package.property.custom.property.declaration=Propiedades y variables//Propiedad de nivel de paquete con declaraciones de propiedad personalizadas
highlighter.descriptor.text.quest=Llaves y operadores//Marcador de nulabilidad de tipo
highlighter.descriptor.text.safe.access=Llaves y operadores//Punto de acceso seguro
highlighter.descriptor.text.smart.cast=Conversiones inteligentes//Valor de conversión inteligente
highlighter.descriptor.text.smart.cast.receiver=Smart-casts//Receptor implícito de smart-cast
highlighter.descriptor.text.smart.constant=Conversiones inteligentes//Constante inteligente
highlighter.descriptor.text.string.escape=Cadena//Secuencia de escape en cadenas y llaves de plantilla
highlighter.descriptor.text.suspend.fun.call=Funciones//Llamada a función de suspensión
highlighter.descriptor.text.synthetic.extension.property=Propiedades y variables//Propiedad de extensión sintética
highlighter.descriptor.text.typeAlias=Clases e interfaces//Alias de tipo
highlighter.descriptor.text.var=Propiedades y variables//Var (variable mutable, parámetro o propiedad)
highlighter.descriptor.text.variable.as.function.call=Propiedades y variables//Variable como llamada a función
highlighter.descriptor.text.variable.as.function.like.call=Propiedades y variables//Variable como llamada de tipo función
highlighter.message.suspend.function.call=Llamada a función de suspensión
highlighter.message.suspending.iteration=Suspendiendo iteración
highlighter.name.dsl=Dsl//
highlighter.name.dsl.markers=Marcadores DSL
highlighter.name.expect.actual.line.markers=Marcadores de línea ''expect''//''actual'' de Kotlin
highlighter.name.implemented.declaration=Declaración implementada
highlighter.name.implementing.declaration=Declaración de implementación
highlighter.name.kotlin.line.markers=Marcadores de línea de Kotlin
highlighter.name.multiplatform.actual.declaration=Declaración actual multiplataforma
highlighter.name.multiplatform.expect.declaration=Declaración expect multiplataforma
highlighter.name.overridden.declaration=Declaración sobrescrita
highlighter.name.overriding.declaration=Declaración de sobrescritura
highlighter.name.style=Estilo {0}
highlighter.notification.text.navigation.to.overriding.classes.is.not.possible.during.index.update=La navegación a las clases que sobrescriben no es posible durante la actualización del índice
highlighter.prefix.text.has.actuals.in=Tiene actuals en {0} {1, choice, 0#módulo|1#módulos}
highlighter.text.click.for.navigate=Haga clic en {0} para navegar
highlighter.text.has.functional.implementations=Tiene implementaciones funcionales
highlighter.text.implements=Implementa
highlighter.text.in={0} en ''{1}''
highlighter.text.or.press=O presione {0}
highlighter.text.overrides=Sobrescrituras
highlighter.title.overriding.declarations.of=Declaraciones que sobrescriben a {0}
highlighter.title.searching.for.overriding.declarations=Buscando declaraciones de sobrescritura
highlighter.title.searching.for.overriding.methods=Buscando métodos que sobrescriben
highlighter.tool.tip.has.expect.declaration.in=Tiene declaraciones expect en {0} {1, choice, 0#módulo|1#módulos}
highlighter.tool.tip.marker.annotation.for.dsl=Anotación de marcador para DSL
highlighter.tool.tip.text.function=Función
highlighter.tool.tip.text.property=Propiedad
highlighter.tool.tip.text.recursive.call=Llamada recursiva
hint.text.no.expression.found=No se encontró ninguna expresión
hints.codevision.implementations.format={0, choice, 1#1 implementación|2#{0,number} implementaciones}
hints.codevision.implementations.too_many.format={0,number}+ implementaciones
hints.codevision.inheritors.format={0, choice, 1#1 heredero|2#{0,number} herederos}
hints.codevision.inheritors.to_many.format={0,number}+ herederos
hints.codevision.overrides.format={0, choice, 1#1 sobrescritura|2#{0,number} sobrescrituras}
hints.codevision.overrides.to_many.format={0,number}+ sobrescrituras
hints.codevision.settings=Configuración…
hints.codevision.usages.format={0, choice, 1#1 uso|2#{0,number} usos}
hints.codevision.usages.too_many.format={0,number}+ usos
hints.description.compiler.plugins.modality=Proporciona sugerencias con la modalidad de declaración cambiada por un plugin del compilador de Kotlin
hints.description.compiler.plugins.supertypes=Proporciona sugerencias con supertipos generados por un plugin del compilador de Kotlin
hints.ranges.greaterOrEqual=≥
hints.ranges.less=<
hints.ranges.lessOrEqual=≤
hints.settings.common.items=Mostrar sugerencias para:
hints.settings.compiled.parameters=Nombres de parámetros compilados
hints.settings.compiler.plugins.modality=Modalidad cambiada por un plugin del compilador de Kotlin
hints.settings.compiler.plugins.supertypes=Supertipo añadido por un plugin del compilador de Kotlin
hints.settings.dont.show.lambda.receivers.parameters=No mostrar sugerencias de parámetros y receptores implícitos
hints.settings.dont.show.lambda.return=No mostrar sugerencias de expresiones de retorno
hints.settings.dont.show.ranges=No mostrar sugerencias de rango
hints.settings.dont.show.suspending=No mostrar sugerencias de llamadas de suspensión
hints.settings.dont.show.types.parameter=No mostrar sugerencias de tipo de los parámetros de función
hints.settings.dont.show.types.property=No mostrar sugerencias de tipo de propiedad
hints.settings.dont.show.types.return=No mostrar sugerencias de tipo de retorno de función
hints.settings.dont.show.types.variable=No mostrar sugerencias de tipo de variable local
hints.settings.excluded.parameters=Nombres de parámetros excluidos
hints.settings.lambda.receivers.parameters=Receptores y parámetros implícitos
hints.settings.lambda.return=Expresiones de retorno
hints.settings.lambdas=Lambdas
hints.settings.parameters=Parámetros
hints.settings.ranges=Rangos
hints.settings.show.lambda.receivers.parameters=Mostrar sugerencias de receptores y parámetros implícitos
hints.settings.show.lambda.return=Mostrar sugerencias de expresiones de retorno
hints.settings.show.ranges=Mostrar sugerencias de rango
hints.settings.show.suspending=Mostrar sugerencias de llamadas de suspensión
hints.settings.show.types.parameter=Mostrar sugerencias de tipo de parámetro de función
hints.settings.show.types.property=Mostrar sugerencias de tipo de propiedad
hints.settings.show.types.return=Mostrar sugerencias de tipo de retorno de la función
hints.settings.show.types.variable=Mostrar sugerencias de tipos de variables locales
hints.settings.suspending=Suspensión de llamadas
hints.settings.types=Tipos
hints.settings.types.parameter=Tipos de parámetros de función
hints.settings.types.property=Tipos de propiedad
hints.settings.types.return=Tipos de retorno de funciones
hints.settings.types.variable=Tipos de variables locales
hints.settings.value.kotlin.time=Advertencia de kotlin.time
hints.settings.value.ranges=Rangos
hints.settings.values.ranges=Rangos
hints.title.argument.name.enabled=Nombre del argumento
hints.title.codevision=Visión de código
hints.title.dont.show.argument.name.enabled=No mostrar sugerencias de nombres de argumentos
hints.title.show.argument.name.enabled=Mostrar sugerencias de nombres de argumentos
hints.tooltip.compiler.plugins.modality=Un plugin del compilador de Kotlin ha cambiado la modalidad de ''{0}'' a ''{1}''
hints.tooltip.compiler.plugins.supertypes=Supertipo añadido por un plugin del compilador de Kotlin
hints.types=Sugerencias de tipo
if.null.return.break.foldable.to=If-Null return/break/… plegable a '?:'
if.then.foldable.to=If-Then plegable a '?:'
ignore.imports.and.formatting=Ignorar importaciones y formato
implement.abstract.class=Implementar clase abstracta
implement.abstract.function=Implementar función abstracta
implement.abstract.member=Implementar miembro abstracto
implement.abstract.property=Implementar propiedad abstracta
implement.as.constructor.parameter=Implementar como parámetro del constructor
implement.interface=Implementar interfaz
implement.sealed.class=Implementar clase sellada
implicit.nothing.s=Nothing implícitos
implicit.parameter.it.of.enclosing.lambda.is.shadowed=El parámetro implícito 'it' de la lambda envolvente está oculto
implicit.unsafe.cast.from.dynamic.to.0=Conversión implícita (no segura) de dynamic a {0}
import.members.from.0=Importar miembros de ''{0}''
import.members.with=Importar miembros con '*'
import.optimizer.notification.text.unused.imports.not.found=No se encontraron importaciones no utilizadas.
import.optimizer.progress.indicator.text.collect.imports.for=Recopilando importaciones para {0}
import.optimizer.text.import={0, choice, 0#importación|2#importaciones}
import.optimizer.text.non.zero=Se eliminaron {0} {1}{2, choice, 0#|1#, se añadieron {2} {3}}
import.optimizer.text.zero=Importaciones reordenadas
import.order.button.text.add.package=Agregar paquete
import.order.button.text.down=Abajo
import.order.button.text.remove=Eliminar
import.order.button.text.up=Subir
import.progress.text.resolve.imports=Buscar todas las importaciones…
import.text.all.alias.imports=Todas las importaciones de alias
import.text.all.other.imports=Todas las demás importaciones
import.text.import=Importar
in.class.0=En la clase ''{0}''
inaccessible.declaration=Declaración inaccesible
incomplete.destructuring.declaration.text=Declaración de desestructuración incompleta
incomplete.destructuring.fix.family.name=Añadir las variables faltantes a la declaración de desestructuración
indent.raw.string=Indentar cadena de texto literal
index.is.not.used.in.the.loop.body=El índice no se usa en el cuerpo del bucle
infix.call.may.be.dot.call=La llamada infija puede ser una llamada con punto
inheritance.of.kotlin.sealed={0,choice,0#La interfaz|1#La clase} Java no puede formar parte de la jerarquía sellada de Kotlin
initialize.with.constructor.parameter=Inicializar con el parámetro del constructor
initialize.with.constructor.parameter.analyzing.existing.variables=Analizando variables existentes…
initializer.is.redundant=El inicializador es redundante
inlay.kotlin.call.chains.hints=Mostrar sugerencias incrustadas para cadenas de llamadas
inlay.kotlin.lambdas.hints=Mostrar sugerencias incrustadas para lambdas
inlay.kotlin.lambdas.hints.hints.lambda.receivers.parameters=Mostrar pistas inlay para receptores y parámetros implícitos
inlay.kotlin.lambdas.hints.hints.lambda.return=Mostrar sugerencias incrustadas para expresiones de retorno
inlay.kotlin.parameters.hints=Muestra los nombres de los parámetros en los puntos de llamada a funciones.
inlay.kotlin.parameters.hints.compiled=Mostrar nombres de parámetros compilados
inlay.kotlin.parameters.hints.excluded=Mostrar nombres de parámetros excluidos
inlay.kotlin.references.types.hints=Mostrar pistas incrustadas para tipos
inlay.kotlin.references.types.hints.hints.type.function.parameter=Mostrar sugerencias incrustadas para los tipos de parámetros de función
inlay.kotlin.references.types.hints.hints.type.function.return=Mostrar sugerencias incrustadas para los tipos de retorno de función
inlay.kotlin.references.types.hints.hints.type.property=Mostrar pistas inlay para tipos de propiedad
inlay.kotlin.references.types.hints.hints.type.variable=Mostrar sugerencias incrustadas para tipos de variables locales
inlay.kotlin.value.kotlin.time=Mostrar sugerencias inlay para advertencias del paquete kotlin.time
inlay.kotlin.value.ranges=Mostrar sugerencias incrustadas para rangos de valores
inlay.kotlin.values.hints=Mostrar sugerencias incrustadas para valores
inlay.kotlin.values.hints.kotlin.values.ranges=Mostrar sugerencias incrustadas para rangos
inline.type.parameter=Inline de parámetro de tipo
inline.variable=Incorporar variable
inline.when.argument=Poner en línea el argumento 'when'
insert.curly.braces.around.variable=Insertar llaves alrededor de la variable
insert.explicit.delegation.call=Insertar llamada de delegación explícita
insert.number.conversion=Insertar conversión de números
inspection.add.annotation.target.problem.description=La anotación solo se aplica a los parámetros. Se recomienda usar un destino de uso (use-site) de anotación explícito.
inspection.add.conversion.call.display.name=Conversión explícita de `Int` necesaria desde 1.9
inspection.add.kotlin.coroutines.display.name=Añadir la biblioteca Kotlin Coroutines
inspection.add.operator.modifier.display.name=La función debe tener el modificador 'operator'
inspection.add.variance.modifier.display.name=El parámetro de tipo puede tener varianza 'in' o 'out'
inspection.ambiguous.actuals.display.name=Actual ambiguo
inspection.ambiguous.expression.when.branch.migration.display.name=Expresiones lógicas ambiguas en ramas 'when' desde 1.7
inspection.array.in.data.class.display.name=Propiedad de array en clase de datos
inspection.assigned.value.is.never.read.display.name=El valor asignado nunca se lee
inspection.boolean.literal.argument.display.name=Argumento de literal booleano sin nombre de parámetro
inspection.can.be.parameter.display.name=El parámetro del constructor nunca se usa como propiedad
inspection.can.be.primary.constructor.property.display.name=La propiedad se asigna explícitamente al parámetro del constructor
inspection.can.be.val.display.name=Var' local nunca se modifica y puede declararse como 'val
inspection.can.convert.to.multi.dollar.string.display.name=Se puede usar la interpolación de varios símbolos de dólar en literales de cadena (disponible desde 2.1)
inspection.can.convert.to.multi.dollar.string.problem.description=Un prefijo de interpolación puede simplificar la cadena
inspection.can.sealed.subclass.be.object.display.name=Subclase sellada sin estado ni equals sobreescrito
inspection.can.unescape.dollar.literal.inspection.display.name=Caracteres de dólar escapados redundantes en literales de cadena
inspection.can.unescape.dollar.literal.inspection.problem.description=Los caracteres de dólar escapados en la cadena se pueden simplificar
inspection.cascade.if.display.name=El 'if' en cascada se puede reemplazar por 'when'
inspection.class.name.display.name=Convención de nomenclatura de clases
inspection.complex.redundant.let.display.name=Llamada 'let' redundante basada en argumentos
inspection.conflicting.extension.property.display.name=Propiedad de extensión en conflicto con una propiedad sintética
inspection.const.property.name.display.name=Convención de nomenclatura de propiedades const
inspection.constant.condition.if.display.name=La condición de la expresión 'if' es constante
inspection.context.parameters.migration.display.text=Se utilizan receptores de contexto obsoletos
inspection.context.parameters.migration.problem.description=Los receptores de contexto deben reemplazarse por parámetros de contexto
inspection.context.parameters.migration.quick.fix.text=Reemplazar receptores de contexto por parámetros de contexto
inspection.control.flow.with.empty.body.display.name=Flujo de control con cuerpo vacío
inspection.convert.argument.to.set.display.name=El argumento podría convertirse en 'Set' para mejorar el rendimiento
inspection.convert.call.chain.into.sequence.display.name=La cadena de llamadas de la colección se puede convertir en 'Sequence' para mejorar el rendimiento
inspection.convert.lambda.to.reference.display.name=Se puede reemplazar por una referencia de función
inspection.convert.na.n.equality.display.name=Convertir la comprobación de igualdad con 'NaN' en una llamada a 'isNaN'
inspection.convert.object.to.data.object.display.name=Convertir 'object' en 'data object'
inspection.convert.pair.constructor.to.to.function.display.name=Convertir el constructor Pair en la función 'to'
inspection.convert.reference.to.lambda.display.name=Se puede reemplazar con lambda
inspection.convert.secondary.constructor.to.primary.display.name=Convertir en constructor primario
inspection.convert.to.string.template.display.name=Concatenación de cadenas que puede convertirse en plantilla de cadena
inspection.convert.try.finally.to.use.call.display.name=Convertir try / finally a una llamada use()
inspection.convert.two.comparisons.to.range.check.display.name=Se deben convertir dos comparaciones en una comprobación de rango
inspection.copy.without.named.arguments.display.name=El método 'copy' de la clase de datos se llama sin argumentos con nombre
inspection.data.class.private.constructor.display.name=El constructor privado de la clase de datos se expone a través del método 'copy'
inspection.deferred.is.result.display.name=Función que devuelve Deferred directamente
inspection.deferred.result.unused.display.name=El resultado de '@Deferred' no se utiliza
inspection.delegation.to.var.property.display.name=Delegación en la propiedad 'var'
inspection.deprecated.callable.add.replace.with.display.name=Anotación @Deprecated sin el argumento 'replaceWith'
inspection.deprecated.enum.declaring.class.property=Propiedad 'Enum.declaringClass' en desuso
inspection.deprecated.gradle.dependency.display.name=Se utiliza una biblioteca obsoleta en Gradle
inspection.deprecated.inline.class.text=Clase inline en desuso
inspection.deprecated.inline.classes.migration.display.name=Las clases inline están obsoletas desde la versión 1.5
inspection.deprecated.maven.dependency.display.name=Se utiliza una biblioteca obsoleta en Maven
inspection.destructure.display.name=Usar declaración de desestructuración
inspection.destructuring.wrong.name.display.name=La variable en la declaración de desestructuración utiliza el nombre de una propiedad de clase de datos incorrecta
inspection.different.kotlin.gradle.version.display.name=Las versiones de los plugins de Kotlin Gradle y del IDE son diferentes
inspection.different.kotlin.maven.version.display.name=Las versiones de los plugins de Maven y del IDE son diferentes
inspection.different.maven.stdlib.version.display.name=Las versiones de la biblioteca y del plugin de Maven son diferentes
inspection.different.stdlib.gradle.version.display.name=Las versiones de la biblioteca Kotlin y del plugin de Gradle son diferentes
inspection.do.not.propagate.method.deprecation.through.overrides=No propagar la obsolescencia de métodos a través de sobrescrituras desde 1.9
inspection.empty.range.display.name=El rango con start mayor que endInclusive está vacío
inspection.enum.entry.name.display.name=Convención de nomenclatura de entradas de enum
inspection.enum.values.method.soft.deprecate.in.java.display.name=Se recomienda reemplazar 'Enum.values()' por 'Enum.getEntries()' a partir de Kotlin 1.9
inspection.enum.values.method.soft.deprecate.migration.display.name=Se recomienda reemplazar 'Enum.values()' por 'Enum.entries' desde 1.9
inspection.equals.or.hash.code.display.name='equals()' y 'hashCode()' no están emparejados
inspection.explicit.this.display.name='this' explícito redundante
inspection.fake.jvm.field.constant.display.name=Propiedad de Kotlin no marcada como const utilizada como constante de Java
inspection.filter.is.instance.call.with.class.literal.argument.display.name=Llamada a 'filterIsInstance' con un argumento de literal de clase
inspection.filter.is.instance.call.with.class.literal.argument.quick.fix.text=Reemplazar el argumento de literal de clase por un parámetro de tipo reificado
inspection.fold.initializer.and.if.to.elvis.display.name=If-Null return/break/… plegable a '?:'
inspection.for.each.parameter.not.used.display.name=Los elementos iterados no se utilizan en forEach
inspection.foreach.join.on.collection.of.job.description=ForEach { it.join() }' se utiliza en 'Collection<Job>' en lugar de un único 'joinAll()
inspection.foreach.join.on.collection.of.job.display.name=Llamada a 'forEach { it.join() }' en 'Collection<Job>' en lugar de un único 'joinAll()'
inspection.foreach.join.on.collection.of.job.replace.with.joinAll=Reemplazar por 'joinAll()'
inspection.from.closed.range.migration.display.name=Paso MIN_VALUE en fromClosedRange() desde 1.3
inspection.function.name.display.name=Convención de nomenclatura de funciones
inspection.function.with.lambda.expression.body.display.name=Función con '= { … }' y tipo de retorno inferido
inspection.gradle.kotlinx.coroutines.deprecation.display.name=Se utiliza una dependencia de kotlinx.coroutines incompatible con Kotlin 1.3+ en Gradle
inspection.has.platform.type.display.name=La función o propiedad tiene un tipo de plataforma
inspection.if.then.to.elvis.display.name=If-Then plegable a '?:'
inspection.if.then.to.safe.access.display.name=If-Then plegable a '?.'
inspection.implicit.nullable.nothing.type.display.name=Tipo 'Nothing?' implícito
inspection.implicit.this.action.name=Añadir 'this' explícito
inspection.implicit.this.display.name='this' implícito
inspection.incomplete.destructuring.declaration.display.name=Declaración de desestructuración incompleta
inspection.inconsistent.comment.for.java.parameter.display.name=Comentario inconsistente para el parámetro Java
inspection.introduce.when.subject.display.name='when' que se puede simplificar introduciendo un argumento
inspection.java.collections.static.method.display.name=La llamada al método estático de Java Collections se puede reemplazar por Kotlin stdlib
inspection.java.collections.static.method.on.immutable.list.display.name=Llamada a un método mutador de Java en una colección inmutable de Kotlin
inspection.java.default.methods.not.overridden.by.delegation.display.name=Métodos predeterminados de Java no sobrescritos por delegación
inspection.java.default.methods.not.overridden.by.delegation.message=Los métodos predeterminados de Java no se sobrescriben mediante delegación
inspection.java.io.serializable.object.must.have.read.resolve.display.name=El objeto Serializable debe implementar 'readResolve'
inspection.java.io.serializable.object.must.have.read.resolve.quick.fix.name=Implementar 'readResolve'
inspection.java.io.serializable.object.must.have.read.resolve.warning=El objeto Serializable debe implementar 'readResolve'
inspection.java.map.for.each.display.name=La llamada al método Map.forEach de Java debe reemplazarse por el forEach de Kotlin
inspection.join.declaration.and.assignment.display.name=Unir declaración y asignación
inspection.join.declaration.and.assignment.option.report.with.complex.initialization.of.member.properties=Informar sobre inicializaciones complejas de propiedades de miembros
inspection.k.doc.missing.documentation.display.name=Faltan comentarios de KDoc en declaraciones públicas
inspection.k.doc.unresolved.reference.display.name=Referencia no resuelta en KDoc
inspection.kotlin.catch.may.ignore.exception.display.name=El bloque 'catch' puede ignorar la excepción
inspection.kotlin.constant.conditions.display.name=Condiciones constantes
inspection.kotlin.covariant.equals.display.name='equals()' covariante
inspection.kotlin.deprecation.display.name=Uso de sintaxis redundante u obsoleta o de símbolos obsoletos
inspection.kotlin.double.negation.action.name=Eliminar doble negación redundante
inspection.kotlin.double.negation.display.name=Doble negación redundante
inspection.kotlin.equals.between.inconvertible.types.display.name='equals()' entre objetos de tipos no convertibles
inspection.kotlin.internal.in.java.display.name=Uso de declaraciones internas de Kotlin desde Java
inspection.kotlin.invalid.bundle.or.property.display.name=Clave de propiedad no válida
inspection.kotlin.jvm.annotation.in.java.description=La anotación JVM de Kotlin ''{0}'' no tiene efecto en Java
inspection.kotlin.jvm.annotation.in.java.display.name=Anotación JVM de Kotlin en Java
inspection.kotlin.maven.plugin.phase.display.name=Plugin de Kotlin Maven mal configurado
inspection.kotlin.options.to.compiler.options.display.name=Uso del DSL 'kotlinOptions' en desuso
inspection.kotlin.redundant.override.display.name=Método de sobreescritura redundante
inspection.kotlin.redundant.suppression.display.name=Supresión de diagnóstico redundante
inspection.kotlin.result.of.filterIsInstance.call.always.empty.collection=El resultado de la llamada a 'filterIsInstance' siempre está vacío
inspection.kotlin.sealed.in.java.display.name=Herencia de una interfaz/clase sellada de Kotlin desde Java
inspection.kotlin.test.j.unit.display.name=Se puede usar kotlin-test-junit
inspection.kotlin.throwable.not.thrown.display.name=Throwable no lanzado
inspection.kotlin.unused.import.display.name=Directiva de importación no utilizada
inspection.kotlin.unused.variable.display.name=Variable no utilizada
inspection.lateinit.var.overrides.lateinit.var.display.name=La propiedad 'lateinit var' sobrescribe la propiedad 'lateinit var'
inspection.leaking.this.display.name=Fuga de 'this' en el constructor
inspection.lift.return.or.assignment.display.name=Se puede extraer el return o la asignación
inspection.lift.return.or.assignment.option.only.single.statement=Informar solo si cada rama es una única sentencia
inspection.local.variable.name.display.name=Convención de nomenclatura de variables locales
inspection.logger.initialized.with.foreign.class.display.name=Logger inicializado con una clase externa
inspection.logger.placeholder.count.matches.argument.count.display.name=El número de marcadores de posición no coincide con el número de argumentos en la llamada de registro
inspection.loop.to.call.chain.display.name=El bucle se puede reemplazar con operaciones de la biblioteca estándar
inspection.main.function.return.unit.display.name=La función main debe devolver 'Unit'
inspection.map.await.on.collection.of.deferred.description=Se utiliza 'map { it.await() }' en 'Collection<Deferred>' en lugar de un único 'awaitAll()'
inspection.map.await.on.collection.of.deferred.display.name=Llamada a 'map { it.await() }' en 'Collection<Deferred>' en lugar de un único 'awaitAll()'
inspection.map.await.on.collection.of.deferred.replace.with.awaitAll=Reemplazar por 'awaitAll()'
inspection.map.get.with.not.null.assertion.operator.display.name='map.get()' con el operador de aserción de no nulo (!!)
inspection.maven.coroutines.deprecation.display.name=Dependencia de kotlinx.coroutines incompatible con Kotlin 1.3+ en Maven
inspection.may.be.constant.display.name=Podría ser 'const'
inspection.member.visibility.can.be.private.display.name=El miembro de clase puede tener visibilidad 'private'
inspection.message.cast.will.always.fail=La conversión siempre fallará
inspection.message.condition.always.false=La condición ''{0}'' siempre es falsa
inspection.message.condition.always.false.when.reached=La condición ''{0}'' siempre es false cuando se alcanza
inspection.message.condition.always.true=La condición ''{0}'' siempre es true
inspection.message.condition.always.true.when.reached=La condición ''{0}'' siempre es true cuando se alcanza
inspection.message.empty.catch.block=Bloque catch vacío
inspection.message.for.never.visited=El rango 'for' siempre está vacío
inspection.message.inconsistent.parameter.name.for.0=Nombre de parámetro inconsistente para ''{0}''
inspection.message.index.out.of.bounds=El índice siempre está fuera de los límites
inspection.message.nonnull.cast.will.always.fail=La operación siempre fallará porque el operando siempre es null
inspection.message.object.with.manual.tostring.can.be.converted.to.data.object=El 'object' con 'toString' manual se puede convertir en 'data object'
inspection.message.result.of.0.always.empty.collection=El resultado de ''{0}'' es siempre una colección vacía
inspection.message.sealed.object.can.be.converted.to.data.object=El subobjeto 'sealed' se puede convertir en 'data object'
inspection.message.value.always.false=El valor de ''{0}'' siempre es false
inspection.message.value.always.null=El valor de ''{0}'' siempre es null
inspection.message.value.always.true=El valor de ''{0}'' siempre es true
inspection.message.value.always.zero=El valor de ''{0}'' siempre es cero
inspection.message.when.condition.always.false=La rama 'when' nunca es accesible
inspection.migrate.diagnostic.suppression.display.name=Se debe reemplazar el nombre del diagnóstico
inspection.move.lambda.outside.parentheses.display.name=Argumento lambda dentro de los paréntesis
inspection.move.suspicious.callable.reference.into.parentheses.display.name=Referencia invocable sospechosa usada como resultado de lambda
inspection.move.variable.declaration.into.when.display.name=La declaración de la variable puede moverse dentro de 'when'
inspection.nested.lambda.shadowed.implicit.parameter.display.name=La lambda anidada tiene un parámetro implícito sombreado
inspection.no.actual.for.expect.display.name=Falta la declaración actual para expect
inspection.non.exhaustive.when.statement.migration.display.name=Las sentencias 'when' no exhaustivas se prohibirán a partir de 1.7
inspection.null.checks.to.safe.call.display.name=Las comprobaciones de nulos pueden sustituirse por llamadas seguras
inspection.nullable.boolean.elvis.action.name=Usar comprobación de igualdad en lugar de elvis para la verificación de booleanos que admiten valores nulos
inspection.nullable.boolean.elvis.display.name=La comprobación de igualdad se puede usar en lugar de elvis para la comprobación de booleanos que admiten valores nulos
inspection.nullable.type.argument.in.java.collection.display.name=Argumento de tipo que admite valores nulos en una colección de Java que no admite null
inspection.object.literal.to.lambda.display.name=El literal de objeto se puede convertir en lambda
inspection.object.private.property.name.display.name=Convención de nomenclatura de propiedades privadas de objetos
inspection.object.property.name.display.name=Convención de nomenclatura de propiedades de objeto
inspection.obsolete.experimental.coroutines.display.name=El uso de corrutinas experimentales está obsoleto desde la versión 1.3
inspection.obsolete.kotlin.js.packages.display.name=Los paquetes 'kotlin.browser' y 'kotlin.dom' están en desuso desde 1.4
inspection.optional.expectation.display.name=La anotación opcional esperada no tiene una anotación real
inspection.package.directory.mismatch.display.name=El nombre del paquete no coincide con el directorio contenedor
inspection.package.name.display.name=Convención de nomenclatura de paquetes
inspection.platform.extension.receiver.of.inline.display.name='inline fun' con receptor que admite nulos hasta Kotlin 1.2
inspection.prefer.current.coroutine.context.to.coroutine.context.inspection.description=El uso de 'kotlin.coroutine.coroutineContext' puede ser ambiguo
inspection.prefer.current.coroutine.context.to.coroutine.context.inspection.fix=Reemplazar por 'currentCoroutineContext()'
inspection.private.property.name.display.name=Convención de nomenclatura de propiedades privadas
inspection.progression.resolution.change.migration.display.name=Cambio de resolución de progresión desde 1.9
inspection.prohibit.jvm.overloads.on.constructors.of.annotation.classes.migration.display.name=La anotación '@JvmOverloads' no se puede utilizar en constructores de clases de anotación desde 1.4
inspection.prohibit.repeated.use.site.target.annotations.migration.display.name=Anotación repetida que no está marcada como '@Repeatable'
inspection.prohibit.type.parameters.for.local.variables.migration.display.name=Variable local con parámetros de tipo
inspection.prohibit.use.site.target.annotations.on.super.types.migration.display.name=Objetivos de anotación sin sentido en la superclase
inspection.property.name.display.name=Convención de nomenclatura de propiedades
inspection.protected.in.final.display.name=La visibilidad 'protected' es efectivamente 'private' en una clase final
inspection.public.api.implicit.type.display.name=Declaración de API pública con tipo de retorno implícito
inspection.recursive.equals.call.display.name=Llamada recursiva a equals
inspection.recursive.property.accessor.display.name=Accesor de propiedad recursivo
inspection.redundant.anonymous.function.description=Creación de funciones anónimas redundantes
inspection.redundant.assequence.call=Llamada a 'asSequence' redundante
inspection.redundant.async.display.name=Llamada 'async' redundante
inspection.redundant.companion.reference.display.name=Referencia a 'Companion' redundante
inspection.redundant.else.in.if.display.name=Else' redundante en 'if
inspection.redundant.elvis.return.null.descriptor=Redundante '?: return null'
inspection.redundant.elvis.return.null.display.name='?: return null' redundante
inspection.redundant.empty.initializer.block.display.name=Bloque de inicialización vacío redundante
inspection.redundant.enum.constructor.invocation.display.name=Invocación redundante del constructor de enum
inspection.redundant.explicit.type.display.name=Tipo explícito obvio
inspection.redundant.getter.display.name=Getter de propiedad redundante
inspection.redundant.if.display.name=Sentencia 'if' redundante
inspection.redundant.inner.class.modifier.descriptor=Modificador 'inner' redundante
inspection.redundant.inner.class.modifier.display.name=Modificador 'inner' redundante
inspection.redundant.interpolation.prefix.display.name=Prefijo de interpolación redundante
inspection.redundant.interpolation.prefix.problem.description=Prefijo de interpolación redundante
inspection.redundant.interpolation.prefix.quick.fix.text=Eliminar prefijo de interpolación redundante
inspection.redundant.label.display.name=Etiqueta redundante
inspection.redundant.label.migration.display.name=Etiqueta redundante
inspection.redundant.label.problem.description=La etiqueta es redundante porque no puede ser referenciada en ninguna de las expresiones 'break', 'continue' o 'return'
inspection.redundant.label.text=Etiqueta redundante
inspection.redundant.labeled.return.on.last.expression.in.lambda.display.name=Return con etiqueta redundante en la última expresión de una lambda
inspection.redundant.lambda.arrow.display.name=Flecha lambda redundante
inspection.redundant.lambda.description=Creación de lambda redundante
inspection.redundant.lambda.or.anonymous.function.display.name=Creación redundante de lambda o función anónima
inspection.redundant.lambda.or.anonymous.function.fix=Inlinear el cuerpo
inspection.redundant.modality.modifier.display.name=Modificador de modalidad redundante
inspection.redundant.not.null.extension.receiver.of.inline.display.name=El receptor de extensión de 'inline fun' puede ser explícitamente anulable hasta Kotlin 1.2
inspection.redundant.nullable.return.type.display.name=Tipo de retorno que admite nulos redundante
inspection.redundant.object.type.check.display.name=Comprobación de tipo 'is' no idiomática para un objeto
inspection.redundant.require.not.null.call.display.name=Llamada redundante a 'requireNotNull' o 'checkNotNull'
inspection.redundant.return.label.display.name=Etiqueta 'return' redundante
inspection.redundant.run.catching.display.name=Llamada a 'runCatching' redundante
inspection.redundant.sam.constructor.display.name=Constructor SAM redundante
inspection.redundant.semicolon.display.name=Punto y coma redundante
inspection.redundant.setter.display.name=Setter de propiedad redundante
inspection.redundant.suspend.modifier.display.name=Modificador 'suspend' redundante
inspection.redundant.unit.expression.display.name='Unit' redundante
inspection.redundant.unit.return.type.action.name=Eliminar tipo de retorno 'Unit' redundante
inspection.redundant.unit.return.type.display.name=Tipo de retorno 'Unit' redundante
inspection.redundant.value.argument.annotation=El argumento de valor coincide con el valor predeterminado del parámetro ''{0}''
inspection.redundant.value.argument.display.name=Argumento de valor redundante
inspection.redundant.visibility.modifier.display.name=Modificador de visibilidad redundante
inspection.redundant.with.display.name=Llamada 'with' redundante
inspection.remove.curly.braces.from.template.display.name=Llaves redundantes en la plantilla de cadena
inspection.remove.empty.class.body.display.name=Reemplazar cuerpo de clase vacío
inspection.remove.empty.parentheses.from.annotation.entry.display.name=Eliminar paréntesis innecesarios
inspection.remove.empty.parentheses.from.lambda.call.action.name=Eliminar los paréntesis innecesarios de la llamada a la función con lambda
inspection.remove.empty.parentheses.from.lambda.call.display.name=Paréntesis innecesarios en la llamada a la función con lambda
inspection.remove.empty.primary.constructor.display.name=Constructor primario vacío redundante
inspection.remove.empty.secondary.constructor.body.display.name=Cuerpo del constructor redundante
inspection.remove.explicit.super.qualifier.display.name=Calificación de supertipo innecesaria
inspection.remove.explicit.type.arguments.display.name=Argumento de tipo innecesario
inspection.remove.for.loop.indices.display.name=Índice de bucle no utilizado
inspection.remove.interpolation.prefix.display.name=Prefijo de interpolación de varios signos de dólar eliminable
inspection.remove.interpolation.prefix.problem.description=El prefijo de la cadena se puede eliminar
inspection.remove.interpolation.prefix.quick.fix.text=Eliminar prefijo de múltiples signos de dólar
inspection.remove.redundant.backticks.display.name=Comillas invertidas redundantes
inspection.remove.redundant.calls.of.conversion.methods.display.name=Llamada redundante a un método de conversión
inspection.remove.redundant.qualifier.name.display.name=Nombre de calificador redundante
inspection.remove.redundant.spread.operator.display.name=Operador de propagación redundante
inspection.remove.setter.parameter.type.display.name=Tipo de parámetro de setter redundante
inspection.remove.single.expression.string.template.display.name=Plantilla de cadena redundante
inspection.remove.to.string.in.string.template.display.name=Llamada redundante a 'toString()' en la plantilla de cadena
inspection.replace.array.equality.op.with.arrays.equals.display.name=Comparación de arrays mediante '==' y '!='
inspection.replace.array.of.with.literal.display.name=La llamada a 'arrayOf' puede reemplazarse por un literal de array […]
inspection.replace.assert.boolean.with.assert.equality.display.name=La aserción de booleano se puede reemplazar por una aserción de igualdad
inspection.replace.associate.function.display.name=associate' se puede reemplazar por 'associateBy' o 'associateWith
inspection.replace.call.with.binary.operator.display.name=Se puede reemplazar con un operador binario
inspection.replace.collection.count.with.size.display.name=El recuento de la colección se puede convertir a tamaño
inspection.replace.get.or.set.display.name=Llamada explícita a 'get' o 'set'
inspection.replace.guard.clause.with.function.call.display.name=La cláusula de guarda se puede reemplazar por una llamada a función de Kotlin
inspection.replace.isempty.with.ifempty.display.name=La condición 'if' se puede reemplazar con una llamada lambda
inspection.replace.java.static.method.with.kotlin.analog.display.name=Los métodos Java deben reemplazarse por el equivalente en Kotlin
inspection.replace.manual.range.with.indices.calls.display.name=El rango puede convertirse en índices o iteración
inspection.replace.mapIndexed.with.list.generator.display.name=Reemplazar 'mapIndexed' por un generador de List
inspection.replace.negated.is.empty.with.is.not.empty.display.name=La llamada negada se puede simplificar
inspection.replace.not.null.assertion.with.elvis.return.display.name=La aserción de no nulidad puede reemplazarse con 'return'
inspection.replace.put.with.assignment.display.name='map.put()' se puede convertir en una asignación
inspection.replace.range.start.end.inclusive.with.first.last.display.name=Las propiedades boxed deben reemplazarse por unboxed
inspection.replace.range.to.with.rangeUntil.display.name=RangeTo' o la llamada '..' debe reemplazarse por '..<
inspection.replace.range.to.with.until.display.name=La llamada a 'rangeTo' o '..' debe reemplazarse por 'until'
inspection.replace.readline.with.readln.display.name=ReadLine' se puede reemplazar por 'readln' o 'readlnOrNull
inspection.replace.size.check.with.is.not.empty.display.name=La comprobación de tamaño se puede reemplazar por 'isNotEmpty()'
inspection.replace.size.zero.check.with.is.empty.display.name=La comprobación de tamaño cero puede reemplazarse por 'isEmpty()'
inspection.replace.string.format.with.literal.display.name=La llamada a 'String.format' se puede reemplazar con plantillas de cadena
inspection.replace.substring.with.drop.last.display.name=La llamada a 'substring' debe reemplazarse por la llamada a 'dropLast'
inspection.replace.substring.with.indexing.operation.display.name=La llamada a 'substring' debe sustituirse por el operador de indexación
inspection.replace.substring.with.substring.after.display.name=La llamada a 'substring' debe reemplazarse por 'substringAfter'
inspection.replace.substring.with.substring.before.display.name=La llamada a 'substring' debe sustituirse por 'substringBefore'
inspection.replace.substring.with.take.display.name=La llamada a 'substring' debe reemplazarse por la llamada a 'take'
inspection.replace.to.string.with.string.template.display.name=La llamada a 'toString' se puede reemplazar con una plantilla de cadena
inspection.replace.to.with.infix.form.display.name=La llamada 'to' debe reemplazarse por la forma infija
inspection.replace.until.with.rangeUntil.operator.display.name=Reemplazar 'until' con el operador '..<'
inspection.replace.with.enum.map.display.name=HashMap' se puede reemplazar por 'EnumMap
inspection.replace.with.ignore.case.equals.display.name=Debe reemplazarse por 'equals(…, ignoreCase = true)'
inspection.replace.with.import.alias.display.name=El nombre plenamente cualificado puede reemplazarse por un alias de importación existente
inspection.replace.with.operator.assignment.display.name=La asignación puede reemplazarse por una asignación con operador
inspection.replace.with.string.builder.append.range.display.name=Llamada a 'StringBuilder.append(CharArray, offset, len)' en la JVM
inspection.restrict.return.statement.target.migration.display.name=La etiqueta de destino no denota una función desde 1.4
inspection.run.blocking.in.suspend.function.description=El uso de 'runBlocking' dentro de una función suspend bloquea el hilo de llamada, lo que anula el propósito de la programación asíncrona
inspection.run.blocking.in.suspend.function.display.name=Llamar a 'runBlocking' desde una función suspend es redundante
inspection.runblocking.analysis.found.runblocking=--> runBlocking
inspection.runblocking.analysis.graphbuilding.progress=Procesando {0}
inspection.runblocking.presentation.descriptor=Analizando runBlocking:
inspection.runblocking.presentation.display.name=RunBlocking en una corrutina
inspection.runblocking.presentation.settings.exploration.option.all=Sí, incluyendo sobrescrituras
inspection.runblocking.presentation.settings.exploration.option.declaration=Sí, excluyendo sobrescrituras
inspection.runblocking.presentation.settings.exploration.option.strict=No
inspection.runblocking.presentation.settings.exploration.title=Explorar funciones con sobrescrituras
inspection.runblocking.presentation.text=Constructor runBlocking llamado desde una corrutina
inspection.safe.cast.with.return.display.name=La conversión segura con 'return' debe reemplazarse por una comprobación de tipo 'if'
inspection.scope.function.conversion.display.name=La función de ámbito se puede convertir en otra
inspection.self.assignment.display.name=Asignación redundante
inspection.self.reference.constructor.parameter.display.name=El constructor nunca se puede completar
inspection.setter.backing.field.assignment.display.name=Campo de respaldo existente sin asignación
inspection.simple.redundant.let.display.name=Llamada 'let' redundante basada en el receptor
inspection.simplifiable.call.chain.display.name=La cadena de llamadas en el tipo de colección puede simplificarse
inspection.simplifiable.call.display.name=La llamada a la función de biblioteca se puede simplificar
inspection.simplifiable.scope.function.display.name=La función de alcance con forEach anidado se puede simplificar
inspection.simplify.assert.not.null.display.name=La llamada 'assert' se puede reemplazar por '!!' o '?:'
inspection.simplify.boolean.with.constants.display.name=La expresión booleana se puede simplificar
inspection.simplify.negated.binary.expression.display.name=Se puede simplificar la expresión booleana negada
inspection.simplify.when.with.boolean.constant.condition.display.name='when' simplificable
inspection.sort.modifiers.display.name=Orden de modificadores no canónico
inspection.suspend.function.on.coroutine.scope.display.name=CoroutineContext ambiguo debido al receptor CoroutineScope de la función suspend
inspection.suspicious.as.dynamic.display.name=Invocación sospechosa de miembro 'asDynamic'
inspection.suspicious.collection.reassignment.display.name=La asignación compuesta crea una nueva colección internamente
inspection.suspicious.equals.combination.display.name=Combinación sospechosa de == y ===
inspection.suspicious.implicit.coroutine.scope.receiver.add.explicit.receiver.fix.text=Añadir receptor explícito con etiqueta (no cambia la semántica)
inspection.suspicious.implicit.coroutine.scope.receiver.description=Existe un acceso implícito sospechoso al receptor 'CoroutineScope' dentro de un contexto suspend
inspection.suspicious.implicit.coroutine.scope.receiver.detect.subclasses.option=Detectar receptores de subtipos de 'CoroutineScope'
inspection.suspicious.implicit.coroutine.scope.receiver.display.name=Acceso sospechoso al receptor implícito 'CoroutineScope'
inspection.suspicious.var.property.display.name=Propiedad 'var' sospechosa: su setter no influye en el resultado de su getter
inspection.test.function.name.display.name=Convención de nomenclatura de funciones de prueba
inspection.this.class.does.not.have.a.constructor=Llamada a constructor prohibida
inspection.trailing.comma.add.line.break=Añadir salto de línea
inspection.trailing.comma.add.trailing.comma=Añadir coma final
inspection.trailing.comma.comma.loses.the.advantages.in.this.position=La coma pierde sus ventajas en esta posición
inspection.trailing.comma.display.name=Recomendaciones de coma final
inspection.trailing.comma.fix.comma.position=Corregir posición de la coma
inspection.trailing.comma.missing.line.break=Falta el salto de línea
inspection.trailing.comma.missing.trailing.comma=Falta la coma final
inspection.trailing.comma.remove.trailing.comma=Eliminar coma final
inspection.trailing.comma.report.also.a.missing.comma=Informar también de la falta de una coma o un salto de línea
inspection.trailing.comma.useless.trailing.comma=Coma final innecesaria
inspection.unlabeled.return.inside.lambda.display.name=Return sin etiqueta dentro de lambda
inspection.unnecessary.opt_in.annotation.display.name=Anotación '@OptIn' innecesaria
inspection.unnecessary.opt_in.redundant.annotation=La anotación opt-in es redundante: no se utiliza ninguna API experimental coincidente
inspection.unnecessary.opt_in.redundant.marker=El marcador de opt-in es redundante: no se utiliza ninguna API experimental marcada con ''{0}''
inspection.unnecessary.opt_in.remove.annotation.fix.family.name=Eliminar anotación
inspection.unnecessary.opt_in.remove.marker.fix.family.name=Eliminar marcador de inclusión voluntaria
inspection.unnecessary.variable.display.name=Variable local innecesaria
inspection.unnecessary.variable.option.report.immediately.returned.variables=Informar sobre variables devueltas inmediatamente
inspection.unreachable.code=Código inalcanzable
inspection.unreachable.code.remove.unreachable.code=Eliminar código inalcanzable
inspection.unsafe.cast.from.dynamic.display.name=Conversión implícita (no segura) desde el tipo dynamic
inspection.unused.equals.display.name=Expresión equals no utilizada
inspection.unused.expression.display.name=Expresión no utilizada
inspection.unused.expression.problem.description=La expresión no se utiliza
inspection.unused.flow.display.name=Flujo no utilizado
inspection.unused.lambda.expression.body.display.name=Valor de retorno no utilizado de una función con cuerpo de expresión lambda
inspection.unused.lambda.expression.inspection.display.name=Expresión lambda no utilizada
inspection.unused.lambda.expression.inspection.problem.description=La expresión lambda nunca se invoca. Para crear un bloque de ámbito, use 'run { … }'
inspection.unused.main.parameter.display.name=El parámetro de main no es necesario
inspection.unused.receiver.parameter=El parámetro receptor nunca se utiliza
inspection.unused.receiver.parameter.display.name=Parámetro receptor no utilizado
inspection.unused.result.of.data.class.copy=Resultado no utilizado de la copia de clase de datos
inspection.unused.symbol.display.name=Símbolo no utilizado
inspection.unused.unary.operator.display.name=Operador unario no utilizado
inspection.use.expression.body.display.name=La sintaxis de cuerpo de expresión es preferible aquí
inspection.use.property.access.syntax.display.name=Llamada a un accesor que puede reemplazarse por la sintaxis de acceso a propiedades
inspection.use.with.index.display.name=La variable de índice incrementada manualmente puede reemplazarse por el uso de 'withIndex()'
inspection.useless.call.on.collection.display.name=Llamada inútil en tipo de colección
inspection.useless.call.on.not.null.display.name=Llamada inútil en un tipo no nulo
inspection.variable.initializer.is.redundant.display.name=El inicializador de variable es redundante
inspection.variable.is.never.read.display.name=La variable nunca se lee
inspection.verbose.nullability.and.emptiness.call=Reemplazar las comprobaciones posteriores con la llamada a ''{0}()''
inspection.verbose.nullability.and.emptiness.display.name=Comprobación detallada de nulidad y vacuidad
inspection.warning.on.main.unused.parameter.migration.display.name='args' no utilizado en 'main' desde 1.4
inspection.when.with.only.else.action.name=Simplificar 'when' con solo una rama 'else'
inspection.when.with.only.else.display.name='when' tiene solo la rama 'else' y puede simplificarse
inspection.wrap.unary.operator.display.name=Uso de operador unario ambiguo con una constante numérica
intention.add.import.alias.group.name=Añadir alias de importación
intention.change.package.text=Cambiar paquete
intention.collection.concatenation.to.build.collection.call.family.name=Convertir a constructor de colecciones
intention.convert.lambda.line=Convertir a lambda de {0,choice,0#una sola línea|1#varias líneas}
intention.create.test.dialog.kotlin=Kotlin
intention.error.cannot.create.class.message=No se puede crear la clase ''{0}''
intention.error.cannot.create.class.title=Error al crear la clase
intention.extract.declarations.from.file.text=Extraer declaración del archivo actual
intention.extract.declarations.from.file.text.details=Extraer ''{0}'' {1, choice, 0#|1#y subclases }del archivo actual
intention.flow.on.dispatchers.io=Flow en 'Dispatchers.IO'
intention.implement.abstract.method.command.name=Implementar método
intention.implement.abstract.method.searching.for.descendants.progress=Buscando descendientes…
intention.name.specify.supertype=Especificar supertipo
intention.name.specify.supertype.title=Especificar supertipo
intention.name.use.correct.parameter.name=Usar el nombre de parámetro correcto
intention.switch.context.to.dispatchers.io=Cambiar al contexto 'Dispatchers.IO'
intention.trailing.comma.custom.text={0,choice,0#Activar|1#Desactivar} una coma final por defecto en el formateador
intention.trailing.comma.text=Activar/desactivar la coma final en el formateador
intention.wrap.in.with.context=Envolver llamada en 'withContext'
interface=Interfaz
interface.member.dependency.required.by.interfaces=Requerido por {0,choice,1#interfaz|2#interfaces}
interface.should.be.external=La interfaz debe ser external
internal.toggle.throwing.cached.pce.title=Interno: alternar lanzamiento de PCE en caché
introduce.0.as.subject.0.when=Introducir ''{0}'' como sujeto de ''when''
introduce.anonymous.parameter.fix.family.name=Introducir parámetro anónimo
introduce.backing.property=Introducir propiedad de respaldo
introduce.constant=Introducir constante
introduce.import.alias=Introducir alias de importación
introduce.property=Introducir propiedad
introduce.type.parameter=Introducir parámetro de tipo
introduce.type.parameter.to.declaration=Introducir parámetro de tipo en la declaración
introduce.variable=Introducir variable
introduce.when.subject=Introducir sujeto de 'when'
invert.if.condition=Invertir la condición 'if'
it.s.prohibited.to.call.0.with.min.value.step.since.1.3=Está prohibido llamar a {0} con el paso MIN_VALUE desde 1.3
iterate.over.0=Iterar sobre ''{0}''
iterate.over.collection=Iterar sobre la colección
java.collection.is.parameterized.with.nullable.type=La colección Java ''{0}'' está parametrizada con {1,choice,1#un tipo que admite valores nulos|2#tipos que admiten valores nulos}
java.collections.static.method.call.should.be.replaced.with.kotlin.stdlib=La llamada al método estático de Java Collections debe reemplazarse por Kotlin stdlib
java.collections.to.process=Colecciones Java a procesar:
java.map.foreach.method.call.should.be.replaced.with.kotlin.s.foreach=La llamada al método Map.forEach de Java debe reemplazarse por el forEach de Kotlin
join.declaration.and.assignment=Unir declaración y asignación
join.with.initializer.fix.text=Unir con el inicializador
junit.static.methods=Métodos estáticos de JUnit
kdoc.comment.unresolved=Sin resolver
kdoc.section.title.author=Autores
kdoc.section.title.constructor=Constructor
kdoc.section.title.parameters=Parámetros
kdoc.section.title.properties=Propiedades
kdoc.section.title.receiver=Receptor
kdoc.section.title.returns=Devuelve
kdoc.section.title.samples=Ejemplos
kdoc.section.title.see.also=Véase también
kdoc.section.title.since=Desde
kdoc.section.title.suppress=Suprimir
kdoc.section.title.throws=Lanza
kmp.move.not.supported.message=Todavía puedes mover, pero la declaración esperada/real coincidente no se moverá.
kmp.move.not.supported.title=No se admite el desplazamiento multiplataforma
kotlin.call.chains.hints=Kotlin: mostrar sugerencias incrustadas para cadenas de llamadas
kotlin.compiler.configurable=Compilador de Kotlin
kotlin.dist.downloading.failed.group.name=Error al descargar la distribución de Kotlin
kotlin.external.compiler.updates.notification.group.name=Actualizaciones del compilador externo de Kotlin disponibles
kotlin.jps.plugin.group.name=Plugin Kotlin JPS
kotlin.lambdas.hints=Kotlin: Mostrar pistas integradas para lambdas
kotlin.lambdas.hints.hints.lambda.receivers.parameters=Kotlin: Mostrar sugerencias incrustadas para receptores y parámetros implícitos
kotlin.lambdas.hints.hints.lambda.return=Kotlin: Mostrar sugerencias incrustadas para expresiones return
kotlin.references.types.hints=Kotlin: mostrar sugerencias incrustadas para los tipos
kotlin.references.types.hints.hints.type.function.parameter=Kotlin: Mostrar sugerencias integradas para tipos de parámetros de función
kotlin.references.types.hints.hints.type.function.return=Kotlin: Mostrar sugerencias incrustadas para los tipos de retorno de función
kotlin.references.types.hints.hints.type.property=Kotlin: Mostrar sugerencias incrustadas para tipos de propiedad
kotlin.references.types.hints.hints.type.variable=Kotlin: Mostrar sugerencias incrustadas para tipos de variables locales
kotlin.script.definitions.model.name.autoReloadScriptDependencies=Recarga automática
kotlin.script.definitions.model.name.autoReloadScriptDependencies.description=Activa la recarga automática si deseas cargar las configuraciones de los scripts automáticamente al cambiar los archivos
kotlin.script.definitions.model.name.is.enabled=Habilitado
kotlin.script.definitions.model.name.name=Nombre
kotlin.script.definitions.model.name.pattern.extension=Patrón/Extensión
kotlin.script.definitions.title=Gestionar definiciones de script:
kotlin.script.in.beta.stage=Kotlin Scripting se encuentra ahora en fase beta
kotlin.script.in.beta.stage.link=Https://kotlinlang.org/docs/components-stability.html#stability-levels-explained
kotlin.script.in.project.sources=<html>Este script no debería estar dentro de la raíz de fuentes. A partir de Kotlin 1.9, se ignorará durante la compilación del módulo.</html>
kotlin.script.in.project.sources.1.9=<html>Este script no debe estar dentro de la raíz de fuentes. A partir de Kotlin 1.9, se ignora durante la compilación del módulo.</html>
kotlin.script.in.project.sources.allow=Permitir…
kotlin.script.in.project.sources.hide=Ocultar
kotlin.script.in.project.sources.later=Decidir más tarde
kotlin.script.in.project.sources.link=Https://youtrack.jetbrains.com/issue/KT-52735
kotlin.script.in.project.sources.move=Mover a…
kotlin.script.lookup.definitions=Buscando definiciones de script de Kotlin…
kotlin.script.sources.index=Índice
kotlin.script.sources.not.yet.indexed=No se indexaron los archivos fuente para reducir el tiempo de inicio del proyecto
kotlin.script.warning.more.info=Más información
kotlin.scripting.configurable=Scripting de Kotlin
kotlin.unreachable.code.display.name=Código inalcanzable
kotlin.values.hints=Mostrar sugerencias incrustadas para valores
kotlin.values.hints.kotlin.values.ranges=Kotlin: Mostrar sugerencias incrustadas para rangos
label.text.default.receiver.value=Valor del receptor por &defecto:
label.text.destination=&Destino:
label.text.destination.directory=Directorio de &destino:
label.text.file=&Archivo:
label.text.file.name=&Nombre de archivo:
label.text.introduce.as=Introducir como (&I):
label.text.move.expect.actual.counterparts=&Mover contrapartes expect/actual
label.text.name=&Nombre:
label.text.package=P&aquete:
label.text.package.name=Nombre del paquete(&G):
label.text.receiver.type=&Tipo de receptor:
label.text.source.sets=Conjuntos de fuentes:
label.text.target.file.name=Nombre del archivo de destino:
label.text.to.class=A la clase:
label.text.to.file=Al &archivo:
label.text.to.object=Al objeto:
label.text.to.package=Al p&aquete:
label.text.type=&Tipo:
label.text.visibility=&Visibilidad:
lambda.argument.0.be.moved.out=El argumento lambda {0,choice,0#puede|1#debe} moverse fuera de los paréntesis
leaking.this.in.constructor.of.enum.class.0.with.overridable.members=Filtración de ''this'' en el constructor de la clase enum {0} (con miembros sobrescribibles)
leaking.this.in.constructor.of.non.final.class.0=Fuga de ''this'' en el constructor de la clase no final {0}
let.0.1=Hacer que {0} {1}
let.type.implement.interface=Hacer que el tipo implemente la interfaz
lift.assignment.out.fix.text.0=Extraer la asignación de ''{0}''
lift.assignment.out.of.try.expression=Extraer la asignación de la expresión 'try'
lift.function.call.out.of.if=Extraer llamada a la función fuera de 'if'
lift.function.call.out.of.when=Extraer la llamada a la función de 'when'
lift.return.out.fix.text.0=Extraer el return de ''{0}''
lift.return.out.of.if.expression=Extraer return de la expresión 'if'
listbox.import.package=Paquete
listbox.import.with.subpackages=Con subpaquetes
livetemplate.description.anonymous=Clase anónima
livetemplate.description.closure=Clausura (función sin nombre)
livetemplate.description.exfun=Función de extensión
livetemplate.description.exval=Propiedad de extensión de solo lectura
livetemplate.description.exvar=Propiedad de lectura y escritura de extensión
livetemplate.description.fun0=Función sin parámetros
livetemplate.description.fun1=Función con un parámetro
livetemplate.description.fun2=Función con dos parámetros
livetemplate.description.ifn=Inserta la expresión 'if null'
livetemplate.description.inn=Inserta la expresión 'if not null'
livetemplate.description.interface=Interfaz
livetemplate.description.iter=Iterar sobre los elementos de un iterable (bucle for-in)
livetemplate.description.main=Función main()
livetemplate.description.maina=Función main(args)
livetemplate.description.singleton=Singleton
livetemplate.description.soutp=Imprime los nombres y valores de los parámetros de la función en System.out
livetemplate.description.void=Función que no devuelve nada
local.variable=Variable local
logger.initialized.with.foreign.class=Logger inicializado con la clase externa ''{0}''
looking.for.usages.and.conflicts=Buscando usos y conflictos…
looking.for.usages.in.java.files=Buscando usos en archivos Java…
loop.can.be.replaced.with.stdlib.operations=El bucle se puede reemplazar con operaciones de stdlib
loop.parameter.0.is.unused=El parámetro de bucle ''{0}'' no se utiliza
loop.to.call.fix.family.name=Reemplazar con operaciones de stdlib
loop.to.call.fix.family.name2=Reemplazar por operaciones de la stdlib con el uso de 'asSequence()'
make.0=Hacer {0}
make.0.1=Hacer ''{0}'' {1}
make.0.1.explicitly=Hacer ''{0}'' {1} explícitamente
make.0.an.annotation.class=Convertir ''{0}'' en una clase de anotación
make.0.explicitly=Hacer {0} explícitamente
make.0.in.1.open=Hacer que ''{0}'' en {1} sea open
make.0.not.1=Hacer que {0} no sea {1}
make.class.an.annotation.class=Convertir clase en clase de anotación
make.constructor.parameter.a.property.0=Convertir el parámetro del constructor en una propiedad{0}
make.member.static.quickfix=Hacer ''{0}'' estático
make.not.nullable=Hacer no nulo
make.open=Hacer 'open'
make.open.fix.text=Hacer la clase open
make.override.accessor.function.0=Crear función de acceso de sobreescritura ''{0}''
make.primary.constructor.0=Convertir en constructor primario {0}
make.private.and.0.1=Hacer private y {0} ''{1}''
make.private.fix.text=Hacer private
make.type.parameter.reified.and.function.inline=Hacer que el parámetro de tipo sea reificado y la función sea inline
making.member.static=Haciendo el miembro estático…
map.get.or.default.can.be.replaced.with.indexing.and.elvis.operator='map.getOrDefault()' puede reemplazarse por el operador de indexación y el operador elvis
map.get.with.not.null.assertion.operator=Map.get()' con el operador de aserción de no nulo '(!!)
map.put.should.be.converted.to.assignment=Map.put() debe convertirse en una asignación
mark.as.deprecated.level.deprecationlevel.hidden=Marcar como '@Deprecated(…, level = DeprecationLevel.HIDDEN)'
max.functions.to.visit=Máximo de funciones a visitar
maximum.count.of.applied.refactoring.before.validity.check=Número máximo de refactorizaciones aplicadas antes de la comprobación de validez
may.contain.only.letters.and.digits=Solo puede contener letras y dígitos
may.contain.only.letters.digits.or.underscores=Solo puede contener letras, números o guiones bajos
member.info.abstract.0=Abstracto {0}
member.info.companion.0=Compañero {0}
merge.else.if=Combinar 'else if'
merge.if.s=Fusionar 'if's
message.change.signature.is.not.applicable.to.dynamically.invoked.functions=Cambiar la firma no es aplicable a funciones invocadas dinámicamente
message.do.not.show.for.local.variables.in.future=No volver a mostrar para variables locales en el futuro
message.text.property.receiver.type.cannot.be.resolved=No se puede resolver el tipo de receptor de la propiedad ''{0}''.\n¿Continuar?
message.text.property.type.cannot.be.resolved=No se puede resolver el tipo de propiedad ''{0}''.\n¿Continuar?
message.text.return.type.cannot.be.resolved=No se puede resolver el tipo de retorno ''{0}''.\n¿Continuar?
message.type.for.cannot.be.resolved=No se puede resolver el tipo ''{0}'' para {1}.\n¿Continuar?
methods.are.absent.in.coroutines.class.since.1.3=Los métodos están ausentes en la clase de corrutinas desde 1.3
microservices.url.path.inlay.hints=Kotlin: Mostrar sugerencias de inlay para la ruta de URL
might.be.const=Puede ser 'const'
migrate.type.parameter.list.syntax=Migrar la sintaxis de la lista de parámetros de tipo
migrate.unsupported.yield.syntax=Migrar sintaxis yield no compatible
minimal.line.count=Número mínimo de líneas
missing.documentation=Falta documentación
modifiers.should.follow.annotations=Los modificadores deben ir después de las anotaciones
move.annotation.to.receiver.type=Mover anotación al tipo de receptor
move.else.branch.to.the.end=Mover la rama else al final
move.lambda.argument.into.parentheses=Mover argumento lambda a los paréntesis
move.lambda.argument.out.of.parentheses=Mover el argumento lambda fuera de los paréntesis
move.members.from=Mover miembros desde:
move.out.of.companion.object=Mover fuera del objeto compañero
move.refactoring.error.text.cannot.perform.refactoring.since.the.following.files.already.exist=No se puede realizar la refactorización porque los siguientes archivos ya existen:\n\n
move.refactoring.test=Prueba de refactorización de movimiento
move.refactoring.testing=Pruebas de refactorización de movimiento
move.reference.into.parentheses=Mover referencia a los paréntesis
move.to.class.body=Mover al cuerpo de la clase
move.to.companion.object=Mover al objeto compañero
move.to.companion.object.command=Mover al objeto compañero
move.to.constructor=Mover al constructor
move.to.constructor.parameters=Mover a los parámetros del constructor
move.to.top.level=Mover al nivel superior
move.type.parameter.constraint.to.where.clause=Mover la restricción del parámetro de tipo a la cláusula 'where'
move.unary.operator.to.previous.line.fix.text=Mover el operador unario a la línea anterior
move.variable.declaration.into.when=Mover declaración de variable a 'when'
moving.to.companion.object=Moviendo al objeto companion…
name=&Nombre:
name.extract.interface=Extraer interfaz
name.introduce.import.alias=Introducir alias de importación
name.introduce.lambda.parameter=Introducir parámetro lambda
name.introduce.parameter1=Introducir parámetro
name.introduce.type.alias=Introducir alias de tipo
name.specify.supertype.command.title=Especificar supertipo
naming.convention.will.be.violated.after.rename=Se infringirán las convenciones de nomenclatura después de renombrar
negated.operation.can.be.simplified=La operación negada se puede simplificar
nested.1.call.in.0.could.be.simplified.to.2=La llamada a ''{1}'' anidada en ''{0}'' podría simplificarse a {2}
no.actual.for.expect.declaration=No hay una declaración actual para la declaración expect en los módulos: {0}
non.canonical.modifiers.order=Orden de modificadores no canónico
non.external.classifier.extending.state.or.props.name=Clasificador no externo que extiende State o Props
not.found.in.0.files=No se encontró en {0} archivo(s)
nothing.to.do=Nada que hacer
notification.navigation.to.overriding.classes=No es posible navegar a las clases que sobrescriben durante la actualización del índice
notification.text.kotlin.js.compiler.body=Utilice el nuevo compilador Kotlin/JS IR para reducir el tamaño del bundle de su aplicación y generar automáticamente definiciones de TypeScript (d.ts).
notification.text.kotlin.js.compiler.learn.more=Más información
notification.text.kotlin.js.compiler.link=Https://kotl.in/jsirstable
notification.text.kotlin.js.compiler.title=¡Kotlin/JS IR es estable en las versiones 1.8.0 y posteriores!
null.checks.replaceable.with.safe.calls=Las comprobaciones de nulo pueden reemplazarse por llamadas seguras
null.checks.to.safe.call.check.fix.text=Reemplazar las comprobaciones de null encadenadas por llamadas seguras
number.of.attempts.then.files.in.project.0=Número de intentos > archivos en el proyecto, {0}
object.0=Objeto "{0}"
object.or.top.level.property=Objeto o propiedad de nivel superior
object.private.property=Propiedad privada del objeto
object.should.be.external.interface=El objeto debe ser una interfaz externa
obsolete.coroutine.usage.fix.family.name=Corregir el uso de corrutinas experimentales
obsolete.coroutine.usage.in.whole.fix.family.name=Corregir usos de corrutinas experimentales en el proyecto
obsolete.kotlin.js.packages.usage.in.whole.fix.family.name=Corregir los usos de los paquetes 'kotlin.dom' y 'kotlin.browser' en el proyecto
obsolete.package.usage.fix.family.name=Corregir el uso del paquete ''{0}''
one.line.return=Retorno en una sola línea
open.moved.members.in.editor=Abrir miembros movidos en el editor
open.moved.method.in.editor=Abrir el método movido en el editor
optimize.imports=Optimizar importaciones
optimize.imports.collect.unused.imports=Recopilando importaciones no utilizadas
optimize.imports.task.removing.redundant.imports=Eliminando importaciones redundantes
optionally.expected.annotation.has.no.actual.annotation.in.module.0.for.platform.1=La anotación opcional esperada no tiene una anotación real en el módulo {0} para la plataforma {1}
overridden.marker.implementation=Se implementa en
overridden.marker.implementations.choose.implementation.find.usages=Propiedades de sobrescritura de {0}
overridden.marker.implementations.choose.implementation.title=Seleccionar implementación de {0}
overridden.marker.implementations.multiple=Tiene implementaciones
overridden.marker.overrides=Se sobrescribe en
overridden.marker.overrides.choose.implementation.find.usages=Superimplementaciones de {0}
overridden.marker.overrides.choose.implementation.title=Seleccionar la superimplementación de {0}
overridden.marker.overrides.multiple=Sobrescrito en subclases
override.accessor.functions.instead=Sobrescribir funciones de acceso en su lugar
override.declaration.choose.to.delete=<html>Hay miembros no utilizados que sobrescriben métodos que se van a eliminar. Seleccione los que también desea eliminar:</html>
override.declaration.delete.multiple.parameters={0} es parte de la jerarquía de métodos. ¿Desea eliminar varios parámetros?
override.declaration.member=Miembro
override.declaration.unused.overriding.methods.description=Hay miembros no utilizados que sobrescriben los métodos que va a eliminar.
override.declaration.unused.overriding.methods.title=Miembros de sobrescritura no utilizados
override.declaration.x.implements.y={0} implementa {1}.
override.declaration.x.in.y={0} en {1}
override.declaration.x.overrides.y.in.class.list={0} sobrescribe las declaraciones en las siguientes clases/interfaces: {1} ¿Desea {2} las declaraciones base?
override.java.default.methods.delegate.fix.text=Sobrescribir los métodos predeterminados de Java mediante la delegación al objeto delegado
override.java.default.methods.superclass.fix.text=Sobrescribir los métodos predeterminados de Java mediante la delegación explícita a la superclase
package.0.already.contains.1=El paquete ''{0}'' ya contiene {1}
package.name=Nombre del paquete
package.usages.are.obsolete.since.1.4=Los usos del paquete ''{0}'' están obsoletos desde 1.4
parameter.0=Parámetro "{0}"
parameter.hints.old=Kotlin: Mostrar sugerencias incrustadas para los parámetros
parameter.name.is.invalid=El nombre del parámetro ''{0}'' no es válido
parameter.name.prompt=Nombre del pará&metro:
parameter.type.is.invalid=El tipo de parámetro ''{0}'' no es válido
parameter.types.are.not.denotable=No se puede extraer el método ya que los siguientes tipos no son denotables en el ámbito de destino:
parameter.used.in.declaration.body.warning=''{0}'' se utiliza en el cuerpo de la declaración
parentheses.should.be.removed=Se deben eliminar los paréntesis
pass.outer.class.instance.as.parameter=Pasar la instancia de la clase &externa como parámetro
perform.refactoring=Realizar refactorización…
placeholder.count.matches.argument.count.fewer.problem.descriptor=Se han proporcionado menos argumentos ({0}) que marcadores de posición especificados ({1}) #loc
placeholder.count.matches.argument.count.more.problem.descriptor=Se han proporcionado más argumentos ({0}) que los marcadores de posición especificados ({1}) #loc
popup.title.choose.supertype=Seleccionar supertipo
popup.title.elements=Elementos
popup.title.expressions=Expresiones
popup.title.types=Tipos
predefined.configuration.all.methods.of.the.class=Todos los métodos de la clase
predefined.configuration.all.vars.of.the.class=Todas las variables de una clase
predefined.configuration.all.vars.of.the.object=Todas las variables de un objeto
predefined.configuration.also.match.vals=Coincidir tanto con var como con val
predefined.configuration.annotations=Anotaciones
predefined.configuration.anonymous.class=Clase anónima
predefined.configuration.array.access=Acceso a array
predefined.configuration.assert.not.null=Operadores de aserción de no nulo
predefined.configuration.assignments=Asignaciones
predefined.configuration.casts=Conversiones de tipos
predefined.configuration.class.annotation=Clases anotadas
predefined.configuration.comments.containing.word=Comentarios que contienen una palabra determinada
predefined.configuration.companion.object.method.calls=Llamadas a métodos desde el objeto companion
predefined.configuration.do.while=Bucles do…while
predefined.configuration.elvis=Operadores Elvis
predefined.configuration.for=Bucles for
predefined.configuration.function.annotation=Funciones anotadas
predefined.configuration.function.explicit.inferred.type=Tipo explícito e inferido
predefined.configuration.function.signature=Firma de la función
predefined.configuration.ifs=Ifs
predefined.configuration.instance=Instancias
predefined.configuration.kdoc.tag=Etiquetas KDoc
predefined.configuration.lambda=Expresiones lambda
predefined.configuration.method.calls=Llamadas a métodos
predefined.configuration.object.companion.object=Objeto y objeto compañero
predefined.configuration.properties.getter=Propiedades con getter explícito
predefined.configuration.safe.call.operator=Operadores de llamada segura
predefined.configuration.string.literals=Literales de cadena
predefined.configuration.strings=Cadenas
predefined.configuration.strings.with.long.template=Cadenas que contienen una plantilla larga
predefined.configuration.trys=Intentos
predefined.configuration.vars.of.given.type=Variables del tipo especificado
predefined.configuration.when=Expresiones when
predefined.configuration.while=Bucles while
premature.end.of.template=Fin prematuro de la plantilla
preparing.move.descriptor=Preparando el descriptor de movimiento
presentation.text.for.receiver.in.container.paren=(para {0} en {1})
presentation.text.for.receiver.in.container.paren.no.brackets=Para {0} en {1}
presentation.text.in.container={0} en {1}
presentation.text.in.container.paren=(en {0})
presentation.text.in.container.paren.no.brackets=En {0}
presentation.text.object.in.container=Objeto en {0}
presentation.text.paren=({0})
presentation.text.paren.no.brackets={0}
print.should.be.replaced.with.logging.display.name=Llamada a 'print()' o 'println()'
private.data.class.constructor.is.exposed.via.the.generated.copy.method=El constructor primario privado se expone a través del método 'copy()' generado de una clase 'data'.
private.property=Propiedad privada
progress.finding.implicit.nothing.s=Buscando Nothing implícitos
progress.looking.up.add.annotation.usage=Buscando el uso de la anotación…
progress.looking.up.sealed.subclass.usage=Buscando usos de subclases selladas…
progress.title.analyze.extraction.data=Analizando datos de extracción…
progress.title.calculate.occurrences=Calculando coincidencias…
progress.title.calculating.type=Calculando tipo…
progress.title.check.for.conflicts=Comprobando si hay conflictos…
progress.title.collect.hierarchy=Recopilando la jerarquía de ''{0}''…
progress.title.collect.members.to.generate=Recopilando miembros…
progress.title.converting.to.if.then.else.expression=Convirtiendo a expresión if-then-else…
progress.title.introducing.value.for.condition=Introduciendo valor para la condición…
progress.title.searching.for.expected.actual=Buscando expect/actual…
project.view.class.error.name=No se ha proporcionado ningún nombre
project.view.class.initializer=Inicializador de clase
project.view.expression=Expresión
property=Propiedad
property.0=Propiedad "{0}"
property.has.an.actual.declaration.in.the.class.constructor=La propiedad tiene una declaración real en el constructor de la clase
property.in.external.interface.should.be.var=La propiedad en la interfaz externa debe ser var
property.is.explicitly.assigned.to.parameter.0.can=La propiedad está asignada explícitamente al parámetro {0}, por lo que se puede declarar directamente en el constructor
property.overloaded.in.child.class.constructor=Propiedad sobrecargada en el constructor de la clase hija
protected.visibility.is.effectively.private.in.a.final.class=La visibilidad 'protected' es efectivamente 'private' en una clase 'final'
provide.return.value=Proporcionar el valor de retorno
put.arguments.on.one.line=Poner los argumentos en una sola línea
put.arguments.on.separate.lines=Colocar argumentos en líneas separadas
put.calls.on.separate.lines=Colocar las llamadas en líneas separadas
put.expressions.on.separate.lines=Colocar las expresiones en líneas separadas
put.parameters.on.one.line=Poner parámetros en una sola línea
put.parameters.on.separate.lines=Colocar los parámetros en líneas separadas
quick.doc.no.documentation=No hay documentación disponible
quick.doc.section.deprecated=Obsoleto:
quick.doc.section.java.declaration=Declaración Java:
quick.doc.section.replace.with=Reemplazar con:
quick.doc.text.enum.ordinal=Ordinal de la constante de enumeración: {0}
quick.doc.text.lateinit='lateinit' permite inicializar una <a href="https://kotlinlang.org/docs/reference/properties.html#late-initialized-properties-and-variables">propiedad no nula fuera de un constructor</a>
quick.doc.text.tailrec='tailrec' marca una función como <a href="https://kotlinlang.org/docs/reference/functions.html#tail-recursive-functions">recursiva de cola</a> (lo que permite al compilador reemplazar la recursión por iteración)
quickFix.add.property.text=Agregar la propiedad ''{2}'' ''{0}{1}'' a ''{3}''
quickfix.add.property.familyName=Añadir propiedad
quickfix.text.suffix.may.change.semantics=(puede cambiar la semántica)
random.seed=Semilla aleatoria
range.could.be.replaced.with.indices.call=El rango podría reemplazarse con una llamada a '.indices'
recursive.equals.call=Llamada recursiva a equals
recursive.property.accessor=Accesor de propiedad recursivo
recursive.synthetic.property.accessor=Accesor de propiedad sintética recursivo
redundant.0=''@{0}'' redundante
redundant.0.call=Llamada a ''{0}'' redundante
redundant.0.modifier=Modificador ''{0}'' redundante
redundant.async.call.may.be.reduced.to.0=La llamada ''async'' redundante se puede reducir a ''{0}''
redundant.call.of.the.conversion.method=Llamada redundante al método de conversión
redundant.companion.reference=Referencia a companion redundante
redundant.constructor.keyword=Palabra clave 'constructor' redundante
redundant.curly.braces.in.string.template=Llaves redundantes en la plantilla de cadena
redundant.double.negation=Doble negación redundante
redundant.else='else' redundante
redundant.empty.class.body=Cuerpo de clase vacío redundante
redundant.empty.initializer.block=Bloque de inicialización vacío redundante
redundant.enum.constructor.invocation=Invocación redundante del constructor de enum
redundant.explicit.this=this explícito redundante
redundant.getter=Getter redundante
redundant.getter.body=Cuerpo del getter redundante
redundant.if.option.ignore.chained=Ignorar sentencias 'if' encadenadas
redundant.if.statement=Sentencia 'if' redundante
redundant.if.statement.analyzing.type=Analizando el tipo de condición…
redundant.lambda.arrow=Flecha lambda redundante
redundant.let.call.could.be.removed=La llamada redundante a 'let' puede eliminarse
redundant.modality.modifier=Modificador de modalidad redundante
redundant.override.fix.text=Eliminar método de sobrescritura redundante
redundant.overriding.method=Método de sobreescritura redundante
redundant.qualifier.name=Nombre de calificador redundante
redundant.qualifier.unnecessary.non.direct.parent.class.qualifier=Calificadores de clase padre no directa innecesarios
redundant.runcatching.call.may.be.reduced.to.0=La llamada redundante a ''runCatching'' puede reducirse a ''{0}''
redundant.sam.constructor=Constructor SAM redundante
redundant.sam.constructors=Constructores SAM redundantes
redundant.semicolon=Punto y coma redundante
redundant.semicolon.text=Eliminar punto y coma redundante
redundant.setter=Setter redundante
redundant.setter.body=Cuerpo del setter redundante
redundant.setter.parameter.type=Tipo de parámetro de setter redundante
redundant.string.template=Plantilla de cadena redundante
redundant.suspend.modifier=Modificador 'suspend' redundante
redundant.tostring.call.in.string.template=Llamada a 'toString()' redundante en la plantilla de cadena
redundant.type.checks.for.object=Comprobaciones de tipo redundantes para el objeto
redundant.unit='Unit' redundante
redundant.unit.return.type=Tipo de retorno 'Unit' redundante
redundant.visibility.modifier=Modificador de visibilidad redundante
refactoring.cannot.be.applied.no.sources.attached=No se puede aplicar la refactorización {0}: no hay fuentes adjuntas
refactoring.cannot.be.applied.to.abstract.declaration=La refactorización {0} no se puede aplicar a una declaración abstracta
refactoring.cannot.be.applied.to.anonymous.function.without.invocation=La refactorización {0} no se puede aplicar a una función anónima sin invocación
refactoring.cannot.be.applied.to.expect.declaration=La refactorización {0} no se puede aplicar a una declaración expect
refactoring.cannot.be.applied.to.lambda.expression.without.invocation=La refactorización {0} no se puede aplicar a una expresión lambda sin invocación
refactoring.cannot.find.target.class=No se puede encontrar la clase de destino
refactoring.class.destination=Destino de la clase
refactoring.extract.to.separate.file.text=Extraer a un archivo separado
refactoring.file.destination=Destino del archivo
refactoring.move.non.kotlin.file=El destino debe ser un archivo Kotlin
refactoring.the.function.cannot.be.converted.to.anonymous.function=La función no se puede convertir en una función anónima
refactoring.the.function.not.found=No se encontró la función
refactoring.the.invocation.cannot.be.resolved=No se puede resolver la llamada de invocación
remove.0=Eliminar ''.{0}''
remove.0.from.parameter=Eliminar ''{0}'' del parámetro
remove.0.from.property=Eliminar {0} de la propiedad
remove.0.modifier=Eliminar el modificador ''{0}''
remove.0.variance.from.1=Eliminar la varianza ''{0}'' de ''{1}''
remove.all.argument.names=Eliminar todos los nombres de argumentos
remove.annotation.doesnt.have.any.effect=Eliminar la anotación, ya que no tiene ningún efecto. Ver: https://youtrack.jetbrains.com/issue/KT-48141
remove.argument.name=Eliminar nombre del argumento
remove.as.dynamic.call.fix.text=Eliminar la invocación 'asDynamic'
remove.assequence.call.fix.text=Eliminar la llamada a 'asSequence'
remove.braces=Eliminar llaves
remove.braces.fix.text=Eliminar llaves
remove.braces.from.0.statement=Quitar llaves de la sentencia ''{0}''
remove.braces.from.all.branches=Eliminar llaves de todas las ramas
remove.braces.from.if.all.statements=Eliminar llaves de todas las sentencias 'if'
remove.braces.from.when.all.entries=Eliminar llaves de todas las entradas 'when'
remove.braces.from.when.entry=Eliminar llaves de la entrada 'when'
remove.branch=Eliminar rama
remove.condition=Eliminar condición
remove.conflicting.import.0=Eliminar importación en conflicto {0}
remove.constructor.call=Eliminar llamada al constructor
remove.conversion.from.kclass.to.class=Eliminar la conversión de 'KClass' a 'Class'
remove.curly.braces=Eliminar llaves
remove.default.parameter.value=Eliminar el valor por defecto del parámetro
remove.deprecated.symbol.import=Eliminar importación de símbolo obsoleto
remove.element=Eliminar elemento
remove.else=Eliminar else en ''{0}''
remove.else.branch=Eliminar la rama else
remove.empty.constructor.body=Eliminar cuerpo del constructor vacío
remove.empty.parentheses.from.annotation.entry.fix.text=Eliminar paréntesis innecesarios
remove.empty.primary.constructor=Eliminar constructor primario vacío
remove.enum.constructor.invocation.fix.text=Eliminar la llamada al constructor del enum
remove.explicit.lambda.parameter.types.may.break.code=Eliminar tipos de parámetros lambda explícitos (puede romper el código)
remove.explicit.supertype.qualification=Eliminar calificación de supertipo explícita
remove.explicit.type.arguments=Eliminar argumentos de tipo explícitos
remove.explicit.type.specification=Eliminar la especificación de tipo explícita
remove.explicit.type.specification.from.0=Eliminar la especificación de tipo explícita de ''{0}''
remove.expression=Eliminar ''{0}''
remove.expression.target=Eliminar objetivo de EXPRESSION
remove.extension.function.type.annotation=Eliminar la anotación @ExtensionFunctionType inaplicable
remove.final.upper.bound=Eliminar el límite superior final
remove.fix.text=Eliminar expresión
remove.from.annotation.argument=Eliminar @ del argumento de la anotación
remove.function.body=Eliminar el cuerpo de la función
remove.identifier.from.anonymous.function=Eliminar el identificador de la función anónima
remove.indices.in.for.loop=Eliminar los índices en el bucle 'for'
remove.initializer.block.fix.text=Eliminar bloque inicializador
remove.jvmfield.annotation=Eliminar la anotación @JvmField
remove.jvmoverloads.annotation=Eliminar la anotación @JvmOverloads
remove.labeled.return.from.last.expression.in.a.lambda=Eliminar return etiquetado de la última expresión en una lambda
remove.let.call=Eliminar llamada a 'let'
remove.modifier=Eliminar modificador
remove.modifier.fix=Hacer que ''{0}'' no sea {1}
remove.modifier.fix.family=Hacer que no sea {0}
remove.parameter.0=Eliminar el parámetro ''{0}''
remove.parts.from.property=Eliminar partes de la propiedad
remove.redundant=Eliminar '?' redundante
remove.redundant.0.modifier=Eliminar el modificador ''{0}'' redundante
remove.redundant.assignment=Eliminar asignación redundante
remove.redundant.assignment.title=Eliminar asignación redundante
remove.redundant.backticks.quick.fix.text=Eliminar comillas invertidas redundantes
remove.redundant.call.fix.text=Eliminar llamada redundante
remove.redundant.calls.of.the.conversion.method=Eliminar llamadas redundantes al método de conversión
remove.redundant.companion.reference.fix.text=Eliminar referencia redundante a Companion
remove.redundant.constructor.keyword.fix.text=Eliminar palabra clave 'constructor' redundante
remove.redundant.else.fix.text=Eliminar 'else' redundante
remove.redundant.elvis.return.null.text=Eliminar '?: return null' redundante
remove.redundant.empty.class.body=Eliminar el cuerpo de clase vacío redundante
remove.redundant.getter.body.fix.text=Eliminar el cuerpo redundante del getter
remove.redundant.getter.fix.text=Eliminar getter redundante
remove.redundant.if.expression=Eliminar la expresión 'if' redundante
remove.redundant.if.may.change.semantics.with.floating.point.types=Eliminar la sentencia 'if' redundante (puede cambiar la semántica con tipos de punto flotante)
remove.redundant.if.text=Eliminar sentencia 'if' redundante
remove.redundant.initializer=Eliminar inicializador redundante
remove.redundant.label=Eliminar etiqueta redundante
remove.redundant.modality.modifier=Eliminar modificador de modalidad redundante
remove.redundant.qualifier.name.quick.fix.text=Eliminar el nombre del calificador redundante
remove.redundant.sam.constructor=Eliminar constructor SAM redundante
remove.redundant.sam.constructors=Eliminar constructores SAM redundantes
remove.redundant.setter.body.fix.text=Eliminar cuerpo del setter redundante
remove.redundant.setter.fix.text=Eliminar setter redundante
remove.redundant.spread.operator.quickfix.text=Eliminar el operador de propagación redundante
remove.redundant.unit.fix.text=Eliminar 'Unit' redundante
remove.redundant.visibility.modifier=Eliminar modificador de visibilidad redundante
remove.redundant.with.fix.text=Eliminar llamada a 'with' redundante
remove.require.not.null.call.fix.text=Eliminar llamada a ''{0}''
remove.return.0=Eliminar return@{0}
remove.return.label.fix.family=Eliminar etiqueta redundante
remove.return.label.fix.text=Eliminar ''@{0}'' redundante
remove.self.assignment.fix.text=Eliminar la autoasignación
remove.single.expression.string.template=Eliminar plantilla de cadena de expresión única
remove.single.lambda.parameter.declaration=Eliminar declaración de parámetro lambda único
remove.star=Eliminar '*'
remove.supertype=Eliminar supertipo
remove.to.string.fix.text=Eliminar la llamada a 'toString()'
remove.token.from.function.declaration=Eliminar el token '=' de la declaración de función
remove.type.arguments=Eliminar argumentos de tipo
remove.type.parameters=Eliminar parámetros de tipo
remove.unary.operator.fix.text=Eliminar el operador unario no utilizado
remove.underscores=Eliminar guiones bajos
remove.unnecessary.parentheses=Quitar paréntesis innecesarios
remove.unnecessary.parentheses.from.function.call.with.lambda=Eliminar paréntesis innecesarios de la llamada a la función con lambda
remove.unused.imports.quickfix.text=Eliminar importaciones no utilizadas
remove.use.site.get.target=Elimine 'get:' para que la anotación sea efectiva (cambia la semántica. Consulte: https://youtrack.jetbrains.com/issue/KT-48141).
remove.useless=Eliminar '?' innecesario
remove.useless.cast=Eliminar cast innecesario
remove.useless.elvis.operator=Eliminar el operador elvis innecesario
remove.useless.is.check=Eliminar comprobación "is" innecesaria
remove.val.or.var.from.parameter=Eliminar 'val' o 'var' del parámetro
remove.var.keyword.text=Eliminar 'var'
remove.variable=Eliminar variable
remove.variable.0=Eliminar variable ''{0}''
rename.base.0=Renombrar {0,choice,1#función|2#propiedad|3#miembro|4#método|11#funciones|12#propiedades|13#miembros|14#métodos} base
rename.class.to.0=Renombrar clase a {0}
rename.class.to.containing.file.name=Renombrar clase con el nombre del archivo que la contiene
rename.declaration.title.0.implements.1.2.of.3={0} {1,choice,1#implementa|2#sobrescribe} {2} de {3}
rename.file=Renombrar archivo
rename.file.0=Renombrar archivo a ''{0}''
rename.file.to.0.1=Renombrar archivo a {0}.{1}
rename.file.to.match.top.level.class.name=Renombrar archivo para que coincida con el nombre de la clase de nivel superior
rename.identifier.fix.text=Renombrar
rename.only.current.0=Renombrar solo {0,choice,1#la función|2#la propiedad} actual
rename.parameter.to.match.overridden.method=Renombrar parámetro para que coincida con el del método sobreescrito
rename.searching.for.all.overrides=Buscando todas las sobrescrituras
rename.searching.for.super.declaration=Buscando la superdeclaración más profunda
rename.to.0=Renombrar a ''{0}''
rename.to.01=Renombrar a {0}
rename.to.fix.text=Renombrar a ''{0}''
rename.to.underscore=Renombrar a _
rename.useless.call.fix.text=Cambiar llamada a ''{0}''
reorder.parameters=Reordenar parámetros
reorder.parameters.command=Reordenar parámetros
repair.actual.members=Reparar miembros reales
replace.&&.with.||=Reemplazar '&&' por '||'
replace.0.call.with.indexing.operator=Reemplazar la llamada a ''{0}'' por un operador de indexación
replace.0.name.with.spaces=Reemplazar el nombre {0} con espacios
replace.0.with=Reemplazar ''{0}()'' por ''+=''
replace.0.with.1=Reemplazar ''{0}'' por ''{1}''
replace.0.with.1.and.vice.versa=Reemplazar ''{0}'' por ''{1}'' y viceversa
replace.and.with.when.guard=Reemplazar '&&' por 'if'
replace.annotation=Reemplazar anotación
replace.annotation.with.0=Reemplazar la anotación con {0}
replace.array.of.boxed.with.array.of.primitive=Reemplazar array de tipos boxeados por array de primitivos
replace.assert.boolean.with.assert.equality=Reemplazar aserción booleana por aserción de igualdad
replace.assert.with.operator=Reemplazar assert con un operador
replace.assignment.with.if.expression=Reemplazar asignación con expresión 'if'
replace.assignment.with.when.expression=Reemplazar la asignación con la expresión 'when'
replace.by.0=Reemplazar por ''{0}''
replace.by.reconstructed.type=Reemplazar por el tipo reconstruido
replace.call.with.unary.operator=Reemplazar llamada por un operador unario
replace.cast.with.call.to.to.0=Reemplazar la conversión con una llamada a ''to{0}()''
replace.cast.with.primitive.conversion.method=Reemplazar cast con método de conversión primitiva
replace.collection.count.with.size.quick.fix.text=Reemplazar 'count' por 'size'
replace.contains.call.with.in.operator=Reemplazar la llamada a 'contains' por el operador 'in'
replace.contains.call.with.in.operator.description=Se ha utilizado una llamada a 'contains' de Java en lugar del operador 'in' idiomático de Kotlin
replace.deprecated.symbol.usage=Reemplazar el uso de símbolos obsoletos
replace.deprecated.symbol.usage.in.whole.project=Reemplazar el uso de símbolos obsoletos en todo el proyecto
replace.diagnostic.name.fix.family.name=Reemplazar nombre del diagnóstico
replace.diagnostic.name.fix.text={0} con {1}
replace.elvis.expression.with.if.expression=Reemplazar la expresión elvis por una expresión 'if'
replace.equal.with.content.equals=Reemplazar '==' por 'contentEquals'
replace.explicit.lambda.parameter.with.it=Reemplazar parámetro lambda explícito con 'it'
replace.explicit.parameter.0.with.it=Reemplazar el parámetro explícito ''{0}'' por ''it''
replace.expression.with.if.expression=Reemplazar la expresión '!!' con una expresión 'if'
replace.function.call.with.if=Reemplazar llamada a función por 'if'
replace.function.call.with.the.opposite=Reemplazar la llamada a la función por la opuesta
replace.function.call.with.when=Reemplazar la llamada a la función por 'when'
replace.get.or.set.call.with.indexing.operator=Reemplazar la llamada a get o set con el operador de indexación
replace.guard.clause.with.kotlin.s.function.call=Reemplazar la cláusula de guarda con una llamada a función de Kotlin
replace.if.expression.with.elvis.expression=Reemplazar la expresión 'if' por una expresión Elvis
replace.if.expression.with.return=Reemplazar la expresión 'if' por return
replace.if.expression.with.safe.access.expression=Reemplazar la expresión 'if' por una expresión de acceso seguro
replace.if.expression.with.safe.cast.expression=Reemplazar la expresión 'if' por una expresión de conversión segura
replace.if.with.elvis.operator=Reemplazar 'if' por el operador elvis
replace.if.with.when=Reemplazar 'if' por 'when'
replace.if.with.when.changes.semantics=Reemplazar 'if' por 'when' (cambia la semántica)
replace.index.loop.with.collection.loop.quick.fix.text=Reemplazar con un bucle sobre los elementos
replace.infix.call.with.ordinary.call=Reemplazar la llamada infija por una llamada ordinaria
replace.int.range.end.inclusive.with.last.quick.fix.text=Reemplazar 'endInclusive' por 'last'
replace.int.range.start.with.first.quick.fix.text=Reemplazar 'start' por 'first'
replace.invalid.positioned.arguments.for.annotation=Reemplazar argumentos posicionales no válidos para la anotación
replace.invoke.with.direct.call=Reemplazar 'invoke' por una llamada directa
replace.it.with.explicit.parameter=Reemplazar 'it' con un parámetro explícito
replace.jvmfield.with.const=Reemplazar '@JvmField' por 'const'
replace.kotlin.options.with.compiler.options=Reemplazar 'kotlinOptions' por 'compilerOptions'
replace.manual.range.with.indices.call.quick.fix.text=Reemplazar con índices
replace.modifier=Reemplazar modificador
replace.negated.0.operation.with.1=Reemplazar la operación ''{0}'' negada por ''{1}''
replace.negated.0.operation.with.1.may.change.semantics.with.floating.point.types=Reemplazar la operación ''{0}'' negada por ''{1}'' (puede cambiar la semántica con tipos de coma flotante)
replace.negated.0.with.1=Reemplazar ''{0}'' negado por ''{1}''
replace.not.equal.with.content.equals=Reemplazar '!=' por 'contentEquals'
replace.nullable.type.with.non.nullable.family.name=Reemplazar tipo que admite null por un tipo que no admite null
replace.overloaded.operator.with.function.call=Reemplazar el operador sobrecargado con una llamada a función
replace.property.initializer.with.if.expression=Reemplazar el inicializador de propiedad con una expresión 'if'
replace.property.initializer.with.when.expression=Reemplazar el inicializador de la propiedad con una expresión 'when'
replace.return.with.if.expression=Reemplazar return con la expresión 'if'
replace.return.with.when.expression=Reemplazar return por una expresión 'when'
replace.safe.access.expression.with.if.expression=Reemplazar la expresión de acceso seguro con una expresión 'if'
replace.scope.function.with.safe.call=Reemplazar la función de ámbito con una llamada segura (?.)
replace.size.check.with.0=Reemplazar comprobación de tamaño por ''{0}''
replace.size.check.with.isnotempty=Reemplazar la comprobación de tamaño por 'isNotEmpty'
replace.size.zero.check.with.isempty=Reemplazar la comprobación de tamaño cero por 'isEmpty'
replace.substring.call.with.droplast.call=Reemplazar la llamada a 'substring' por la llamada a 'dropLast'
replace.substring.call.with.indexing.operation.call=Reemplazar la llamada a 'substring' por una llamada a una operación de indexación
replace.substring.call.with.substringafter.call=Reemplazar la llamada a 'substring' por la llamada a 'substringAfter'
replace.substring.call.with.substringbefore.call=Reemplazar la llamada a 'substring' por la llamada a 'substringBefore'
replace.substring.call.with.take.call=Reemplazar la llamada 'substring' por la llamada 'take'
replace.to.with.infix.form.quickfix.text=Reemplazar 'to' con la forma infija
replace.tostring.with.string.template=Reemplazar 'toString' con una plantilla de cadena
replace.total.order.equality.with.ieee.754.equality=Reemplazar la igualdad de orden total con la igualdad IEEE 754
replace.usages.of.0.in.whole.project=Reemplazar los usos de ''{0}'' en todo el proyecto
replace.when.with.if=Reemplazar 'when' por 'if'
replace.with.0=Reemplazar con ''{0}''
replace.with.0.1.2=Reemplazar con {0}[{1}] ?: {2}
replace.with.0.call=Reemplazar con la llamada ''{0}()''
replace.with.0.operator=Reemplazar con el operador ''{0}''
replace.with.a.for.loop=Reemplazar por un bucle 'for'
replace.with.a.foreach.function.call=Reemplazar con una llamada a la función ''{0}''
replace.with.array.call=Reemplazar con llamada a array
replace.with.array.literal.fix.family.name=Reemplazar por […]
replace.with.arrayof=Reemplazar con 'arrayOf'
replace.with.assignment.fix.text=Reemplazar con asignación (el original está vacío)
replace.with.binary.operator=Reemplazar con operador binario
replace.with.block.comment=Reemplazar con comentario de bloque
replace.with.content.equals=Reemplazar por 'contentEquals'
replace.with.contentequals=Reemplaza '!=' con 'contentEquals'
replace.with.contentequals2=Reemplazar '==' por 'contentEquals'
replace.with.contentequals3=Sustituir con 'contentEquals'
replace.with.dollar.literals=Reemplazar dólares escapados con literales
replace.with.dot.call=Reemplazar con llamada con punto
replace.with.elvis.error.fix.text=Reemplazar con '?: error("")'
replace.with.elvis.return.fix.text=Reemplazar con ''?: return{0}''
replace.with.end.of.line.comment=Reemplazar con comentario de fin de línea
replace.with.enum.map.fix.text=Reemplazar con 'EnumMap'
replace.with.equality.check.fix.text=Reemplazar por una comprobación de igualdad
replace.with.equality.fix.text=Reemplazar ''{0}'' por ''{1}''
replace.with.error=Reemplazar con '?: error(…)'
replace.with.explicit.type=Reemplazar '_' por el tipo explícito
replace.with.field.fix.text=Reemplazar con 'field'
replace.with.filter.fix.text=Reemplazar por filtro
replace.with.generated.publishedapi.bridge.call.0=Reemplazar con la llamada al puente @PublishedApi generada ''{0}''
replace.with.get.or.else.fix.text=Reemplazar con una llamada a 'getOrElse'
replace.with.get.value.call.fix.text=Reemplazar por la llamada a 'getValue'
replace.with.if.fix.text=Reemplazar con comprobación de tipo 'if'
replace.with.import.alias=Reemplazar con el alias de importación
replace.with.in.when=Reemplazar ',' por '||' en when
replace.with.indexing.and.elvis.operator=Reemplazar por indexación y el operador elvis
replace.with.infix.function.call=Reemplazar con llamada a función infija
replace.with.kotlin.analog.function.family.name=Reemplazar con el análogo de Kotlin
replace.with.kotlin.analog.function.text=Reemplazar con la función ''{0}''
replace.with.kotlin.s.foreach=Reemplazar con forEach de Kotlin
replace.with.kotlin.s.function.call=Reemplazar con llamada a función de Kotlin
replace.with.label.0.at=Reemplazar con la etiqueta {0}@
replace.with.list.generator.fix.text=Reemplazar con el generador de List
replace.with.operator.assignment=Reemplazar con asignación con operador
replace.with.ordinary.assignment=Reemplazar por una asignación ordinaria
replace.with.parameter.name=Reemplazar '_' por el nombre del parámetro
replace.with.publishedapi.bridge.call=Reemplazar con llamada de puente @PublishedApi
replace.with.rangeUntil.quick.fix.text=Reemplazar con '..<'
replace.with.repeat.fix.family.name=Reemplazar con 'repeat()'
replace.with.return=Reemplazar '!!' por '?: return'
replace.with.safe.call=Reemplazar con una llamada segura (?.)
replace.with.safe.this.call=Reemplazar con una llamada segura (this?.)
replace.with.std.lib.fix.text=Reemplazar con {0}.{1}
replace.with.stdlib.operations=Reemplazar con operaciones de stdlib
replace.with.stdlib.operations.with.use.of.assequence=Reemplazar con operaciones de stdlib usando 'asSequence()'
replace.with.string.literal.fix.family.name=Reemplazar con plantillas de cadena
replace.with.underscore=Reemplazar el tipo explícito por '_'
replace.with.until.quick.fix.text=Reemplazar con 'until'
replace.with1=Reemplazar con '+='
replace.||.with.&&=Reemplazar '||' por '&&'
replaceable.with.enummap=Puede reemplazarse por 'EnumMap'
replaceable.with.operator.assignment=Reemplazable por asignación con operador
report.also.for.a.variables.without.a.whitespace.around=Informar también para las variables sin espacios en blanco alrededor
report.also.on.call.with.single.boolean.literal.argument=Informar también en llamadas con un único argumento literal booleano
report.also.on.statement=Informar también sobre la sentencia
report.for.types.with.platform.arguments=Informar sobre tipos con argumentos de plataforma
reports.only.function.calls.from.kotlinx.coroutines=Informar solo las llamadas a funciones de 'kotlinx.coroutines'
reset.files=Restablecer archivos…
resolve.pasted.references=Resolver referencias pegadas
result.of.0.call.is.not.thrown=El resultado de la llamada a ''{0}'' no se lanza
retargeting.usages.progress=Redireccionando usos
rethrow.stored.pce.as.a.new.runtime.exception=Volver a lanzar el PCE almacenado como una nueva excepción de tiempo de ejecución
return.type=Tipo de &retorno:
return.type.is.invalid=El tipo de retorno no es válido
return.when=retornar when
revert.applied.imports.command=Revertir importaciones aplicadas
roots.description.text.update.source.roots.for.non.jvm.modules.in.kotlin.project=Actualizar las raíces de fuentes para módulos no JVM en el proyecto Kotlin
round.using.0=Redondear usando {0}()
safe.delete.constructor=Eliminación segura del constructor
saving.files=Guardando archivos…
scanning.files.0.fo.1.file.2.occurrences.found=Escaneando archivos: {0} de {1} archivo. {2} coincidencias encontradas
script.action.text.ignore=Ignorar
script.action.text.open.settings=Abrir configuración
script.action.text.show.all=Mostrar todo
script.name.kotlin.scripting=Scripting de Kotlin
script.text.multiple.script.definitions.are.applicable.for.this.script=Se aplican múltiples definiciones de script a este script. Se utiliza {0}
sealed.sub.class.has.no.state.and.no.overridden.equals=La subclase 'sealed' no tiene estado ni 'equals()' sobreescrito
search.for.not.property.candidates=Buscar candidatos que no sean propiedades
search.for.text.occurrences=Buscar apariciones de &texto
search.in.comments.and.strings=Buscar en &comentarios y cadenas
searching.0=Buscando {0}…
searching.for.0=Buscando {0}
searching.for.imports.to.delete.title=Buscando importaciones para eliminar
searching.for.not.property.candidates=Buscando candidatos que no son propiedades
searching.for.overriding.methods=Buscando métodos de sobrescritura
searching.inheritors=Buscando herederos…
searching.usages.of.0.parameter=Buscando usos del parámetro ''{0}''
select.lambda.to.label=Seleccionar lambda para etiquetar
select.loop.statement.to.label=Seleccione la instrucción de bucle para etiquetar
select.target.code.block.file=Seleccionar bloque de código / archivo de destino
select.target.file=Seleccionar archivo de destino
selected.code.fragment.has.multiple.exit.points=El fragmento de código seleccionado tiene múltiples puntos de salida.
selected.code.fragment.has.multiple.output.values=El fragmento de código seleccionado tiene más de 3 valores de salida:
selected.code.fragment.has.output.values.and.exit.points=El fragmento de código seleccionado tiene valores de salida, así como puntos de salida alternativos
setter.of.0.will.become.invisible.after.extraction=El setter de {0} no será visible tras la extracción
shortening.usages.progress=Acortando usos
should.be.replaced.with.if.type.check=Debe reemplazarse por una comprobación de tipo 'if'
should.be.replaced.with.indexing=Debe reemplazarse por indexación
should.be.replaced.with.kotlin.function=Debe reemplazarse por una función de Kotlin
should.be.replaced.with.list.generator=Debe reemplazarse por el generador de List
should.not.contain.lowercase.letter=No debe contener letras minúsculas
should.not.contain.underscores=No debe contener guiones bajos
should.not.contain.underscores.in.the.middle.or.the.end=No debe contener guiones bajos en el medio ni al final
should.not.contain.underscores.with.camel.case=No debe contener guiones bajos cuando se utiliza camel case
should.not.start.with.an.underscore=No debe comenzar con un guion bajo
should.not.start.with.an.uppercase.letter=No debe comenzar con una letra mayúscula
should.start.with.a.lowercase.letter=Debe comenzar con una letra minúscula
should.start.with.an.uppercase.letter=Debe comenzar con una letra mayúscula
signature.preview=Vista previa de la firma
simplify.0.to.1=Simplificar ''{0}'' a ''{1}''
simplify.boolean.expression=Simplificar expresión booleana
simplify.call.chain.fix.text=Fusionar cadena de llamadas en ''{0}''
simplify.call.fix.text=Convertir la llamada ''{0}'' a ''{1}''
simplify.comparison=Simplificar comparación
simplify.fix.text=Simplificar expresión
simplify.foldable.if.then=Simplificar if-then plegable
simplify.negated.operation=Simplificar la operación negada
simplify.when.fix.text=Simplificar 'when'
since.kotlin.1.3.main.parameter.is.not.necessary=Desde Kotlin 1.3 el parámetro main no es necesario
slicer.text.in=En
slicer.text.tracking.enclosing.lambda=(Rastreando lambda circundante)
slicer.text.tracking.lambda.argument=(Rastreando parámetro lambda)
slicer.text.tracking.lambda.calls=(Rastreando llamadas lambda)
slicer.text.tracking.lambda.receiver=(Seguimiento del receptor lambda)
slicer.title.dataflow.from.here=Flujo de datos desde aquí
slicer.title.dataflow.to.here=Flujo de datos hasta aquí
slicer.tool.tip.text.variable.dereferenced=Variable desreferenciada
some.types.are.not.accessible.from.0.1=No se puede acceder a algunos tipos desde {0}:\n{1}
sort.modifiers=Ordenar modificadores
specify.all.remaining.arguments.by.name=Especificar todos los argumentos restantes por nombre
specify.all.types.explicitly.in.destructuring.declaration=Especificar todos los tipos explícitamente en la declaración de desestructuración
specify.explicit.lambda.signature=Especificar firma lambda explícita
specify.override.explicitly=Especificar sobrescritura explícitamente
specify.override.for.0.explicitly=Especificar explícitamente la sobrescritura para ''{0}''
specify.remaining.required.arguments.by.name=Especificar los argumentos obligatorios restantes por nombre
specify.return.type.explicitly=Especificar el tipo de retorno explícitamente
specify.super.type=Especificar el supertipo ''{0}'' explícitamente
specify.type.explicitly=Especificar el tipo explícitamente
split.if.into.two=Dividir 'if' en dos
split.property.declaration=Dividir declaración de propiedad
spring.secured.urls.inlay.hints=Kotlin: Mostrar sugerencias incrustadas para URLs de Spring protegidas
ssr.modifier.match.call.semantically=Coincidir llamada semánticamente
ssr.modifier.match.companion.object=Coincidir con companion object
ssr.modifier.match.val=Coincidir con val
ssr.modifier.match.var=Coincidir con var
start.import.button.text.add=Añadir
start.import.button.text.remove=Eliminar
statement=Sentencia
status=(estado)
status.text.no.definitions=Sin definiciones
step.1.collecting.0.1.2=Paso 1: Recopilando {0}:{1}:{2}
step.2.0.of.1=Paso 2: {0} de {1}
step.3.0.of.1=Paso 3: {0} de {1}
surround.with.0=Rodear con {0}(…)
surround.with.array.of=Rodear con arrayOf(…)
surround.with.lambda=Envolver con lambda
surround.with.null.check=Rodear con comprobación de null
surround.with.star.0=Rodear con *{0}(…)
suspicious.asdynamic.member.invocation=Invocación de miembro 'asDynamic' sospechosa
suspicious.callable.reference.as.the.only.lambda.element=Referencia invocable sospechosa como el único elemento de la lambda
suspicious.combination.of.and=Combinación sospechosa de == y ===
suspicious.var.property.its.setter.does.not.influence.its.getter.result=Propiedad 'var' sospechosa: su setter no influye en el resultado de su getter
test.function=Función de prueba
test.integration.button.text.cancel=Cancelar
test.integration.button.text.rewrite=Reescribir
test.integration.message.text.create.test.in.the.same.source.root=¿Crear prueba en la misma raíz de fuentes?
test.integration.message.text.kotlin.class=La clase Kotlin ''{0}'' ya existe. ¿Desea actualizarla?
test.integration.title.no.test.roots.found=No se encontraron raíces de prueba
test.result.log.file.will.be.placed.here=El archivo de registro de resultados de la prueba se colocará aquí
text.0.1.must.be.moved.with.sealed.parent.class.and.all.its.subclasses={0} ''{1}'' debe moverse junto con la clase padre sellada y todas sus subclases
text.0.already.contains.1={0} ya contiene {1}
text.0.already.contains.nested.class.1={0} ya contiene una clase anidada llamada {1}
text.0.already.declared.in.1={0} ya está declarado en {1}
text.0.have.no.inheritors.warning={0} no tiene herederos\nBajar los miembros resultará en su eliminación. ¿Desea continuar?
text.0.in.1.will.override.corresponding.member.of.2.after.refactoring={0} en {1} sobrescribirá el miembro correspondiente de {2} después de la refactorización
text.0.inherits.from.1.it.will.not.be.affected.by.refactoring={0} hereda de {1}.\nNo se verá afectado por la refactorización
text.0.is.invalid.destination.package=''{0}'' no es un nombre de paquete de destino válido
text.0.is.not.allowed.in.the.target.context=''{0}'' no se permite en el contexto de destino
text.0.is.not.valid.package.name={0} no es un nombre de paquete válido
text.0.to.inline={0} para integrar
text.0.uses.1.which.is.not.accessible.from.2={0} utiliza {1}, que no es accesible desde {2}
text.0.uses.1.which.will.be.inaccessible.after.move={0} utiliza {1}, que será inaccesible tras el movimiento
text.0.uses.1.which.will.not.be.accessible.from.subclass={0} utiliza {1}, que no será accesible desde la subclase.
text.0.uses.internal.1.which.will.be.inaccessible.after.move={0} utiliza {1} interno, que será inaccesible después de moverlo
text.0.will.be.shadowed.by.1={0} será ocultado por {1}
text.0.will.clash.with.existing.1.in.2={0} después de renombrar entrará en conflicto con el {1} existente en {2}
text.0.will.no.longer.be.accessible.after.signature.change={0} dejará de ser accesible después del cambio de firma
text.Assignment=Asignación
text.Function=Función
text.Name=Nombre
text.Package=Paquete
text.Property=Propiedad
text.Return=Retorno
text.abstract=Abstracto
text.actual.moved.to.common.modules.target=La declaración actual ''{0}'' se movería a un módulo común.
text.add.getter=Añadir getter
text.add.getter.and.setter=Añadir getter y setter
text.add.setter=Añadir setter
text.add.use.site.target.0=Añadir destino de sitio de uso ''{0}''
text.all.declarations.must.belong.to.the.same.directory.or.class=Todas las declaraciones deben pertenecer al mismo directorio o clase
text.annotation=Anotación
text.annotation.class=Clase de anotación
text.anonymous=[Anónimo]
text.anonymous.function=Función anónima
text.at.least.one.file.must.be.selected=Debe seleccionar al menos un miembro.
text.callee.text.would.be.shown.here=El texto del callee se mostrará aquí
text.caller.text.with.highlighted.callee.call.would.be.shown.here=Aquí se mostrará el texto del llamador\ncon la llamada al destinatario resaltada
text.can=Puede
text.cannot.create.target.directory.0=No se puede crear el directorio de destino {0}
text.cannot.determine.source.directory=No se puede determinar el directorio de fuentes
text.cannot.find.package.corresponding.to.0=No se pudo encontrar el paquete correspondiente a {0}
text.cannot.find.target.package.name=No se puede encontrar el nombre del paquete de destino
text.cannot.inline.reference.from.0.to.1=No se puede insertar en línea la referencia de {0} a {1}
text.cannot.move.expect.actual.declaration.to.file=No se pudo mover la declaración expect/actual al archivo
text.cannot.move.for.current.project=No se puede mover para el proyecto actual
text.cannot.move.inner.class.0.into.itself=No se puede mover la clase anidada {0} a sí misma
text.cannot.move.to.original.file=No se puede mover al archivo original
text.change.file.package.to.0=Cambiar el paquete del archivo a ''{0}''
text.change.use.site.target.0=Cambiar el destino del lugar de uso a ''{0}''
text.choose.containing.file=Seleccionar archivo contenedor
text.class=Clase
text.class.0={0,choice,1#clase|2#clases}
text.class.0.already.contains.member.1={0} ya contiene {1}
text.class.0.already.exists.in.package.1=La clase {0} ya existe en el paquete {1}
text.class.0.already.exists.in.the.target.scope=La clase {0} ya existe en el ámbito de destino
text.class.0.is.final={0} es final
text.constructor=Constructor
text.convert._it_.to.explicit.lambda.parameter=Convertir 'it' en un parámetro lambda explícito
text.create=Crear
text.create.destructuring.declaration=Crear declaración de desestructuración
text.create.single.variable=Crear una sola variable
text.declaration=Declaración
text.declarations.clash.move.0.destination.1.declared.in.scope.2=Las siguientes declaraciones entrarían en conflicto: mover {0} y el destino {1} declarado en el ámbito {2}
text.default.value=// valor por defecto = {0}
text.destination.class.should.be.kotlin.class=La clase de destino debe ser una clase Kotlin
text.do.you.want.to.rename.0.as.well=¿Desea cambiar también el nombre de {0}()?
text.do.you.want.to.rename.base.property=¿Desea renombrar la propiedad base?
text.do.you.want.to.rename.base.property.from.0=¿Desea cambiar el nombre de la propiedad base desde \n{0}?
text.done=Hecho
text.duplicating.local.variable=Duplicando la variable local ''{0}''
text.duplicating.parameter=Duplicando el parámetro ''{0}''
text.duplicating.property=Duplicando la propiedad ''{0}''
text.enable.annotation.target.feature=Añadir argumento del compilador: {0}
text.enum=Enumeración
text.enum.class=Clase enum
text.enum.constant=Constante de enumeración
text.expected.moved.to.platform.modules.target=La declaración 'expected' ''{0}'' se movería a un módulo de plataforma.
text.explicit.receiver.is.already.present.in.call.element.0=El receptor explícito ya está presente en el elemento de llamada: {0}
text.extend=Extender
text.extension=Extensión
text.extension.function=Función de extensión
text.extension.function.0={0,choice,1#función|2#funciones} de extensión
text.extension.property=Propiedad de extensión
text.extension.property.0={0,choice,1#propiedad|2#propiedades} de extensión
text.extract.superclass=Extraer superclase
text.file.0.already.exists.in.1=El archivo {0} ya existe en {1}
text.file.name.cannot.be.empty=El nombre de archivo no puede estar vacío.
text.first.definition.that.matches.script.pattern.extension.applied.starting.from.top=Se aplica la primera definición que coincida con el patrón/extensión del script, empezando desde arriba
text.function=Función
text.function.0={0,choice,1#función|2#funciones}
text.function.already.exists=La función ya existe: ''{0}''
text.function.in.ticks.0=Función ''{0}''
text.getter=getter
text.implement=Implementar
text.implements=Implementa
text.implicit.companion.object.will.be.inaccessible.0=El objeto compañero implícito será inaccesible: {0}
text.incorrect.target.path.directory.0.does.not.belong.to.current.project=Ruta de destino incorrecta. El directorio {0} no pertenece al proyecto actual.
text.indirect.outer.instances.will.not.be.extracted.0=No se extraerán las instancias externas indirectas: {0}
text.infix.extension.function=Función de extensión infija
text.infix.extension.function.0=Extensión infija {0,choice,1#función|2#funciones}
text.infix.function=Función infix
text.infix.function.0={0,choice,1#función infija|2#funciones infijas}
text.initializer=Inicializador
text.inline.0=Poner {0} en línea
text.inline.all.references.and.verb.0.the.kind.1.occurrences.2=Poner en línea todas las referencias y {0} {1} {2}
text.inline.function.not.supported=La función inline aún no es compatible
text.inline.recursive.function.is.supported.only.on.references=La función recursiva inline solo se admite en referencias
text.inline.this.reference.and.keep.the.0=Inlinear esta referencia y mantener el {0}
text.inlined.0.overrides.0.1={0} insertado en línea sobrescribe {0} {1}
text.inlining.0.1=Incrustando {0} {1}
text.inner.class.0.cannot.be.moved.to.interface={0} es una clase interna. No se puede mover a la interfaz.
text.interface=interfaz
text.introduce.default.value=Intro&ducir valor predeterminado
text.invalid.target.path.0=Ruta de destino {0} no válida
text.invalid.target.specified=Se ha especificado un objetivo no válido
text.keep=Mantener
text.lambda.parameter=Parámetro lambda
text.lambda.parameters=&Parámetros lambda:
text.lambda.return.type=&Tipo de retorno lambda
text.lazy.property=Propiedad diferida
text.local.property=Propiedad
text.local.variable=Variable local
text.looking.for.usages=Buscando usos
text.member=Miembro
text.member.0.in.super.class.will.clash.with.existing.member.of.1={0} en la superclase entraría en conflicto con el miembro existente de {1}
text.member.extension.call.will.not.be.processed.0=No se procesará la llamada de extensión de miembro: {0}
text.move.declaration.no.support.for.companion.objects=Mover declaración no es compatible con los objetos companion
text.move.declaration.no.support.for.enums=No se admite mover la declaración para entradas de enumeración
text.move.declaration.no.support.for.multi.file=No se admite mover declaraciones desde diferentes archivos
text.move.declaration.no.support.for.nested.declarations=Mover declaración no soportado para declaraciones anidadas
text.move.declaration.no.support.incorrect.modality=No se admite mover miembros 'abstract', 'open' y 'override'
text.move.declaration.only.support.for.single.elements=No se admite mover la declaración para múltiples declaraciones anidadas
text.move.declaration.only.support.for.some.nested.declarations=Mover declaración no es compatible con declaraciones anidadas que no sean clases, funciones y propiedades anidadas
text.move.declaration.proceed.move.without.mpp.counterparts.text=Esta refactorización moverá la declaración seleccionada sin sus contrapartes expect/actual, lo que podría provocar errores de compilación.\n¿Desea continuar?
text.move.declaration.proceed.move.without.mpp.counterparts.title=No se puede realizar la refactorización. Esta refactorización no admite declaraciones MPP.
text.move.declaration.supports.only.top.levels.and.nested.classes=Mover declaración solo se admite para declaraciones de nivel superior y clases anidadas
text.move.declarations=Mover declaraciones
text.move.file.0=Mover {0}
text.move.file.no.support.for.file.target=No se admite mover archivos a un destino que no sea un directorio
text.move.method.is.not.supported.for.generic.classes=El método Move no es compatible con clases genéricas
text.move.method.is.not.supported.for.non.project.methods=El método Move no es compatible con métodos que no pertenecen al proyecto
text.move.method.is.not.supported.when.method.is.a.part.of.inheritance.hierarchy=No se admite Mover método cuando el método forma parte de una jerarquía de herencia
text.move.refactoring.not.available.during.indexing=La refactorización de movimiento no está disponible mientras se realiza la indexación
text.moving.multiple.nested.classes.to.top.level.not.supported=No se admite mover varias clases anidadas al nivel superior
text.name=Nombre
text.nested.classes.to.upper.level=Clases anidadas al nivel superior
text.no.destination.object.specified=No se ha especificado el objeto de destino
text.no.elements.to.move.are.selected=No se han seleccionado elementos para mover.
text.no.files.to.move=No hay archivos especificados para mover
text.no.name.provided.for.type.alias=No se ha proporcionado ningún nombre para el alias de tipo
text.no.package.corresponds.to.directory=Ningún paquete corresponde a este directorio
text.non.kotlin.0.will.not.be.affected.by.refactoring={0} que no sea de Kotlin no se verá afectado por la refactorización
text.object=Objeto
text.object.0={0,choice,1#objeto|2#objetos}
text.operator.0={0,choice,1#operador|2#operadores}
text.overload=Sobrecarga
text.overrides=Sobrescrituras
text.package.directive.dont.match.file.location=La directiva de paquete no coincide con la ubicación del archivo
text.parameter=Parámetro
text.parameter.0=Parámetro ''{0}''
text.parameter.name=&Nombre del parámetro:
text.parameter.reference.can.t.be.safely.replaced.with.0.since.1.is.ambiguous.in.this.context=La referencia de parámetro no se puede reemplazar de forma segura por {0} ya que {1} es ambiguo en este contexto
text.parameter.reference.can.t.be.safely.replaced.with.0.since.target.function.can.t.be.referenced.in.this.context=La referencia de parámetro no se puede reemplazar de forma segura con {0} porque la función de destino no se puede referenciar en este contexto
text.parameter.type=&Tipo de parámetro:
text.parameters=&Parámetros
text.part=Parte
text.pattern=Patrón:
text.primary=Principal
text.primary.constructor=Constructor primario
text.proceed.with.extraction=Continuar con la extracción de todos modos
text.process.duplicates=Procesar duplicados
text.processing.file.0=Procesando {0}
text.property=Propiedad
text.property.0={0,choice,1#propiedad|2#propiedades}
text.property.in.ticks.0=Propiedad ''{0}''
text.property.with.getter=Propiedad con getter
text.property.with.initializer=Propiedad con inicializador
text.property.would.conflict.with.superclass.primary.constructor.parameter.0=La propiedad ''{0}'' entraría en conflicto con el parámetro del constructor primario ''{1}'' de la superclase.
text.pushed.member.will.not.be.available.in.0=El miembro desplazado no estará disponible en ''{0}''
text.qualified.call.will.not.be.processed.0=No se procesará la llamada calificada: {0}
text.receiver=Receptor
text.receiver.can.t.be.safely.transformed.to.value.argument=El receptor no se puede transformar de forma segura en un argumento de valor: {0}
text.refactoring.can.t.be.performed.on.the.selected.code.element=No se puede realizar la refactorización en el elemento de código seleccionado.
text.refactoring.is.not.applicable.to.this.code.fragment=La refactorización no es aplicable a este fragmento de código
text.reference.cannot.be.converted.to.a.lambda=La referencia no se puede convertir en una lambda
text.references.in.code.to.0.1.and.its.declarations=Referencias en el código a {0} {1} y sus declaraciones
text.references.to.outer.classes.have.to.be.added.manually=Las referencias a las clases externas deberán añadirse manualmente después del traslado
text.remove=Eliminar
text.remove.0.no.longer.used=Eliminar {0} que ya no se usa
text.remove.question=Eliminar '?'
text.rename.as.part.of.phrase=Renombrar
text.rename.is.not.applicable.to.compiler.plugin.generated.declarations=Renombrar no es aplicable a las declaraciones generadas por el plugin del compilador
text.rename.is.not.applicable.to.secondary.constructors=Cambiar nombre no es aplicable a los constructores secundarios
text.rename.is.not.applicable.to.synthetic.declarations=Renombrar no es aplicable a declaraciones sintéticas
text.rename.not.applicable.to.backing.field.reference=Cambiar nombre no es aplicable a la referencia de un campo de respaldo
text.rename.not.applicable.to.dynamically.invoked.methods=Renombrar no es aplicable a miembros invocados dinámicamente
text.rename.overloads.title=Renombrar sobrecargas
text.rename.parameters.title=Renombrar parámetros
text.return=Retorno
text.sealed.broken.hierarchy.none.in.target=La jerarquía sellada de ''{0}'' se dividiría. Ninguno de sus miembros reside en el paquete ''{1}'' del módulo ''{2}'': {3}.
text.sealed.broken.hierarchy.still.in.source=La jerarquía sellada de ''{0}'' se dividiría. El paquete ''{1}'' del módulo ''{2}'' aún contendría sus miembros: {3}.
text.sealed.class.0.must.be.moved.with.all.its.subclasses=La clase sellada ''{0}'' debe moverse con todas sus subclases
text.secondary=Secundario
text.secondary.constructor=Constructor secundario
text.select.target.code.block=Seleccionar bloque de código de destino
text.select.target.code.block.file=Seleccionar bloque de código / archivo de destino
text.select.target.file=Seleccionar archivo de destino
text.setter=setter
text.should=Debería
text.there.is.already.a.parameter=Ya existe un parámetro ''{0}'' en {1}. Entrará en conflicto con el nuevo parámetro.
text.there.is.already.a.variable.0.in.1.it.will.conflict.with.the.new.parameter=Ya existe una variable ''{0}'' en {1}. Entrará en conflicto con el nuevo parámetro.
text.type=Tipo
text.type.alias=Alias de tipo
text.type.alias.0=Tipo {0,choice,1#alias|2#alias}
text.type.alias.cannot.refer.to.types.which.aren.t.accessible.in.the.scope.where.it.s.defined=El alias de tipo no puede hacer referencia a tipos que no son accesibles en el ámbito donde está definido
text.type.alias.name.must.be.a.valid.identifier.0=El nombre del alias de tipo debe ser un identificador válido: {0}
text.type.already.exists.in.the.target.scope=El tipo {0} ya existe en el ámbito de destino
text.type.parameter=Tipo {0, choice, 0#parámetro|2#parámetros}
text.type.parameter.names.must.be.distinct=Los nombres de los parámetros de tipo deben ser distintos
text.type.parameters=&Parámetros de tipo
text.unexpected.element.type.0=Tipo de elemento inesperado: {0}
text.update.usages.to.reflect.declaration.0.move=Actualizar los usos para reflejar el movimiento de {0, choice, 0#la declaración|1#las declaraciones}
text.updating.usages.progress=Actualizando usos…
the.anonymous.object=El objeto anónimo
the.declaration.has.0.modifier=La declaración tiene el modificador ''{0}''
the.function.declaration.shouldn.t.have.a.default.implementation=La declaración de la función no debe tener una implementación predeterminada
there.are.possible.side.effects.found.in.expressions.assigned.to.the.variable.0=Se han encontrado posibles efectos secundarios en las expresiones asignadas a la variable ''{0}''<br>Puede:<br>-<b>Eliminar</b> la asignación completa, o<br>-<b>Transformar</b> el lado derecho de la asignación en una sentencia independiente.<br>
there.is.own.replacewith.on.0.that.is.used.through.this.alias.please.replace.usages.first=Hay un ''ReplaceWith'' propio en ''{0}'' que se utiliza a través de este alias. Reemplace los usos primero.
these.declarations.cannot.be.transformed=Estas declaraciones no se pueden transformar:
this.call.is.useless.with=Esta llamada es inútil con ?.
this.property.conflicts.with.synthetic.extension.and.should.be.removed.or.renamed.to.avoid.breaking.code.by.future.changes.in.the.compiler=La propiedad entra en conflicto con una extensión sintética y debe eliminarse o renombrarse para evitar que el código se rompa en versiones futuras del compilador de Kotlin
this.range.is.empty=Este rango está vacío.
this.range.is.empty.did.you.mean.to.use.0=Este rango está vacío. ¿Quiso decir ''{0}''?
this.type.probably.can.be.changed.to.nullable=Este tipo probablemente puede cambiarse a nullable
this.when.is.simplifiable=Este 'when' se puede simplificar
throwable.instance.0.is.not.thrown=La instancia de Throwable ''{0}'' no se lanza
titile.not.found=No encontrado
title.choose.destination.object=Seleccionar objeto de destino
title.choose.logger.factory.class=Seleccionar clase de fábrica de loggers
title.choose.use.site.target=Seleccionar destino del sitio de uso
title.done=Hecho
title.error=Error
title.import.layout=Importar diseño
title.inline.function=Inlinear función
title.inline.property=Incorporar propiedad
title.inline.type.alias=Poner alias de tipo en línea
title.introduce.parameter.to.declaration=Introducir parámetro en la declaración
title.kdoc.for.abstracts=KDoc para abstractos
title.lateinit.var.overrides.lateinit.var='lateinit var' sobrescribe al 'lateinit var' de super
title.logger.factory.class.name=Nombre de la clase de la fábrica de registradores
title.logger.factory.method.name=Nombre del método de fábrica de Logger
title.move.method=Mover método
title.move.nested.classes.to.upper.level=Mover clases anidadas al nivel superior
title.packages.to.use.import.with=Paquetes para usar import con '*'
title.parameters=Parámetros
title.rename.file=Renombrar archivo
title.rename.file.to=Renombrar archivo a:
title.rename.overloads.to=Renombrar sobrecargas a:
title.rename.warning=Advertencia de cambio de nombre
title.select.a.name.for.this.parameter=Seleccione un nombre para el parámetro ''this@{0}''
title.select.target.code.block=Seleccionar bloque de código de destino
title.success=Éxito
to.fully.qualified.name=A (nombre calificado completo):
tooltip.implements.function=Implementa la función en
tooltip.implements.property=Implementa la propiedad en
tooltip.is.implemented.by=Implementado por
tooltip.is.subclassed.by=Subclaseado por
tooltip.overrides.function=Sobrescribe la función en
tooltip.overrides.property=Sobrescribe la propiedad en:
top.level=Nivel superior
two.comparisons.should.be.converted.to.a.range.check=Dos comparaciones deben convertirse en una comprobación de rango
type.0.1.is.not.accessible.from.target.module={0, choice, 0#El tipo|2#Los tipos} {1} no es accesible desde el módulo de destino
type.alias.0=Alias de tipo "{0}"
type.arguments.will.be.lost.after.conversion.0=Los argumentos de tipo se perderán después de la conversión: {0}
type.parameter.0=Parámetro de tipo "{0}"
type.parameter.can.have.0.variance=El parámetro de tipo puede tener varianza ''{0}''
type.provider.anonymous.object=Objeto anónimo
type.provider.no.expression.found=No se encontró la expresión
type.provider.smart.cast.from=(conversión inteligente de {0})
type.provider.unknown.type=Tipo desconocido
unclear.precedence.of.binary.expression.inspection=La expresión debería usar paréntesis aclaratorios
unclear.precedence.of.binary.expression.inspection.display.name=Múltiples operadores con distinta precedencia
unclear.precedence.of.binary.expression.quickfix=Añadir paréntesis aclaratorios
unclear.precedence.of.binary.expression.report.even.obvious.cases.checkbox=Informar incluso de casos obvios
unknown.types.title=Tipos desconocidos
unlabeled.return.inside.lambda=Return sin etiqueta dentro de lambda
unrecognized.reference.will.be.skipped.0=Se omitirá la referencia no reconocida: {0}
unsupported.usage.0=Uso no compatible: {0}
until.can.be.replaced.with.rangeUntil.operator=Until' se puede reemplazar con el operador '..<
unused.equals.expression=Expresión equals no utilizada
unused.import.directive=Directiva de importación no utilizada
unused.return.value.of.a.function.with.lambda.expression.body=Valor de retorno no utilizado de una función con cuerpo de expresión lambda
unused.unary.operator=Operador unario no utilizado
unwrap.else=Desempaquetar else en ''{0}''
unwrap.expression=Desenvolver ''{0}''
unwrap.parameter=Quitar envoltorio de ''{0}'' arg ''{1}''
update.indices=Actualizar índices…
update.obsolete.label.syntax=Actualizar sintaxis de etiqueta obsoleta
usage.of.kotlin.internal.declaration.from.different.module=Uso de la declaración internal de Kotlin desde un módulo diferente
usage.of.redundant.or.deprecated.syntax.or.deprecated.symbols=Uso de sintaxis redundante u obsoleta o símbolos obsoletos
usage.provider.text.property.of.0={0} de {1}
usage.provider.text.unnamed=<sin nombre>
usages.of.nested.declarations.from.non.kotlin.code.won.t.be.processed=No se procesarán los usos de declaraciones anidadas desde código que no sea Kotlin
usages.of.outer.class.instance.inside.declaration.0.won.t.be.processed=No se procesarán los usos de la instancia de la clase externa dentro de la declaración ''{0}''
usages.of.outer.class.instance.inside.of.property.0.won.t.be.processed=No se procesarán los usos de la instancia de la clase externa dentro de la propiedad ''{0}''
use.destructuring.declaration=Usar declaración de desestructuración
use.expression.body.instead.of.0=Usar cuerpo de expresión en lugar de {0}
use.inherited.visibility=Usar visibilidad heredada
use.of.getter.method.instead.of.property.access.syntax=Uso del método getter en lugar de la sintaxis de acceso a propiedades
use.of.non.const.kotlin.property.as.java.constant.is.incorrect.will.be.forbidden.in.1.4=El uso de una propiedad de Kotlin que no sea const como constante de Java es incorrecto. Estará prohibido en 1.4.
use.of.setter.method.instead.of.property.access.syntax=Uso del método setter en lugar de la sintaxis de acceso a propiedades
use.property.access.syntax=Usar sintaxis de acceso a propiedades
use.property.access.syntax.option.report.non.trivial.accessors=Informar sobre accesores no triviales
use.withindex.instead.of.manual.index.increment=Usar withIndex() en lugar del incremento manual del índice
useless.call.on.collection.type=Llamada innecesaria en un tipo de colección
useless.call.on.not.null.type=Llamada inútil en un tipo no nulo
uses.of.should.be.replaced.with.logging=Los usos de <code>{0}</code> probablemente deberían reemplazarse por un registro más robusto
variable.0.is.assigned.to.itself=La variable ''{0}'' se asigna a sí misma
variable.declaration.could.be.inlined=La declaración de la variable se puede integrar
variable.declaration.could.be.moved.into.when=La declaración de la variable puede moverse a 'when'
variable.is.never.modified.and.can.be.declared.immutable.using.val=La variable nunca se modifica, por lo que se puede declarar usando 'val'
variable.is.never.read=La variable ''{0}'' nunca se lee
variable.is.same.as.0.and.should.be.inlined=La variable es igual a ''{0}'' y se puede integrar
variable.name.0.matches.the.name.of.a.different.component=El nombre de la variable ''{0}'' coincide con el nombre de otro componente
variable.used.only.in.following.return.and.should.be.inlined=La variable solo se utiliza en el siguiente return y puede integrarse
vcs.code.author=Kotlin: Mostrar sugerencias de incrustación con el autor del código
version={version}
visibility=&Visibilidad:
when.has.only.else.branch.and.should.be.simplified='when' solo tiene una rama 'else' y debería simplificarse
when.with.subject.should.be.used=Se debe utilizar 'when' con sujeto
wrap.argument.with.parentheses=Envolver argumento con paréntesis
wrap.element.with.0.call=Envolver el elemento con una llamada a ''{0}()''
wrap.expression.in.parentheses=Envolver expresión entre paréntesis
wrap.run.fix.text=Convertir para ejecutar { … }
wrap.unary.operator.quickfix.text=Envolver el operador unario y el valor con ()
wrap.with=Envolver con []
wrap.with.array.literal=Envolver con literal de array
wrap.with.collection.literal.call=Envolver con una llamada a un literal de colección
wrap.with.coroutine.scope.fix.family.name=Envolver con coroutineScope
wrap.with.coroutine.scope.fix.text=Envolver el cuerpo de la función con 'coroutineScope { … }'
wrap.with.coroutine.scope.fix.text2=Envolver llamada con 'coroutineScope { … }'
wrap.with.coroutine.scope.fix.text3=Eliminar el receptor & envolver con 'coroutineScope { … }'
wrap.with.let.call=Envolver con una llamada '?.let { … }'
