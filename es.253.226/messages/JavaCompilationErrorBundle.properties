access.generic.problem=No se puede acceder a ''{0}'' en ''{1}''
access.package.local=''{0}'' no es público en ''{1}''. No se puede acceder desde fuera del paquete
access.private='{0}'' tiene acceso privado en ''{1}'
access.protected='{0}'' tiene acceso protegido en ''{1}'
annotation.attribute.duplicate=Atributo duplicado ''{0}''
annotation.attribute.illegal.array.initializer=Inicializador no válido para ''{0}''
annotation.attribute.incompatible.type=Tipos incompatibles. Encontrado: ''{1}'', requerido: ''{0}''
annotation.attribute.name.missing=Se esperaba un atributo de anotación de la forma 'name=value'
annotation.attribute.non.class.literal=El valor del atributo debe ser un literal de clase
annotation.attribute.non.constant=El valor del atributo debe ser constante
annotation.attribute.non.enum.constant=El valor del atributo debe ser una constante de enumeración
annotation.attribute.unknown.method=No se puede encontrar el método @interface ''{0}()''
annotation.cannot.be.local=No se permiten anotaciones locales
annotation.container.abstract=La anotación de contenedor ''{0}'' no tiene un valor predeterminado para ''{1}''
annotation.container.bad.type=Anotación de contenedor no válida ''{0}'': el método ''value'' debe tener el tipo ''{1}''
annotation.container.low.retention=La anotación de contenedor ''{0}'' tiene una retención menor (''{1}'') que la anotación contenida
annotation.container.missed.annotation=La anotación de contenedor ''{0}'' no tiene la anotación @{1} requerida
annotation.container.no.value=Anotación de contenedor no válida ''{0}'': no se ha declarado el método ''value''
annotation.container.not.applicable=La anotación de contenedor ''@{0}'' no es aplicable a {1}
annotation.container.wide.target=El destino de la anotación de contenedor ''{0}'' no es un subconjunto del destino de esta anotación
annotation.container.wrong.place=La anotación de contenedor ''{0}'' no debe estar presente junto con el elemento que contiene
annotation.cyclic.element.type=Tipo de elemento de anotación cíclico
annotation.duplicate=Anotación duplicada
annotation.duplicate.explained=Anotación duplicada. {0}
annotation.duplicate.non.repeatable=Anotación duplicada. La declaración de ''{0}'' no tiene una anotación java.lang.annotation.Repeatable válida.
annotation.malformed.repeatable.explained={0}
annotation.may.not.have.extends.list=No se permite 'extends' en @interface
annotation.member.clash=El miembro @interface entra en conflicto con ''{0}'' en {1}
annotation.member.invalid.type=Tipo ''{0}'' no válido para el miembro de la anotación
annotation.member.may.not.have.parameters=Los miembros de @interface no pueden tener parámetros
annotation.member.may.not.have.throws.list=No se permite 'throws' en métodos de @interface
annotation.missing.attribute=Falta {0}, pero es obligatorio
annotation.not.allowed.class=El tipo literal de clase no puede ser anotado
annotation.not.allowed.here=No se permiten anotaciones aquí
annotation.not.allowed.in.permit.list=No se permiten anotaciones en la lista 'permits'
annotation.not.allowed.on.package=Las anotaciones de paquete solo se permiten en el archivo 'package-info.java'
annotation.not.allowed.ref=La anotación no es aplicable a este tipo de referencia
annotation.not.allowed.static=El tipo calificador de un miembro estático no puede estar anotado
annotation.not.allowed.var=El tipo 'var' no puede estar anotado
annotation.not.allowed.void=El tipo 'void' no se puede anotar
annotation.not.applicable=''@{0}'' no es aplicable a {1}
annotation.permits='permits' no se permite en @interface
annotation.repeated.target=Destino de anotación repetido
annotation.type.expected=Se esperaba un tipo de anotación
array.empty.diamond=No se permite la creación de arrays con '<>'
array.generic=No se permite la creación de arrays genéricos
array.illegal.initializer=Inicializador ilegal para ''{0}''
array.initializer.not.allowed=No se permite un inicializador de matriz aquí
array.too.many.dimensions=Demasiadas dimensiones de matriz
array.type.arguments=No se permite la creación de arrays con argumentos de tipo
array.type.expected=Se esperaba un tipo de array; se encontró: ''{0}''
assignment.declared.outside.guard=No se puede asignar un valor a la variable ''{0}'' porque está declarada fuera del guard
assignment.to.final.variable=No se puede asignar un valor a la variable final ''{0}''
binary.operator.not.applicable=El operador ''{0}'' no se puede aplicar a ''{1}'', ''{2}''
break.out.of.switch.expression=No se permite break fuera de una expresión switch
break.outside.switch.or.loop='break' fuera de switch o bucle
call.ambiguous=Llamada a método ambigua: tanto ''{0}'' como ''{1}'' coinciden
call.ambiguous.no.match=No se puede resolver el método ''{0}'' en ''{1}''
call.ambiguous.tooltip=<html><body><table border=0><tr><td colspan={0}>Llamada a método ambigua. Ambos</td></tr><tr>{1}<td>en <b>{2}</b>y</td></tr><tr>{3}<td>en <b>{4}</b>coinciden</td></tr></table></body></html>
call.constructor.duplicate=Solo se permite una llamada explícita al constructor en un constructor
call.constructor.must.be.first.statement=La llamada a ''{0}'' debe ser la primera sentencia en el cuerpo del constructor
call.constructor.must.be.top.level.statement=La llamada a ''{0}'' debe ser una instrucción de nivel superior en el cuerpo del constructor
call.constructor.only.allowed.in.constructor=Llamada a ''{0}'' solo permitida en el cuerpo del constructor
call.constructor.record.in.canonical=El constructor canónico no puede delegar en otro constructor
call.constructor.recursive=Llamada recursiva al constructor
call.direct.abstract.method.access=No se puede acceder directamente al método abstracto ''{0}''
call.expected=Se esperaba una llamada al método
call.formal.varargs.element.type.inaccessible.here=El tipo de elemento de varargs formal {0} es inaccesible desde aquí
call.member.before.constructor=No se puede llamar a ''{0}'' antes de que se llame al constructor de la superclase
call.parsed.as.deconstruction.pattern=Se requiere una expresión constante, un patrón o null
call.qualifier.primitive=No se pueden llamar a métodos en el tipo ''{0}''
call.static.interface.method.qualifier=El método estático solo se puede invocar en la interfaz que lo contiene
call.super.enum.constructor=No se permite la llamada a 'super' en el constructor de la enumeración
call.super.qualifier.not.inner.class=No se permite el calificador porque la superclase ''{0}'' no es una clase interna no estática
call.type.inference.error={0}
call.unresolved=No se puede resolver el método ''{0}''
call.unresolved.name=No se puede resolver el método ''{0}''
call.wrong.arguments='{0}'' en ''{1}'' no se puede aplicar a ''{2}'
call.wrong.arguments.count.mismatch=Se esperaba {0, choice, 0#ningún argumento|1#1 argumento|1<{0} argumentos}, pero se encontró {1}
cast.inconvertible=Tipos inconvertibles; no se puede convertir ''{0}'' a ''{1}''
cast.intersection.inheritance.clash={0} no se puede heredar con argumentos diferentes: {1} y {2}
cast.intersection.not.interface=Se esperaba una interfaz aquí
cast.intersection.repeated.interface=Interfaz repetida
cast.intersection.unexpected.type=Tipo inesperado: se esperaba una clase
catch.type.parameter=No se pueden capturar parámetros de tipo
clash.methods.message='{0}'' entra en conflicto con ''{1}'
clash.methods.message.show.classes='{0}'' en ''{2}'' entra en conflicto con ''{1}'' en ''{3}'
class.already.imported=''{0}'' ya está definido en esta unidad de compilación
class.anonymous.extends.sealed=Las clases anónimas no deben extender clases selladas
class.cannot.be.referenced.from.static.context=No se puede hacer referencia a ''{0}'' desde un contexto estático
class.cannot.extend.multiple.classes=La clase no puede extender múltiples clases
class.clashes.with.package=La clase ''{0}'' entra en conflicto con un paquete con el mismo nombre
class.cyclic.inheritance=Herencia cíclica que involucra a ''{0}''
class.duplicate=Clase duplicada: ''{0}''
class.duplicate.in.other.file=Se encontró una clase duplicada en el archivo ''{0}''
class.extends.final=No se puede heredar de {1, choice, 1#la clase final|2#la enumeración|3#el registro|4#la clase de valor no abstracta} ''{0}''
class.extends.interface=No se esperaba una interfaz aquí
class.extends.prohibited.class=Las clases no pueden extender directamente ''{0}''
class.extends.sealed.another.module=No se permite que una clase extienda una clase sellada de otro módulo
class.extends.sealed.another.package={0} ''{1}'' de otro paquete no tiene permitido extender {2} sellado ''{3}'' en un módulo sin nombre
class.extends.sealed.local=Las clases locales no deben extender clases selladas
class.extends.sealed.not.permitted=No se permite ''{0}'' en la jerarquía sellada
class.generic.extends.exception=La clase genérica no puede extender 'java.lang.Throwable'
class.implements.class=Se esperaba una interfaz aquí
class.implicit.initializer=No se permiten inicializadores en las clases declaradas implícitamente
class.implicit.invalid.file.name=El nombre del archivo de una clase declarada implícitamente no es un identificador válido
class.implicit.no.main.method=La clase declarada implícitamente no contiene el método 'main'
class.implicit.package.statement=La sentencia de paquete no se permite en clases declaradas implícitamente
class.inheritance.different.type.arguments='{0}'' no se puede heredar con diferentes argumentos de tipo: ''{1}'' y ''{2}'
class.inheritance.method.clash=Los métodos {0} de {1} y {2} de {3} se heredan con la misma firma
class.inheritance.raw.and.generic='{0}'' no se puede heredar como un tipo raw y con argumentos de tipo genérico ''{1}'
class.inherits.abstract.and.default={0} hereda los métodos abstractos y predeterminados de {1} de los tipos {2} y {3}
class.inherits.type.parameter=La clase no puede heredar de su parámetro de tipo
class.inherits.unrelated.defaults={0} hereda valores por defecto no relacionados para {1} de los tipos {2} y {3}
class.initializer.must.complete.normally=El inicializador debe poder finalizar normalmente
class.must.implement.method=La clase ''{0}'' debe implementar el método abstracto ''{1}'' en ''{2}''
class.must.implement.method.enum.constant=La constante de enumeración ''{0}'' debe implementar el método abstracto ''{1}'' en ''{2}''
class.must.implement.method.or.abstract=La clase ''{0}'' debe declararse como abstracta o implementar el método abstracto ''{1}'' en ''{2}''
class.not.accessible=No se puede acceder a {0}
class.not.enclosing=''{0}'' no es una clase contenedora
class.or.package.expected=Se esperaba una clase o un paquete
class.permitted.must.have.modifier=Todas las subclases de una clase sellada deben ser final, sealed o non-sealed
class.permitted.not.direct.subclass=Cláusula ''permits'' no válida: ''{0}'' debe {1, choice, 1#extender|2#implementar} directamente a ''{2}''
class.reference.list.duplicate=Referencia duplicada a ''{0}'' en la lista ''{1}''
class.reference.list.inner.private='{0}'' tiene acceso privado en ''{1}'
class.reference.list.name.expected=Se esperaba un nombre de clase
class.reference.list.no.enclosing.instance=No hay ninguna instancia envolvente del tipo ''{0}'' en el ámbito
class.sealed.incomplete.permits=La cláusula permits de una clase sellada debe contener todas las subclases
class.sealed.inheritor.expected.modifiers=Se esperaba el modificador 'sealed' o 'non-sealed'
class.sealed.inheritor.expected.modifiers.can.be.final=Se esperaba el modificador 'sealed', 'non-sealed' o 'final'
class.sealed.no.inheritors=La clase sellada debe tener subclases
class.sealed.permits.on.non.sealed=Cláusula ''permits'' no válida: ''{0}'' debe ser sealed
class.wrong.filename=La clase ''{0}'' es pública, debe declararse en un archivo llamado ''{0}.java''
comment.shebang.java.file=El mecanismo Shebang en archivos .java no está permitido
comment.unclosed=Comentario sin cerrar
constructor.ambiguous.implicit.call=Llamada implícita al constructor ambigua: tanto ''{0}'' como ''{1}'' coinciden
constructor.in.implicit.class=No se permite un constructor explícito en una clase declarada implícitamente
constructor.no.default=No hay ningún constructor sin argumentos disponible en ''{0}''
continue.out.of.switch.expression=No se permite 'continue' fuera de una expresión switch
continue.outside.loop=Sentencia 'continue' fuera del bucle
enum.constant.illegal.access.in.constructor=No se permite acceder a {0, choice, 1#un campo estático|2#una constante de enumeración} desde {1, choice, 1#el constructor|2#el inicializador de campo de instancia|3#el inicializador de instancia} de la enumeración
enum.constant.modifier=No se permiten modificadores para las constantes de enumeración
enum.extends=No se permite 'extends' en enumeraciones
enum.permits='permits' no está permitido en una enumeración
exception.already.caught=La excepción ''{0}'' ya ha sido capturada
exception.must.be.disjoint=Los tipos en un multi-catch deben ser disjuntos: ''{0}'' es una subclase de ''{1}''
exception.never.thrown.try=La excepción ''{0}'' nunca se lanza en el bloque try correspondiente
exception.never.thrown.try.multi=La excepción ''{0}'' nunca se lanza en el bloque try correspondiente
exception.unhandled={1, choice, 0#Excepción no controlada|2#Excepciones no controladas}: {0}
exception.unhandled.close={1, choice, 0#Excepción no manejada|2#Excepciones no manejadas} del recurso auto-closeable: {0}
expression.class.parameterized.type=No se puede acceder al objeto de clase de un tipo parametrizado
expression.class.type.parameter=No se puede acceder al objeto de clase de un parámetro de tipo
expression.expected=Se esperaba una expresión
expression.qualified.class.expected=Se espera un nombre de clase aquí
expression.super.bad.qualifier.method.overridden=Calificador de tipo incorrecto en la llamada super predeterminada: el método {0} se ha sobrescrito en {1}
expression.super.bad.qualifier.redundant.extended=Calificador de tipo incorrecto en la llamada super predeterminada: la interfaz redundante {0} es extendida por {1}
expression.super.dot.expected=Se esperaba '.'
expression.super.no.enclosing.instance=No hay ninguna instancia envolvente de tipo ''{0}'' en el ámbito
expression.super.not.enclosing.class=''{0}'' no es una clase envolvente
expression.super.unqualified.default.method=No se permite una referencia super no calificada en un método de extensión
field.initialized.before.constructor.call=No se puede asignar el campo inicializado ''{0}'' antes de llamar al constructor de la superclase
field.not.initialized=El campo ''{0}'' podría no haber sido inicializado
foreach.not.applicable=Foreach no es aplicable al tipo ''{0}''
guard.evaluated.to.false=La etiqueta case tiene una guarda que es una expresión constante con valor 'false'
guard.misplaced=Solo se permite guard después de patrones
identifier.restricted=''{0}'' es un identificador restringido y no se puede utilizar para declaraciones de tipos
illegal.character=Carácter no válido: {0}
illegal.unicode.escape=Secuencia de escape Unicode no válida
import.list.extra.semicolon=No se permiten puntos y coma adicionales entre las sentencias import
import.single.class.conflict=''{0}'' ya está definido en una importación de tipo único
import.single.static.class.already.defined=La clase ''{0}'' ya está definida en una importación estática única
import.single.static.class.ambiguous=La clase ''{0}'' es ambigua en una importación estática única
import.single.static.field.already.defined=El campo ''{0}'' ya está definido en una importación estática única
import.single.static.field.ambiguous=El campo ''{0}'' es ambiguo en una única importación estática
import.static.on.demand.resolves.to.class=No se encontró la clase {0}
incomplete.project.state.pending.reference=No se resolverá hasta que el proyecto se cargue por completo
instanceof.illegal.generic.type=Tipo genérico no válido para instanceof
instanceof.type.parameter=Se esperaba una clase o un array
instanceof.unsafe.cast='{0}'' no se puede convertir de forma segura a ''{1}'
instantiation.abstract=''{0}'' es abstracto; no se puede instanciar
instantiation.enum=No se pueden instanciar tipos enumerados
insufficient.language.level={0} no se admite en el nivel de lenguaje ''{1}''
interface.class.initializer=No se permite el inicializador de clase en la interfaz
interface.constructor=No se permiten constructores en la interfaz
interface.extends.class=Se esperaba una interfaz aquí
interface.implements='implements' no está permitido en la interfaz
label.duplicate=La etiqueta ''{0}'' ya está en uso
label.must.be.loop=El destino de ''continue'' debe ser una etiqueta de bucle: ''{0}''
label.unresolved=Etiqueta no definida: ''{0}''
label.without.statement=Etiqueta sin sentencia
lambda.incompatible.parameter.types=Tipos de parámetros incompatibles en la expresión lambda: se esperaba {0} pero se encontró {1}
lambda.inference.error={0}
lambda.multiple.sam.candidates=Se encontraron múltiples métodos abstractos que no sobrescriben en {0}
lambda.no.target.method.found=No se encontró el método de destino
lambda.not.a.functional.interface={0} no es una interfaz funcional
lambda.not.expected=Expresión lambda inesperada
lambda.parameters.inconsistent.var=No se pueden mezclar 'var' y parámetros con tipos explícitos en una expresión lambda
lambda.return.type.error={0}
lambda.sam.generic=El método de destino es genérico
lambda.sealed=Lambda no puede implementar una interfaz sellada
lambda.sealed.functional.interface=La interfaz funcional no se puede declarar como 'sealed'
lambda.target.not.interface=El tipo de destino de una conversión lambda debe ser una interfaz
lambda.type.inference.failure=No se puede inferir el tipo de la interfaz funcional
lambda.wrong.number.of.parameters=Número incorrecto de parámetros en la expresión lambda: se esperaban {0} pero se encontraron {1}
literal.binary.no.digits=Los números binarios deben contener al menos un dígito binario
literal.character.empty=Literal de carácter vacío
literal.character.illegal.escape=Carácter de escape ilegal en el literal de carácter
literal.character.too.long=Demasiados caracteres en el literal de carácter
literal.character.unclosed=Literal de carácter sin cerrar
literal.floating.malformed=Literal de punto flotante mal formado
literal.floating.too.large=Número de coma flotante demasiado grande
literal.floating.too.small=Número de punto flotante demasiado pequeño
literal.hexadecimal.no.digits=Los números hexadecimales deben contener al menos un dígito hexadecimal.
literal.illegal.underscore=Guion bajo ilegal
literal.integer.too.large=Número entero demasiado grande
literal.long.too.large=Número long demasiado grande
literal.string.illegal.escape=Carácter de escape ilegal en el literal de cadena
literal.string.illegal.line.end=No se permite el fin de línea en literales de cadena
literal.text.block.no.new.line=Inicio de bloque de texto no válido: falta un salto de línea después de las comillas de apertura
literal.text.block.unclosed=Bloque de texto sin cerrar
lvalue.variable.expected=Se esperaba una variable
lvti.array=No se permite 'var' como tipo de elemento de un array
lvti.compound='var' no está permitido en una declaración compuesta
lvti.lambda=No se puede inferir el tipo: la expresión lambda requiere un tipo de destino explícito
lvti.method.reference=No se puede inferir el tipo: la referencia de método requiere un tipo de destino explícito
lvti.no.initializer=No se puede inferir el tipo: 'var' en una variable sin un inicializador
lvti.null=No se puede inferir el tipo: el inicializador de la variable es 'null'
lvti.self.referenced=No se puede inferir el tipo de ''{0}'', se utiliza en su propio inicializador de variable
lvti.void=No se puede inferir el tipo: el inicializador de la variable es 'void'
method.abstract.body=Los métodos abstractos no pueden tener cuerpo
method.abstract.in.non.abstract.class=Método abstracto en una clase no abstracta
method.default.in.class=Los métodos de extensión solo se pueden utilizar dentro de una interfaz
method.default.overrides.object.member=El método predeterminado ''{0}'' sobrescribe un miembro de ''java.lang.Object''
method.default.should.have.body=El método de extensión debe tener un cuerpo
method.duplicate='{0}'' ya está definido en ''{1}'
method.generic.same.erasure={0}; ambos métodos tienen el mismo borrado
method.generic.same.erasure.hide={0}; ambos métodos tienen el mismo borrado, pero ninguno oculta al otro
method.generic.same.erasure.override={0}; ambos métodos tienen el mismo borrado (erasure), pero ninguno de los dos sobrescribe al otro
method.inheritance.clash.does.not.throw={0}; el método sobrescrito no lanza ''{1}''
method.inheritance.clash.incompatible.return.types={0}; tipo de retorno incompatible
method.inheritance.clash.unrelated.return.types={0}; los métodos tienen tipos de retorno no relacionados
method.inheritance.weaker.privileges={0}; intentando asignar privilegios de acceso más débiles (''{1}''); era ''{2}''
method.instance.overrides.static=El método de instancia ''{0}'' en ''{1}'' no puede sobrescribir el método estático ''{2}'' en ''{3}''
method.interface.body=Los métodos abstractos de una interfaz no pueden tener cuerpo
method.missing.return.type=Falta el tipo de retorno del método o el nombre del constructor no coincide con el nombre de la clase
method.native.body=Los métodos nativos no pueden tener cuerpo
method.no.parameter.list=Se esperaba una lista de parámetros
method.overrides.final=''{0}'' no puede sobrescribir ''{1}'' en ''{2}''; el método sobrescrito es final
method.private.in.interface.should.have.body=Los métodos privados en las interfaces deben tener un cuerpo
method.reference.abstract.method=No se puede acceder directamente al método abstracto ''{0}''
method.reference.enclosing.instance.not.in.scope=Una instancia envolvente de tipo {0} no está en el ámbito
method.reference.inference.error={0}
method.reference.non.static.method.in.static.context=No se puede hacer referencia a un método no estático desde un contexto estático
method.reference.not.expected=No se esperaba una expresión de referencia a método aquí
method.reference.parameterized.qualifier=Calificador parametrizado en referencia a método estático
method.reference.qualifier.class.unresolved=No se puede encontrar la clase {0}
method.reference.qualifier.wildcard=Comodín inesperado
method.reference.raw.constructor=Referencia a constructor raw con parámetros de tipo explícitos para el constructor
method.reference.return.type.error={0}
method.reference.sealed=La referencia a método no puede implementar una interfaz sellada
method.reference.static.method.non.static.qualifier=Método estático referenciado a través de un calificador no estático
method.reference.static.method.receiver=Método estático referenciado mediante un receptor
method.reference.unresolved.constructor=No se puede resolver el constructor ''{0}''
method.reference.unresolved.method=No se puede resolver el método ''{0}''
method.should.have.body=Se esperaba el cuerpo del método
method.should.have.body.or.abstract=Se espera un cuerpo de método o el modificador 'abstract'
method.static.in.interface.should.have.body=Los métodos estáticos en las interfaces deben tener un cuerpo
method.static.overrides.instance=El método estático ''{0}'' en ''{1}'' no puede sobrescribir el método de instancia ''{2}'' en ''{3}''
method.throws.class.name.expected=Se esperaba un nombre de clase
modifier.incompatible=Combinación ilegal de modificadores ''{0}'' y ''{1}''
modifier.not.allowed=El modificador ''{0}'' no se permite aquí
modifier.not.allowed.local.class=El modificador ''{0}'' no está permitido en clases locales
modifier.not.allowed.non.sealed=El modificador 'non-sealed' no está permitido en clases que no tienen una superclase 'sealed'
modifier.repeated=Modificador repetido ''{0}''
module.access.bad.name=El nombre del módulo ''{0}'' no es válido
module.access.does.not.read=El módulo ''{0}'' no puede leer ''{1}''
module.access.from.named=El paquete ''{0}'' está declarado en el módulo ''{1}'', pero este no lo exporta al módulo ''{2}''
module.access.from.unnamed=El paquete ''{0}'' se declara en el módulo ''{1}'', pero no se exporta al módulo sin nombre
module.access.jps.dependency.problem=No se ha especificado la dependencia del módulo para ''{0}'' en la estructura del proyecto
module.access.not.in.graph=Falta el módulo ''{0}'' en el gráfico de módulos
module.access.package.bad.name=El paquete ''{0}'' está declarado en un módulo con un nombre no válido (''{1}'')
module.access.package.does.not.read=El paquete ''{0}'' se declara en el módulo ''{1}'', pero el módulo ''{2}'' no lo lee
module.access.package.not.in.graph=El paquete ''{0}'' está declarado en el módulo ''{1}'', pero este último no está en el grafo de módulos
module.access.to.unnamed=El paquete ''{0}'' está declarado en un módulo sin nombre, pero el módulo ''{1}'' no lo lee
module.conflicting.packages=El paquete ''{0}'' existe en otro módulo: {1}
module.conflicting.reads=El módulo ''{0}'' lee el paquete ''{1}'' tanto de ''{2}'' como de ''{3}''
module.cyclic.dependence=Dependencia cíclica: {0}
module.duplicate.exports=''exports'' duplicados: {0}
module.duplicate.exports.target=Destino ''exports'' duplicado: {0}
module.duplicate.implementation=Implementación duplicada: {0}
module.duplicate.opens=''opens'' duplicado: {0}
module.duplicate.opens.target=Objetivo ''opens'' duplicado: {0}
module.duplicate.provides=''provides'' duplicado: {0}
module.duplicate.requires=''requires'' duplicado: {0}
module.duplicate.uses=''uses'' duplicado: {0}
module.file.duplicate='module-info.java' ya existe en el módulo
module.file.wrong.location=La declaración del módulo debe estar ubicada en la raíz de fuentes del módulo
module.file.wrong.name=La declaración del módulo debe estar en un archivo llamado 'module-info.java'
module.import.not.allowed=No se permite la importación de módulos
module.no.package=Un archivo de módulo no debe tener una sentencia 'package'
module.not.found=Módulo no encontrado: {0}
module.not.on.path=El módulo no está en las dependencias: {0}
module.opens.in.weak.module='opens' no está permitido en un módulo abierto
module.reference.package.empty=El paquete está vacío: {0}
module.reference.package.not.found=Paquete no encontrado: {0}
module.service.abstract=La implementación del servicio es una clase abstracta: {0}
module.service.alien=La implementación del servicio debe definirse en el mismo módulo que la directiva provides
module.service.enum=La definición del servicio es una enumeración: {0}
module.service.implementation.type=El tipo de implementación del servicio debe ser un subtipo del tipo de interfaz del servicio o tener un método 'provider' público y estático sin argumentos.
module.service.inner=La implementación del servicio es una clase interna: {0}
module.service.no.constructor=La implementación del servicio no tiene un constructor público predeterminado: {0}
module.service.provider.type=El tipo de retorno del método ''provider'' debe ser un subtipo del tipo de interfaz del servicio: {0}
new.expression.anonymous.implements.interface.with.type.arguments=La clase anónima implementa una interfaz; no puede tener argumentos de tipo
new.expression.arguments.to.default.constructor.call=El constructor por defecto se invoca con argumentos
new.expression.diamond.anonymous.inner.non.private=No se puede usar '<>' debido a un método no privado que no sobrescribe ni implementa un método de un supertipo
new.expression.diamond.inference.failure={0}
new.expression.diamond.not.allowed=El operador diamante no está permitido aquí
new.expression.diamond.not.applicable=El operador diamante no es aplicable a tipos no parametrizados
new.expression.qualified.anonymous.implements.interface=Calificador inesperado para una clase anónima que implementa una interfaz
new.expression.qualified.malformed=New cualificado no válido
new.expression.qualified.qualified.class.reference=No se permite una referencia de clase calificada en un 'new' calificado
new.expression.qualified.static.class=New calificado de clase estática
new.expression.type.parameter=El parámetro de tipo ''{0}'' no se puede instanciar directamente
new.expression.unresolved.constructor=No se puede resolver el constructor ''{0}''
override.on.non-overriding.method=El método no sobrescribe ningún método de su superclase
override.on.static.method=Los métodos estáticos no pueden anotarse con @Override
package.clashes.with.class=El paquete ''{0}'' entra en conflicto con una clase del mismo nombre
pattern.cannot.infer.type=No se puede inferir el tipo de patrón: {0}
pattern.deconstruction.annotation=No se permiten anotaciones en los tipos de patrones de deconstrucción
pattern.deconstruction.count.mismatch=Número incorrecto de patrones anidados: se esperaba {0} pero se encontró {1}
pattern.deconstruction.requires.record=El patrón de deconstrucción solo se puede aplicar a un registro, ''{0}'' no es un registro
pattern.deconstruction.variable=No se permite un identificador aquí
pattern.expected.class.or.array.type=Se requiere un tipo de clase o de array
pattern.instanceof.equals=El tipo de patrón ''{0}'' es el mismo que el tipo de la expresión
pattern.instanceof.supertype=El tipo de patrón ''{0}'' es un supertipo del tipo de expresión ''{1}''
pattern.not.exhaustive=El patrón ''{0}'' no es exhaustivo en ''{1}''
pattern.type.pattern.expected=Se esperaba un patrón de tipo
pattern.unsafe.cast='{0}'' no se puede convertir de forma segura a ''{1}'
preview.api.usage={0} es una API de vista previa y está deshabilitada de forma predeterminada
receiver.name.mismatch=El nombre del receptor no coincide con el tipo de la clase envolvente
receiver.static.context=El receptor no se puede usar en un contexto estático
receiver.type.mismatch=El tipo del receptor no coincide con el tipo de la clase contenedora
receiver.wrong.context=No se permiten receptores fuera de la lista de parámetros del método
receiver.wrong.position=El receptor debe ser el primer parámetro
record.accessor=Accesor de componente de registro
record.accessor.non.public=El accessor del componente de record debe ser 'public'
record.accessor.wrong.return.type=Tipo de retorno del accessor del componente incorrecto. Se esperaba: ''{0}'', se encontró: ''{1}''
record.canonical.constructor=Constructor canónico
record.canonical.constructor.wrong.parameter.name=Los nombres de los parámetros del constructor canónico deben coincidir con los nombres de los componentes del record. Esperado: ''{0}'', encontrado: ''{1}''
record.canonical.constructor.wrong.parameter.type=Tipo de parámetro incorrecto para el componente de registro ''{0}''. Se esperaba: ''{1}'', se encontró: ''{2}''
record.compact.constructor=Constructor compacto
record.component.cstyle.declaration=No se permite la declaración de arrays al estilo C en un componente de registro
record.component.not.initialized=El componente de registro ''{0}'' podría no estar inicializado en el constructor canónico
record.component.restricted.name=Nombre de componente de registro ilegal ''{0}''
record.component.vararg.not.last=El componente de registro vararg debe ser el último de la lista
record.constructor.stronger.access=El nivel de acceso de {0} no puede ser más restrictivo que el nivel de acceso del registro (''{1}'')
record.extends='extends' no se permite en registros
record.header.regular.class=Encabezado de record declarado para un no-record
record.instance.field=No se permiten campos de instancia en los registros
record.instance.initializer=No se permite un inicializador de instancia en los registros
record.no.constructor.call.in.non.canonical=El constructor de registro no canónico debe delegar en otro constructor
record.no.header=El registro no tiene un encabezado declarado
record.permits=No se permite 'permits' en los registros
record.special.method.throws={0} no debe declarar una cláusula ''throws''
record.special.method.type.parameters={0} no puede tener parámetros de tipo
reference.ambiguous=La referencia a ''{0}'' es ambigua, tanto ''{1}'' como ''{2}'' coinciden
reference.class.in.default.package=La clase ''{0}'' está en el paquete predeterminado
reference.enum.forward=No se puede hacer referencia a la constante de enumeración ''{0}'' antes de su definición
reference.enum.self=No se puede hacer referencia a la constante de enumeración ''{0}'' desde su propia definición
reference.field.forward=No se puede leer el valor del campo ''{0}'' antes de la definición del campo
reference.field.self=No se puede leer el valor del campo ''{0}'' desde el interior de la propia definición del campo
reference.implicit.class=No se puede hacer referencia a la clase declarada implícitamente ''{0}''
reference.local.class.other.switch.branch=No se puede hacer referencia a la clase local ''{0}'' desde otra rama de switch
reference.member.before.constructor=No se puede hacer referencia a ''{0}'' antes de que se llame al constructor de la superclase
reference.non.static.from.static.context=No se puede hacer referencia al {0} no estático ''{1}'' desde un contexto estático
reference.outer.type.parameter.from.static.context=No se puede hacer referencia a ''{0}'' desde un contexto estático
reference.package.not.found=No se encontró el paquete: {0}
reference.qualifier.not.expression=El calificador debe ser una expresión
reference.qualifier.primitive=No se puede acceder a los campos en el tipo ''{0}''
reference.select.from.type.parameter=No se puede seleccionar de un parámetro de tipo
reference.type.argument.static.class=No se permiten argumentos de tipo aquí porque la clase ''{0}'' es estática
reference.type.needs.type.arguments=Tipo con formato incorrecto: ''{0}'' requiere argumentos de tipo porque su calificador tiene argumentos de tipo
reference.unresolved=No se puede resolver el símbolo ''{0}''
resource.declaration.or.variable.expected=Se esperaba una declaración, una variable final o efectivamente final
return.before.explicit.constructor.call=No se permite ''return'' antes de la llamada a ''{0}''
return.compact.constructor=La sentencia 'return' no se permite en un constructor compacto
return.from.constructor=No se puede devolver un valor desde un constructor
return.from.void.method=No se puede devolver un valor desde un método con tipo de resultado void
return.missing=Falta la sentencia return
return.outside.method=Return fuera del método
return.outside.switch.expression=Return fuera de la expresión switch envolvente
return.value.missing=Falta el valor de retorno
safe.varargs.on.fixed.arity=@SafeVarargs no se permite en métodos con aridad fija
safe.varargs.on.non.final.method=@SafeVarargs no está permitido en métodos de instancia que no sean final
safe.varargs.on.record.component=No se permite @SafeVarargs en un componente de registro
statement.bad.expression=No es una sentencia
statement.case.outside.switch=Sentencia 'case' fuera de 'switch'
statement.declaration.not.allowed=Declaración no permitida aquí
statement.invalid=Sentencia no válida
statement.unreachable=Sentencia inalcanzable
statement.unreachable.loop.body=La condición del bucle siempre es false, lo que hace que el cuerpo del bucle sea inalcanzable
string.template.processor.missing=Falta el procesador en la expresión de plantilla de cadena
string.template.raw.processor=No se permite el tipo de procesador raw: {0}
string.template.void.not.allowed.in.embedded=No se permite una expresión de tipo 'void' como expresión incrustada en una plantilla de cadena
switch.default.and.boolean=Switch' tiene todos los valores booleanos y una etiqueta 'default
switch.default.label.contains.case=La etiqueta para el caso por defecto debe utilizar solo la palabra clave 'default', sin 'case'
switch.default.label.not.allowed=No se permite la etiqueta predeterminada aquí: 'default' solo se puede utilizar como una etiqueta case única o combinada únicamente con 'null'
switch.default.null.order=Orden de etiquetas case no válido: 'null' debe ser la primera y 'default' la segunda
switch.different.case.kinds=Se utilizan diferentes tipos de 'case' en el 'switch'
switch.dominance.violation=La etiqueta está dominada por la etiqueta de caso anterior ''{0}''
switch.empty=''switch'' {0} no tiene ninguna cláusula case
switch.expression.cannot.be.void=El tipo de destino para la expresión switch no puede ser void
switch.expression.incompatible.type=Tipo incorrecto en la expresión switch: {0} no se puede convertir a {1}
switch.expression.no.result=La expresión 'switch' no tiene ninguna expresión de resultado
switch.expression.should.produce.result=La expresión switch debe producir un resultado en todas las rutas de ejecución
switch.fallthrough.to.pattern=Paso directo ilegal al patrón
switch.incomplete=''switch'' {0} no cubre todos los valores de entrada posibles
switch.label.combination.constants.and.patterns=Combinación de etiquetas case no válida: una etiqueta case debe contener una lista de constantes case o un único patrón case
switch.label.combination.constants.and.patterns.unnamed=Combinación de etiquetas case no válida: una etiqueta case debe contener una lista de constantes case o una lista de patrones case
switch.label.constant.expected=Se requiere una expresión constante
switch.label.duplicate=Etiqueta ''{0}'' duplicada
switch.label.duplicate.default=Etiqueta 'default' duplicada
switch.label.duplicate.unconditional.pattern=Patrón incondicional duplicado
switch.label.expected=La sentencia debe ir precedida de una etiqueta case
switch.label.multiple.patterns=Combinación de etiquetas case no válida: una etiqueta case no puede contener más de un patrón case
switch.label.multiple.patterns.unnamed=Combinación de etiquetas case no válida: solo se permiten múltiples patrones si ninguno de ellos declara variables de patrón
switch.label.pattern.expected=Se esperaba un patrón para el tipo de selector switch ''{0}''
switch.label.qualified.enum=Una etiqueta de caso de un switch de enumeración debe ser el nombre no cualificado de una constante de enumeración
switch.label.unexpected=Se requiere una expresión constante, patrón o null
switch.multiple.labels.with.pattern.variables=Solo se permiten múltiples etiquetas switch para un grupo de sentencias con etiquetas switch si ninguna de las etiquetas declara variables de patrón.
switch.null.label.not.allowed=Combinación de etiquetas case no válida: 'null' solo se puede utilizar como una etiqueta case única o emparejada únicamente con 'default'
switch.null.type.incompatible='null'' no se puede convertir a ''{0}'
switch.rule.should.produce.result=La regla de la expresión switch debe producir un resultado en todas las rutas de ejecución
switch.selector.type.invalid=No se admite el tipo de selector de ''{0}''
switch.selector.type.invalid.level=El tipo de selector ''{0}'' no es compatible con el nivel de lenguaje ''{1}''
switch.unconditional.pattern.and.boolean='switch' tiene todos los valores booleanos y un patrón incondicional
switch.unconditional.pattern.and.default=Switch' tiene tanto un patrón incondicional como una etiqueta 'default
syntax.error={0}
type.argument.in.permits.list=No se permiten genéricos en la lista permits
type.argument.not.allowed=No se permiten parámetros de referencia aquí
type.argument.on.raw.method=Argumentos de tipo proporcionados en un método raw
type.argument.on.raw.type=Argumentos de tipo proporcionados en un tipo raw
type.argument.primitive=El argumento de tipo no puede ser de un tipo primitivo
type.inaccessible=''{0}'' es inaccesible desde aquí
type.incompatible=Tipos incompatibles. Encontrado: ''{1}'', requerido: ''{0}''
type.incompatible.reason.ambiguous.method.reference=Razón: la referencia a método es ambigua: tanto ''{0}'' como ''{1}'' coinciden
type.incompatible.reason.inference=Razón: {0}
type.incompatible.tooltip.provided.type=Proporcionado:
type.incompatible.tooltip.required.type=Tipo requerido:
type.parameter.absent.class=El tipo ''{0}'' no tiene parámetros de tipo
type.parameter.absent.method=El método ''{0}'' no tiene parámetros de tipo
type.parameter.actual.inferred.mismatch=El argumento de tipo real y el tipo inferido se contradicen entre sí
type.parameter.cannot.be.followed.by.other.bounds=El parámetro de tipo no puede estar seguido de otros límites
type.parameter.count.mismatch=Número incorrecto de argumentos de tipo: {0}; se requieren: {1}
type.parameter.duplicate=Parámetro de tipo duplicado: ''{0}''
type.parameter.extends.interface.expected=Se espera una interfaz aquí
type.parameter.incompatible.upper.bounds=El parámetro de tipo {0} tiene límites superiores incompatibles: {1}
type.parameter.inferred.type.not.within.extend.bound=El tipo inferido ''{2}'' para el parámetro de tipo ''{0}'' no está dentro de su límite; debería extender ''{1}''
type.parameter.inferred.type.not.within.implement.bound=El tipo inferido ''{2}'' para el parámetro de tipo ''{0}'' no está dentro de sus límites; debe implementar ''{1}''
type.parameter.on.annotation=@interface no puede tener parámetros de tipo
type.parameter.on.annotation.member=Los miembros de @interface no pueden tener parámetros de tipo
type.parameter.on.enum=Un enum no puede tener parámetros de tipo
type.parameter.type.not.within.extend.bound=El parámetro de tipo ''{0}'' no está dentro de sus límites; debe extender ''{1}''
type.parameter.type.not.within.implement.bound=El parámetro de tipo ''{0}'' no está dentro de su límite; debe implementar ''{1}''
type.restricted.identifier=Referencia no válida al tipo restringido ''{0}''
type.unknown.class=Clase desconocida: ''{0}''
type.void.illegal=Tipo no válido: 'void'
type.void.not.allowed=El tipo 'void' no está permitido aquí
type.wildcard.cannot.be.instantiated=El tipo comodín ''{0}'' no se puede instanciar directamente
type.wildcard.may.be.used.only.as.reference.parameters=Los comodines solo pueden usarse como parámetros de referencia
type.wildcard.not.expected=No se esperaba un comodín
unary.operator.not.applicable=El operador ''{0}'' no se puede aplicar a ''{1}''
underscore.identifier=Desde Java 9, '_' es una palabra clave y no puede usarse como identificador
underscore.identifier.lambda=No se permite el uso de '_' como nombre de parámetro lambda
underscore.identifier.unnamed=No se permite el uso de '_' como referencia
unnamed.field.not.allowed=No se permite un campo sin nombre
unnamed.method.parameter.not.allowed=No se permiten parámetros de método sin nombre
unnamed.variable.brackets=No se permiten corchetes después de una declaración de variable sin nombre
unnamed.variable.not.allowed.in.this.context=No se permite la declaración de variables sin nombre en este contexto
unnamed.variable.without.initializer=La declaración de variable sin nombre debe tener un inicializador
value.class.extends.non.abstract=Las clases de valor solo pueden extender clases de valor abstractas o 'java.lang.Object'
vararg.cstyle.array.declaration=No se permite la declaración de arrays al estilo C en parámetros vararg
vararg.not.last.parameter=El parámetro vararg debe ser el último de la lista
variable.already.assigned=Es posible que la variable ''{0}'' ya haya sido asignada
variable.already.assigned.constructor=No se puede asignar el campo final ''{0}'' {1, choice, 1#antes|2#después} de la llamada al constructor encadenado
variable.already.assigned.field=El campo final ''{0}'' ya está inicializado en otro inicializador de campo
variable.already.assigned.initializer=El campo final ''{0}'' ya se ha inicializado en un inicializador de clase
variable.already.defined=La variable ''{0}'' ya está definida en el ámbito
variable.assigned.in.loop=La variable ''{0}'' podría ser asignada en un bucle
variable.must.be.effectively.final=La variable ''{0}'' se accede desde una clase interna, debe ser final o efectivamente final
variable.must.be.effectively.final.guard=La variable utilizada en la expresión de guarda debe ser final o efectivamente final
variable.must.be.effectively.final.lambda=La variable usada en una expresión lambda debe ser final o efectivamente final
variable.must.be.final=La variable ''{0}'' es accedida desde una clase interna, debe ser declarada final
variable.must.be.final.resource=La variable utilizada como recurso try-with-resources debe ser final o efectivamente final
variable.not.initialized=La variable ''{0}'' podría no haber sido inicializada
yield.unexpected='yield' fuera de una expresión switch
yield.void=El tipo de la expresión no debe ser 'void'
