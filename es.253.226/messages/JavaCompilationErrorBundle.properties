access.generic.problem=No se puede acceder a ''{0}'' en ''{1}''
access.package.local=''{0}'' no es público en ''{1}''. No se puede acceder desde fuera del paquete
access.private=''{0}'' tiene acceso privado en ''{1}''
access.protected=''{0}'' tiene acceso protegido en ''{1}''
annotation.attribute.duplicate=Atributo ''{0}'' duplicado
annotation.attribute.illegal.array.initializer=Inicializador no válido para ''{0}''
annotation.attribute.incompatible.type=Tipos incompatibles. Encontrado: ''{1}'', requerido: ''{0}''
annotation.attribute.name.missing=Se espera un atributo de anotación con el formato 'name=value'
annotation.attribute.non.class.literal=El valor del atributo debe ser un literal de clase
annotation.attribute.non.constant=El valor del atributo debe ser constante
annotation.attribute.non.enum.constant=El valor del atributo debe ser una constante de enumeración
annotation.attribute.unknown.method=No se puede encontrar el método @interface ''{0}()''
annotation.cannot.be.local=No se permiten anotaciones locales
annotation.container.abstract=La anotación de contenedor ''{0}'' no tiene un valor predeterminado para ''{1}''
annotation.container.bad.type=Anotación de contenedor no válida ''{0}'': el método ''value'' debería tener el tipo ''{1}''
annotation.container.low.retention=La anotación de contenedor '{0}' tiene una retención ('{1}') más corta que la anotación contenida.
annotation.container.missed.annotation=Anotación de contenedor ''{0}'' no tiene la anotación @{1} obligatoria
annotation.container.no.value=Anotación de contenedor ''{0}'' no válida: no se declaró el método ''value''
annotation.container.not.applicable=La anotación de contenedor ''@{0}'' no es aplicable a {1}
annotation.container.wide.target=El objetivo de la anotación de contenedor ''{0}'' no es un subconjunto del objetivo de esta anotación
annotation.container.wrong.place=La anotación de contenedor ''{0}'' no debe estar presente junto con el elemento que contiene
annotation.cyclic.element.type=Tipo de elemento de anotación cíclico
annotation.duplicate=Anotación duplicada
annotation.duplicate.explained=Anotación duplicada. {0}
annotation.duplicate.non.repeatable=Anotación duplicada. La declaración de ''{0}'' no tiene una anotación java.lang.annotation.Repeatable válida
annotation.malformed.repeatable.explained={0}
annotation.may.not.have.extends.list='extends' no permitido en @interface
annotation.member.clash=miembro de @interface entra en conflicto con ''{0}'' en {1}
annotation.member.invalid.type=Tipo no válido ''{0}'' para miembro de anotación
annotation.member.may.not.have.parameters=@interface los miembros no pueden tener parámetros
annotation.member.may.not.have.throws.list=No se permite 'throws' en un método de @interface
annotation.missing.attribute={0} es obligatorio y falta
annotation.not.allowed.class=No se puede anotar el tipo literal de clase
annotation.not.allowed.here=Las anotaciones no están permitidas aquí
annotation.not.allowed.in.permit.list=Anotaciones no permitidas en la lista 'permits'
annotation.not.allowed.on.package=Las anotaciones del paquete deben estar en el archivo package-info.java
annotation.not.allowed.ref=La anotación no es aplicable a este tipo de referencia
annotation.not.allowed.static=El tipo calificador de miembro estático no puede estar anotado
annotation.not.allowed.var=El tipo 'var' no puede ser anotado
annotation.not.allowed.void='void' no se puede anotar
annotation.not.applicable=''{0}'' no es aplicable a {1}
annotation.permits='permits' no se permite en @interface
annotation.repeated.target=Objetivo de anotación repetido
annotation.type.expected=Se esperaba tipo de anotación
array.empty.diamond=No se permite la creación de matrices con '<>'
array.generic=Creación de matrices genéricas no permitida
array.illegal.initializer=Inicializador no válido para ''{0}''
array.initializer.not.allowed=El inicializador de arreglo no está permitido aquí
array.too.many.dimensions=Demasiadas dimensiones de matriz
array.type.arguments=Creación de array con argumentos de tipo no permitida
array.type.expected=Se esperaba un tipo de array; encontrado: ''{0}''
assignment.declared.outside.guard=No se puede asignar un valor a la variable ''{0}'', porque está declarada fuera del guard
assignment.to.final.variable=No se puede asignar un valor a la variable final ''{0}''
binary.operator.not.applicable=El operador ''{0}'' no se puede aplicar a ''{1}'', ''{2}''
break.out.of.switch.expression=No se permite el break fuera de una expresión switch
break.outside.switch.or.loop='break' fuera de switch o bucle
call.ambiguous=Llamada a método ambigua: tanto ''{0}'' como ''{1}'' coinciden
call.ambiguous.no.match=No se puede resolver el método ''{0}'' en ''{1}''
call.ambiguous.tooltip=<html><body><table border=0><tr><td colspan={0}>Llamada a método ambigua. Tanto</td></tr><tr>{1}<td>en <b>{2}</b>y</td></tr><tr>{3}<td>en <b>{4}</b>coinciden</td></tr></table></body></html>
call.constructor.duplicate=Solo se permite una llamada explícita al constructor en el constructor
call.constructor.must.be.first.statement=La llamada a ''{0}'' debe ser la primera instrucción en el cuerpo del constructor
call.constructor.must.be.top.level.statement=La llamada a ''{0}'' debe ser una sentencia de nivel superior en el cuerpo del constructor
call.constructor.only.allowed.in.constructor=La llamada a ''{0}'' solo está permitida en el cuerpo del constructor
call.constructor.record.in.canonical=El constructor canónico no puede delegar a otro constructor
call.constructor.recursive=Llamada a constructor recursiva
call.direct.abstract.method.access=No se puede acceder directamente al método abstracto ''{0}''
call.expected=Se esperaba una llamada a método
call.formal.varargs.element.type.inaccessible.here=El tipo de elemento varargs formal {0} es inaccesible desde aquí
call.member.before.constructor=No se puede llamar a ''{0}'' antes de que se llame al constructor de la superclase
call.parsed.as.deconstruction.pattern=Se requiere una expresión constante, patrón o null
call.qualifier.primitive=No se pueden llamar métodos en el tipo ''{0}''
call.static.interface.method.qualifier=El método estático solo puede ser llamado en su interfaz contenedora
call.super.enum.constructor=Llamada a 'super' no está permitida en el constructor de enumeraciones
call.super.qualifier.not.inner.class=No se permite el calificador porque la superclase ''{0}'' no es una clase interna no estática
call.type.inference.error={0}
call.unresolved=No se puede resolver el método ''{0}''
call.unresolved.name=No se puede resolver el método ''{0}''
call.wrong.arguments=''{0}'' en ''{1}'' no se puede aplicar a ''{2}''
call.wrong.arguments.count.mismatch=Se esperaba {0, choice, 0#ningún argumento|1#1 argumento|1<{0} argumentos}, pero se encontró {1}
cast.inconvertible=Tipos inconvertibles; no se puede convertir ''{0}'' a ''{1}''
cast.intersection.inheritance.clash={0} no se puede heredar con argumentos diferentes: {1} y {2}
cast.intersection.not.interface=Se esperaba una interfaz aquí
cast.intersection.repeated.interface=Interfaz repetida
cast.intersection.unexpected.type=Tipo inesperado: se espera una clase
catch.type.parameter=No se pueden capturar parámetros de tipo
clash.methods.message='{0}' entra en conflicto con '{1}'
clash.methods.message.show.classes=''{0}'' en ''{2}'' entra en conflicto con ''{1}'' en ''{3}''
class.already.imported=''{0}'' ya está definido en esta unidad de compilación
class.anonymous.extends.sealed=Las clases anónimas no deben extender clases selladas
class.cannot.be.referenced.from.static.context=''{0}'' no se puede referenciar desde un contexto estático
class.cannot.extend.multiple.classes=Una clase no puede extender varias clases
class.clashes.with.package=La clase ''{0}'' entra en conflicto con el paquete del mismo nombre
class.cyclic.inheritance=Herencia cíclica que involucra ''{0}''
class.duplicate=Clase duplicada: ''{0}''
class.duplicate.in.other.file=Clase duplicada encontrada en el archivo ''{0}''
class.extends.final=No se puede heredar de {1, choice, 1#clase final|2#enumeración|3#registro|4#clase de valor no abstracta} ''{0}''
class.extends.interface=No se espera una interfaz aquí
class.extends.prohibited.class=Las clases no pueden extender directamente ''{0}''
class.extends.sealed.another.module=Una clase no puede extender una clase sealed de otro módulo
class.extends.sealed.another.package={0} ''{1}'' desde otro paquete no puede extender el sealed {2} ''{3}'' en módulo sin nombre
class.extends.sealed.local=Las clases locales no deben extender clases sealed
class.extends.sealed.not.permitted=''{0}'' no está permitido en la jerarquía sealed
class.generic.extends.exception=Una clase genérica no puede extender 'java.lang.Throwable'
class.implements.class=Se esperaba una interfaz aquí
class.implicit.initializer=Los inicializadores no están permitidos en clases declaradas implícitamente
class.implicit.invalid.file.name=El nombre de archivo de una clase declarada implícitamente no es un identificador válido
class.implicit.no.main.method=La clase declarada implícitamente no contiene un método 'main'
class.implicit.package.statement=La declaración de paquete no está permitida para una clase declarada implícitamente
class.inheritance.different.type.arguments=''{0}'' no se puede heredar con argumentos de tipo diferentes: ''{1}'' y ''{2}''
class.inheritance.method.clash=Los métodos {0} de {1} y {2} de {3} se heredan con la misma firma
class.inheritance.raw.and.generic=''{0}'' no se puede heredar como un tipo raw y con argumentos de tipo genérico ''{1}''
class.inherits.abstract.and.default={0} hereda de los tipos {2} y {3} una implementación abstracta y una predeterminada para {1}
class.inherits.type.parameter=La clase no puede heredar de su parámetro de tipo
class.inherits.unrelated.defaults={0} hereda valores por defecto no relacionados para {1} de los tipos {2} y {3}
class.initializer.must.complete.normally=El inicializador debe poder completarse normalmente
class.must.implement.method=La clase ''{0}'' debe implementar el método abstracto ''{1}'' en ''{2}''.
class.must.implement.method.enum.constant=La constante de enumeración ''{0}'' debe implementar el método abstracto ''{1}'' en ''{2}''
class.must.implement.method.or.abstract=La clase ''{0}'' debe declararse como abstracta o implementar el método abstracto ''{1}'' en ''{2}''
class.not.accessible=No se puede acceder a {0}
class.not.enclosing=''{0}'' no es una clase contenedora
class.or.package.expected=Se esperaba una clase o paquete
class.permitted.must.have.modifier=Todas las subclases de clases sealed deben ser final, sealed o non-sealed
class.permitted.not.direct.subclass=Cláusula ''permits'' no válida: ''{0}'' debe {1, choice, 1#extender|2#implementar} directamente ''{2}''
class.reference.list.duplicate=Referencia duplicada a ''{0}'' en la lista ''{1}''
class.reference.list.inner.private=''{0}'' tiene acceso privado en ''{1}''
class.reference.list.name.expected=Se espera un nombre de clase
class.reference.list.no.enclosing.instance=No hay instancia contenedora del tipo ''{0}'' en el ámbito
class.sealed.incomplete.permits=La cláusula permits de una clase sellada debe contener todas las subclases
class.sealed.inheritor.expected.modifiers=Se esperaba el modificador 'sealed' o 'non-sealed'
class.sealed.inheritor.expected.modifiers.can.be.final=Se esperaba el modificador 'sealed', 'non-sealed' o 'final'
class.sealed.no.inheritors=La clase sealed debe tener subclases
class.sealed.permits.on.non.sealed=Cláusula ''permits'' no válida: ''{0}'' debe ser sealed
class.wrong.filename=La clase ''{0}'' es pública y debe declararse en un archivo llamado ''{0}.java''
comment.shebang.java.file=El mecanismo Shebang en archivos .java no está permitido
comment.unclosed=Comentario no cerrado
constructor.ambiguous.implicit.call=Llamada a constructor implícito ambigua: ambos ''{0}'' y ''{1}'' coinciden
constructor.in.implicit.class=No se permite un constructor explícito en una clase declarada implícitamente
constructor.no.default=No hay un constructor sin argumentos disponible en ''{0}''
continue.out.of.switch.expression=No se permite usar continue fuera de una expresión switch
continue.outside.loop=Sentencia 'continue' fuera del bucle
enum.constant.illegal.access.in.constructor=No se permite acceder a {0, choice, 1#campo estático|2#constante de enumeración} desde la enumeración {1, choice, 1#constructor|2#inicializador de campo de instancia|3#inicializador de instancia}
enum.constant.modifier=No se permiten modificadores para constantes de enumeración
enum.extends='extends' no permitido en la enumeración
enum.permits='permits' no está permitido en la enumeración
exception.already.caught=La excepción ''{0}'' ya ha sido capturada
exception.must.be.disjoint=Los tipos en multi-catch deben ser disjuntos: ''{0}'' es una subclase de ''{1}''
exception.never.thrown.try=La excepción ''{0}'' nunca se lanza en el bloque try correspondiente
exception.never.thrown.try.multi=La excepción ''{0}'' nunca se lanza en el bloque try correspondiente
exception.unhandled=No manejado {1, choice, 0#excepción|2#excepciones}: {0}
exception.unhandled.close=No manejado {1, choice, 0#excepción|2#excepciones} desde recurso autocerrable: {0}
expression.class.parameterized.type=No se puede acceder al objeto de clase de un tipo parametrizado
expression.class.type.parameter=No se puede acceder al objeto de clase de un parámetro de tipo
expression.expected=Se esperaba una expresión
expression.qualified.class.expected=Se esperaba aquí el nombre de la clase
expression.super.bad.qualifier.method.overridden=Calificador de tipo incorrecto en la llamada super predeterminada: el método {0} se anula en {1}
expression.super.bad.qualifier.redundant.extended=Calificador de tipo incorrecto en llamada super predeterminada: la interfaz redundante {0} es extendida por {1}
expression.super.dot.expected='.' esperado
expression.super.no.enclosing.instance=No hay instancia envolvente de tipo ''{0}'' en el ámbito
expression.super.not.enclosing.class=''{0}'' no es una clase envolvente
expression.super.unqualified.default.method=No se permite la referencia super no cualificada en el método de extensión
field.initialized.before.constructor.call=No se puede asignar el campo inicializado ''{0}'' antes de llamar al constructor de la superclase
field.not.initialized=Campo ''{0}'' podría no haber sido inicializado
foreach.not.applicable=Foreach no aplicable al tipo ''{0}''
guard.evaluated.to.false=La etiqueta de caso tiene un guard que es una expresión constante con valor 'false'.
guard.misplaced=Guard solo se permite después de patrones.
identifier.restricted=''{0}'' es un identificador restringido y no puede usarse para declaraciones de tipo
illegal.character=Carácter ilegal: {0}
illegal.unicode.escape=Secuencia de escape Unicode no válida
import.list.extra.semicolon=No se permiten punto y coma adicionales entre las declaraciones de importación
import.single.class.conflict=''{0}'' ya está definido en una importación de tipo único
import.single.static.class.already.defined=La clase ''{0}'' ya está definida en una importación estática simple
import.single.static.class.ambiguous=Clase ''{0}'' es ambigua en una única importación estática
import.single.static.field.already.defined=El campo ''{0}'' ya está definido en una importación static única
import.single.static.field.ambiguous=El campo ''{0}'' es ambiguo en una única importación estática
import.static.on.demand.resolves.to.class=Clase {0} no encontrada
incomplete.project.state.pending.reference=No resuelto hasta que el proyecto esté completamente cargado
instanceof.illegal.generic.type=Tipo genérico ilegal para instanceof
instanceof.type.parameter=Se espera clase o array
instanceof.unsafe.cast=''{0}'' no se puede convertir de forma segura a ''{1}''
instantiation.abstract=''{0}'' es abstracto; no se puede instanciar
instantiation.enum=Los tipos enum no pueden ser instanciados
insufficient.language.level={0} no son compatibles en el nivel de lenguaje ''{1}''
interface.class.initializer=El inicializador de clase no está permitido en la interfaz
interface.constructor=El constructor no está permitido en la interfaz
interface.extends.class=Interfaz esperada aquí
interface.implements='implements' no permitido en la interfaz
label.duplicate=Etiqueta ''{0}'' ya está en uso
label.must.be.loop=''continue'' el objetivo debe ser una etiqueta de bucle: ''{0}''
label.unresolved=Etiqueta no definida: ''{0}''
label.without.statement=Etiqueta sin declaración
lambda.incompatible.parameter.types=Tipo de parámetro incompatible en la expresión lambda: se esperaba {0} pero se encontró {1}
lambda.inference.error={0}
lambda.multiple.sam.candidates=Múltiples métodos abstractos que no se anulan encontrados en {0}
lambda.no.target.method.found=No se encontró el método objetivo
lambda.not.a.functional.interface={0} no es una interfaz funcional
lambda.not.expected=Expresión lambda inesperada
lambda.parameters.inconsistent.var=No se pueden mezclar 'var' y parámetros escritos explícitamente en una expresión lambda
lambda.return.type.error={0}
lambda.sam.generic=Método de destino es genérico
lambda.sealed=Lambda no puede implementar una interfaz sealed
lambda.sealed.functional.interface=La interfaz funcional no puede declararse como 'sealed'
lambda.target.not.interface=El tipo de destino de una conversión lambda debe ser una interfaz
lambda.type.inference.failure=No se puede inferir el tipo de interfaz funcional
lambda.wrong.number.of.parameters=Número incorrecto de parámetros en la expresión lambda: se esperaban {0}, pero se encontraron {1}
literal.binary.no.digits=Los números binarios deben contener al menos un dígito binario
literal.character.empty=Literal de carácter vacío
literal.character.illegal.escape=Carácter de escape ilegal en literal de carácter
literal.character.too.long=Demasiados caracteres en el literal de carácter
literal.character.unclosed=Literal de carácter sin cerrar
literal.floating.malformed=Literal de punto flotante mal formado
literal.floating.too.large=Número de punto flotante demasiado grande
literal.floating.too.small=Número de punto flotante demasiado pequeño
literal.hexadecimal.no.digits=Los números hexadecimales deben contener al menos un dígito hexadecimal
literal.illegal.underscore=Guion bajo no permitido
literal.integer.too.large=Número entero demasiado grande
literal.long.too.large=Número largo demasiado grande
literal.string.illegal.escape=Carácter de escape ilegal en literal de cadena
literal.string.illegal.line.end=El final de línea no está permitido en literales de cadena
literal.text.block.no.new.line=Inicio de bloque de texto ilegal: falta nueva línea después de las comillas de apertura
literal.text.block.unclosed=Bloque de texto sin cerrar
lvalue.variable.expected=Se esperaba una variable
lvti.array='var' no está permitido como tipo de elemento de un array
lvti.compound='var' no está permitido en una declaración compuesta
lvti.lambda=No se puede inferir el tipo: la expresión lambda requiere un tipo de destino explícito
lvti.method.reference=No se puede inferir el tipo: la referencia de método requiere un tipo de destino explícito
lvti.no.initializer=No se puede inferir el tipo: 'var' en una variable sin un inicializador
lvti.null=No se puede inferir el tipo: el inicializador de variable es 'null'
lvti.self.referenced=No se puede inferir el tipo para ''{0}'', se utiliza en su propio inicializador de variable
lvti.void=No se puede inferir el tipo: el inicializador de variable es 'void'
method.abstract.body=Los métodos abstractos no pueden tener cuerpo
method.abstract.in.non.abstract.class=Método abstracto en clase no abstracta
method.default.in.class=Los métodos de extensión solo se pueden usar dentro de una interfaz
method.default.overrides.object.member=Método predeterminado ''{0}'' anula un miembro de ''java.lang.Object''
method.default.should.have.body=Un método de extensión debe tener un cuerpo
method.duplicate=''{0}'' ya está definido en ''{1}''
method.generic.same.erasure={0}; ambos métodos tienen la misma eliminación
method.generic.same.erasure.hide={0}; ambos métodos tienen la misma borradura, pero ninguno oculta al otro
method.generic.same.erasure.override={0}; ambos métodos tienen la misma eliminación, pero ninguno de los dos anula al otro
method.inheritance.clash.does.not.throw={0}; el método anulado no lanza ''{1}''
method.inheritance.clash.incompatible.return.types={0}; tipo de retorno incompatible
method.inheritance.clash.unrelated.return.types={0}; métodos tienen tipos de retorno no relacionados
method.inheritance.weaker.privileges={0}; intentando asignar privilegios de acceso más débiles (''{1}''); era ''{2}''
method.instance.overrides.static=El método de instancia ''{0}'' en ''{1}'' no puede anular el método estático ''{2}'' en ''{3}''
method.interface.body=Los métodos abstractos de interfaz no pueden tener cuerpo
method.missing.return.type=Declaración de método no válida; se requiere tipo de retorno
method.native.body=Los métodos nativos no pueden tener cuerpo
method.no.parameter.list=Se esperaba una lista de parámetros
method.overrides.final=''{0}'' no puede anular ''{1}'' en ''{2}''; el método anulado es final
method.private.in.interface.should.have.body=Los métodos privados en interfaces deberían tener un cuerpo
method.reference.abstract.method=El método abstracto ''{0}'' no puede ser accedido directamente
method.reference.enclosing.instance.not.in.scope=Una instancia englobante del tipo {0} no está en el ámbito
method.reference.inference.error={0}
method.reference.non.static.method.in.static.context=No se puede hacer referencia a un método no estático desde un contexto estático
method.reference.not.expected=La expresión de referencia de método no se espera aquí
method.reference.parameterized.qualifier=Calificador parametrizado en referencia a método estático
method.reference.qualifier.class.unresolved=No se puede encontrar la clase {0}
method.reference.qualifier.wildcard=Comodín inesperado
method.reference.raw.constructor=Referencia a constructor raw con parámetros de tipo explícitos
method.reference.return.type.error={0}
method.reference.sealed=La referencia a método no puede implementar una interfaz sellada
method.reference.static.method.non.static.qualifier=Método estático referenciado a través de calificador no estático
method.reference.static.method.receiver=Método estático referenciado a través del receptor
method.reference.unresolved.constructor=No se puede resolver el constructor ''{0}''
method.reference.unresolved.method=No se puede resolver el método ''{0}''
method.should.have.body=Se esperaba el cuerpo del método
method.should.have.body.or.abstract=Cuerpo del método o modificador 'abstract' esperado
method.static.in.interface.should.have.body=Los métodos estáticos en las interfaces deben tener un cuerpo
method.static.overrides.instance=El método estático ''{0}'' en ''{1}'' no puede sobrescribir el método de instancia ''{2}'' en ''{3}''
method.throws.class.name.expected=Se esperaba el nombre de clase
modifier.incompatible=Combinación ilegal de modificadores ''{0}'' y ''{1}''
modifier.not.allowed=Modificador ''{0}'' no permitido aquí
modifier.not.allowed.local.class=Modificador ''{0}'' no permitido en clases locales
modifier.not.allowed.non.sealed=El modificador 'non-sealed' no está permitido en clases que no tienen una superclase sealed
modifier.repeated=Modificador repetido ''{0}''
module.access.bad.name=El módulo ''{0}'' tiene un nombre no válido
module.access.does.not.read=El módulo ''{0}'' falla al leer ''{1}''
module.access.from.named=El paquete ''{0}'' se declara en el módulo ''{1}'', que no lo exporta al módulo ''{2}''
module.access.from.unnamed=El paquete ''{0}'' está declarado en el módulo ''{1}'', que no lo exporta al módulo sin nombre
module.access.jps.dependency.problem=La dependencia del módulo ''{0}'' no está especificada en la estructura del proyecto.
module.access.not.in.graph=El módulo ''{0}'' falta en el grafo de módulos.
module.access.package.bad.name=El paquete ''{0}'' está declarado en un módulo con un nombre inválido (''{1}'')
module.access.package.does.not.read=El paquete ''{0}'' está declarado en el módulo ''{1}'', pero el módulo ''{2}'' no lo lee
module.access.package.not.in.graph=El paquete ''{0}'' está declarado en el módulo ''{1}'', que no está en el grafo de módulos.
module.access.to.unnamed=El paquete ''{0}'' está declarado en el módulo sin nombre, pero el módulo ''{1}'' no lo lee
module.conflicting.packages=El paquete ''{0}'' existe en otro módulo: {1}
module.conflicting.reads=El módulo ''{0}'' lee el paquete ''{1}'' tanto de ''{2}'' como de ''{3}''
module.cyclic.dependence=Dependencia cíclica: {0}
module.duplicate.exports=Duplicado de ''exports'': {0}
module.duplicate.exports.target=Objetivo ''exports'' duplicado: {0}
module.duplicate.implementation=Implementación duplicada: {0}
module.duplicate.opens=Duplicado ''opens'': {0}
module.duplicate.opens.target=Duplicar objetivo ''opens'': {0}
module.duplicate.provides='''provides'' duplicado: {0}
module.duplicate.requires=Duplicado ''requires'': {0}
module.duplicate.uses=Duplicado ''uses'': {0}
module.file.duplicate='module-info.java' ya existe en el módulo
module.file.wrong.location=La declaración del módulo debe estar ubicada en la raíz de origen de un módulo
module.file.wrong.name=La declaración del módulo debería estar en un archivo llamado 'module-info.java'.
module.import.not.allowed=No se permite la importación de módulos
module.no.package=Un archivo de módulo no debe tener una declaración 'package'
module.not.found=Módulo no encontrado: {0}
module.not.on.path=El módulo no está en las dependencias: {0}
module.opens.in.weak.module='opens' no está permitido en un módulo abierto
module.reference.package.empty=El paquete está vacío: {0}
module.reference.package.not.found=Paquete no encontrado: {0}
module.service.abstract=La implementación del servicio es una clase abstracta: {0}
module.service.alien=La implementación del servicio debe definirse en el mismo módulo que la directiva provides
module.service.enum=La definición del servicio es un enum: {0}
module.service.implementation.type=El tipo de implementación del servicio debe ser un subtipo del tipo de interfaz del servicio, o tener un método 'provider' público y estático sin argumentos
module.service.inner=La implementación del servicio es una clase interna: {0}
module.service.no.constructor=La implementación del servicio no tiene un constructor predeterminado público: {0}
module.service.provider.type=El tipo de retorno del método ''provider'' debe ser un subtipo del tipo de la interfaz de servicio: {0}
new.expression.anonymous.implements.interface.with.type.arguments=Clase anónima implementa interfaz; no puede tener argumentos de tipo
new.expression.arguments.to.default.constructor.call=Se llama al constructor por defecto con argumentos
new.expression.diamond.anonymous.inner.non.private=No se puede usar '<>' debido a un método no privado que no anula ni implementa un método de un supertipo
new.expression.diamond.inference.failure={0}
new.expression.diamond.not.allowed=El operador diamante no está permitido aquí
new.expression.diamond.not.applicable=El operador diamante no es aplicable a tipos no parametrizados
new.expression.qualified.anonymous.implements.interface=Inesperado calificador para clase anónima que implementa interfaz
new.expression.qualified.malformed=new cualificado no válido
new.expression.qualified.qualified.class.reference=La referencia de clase calificada no está permitida en new calificado.
new.expression.qualified.static.class=new calificado de clase estática
new.expression.type.parameter=El parámetro de tipo ''{0}'' no se puede instanciar directamente
new.expression.unresolved.constructor=No se puede resolver el constructor ''{0}''
override.on.non-overriding.method=El método no anula un método de su superclase
override.on.static.method=Los métodos estáticos no pueden ser anotados con @Override
package.clashes.with.class=Paquete ''{0}'' entra en conflicto con clase del mismo nombre
pattern.cannot.infer.type=No se puede inferir el tipo de patrón: {0}
pattern.deconstruction.annotation=No se permiten anotaciones en tipos de patrones de desestructuración
pattern.deconstruction.count.mismatch=Número incorrecto de patrones anidados: se esperaban {0}, pero se encontraron {1}
pattern.deconstruction.requires.record=El patrón de deconstrucción solo se puede aplicar a un registro; ''{0}'' no es un registro
pattern.deconstruction.variable=Identificador no está permitido aquí
pattern.expected.class.or.array.type=Se requiere un tipo de clase o de array
pattern.instanceof.equals=El tipo de patrón ''{0}'' es el mismo que el tipo de expresión
pattern.instanceof.supertype=El tipo de patrón ''{0}'' es un supertipo del tipo de expresión ''{1}''
pattern.not.exhaustive=El patrón ''{0}'' no es exhaustivo en ''{1}''
pattern.type.pattern.expected=Se esperaba un patrón de tipo
pattern.unsafe.cast=''{0}'' no se puede convertir de forma segura a ''{1}''
preview.api.usage={0} es una API de vista previa y está deshabilitada por defecto
receiver.name.mismatch=El nombre del receptor no coincide con el tipo de la clase contenedora
receiver.static.context=El receptor no se puede utilizar en un contexto estático
receiver.type.mismatch=El tipo del receptor no coincide con el tipo de la clase contenedora
receiver.wrong.context=No se permiten receptores fuera de la lista de parámetros del método
receiver.wrong.position=El receptor debe ser el primer parámetro
record.accessor=Accesor del componente de registro
record.accessor.non.public=El accesor del componente de registro debe ser 'public'
record.accessor.wrong.return.type=Tipo de retorno del accesor del componente incorrecto. Esperado: ''{0}'', encontrado: ''{1}''
record.canonical.constructor=Constructor canónico
record.canonical.constructor.wrong.parameter.name=Los nombres de los parámetros del constructor canónico deben coincidir con los nombres de los componentes del registro. Se esperaba: ''{0}'', se encontró: ''{1}''
record.canonical.constructor.wrong.parameter.type=Tipo de parámetro incorrecto para el componente de registro ''{0}''. Esperado: ''{1}'', encontrado: ''{2}''
record.compact.constructor=Constructor compacto
record.component.cstyle.declaration=La declaración de array estilo C no está permitida en el componente de registro
record.component.not.initialized=El componente de registro ''{0}'' podría no ser inicializado en el constructor canónico
record.component.restricted.name=Nombre de componente de registro no válido ''{0}''
record.component.vararg.not.last=El componente record vararg debe ser el último de la lista
record.constructor.stronger.access={0} el nivel de acceso no puede ser más restrictivo que el nivel de acceso del registro (''{1}'')
record.extends=No se permite 'extends' en registros
record.header.regular.class=Encabezado de registro declarado para un no-registro
record.instance.field=Los campos de instancia no están permitidos en los registros
record.instance.initializer=Inicializador de instancia no está permitido en registros
record.no.constructor.call.in.non.canonical=El constructor de registro no canónico debe delegar en otro constructor
record.no.header=El registro no tiene encabezado declarado
record.permits='permits' no permitido en registros
record.special.method.throws={0} no debe declarar una cláusula ''throws''
record.special.method.type.parameters={0} no puede tener parámetros de tipo
reference.ambiguous=La referencia a ''{0}'' es ambigua, tanto ''{1}'' como ''{2}'' coinciden
reference.class.in.default.package=La clase ''{0}'' está en el paquete predeterminado
reference.enum.forward=No se puede hacer referencia a la constante de enumeración ''{0}'' antes de su definición
reference.enum.self=No se puede hacer referencia a la constante de enumeración ''{0}'' desde dentro de su propia definición
reference.field.forward=No se puede leer el valor del campo ''{0}'' antes de la definición del campo
reference.field.self=No se puede leer el valor del campo ''{0}'' desde dentro de la definición del campo.
reference.implicit.class=No se puede hacer referencia a la clase declarada implícitamente ''{0}''
reference.local.class.other.switch.branch=La clase local ''{0}'' no se puede referenciar desde otra rama switch
reference.member.before.constructor=No se puede hacer referencia a ''{0}'' antes de que se llame al constructor de la superclase
reference.non.static.from.static.context=No se puede hacer referencia al {0} no estático ''{1}'' desde un contexto estático
reference.outer.type.parameter.from.static.context=''{0}'' no se puede referenciar desde un contexto estático
reference.package.not.found=Paquete no encontrado: {0}
reference.qualifier.not.expression=El calificador debe ser una expresión
reference.qualifier.primitive=No se pueden acceder a los campos del tipo ''{0}''
reference.select.from.type.parameter=No se puede seleccionar de un parámetro de tipo
reference.type.argument.static.class=Los argumentos de tipo no están permitidos aquí porque la clase ''{0}'' es estática
reference.type.needs.type.arguments=Tipo con formato incorrecto: ''{0}'' necesita argumentos de tipo porque su calificador tiene argumentos de tipo
reference.unresolved=No se puede resolver el símbolo ''{0}''
resource.declaration.or.variable.expected=Se espera declaración, variable final o efectivamente final
return.before.explicit.constructor.call='return' no permitido antes de la llamada a ''{0}''
return.compact.constructor=La sentencia 'return' no está permitida en el constructor compacto
return.from.constructor=No se puede devolver un valor desde un constructor
return.from.void.method=No se puede devolver un valor desde un método con tipo de resultado void
return.missing=Falta la declaración return
return.outside.method=Retorno fuera de método
return.outside.switch.expression=Return fuera de la expresión switch adjunta
return.value.missing=Falta valor de retorno
safe.varargs.on.fixed.arity=@SafeVarargs no está permitido en métodos con aridad fija
safe.varargs.on.non.final.method=@SafeVarargs no está permitido en métodos de instancia no finales
safe.varargs.on.record.component=@SafeVarargs no está permitido en un componente de registro
statement.bad.expression=No es una instrucción
statement.case.outside.switch=Sentencia case fuera de switch
statement.declaration.not.allowed=Declaración no permitida aquí
statement.invalid=Sentencia no válida
statement.unreachable=Sentencia inalcanzable
statement.unreachable.loop.body=La condición del bucle es siempre false, haciendo que el cuerpo del bucle sea inalcanzable
string.template.processor.missing=Falta el procesador en la expresión de plantilla de cadena
string.template.raw.processor=El tipo de procesador en bruto no está permitido: {0}
string.template.void.not.allowed.in.embedded=Una expresión con el tipo 'void' no está permitida como expresión incrustada en una plantilla de cadena
switch.default.and.boolean='switch' tiene todos los valores booleanos y una etiqueta default
switch.default.label.contains.case=La etiqueta para el caso por defecto solo debe usar la palabra clave 'default', sin 'case'
switch.default.label.not.allowed=No se permite la etiqueta predeterminada aquí: 'default' solo se puede usar como una única etiqueta case o emparejada únicamente con 'null'
switch.default.null.order=Orden no válido de las etiquetas case: 'null' debe ser la primera y 'default' la segunda.
switch.different.case.kinds=Diferentes tipos de 'case' utilizados en 'switch'
switch.dominance.violation=La etiqueta está dominada por la etiqueta case anterior ''{0}''
switch.empty=''switch'' {0} no tiene ninguna cláusula case
switch.expression.cannot.be.void=El tipo de destino para la expresión switch no puede ser void
switch.expression.incompatible.type=Tipo incorrecto en la expresión switch: {0} no se puede convertir a {1}
switch.expression.no.result='La expresión 'switch' no tiene expresiones de resultado'
switch.expression.should.produce.result=La expresión switch debería producir un resultado en todas las rutas de ejecución
switch.fallthrough.to.pattern=Continuación ilegal a un patrón
switch.incomplete=''switch'' {0} no cubre todos los valores de entrada posibles
switch.label.combination.constants.and.patterns=Combinación de etiquetas case no válida: una etiqueta case debe constar de una lista de constantes case o de un único patrón case.
switch.label.combination.constants.and.patterns.unnamed=Combinación no válida de etiquetas 'case': una etiqueta 'case' debe constar de una lista de constantes 'case' o de una lista de patrones 'case'
switch.label.constant.expected=Expresión constante requerida
switch.label.duplicate=Etiqueta duplicada ''{0}''
switch.label.duplicate.default=Etiqueta predeterminada duplicada
switch.label.duplicate.unconditional.pattern=Patrón incondicional duplicado
switch.label.expected=La declaración debe ir precedida de una etiqueta case
switch.label.multiple.patterns=Combinación de etiquetas case no válida: una etiqueta case no debe consistir en más de un patrón.
switch.label.multiple.patterns.unnamed=Combinación de etiquetas case no válida: se permiten múltiples patrones solo si ninguno de ellos declara variables de patrón.
switch.label.pattern.expected=Se espera un patrón para el tipo de selector de interruptor ''{0}''
switch.label.qualified.enum=Una etiqueta de case de switch de enumeración debe ser el nombre no calificado de una constante de enumeración
switch.label.unexpected=Se requiere una expresión constante, un patrón o nulo
switch.multiple.labels.with.pattern.variables=Solo se permiten múltiples etiquetas switch para un grupo de sentencias con etiqueta switch si ninguna de ellas declara variables de patrón.
switch.null.label.not.allowed=Combinación de etiquetas case no válida: 'null' solo puede usarse como una etiqueta case única o emparejarse solo con 'default'
switch.null.type.incompatible='null' no se puede convertir a '{0}'
switch.rule.should.produce.result=La regla de expresión switch debería producir un resultado en todas las rutas de ejecución
switch.selector.type.invalid=El tipo de selector ''{0}'' no es compatible
switch.selector.type.invalid.level=El tipo de selector ''{0}'' no se admite en el nivel de lenguaje ''{1}''
switch.unconditional.pattern.and.boolean='switch' tiene todos los valores booleanos y un patrón incondicional
switch.unconditional.pattern.and.default='switch' tiene tanto un patrón incondicional como una etiqueta default
syntax.error={0}
type.argument.in.permits.list=No se permiten genéricos en la lista de permisos
type.argument.not.allowed=No se permiten parámetros de referencia aquí
type.argument.on.raw.method=Argumentos de tipo proporcionados en un método sin procesar
type.argument.on.raw.type=Argumentos de tipo proporcionados en un tipo raw
type.argument.primitive=El argumento de tipo no puede ser de un tipo primitivo
type.inaccessible=''{0}'' es inaccesible desde aquí
type.incompatible=Tipos incompatibles. Encontrado: ''{1}'', requerido: ''{0}''
type.incompatible.reason.ambiguous.method.reference=razón: referencia de método es ambigua: tanto ''{0}'' como ''{1}'' coinciden
type.incompatible.reason.inference=razón: {0}
type.incompatible.tooltip.provided.type=Proporcionado:
type.incompatible.tooltip.required.type=Tipo requerido:
type.parameter.absent.class=Tipo ''{0}'' no tiene parámetros de tipo
type.parameter.absent.method=El método ''{0}'' no tiene parámetros de tipo
type.parameter.actual.inferred.mismatch=El argumento de tipo real y el tipo inferido se contradicen mutuamente
type.parameter.cannot.be.followed.by.other.bounds=El parámetro de tipo no puede ir seguido de otros límites
type.parameter.count.mismatch=Número incorrecto de argumentos de tipo: {0}; requeridos: {1}
type.parameter.duplicate=Parámetro de tipo duplicado: ''{0}''
type.parameter.extends.interface.expected=Aquí se esperaba una interfaz
type.parameter.incompatible.upper.bounds=El parámetro de tipo {0} tiene límites superiores incompatibles: {1}
type.parameter.inferred.type.not.within.extend.bound=Tipo inferido ''{2}'' para el parámetro de tipo ''{0}'' no está dentro de sus límites; debe extender ''{1}''
type.parameter.inferred.type.not.within.implement.bound=El tipo inferido ''{2}'' para el parámetro de tipo ''{0}'' no está dentro de sus límites; debería implementar ''{1}''
type.parameter.on.annotation=@interface no puede tener parámetros de tipo
type.parameter.on.annotation.member=Los miembros @interface no pueden tener parámetros de tipo
type.parameter.on.enum=Los enums no pueden tener parámetros de tipo
type.parameter.type.not.within.extend.bound=El parámetro de tipo ''{0}'' no está dentro de su límite; debería extender ''{1}''
type.parameter.type.not.within.implement.bound=El parámetro de tipo ''{0}'' no está dentro de su límite; debe implementar ''{1}''
type.restricted.identifier=Referencia ilegal al tipo restringido ''{0}''
type.unknown.class=Clase desconocida: ''{0}''
type.void.illegal=Tipo no válido: 'void'
type.void.not.allowed=El tipo 'void' no está permitido aquí
type.wildcard.cannot.be.instantiated=El tipo comodín ''{0}'' no se puede instanciar directamente
type.wildcard.may.be.used.only.as.reference.parameters=Los comodines solo pueden usarse como parámetros de referencia
type.wildcard.not.expected=No se esperaba comodín
unary.operator.not.applicable=El operador ''{0}'' no se puede aplicar a ''{1}''
underscore.identifier=Desde Java 9, '_' es una palabra clave y no se puede utilizar como identificador
underscore.identifier.lambda=No se permite el uso de '_' como nombre de parámetro lambda
underscore.identifier.unnamed=No se permite usar '_' como referencia
unnamed.field.not.allowed=El campo sin nombre no está permitido
unnamed.method.parameter.not.allowed=No se permiten parámetros de método sin nombre
unnamed.variable.brackets=No se permiten corchetes después de una declaración de variable sin nombre
unnamed.variable.not.allowed.in.this.context=La declaración de variable sin nombre no está permitida en este contexto
unnamed.variable.without.initializer=La declaración de variable sin nombre debe tener un inicializador
value.class.extends.non.abstract=Las clases de valor solo pueden extender clases de valor abstractas o 'java.lang.Object'
vararg.cstyle.array.declaration=La declaración de matriz de estilo C no está permitida en el parámetro vararg
vararg.not.last.parameter=El parámetro vararg debe ser el último de la lista
variable.already.assigned=La variable ''{0}'' podría ya haber sido asignada
variable.already.assigned.constructor=No se puede asignar el campo final ''{0}'' después de una llamada a un constructor encadenado
variable.already.assigned.field=El campo final ''{0}'' ya está inicializado en otro inicializador de campo
variable.already.assigned.initializer=El campo final ''{0}'' ya está inicializado en un inicializador de clase
variable.already.defined=La variable ''{0}'' ya está definida en el ámbito
variable.assigned.in.loop=La variable ''{0}'' podría asignarse en un bucle
variable.must.be.effectively.final=La variable ''{0}'' se accede desde una clase interna, necesita ser final o efectivamente final
variable.must.be.effectively.final.guard=La variable utilizada en la expresión guard debe ser final o efectivamente final.
variable.must.be.effectively.final.lambda=La variable utilizada en una expresión lambda debe ser final o efectivamente final
variable.must.be.final=La variable ''{0}'' se accede desde una clase interna, necesita ser declarada final
variable.must.be.final.resource=La variable utilizada como recurso de try-with-resources debe ser final o efectivamente final
variable.not.initialized=La variable ''{0}'' podría no haber sido inicializada
yield.unexpected='yield' fuera de una expresión switch
yield.void=El tipo de expresión no debe ser 'void'