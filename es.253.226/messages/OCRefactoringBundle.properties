0.was.not.initialized={0} no se inicializó
button.cancel=&Cancelar
button.extract=Extraer
button.inline=En l&ínea
button.inline.all.usages.file=Inline de &todos los usos{0, choice, 0# en el archivo|1#}
button.inline.current.usage=Incorporar &uso actual
button.rename=&Renombrar
button.rename.all=Renombrar todos los usos(&R)
button.rename.code=Renombrar solo usos de &código
button.view.usages=&Mostrar usos
can.t.extract.type.of.0.definition=No se puede extraer el tipo de la definición {0}
can.t.inline.definition=No se puede aplicar inline a la definición de {0}
can.t.introduce.parameter.to.a.function.with.default.parameter.values=No se puede introducir un parámetro en una función con valores de parámetros por defecto
can.t.refactor.the.compound.initializer=No se puede refactorizar el inicializador compuesto
cannot.determine.type.of.the.selected.expression=No se puede determinar el tipo de la expresión seleccionada
cannot.find.the.method.function=No se puede encontrar el método/función
cannot.inline.constructor.expression=No se puede insertar la expresión del constructor en línea
cannot.inline.function.reference.in.non.call.expression=No se puede aplicar inline a la referencia de la función en una expresión que no sea una llamada
cannot.inline.function.type=No se puede insertar en línea el tipo de función
cannot.inline.method.reference.in.property.attribute=No se puede inlinear la referencia de método en un atributo de propiedad
cannot.inline.method.reference.in.selector.expression=No se puede realizar el inline de la referencia del método en la expresión '@selector'
cannot.inline.method.reference.in.xml.file=No se puede realizar el inline de la referencia al método en un archivo XML
cannot.inline.recursive=No se puede insertar en línea la llamada recursiva a {0}
cannot.inline.the.macro.inside.another.macro.definition=No se puede poner en línea la macro dentro de la definición de otra macro
cannot.inline.usage.in.swift.code=No se puede aplicar inline al uso en el código Swift
cannot.inline.usages.inside.the.macro.substitutions=No se pueden integrar los usos dentro de las sustituciones de macro
cannot.perform.refactoring.selected.expression.has.void.type=No se puede realizar la refactorización porque la expresión seleccionada tiene un tipo void.
declaration.must.have.one.declarator.to.introduce.the.type=La declaración debe tener un declarador para introducir el tipo
dialog.message.accessed.for.address=Se accede a {0} para obtener la dirección
dialog.message.accessed.for.writing=Se está accediendo a {0} para escritura
dialog.message.can.t.copy.to.itself=No se puede copiar ''{0}'' a sí mismo
dialog.message.can.t.move.to.itself=No se puede mover ''{0}'' a sí mismo
dialog.message.can.t.refactor.with.variable.arguments=No se puede refactorizar un {0} con argumentos variables
dialog.message.cannot.extract.there.are.multiple.exit.points.in.selected.code.fragment=No se puede extraer {0}.\nHay múltiples puntos de salida en el fragmento de código seleccionado.
dialog.message.cannot.find.method.function=No se puede encontrar el método/función
dialog.message.cannot.inline.blocks=No se pueden insertar bloques en línea
dialog.message.cannot.inline.methods.with.return.statements.interrupting.execution.flow=No se pueden integrar en línea métodos con instrucciones return que interrumpan el flujo de ejecución
dialog.message.cannot.inline.parameters.blocks=No se pueden insertar inline los parámetros de los bloques
dialog.message.cannot.inline.parameters.lambdas=No se pueden aplicar inline los parámetros de las lambdas
dialog.message.cannot.inline.protocol.method=No se puede insertar en línea un método de protocolo
dialog.message.cannot.inline.with.empty.body=No se puede inlinear un {0} con un cuerpo vacío
dialog.message.cant.refactor.operators=No se pueden refactorizar las funciones de operador de C++
dialog.message.containing.class.invalid=La clase contenedora "{0}" no es válida
dialog.message.containing.class.outside.project=La clase contenedora "{0}" está fuera del proyecto
dialog.message.directory.already.exists.at=El directorio ya existe en ''{0}''
dialog.message.do.you.want.to.proceed.refactoring=¿Continuar con la refactorización?
dialog.message.do.you.want.to.refactor.base.s=¿Desea refactorizar {0} base?
dialog.message.elements.to=Elementos para {0}
dialog.message.file.already.exists=El archivo ya existe
dialog.message.file.already.exists.at=El archivo ya existe en ''{0}''
dialog.message.interface.was.not.implemented=La interfaz {0} no se ha implementado
dialog.message.lambdas.cant.extract.dependent.types=No se pueden extraer expresiones con tipos dependientes a un parámetro lambda
dialog.message.lambdas.cant.extract.functional.type=No se pueden extraer expresiones de tipo funcional a un parámetro lambda
dialog.message.lambdas.cant.extract.initializer.list=No se puede extraer la lista de inicializadores al parámetro lambda
dialog.message.lambdas.not.supported=Las lambdas no son compatibles con el estándar de lenguaje actual
dialog.message.must.have.initializer={0} debe tener un inicializador
dialog.message.name.invalid=El nombre de {0} no es válido
dialog.message.no.inheritors.are.selected=No se han seleccionado herederos
dialog.message.no.selector.parts.for=No hay partes de selector para {0}
dialog.message.overrides.in.choice.which.out.project={0} sobrescribe {1} en {2}{3, choice, 0#, que está fuera del proyecto|1#}.
dialog.message.paramer.default.value.invalid=''{0}'' no es una expresión
dialog.message.parameter.name.invalid=El nombre del parámetro ''{0}'' no es válido
dialog.message.return.type.invalid=El tipo de retorno de {0} no es válido
dialog.message.selected.statements.should.be.inside.function.choice.or.method=Las sentencias seleccionadas deben estar dentro de una función{0, choice, 0# o método|1#}
dialog.message.selector.part.invalid=La parte del selector ''{0}'' no es válida
dialog.message.several.call.sites.with.different.parameter.initializers=Hay varios puntos de llamada con diferentes inicializadores de parámetros
dialog.message.there.are.no.calls.in.project=No hay llamadas de {0} en el proyecto
dialog.message.there.are.no.usages=No hay usos de {0}
dialog.message.variable.must.be.const=La variable "{0}" debe ser constante
dialog.title.choose.containing.class=Seleccionar clase contenedora
dialog.title.extract.block.parameter=Extraer parámetro de bloque
dialog.title.extract.function=Extraer función
dialog.title.extract.lambda.parameter=Extraer parámetro lambda
dialog.title.extract.method=Extraer método
dialog.title.inline=Insertar {0}
element.has.inheritor={0} tiene {1, choice, 0#métodos|1#funciones} herederos
element.inherits.method={0} hereda un método de {1}
element.is.accessed.for.writing=Se accede a {0} para escritura
element.is.written.in.the.block={0} está escrito en el bloque
escalate.visibility.current.visibility.column=Visibilidad actual
escalate.visibility.member.column=Miembro
escalate.visibility.required.visibility.column=Visibilidad requerida
extract.dialog.button.extract=Extra&er
extract.invalid.name.for.class.type.error=El nombre de {0} no es válido
file.0.already.exists.in.the.project=El archivo ''{0}'' ya existe en el proyecto
label.declaration.place=Lugar de la declaración:
message.never.used={0} no se utiliza nunca
namespace.qualifier.should.be.resolved.to.the.class=El calificador de espacio de nombres debe resolverse en la clase
progress.title.inplace.rename.appending.additional.elements=Añadiendo elementos adicionales
progress.title.inplace.rename.preparing=Preparando el cambio de nombre
property.inplace.introducer.label.semantics=Semántica
push.down.inheritor.column=Heredero
question.inline.usage=¿Integrar {0} uso{1, choice, 0#|1#s} de {2}?
refactoring.change.signature.target.symbols.panel=Destinos:
refactoring.extract.category.title=Extraer categoría
refactoring.extract.subclass.title=Extraer subclase
refactoring.extract.super.protocol.title=Extraer superprotocolo
refactoring.introduce.block.expression.represent.error=El bloque seleccionado debe representar {0}
refactoring.introduce.constant.auto.declaration=Declarar &auto
refactoring.introduce.constant.constexpr.declaration=Declarar &constexpr
refactoring.introduce.constant.name=Introducir constante
refactoring.introduce.constant.static.declaration=Declarar &estático
refactoring.introduce.define.name=Introducir Define
refactoring.introduce.expressions.choose.dialog.title=Expresiones
refactoring.introduce.instance.variable.name=Introducir variable de instancia
refactoring.introduce.ivar.name=Introducir Ivar
refactoring.introduce.parameter.name=Introducir parámetro
refactoring.introduce.property.name=Introducir propiedad
refactoring.introduce.put.to.header=Poner en el encabezado(&H)
refactoring.introduce.typedef.name=Introducir typedef
refactoring.introduce.variable.name=Introducir variable
refactoring.introducer.declare.auto=Declarar &auto
refactoring.introducer.declare.const=Declarar &const
refactoring.ivar.inplace.introducer.declare.interface=Declarar en la &interfaz
refactoring.ivar.inplace.introducer.generate.property=Generar &propiedad
refactoring.move.cant.find.symbol=No se puede encontrar el símbolo de la clase seleccionada
refactoring.move.caret.position=El cursor debe estar situado dentro de una clase
refactoring.move.escalate.visibility.declare.in.interface=Declarar en la interfaz
refactoring.move.file.has.no.members=El archivo "{0}" no tiene miembros para mover
refactoring.move.members.error.class.name.invalid=El nombre de la clase no es válido
refactoring.move.members.error.no.target.class.selected=No se ha seleccionado ninguna clase de destino
refactoring.move.members.error.not.in.project.sources={0} no se encuentra dentro del proyecto
refactoring.move.members.error.the.same.source.and.target=Las clases de origen y destino deben ser diferentes
refactoring.move.members.message.target.does.not.exist=La clase de destino "{0}" aún no existe.
refactoring.move.members.ok.button.text=&Mover
refactoring.move.namespace.has.no.members=El espacio de nombres "{0}" no tiene miembros para mover
refactoring.move.no.members.are.selected.error=No se han seleccionado miembros
refactoring.move.pull.up.ok.button.text=S&ubir
refactoring.move.push.down.ok.button.text=Emp&ujar
refactoring.parameter.introducer.refactor.super.method=Refactorizar &súper {0}
refactoring.property.introducer.generate.instance.variable=Generar variable de &instancia
refactoring.property.introducer.generate.synthesize=Generar @&synthesize
refactoring.property.introducer.make.readonly=Hacer de solo &lectura
refactoring.property.introducer.put.to.private.category=Colocar en la categoría &privada
refactoring.rename=&Renombrar {0}
refactoring.rename.0.already.exists.in.1={0} ya existe en {1}
refactoring.rename.0.already.exists.in.the.scope={0} ya existe en el ámbito
refactoring.rename.associated.file=Renombrar archivo asociado
refactoring.rename.class.aliases=&Renombrar alias de clase
refactoring.rename.command.name=Renombrar
refactoring.symbol.has.no.members.to.move={0} no tiene miembros para mover
rename.multiple.macro.usages.message={0} tiene varios usos con diferentes asignaciones para "{1}". El cambio de nombre puede romper el código. ¿Desea continuar?
rename.non.code.usages.message={0} {0, choice, 1#uso encontrado|2#usos encontrados} en comentarios y archivos que no son de código.\n¿Desea {0, choice, 1#renombrarlo|2#renombrarlos}?
rename.reference.command.name=Renombrar referencia
rename.reference.invalid.dialog.button.yes=Continuar editando
rename.reference.invalid.dialog.title=Identificador no válido
selected.expression.cannot.be.a.constant.initializer=La expresión seleccionada no puede ser un inicializador de constante
selected.expression.should.be.inside.a.block.statement=La expresión seleccionada debe estar dentro de una sentencia de bloque
selected.expression.should.be.inside.a.function.or.method=La expresión seleccionada debe estar dentro de una función o un método
selected.expression.should.be.inside.an.instance.method=La expresión seleccionada debe estar dentro de un método de instancia
selected.expression.should.be.inside.an.instance.method1=La expresión seleccionada debe estar dentro de un método de instancia
several.definitions.of.0=Hay varias definiciones de {0}
text.parameter.initializer.not.available.in=El inicializador de parámetros no está disponible en {0}: {1}.
the.address.of.is.taken=La dirección de {0} está ocupada
the.type.is.empty=El tipo está vacío
there.are.several.definitions.of=Existen varias definiciones de {0}
there.are.usages.in.other.blocks=Hay usos en otros bloques
top.level.namespace.placeholder=Espacio de nombres de nivel superior
trying.to.rename.0.to.existing.file.name.1=Intentando renombrar {0} al nombre de archivo existente {1}
