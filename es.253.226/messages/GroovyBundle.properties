0.expressions.on.trait.fields.properties.are.not.supported.in.traits=No se admiten expresiones {0} en campos/propiedades de traits dentro de los traits
0.is.deprecated=''{0}'' está en desuso
Cannot.perform.undo.operation=No se puede realizar la operación de deshacer
Constructor=Constructor
Equals=Igual
Getter=Getter
Inner.methods.are.not.supported=No se admiten métodos internos
Setter=Setter
Undo.disable=Deshacer deshabilitado
abstract.methods.must.not.have.body=Los métodos abstractos no deben tener cuerpo
abstract.visibility.presentation=Abstracto
action.ConvertGroovyToJava.description=Convertir archivos Groovy a Java
action.ConvertGroovyToJava.text=Convertir a Java
action.ConvertToCompileStatic.description=Convertir archivos Groovy a @CompileStatic
action.ConvertToCompileStatic.text=Convertir a @CompileStatic
action.DumpGroovyControlFlowAction.text=Volcar flujo de control de Groovy
action.ExcludeFromStubGeneration.description=No generar stubs de Java para este archivo Groovy al compilar
action.ExcludeFromStubGeneration.text=Excluir de la generación de stubs
action.Gant.NewScript.description=Crea un nuevo script de Gant
action.Gant.NewScript.text=Script de Gant
action.Groovy.CheckResources.Make.description=Ejecutar el compilador incremental para archivos Groovy en las raíces de recursos para comprobar si hay problemas de compilación
action.Groovy.CheckResources.Make.text=Compilar recursos(_B)
action.Groovy.CheckResources.Rebuild.description=Ejecutar el compilador para todos los archivos Groovy en las raíces de recursos para comprobar si hay problemas de compilación
action.Groovy.CheckResources.Rebuild.text=Reconstruir recursos(_R)
action.Groovy.Console.description=Iniciar la consola Groovy
action.Groovy.Console.text=Consola de Groovy
action.Groovy.NewClass.description=Crear nueva clase Groovy
action.Groovy.NewClass.text=Clase Groovy
action.Groovy.NewScript.description=Crea un nuevo script Groovy
action.Groovy.NewScript.text=Script de Groovy
action.build.module.restart.description=Compilar el módulo ''{0}'' y reiniciar
action.build.restart.text=Compilar y reiniciar
action.collapse.all.description=Contraer todo
action.collapse.all.text=Contraer todo
action.convert.lambda.to.closure=Convertir lambda a clausura
action.expand.all.description=Expandir todo
action.expand.all.text=Expandir todo
action.org.jetbrains.plugins.groovy.actions.generate.accessors.GroovyGenerateGetterAction.description=Genera un getter
action.org.jetbrains.plugins.groovy.actions.generate.accessors.GroovyGenerateGetterAction.text=Getter
action.org.jetbrains.plugins.groovy.actions.generate.accessors.GroovyGenerateGetterSetterAction.description=Genera getter
action.org.jetbrains.plugins.groovy.actions.generate.accessors.GroovyGenerateGetterSetterAction.text=Getter y setter
action.org.jetbrains.plugins.groovy.actions.generate.accessors.GroovyGenerateSetterAction.description=Genera un setter
action.org.jetbrains.plugins.groovy.actions.generate.accessors.GroovyGenerateSetterAction.text=Setter
action.org.jetbrains.plugins.groovy.actions.generate.constructors.GroovyGenerateConstructorAction.description=Genera un constructor
action.org.jetbrains.plugins.groovy.actions.generate.constructors.GroovyGenerateConstructorAction.text=Constructor
action.org.jetbrains.plugins.groovy.actions.generate.equals.GroovyGenerateEqualsAction.description=La acción genera equals y hashCode ahora
action.org.jetbrains.plugins.groovy.actions.generate.equals.GroovyGenerateEqualsAction.text=Equals() y hashCode()
action.org.jetbrains.plugins.groovy.actions.generate.missing.GroovyGenerateMethodMissingAction.description=La acción genera propertyMissing()
action.org.jetbrains.plugins.groovy.actions.generate.missing.GroovyGenerateMethodMissingAction.text=methodMissing()
action.org.jetbrains.plugins.groovy.actions.generate.missing.GroovyGeneratePropertyMissingAction.description=La acción genera propertyMissing()
action.org.jetbrains.plugins.groovy.actions.generate.missing.GroovyGeneratePropertyMissingAction.text=propertyMissing()
action.org.jetbrains.plugins.groovy.actions.generate.tostring.GroovyGenerateToStringAction.description=Generar método toString()
action.org.jetbrains.plugins.groovy.actions.generate.tostring.GroovyGenerateToStringAction.text=toString()(_S)
action.remove.dynamic.member.description=Eliminar miembro dinámico
action.remove.dynamic.member.text=Eliminar
add.class.to.extends.family.name=Implementar
add.compilestatic=Añadir @CompileStatic
add.dynamic.element=Añadir elemento dinámico
add.dynamic.method=Agregar método dinámico
add.dynamic.method.0=Añadir método dinámico ''{0}''
add.dynamic.property=Agregar propiedad dinámica ''{0}''
add.method=Añadir el método ''{0}()'' a la clase ''{1}''
add.method.family=Añadir método
add.modifier.sealed=Añadir modificador 'sealed'
add.parenthesis.to.lambda.parameter.list=Agregar paréntesis a la lista de parámetros
add.return.type=Añadir tipo de retorno
add.return.type.to.method.declaration=Añadir tipo de retorno a la declaración del método
add.to.resources=Agregar a recursos
add.type.customizer.to.resources=Añadir script de personalización de tipos a los recursos
ambiguous.code.block=Bloque de código ambiguo
annotation.collector.cannot.have.attributes=El tipo de anotación anotado con @AnnotationCollector no puede tener atributos
annotation.field.can.only.be.used.within.a.script=La anotación @Field solo se puede utilizar dentro de un script
annotation.field.can.only.be.used.within.a.script.body=La anotación @Field solo se puede utilizar dentro del cuerpo de un script
annotation.field.should.have.type.declaration=El campo en la anotación debe tener una declaración de tipo
annotation.type.cannot.be.inner=El tipo de anotación no puede ser interno
annotation.types.may.not.have.extends.clause=Los tipos de anotación no pueden tener una cláusula 'extends'
annotation.types.may.not.have.implements.clause=Los tipos de anotación no pueden tener la cláusula 'implements'
anonymous.class=Clase anónima
anonymous.class.cannot.have.abstract.method=La clase anónima no puede tener un método abstracto
anonymous.class.derived.from.0=Clase anónima derivada de {0}
anonymous.classes.cannot.be.created.from.traits=Las clases anónimas de traits están disponibles desde Groovy 2.5.2
are.you.sure.to.delete.dynamic.property=¿Seguro que desea eliminar ''{0}''?
are.you.sure.to.delete.elements=¿Está seguro de que desea eliminar ''{0}'' elementos?
at.interface.0.does.not.contain.attribute=@interface ''{0}'' no contiene el atributo ''{1}''
attribute.descriptor.abstract.class=Clase abstracta
attribute.descriptor.annotation.attribute.name=Nombre del atributo de anotación
attribute.descriptor.annotation.name=Nombre de la anotación
attribute.descriptor.annotations=Anotaciones
attribute.descriptor.anonymous.class=Clase anónima
attribute.descriptor.bad.character=Carácter no válido
attribute.descriptor.block.comment=Comentario de bloque
attribute.descriptor.braces=Llaves
attribute.descriptor.braces.and.operators=Llaves y operadores
attribute.descriptor.brackets=Corchetes
attribute.descriptor.class=Clase
attribute.descriptor.classes.and.interfaces=Clases e interfaces
attribute.descriptor.closure.expression.braces.and.arrow=Llaves y flecha de la expresión de clausura
attribute.descriptor.comments=Comentarios
attribute.descriptor.constructor.call=Llamada al constructor
attribute.descriptor.constructor.declaration=Declaración de constructor
attribute.descriptor.enum=Enumeración
attribute.descriptor.fields=Campos
attribute.descriptor.groovydoc=Groovydoc
attribute.descriptor.groovydoc.tag=Etiqueta
attribute.descriptor.groovydoc.text=Texto
attribute.descriptor.gstring=GString
attribute.descriptor.instance.field=Campo de instancia
attribute.descriptor.instance.method.call=Llamada a método de instancia
attribute.descriptor.instance.property.reference=Referencia de propiedad de instancia
attribute.descriptor.interface=Interfaz
attribute.descriptor.invalid.string.escape=Secuencia de escape de cadena no válida
attribute.descriptor.keyword=Palabra clave
attribute.descriptor.label=Etiqueta
attribute.descriptor.lambda.expression.braces.and.arrow=Llaves y flecha de expresión lambda
attribute.descriptor.line.comment=Comentario de línea
attribute.descriptor.list.map.to.object.conversion=Conversión de lista/mapa a objeto
attribute.descriptor.local.variable=Variable local
attribute.descriptor.map.key.named.argument=Clave de mapa/Argumento con nombre
attribute.descriptor.method.declaration=Declaración de método
attribute.descriptor.methods=Métodos
attribute.descriptor.number=Número
attribute.descriptor.operator.sign=Signo del operador
attribute.descriptor.parameter=Parámetro
attribute.descriptor.parentheses=Paréntesis
attribute.descriptor.reassigned.local.variable=Variable local reasignada
attribute.descriptor.reassigned.parameter=Parámetro reasignado
attribute.descriptor.references=Referencias
attribute.descriptor.static.field=Campo estático
attribute.descriptor.static.method.call=Llamada a método estático
attribute.descriptor.static.property.reference=Referencia a propiedad estática
attribute.descriptor.string=Cadena
attribute.descriptor.strings=Cadenas
attribute.descriptor.trait=Rasgo
attribute.descriptor.type.parameter=Parámetro de tipo
attribute.descriptor.unresolved.reference=Referencia no resuelta
attribute.descriptor.valid.string.escape=Escape de cadena válido
attribute.descriptor.variables.and.parameters=Variables y parámetros
attribute.name.expected=Se esperaba un nombre de atributo
base.script.annotation.is.allowed.only.inside.scripts=La anotación @BaseScript solo puede usarse dentro de un script
break.outside.loop=La sentencia break con etiquetas con nombre solo se permite dentro de bucles
break.outside.loop.or.switch=La sentencia 'break' solo se permite dentro de bucles o sentencias switch con estilo de dos puntos
builder.annotation.not.support.super.for.simple.strategy=El atributo de anotación 'includeSuperProperties' no es compatible con groovy.transform.builder.SimpleStrategy
call.can.throw.npe=La cadena de llamadas puede lanzar una NullPointerException
call.without.parentheses.are.supported.since.groovy.3=Se admiten las llamadas sin paréntesis en la lista de argumentos desde Groovy 3.0
cannot.access=El acceso a ''{0}'' excede sus derechos de acceso
cannot.apply.constructor=El constructor ''{0}'' en ''{1}'' no se puede aplicar a ''{2}''
cannot.apply.default.constructor=No se puede aplicar el constructor predeterminado para la clase ''{0}''
cannot.apply.method.or.closure='{0}'' no se puede aplicar a ''{1}'
cannot.apply.method1='{0}'' en ''{1}'' no se puede aplicar a ''{2}'
cannot.assign=No se puede asignar ''{0}'' a ''{1}''
cannot.assign.a.value.to.final.field.0=No se puede asignar un valor al campo final ''{0}''
cannot.assign.a.value.to.final.parameter.0=No se puede asignar un valor al parámetro final ''{0}''
cannot.assign.string.to.enum.0=No se puede asignar una cadena al enumerado ''{0}''
cannot.cast=No se puede convertir ''{0}'' a ''{1}''
cannot.create.class=No se puede crear la clase
cannot.create.class.error.text=No se puede crear la clase ''{0}'': {1}
cannot.create.class.error.title=No se puede crear la clase
cannot.find.enum.constant.0.in.enum.1=No se puede encontrar la constante de enumeración ''{0}'' en la enumeración ''{1}''
cannot.infer.argument.types=No se pueden inferir los tipos de argumento
cannot.instantiate.abstract.class=No se puede instanciar la clase abstracta ''{0}''
cannot.instantiate.interface=No se puede instanciar la interfaz ''{0}''
cannot.reference.non.static=No se puede hacer referencia al símbolo no estático ''{0}'' desde un contexto estático
cannot.resolve=No se puede resolver el símbolo ''{0}''
cannot.return.from.constructor=No se puede devolver un objeto desde el constructor.
cannot.return.from.void.method=No se puede devolver un objeto desde un método que devuelve 'void'
cannot.return.type=No se puede devolver ''{0}'' desde un método que devuelve ''{1}''
catch.statement.parameter.type.should.be.a.subclass.of.throwable=El tipo de parámetro de la sentencia catch debe ser una subclase de Throwable
change.base.method.label=Cambiar método base
change.implements.and.extends.classes=Normalizar las listas extends e implements
change.lvalue.type=Cambiar el tipo de la variable ''{0}'' a ''{1}''
change.modifier=Hacer ''{0}'' {1}
change.modifier.family.name=Cambiar modificadores
change.modifier.not=Hacer que ''{0}'' no sea {1}
change.signature.default.initializer.column=Inicializador predeterminado
change.signature.type.column=Tipo
change.usages.label=Cambiar usos
checkbox.delegate.via.overloading.method=Delegar mediante un método de sobrecarga
checkbox.ignore.conditional.operators=Ignorar operadores condicionales
checkbox.ignore.double.checked.locking.on.volatile.fields=Ignorar el bloqueo de doble comprobación en campos volátiles
checkbox.ignore.obscure.operators=Ignorar operadores poco comunes
checkbox.inspect.anonymous.closures=Inspeccionar clausuras anónimas
checkbox.inspect.gradle.files=Inspeccionar archivos de Gradle
checkbox.only.warn.if.loop.empty=Solo advertir si el bucle está vacío
checkbox.report.unmatched.null=Informar de 'null' no coincidentes
class.definition.is.not.expected.here=No se espera una definición de clase aquí
class.is.not.annotation=''{0}'' no es una anotación
closure=Clausura
closure.is.accessed.outside.of.groovy=Se accede al campo <b>{0}</b> fuera de Groovy
closure.is.too.complex.to.analyze=La clausura es demasiado compleja para analizar.\nNo se infieren los tipos de las variables locales.
closure.used.as.variable=La clausura se pasa como argumento. La refactorización puede romper la semántica.
code.style.groovydoc.enable=Habilitar el formateo de GroovyDoc
code.style.groovydoc.tab.name=GroovyDoc
code.style.group.list.map.literals=Literales de lista y mapa
code.style.option.after.assert.separator=Después del separador de 'assert'
code.style.option.align.multiline.named.arguments=Alinear argumentos con nombre multilínea
code.style.option.align.when.multiple=Alinear si hay varios
code.style.option.before.assert.separator=Antes del separador 'assert'
code.style.option.before.record.parameter.list=Antes de la lista de parámetros del record
code.style.option.closure.left.brace.in.method.calls=Llave izquierda de clausura en llamadas a métodos
code.style.option.gstring.injection.braces=Llaves de inyección de GString
code.style.option.import.annotations=Importar anotaciones
code.style.option.in.named.argument.after.colon=En el argumento con nombre después de ':'
code.style.option.in.named.argument.before.colon=En el argumento con nombre antes de ':'
code.style.option.list.maps.literals=Literales de listas y mapas
code.style.option.regexp.expression=Expresión regular (==~, =~)
code.style.option.relational.operators=Operadores relacionales (<, >, <=, >=, <=>)
code.style.option.simple.lambdas.closures.in.one.line=Lambdas/clausuras simples en una línea
code.style.option.tuple.assignment.expression=Expresión de asignación de tupla
code.style.option.unary.operators=Operadores unarios (!, -, +, ++, --, *)
code.style.option.use.flying.geese.braces=Colocar las llaves de cierre en una sola línea
code.style.option.wrap.after.dot=Ajustar después del punto
collection.literal.contains.named.argument.and.expression.items=El literal de colección contiene argumentos con nombre y de expresión al mismo tiempo
command.name.add.dynamic.member=Añadir miembro dinámico
comments.count.as.content=Los comentarios cuentan como contenido
configurable.GantConfigurable.display.name=Gant
configurable.GroovyCompilerConfigurable.display.name=Compilador Groovy
configurable.greclipse.border.title=Opciones de Groovy-Eclipse
configurable.greclipse.command.java.agent.class.workaround='-javaAgentClass' impide el uso de las opciones de VM predefinidas
configurable.greclipse.command.line.params.label=Parámetros de la línea de comandos:
configurable.greclipse.debug.checkbox=Generar información de depuración
configurable.greclipse.path.chooser.description=Seleccione la ruta a groovy-eclipse-batch-*.jar con la versión que coincida con su distribución de Groovy
configurable.greclipse.path.label=Ruta al archivo jar groovy-eclipse-batch:
configurable.greclipse.vm.options.comment=Si se especifica, sobrescribe las opciones de VM del proceso de compilación compartidas y locales del usuario
configurable.greclipse.vm.options.label=Opciones de VM:
configurable.hotswap.checkbox=Habilitar agente de hot-swap para el código Groovy
configurable.hotswap.checkbox.description=Puede causar problemas de serialización en la aplicación depurada
configure.groovy.library=Configurar Groovy SDK…
constructor.cannot.have.static.modifier=El constructor no puede ser static
constructors.are.not.allowed.in.anonymous.class=No se permiten constructores en clases anónimas
constructors.are.not.allowed.in.interface=Los constructores no están permitidos en la interfaz
constructors.cannot.have.return.type=No se permite el elemento de tipo de retorno en el constructor
continue.outside.loop=La sentencia continue solo se permite dentro de bucles
conversion.closure.not.allowed.in.non.groovy.files=No se permite la refactorización de closures que tengan apariciones en archivos que no sean Groovy:
conversion.method.not.allowed.in.non.groovy.files=No se permite la refactorización para métodos que tengan apariciones en archivos que no sean Groovy:
convert.cannot.itself=La refactorización no está disponible para el propio parámetro de mapa
convert.param.to.map.entry=Convertir parámetro en entrada de mapa
convert.parameter.to.map.entry.title=Convertir parámetro en entrada de mapa
create.annotation.text=Crear anotación ''{0}''
create.class.family.name=Crear clase
create.class.text=Crear clase ''{0}''
create.directory.command=Crear directorio
create.enum=Crear enum ''{0}''
create.field.from.usage=Crear campo ''{0}''
create.field.from.usage.family.name=Crear campo a partir del uso
create.instance.of.built-in.type=Instanciación de un tipo integrado
create.interface.text=Crear interfaz ''{0}''
create.method.from.usage=Crear método ''{0}''
create.method.from.usage.family.name=Crear método a partir del uso
create.parameter.from.usage=Crear parámetro ''{0}''
create.parameter.from.usage.family.name=Crear parámetro a partir del uso
create.record.text=Crear registro ''{0}''
create.trait=Crear rasgo ''{0}''
create.variable.from.usage=Crear variable ''{0}''
create.variable.from.usage.family.name=Crear variable a partir del uso
cyclic.inheritance.involving.0=Herencia cíclica que involucra a ''{0}''
debug.option=Habilitar seguimiento de pila de &depuración
declare.explicit.implementations.of.trait=Declarar implementaciones explícitas del trait
declared.type.0.extends.1.which.is.circular.inheritance=El tipo declarado ''{0}'' extiende ''{1}'', lo cual es una herencia circular
declared.type.0.have.to.extend.script=El tipo declarado ''{0}'' no extiende la clase ''groovy.lang.Script''
def.visibility.presentation=Predeterminado
default.initializers.are.not.allowed.in.abstract.method=No se permiten inicializadores predeterminados en métodos abstractos
default.modifier.in.old.versions=El modificador 'default' está disponible en Groovy 3.0 o versiones posteriores
delegate.annotation.is.only.for.methods.without.arguments=La anotación @Delegate no se puede aplicar a métodos con argumentos
destination.package=Paquete de destino:
dialog.create.class.package.chooser.title=Seleccionar paquete de destino
dialog.message.gant.not.configured=Gant no está configurado
dialog.title.no.jdk.specified.error=No se ha especificado el SDK de Groovy
dialog.title.no.jdk.specified.prompt=¿Desea crear un proyecto sin ningún SDK asignado?
dialog.title.no.jdk.specified.title=SDK de Groovy no especificado
dialog.title.refactoring.unavailable.in.current.scope=Refactorización no disponible en el ámbito actual
dialog.title.select.groovy.sdk=Seleccionar SDK de Groovy
dialog.title.specify.groovy.sdk=Especificar la ubicación del SDK de Groovy
dialog.title.validation.directory.you.specified.does.not.contain.groovy.sdk.do.you.want.to.create.project.with.this.configuration=Ha especificado un directorio que no contiene el SDK de Groovy. ¿Desea crear el proyecto con esta configuración?
dialog.title.validation.invalid.sdk.specified.error=SDK de Groovy especificado no válido
dialog.title.validation.invalid.sdk.specified.title=SDK de Groovy especificado no válido
dialog.title.validation.path.does.not.contain.groovy.sdk=La ruta no contiene el SDK de Groovy
dialog.title.validation.path.should.not.be.empty=La ruta no debe estar vacía
do.you.want.to.change.method.return.type=¿Desea cambiar el tipo de retorno del método ''{0}''?
do.you.want.to.change.type.of.parameter.in.method=¿Desea cambiar el tipo del parámetro ''{0}'' en el método ''{1}''?
do.you.want.to.change.variable.type=¿Desea cambiar el tipo de ''{0}''?
doc.end.expected=Se esperaba '*/'
documentation.cannot.infer.type.label=No se puede inferir el tipo
documentation.gdk.label=GDK
documentation.inferred.type.label=Tipo inferido
duplicate.attribute=Atributo duplicado
duplicate.class=La clase ''{0}'' ya existe en ''{1}''
duplicate.element.in.the.map=Elemento duplicado ''{0}'' en el mapa
duplicate.inner.class=Clase duplicada: ''{0}''
duplicate.modifier=Modificador duplicado ''{0}''
duplicated.named.parameter=Se encontró un parámetro con nombre duplicado ''{0}''
duplicating.named.parameter=El parámetro con nombre duplicado ''{0}'' aparece en los parámetros: {1}
dynamic.dialog.class.label=&Clase:
dynamic.dialog.static.checkbox=&Estático
dynamic.dialog.type.label=&Tipo:
dynamic.element=Elemento dinámico
dynamic.element.deletion=Eliminación de elementos dinámicos
dynamic.members.column.name.element=Elemento dinámico
dynamic.members.column.name.type=Tipo
dynamic.method.property.type=Tipo de propiedad (&T):
dynamic.method.return.type=Tipo de re&torno:
dynamic.name=Nombre
dynamic.properties.table.name=Argumentos del método
dynamic.property.deletion=Eliminación de propiedad dinámica
dynamic.tool.window.id=Miembros dinámicos
dynamic.type=Tipo
ellipsis.type.is.not.allowed.here=No se permite el tipo de elipsis aquí
enums.may.not.have.extends.clause=Las enumeraciones no pueden tener la cláusula 'extends'
equals.between.inconvertible.types.tooltip=<code>{0}</code> entre objetos de tipos no convertibles ''{1}'' y ''{2}''
exception.0.has.already.been.caught=La excepción ''{0}'' ya se ha capturado
expected.0.to.be.inline.constant=Se esperaba que ''{0}'' fuera una constante inline
expected.type.0=Se esperaba ''{0}'', se encontró ''{1}''
explicit.constructors.are.not.allowed.in.immutable.class=No se permiten constructores explícitos en las clases @Immutable
explicit.includes.and.excludes=Solo debe proporcionarse uno de 'includes' y 'excludes'
expression.expected=Se esperaba una expresión
expression.type.no.expression=No se encontró ninguna expresión
expression.type.unknown=<desconocido>
extract.closure.command.name=Extraer clausura
field.already.defined=El campo ''{0}'' ya está definido
field.already.exists=El campo <b>{0}</b> ya existe
field.is.used.in.argument.label=El campo <b>{0}</b> se utiliza en la etiqueta del argumento
field.should.be.immutable=El campo ''{0}'' debería tener un tipo inmutable o estar declarado como tal con @ImmutableOptions
file.exists=El archivo ''{0}'' ya existe en el directorio ''{1}''
file.template.group.title.groovy=Groovy
filetype.dgm.description=Archivo descriptor de módulo de extensión de Groovy
filetype.dgm.display.name=DGM
filetype.gdsl.description=Configuración de IntelliJ Groovy DSL
filetype.gdsl.display.name=Groovy DSL
filetype.logback.description=Configuración de Groovy Logback DSL
filetype.logback.display.name=Groovy Logback DSL
final.class.cannot.be.extended=No se puede extender una clase final
final.visibility.presentation=final
find.method.ro.closure.usages=Buscando usos de la clausura envolvente en los archivos del proyecto
find.method.ro.method.usages=Buscando usos del método envolvente en los archivos del proyecto
find.usages.method.0.of.class.1={0} de {1}
fix.class=Corregir clase {0}
fix.package.name=Corregir nombre del paquete
framework.0.home.label=Directorio home de {0}:
framework.0.library=Biblioteca {0}
framework.0.library.version.1=Biblioteca {0} de la versión {1}
framework.0.sdk.chooser.description=Seleccione un directorio que contenga la distribución de {0}
framework.0.sdk.chooser.error.message=Parece que la distribución {0} en la ruta especificada está dañada. No se puede determinar la versión.
framework.0.sdk.chooser.error.title=Error al crear la biblioteca
framework.0.sdk.chooser.title=SDK de {0}
framework.gant=Gant
gdsl.error.notification.title=Error de ejecución del script DSL
gdsl.investigate.link.label=Haga clic aquí para investigar
generate.equals.and.hashcode.already.defined.title=Equals() y hashCode() ya definidos
generate.equals.and.hashcode.already.defined.warning=Equals() y hashCode() ya están definidos
generate.equals.and.hashcode.already.defined.warning.anonymous=Equals() y hashCode() ya están definidos
generate.equals.compare.arrays.comment=// Probablemente incorrecto: comparando arrays Object[] con Arrays.equals
generate.equals.compare.nested.arrays.comment=// Comparar arreglos anidados - valores de {0} aquí
generate.method.missing.already.defined.title=methodMissing() ya definido
generate.method.missing.already.defined.warning=MethodMissing() ya está definido
generate.property.missing.already.defined.title=PropertyMissing() ya está definido
generate.property.missing.already.defined.warning=PropertyMissing() ya está definido
generated.stub.exclude.link.label=Excluir de la generación de stubs
generated.stub.message=Este stub se genera para la clase Groovy para permitir la compilación cruzada Groovy-Java
generated.stub.navigate.link.label=Ir a la clase Groovy
getter.0.clashes.with.getter.1=Se produjo un conflicto: ''{0}'' con ''{1}''
getter.kind.gdk.method.0=Método GDK {0}
getter.kind.getter.0=Getter {0}
getter.kind.method.0=Método {0}
ginq.code.style.group.ginq.clauses=Cláusulas GINQ
ginq.code.style.option.indent.having.clauses=Indentar la cláusula 'having'
ginq.code.style.option.indent.on.clauses=Indentar cláusula 'on'
ginq.code.style.option.space.after.keyword=Espacio después de las palabras clave
ginq.code.style.option.wrap.having.clauses=Ajustar cláusula 'having'
ginq.code.style.option.wrap.on.clauses=Ajustar cláusula 'on'
ginq.error.message.0.must.be.after.1='{0}'' debe estar después de ''{1}'
ginq.error.message.0.must.be.before.1='{0}'' debe estar antes de ''{1}'
ginq.error.message.boolean.condition.expected=Se esperaba una condición booleana
ginq.error.message.container.expected=Se esperaba GINQ, Iterable, Stream o array
ginq.error.message.expected.a.boolean.expression=Se esperaba una expresión booleana
ginq.error.message.expected.alias=Nombre de alias esperado
ginq.error.message.expected.data.source=Se esperaba un origen de datos
ginq.error.message.expected.in.operator=Se esperaba '… in …'
ginq.error.message.expected.one.or.two.arguments.for.limit=Se esperan uno o dos argumentos para 'limit'
ginq.error.message.from.must.be.in.the.start.of.a.query='from' debe estar al principio de una consulta
ginq.error.message.groupby.expected.a.list.of.expressions=Se esperaba una lista de expresiones
ginq.error.message.on.is.expected.after.join=Se espera 'on' después de una cláusula de tipo 'join'
ginq.error.message.on.should.not.be.provided.after.crossjoin=No se esperaba 'on' después de 'crossjoin'
ginq.error.message.orderby.expected.a.list.of.ordering.fields=Se esperaba una lista de campos de ordenación
ginq.error.message.query.should.end.with.select=La consulta debe terminar con 'select'
ginq.error.message.query.should.start.from.from=La consulta debe comenzar con 'from'
ginq.error.message.unrecognized.query=Consulta no reconocida
gr.package.inspection.check.scripts=Comprobar scripts
grab.error.0.title=No se puede ejecutar @Grab: {0}
grab.error.ivy.missing.message=Lo sentimos, pero IDEA no puede aplicar @Grab a las dependencias sin Apache Ivy. Por favor, añada Apache Ivy a las dependencias de su módulo y vuelva a ejecutar la acción.
grab.error.ivy.missing.title=Falta Ivy
grab.family.name=Grab
grab.intention.name=Obtener los artefactos
grab.jar.count=<b>{0}</b>: {1} {1, choice, 0#jars|1#jar|2#jars}
grab.progress.title=Procesando anotaciones @Grab
grab.result.title={0} {0, choice, 0#dependencias Grape (jars) añadidas|1#dependencia Grape (jar) añadida|2#dependencias Grape (jars) añadidas}
groovy.complex.argument.label.annotator.message=Una expresión de etiqueta compleja antes de dos puntos debe estar entre paréntesis
groovy.complex.argument.label.quick.fix.message=Poner entre paréntesis la expresión
groovy.consoles.type=Consolas Groovy
groovy.debug.caption=Groovy
groovy.debug.disable.specific.methods=No entrar en clases Groovy especí&ficas
groovy.does.not.support.constructor.type.arguments=Groovy no admite argumentos de tipo de constructor
groovy.file.0=Archivo Groovy ''{0}''
groovy.file.extension.is.not.mapped.to.groovy.file.type=Los archivos *.groovy están asignados a ''{0}''.\nPuede asignarlos a Groovy en Ajustes | Tipos de archivo
groovy.library.is.not.configured.for.module=Groovy SDK no está configurado para el módulo ''{0}''
groovy.library.label=Biblioteca de Groovy:
groovy.term.annotation=Anotación
groovy.term.binding=Variable de vinculación del script
groovy.term.class=Clase
groovy.term.closure=Clausura
groovy.term.enum=Enumeración
groovy.term.expression=Expresión
groovy.term.field=Campo
groovy.term.interface=interfaz
groovy.term.label=Etiqueta
groovy.term.method=Método
groovy.term.parameter=Parámetro
groovy.term.property=Propiedad
groovy.term.record=Registro
groovy.term.trait=trait
groovy.term.type.parameter=Parámetro de tipo
groovy.term.variable=Variable local
groovy.version.0=Groovy {0}
groovy.version.bundled.0=Groovy integrado {0}
group.Groovy.CheckResources.description=Ejecutar el compilador para los archivos Groovy en las raíces de recursos para comprobar si hay problemas de compilación
group.Groovy.CheckResources.text=Recursos de Groovy(_O)
header.extract.closure=Extraer clausura
highlight.if.groovy.object.methods.overridden=Resaltar referencias de clases que sobrescriben invokeMethod(), getProperty() o setProperty()
highlight.if.missing.methods.declared=Resaltar referencias de la clase que declara missingMethod() o missingProperty()
identifier.expected=Se esperaba un identificador
identifier.or.block.expected=Se esperaba un identificador o un bloque de código
ignore.boolean.expressions=Ignorar variables no asignadas en comprobaciones booleanas
ignore.when.catch.parameter.is.named.ignore.or.ignored=Ignorar si el parámetro de catch se llama ignore o ignored
illegal.combination.of.modifiers=Combinación ilegal de modificadores
illegal.combination.of.modifiers.abstract.and.final=Combinación ilegal de los modificadores 'abstract' y 'final'
illegal.combination.of.modifiers.volatile.and.final=Combinación ilegal de los modificadores 'volatile' y 'final'
illegal.default.modifier=El modificador 'default' solo tiene sentido en los métodos de una interfaz
illegal.default.modifier.fix=Eliminar el modificador 'default'
illegal.escape.character.in.string.literal=Carácter de escape no válido en el literal de cadena
illegal.method.name=El nombre del método contiene caracteres no válidos: {0}
illegal.nonsealed.modifier.fix=Eliminar el modificador 'non-sealed'
illegal.sealed.modifier.fix=Eliminar el modificador 'sealed'
illegal.single.argument.lambda=La forma de lambda con un solo argumento solo está disponible como la parte derecha de una expresión de asignación o como argumento dentro de una llamada a un método
illegal.type.void=Tipo ilegal: 'void'
immutable.options.property.not.exist=La propiedad ''{0}'' no existe
implement.class=Implementar {0}
import.statement.cannot.have.modifiers=La sentencia import no puede tener modificadores
incorrect.number.of.values=Número de valores incorrecto. Esperado:{0} Obtenido:{1}
incorrect.variable.name=Nombre de variable incorrecto
indexed.property.is.applicable.to.properties.only=@IndexedProperty es aplicable únicamente a propiedades
infer.method.parameters.types=Añadir tipos explícitos a los parámetros
infer.method.parameters.types.for.method.declaration=Añadir tipos explícitos para todos los parámetros en la declaración del método
initializer.cannot.be.0=El inicializador no puede ser {0}
initializer.cannot.have.annotations=Los inicializadores no pueden tener anotaciones
initializers.are.forbidden.with.defaults=Los valores predeterminados están prohibidos cuando 'defaults' está deshabilitado en @TupleConstructor
initializers.are.not.allowed.in.interface=No se permiten inicializadores en la interfaz
injection.should.not.contain.line.feeds=La inyección de GString no debe contener saltos de línea.
inspection.annotations=Anotaciones
inspection.assignments=Problemas de asignación
inspection.bugs=Bugs probables
inspection.confusing=Construcciones de código potencialmente confusas
inspection.control.flow=Problemas del flujo de control
inspection.data.flow=Flujo de datos
inspection.display.name.access.to.inaccessible.element=Elemento inaccesible
inspection.display.name.access.to.static.field.locked.on.instance=Acceso a un campo estático bloqueado en datos de instancia
inspection.display.name.annotation.references.unknown.identifier=@TupleConstructor y @MapConstructor
inspection.display.name.assignability.check=Asignaciones de tipos incompatibles
inspection.display.name.assignment.can.be.operator.assignment=La asignación puede reemplazarse por una asignación con operador
inspection.display.name.assignment.to.for.loop.parameter=Asignación al parámetro del bucle 'for'
inspection.display.name.assignment.to.method.parameter=Asignación a parámetro de método
inspection.display.name.break=Sentencia 'break'
inspection.display.name.busy.wait=Espera activa
inspection.display.name.change.to.method=La invocación de operador se puede reemplazar por una llamada a un método
inspection.display.name.change.to.operator=La llamada al método se puede reemplazar por una invocación de operador
inspection.display.name.check.labeled.statement=Inspección de sentencias etiquetadas
inspection.display.name.clashing.getters=Getters en conflicto
inspection.display.name.clashing.trait.methods=Métodos de trait en conflicto
inspection.display.name.class.naming.convention=Convención de nomenclatura de clases
inspection.display.name.conditional=Expresión ternaria
inspection.display.name.conditional.can.be.conditional.call=La expresión ternaria se puede reemplazar por una llamada segura
inspection.display.name.conditional.can.be.elvis=La expresión ternaria se puede reemplazar por una expresión elvis
inspection.display.name.conditional.with.identical.branches=Expresión ternaria con ramas idénticas
inspection.display.name.constant.conditional=Expresión condicional constante
inspection.display.name.constant.if.statement=Sentencia if constante
inspection.display.name.constant.naming.convention=Convención de nomenclatura de constantes
inspection.display.name.constructor.named.arguments=Argumentos con nombre de la llamada al constructor
inspection.display.name.continue=Sentencia 'continue'
inspection.display.name.continue.or.break.from.finally.block=Continue' o 'break' desde el bloque 'finally
inspection.display.name.delegates.to=@DelegatesTo
inspection.display.name.deprecated.api.usage=Uso de API en desuso
inspection.display.name.divide.by.zero=División por cero
inspection.display.name.double.checked.locking=Bloqueo de doble comprobación
inspection.display.name.double.negation=Doble negación
inspection.display.name.duplicate.switch.branch=Caso de switch duplicado
inspection.display.name.empty.catch.block=Bloque 'catch' vacío
inspection.display.name.empty.finally.block=Bloque 'finally' vacío
inspection.display.name.empty.statement.body=Sentencia con cuerpo vacío
inspection.display.name.empty.sync.block=Bloque 'synchronized' vacío
inspection.display.name.empty.try.block=Bloque 'try' vacío
inspection.display.name.equals.between.inconvertible.types='equals()' entre objetos de tipos no convertibles
inspection.display.name.fallthrough=Fallthrough en la sentencia 'switch'
inspection.display.name.final.variable.access=Acceso a variable final
inspection.display.name.groovydoc.check=Referencia de GroovyDoc no resuelta
inspection.display.name.gstring.key=Clave de mapa GString
inspection.display.name.if.statement.with.identical.branches=Sentencia if con ramas idénticas
inspection.display.name.if.statement.with.too.many.branches=Sentencia 'if' con demasiadas ramas
inspection.display.name.implicit.null.argument=Argumento null implícito
inspection.display.name.in.argument.check=Tipos de argumentos 'in' incompatibles
inspection.display.name.incorrect.range.argument=Argumentos de rango incorrectos
inspection.display.name.infinite.loop.statement=Sentencia de bucle infinito
inspection.display.name.infinite.recursion=Recursividad infinita
inspection.display.name.instance.method.naming.convention=Convención de nomenclatura de métodos de instancia
inspection.display.name.instance.variable.naming.convention=Convención de nomenclatura de variables de instancia
inspection.display.name.java.style.properties.invocation=Acceso a propiedades al estilo Java
inspection.display.name.list.get.can.be.keyed.access=La llamada a List.get puede ser acceso por clave
inspection.display.name.list.set.can.be.keyed.access=La llamada a List.set puede ser un acceso por clave
inspection.display.name.local.variable.naming.convention=Convención de nomenclatura de variables locales
inspection.display.name.loop.statement.that.doesnt.loop=Sentencia de bucle que no itera
inspection.display.name.map.get.can.be.keyed.access=La llamada a Map.get puede ser un acceso por clave
inspection.display.name.map.put.can.be.keyed.access=La llamada a Map.put puede ser un acceso por clave
inspection.display.name.method.may.be.static=El método puede ser 'static'
inspection.display.name.method.parameter.count=Método con demasiados parámetros
inspection.display.name.method.with.more.than.three.negations=Método con más de tres negaciones
inspection.display.name.multiple.return.points.per.method=Método con múltiples puntos de retorno
inspection.display.name.negated.conditional=Expresión condicional negada
inspection.display.name.negated.if=Expresión de condición 'if' negada
inspection.display.name.nested.assignment=Asignación anidada
inspection.display.name.nested.conditional=Expresión condicional anidada
inspection.display.name.nested.switch=Sentencia switch anidada
inspection.display.name.nested.synchronized.statement=Sentencia 'synchronized' anidada
inspection.display.name.new.instance.of.singleton=Nueva instancia de una clase anotada con @groovy.lang.Singleton
inspection.display.name.no.return=Falta la sentencia return
inspection.display.name.non.extending.permitted.subclasses=Subclases permitidas que no extienden
inspection.display.name.non.short.circuit.boolean=Booleano sin cortocircuito
inspection.display.name.notify.while.not.synchronized='notify()' o 'notifyAll()' sin estar sincronizado
inspection.display.name.octal.integer=Entero octal
inspection.display.name.overly.complex.arithmetic.expression=Expresión aritmética excesivamente compleja
inspection.display.name.overly.complex.boolean.expression=Expresión booleana excesivamente compleja
inspection.display.name.overly.complex.method=Método excesivamente complejo
inspection.display.name.overly.long.method=Método excesivamente largo
inspection.display.name.overly.nested.method=Método excesivamente anidado
inspection.display.name.package.mismatch=Discrepancia de paquete
inspection.display.name.parameter.naming.convention=Convención de nomenclatura de parámetros de método
inspection.display.name.pointless.arithmetic=Expresión aritmética sin sentido
inspection.display.name.pointless.boolean=Expresión booleana sin sentido
inspection.display.name.pojo.without.compile.static=@POJO sin @CompileStatic
inspection.display.name.public.field.accessed.in.synchronized.context=Campo no privado accedido en un contexto sincronizado
inspection.display.name.reassigned.in.closure.local.var=Variable local reasignada en un closure o clase anónima
inspection.display.name.result.of.assignment.used=Resultado de la asignación utilizado
inspection.display.name.result.of.increment.or.decrement.used=Resultado de incremento o decremento utilizado
inspection.display.name.result.of.object.allocation.ignored=Resultado de la asignación de objetos ignorado
inspection.display.name.return.from.closure.can.be.implicit=La sentencia 'return' puede ser implícita
inspection.display.name.return.from.finally.block=Return' dentro de un bloque 'finally
inspection.display.name.second.unsafe.call=Segunda llamada no segura
inspection.display.name.silly.assignment=Asignación absurda
inspection.display.name.singleton.constructor=Constructores @Singleton
inspection.display.name.static.method.naming.convention=Convención de nomenclatura de métodos estáticos
inspection.display.name.static.variable.naming.convention=Convención de nomenclatura de variables estáticas
inspection.display.name.string.style.violation=Violación del estilo de cadena
inspection.display.name.switch.exhaustiveness.check=Comprobación de exhaustividad para expresiones switch
inspection.display.name.switch.statement.with.no.default=Sentencia switch sin caso 'default'
inspection.display.name.synchronization.on.non.final.field=Sincronización en un campo no final
inspection.display.name.synchronization.on.this=Sincronización sobre 'this'
inspection.display.name.synchronization.on.variable.initialized.with.literal=Sincronización en una variable inicializada con un literal
inspection.display.name.synchronized.method=Método sincronizado
inspection.display.name.system.run.finalizers.on.exit=Llamada a System.runFinalizersOnExit()
inspection.display.name.thread.stop.suspend.resume=Llamada a Thread.stop(), Thread.suspend() o Thread.resume()
inspection.display.name.throw.from.finally.block=Throw' dentro del bloque 'finally
inspection.display.name.trivial.conditional=Expresión condicional redundante
inspection.display.name.trivial.if=Sentencia 'if' redundante
inspection.display.name.type.customizer=Inspección de personalizador de tipos
inspection.display.name.unassigned.access=Variable no asignada
inspection.display.name.unchecked.assignment.of.member.of.raw.type=Asignación no comprobada de miembros de un tipo raw
inspection.display.name.unconditional.wait=Llamada a 'wait' incondicional
inspection.display.name.unnecessary.alias=Alias de importación innecesario
inspection.display.name.unnecessary.continue=Sentencia 'continue' innecesaria
inspection.display.name.unnecessary.def.modifier='def' innecesario
inspection.display.name.unnecessary.final.modifier='final' innecesario
inspection.display.name.unnecessary.non.sealed.modifier=Modificador 'non-sealed' innecesario
inspection.display.name.unnecessary.public.modifier='public' innecesario
inspection.display.name.unnecessary.qualified.reference=Referencia cualificada innecesaria
inspection.display.name.unnecessary.return=Sentencia 'return' innecesaria
inspection.display.name.unnecessary.sealed.modifier=Modificador 'sealed' innecesario
inspection.display.name.unnecessary.semicolon=Punto y coma innecesario
inspection.display.name.unreachable.statement=Sentencia inalcanzable
inspection.display.name.unresolved.access=Expresión de referencia no resuelta
inspection.display.name.unresolved.labels.in.named.variant=Etiqueta no resuelta en @NamedVariant/@NamedParam/@NamedDelegate
inspection.display.name.unsynchronized.method.overrides.synchronized.method=Método no sincronizado sobrescribe un método sincronizado
inspection.display.name.untyped.access=Expresión de referencia sin tipo
inspection.display.name.unused.assignment=Asignación no utilizada
inspection.display.name.unused.catch.parameter=Parámetro 'catch' no utilizado
inspection.display.name.unused.declaration=Declaración no utilizada
inspection.display.name.unused.inc.dec=Incremento o decremento no utilizado
inspection.display.name.variable.can.be.final=La variable puede ser final
inspection.display.name.wait.call.not.in.loop='wait()' no está en un bucle
inspection.display.name.wait.while.not.synchronized='wait()' sin sincronización
inspection.display.name.while.loop.spins.on.field=Bucle while realiza un spin sobre un campo
inspection.error.handling=Gestión de errores
inspection.gpath=GPath
inspection.message.0.not.allowed.for.record=No se permite ''{0}'' para el registro
inspection.message.access.to.static.field.locked.on.instance.data=Acceso al campo estático <code>#ref</code> bloqueado sobre los datos de la instancia #loc
inspection.message.annotation.non.sealed.cannot.be.applied.to.enum.class=La anotación '@NonSealed' no se puede aplicar a una clase enum
inspection.message.annotation.sealed.cannot.be.applied.to.enum.class=La anotación '@Sealed' no se puede aplicar a una clase enum
inspection.message.arrows.in.case.expressions.are.available.with.groovy.4.or.later=Las flechas en las expresiones 'case' están disponibles en Groovy 4.0 o posterior
inspection.message.assignment.replaceable.with.operator.assignment=<code>#ref</code> podría simplificarse a ''{0}'' #loc
inspection.message.assignment.to.for.loop.parameter=Asignación al parámetro del bucle for '#ref' #loc
inspection.message.assignment.to.method.parameter=Asignación al parámetro del método '#ref' #loc
inspection.message.both.open.ranges.are.available.in.groovy.4.or.later=Los rangos abiertos en ambos extremos están disponibles en Groovy 4.0 o posterior
inspection.message.call.to.ref.can.be.keyed.access=La llamada a '#ref' puede ser acceso mediante clave #loc
inspection.message.call.to.ref.outside.of.loop=Llamada a '#ref' fuera de un bucle #loc
inspection.message.call.to.ref.outside.of.synchronized.context=Llamada a '#ref' fuera del contexto sincronizado #loc
inspection.message.call.to.ref.outside.synchronized.context=Llamada a '#ref' fuera del contexto sincronizado #loc
inspection.message.call.to.system.ref=Llamada a 'System.#ref' #loc
inspection.message.call.to.thread.ref=Llamada a 'Thread.#ref' #loc
inspection.message.call.to.thread.ref.in.a.loop=Llamada a <code>Thread.#ref()</code> en un bucle, probablemente en espera activa #loc
inspection.message.cannot.determine.type.ref=No se puede determinar el tipo de '#ref'
inspection.message.cannot.resolve.method.call=No se puede resolver el método 'call'
inspection.message.case.or.default.branches.are.expected=Se esperan ramas 'case' o 'default'
inspection.message.class.cannot.be.non.sealed.without.sealed.parent=La clase ''{0}'' no puede ser non-sealed sin un padre sealed
inspection.message.class.has.no.explicit.or.implicit.subclasses=La clase ''{0}'' no tiene subclases permitidas explícitas o implícitas
inspection.message.code.ref.code.recurses.infinitely.can.only.complete.by.throwing.exception=<code>#ref</code> tiene una recursión infinita y solo puede completarse lanzando una excepción #loc
inspection.message.code.ref.code.statement.doesnt.loop=La sentencia <code>#ref</code> no realiza bucles #loc
inspection.message.compact.constructor.should.have.explicit.visibility.modifier=El constructor compacto debe tener un modificador de visibilidad explícito
inspection.message.conditional.expression=Expresión condicional #loc
inspection.message.conditional.expression.can.be.call=La expresión condicional puede ser una llamada #loc
inspection.message.conditional.expression.can.be.elvis=La expresión condicional puede ser Elvis #loc
inspection.message.conditional.expression.with.identical.branches=Expresión condicional con ramas idénticas #loc
inspection.message.constant.name.ref.doesnt.match.regex=El nombre de la constante ''#ref'' no coincide con la expresión regular ''{0}'' #loc
inspection.message.constant.name.ref.too.long=El nombre de la constante '#ref' es demasiado largo
inspection.message.constant.name.ref.too.short=El nombre de la constante '#ref' es demasiado corto
inspection.message.couldnt.find.property.field.with.this.name=No se pudo encontrar la propiedad o el campo con este nombre #loc
inspection.message.divide.by.zero=División por cero #loc
inspection.message.double.checked.locking=Bloqueo de doble comprobación #loc
inspection.message.double.negation.ref=Doble negación #ref #loc
inspection.message.dsl.descriptor.file.has.been.changed.and.isnt.currently.executed=El archivo descriptor DSL ha sido modificado y no se está ejecutando actualmente
inspection.message.dsl.descriptor.file.has.been.disabled.due.to.processing.error=El archivo descriptor DSL se ha desactivado debido a un error de procesamiento
inspection.message.duplicate.switch.case.ref=Caso de switch duplicado '#ref' #loc
inspection.message.empty.ref.block=Bloque '#ref' vacío #loc
inspection.message.fallthrough.in.switch.statement=Caída en la sentencia 'switch' #loc
inspection.message.fraction.literals.without.leading.zero.are.available.in.groovy.or.later=Los literales de fracción sin cero inicial están disponibles en Groovy 4.0 o posterior
inspection.message.gstring.used.as.maps.key=GString se utiliza como clave del mapa #loc
inspection.message.instance.method.name.ref.doesnt.match.regex=El nombre del método de instancia ''#ref'' no coincide con la expresión regular ''{0}'' #loc
inspection.message.instance.method.name.ref.too.long=El nombre del método de instancia '#ref' es demasiado largo
inspection.message.instance.method.name.ref.too.short=El nombre del método de instancia '#ref' es demasiado corto
inspection.message.instance.variable.name.ref.doesn.t.match.regex=El nombre de la variable de instancia ''#ref'' no coincide con la expresión regular ''{0}'' #loc
inspection.message.instance.variable.name.ref.too.long=El nombre de la variable de instancia '#ref' es demasiado largo
inspection.message.instance.variable.name.ref.too.short=El nombre de la variable de instancia '#ref' es demasiado corto
inspection.message.interface.cannot.be.non.sealed.without.sealed.parent=La interfaz ''{0}'' no puede ser non-sealed sin un padre sealed
inspection.message.interface.has.no.explicit.or.implicit.implementors=La interfaz ''{0}'' no tiene implementadores permitidos explícitos o implícitos
inspection.message.interpolated.string.should.be.dollar.slashy.quoted=La cadena interpolada debe estar delimitada por dollar-slashy ( $/)
inspection.message.interpolated.string.should.be.double.quoted=La cadena interpolada debe estar entre comillas dobles
inspection.message.interpolated.string.should.be.quoted.with.triple.double.quotes=La cadena interpolada debe estar entre """
inspection.message.interpolated.string.should.be.slashy.quoted=La cadena interpolada debería estar delimitada por barras
inspection.message.invalid.permits.clause.must.be.sealed=Cláusula ''permits'' no válida: ''{0}'' debe ser ''sealed''
inspection.message.invalid.permits.clause.must.directly.extend=Cláusula ''permits'' no válida: ''{0}'' debe extender directamente a ''{1}''
inspection.message.keyword.yield.available.with.groovy.4.or.later=La palabra clave 'yield' está disponible en Groovy 4.0 o posterior
inspection.message.label.name.ref.not.supported.by.0=El nombre de etiqueta ''#ref'' no es compatible con {0}
inspection.message.left.open.ranges.are.available.in.groovy.4.or.later=Los rangos abiertos por la izquierda están disponibles en Groovy 4.0 o posterior
inspection.message.local.variable.name.ref.doesnt.match.regex=El nombre de la variable local ''#ref'' no coincide con la expresión regular ''{0}'' #loc
inspection.message.local.variable.name.ref.too.long=El nombre de la variable local '#ref' es demasiado largo
inspection.message.local.variable.name.ref.too.short=El nombre de la variable local '#ref' es demasiado corto
inspection.message.method.called.with.implicit.null.argument=El método se llama con un argumento null implícito
inspection.message.method.parameter.name.ref.doesnt.match.regex=El nombre del parámetro del método ''#ref'' no coincide con la expresión regular ''{0}'' #loc
inspection.message.method.parameter.name.ref.too.long=El nombre del parámetro del método '#ref' es demasiado largo
inspection.message.method.parameter.name.ref.too.short=El nombre del parámetro de método '#ref' es demasiado corto
inspection.message.method.ref.contains.too.many.parameters.0.1=El método ''#ref'' contiene demasiados parámetros ({0}>{1})
inspection.message.method.ref.has.too.many.negations=El método ''#ref'' tiene demasiadas negaciones ({0} > 3)
inspection.message.method.ref.overly.complex.cyclomatic.complexity=El método ''#ref'' es excesivamente complejo (complejidad ciclomática = {0}>{1})
inspection.message.method.ref.overly.nested.nesting.depth=El método ''#ref'' está excesivamente anidado (profundidad de anidamiento = {0}>{1})
inspection.message.method.ref.too.long.statement.count=El método ''#ref'' es demasiado largo (número de sentencias = {0}>{1})
inspection.message.mixing.arrows.colons.not.allowed=No se permite mezclar flechas y dos puntos
inspection.message.modifier.non.sealed.cannot.be.applied.to.enum.class=El modificador 'non-sealed' no se puede aplicar a una clase enum
inspection.message.modifier.nonsealed.available.with.groovy.or.later=El modificador 'non-sealed' está disponible en Groovy 4.0 o posterior
inspection.message.modifier.sealed.available.with.groovy.or.later=El modificador 'sealed' está disponible en Groovy 4.0 o posterior
inspection.message.modifier.sealed.cannot.be.applied.to.enum.class=El modificador 'sealed' no se puede aplicar a una clase enum
inspection.message.multiline.string.should.be.dollar.slashy.quoted=La cadena multilínea debe estar delimitada por dollar-slashy ($/)
inspection.message.multiline.string.should.be.quoted.with.triple.double.quotes=La cadena multilínea debe estar entre comillas triples (""")
inspection.message.multiline.string.should.be.quoted.with.triple.quotes=La cadena multilínea debe estar entre comillas triples (''')
inspection.message.multiline.string.should.be.slashy.quoted=La cadena multilínea debería estar delimitada por barras
inspection.message.multiple.expressions.in.case.section.are.available.with.groovy.4.or.later=Múltiples expresiones en etiquetas case están disponibles en Groovy 4.0 o posterior
inspection.message.negated.conditional.expression=Expresión condicional negada #loc
inspection.message.negated.if.condition.expression=Expresión de condición if negada #loc
inspection.message.nested.assignment=Uso del resultado de una expresión de asignación #loc
inspection.message.nested.assignment.expression=Expresión de asignación anidada #loc
inspection.message.nested.conditional.expression=Expresión condicional anidada #loc
inspection.message.nested.ref.statement=Sentencia '#ref' anidada #loc
inspection.message.non.private.field.accessed.in.synchronized.context=Campo no privado '#ref' accedido en un contexto sincronizado #loc
inspection.message.non.short.circuit.boolean.expression=Expresión booleana sin cortocircuito #loc
inspection.message.not.allowed.in.sealed.hierarchy=''{0}'' no está permitido en la jerarquía sellada
inspection.message.octal.integer.ref=Entero octal #ref #loc
inspection.message.only.one.final.sealed.non.sealed.should.be.applied.to.class=Solo se debe aplicar uno de 'final', 'sealed', 'non-sealed', @Sealed o @NonSealed a la clase
inspection.message.overly.complex.arithmetic.expression=Expresión aritmética excesivamente compleja #loc
inspection.message.overly.complex.boolean.expression=Expresión booleana excesivamente compleja #loc
inspection.message.package.name.mismatch=El nombre del paquete no coincide
inspection.message.package.name.mismatch.actual.0.expected.1=El nombre del paquete no coincide. Actual: ''{0}'', esperado: ''{1}''
inspection.message.permits.available.with.groovy.4.or.later='permits' está disponible en Groovy 4.0 o posterior
inspection.message.plain.string.should.be.dollar.slashy.quoted=La cadena de texto simple debería estar delimitada por dollar-slashy ($/)
inspection.message.plain.string.should.be.double.quoted=La cadena de texto plana debe estar entre comillas dobles
inspection.message.plain.string.should.be.quoted.with.triple.double.quotes=La cadena de texto simple debe estar entre comillas triples """
inspection.message.plain.string.should.be.quoted.with.triple.quotes=La cadena simple debe estar entre comillas triples (''')
inspection.message.plain.string.should.be.single.quoted=La cadena simple debe estar entre comillas simples
inspection.message.plain.string.should.be.slashy.quoted=La cadena simple debe estar delimitada por barras (slashy-quoted)
inspection.message.pojo.has.effect.only.with.compilestatic=@POJO solo tiene efecto con @CompileStatic
inspection.message.property.0.is.final=La propiedad ''{0}'' es final #loc
inspection.message.property.0.is.ignored.by.map.constructor=La propiedad ''{0}'' es ignorada por @MapConstructor #loc
inspection.message.property.not.indexable.type.must.be.array.or.list.but.found.0=La propiedad no es indexable. El tipo debe ser un array o una lista, pero se encontró {0}
inspection.message.record.parameter.should.be.immutable=El parámetro del record ''{0}'' debe tener un tipo inmutable o estar declarado como tal con @ImmutableOptions
inspection.message.records.are.available.in.groovy.4.or.later=Los registros están disponibles en Groovy 4.0.0-beta-2 o posterior
inspection.message.ref.can.be.simplified='#ref' se puede simplificar #loc
inspection.message.ref.has.0.return.points=<code>#ref</code> tiene {0} puntos de retorno #loc
inspection.message.ref.inside.finally.block='#ref' dentro del bloque 'finally' #loc
inspection.message.ref.is.unnecessary.as.last.statement.in.loop=#ref es innecesario como última sentencia en un bucle #loc
inspection.message.ref.is.unnecessary.as.last.statement.in.method.with.no.return.value=#ref es innecesario como última sentencia en un método sin valor de retorno #loc
inspection.message.ref.loop.spins.on.field=El bucle <code>#ref</code> realiza un spin sobre el campo #loc
inspection.message.ref.statement=#ref sentencia #loc
inspection.message.ref.statement.at.end.closure.can.be.made.implicit=Retorno explícito al final del closure #loc
inspection.message.ref.statement.can.be.simplified=La sentencia #ref se puede simplificar #loc
inspection.message.ref.statement.cannot.complete.without.throwing.exception=La sentencia <code>#ref</code> no puede completarse sin lanzar una excepción #loc
inspection.message.ref.statement.has.empty.body=La sentencia '#ref' tiene un cuerpo vacío
inspection.message.ref.statement.has.empty.branch=La sentencia '#ref' tiene una rama vacía
inspection.message.ref.statement.with.identical.branches=Sentencia '#ref' con ramas idénticas #loc
inspection.message.ref.statement.with.no.default.branch=Sentencia #ref sin rama 'default' #loc
inspection.message.ref.statement.with.too.many.branches=Sentencia ''#ref'' con demasiadas bifurcaciones ({0}) #loc
inspection.message.result.increment.or.decrement.expression.used=Uso del resultado de incremento o decremento #loc
inspection.message.result.of.new.ref.is.ignored=El resultado de ''new #ref{0}'' se ignora #loc
inspection.message.silly.assignment=Asignación redundante #loc
inspection.message.static.interface.methods.must.be.qualified.in.groovy.4=Los métodos de interfaz 'static' deben estar calificados a partir de Groovy 4
inspection.message.static.method.name.ref.doesnt.match.regex=El nombre del método estático ''#ref'' no coincide con la expresión regular ''{0}'' #loc
inspection.message.static.method.name.ref.too.long=El nombre del método estático ''#ref'' es demasiado largo
inspection.message.static.method.name.ref.too.short=El nombre del método estático ''#ref'' es demasiado corto
inspection.message.static.variable.name.ref.doesnt.match.regex=El nombre de la variable estática ''#ref'' no coincide con la expresión regular ''{0}'' #loc
inspection.message.static.variable.name.ref.too.long=El nombre de la variable estática '#ref' es demasiado largo
inspection.message.static.variable.name.ref.too.short=El nombre de la variable estática '#ref' es demasiado corto
inspection.message.string.escaping.could.be.minimized=Se podría minimizar el escapado
inspection.message.switch.expression.does.not.cover.all.possible.outcomes=La expresión switch no cubre todos los resultados posibles
inspection.message.switch.expressions.are.available.with.groovy.4.or.later=Las expresiones switch están disponibles en Groovy 4.0 o posterior
inspection.message.switch.expressions.do.not.support.return=Las expresiones switch no admiten 'return'
inspection.message.synchronization.on.non.final.field.ref=Sincronización en el campo no final ''#ref'' #loc
inspection.message.synchronization.on.ref=Sincronización en '#ref' #loc
inspection.message.synchronization.on.variable.ref.which.was.initialized.with.literal=Sincronización en '#ref', que se inicializó con un literal #loc
inspection.message.synchronized.method.ref=Método sincronizado '#ref' #loc
inspection.message.traits.0.contain.clashing.methods.with.signature.1=Los traits {0} contienen métodos en conflicto con la firma {1}
inspection.message.trivial.conditional.expression=Expresión condicional trivial #loc
inspection.message.type.argument.0.can.not.be.1=El tipo del argumento ''{0}'' no puede ser ''{1}''
inspection.message.unconditional.call.to.ref=Llamada incondicional a <code>#ref()</code> #loc
inspection.message.unreachable.statement=Sentencia inalcanzable #loc
inspection.message.unsynchronized.method.ref.overrides.synchronized.method=El método no sincronizado '#ref' sobrescribe un método sincronizado #loc
inspection.message.unused.catch.parameter.ref=Parámetro catch no utilizado '#ref' #loc
inspection.message.yield.or.throw.expected.in.case.section=Se espera 'yield' o 'throw' en la sección case
inspection.method.metrics=Métricas de método
inspection.naming=Convenciones de nomenclatura
inspection.other=Otros
inspection.redundancy=Redundancia de declaración
inspection.separator.disable.in.file.types=Habilitar en tipos de archivo:
inspection.style=Estilo
inspection.threading=Problemas de subprocesos
inspection.validity=Problemas de validez
intention.category.closures=Groovy/Clausuras
intention.category.comments=Groovy/Comentarios
intention.category.control.flow=Groovy/Flujo de control
intention.category.conversions=Groovy/Conversiones de expresiones
intention.category.groovy=Groovy
intention.category.groovy.declaration=Groovy/Declaración
intention.category.groovy.other=Groovy/Otros
intention.category.groovy.style=Groovy/Estilo Groovy
intention.family.name.activate.dsl.descriptor=Activar descriptor DSL
intention.family.name.add.attributes.to.annotation=Agregar atributos a la anotación
intention.family.name.add.cast=Añadir cast
intention.family.name.add.class.to.clause=Agregar clase a la cláusula
intention.family.name.add.missing.case.branches=Agregar ramas de case faltantes
intention.family.name.add.parameter.cast=Añadir cast de parámetro
intention.family.name.change.variable.type=Cambiar tipo de variable
intention.family.name.collapse.conditional.expressions=Contraer expresión condicional
intention.family.name.collapse.if.statement=Contraer sentencia 'if'
intention.family.name.convert.conditional.expression.to.elvis=Convertir expresión condicional en Elvis
intention.family.name.create.field=Crear campo
intention.family.name.fix.quotation=Corregir comillas
intention.family.name.fix.range.class=Corregir clase de rango
intention.family.name.make.return.implicit=Hacer que el retorno sea implícito
intention.family.name.remove.double.negation=Eliminar doble negación
intention.family.name.remove.unnecessary.continue=Eliminar continue innecesario
intention.family.name.remove.unnecessary.return=Eliminar return innecesario
intention.family.name.rename=Cambiar nombre
intention.family.name.replace.for.each.operator=Reemplazar el operador 'for-each'
intention.family.name.replace.keywords=Reemplazar elementos
intention.family.name.replace.modifiers=Reemplazar modificadores
intention.family.name.replace.something.with=Reemplazar ''{0}'' por ''{1}''
intention.family.name.replace.with.conditional.call=Reemplazar por llamada condicional
intention.family.name.replace.with.keyed.access=Reemplazar con acceso por clave
intention.family.name.replace.with.short.circuit.expression=Reemplazar con una expresión de cortocircuito
intention.family.name.simplify=Simplificar
intention.name.activate.back=Reactivar
intention.name.add.required.attributes.to.map.constructor=Añadir los atributos requeridos a '@MapConstructor'
intention.name.add.to.clause=Añadir ''{0}'' a la cláusula {1} de ''{2}''
intention.name.cast.operand.to.0=Convertir el operando a {0}
intention.name.cast.to.0=Convertir a {0}
intention.name.change.quotes.to.triple.double.quotes=Cambiar comillas a """
intention.name.change.quotes.to.triple.single.quotes=Cambiar comillas a '''
intention.name.convert.to.dollar.slashy.string=Convertir a cadena dollar-slashy
intention.name.convert.to.double.quoted.string=Convertir a cadena con comillas dobles
intention.name.convert.to.single.quoted.string=Convertir a cadena con comillas simples
intention.name.convert.to.slashy.string=Convertir en cadena con barras
intention.name.create.abstract.method.in.class=Crear el método abstracto ''{0}'' en ''{1}''
intention.name.create.constant.field.in.class=Crear campo constante ''{0}'' en ''{1}''
intention.name.create.enum.constant.0=Crear constante de enumeración ''{0}''
intention.name.create.field.in.class=Crear campo ''{0}'' en ''{1}''
intention.name.create.method.in.class=Crear el método ''{0}'' en ''{1}''
intention.name.insert.case.0=Insertar ''case {0}''
intention.name.insert.case.0.case.1=Insertar ''case {0}'', ''case {1}''
intention.name.insert.default.branch=Insertar rama 'default'
intention.name.insert.missing.branches=Insertar ramas faltantes
intention.name.make.compact.constructor.public=Hacer 'public' el constructor compacto
intention.name.remove.wrong.modifiers.for.record=Eliminar modificadores incorrectos para el registro
intention.name.replace=Reemplazar ''{0}'' por ''{1}''
intention.name.replace.eq.with.0.eq=Reemplazar ''='' por ''{0}=''
intention.name.replace.with.in=Reemplazar ':' por 'in'
intention.name.replace.with.qualified.expression=Reemplazar con nombre calificado
interface.cannot.have.modifier.final=La interfaz no puede tener el modificador 'final'
interface.members.are.not.allowed.to.be=No se permite que los miembros de la interfaz sean {0}
interface.must.have.no.static.method=La interfaz no debe tener métodos estáticos
introduce.constant.title=Introducir constante
introduce.parameter.delegate.via.overload=De&legar mediante un método de sobrecarga
introduce.parameter.delegating.unavailable.tooltip=No se permite la delegación en el contexto de una clausura
introduce.parameter.do.not.replace.option.label=N&o reemplazar
introduce.parameter.explicit.return.statement.option.label=Usar sentencia return e&xplícita
introduce.parameter.replace.all.fields.option.label=&Reemplazar todos los campos
introduce.parameter.replace.fields.border.title=Reemplazar los campos utilizados en la expresión por sus getters
introduce.parameter.replace.inaccessible.fields.option.label=Reemplazar campos &inaccesibles en el contexto de uso
introduce.variable.change.type.advertisement=Presione {0} para cambiar el tipo
introduce.variable.declare.final.label=Declarar como &final
introduce.variable.name.label=&Nombre:
introduce.variable.replace.all.0.occurrences=Reemplazar &todas las ocurrencias ({0} ocurrencias)
introduce.variable.replace.all.occurrences=Reemplazar &todas las ocurrencias
introduce.variable.type.label=&Tipo:
invalid.lvalue=Valor no válido para asignar
invalid.qualified.name=Este no es un nombre calificado de Groovy válido
investigate.gdsl.error.family.name=Investigar error de procesamiento del descriptor DSL
investigate.gdsl.error.intention.name=Ver detalles
invoke.completion.second.time.to.show.skipped.methods=Invocar el completado por segunda vez para mostrar los métodos omitidos
is.not.enclosing.class=''{0}'' no es una clase envolvente
java.style.for.each.statement.requires.a.type.declaration=La sentencia for-each al estilo Java requiere una declaración de tipo
java.style.properties.invocation.intention.family.name=Cambiar invocación de accesor estilo Java a referencia de propiedad estilo Groovy
java.style.properties.invocation.intention.name=Cambiar a referencia de propiedad al estilo Groovy
java.style.property.access=Invocación de accesores al estilo Java
label.already.used=La etiqueta ''{0}'' ya está en uso
label.groovy.sdk=SDK de Groovy:
language.groovy=Groovy
leave.only.modifier.or.annotation.0=Dejar solo ''{0}''
listener.list.field.must.have.a.generic.collection.type=El campo @ListenerList debe tener un tipo Collection genérico
listener.list.field.with.generic.wildcards.not.supported=No se admite el campo @ListenerList con comodines genéricos
live.template.context.declaration=Declaración
live.template.context.expression=Expresión
live.template.context.statement=Sentencia
local.var.0.is.reassigned=La variable local ''{0}'' se ha vuelto a asignar
lock.field.0.must.be.static=El campo de bloqueo ''{0}'' debe ser static
lock.field.0.must.not.be.static=El campo de bloqueo ''{0}'' no debe ser static
lock.field.0.not.found=No se encontró el campo de bloqueo ''{0}''
loss.of.precision=Posible pérdida de precisión de ''{0}'' a ''{1}''
map.param.name=&Nombre del parámetro de mapa:
map.parameter.dialog.create.new.checkbox=&Crear nuevo parámetro para argumentos con nombre
map.parameter.dialog.explicit.type.checkbox=Especificar el tipo explícitamente
method.0.cannot.have.weaker.access.privileges.1.than.2.in.3.4=El método ''{0}'' no puede tener privilegios de acceso más débiles (''{1}'') que ''{2}'' en ''{3}'' (''{4}'')
method.0.cannot.override.method.1.in.2.overridden.method.is.final=El método ''{0}'' no puede sobrescribir el método ''{1}'' en ''{2}''; el método sobrescrito es final
method.0.is.too.complex.too.analyze=El método ''{0}'' es demasiado complejo para analizar.\nNo se han inferido los tipos de las variables locales.
method.call.is.ambiguous=La llamada al método es ambigua
method.does.not.override.super=El método no sobreescribe un método de su superclase
method.duplicate=El método con la firma {0} ya está definido en la clase ''{1}''
method.has.incorrect.modifier.volatile=El método tiene el modificador 'volatile' incorrecto
method.is.not.implemented=El método ''{0}'' no está implementado
method.is.used.outside.of.groovy=El método se utiliza fuera de Groovy
method.may.be.static=El método puede ser static
method.may.be.static.ignore.empty.method.option=Ignorar métodos vacíos
method.may.be.static.only.private.or.final.option=Solo comprobar métodos final o private
method.may.be.static.option.ignore.trait.methods=Ignorar métodos de trait
method.parameters.count.max.parameters.option=Número máximo de parámetros:
method.returns.max.returns.option=Límite de puntos de retorno:
method.with.signature.already.exists=Ya existe un método con la firma {0}
method.with.type.parameters.should.have.return.type=El método con parámetros de tipo debe tener un tipo de retorno
missed.attributes=Atributos faltantes: {0}
missing.required.named.parameter=Falta el parámetro con nombre obligatorio ''{0}''
mixing.private.and.public.protected.methods.of.the.same.name=Mezcla de métodos private y public/protected con el mismo nombre
modifier.0.not.allowed=Modificador ''{0}'' no permitido aquí
modifier.transient.not.allowed.here=El modificador 'transient' no se permite aquí
modifier.volatile.not.allowed.here=El modificador 'volatile' no está permitido aquí
module.name.0.and.groovy.version.1={0} ({1})
module.with.groovy=Módulo simple con biblioteca Groovy adjunta
move.class.0.from.method=Mover ''{0}'' a la ubicación correcta
move.class.from.method.family.name=Corrección rápida "Mover al lugar correcto"
move.to.correct.dir=Mover al paquete ''{0}''
move.to.correct.dir.family.name=Mover archivo al paquete correcto
multiple.assignments.without.list.expr=Las asignaciones múltiples sin expresiones de lista en el lado derecho no son compatibles en el modo de comprobación de tipos estática
named.arguments.are.not.allowed.inside.index.operations=No se permiten argumentos con nombre dentro de las operaciones de índice
native.methods.cannot.have.body=Los métodos nativos no pueden tener cuerpo
native.visibility.presentation=nativo
new.class.action.description=Crea una nueva clase Groovy
new.class.action.text=Clase Groovy
new.class.dialog.title=Nueva clase Groovy
new.class.list.item.annotation=Anotación
new.class.list.item.class=Clase
new.class.list.item.enum=Enum
new.class.list.item.interface=Interfaz
new.class.list.item.record=Registro
new.class.list.item.trait=Trait
new.gant.script.dialog.message=Introduzca un nombre para el nuevo script de Gant
new.gant.script.dialog.title=Nuevo script de Gant
new.instance.of.singleton=Nueva instancia de clase anotada con @groovy.lang.Singleton
new.project.wizard.groovy.creating.main.file=Creando archivo principal Groovy...
new.project.wizard.groovy.retrieving.has.failed=Error al recuperar las versiones de Groovy
new.script.action.description=Crear nuevo script Groovy
new.script.action.text=Script Groovy
new.script.dialog.title=Nuevo script de Groovy
new.script.list.item.script=Script de Groovy
new.script.list.item.script.dsl=Script GroovyDSL
newlines.here.are.available.since.groovy.3=Los caracteres de nueva línea en la lista de argumentos están disponibles desde Groovy 3.0
no.applicable.signature.found=No se encontró ninguna firma aplicable
no.class.expected.here=No se esperaba una clase aquí
no.class.in.file.template=No se encontró ninguna clase en la plantilla de archivo
no.implements.clause.allowed.for.interface=Las interfaces no pueden tener la cláusula 'implements'
no.interface.expected.here=No se esperaba una interfaz aquí
no.return.message=No todas las rutas de ejecución devuelven un valor
no.such.property=La propiedad ''{0}'' no existe
no.super.classes.found=No se encontraron superclases
no.super.method.found=No se encontraron supermétodos
no.type.specified=No se ha especificado ningún tipo
non.sealed.visibility.presentation=No sellado
non.static.classes.not.allowed=No se permiten clases internas no estáticas en traits
not.abstract.method.should.have.body=El método no abstracto debe tener cuerpo
not.allowed.modifier.in.for.in=No se permite el modificador ''{0}'' aquí
notification.group.grape=Anotación @Grab de Groovy procesada
notification.group.groovy.dsl=Errores de Groovy DSL
only.abstract.class.can.have.abstract.method=Solo las clases abstractas pueden tener métodos abstractos
only.traits.expected.here=Solo se esperan rasgos aquí
operator.call.is.ambiguous=La llamada al operador es ambigua
operator.is.not.supported.in=El operador ''{0}'' no es compatible con la versión actual
optimize.all.imports=Optimizar las sentencias de importación no utilizadas
optimize.imports=Optimizar importaciones
optimize.imports.progress.title=Optimizando las importaciones en archivos Groovy…
other.scope=Otro ámbito
overly.complex.method.complexity.limit.option=Límite de complejidad del método:
overly.long.method.statements.limit.option=Máximo de sentencias por método:
overly.nested.method.nesting.limit.option=Profundidad máxima de anidamiento:
overriding.methods.of.0=Métodos de sobrescritura de ''{0}''
package.definition.cannot.have.modifiers=La definición del paquete no puede tener modificadores
packageLocal.visibility.presentation=Visibilidad predeterminada
parameter.can.be.final.tooltip=El parámetro ''{0}'' puede ser final
parameter.cast.fix=Convertir el {0,number,ordinal} parámetro a {1}
parameter.hint.number.of.arguments={0, choice, 0#|1#{0} argumento|2#{0} argumentos}
parameter.list.owner.chooser.title=Introducir parámetro en
pointless.arithmetic.error.message=Operaciones aritméticas redundantes #loc
pointless.boolean.problem.descriptor=Operaciones booleanas redundantes #loc
pointless.boolean.quickfix=Simplificar
popup.content.navigation.to.overriding.classes.unavailable=No es posible navegar a las clases que sobrescriben durante la actualización del índice
postfix.template.provider.name=Groovy
primitive.bound.types.are.not.allowed=No se permiten tipos de límites primitivos
primitive.type.parameters.are.not.allowed=No se permiten parámetros de tipos primitivos en la lista de parámetros de tipo
private.visibility.presentation=Privado
property.missing=Propiedad faltante
property.name.expected=Se esperaba un nombre de propiedad
protected.visibility.presentation=Protegido
public.visibility.presentation=Público
pull.up.abstract.wont.be.accessible.from=No se puede definir {0} como abstract porque no será accesible desde la subclase.
pull.up.wont.be.accessible.from={0} no será accesible desde {1}
pull.up.wont.be.accessible.from.the.subclass={0} utiliza {1}, que no será accesible desde la subclase.
qualified.0.is.allowed.only.in.nested.or.inner.classes={0} calificado solo se permite en clases anidadas/internas
recursive.constructor.invocation=Invocación recursiva de constructor
remove.0=Eliminar ''{0}''
remove.catch.block=Eliminar bloque catch
remove.exception=Eliminar excepción
remove.modifier=Eliminar ''{0}''
remove.parameter.0=Eliminar parámetro ''{0}''
remove.unused.parameter=Eliminar parámetro no utilizado
rename.file.to.0=Renombrar archivo a ''{0}''
repetitive.method.name.0=Nombre de método repetido ''{0}''
replace.0.with.1=Reemplazar ''{0}'' por el binario ''{1}''
replace.all.occurrences.and.remove.variable.0=Reemplazar todas las apariciones y eliminar la variable ''{0}''
replace.new.expression.with.instance.access=Reemplazar con acceso a la instancia
replace.postfix.0.with.prefix.0=Reemplazar el postfijo ''{0}'' por el prefijo ''{0}''
replace.primitive.type.with.wrapper=Reemplazar tipo primitivo con clase envolvente
replace.qualified.name.with.import=Reemplazar nombre calificado por importación
replace.with.get.at=Reemplazar con acceso por índice
replace.with.list.literal=Reemplazar con literal de lista
replace.with.method.fix=Reemplazar por el método ''{0}''
replace.with.method.message=Se puede reemplazar por la llamada al método ''{0}''
replace.with.operator.compareTo.equality.option=Reemplazar la igualdad de 'compareTo' por el operador de igualdad (es decir, ==)
replace.with.operator.double.negation.option=Usar doble negación (es decir, !!)
replace.with.operator.fix=Reemplazar ''{0}'' con el operador
replace.with.operator.message=''{0}'' se puede reemplazar por un operador
replace.with.operator.parentheses=No sugerir el reemplazo por un operador si requiere paréntesis adicionales
replace.with.wrapper=Reemplazar con ''{0}''
require.closure.as.attribute.value=Se esperaba una clausura como valor de atributo
return.type.is.incompatible=El tipo de retorno de {0} en {1} es incompatible con {2} en {3}
rtype.cannot.contain.ltype='{1}'' no puede contener ''{0}'
run.configuration.module.chooser.label=&Módulo:
run.configuration.module.classpath.checkbox=Añadir &classpath del módulo al ejecutor
run.configuration.script.path.label=Ruta del script:
script.cannot.have.modifier.native=El script no puede tener el modificador 'native'
script.generated.with.same.name=Se ha generado una clase sintética ''{0}'' para el código del script
script.method.cannot.have.modifier.abstract=El método de script no puede tener el modificador 'abstract'
script.runner.cant.find.script=No se puede encontrar el script ''{0}''
script.runner.chooser.description=Especificar la ruta al script
script.runner.chooser.title=Ruta del script
script.runner.class.cannot.be.executed=No se puede ejecutar la clase
script.runner.class.does.not.exist=La clase no existe
script.runner.description=Clase o script Groovy
script.runner.display.name=Groovy
script.runner.file.is.not.groovy.file=El archivo de script no es un archivo Groovy
script.runner.module.not.specified.message=No se ha especificado el módulo
script.runner.no.groovy.for.module=Groovy no está configurado para el módulo ''{0}''
script.runner.unknown.script.type=Tipo de script desconocido ''{0}''
sealed.visibility.presentation=Sellado
second.unsafe.call=Segunda llamada insegura
select.framework.0.home.title=Seleccionar el directorio de inicio de {0}
select.module.action.description=Seleccionar el módulo del que usar el classpath
select.module.action.text=Seleccionar módulo…
select.module.popup.title=Usar classpath del módulo
selfType.class.does.not.inherit=@SelfType: La clase ''{0}'' no hereda de ''{1}''
separator.domain.of.inspection.usage=Dominio de uso
separator.preferable.string.kind=Tipo preferido
settings.code.style.absolute=Absoluto
settings.code.style.indent.labels=Indentar etiquetas
settings.code.style.indent.statements.after.label=Indentar sentencias después de la etiqueta
settings.code.style.label.indent.size=Tamaño de sangría de etiqueta
settings.code.style.label.indent.style=Estilo de sangría de etiqueta:
settings.compiler.alternative=Como alternativa, puede especificar el compilador Groovy-Eclipse en la <a>página del compilador de Java</a>
settings.compiler.exclude.from.stub.generation=Excluir de la generación de stubs:
settings.compiler.invoke.dynamic.support=Soporte para invoke &dynamic
settings.compiler.path.to.configscript=Ruta al script de &configuración:
settings.compiler.select.path.to.groovy.compiler.configscript=Seleccionar la ruta al script de configuración del compilador de Groovy
settings.inlay.groovy.implicit.null.argument.provider.description=Si un método acepta solo un parámetro, Groovy permite llamarlo sin ningún argumento. En este caso, Groovy pasa implícitamente un único 'null' como argumento.
settings.inlay.groovy.implicit.null.argument.provider.name='null' implícito
settings.inlay.groovy.lambda.parameter.provider.description=Muestra los tipos de un parámetro en expresiones lambda:
settings.inlay.groovy.lambda.parameter.provider.name=Parámetro lambda
settings.inlay.groovy.local.variable.implicit.types.description=Muestra los tipos en el lugar de la declaración para las variables locales declaradas con 'def' o 'var'.
settings.inlay.groovy.local.variable.implicit.types.name=Sugerencias de tipo de variable local
shows.parameter.names.at.function.call.sites=Muestra los nombres de los parámetros en los puntos de llamada a funciones.
singleton.constructor.found=La clase @Singleton no debe tener constructores
singleton.constructor.makeNonStrict=Hacer que @Singleton no sea estricto
singleton.constructor.remove=Eliminar constructor
spread.operator.is.not.available=El operador spread no se puede utilizar como argumento con la comprobación de tipos estática.
static.import.method.0.fix=Importar método estático ''{0}''
static.import.method.fix=Importar método estático…
static.visibility.presentation=Estático
strictfp.visibility.presentation=strictfp
string.end.expected=Se esperaba el final de la cadena
string.option.do.not.handle.specifically=No tratar de forma específica
string.option.dollar.slashy.string=Cadena dollar-slashy
string.option.double.quoted.string=Cadena entre comillas dobles
string.option.single.quoted.string=Cadena entre comillas simples
string.option.slashy.string=Cadena entre barras
string.option.triple.double.quoted.string=Cadena con triple comilla doble
string.option.triple.quoted.string=Cadena con comillas triples
string.sort.default=Predeterminado
string.sort.multiline.string=Cadena multilínea
string.sort.strings.with.escaping=Cadenas con escape
string.sort.strings.with.interpolation=Cadenas con interpolación
super.cannot.be.used.in.static.context='super' no se puede usar en un contexto estático
super.is.not.allowed.in.pre.with.call.super=No se permite la llamada a super en 'pre' con 'callSuper' habilitado
surround.with.cast=((Tipo) expr)
surround.with.closure={ -> … }.call()
surround.with.for=for
surround.with.if=if
surround.with.if.else=if / else
surround.with.if.else.expr=if (expr) / else
surround.with.if.expr=if (expr)
surround.with.parentheses=(expr)
surround.with.shouldFail=shouldFail () {…}
surround.with.try=try
surround.with.try.catch=try / catch
surround.with.try.catch.finally=try / catch / finally
surround.with.try.finally=try / finally
surround.with.while=while
surround.with.while.expr=while (expr)
surround.with.with=with () {…}
surround.with.with.expr=with (expr)
synchronized.not.allowed.on.abstract.method=No se permite @Synchronized en un método abstracto
synchronized.visibility.presentation=Sincronizado
target.0.does.not.exist=El objetivo ''{0}'' no existe
target.annotation.is.unused=@Target no se utiliza
text.class.0.is.unused=La clase {0} no se utiliza
text.constructor.0.is.unused=El constructor {0} no se utiliza
text.method.0.is.unused=El método {0} no se utiliza
text.parameter.0.is.unused=El parámetro {0} no se utiliza
text.property.0.is.unused=La propiedad {0} no se utiliza
the.usage.of.a.map.entry.expression.to.initialize.an.enum.is.currently.not.supported=Actualmente no se admite el uso de una expresión de entrada de mapa para inicializar un Enum
there.is.no.default.constructor.available.in.class.0=No hay ningún constructor predeterminado disponible en la clase ''{0}''
this.super.completion.advertisement=Presionar {0} dos veces sin un calificador de clase mostrará todos los métodos estáticos accesibles
throws.clause.is.not.allowed.in.at.interface=La cláusula 'throws' no está permitida en miembros de @interface
top.level.class.may.not.have.private.modifier=La clase de nivel superior no puede tener el modificador 'private'
top.level.class.may.not.have.protected.modifier=La clase de nivel superior no puede tener el modificador 'protected'
trait.method.cannot.be.protected=No se permite que los métodos de trait sean protected
transient.visibility.presentation=Transitorio
try.catch.fix=Corrección try-catch
try.without.catch.finally=try' sin 'catch' o 'finally
tuple.cant.be.placed.in.class=No se permiten asignaciones múltiples para campos
tuple.declaration.should.end.with.def.modifier=La declaración de tupla debe terminar con el modificador 'def'
type.argument.0.is.not.in.its.bound.should.extend.1=El parámetro de tipo ''{0}'' no está dentro de sus límites; debe extender ''{1}''
type.argument.list.is.not.allowed.here=No se permite la lista de argumentos de tipo aquí
type.customizer.is.not.marked.as.a.resource.file=El script del personalizador de tipos no está marcado como recurso del compilador
type.doesnt.contain.method=El tipo ''{0}'' no se puede iterar en un rango porque no tiene el método ''{1}''
type.doesnt.implement.comparable=El tipo ''{0}'' no implementa Comparable
type.parameters.are.unexpected=No se esperan parámetros de tipo
unassigned.access.tooltip=La variable ''{0}'' podría no estar asignada
undefined.label=Etiqueta no definida ''{0}''
undefined.library.version=Indefinido
unexpected.attribute.type.0=Tipo de atributo inesperado: ''{0}''
unnecessary.alias.description=Alias innecesario
unnecessary.alias.fix=Eliminar alias innecesario
unnecessary.def.explicitly.typed.only=Solo informar en declaraciones con tipos explícitos
unnecessary.modifier.description=El modificador ''{0}'' no es necesario
unnecessary.modifier.remove=Eliminar ''{0}'' innecesario
unnecessary.semicolon.description=Punto y coma innecesario
unnecessary.semicolon.fix=Eliminar punto y coma
unnecessary.type=Excepción innecesaria ''{0}''. ''{1}'' ya está declarada
unresolved.type.status=El tipo ''{0}'' no se ha resuelto
unsupported.anonymous.class.0=Las clases anónimas no son compatibles con Groovy {0}
unsupported.array.initializers=Los inicializadores de arrays no son compatibles en la versión actual
unsupported.command.syntax.0=La sintaxis de expresiones de comando no es compatible con Groovy {0}
unsupported.diamonds.0=El operador diamante no es compatible con Groovy {0}
unsupported.do.while.statement='do while' no se admite en la versión actual
unsupported.dollar.slashy.string.0=Las cadenas de texto "dollar slashy" no son compatibles con Groovy {0}
unsupported.elvis.assignment=La asignación Elvis no se admite en la versión actual
unsupported.expression.list.in.for.update=No se admiten múltiples expresiones en la actualización de 'for' en la versión actual
unsupported.inner.class.0=Las clases internas no se admiten en Groovy {0}
unsupported.lambda=Las lambdas no son compatibles con la versión actual
unsupported.multiline.slashy.string.0=No se admiten las cadenas slashy multilínea en Groovy {0}
unsupported.multiple.variables.in.for=No se admiten varias variables en la inicialización de 'for' en la versión actual
unsupported.negated.in=La negación de 'in' no es compatible en la versión actual
unsupported.negated.instanceof=No se admite 'instanceof' negado en la versión actual
unsupported.resource.list='try' con recursos no es compatible en la versión actual
unsupported.safe.index.access=El acceso seguro a índices no se admite en la versión actual
unsupported.traits.0=Los traits no son compatibles en Groovy {0}
unsupported.tuple.application.initializer=El inicializador de la aplicación no es compatible con la versión actual
unsupported.tuple.declaration.in.for=La declaración de tuplas en la inicialización de 'for' no es compatible con la versión actual
unsupported.type.annotations=Las anotaciones de tipo no se admiten en la versión actual
unused.0=''{0}'' no se utiliza
unused.assignment.tooltip=La asignación no se utiliza
unused.default.parameter.fix=Eliminar inicializador
unused.default.parameter.message=No se utiliza el parámetro predeterminado
unused.import=Importación no utilizada
unused.variable=La variable no se utiliza
variable.0.might.not.have.been.initialized=Es posible que la variable ''{0}'' no se haya inicializado
variable.already.defined=La variable ''{0}'' ya está definida
variable.can.be.final.tooltip=La variable ''{0}'' puede ser final
variable.cannot.be=La variable no puede tener el modificador ''{0}''
volatile.visibility.presentation=Volátil
wildcards.are.not.allowed.in.extends.list=Un supertipo no puede especificar un tipo comodín.
write.access.to.closure.variable=Acceso de escritura al campo <b>{0}</b>
wrong.closure.first.parameter.type=El closure ''{0}'' se utiliza con argumentos con nombre, pero su primer parámetro ''{1}'' no es conforme al tipo Map.
wrong.method.first.parameter.type=El método ''{0}'' se utiliza con argumentos con nombre, pero su primer parámetro ''{1}'' no cumple con el tipo Map.
wrong.number.of.type.arguments=Número incorrecto de argumentos de tipo: {0}; requeridos: {1}
