action.AddToISuite.text=Añadir a la suite de patrones de JUnit
action.excludeFromSuite.text=Excluir de la suite
action.text.test.category=Pruebas de {0}
action.text.test.tags=Pruebas de {0}
action.text.test.unknown.target=Desconocido
async.stack.trace.for.exceptions.name=Imprimir traza de pila asíncrona para excepciones
cannot.browse.test.inheritors.dialog.title=No se pueden examinar los herederos de TestCase
category.interface.dialog.title=Interfaz de categoría
category.is.not.specified.error.message=Categoría no especificada
category.label=Categoría
change.list.label=Lista de cambios
class.isnt.inheritor.of.testcase.error.message={0} no hereda de TestCase
class.not.test.error.message=La clase ''{0}'' no es una prueba
combobox.changelists.all=Todas
configuration.not.specified.message=Tipo de prueba de configuración no especificado: {0}
create.setup.dialog.message=El método setUp ya existe, pero no está anotado como {0}. ¿Anotar?
create.setup.dialog.title=Crear método setUp
default.junit.config.empty.category=No válido
default.junit.config.name.all.in.module=Todo en {0}
default.junit.config.name.all.in.package.in.module={0} en {1}
default.junit.config.name.category=@Category({0})
default.junit.config.name.tags=Etiquetas ({0})
default.junit.config.name.temp.suite=Suite temporal
default.junit.config.name.whole.project=Proyecto completo
default.junit.configuration.name=<sin nombre>
dialog.message.failed.to.resolve.maven.id=No se pudo resolver {0}
dialog.message.no.unique.id.specified.exception=No se ha especificado un ID único
dialog.title.preparing.test=Preparando prueba
directory.0.is.not.found.error.message=No se encontró el directorio ''{0}''
directory.is.not.specified.error.message=No se ha especificado el directorio
directory.label=Directorio
directory.not.found.error.message=No se encontró el directorio ''{0}''
expected.exception.never.thrown.display.name=La excepción esperada nunca se lanzó en el cuerpo del método de prueba
expected.exception.never.thrown.problem.descriptor=La excepción <code>#ref</code> esperada nunca se lanza en el cuerpo de ''{0}()'' #loc
fix.data.provider.create.method.fix.name=Crear método de proveedor de datos '@Parameters public static Iterable<Object> parameters()'
fix.data.provider.multiple.methods.problem=Múltiples métodos de proveedor de datos @Parameters presentes en la clase <code>#ref</code>
fix.data.provider.signature.family.name=Corregir firma del método del proveedor de datos
fix.data.provider.signature.fix.name=Cambiar la signatura del método a ''{0}''
fix.data.provider.signature.incorrect.problem=El método del proveedor de datos <code>#ref()</code> tiene una firma incorrecta
fix.data.provider.signature.missing.method.problem=La clase de prueba parametrizada <code>#ref</code> carece de un método proveedor de datos anotado con '@Parameters'
fork.mode.label=Modo &fork:
fork.mode.name=Modo fork
inspection.parameterized.parameters.static.collection.display.name=Clase de prueba parametrizada sin método proveedor de datos
junit.config.with.parameter.0=Con el parámetro "{0}"
junit.configuration.across.module.dependencies.radio=Dependencias entre módu&los
junit.configuration.class.label=&Clase:
junit.configuration.description=Configuración de pruebas de JUnit
junit.configuration.display.name=JUnit
junit.configuration.fork.mode.class=Clase
junit.configuration.fork.mode.method=Método
junit.configuration.fork.mode.none=Ninguno
junit.configuration.fork.mode.repeat=Repetir
junit.configuration.in.single.module.radio=En un solo &módulo
junit.configuration.in.whole.project.radio=En todo el &proyecto
junit.configuration.kind.all.in.directory=Todo en el directorio
junit.configuration.kind.all.in.package=Todo en el paquete
junit.configuration.kind.by.pattern=Patrón
junit.configuration.kind.by.tags=Etiquetas
junit.configuration.kind.by.unique.id=ID único
junit.configuration.kind.category=Categoría
junit.configuration.kind.class=Clase
junit.configuration.kind.method=Método
junit.configuration.method.label=M&étodo:
junit.configuration.package.label=Pa&quete:
junit.configuration.repeat.mode.n.times=N veces
junit.configuration.repeat.mode.once=Una vez
junit.configuration.repeat.mode.until.failure=Hasta que falle
junit.configuration.repeat.mode.until.stopped=Hasta que se detenga
junit.configuration.repeat.mode.until.success=Hasta que tenga éxito
junit.configuration.search.for.tests.label=Buscar pruebas:
junit.entry.point.suggest.package.private.visibility.junit5=Sugerir el nivel de visibilidad package-private para las pruebas de JUnit 5
junit.inspections.group.name=JUnit
junit.not.found.in.module.error.message=No se encontró JUnit en el módulo ''{0}''
junit3.style.test.method.in.junit4.class.display.name=Método de prueba JUnit de estilo antiguo en una clase JUnit 4
junit3.style.test.method.in.junit4.class.problem.descriptor=Método de prueba JUnit de estilo antiguo <code>#ref()</code> en la clase JUnit 4 #loc
junit5.migration.description=Para transferir las anotaciones de prueba de JUnit 4 a las nuevas de Jupiter, ¡lo que puede dar como resultado código en rojo! Las aserciones no se migrarán. Consulte la inspección 'JUnit | La prueba de JUnit 4 puede ser JUnit 5' para migrar únicamente las pruebas que se puedan convertir de forma totalmente automática.
jvm.inspections.junit.assertequals.may.be.assertsame.display.name=assertEquals()' puede ser 'assertSame()
jvm.inspections.junit.assertequals.may.be.assertsame.problem.descriptor=<code>#ref()</code> puede ser 'assertSame()' #loc
jvm.inspections.junit.assertequals.on.array.display.name='assertEquals()' llamado en un array
jvm.inspections.junit.assertequals.on.array.problem.descriptor=<code>#ref()</code> invocado en un array #loc
jvm.inspections.junit.ignored.test.class.problem.descriptor=La clase de prueba ''{0}'' está ignorada/deshabilitada {1, choice, 1#|2#sin motivo} #loc
jvm.inspections.junit.ignored.test.display.name=Prueba JUnit anotada con '@Ignore'/'@Disabled'
jvm.inspections.junit.ignored.test.ignore.reason.option=Informar solo las anotaciones sin motivo
jvm.inspections.junit.ignored.test.method.problem.descriptor=El método de prueba ''{0}()'' está ignorado/desactivado{1, choice, 1#|2# sin motivo} #loc
jvm.inspections.junit.malformed.annotated.double.descriptor={0, choice, 0#El campo|1#El método} <code>#ref</code> anotado con ''@{1}'' debe ser {2} y {3}
jvm.inspections.junit.malformed.annotated.double.typed.descriptor={0, choice, 0#El campo|1#El método} <code>#ref</code> anotado con ''@{1}'' debe ser {2}, {3} y de tipo ''{4}''
jvm.inspections.junit.malformed.annotated.method.double.param.double.descriptor=El método <code>#ref</code> anotado con ''@{0}'' debe ser {1}, {2} y no declarar los parámetros ''{3}'' y ''{4}''
jvm.inspections.junit.malformed.annotated.method.double.param.single.descriptor=El método <code>#ref</code> anotado con ''@{0}'' debe ser {1}, {2} y no declarar el parámetro ''{3}''
jvm.inspections.junit.malformed.annotated.method.double.typed.param.double.descriptor=El método <code>#ref</code> anotado con ''@{0}'' debe ser {1}, {2}, de tipo ''{3}'' y no declarar los parámetros {4} y ''{5}''
jvm.inspections.junit.malformed.annotated.method.double.typed.param.single.descriptor=El método <code>#ref</code> anotado con ''@{0}'' debería ser {1}, {2}, de tipo ''{3}'' y no declarar el parámetro ''{4}''
jvm.inspections.junit.malformed.annotated.method.param.double.descriptor=El método <code>#ref</code> anotado con ''@{0}'' no debe declarar los parámetros {1} y ''{2}''
jvm.inspections.junit.malformed.annotated.method.param.single.descriptor=El método <code>#ref</code> anotado con ''@{0}'' no debe declarar el parámetro ''{1}''
jvm.inspections.junit.malformed.annotated.method.single.param.double.descriptor=El método <code>#ref</code> anotado con ''@{0}'' debería ser {1} y no declarar los parámetros ''{2}'' y ''{3}''
jvm.inspections.junit.malformed.annotated.method.single.param.single.descriptor=El método <code>#ref</code> anotado con ''@{0}'' debe ser {1} y no debe declarar el parámetro ''{2}''
jvm.inspections.junit.malformed.annotated.method.single.typed.param.double.descriptor=El método <code>#ref</code> anotado con ''@{0}'' debe ser {1}, de tipo ''{2}'' y no declarar los parámetros {3} y ''{4}''
jvm.inspections.junit.malformed.annotated.method.single.typed.param.single.descriptor=El método <code>#ref</code> anotado con ''@{0}'' debe ser {1}, de tipo ''{2}'' y no declarar el parámetro ''{3}''
jvm.inspections.junit.malformed.annotated.method.typed.param.double.descriptor=El método <code>#ref</code> anotado con ''@{0}'' debe ser de tipo ''{1}'' y no declarar los parámetros {2} y ''{3}''
jvm.inspections.junit.malformed.annotated.method.typed.param.single.descriptor=El método <code>#ref</code> anotado con ''@{0}'' debe ser de tipo ''{1}'' y no declarar el parámetro ''{2}''
jvm.inspections.junit.malformed.annotated.single.descriptor={0, choice, 0#El campo|1#El método} <code>#ref</code> anotado con ''@{1}'' debe ser {2}
jvm.inspections.junit.malformed.annotated.single.typed.descriptor={0, choice, 0#El campo|1#El método} <code>#ref</code> anotado con ''@{1}'' debe ser {2} y de tipo ''{3}''
jvm.inspections.junit.malformed.annotated.suspend.function.descriptor=El método <code>#ref</code> anotado con ''@{0}'' no debe ser una función de suspensión
jvm.inspections.junit.malformed.annotated.typed.descriptor={0, choice, 0#Campo|1#Método} <code>#ref</code> anotado con ''@{1}'' debe ser de tipo ''{2}''
jvm.inspections.junit.malformed.declaration.name=Declaración de JUnit mal formada
jvm.inspections.junit.malformed.extension.class.level.descriptor={0} debe registrarse a nivel de clase
jvm.inspections.junit.malformed.fix.class.signature=Corregir firma de la clase
jvm.inspections.junit.malformed.fix.class.signature.descriptor=Corregir firma de la clase ''{0}''
jvm.inspections.junit.malformed.fix.class.signature.multi=Corregir firmas de clase
jvm.inspections.junit.malformed.fix.field.signature=Corregir la firma del campo
jvm.inspections.junit.malformed.fix.field.signature.descriptor=Corregir la firma del campo ''{0}''
jvm.inspections.junit.malformed.fix.method.signature=Corregir la firma del método
jvm.inspections.junit.malformed.fix.method.signature.descriptor=Corregir la signatura del método ''{0}''
jvm.inspections.junit.malformed.missing.nested.annotation.descriptor=Las pruebas en la clase anidada no se ejecutarán
jvm.inspections.junit.malformed.no.arg.descriptor=El método <code>#ref</code> debe ser {0}, {1}{2, choice, 0# y no tener parámetros|1#, no tener parámetros y ser de tipo void}
jvm.inspections.junit.malformed.option.ignore.test.parameter.if.annotated.by=Ignorar el parámetro de prueba si está anotado por:
jvm.inspections.junit.malformed.param.duplicated.enum.descriptor=Nombre de constante 'enum' duplicado
jvm.inspections.junit.malformed.param.empty.source.unsupported.descriptor=''@{0}'' no puede proporcionar un argumento al método porque el método tiene un parámetro de tipo ''{1}'' no compatible
jvm.inspections.junit.malformed.param.exactly.one.type.of.input.must.be.provided.descriptor=Se debe proporcionar exactamente un tipo de entrada
jvm.inspections.junit.malformed.param.file.source.descriptor=No se puede resolver el origen del archivo: ''{0}''
jvm.inspections.junit.malformed.param.method.source.assignable.descriptor=No se encontró ninguna conversión implícita para convertir ''{0}'' a ''{1}''
jvm.inspections.junit.malformed.param.method.source.no.params.descriptor=La fuente de método ''{0}'' no debe tener parámetros
jvm.inspections.junit.malformed.param.method.source.return.type.descriptor=La fuente del método ''{0}'' debe tener uno de los siguientes tipos de retorno: ''Stream<?>'', ''Iterator<?>'', ''Iterable<?>'' o ''Object[]''
jvm.inspections.junit.malformed.param.method.source.static.descriptor=El origen del método ''{0}'' debe ser static
jvm.inspections.junit.malformed.param.method.source.unresolved.descriptor=No se puede resolver el origen del método destino: ''{0}''
jvm.inspections.junit.malformed.param.multiple.parameters.descriptor=Solo se puede proporcionar un único parámetro mediante ''@{0}''
jvm.inspections.junit.malformed.param.no.sources.are.provided.descriptor=No se han proporcionado fuentes, la suite estaría vacía
jvm.inspections.junit.malformed.param.no.value.source.is.defined.descriptor=No se ha definido el origen de valores
jvm.inspections.junit.malformed.param.unresolved.enum.descriptor=No se puede resolver la referencia a la constante 'enum'.
jvm.inspections.junit.malformed.param.wrapped.in.arguments.descriptor=Múltiples parámetros deben estar envueltos en 'Arguments'
jvm.inspections.junit.malformed.repetition.number.descriptor=El número de repeticiones debe ser mayor que cero
jvm.inspections.junit.malformed.source.without.params.descriptor=''@{0}'' no puede proporcionar un argumento al método porque el método no tiene parámetros
jvm.inspections.junit.malformed.suspend.function.descriptor=El método <code>#ref</code> no debe ser una función de suspensión
jvm.inspections.junit.malformed.test.combination.descriptor=Combinación sospechosa de {0} y ''@{1}''
jvm.inspections.junit.mixed.annotations.junit.descriptor=Método <code>#ref()</code> anotado con ''@{0}'' dentro de una clase que extiende JUnit {1} TestCase #loc
jvm.inspections.junit.mixed.annotations.name=Uso de múltiples versiones de la API de JUnit en un único TestCase
jvm.inspections.junit3.super.teardown.display.name=JUnit 3 'super.tearDown()' no se llama desde el bloque 'finally'
jvm.inspections.junit3.super.teardown.problem.descriptor=<code>#ref()</code> no se llama desde el bloque 'finally' #loc
jvm.inspections.junit4.converter.display.name=La prueba de JUnit 3 puede ser JUnit 4
jvm.inspections.junit4.converter.problem.descriptor=<code>#ref</code> se puede convertir en un caso de prueba JUnit4
jvm.inspections.junit4.converter.quickfix.conflict.call.compile=La llamada al método {0} no compilará cuando {1} se convierta a JUnit 4
jvm.inspections.junit4.converter.quickfix.conflict.name=El método {0} tendrá un conflicto de nombres con su supermétodo
jvm.inspections.junit4.converter.quickfix.conflict.semantics=La llamada al método {0} puede cambiar la semántica cuando {1} se convierte a JUnit 4
jvm.inspections.junit4.converter.quickfix.conflict.suite=La migración del método suite para {0} tiene efectos secundarios que se eliminarán
jvm.inspections.junit4.converter.quickfix.name=Convertir a caso de prueba JUnit 4
jvm.inspections.junit4.inherited.runwith.display.name=La anotación '@RunWith' ya existe en una clase padre
jvm.inspections.junit4.inherited.runwith.problem.descriptor=La anotación ''@RunWith'' ya existe en la clase {0}
jvm.inspections.junit5.assertions.converter.display.name=Aserciones obsoletas de JUnit 5
jvm.inspections.junit5.assertions.converter.familyName=Sustituir por una llamada compatible con JUnit 5
jvm.inspections.junit5.assertions.converter.problem.descriptor=La llamada a <code>#ref()</code> desde ''{0}'' debe reemplazarse por una llamada a un método de ''{1}'' #loc
jvm.inspections.junit5.assertions.converter.quickfix=Reemplazar con la llamada al método ''{0}''
jvm.inspections.junit5.converter.display.name=La prueba de JUnit 4 puede ser JUnit 5
jvm.inspections.junit5.converter.problem.descriptor=#ref puede ser un test de JUnit 5
jvm.inspections.junit5.converter.quickfix=Migrar a JUnit 5
jvm.inspections.junit5.converter.quickfix.conflict.inheritor=La clase {0} no se puede convertir a JUnit 5 porque hay herederos incompatibles: {1}
jvm.inspections.junit5.converter.quickfix.presentation.text=Convertir aserciones
jvm.inspections.migrate.assert.to.matcher.description=La expresión de aserción <code>#ref</code> se puede reemplazar por la llamada a ''{0}'' #loc
jvm.inspections.migrate.assert.to.matcher.option=Importar estáticamente los métodos del matcher
jvm.inspections.migrate.assertion.name=La aserción de JUnit puede ser una llamada a 'assertThat()'
jvm.inspections.unconstructable.test.case.junit3.descriptor=La clase de prueba <code>#ref</code> no se puede construir porque no tiene un constructor 'public' sin argumentos o con un único parámetro 'String' #loc
jvm.inspections.unconstructable.test.case.junit4.descriptor=La clase de prueba <code>#ref</code> no se puede construir porque debe tener exactamente un constructor 'public' sin argumentos #loc
jvm.inspections.unconstructable.test.case.not.public.descriptor=La clase de prueba <code>#ref</code> no se puede construir porque no es 'public' #loc
method.name.not.specified.error.message=No se ha especificado el nombre del método
module.does.not.exists=El módulo ''{0}'' no existe en el proyecto ''{1}''
module.to.choose.classpath.not.specified.error.message=No se ha especificado el módulo para elegir el classpath
multiple.exceptions.declared.on.test.method.display.name=Múltiples excepciones declaradas en el método de prueba
multiple.exceptions.declared.on.test.method.problem.descriptor=<code>#ref</code> se puede reemplazar por 'throws Exception' #loc
no.module.selected.error.message=No se ha seleccionado ningún módulo
no.pattern.error.message=No se ha seleccionado ningún patrón
no.test.class.specified.error.text=No se ha especificado ninguna clase de prueba
package.does.not.exist.error.message=El paquete ''{0}'' no existe
pattern.label=Patrón
progress.title.download.additional.dependencies=Descargando dependencias adicionales…
repeat.count.label=&Número de repeticiones:
repeat.label=&Repetir:
repeat.name=Repetir
running.tests.disabled.during.index.update.error.message=La ejecución de pruebas está desactivada durante la actualización del índice
search.scope.module=En un solo módulo
search.scope.module.deps=En las dependencias del módulo
search.scope.name=Buscar pruebas
search.scope.project=En todo el proyecto
tag.expression.label=Expresión de etiqueta
tag.name.0.must.be.syntactically.valid.warning=El nombre de la etiqueta [{0}] debe ser sintácticamente válido
tags.are.not.specified.error.message=No se han especificado etiquetas
test.class.hint=El nombre completo calificado de una clase que contiene pruebas
test.discovery.by.all.changes.combo.item=Todos
test.group=Pruebas
test.kind.hint=El tipo de recurso para buscar pruebas
test.method.doesnt.exist.error.message=El método de prueba ''{0}'' no existe
test.method.hint=El nombre totalmente cualificado de un método de prueba
test.package.hint=Nombre del paquete que contiene las pruebas
test.pattern.hint=Una expresión regular para coincidir con los nombres de las clases que contienen pruebas
uniqueid.label=ID único
unused.declaration.junit.test.entry.point=Casos de prueba JUnit
usage.of.obsolete.assert.display.name=Uso del método obsoleto 'junit.framework.Assert'
use.of.obsolete.assert.problem.descriptor=La llamada a <code>#ref()</code> desde ''{0}'' debe sustituirse por una llamada a un método de ''org.junit.Assert'' #loc
use.of.obsolete.assert.quickfix=Reemplazar por una llamada al método 'org.junit.Assert'
