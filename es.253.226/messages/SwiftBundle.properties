action.Swift.ExtractFunction.text=Extraer función…
action.Swift.FormatFileWithSwiftFormat.text=Reformatear código con Swift Format
action.Swift.Generate.DebugDescription.description=Generar debugDescription
action.Swift.Generate.DebugDescription.text=DebugDescription…
action.Swift.Generate.Description.description=Generar descripción
action.Swift.Generate.Description.text=Descripción…
action.Swift.Generate.EqualsHashValue.description=Generar equals y hash
action.Swift.Generate.EqualsHashValue.text=Equals y hash
action.Swift.Generate.Init.description=Generar inicializador
action.Swift.Generate.Init.text=Inicializador
action.Swift.GenerateDocComment.text=Generar comentario de documentación
action.Swift.IntroduceClosureVariable.text=Extraer variable de clausura…
action.Swift.NewFile.description=Crear nuevo Archivo o Tipo Swift
action.Swift.NewFile.text=Nuevo archivo o tipo Swift
action.Swift.ShowSwiftIDETest.text=Ejecutar informe de Swift IDE
action.Swift.SwiftFormatCreateConfigFileAction.text=Crear archivo de configuración de Swift Format
action.Swift.ToggleErrorHints.text=Mostrar sugerencias de error
action.Swift.ToggleGlobalErrorHints.text=Mostrar sugerencias de errores de Swift
action.Swift.ToggleGlobalTypeHints.text=Mostrar sugerencias de tipo de Swift
action.Swift.ToggleTypeHints.text=Mostrar sugerencias de tipo
auto.import.command.name=Importar módulos automáticamente
auto.import.completion.presentation.tail.from.0=(de {0})
auto.import.settings.checkbox.sort=Ordenar importaciones
auto.import.settings.import.symbol=Importar automáticamente símbolos específicos
auto.import.settings.import.symbol.help=Al importar símbolos automáticamente, es preferible añadir la importación del propio símbolo en lugar de importar el módulo completo que lo declara.
auto.import.settings.optimize.non.module=Optimizar importaciones de elementos que no son módulos
auto.import.settings.optimize.non.module.help=Al optimizar las importaciones, sustituye las importaciones explícitas de funciones, estructuras, clases, etc., por la importación de su módulo primario
call.hierarchy.usage.in=Uso en ''{0}''
change.info.async.throws.label=async/throws:
change.info.default.value.code.comment=Valor por defecto = {0}
change.info.default.value.label=Valor predeterminado:
change.info.dialog.invalid.function.name.0=Nombre de función no válido: ''{0}''
change.info.dialog.invalid.parameter.internal.name.0=Nombre interno del parámetro no válido: ''{0}''
change.info.dialog.invalid.parameter.name.0=Nombre de parámetro no válido: ''{0}''
change.info.dialog.no.function.name.specified=No se ha especificado el nombre de la función
change.info.dialog.parameter.after.variadic.should.have.nonempty.name=El parámetro que sigue a un parámetro variádico debe tener un nombre no vacío
change.info.dialog.rethrows.should.have.throwing.parameter=La función 'rethrows' debe tener un parámetro de función que lance errores
change.info.internal.name.label=Nombre interno:
change.info.name.label=Nombre:
change.info.optional.label=Opcional:
change.info.options.label=Opciones
change.info.return.type.label=Tipo de retorno:
change.info.type.label=Tipo:
change.signature.0.1.will.no.longer.be.visible.from.overriding.0.in.2.3=El {0} ''{1}'' ya no será visible desde la sobrescritura del {0} en {2} ''{3}''
change.signature.0.1.with.2.visibility.wont.be.accessible.from.3.4={0} ''{1}'' con visibilidad ''{2}'' no será accesible desde {3} ''{4}''
change.signature.0.can.throw.but.thrown.errors.are.not.handled=''{0}'' puede lanzar, pero los errores lanzados no se manejan
change.signature.0.is.async.but.not.awaited=''{0}'' espera una llamada, pero no está marcado como async
change.signature.dialog.title=Cambiar firma
change.signature.initializer.will.conflict.with.0.in.1.2=El inicializador entrará en conflicto con {0} en {1} ''{2}''
change.signature.processed.elements.header=Elementos para cambiar la firma
change.signature.subscript.will.conflict.with.0.in.1.2=El subíndice entrará en conflicto con {0} en {1} ''{2}''
change.signature.target.not.found=El cursor debe estar en una función, un inicializador o un subíndice
change.signature.title=Cambiar firma
code.style.blank.lines.around.class=Alrededor de declaraciones de tipo:
code.style.blank.lines.around.field=Alrededor de la propiedad:
code.style.blank.lines.around.field.in.protocol=Alrededor de las propiedades en el protocolo:
code.style.blank.lines.around.method=Alrededor de métodos/funciones:
code.style.blank.lines.around.method.in.protocol=Alrededor de métodos/funciones en el protocolo:
code.style.blank.lines.before.method.body=Antes del cuerpo del método/función:
code.style.code.generation.doc.comment.style=Preferir comentarios de documentación de bloque (/** */) en lugar de línea (///)
code.style.code.generation.doc.comment.tag.delimiter=Delimitador de elementos de lista:
code.style.code.generation.prefer.explicit.return=Preferir retorno explícito(&R)
code.style.code.generation.prefer.void=Preferir Void en lugar de ()(&V)
code.style.code.generation.tab.title=Generación de código
code.style.indent.directives.as.code=Seguir la sangría del código
code.style.indent.directives.children=Indentar elementos secundarios
code.style.indent.group.title.directives=Directivas
code.style.indent.method.chain=Sangría de métodos encadenados:
code.style.indent.multiline.string.or.regex=Indentar cadenas multilínea o expresiones regulares
code.style.spaces.after.argument.colon=Después de los dos puntos en llamadas a métodos/funciones
code.style.spaces.after.dictionary.literal.colon=Después de los dos puntos en el literal de diccionario 'key:value'
code.style.spaces.after.dictionary.type.colon=Tras los dos puntos en el tipo de diccionario
code.style.spaces.after.operator.in.function.declarations=Operadores en declaraciones de función
code.style.spaces.after.semicolon=Después del punto y coma
code.style.spaces.after.superclass.colon=Después de los dos puntos en la cláusula de herencia de tipos
code.style.spaces.after.type.colon=Después de los dos puntos en la anotación de tipo
code.style.spaces.around.range.operators=Operadores de rango (…, ..<)
code.style.spaces.attribute.parameters=Parámetros de atributo
code.style.spaces.attribute.parentheses=Paréntesis de atributo
code.style.spaces.before.argument.colon=Antes de los dos puntos en llamadas a métodos/funciones
code.style.spaces.before.class.lbrace=Antes de la llave de apertura de la clase
code.style.spaces.before.dictionary.literal.colon=Antes de los dos puntos en pares 'key:value' de literales de diccionario
code.style.spaces.before.dictionary.type.colon=Antes de los dos puntos en el tipo de diccionario
code.style.spaces.before.method.call.parentheses=Paréntesis de llamada a método/función
code.style.spaces.before.method.lbrace=Llave de apertura de método/función
code.style.spaces.before.method.parentheses=Paréntesis de declaración de método/función
code.style.spaces.before.semicolon=Antes del punto y coma
code.style.spaces.before.superclass.colon=Antes de los dos puntos en la cláusula de herencia de tipos
code.style.spaces.before.type.colon=Antes de los dos puntos en anotaciones de tipo
code.style.spaces.closure.arrow=Flecha de clausura (->)
code.style.spaces.equality.operator=Operador de igualdad '=='
code.style.spaces.group.title.colon=Alrededor de los dos puntos
code.style.spaces.group.title.in.ternary=En el operador ternario
code.style.spaces.shift.operators=Operadores de desplazamiento (<<, >>)
code.style.spaces.within.empty.method.call.parentheses=Paréntesis de llamada a método/función vacíos
code.style.spaces.within.empty.method.parentheses=Entre paréntesis de declaración de método/función vacíos
code.style.spaces.within.literal.brackets=Corchetes de literales de matriz y diccionario
code.style.spaces.within.method.call.parentheses=Paréntesis de llamada a método/función
code.style.spaces.within.method.parentheses=Paréntesis de declaración de método/función
code.style.spaces.within.string.interpolations=Espacios dentro de interpolaciones de cadenas
code.style.wrapping.align.in.columns=Alinear en columnas
code.style.wrapping.align.when.multiline=Alinear si hay varias líneas
code.style.wrapping.array.literal=Literales de array y diccionario
code.style.wrapping.array.new.line.after.left.bracket=Nueva línea después de '['
code.style.wrapping.array.right.bracket.on.new.line=Colocar ']' en una nueva línea
code.style.wrapping.brace.placement.class.declaration=En la declaración de clase
code.style.wrapping.classes.annotation=Anotaciones de declaración de tipos
code.style.wrapping.closure.signature.on.next.line=Parámetros en una línea nueva si hay varias líneas
code.style.wrapping.fields.annotation=Anotaciones de propiedades
code.style.wrapping.group.title.closure=Clausura
code.style.wrapping.group.title.condition.clauses=Cláusulas de condición
code.style.wrapping.group.title.do.while=Sentencia 'repeat … while'
code.style.wrapping.group.title.guard=Sentencia 'guard'
code.style.wrapping.group.title.if=Sentencia 'if'
code.style.wrapping.group.title.method.arguments=Argumentos de llamada a método/función
code.style.wrapping.group.title.method.parameters=Parámetros de declaración de método/función
code.style.wrapping.group.title.superclass.list=Lista de clases base y protocolos adoptados
code.style.wrapping.group.title.ternary=Operación condicional ternaria
code.style.wrapping.group.title.try=Sentencia 'do'
code.style.wrapping.group.title.variable.groups=Grupos de variables
code.style.wrapping.guard.else=Else
code.style.wrapping.guard.else.always=Ajustar siempre
code.style.wrapping.guard.else.never=No ajustar
code.style.wrapping.guard.else.wrapped=Ajuste condicional
code.style.wrapping.keep.control.statement.in.one.line=Mantener la sentencia de control en una línea
code.style.wrapping.keep.simple.argument.blocks.in.one.line=Mantener bloques de argumentos de clausura simples en una línea
code.style.wrapping.keep.simple.blocks.in.one.line=Bloques y clausuras (finales) en una sola línea
code.style.wrapping.keep.simple.methods.in.one.line=Mantener métodos y funciones simples en una sola línea
code.style.wrapping.local.variables.annotation=Anotaciones de variables locales
code.style.wrapping.method.brace.placement=En métodos y funciones
code.style.wrapping.method.chain.dot.on.new.line='.' en una nueva línea
code.style.wrapping.methods.annotation=Anotaciones de método
code.style.wrapping.parameters.annotation=Anotaciones de parámetros
code.style.wrapping.structures.in.one.line=Declaraciones de tipos vacíos en una sola línea
color.conditionally.not.compiled=Palabras clave y directivas//Código no compilado condicionalmente
color.settings.actor=Tipo//Actor
color.settings.anonymous.closure.parameter=Identificador//Parámetro de clausura anónima
color.settings.argument.label=Identificador // Etiqueta de argumento
color.settings.associated.type=Tipo//Tipo asociado
color.settings.attribute.argument=Argumento de atributo
color.settings.attribute.name=Nombre del atributo
color.settings.class=Clase
color.settings.colon=Llaves y operadores//Dos puntos
color.settings.directive=Palabras clave y directivas//Directiva
color.settings.directive.condition=Palabras clave y directivas//Condición de directiva
color.settings.directive.flag=Palabras clave y directivas//Marca de directiva
color.settings.enum.case.value=Identificador//Valor de caso de enumeración
color.settings.external.parameter.name=Identificador//Nombre de parámetro externo
color.settings.function.and.method.call=Llamada a funciones y métodos
color.settings.function.and.method.declaration=Función//Declaración de función y método
color.settings.inline.closure.parameter=Identificador//Parámetro de clausura en línea
color.settings.inline.hints.error.hint=Sugerencias insertadas//Sugerencia de error
color.settings.inline.hints.type.hint=Sugerencias inline//Sugerencias de tipo
color.settings.keyword=Palabras clave y directivas//Palabras clave
color.settings.module.name=Tipo//Nombre del módulo
color.settings.nested.function.call=Función//Llamada a función anidada
color.settings.nested.function.declaration=Función//Declaración de función anidada
color.settings.operator.sign=Llaves y operadores//Signo de operador
color.settings.property=Identificador//Propiedad
color.settings.protocol=Tipo//Protocolo
color.settings.self.and.super.keywords=Palabras clave y directivas//'self' y 'super'
color.settings.struct.and.enum=Tipo//Estructura y enumeración
color.settings.tuple.label=Identificador // Etiqueta de tupla
color.settings.tuple.type.label=Identificador//Etiqueta de tipo de tupla
color.settings.type.alias=Tipo//Alias de tipo
color.settings.type.parameter=Tipo//Parámetro genérico
color.settings.wildcard=Identificador//Comodín
command.name.extract.function=Extraer función
context.declaration=Declaración
context.statement=Sentencia
create.file.action=Crear archivo Swift {0}
create.file.description=Crea un nuevo archivo Swift
create.file.dialog.title=Nuevo archivo Swift
create.file.kind=Tipo(&K):
create.file.kind.file=Archivo
create.file.title=Archivo Swift
create.file.type.description=Crea un nuevo tipo de Swift
create.file.type.dialog.title=Nuevo tipo Swift
create.file.type.dialog.title.with.kind=Nuevo {0} de Swift
create.file.type.title=Tipo Swift
create.from.usage.choose.target.type=Seleccionar tipo de destino
create.from.usage.create.function.command=Crear función a partir del uso
create.from.usage.create.init.command=Crear inicializador a partir del uso
create.from.usage.create.type.command=Crear nuevo tipo Swift
create.from.usage.create.variable.command=Crear variable a partir del uso
create.from.usage.location.in=(en {0})
create.from.usage.location.new.file=Nuevo archivo
create.from.usage.location.this.file=Este archivo
doc.comments.enable.markdown=Habilite el complemento Markdown para dar formato a los comentarios de documentación
editor.appearance.error.hints=Mostrar sugerencias de errores de Swift
editor.appearance.type.hints=Mostrar sugerencias de tipo de Swift
error.cannot.perform.refactoring=No se puede realizar la refactorización
error.no.expression.found=No se encontró ninguna expresión
extract.method.0.1.will.be.shadowed.by.2.1={0} ''{1}'' será ocultado por {2} ''{1}''
extract.method.at.least.two.parameters.have.name.0=Al menos dos parámetros tienen el nombre ''{0}''
extract.method.cannot.extract.mutable.value=No se puede extraer un valor mutable
extract.method.error.cannot.determine.expr.type=No se puede determinar el tipo de la expresión seleccionada.
extract.method.error.cannot.determine.function.result.type=No se puede determinar el tipo de resultado de la función.
extract.method.error.cannot.determine.parameters.type=No se puede determinar el tipo de los parámetros
extract.method.error.cannot.extract.expr.with.var.declarations=No se puede extraer de una expresión con declaraciones de variables
extract.method.error.cannot.extract.with.returns=No se puede extraer una función que contenga instrucciones de retorno dentro del fragmento de código
extract.method.error.fragment.should.be.inside.code.block=El fragmento seleccionado debe estar dentro de un bloque de código.
extract.method.error.multiple.exit.points=El fragmento de código seleccionado tiene múltiples puntos de salida.
extract.method.error.result.builder.block=No se puede extraer la función de una clausura de result builder
extract.method.error.should.represent.expr.or.statements=El bloque seleccionado debe representar un conjunto de sentencias o expresiones.
extract.method.function.0.will.conflict.with.1.2=La función ''{0}'' entrará en conflicto con {1} {2}
extract.method.method.0.will.conflict.with.1.in.2.3=El método ''{0}'' entrará en conflicto con {1} en {2} ''{3}''
extract.method.title.closure=Extraer closure
extract.method.title.function=Extraer función
extract.method.title.method=Extraer método
extract.method.variable.0.will.no.longer.be.accessible=La variable ''{0}'' ya no será accesible tras la refactorización
find.usages.base.member.warning.message.default.implementation.method={0} es la implementación predeterminada del método declarado en {1}\n\n¿Desea buscar los usos del {3, choice, 1#método|2#método} del protocolo?
find.usages.base.member.warning.message.default.implementation.property={0} es la implementación predeterminada de la propiedad declarada en {1}\n\n¿Desea buscar usos de la {3, choice, 1#propiedad|2#propiedades} del protocolo?
find.usages.base.member.warning.message.default.implementation.subscript={0} es la implementación predeterminada del subíndice declarado en {1}\n\n¿Desea buscar los usos del {3,choice,1#subíndice|2#subíndices} del protocolo?
find.usages.base.member.warning.message.implements.method={0} implementa el método declarado en {1}\n\n¿Desea buscar los usos del {3,choice,1#método|2#métodos} del protocolo?
find.usages.base.member.warning.message.implements.property={0} implementa la propiedad declarada en {1}\n\n¿Desea buscar los usos de la {3,choice,1#propiedad|2#propiedades} del protocolo?
find.usages.base.member.warning.message.implements.subscript={0} implementa el subíndice declarado en {1}\n\n¿Desea buscar los usos del {3,choice,1#subííndice|2#subíndices} del protocolo?
find.usages.base.member.warning.message.override.implemented.method={0} sobrescribe el método declarado en {2} e implementa el método declarado en {1}\n\n¿Desea buscar usos del {3,choice,1#método|2#métodos} base y de protocolo?
find.usages.base.member.warning.message.override.implemented.property={0} sobrescribe la propiedad declarada en {2} e implementa la propiedad declarada en {1}\n\n¿Desea buscar usos de la {3,choice,1#propiedad|2#propiedades} de base y protocolo?
find.usages.base.member.warning.message.override.implemented.subscript={0} sobrescribe el subíndice declarado en {2} e implementa el subíndice declarado en {1}\n\n¿Desea buscar usos del {3,choice,1#subíndice|2#subíndices} de base y protocolo?
find.usages.base.member.warning.message.override.method={0} sobrescribe el método declarado en {2}\n\n¿Desea buscar los usos del {3,choice,1#método|2#métodos} base?
find.usages.base.member.warning.message.override.property={0} sobrescribe la propiedad declarada en {2}\n\n¿Desea buscar los usos de la {3,choice,1#propiedad|2#propiedades} base?
find.usages.base.member.warning.message.override.subscript={0} sobrescribe el subíndice declarado en {2}\n\n¿Desea buscar usos del {3,choice,1#subíndice|2#subíndices} base?
find.usages.base.member.warning.title=Advertencia
find.usages.option.search.in.not.compiled.code=Mostrar usos potenciales en código no compilado condicionalmente
generate.0.title=Generar {0}
generate.cannot.generate.0.for.1=No se puede generar {0} para {1}
generate.description.multi.string.template=Cadena de varias líneas
generate.description.single.string.template=Cadena única
generate.description.string.concatenation.template=Múltiples cadenas con concatenación (+)
generate.equals.hash=equals y hash
generate.equals.hash.choose.in.0=Seleccionar las propiedades para incluir en {0}
generate.if.statements.equals.template=Múltiples sentencias if
generate.init.choose.properties=Seleccionar propiedades para inicializar
generate.init.choose.super.init=Seleccionar inicializador de la superclase
generate.init.init.already.exists=El inicializador ya existe
generate.method.0.and.operator.function.1.are.already.defined=El método ''{0}'' y la función de operador ''{1}'' ya están definidos. ¿Desea eliminarlos y continuar?
generate.method.0.and.property.1.are.already.defined=El método ''{0}'' y la propiedad ''{1}'' ya están definidos. ¿Desea eliminarlos y continuar?
generate.method.0.is.already.defined=El método ''{0}'' ya está definido. ¿Desea eliminarlo y continuar?
generate.method.0.property.1.and.operator.function.2.are.already.defined=El método ''{0}'', la propiedad ''{1}'' y la función de operador ''{2}'' ya están definidos. ¿Desea eliminarlos y continuar?
generate.operator.function.0.is.already.defined=La función de operador ''{0}'' ya está definida. ¿Desea eliminarla y continuar?
generate.preparing.generation.title=Preparando la generación…
generate.property.0.and.operator.function.1.are.already.defined=La propiedad ''{0}'' y la función de operador ''{1}'' ya están definidas. ¿Desea eliminarlas y continuar?
generate.property.0.is.already.defined=La propiedad ''{0}'' ya está definida. ¿Desea eliminarla y continuar?
generate.single.expression.equals.template=Expresión única
generate.template.title=Plantilla(&T):
got.it.no.refactoring.in.not.compiled.code.header=La acción de refactorización no está disponible
got.it.no.refactoring.in.not.compiled.code.message=Las acciones de refactorización no están disponibles en código no compilado condicionalmente. Cambie a un contexto de resolución diferente para habilitar la rama de la directiva `#if` circundante.
got.it.search.not.compiled.code.header=Usos en código no compilado condicionalmente
got.it.search.not.compiled.code.message=La búsqueda de usos en el código no compilado condicionalmente se puede habilitar desde el diálogo "Cambiar nombre". Para mostrar el diálogo "Cambiar nombre", presione {0} de nuevo.
goto.base.type=Tipo base
goto.class.kind=Tipo
goto.class.kinds.title=Tipo
goto.super.action=Seleccionar {0}
goto.super.class=Superclase o protocolo
goto.super.extension.of.0=Extensión de {0}
goto.super.location={0} (en {1})
goto.super.menu.action={0} superior(_U)
goto.super.typealias=Alias de tipo o tipo asociado
inheritance.relation.implements=Implementa {0}
inheritance.relation.is.implemented=Implementado
inheritance.relation.is.overridden=Sobrescrito
inheritance.relation.is.subclassed=Subclasificado
inheritance.relation.overrides=Sobrescribe {0}
inline.0.action.1=Integrando en línea {0} {1}
inline.0.command.1=Inlineando {0} {1}
inline.all.invocations.and.keep.the.0=Inlinear todas las invocaciones y mantener {0}(&A)
inline.all.invocations.and.remove.the.0=Incrustar todas las invocaciones y eliminar {0}(&A)
inline.all.references.and.keep.the.0=Sustituir todas las referencias y conservar {0}(&A)
inline.all.references.and.remove.the.0=Inlinear todas las referencias y eliminar {0}(&A)
inline.all.typealias.and.keep.the.0=Sustituir todos los alias de tipo y mantener {0}(&A)
inline.all.typealias.and.remove.the.0=Sustituir todo y eliminar {0}(&A)
inline.error.cannot.access.symbol.0=No se puede acceder al símbolo {0}
inline.error.cannot.resolve.symbol=No se puede resolver el símbolo
inline.error.function.definition.contains.no.body=La definición de la función no contiene cuerpo
inline.error.function.no.return.statement=La función no tiene una sentencia return
inline.error.implements.function.from.0=El método en línea implementa un método de {0}
inline.error.inline.function.has.conditionally.compiled.code=Es posible que la función no se inserte en línea correctamente porque contiene código no compilado condicionalmente
inline.error.inline.function.only.in.swift.code=La inserción de funciones solo se admite en el código Swift
inline.error.inline.recursive.function.only.on.invocations=La inserción en línea de funciones recursivas solo se admite en las invocaciones
inline.error.inline.typealias.has.conditionally.compiled.code=Es posible que este alias de tipo no se incorpore correctamente en línea porque contiene código no compilado condicionalmente.
inline.error.inline.variable.has.conditionally.compiled.code=Es posible que la variable no se inserte correctamente en línea porque contiene código no compilado condicionalmente
inline.error.inline.variable.no.single.definition=No se encontró una única definición para aplicar inline
inline.error.inlined.expression.should.be.part.of.statement=La expresión insertada debe formar parte de una sentencia
inline.error.invalid.function.arguments=Argumentos de función no válidos
inline.error.is.overridden.by.function.from.0=El método inline es sobreescrito por un método de {0}
inline.error.not.function.call=No es una llamada a una función
inline.error.overrides.associated.type.from.0=El alias de tipo en línea sobrescribe el tipo asociado de {0}
inline.error.overrides.function.from.0=El método inline sobrescribe el método de {0}
inline.error.unexpected.error=Error inesperado al realizar el inline
inline.function.description=Reemplazar la llamada a la función por su cuerpo
inline.function.label.kind.0.name.1=Inline de {0} {1}:
inline.function.label.kind.0.name.1.2.occurrences=Poner en línea {2} llamadas de {0} {1}:
inline.function.label.kind.0.name.1.occurence=Sustituir en línea la llamada a {0} {1}:
inline.include.doc.comments=Incluir comentarios de documentación en línea
inline.recursively=Inline recursivamente
inline.this.invocation.only.and.keep.the.0=Inline solo esta llamada y mantener {0}
inline.this.reference.only.and.keep.the.0=Incorporar solo esta referencia y mantener {0}
inline.this.typealias.only.and.keep.the.0=Sustituir solo este uso y mantener {0}
inline.title.0=Poner en línea {0}
inline.typealias.label.kind.0.name.1=Inlinear {0} {1}:
inline.typealias.label.kind.0.name.1.2.occurrences=Insertar alineado {2} apariciones de {0} {1}:
inline.typealias.label.kind.0.name.1.occurence=Sustituir en línea los usos de {0} {1}:
inline.variable.label.kind.0.name.1=Poner {0} {1} en línea:
inline.variable.label.kind.0.name.1.2.occurrences=Incrustar {2} referencias de {0} {1}:
inline.variable.label.kind.0.name.1.occurence=Inlinear la referencia de {0} {1}:
inspection.conditionally.not.compiled.code=Código no compilado condicionalmente
inspection.missing.doc.comment.parameter.item=comentario de doc perdido para el parámetro
inspection.missing.doc.comment.parameter.item.error=El parámetro {0} no está descrito en el comentario de documentación
inspection.missing.doc.comment.parameter.item.fix=Actualizar comentario doc
inspection.missing.localization=falta localización
inspection.missing.localization.all.languages.only=Informar solo de las localizaciones faltantes en todos los idiomas
inspection.redundant.attribute=atributo redundante
inspection.redundant.attribute.error=''@{0}'' es redundante
inspection.redundant.attribute.fix=Eliminar ''@{0}'' redundante
inspection.redundant.closure=Cierre redundante
inspection.redundant.closure.error=Creación de clausura redundante
inspection.redundant.closure.fix=Poner el cuerpo en línea
inspection.redundant.nullable.function.type.error=''{0}'' siempre devuelve un tipo no nulo
inspection.redundant.nullable.type=Tipo nulo redundante
inspection.redundant.nullable.type.error=''{0}'' siempre es de tipo no nulo
inspection.redundant.nullable.type.fix=Eliminar '?' redundante
inspection.redundant.return=Devolución redundante
inspection.redundant.return.error='return' redundante
inspection.redundant.return.fix=Eliminar 'return' redundante
inspection.unnecessary.argument.list=Paréntesis de argumento vacío antes del cierre
inspection.unnecessary.argument.list.error=Los paréntesis de los argumentos son innecesarios
inspection.unnecessary.argument.list.fix=Eliminar paréntesis de argumentos innecesarios
inspection.unnecessary.parentheses=Paréntesis innecesarios
inspection.unnecessary.parentheses.error=Paréntesis innecesarios
inspection.unnecessary.parentheses.fix=Eliminar paréntesis innecesarios
inspection.unnecessary.self=self innecesario
inspection.unnecessary.self.error='self' es innecesario
inspection.unnecessary.self.fix=Eliminar 'self' innecesario
inspection.unnecessary.tuple.wrap=Envoltura de tupla innecesaria
inspection.unnecessary.tuple.wrap.error=La tupla de un solo elemento puede reemplazarse por el tipo
inspection.unnecessary.tuple.wrap.fix=Reemplazar la tupla de un solo elemento por el tipo
intention.access.control.error.access=No se puede acceder a {0}: es {1} en {2}
intention.access.control.error.access.dynamic=No se puede acceder a {0}: el subíndice del miembro dinámico es {1} en {2}
intention.access.control.error.override=No se puede sobrescribir {0}: es {1} en {2}
intention.access.control.fix=Hacer {1} {0} en {2}
intention.access.control.remove.setter=Eliminar {1} de {0}
intention.add.catch.clause=Añadir 'catch'
intention.add.default.catch.clause=Añadir cláusula 'catch' predeterminada
intention.add.digit.separators=Añadir separadores de dígitos
intention.add.explicit.qualifier=Añadir calificador explícito
intention.add.explicit.type=Añadir tipo explícito
intention.add.try.to.expression=Añadir 'try' a la expresión
intention.add.try.to.iteration=Añadir 'try' a la iteración
intention.category.swift=Swift
intention.convert.to.binary=Convertir a binario
intention.convert.to.closure.argument=Convertir en argumento de clausura
intention.convert.to.decimal=Convertir a decimal
intention.convert.to.hex=Convertir a hexadecimal
intention.convert.to.multiline.string=Convertir a literal de cadena multilínea
intention.convert.to.octal=Convertir a octal
intention.convert.to.string=Convertir a literal de cadena de una sola línea
intention.convert.to.trailing.closure=Convertir a clausura de cierre
intention.create.actor.0=Crear actor ''{0}''
intention.create.actor.0.in.new.file=Crear actor ''{0}'' en un nuevo archivo
intention.create.actor.0.nested.in.1=Crear el actor ''{0}'' anidado en ''{1}''
intention.create.class.0=Crear clase ''{0}''
intention.create.class.0.in.new.file=Crear clase ''{0}'' en un nuevo archivo
intention.create.class.0.nested.in.1=Crear clase ''{0}'' anidada en ''{1}''
intention.create.enum.0=Crear enumeración ''{0}''
intention.create.enum.0.in.new.file=Crear enumeración ''{0}'' en un nuevo archivo
intention.create.enum.0.nested.in.1=Crear enumeración ''{0}'' anidada en ''{1}''
intention.create.enum.case.0=Crear caso de enumeración ''{0}''
intention.create.global.function.0=Crear función global ''{0}''
intention.create.global.variable.0=Crear variable global ''{0}''
intention.create.initializer=Crear inicializador
intention.create.local.variable.0=Crear variable local ''{0}''
intention.create.method.0=Crear método ''{0}''
intention.create.method.0.in.extension=Crear método de extensión ''{0}''
intention.create.new.swift.declaration=Crear nueva declaración de Swift
intention.create.new.swift.type.in.a.new.file=Crear nuevo tipo Swift en un archivo nuevo
intention.create.property.0=Crear propiedad ''{0}''
intention.create.property.0.in.extension=Crear propiedad de extensión ''{0}''
intention.create.protocol.0=Crear protocolo ''{0}''
intention.create.protocol.0.in.new.file=Crear protocolo ''{0}'' en un nuevo archivo
intention.create.protocol.0.nested.in.1=Crear el protocolo ''{0}'' anidado en ''{1}''
intention.create.struct.0=Crear estructura ''{0}''
intention.create.struct.0.in.new.file=Crear la estructura ''{0}'' en un nuevo archivo
intention.create.struct.0.nested.in.1=Crear estructura ''{0}'' anidada en ''{1}''
intention.create.type.0=Crear tipo ''{0}''
intention.create.type.0.in.new.file=Crear el tipo ''{0}'' en un nuevo archivo
intention.create.type.0.nested.in.1=Crear el tipo ''{0}'' anidado en ''{1}''
intention.create.type.method.0=Crear método de tipo ''{0}''
intention.create.type.method.0.in.extension=Crear método de tipo ''{0}'' en la extensión
intention.create.type.property.0=Crear propiedad de tipo ''{0}''
intention.create.type.property.0.in.extension=Crear propiedad de tipo de extensión ''{0}''
intention.decrease.string.escape.level=Disminuir el nivel de escape de la cadena
intention.demorgans.law=Leyes de De Morgan
intention.demorgans.law.format=Reemplazar ''{0}'' por ''{1}''
intention.extract.class.0.to.extension=Extraer clase ''{0}'' a una extensión
intention.extract.class.0.to.type.declaration=Extraer la clase ''{0}'' a una declaración de tipo
intention.extract.conformance.to.extension.cannot.add.protocol.conformance.to.protocol=Las extensiones de protocolo no pueden cumplir con otros protocolos
intention.extract.conformance.to.extension.cannot.extract.class=No se puede extraer la herencia de clase ''{0}'' a una extensión
intention.extract.conformance.to.extension.familyName=Extraer conformidad a la extensión
intention.extract.conformance.to.extension.type.cannot.be.local=No se puede crear una extensión en un ámbito local
intention.extract.conformance.to.extension.type.must.be.fileprivate=El tipo debe ser al menos fileprivate
intention.extract.enum.0.to.extension=Extraer enumeración ''{0}'' a extensión
intention.extract.enum.0.to.type.declaration=Extraer la enumeración ''{0}'' a una declaración de tipo
intention.extract.from.extension.to.type.declaration.error.message.title=Extraer miembro a su declaración de tipo original
intention.extract.from.extension.to.type.declaration.familyName=Extraer miembro a la declaración de tipo original
intention.extract.from.extension.to.type.declaration.original.analysis.on.type.not.allowed=La declaración de tipo original está fuera del ámbito
intention.extract.from.extension.to.type.declaration.original.type.not.found=No se encontró la declaración de tipo original
intention.extract.function.0.to.extension=Extraer función ''{0}'' a una extensión
intention.extract.function.0.to.type.declaration=Extraer función ''{0}'' a la declaración de tipo
intention.extract.initializer.to.extension=Extraer inicializador a la extensión
intention.extract.initializer.to.type.declaration=Extraer inicializador a la declaración de tipo
intention.extract.member.to.extension.cannot.extract.from.protocol=No se puede extraer del protocolo
intention.extract.member.to.extension.type.cannot.be.local=No se puede crear una extensión en un ámbito local
intention.extract.member.to.extension.type.must.be.fileprivate=El tipo debe ser al menos fileprivate
intention.extract.members.to.extension.error.message.title=Extraer miembros a extensión
intention.extract.members.to.extension.familyName=Extraer miembros a extensión
intention.extract.multiple.members.to.extension=Extraer miembros a extensión
intention.extract.multiple.members.to.type.declaration=Extraer miembros a una declaración de tipo
intention.extract.property.0.to.extension=Extraer propiedad ''{0}'' a la extensión
intention.extract.property.0.to.type.declaration=Extraer la propiedad ''{0}'' a la declaración de tipo
intention.extract.struct.0.to.extension=Extraer la estructura ''{0}'' a una extensión
intention.extract.struct.0.to.type.declaration=Extraer la estructura ''{0}'' a una declaración de tipo
intention.extract.subscript.to.extension=Extraer subíndice a extensión
intention.extract.subscript.to.type.declaration=Extraer subíndice a declaración de tipo
intention.extract.typealias.0.to.extension=Extraer el alias de tipo ''{0}'' a una extensión
intention.extract.typealias.0.to.type.declaration=Extraer el alias de tipo ''{0}'' a una declaración de tipo
intention.flip.binary.expression=Invertir expresión binaria
intention.flip.binary.expression.format=Invertir ''{0}''
intention.flip.comparison=Invertir comparación
intention.flip.comparison.format=Invertir ''{0}'' a ''{1}''
intention.generate.documentation.comment=Añadir comentario de documentación
intention.implement.equals=Implementar equals faltante
intention.implement.hash=Implementar hash faltante
intention.implement.members.error=El tipo {0} no cumple con {1} {2}
intention.implement.members.implement.missing=Implementar {0} {0, choice, 1#miembro faltante|2#miembros faltantes}
intention.implement.missing.equals.hash=Implementar equals y hash faltantes
intention.increase.string.escape.level=Aumentar nivel de escape de la cadena
intention.invert.if.statement=Invertir sentencia 'if'
intention.join.declaration.and.assignment=Unir declaración y asignación
intention.localize.string=Localizar cadena
intention.localize.string.title.case=Localizar cadena de texto
intention.mark.the.enclosing.function.as.throws=Añadir 'throws' a la firma de la función
intention.merge.conditions=Combinar condiciones
intention.merge.else.if=Combinar 'else if'
intention.merge.nested.if=Combinar 'if' anidados
intention.negate.comparison=Negar comparación
intention.negate.comparison.format=Negar ''{0}'' a ''{1}''
intention.remove.digit.separators=Eliminar separadores de dígitos
intention.remove.explicit.type=Eliminar tipo explícito
intention.replace.guard.with.if=Reemplazar 'guard' por 'if'
intention.replace.if.with.guard=Reemplazar 'if' por 'guard'
intention.replace.rethrows.with.throws=Reemplazar 'rethrows' por 'throws'
intention.simplifyifelse.collapse.conditional.expression=Contraer expresión condicional
intention.simplifyifelse.collapse.guard=Contraer 'guard'
intention.simplifyifelse.collapse.ifelse=Contraer 'if else'
intention.simplifyifelse.familyName=Simplificar if-else
intention.simplifyifelse.replace.guard.with.0=Reemplazar ''guard'' por ''{0}''
intention.simplifyifelse.replace.if.else.with.0=Reemplazar ''if else'' por ''{0}''
intention.simplifyifelse.simplify=Simplificar
intention.simplifyifelse.simplify.guard=Simplificar 'guard'
intention.simplifyifelse.simplify.if.else=Simplificar 'if else'
intention.split.condition=Dividir en condiciones separadas
intention.split.declaration.and.assignment=Dividir declaración y asignación
intention.split.else.if=Dividir 'else if'
intention.split.into.separate.declarations=Dividir en declaraciones separadas
intention.split.nested.if=Dividir en 'if' anidado
intention.suppress.call.error.with.try=Suprimir este error con 'try!'
intention.surround.with.do.catch=Envolver con 'do/catch'
intention.swift.module.info=Mostrar información del módulo
intention.switch.resolve.configuration.specified=Cambiar a ''{0}'' para activar esta rama
intention.unresolved.reference.0.1=Importar {0} ''{1}''
intention.unwrap.with.guard.let=Desempaquetar con 'guard let'
intention.unwrap.with.if.let=Desempaquetar con 'if let'
intention.wrong.return.type.fix=Corregir el tipo de retorno de la función
intention.wrong.return.type.fix.with.types=Hacer que ''{0}'' devuelva ''{1}''
introduce.variable.declare.with.var=Declarar con var(&V)
introduce.variable.expression.will.be.ambiguous.without.explicit.type=La expresión será ambigua<br/>sin un tipo explícito
introduce.variable.specify.type.explicitly=Especificar tipo explícitamente (&T)
notification.group.plugin.errors=Fallo del servicio de lenguaje Swift
optimize.imports.rearranged.imports=Importaciones reordenadas
optimize.imports.removed.0.added.1.imports={0} {0,choice,0#importaciones eliminadas|1#importación eliminada|1<importaciones eliminadas}, {1} {1,choice,0#importaciones añadidas|1#importación añadida|1<importaciones añadidas}
optimize.imports.removed.0.imports=Se han eliminado {0} {0,choice,0#importaciones|1#importación|1<importaciones}
override.implement.elements.to.implement.chooser.title=Seleccionar miembros a implementar
override.implement.elements.to.override.chooser.title=Seleccionar miembros para sobrescribir
override.implement.elements.to.override.implement.chooser.title=Seleccionar miembros para sobrescribir/implementar
override.implement.implement.not.allowed=No se puede implementar
override.implement.nothing.to.implement=No hay nada que implementar
override.implement.nothing.to.override=Nada que sobrescribir
override.implement.override.not.allowed=No se puede sobrescribir
override.implement.progress=Procesando miembros a sobrescribir/implementar…
override.implement.show.members.to.implement.title=Mostrar miembros a implementar
override.implement.show.no.optional.members=Mostrar miembros opcionales (no hay opcionales)
override.implement.show.only.optional.members=Mostrar miembros opcionales (solo opcionales)
override.implement.show.optional.member=Mostrar 1 miembro opcional (&O)
override.implement.show.optional.members=Mostrar {0} miembros opcionales (&O)
refactor.0.overrides.associated.type.of.1={0} sobrescribe el tipo asociado de {1}
refactor.0.overrides.declaration.in.1={0} sobrescribe la declaración en {1}
refactor.0.overrides.initializer.of.1={0} sobrescribe el inicializador de {1}
refactor.0.overrides.method.of.1={0} sobrescribe el método de {1}
refactor.0.overrides.property.of.1={0} sobrescribe la propiedad de {1}
refactor.0.overrides.subscript.of.1={0} sobrescribe el subíndice de {1}
refactor.base.declaration=Refactorizar {0,choice,1#declaración base|2#declaraciones base}
refactor.only.current.declaration=Refactorizar solo la declaración actual
refactoring.option.search.in.not.compiled.code=Aplicar a código no compilado condicionalmente
rename.containing.file.dialog.description=Renombrar el archivo contenedor con el siguiente nombre:
rename.containing.file.dialog.title=Renombrar el archivo que lo contiene
rename.containing.file.entity.name=Archivo contenedor
rename.error.dynamic.called.values=No se pueden renombrar los valores llamados dinámicamente
rename.error.message.renaming.swift.member.elements.in.objective.c.code.is.not.supported=No se admite el cambio de nombre de elementos miembro de Swift en el código Objective-C
rename.error.title=Swift - Renombrar
rename.inheritor.entity.name=Heredero
rename.inheritors=Renombrar herederos
rename.inheritors.to=Renombrar herederos a:
rename.init.is.not.supported=No se admite cambiar el nombre de los inicializadores de Swift
rename.related.dialog.description=Renombrar las declaraciones relacionadas con los siguientes nombres a:
rename.related.dialog.title=Renombrar declaraciones relacionadas
rename.related.entity.name=Declaración relacionada
rename.self.is.not.supported=No se admite el cambio de nombre del parámetro self
rename.title=Cambiar nombre de Swift
searching.for.implementations=Buscando implementaciones…
searching.for.overriders=Buscando sobrescrituras…
searching.for.subclasses=Buscando subclases…
sourcekit.fix.it=Aplicar Fix-it
sourcekit.inspections=Inspecciones de SourceKit
swift-format.dump.progress=Creando el archivo de configuración '.swift-format' predeterminado
swift-format.format.progress=Reformateando {0}
swift.name=Swift
syntax.error.call.can.throw.but.it.is.executed.in.a.non.throwing.autoclosure=La llamada puede lanzar, pero se ejecuta en un autoclosure que no lanza.
syntax.error.call.can.throw.but.it.is.not.marked.with.try.and.it.is.executed.in.a.non.throwing.autoclosure=La llamada puede lanzar, pero no está marcada con 'try' y se ejecuta en un autoclosure que no lanza
syntax.error.call.can.throw.in.default.argument=La llamada puede lanzar, pero no se pueden lanzar errores desde un argumento predeterminado
syntax.error.call.can.throw.in.property.initializer=La llamada puede lanzar errores, pero no se pueden lanzar desde el inicializador de una propiedad
syntax.error.call.can.throw.not.marked.with.try=La llamada puede lanzar errores, pero no está marcada con 'try'
syntax.error.call.can.throw.not.marked.with.try.not.exhaustive=La llamada puede lanzar errores, pero no está marcada con 'try' y el bloque catch contenedor no es exhaustivo
syntax.error.call.can.throw.not.marked.with.try.not.handled=La llamada puede lanzar una excepción, pero no está marcada con 'try' y el error no se gestiona
syntax.error.call.rethrows.function.can.only.throw.parameter.call.not.handled=La llamada puede lanzar un error, pero no se ha gestionado; una función declarada como 'rethrows' solo puede lanzar errores si su parámetro lanza uno.
syntax.error.call.rethrows.function.can.only.throw.parameter.call.not.marked.with.try.not.handled=La llamada puede lanzar errores, pero no está marcada con 'try' y el error no se maneja; una función declarada como 'rethrows' solo puede lanzar un error si su parámetro lo lanza
syntax.error.duplicate.platform=La plataforma ''{0}'' ya se ha especificado
syntax.error.error.is.not.handled=El error no se maneja porque la función contenedora no está declarada como 'throws'
syntax.error.error.is.not.handled.not.exhaustive=El error no se ha gestionado porque el bloque catch envolvente no es exhaustivo
syntax.error.errors.are.not.handled=Los errores lanzados desde aquí no se manejan.
syntax.error.errors.are.not.handled.not.exhaustive=Los errores lanzados desde aquí no se manejan porque el catch circundante no es exhaustivo
syntax.error.hashbang.line.is.allowed.only.in.the.first.line.of.the.file=La línea hashbang solo se permite en la primera línea del archivo
syntax.error.hashbang.line.is.allowed.only.in.the.first.line.of.the.main.file=La línea hashbang solo se permite en la primera línea del archivo principal
syntax.error.hashbang.line.is.allowed.only.in.the.main.file=La línea hashbang solo está permitida en el archivo principal
syntax.error.interpolation.can.throw.but.it.is.executed.in.a.non.throwing.autoclosure=La interpolación puede lanzar errores, pero se ejecuta en un autoclosure que no lanza
syntax.error.interpolation.can.throw.but.it.is.not.marked.with.try.and.it.is.executed.in.a.non.throwing.autoclosure=La interpolación puede lanzar errores, pero no está marcada con 'try' y se ejecuta en un autoclosure que no lanza errores
syntax.error.interpolation.can.throw.in.default.argument=La interpolación puede lanzar, pero no se pueden lanzar errores desde un argumento predeterminado
syntax.error.interpolation.can.throw.in.property.initializer=La interpolación puede lanzar errores, pero no se pueden lanzar errores desde un inicializador de propiedad
syntax.error.interpolation.can.throw.not.marked.with.try=La interpolación puede lanzar una excepción, pero no está marcada con 'try'
syntax.error.interpolation.can.throw.not.marked.with.try.not.exhaustive=La interpolación puede lanzar un error, pero no está marcada con 'try' y el catch contenedor no es exhaustivo
syntax.error.interpolation.can.throw.not.marked.with.try.not.handled=La interpolación puede lanzar un error, pero no está marcada con 'try' y el error no se ha controlado
syntax.error.interpolation.rethrows.function.can.only.throw.parameter.call.not.handled=La interpolación puede lanzar errores, pero el error no se maneja; una función declarada como 'rethrows' solo puede lanzar si la llamada a su parámetro lanza uno
syntax.error.interpolation.rethrows.function.can.only.throw.parameter.call.not.marked.with.try.not.handled=La interpolación puede lanzar, pero no está marcada con 'try' y el error no se maneja; las funciones declaradas con 'rethrows' solo pueden lanzar si su parámetro lanza
syntax.error.iteration.can.throw.not.marked.with.try=La iteración puede lanzar, pero no está marcada con 'try'
syntax.error.iteration.can.throw.not.marked.with.try.not.exhaustive=La iteración puede lanzar una excepción, pero no está marcada con 'try' y el catch circundante no es exhaustivo
syntax.error.iteration.can.throw.not.marked.with.try.not.handled=La iteración puede lanzar un error, pero no está marcada con 'try' y el error no se ha manejado
syntax.error.operator.can.throw.not.marked.with.try=El operador puede lanzar un error, pero la expresión no está marcada con 'try'
syntax.error.property.can.throw.but.it.is.executed.in.a.non.throwing.autoclosure=El acceso a la propiedad puede lanzar errores, pero se ejecuta en un autoclosure que no lanza errores
syntax.error.property.can.throw.but.it.is.not.marked.with.try.and.it.is.executed.in.a.non.throwing.autoclosure=El acceso a la propiedad puede lanzar errores, pero no está marcado con 'try' y se ejecuta en un autoclosure que no lanza errores
syntax.error.property.can.throw.in.default.argument=El acceso a la propiedad puede lanzar excepciones, pero no se puede lanzar un error desde un argumento predeterminado
syntax.error.property.can.throw.in.property.initializer=El acceso a la propiedad puede lanzar errores, pero no se puede lanzar un error desde un inicializador de propiedad
syntax.error.property.can.throw.not.marked.with.try=El acceso a la propiedad puede lanzar un error, pero no se ha marcado con 'try'
syntax.error.property.can.throw.not.marked.with.try.not.exhaustive=El acceso a la propiedad puede lanzar una excepción, pero no está marcado con 'try' y el catch envolvente no es exhaustivo.
syntax.error.property.can.throw.not.marked.with.try.not.handled=El acceso a la propiedad puede lanzar un error, pero no está marcado con 'try' y el error no está controlado
syntax.error.property.rethrows.function.can.only.throw.parameter.call.not.handled=El acceso a la propiedad puede lanzar, pero el error no se maneja; una función declarada como 'rethrows' solo puede lanzar si su parámetro lanza
syntax.error.property.rethrows.function.can.only.throw.parameter.call.not.marked.with.try.not.handled=El acceso a la propiedad puede lanzar errores, pero no está marcado con 'try' y el error no se ha gestionado; las funciones declaradas como 'rethrows' solo pueden lanzar si sus parámetros lanzan
syntax.error.rethrows.function.can.only.throw.parameter.call=Una función declarada con 'rethrows' solo puede lanzar si su parámetro lanza
syntax.error.rethrows.function.must.take.a.throwing.function.argument=Una función 'rethrows' debe recibir un argumento de función que lance errores
syntax.error.rethrows.is.not.allowed.in.closures='rethrows' no está permitido en las clausuras
syntax.error.rethrows.is.not.allowed.in.function.type.elements=Solo las declaraciones de funciones pueden marcarse como 'rethrows'
syntax.error.rethrows.is.not.allowed.in.subscripts=No se permite 'rethrows' en subíndices
syntax.error.subscript.can.throw.but.it.is.executed.in.a.non.throwing.autoclosure=El acceso al subíndice puede lanzar errores, pero se ejecuta en un autoclosure que no lanza errores
syntax.error.subscript.can.throw.but.it.is.not.marked.with.try.and.it.is.executed.in.a.non.throwing.autoclosure=El acceso al subíndice puede lanzar errores, pero no está marcado con 'try' y se ejecuta en un autoclosure que no lanza errores
syntax.error.subscript.can.throw.in.default.argument=El acceso a subíndices puede lanzar errores, pero no se puede lanzar un error desde un argumento por defecto
syntax.error.subscript.can.throw.in.property.initializer=El acceso mediante subíndices puede lanzar errores, pero no se pueden lanzar errores desde el inicializador de una propiedad
syntax.error.subscript.can.throw.not.marked.with.try=El acceso al subíndice puede lanzar un error, pero no está marcado con 'try'
syntax.error.subscript.can.throw.not.marked.with.try.not.exhaustive=El acceso al subíndice puede lanzar errores, pero no está marcado con 'try' y el catch envolvente no es exhaustivo
syntax.error.subscript.can.throw.not.marked.with.try.not.handled=El acceso mediante subíndice puede lanzar un error, pero no está marcado con 'try' y el error no se ha gestionado
syntax.error.subscript.rethrows.function.can.only.throw.parameter.call.not.handled=El acceso al subíndice puede lanzar un error, pero el error no se ha manejado; las funciones declaradas como 'rethrows' solo pueden lanzar errores si su parámetro lo lanza.
syntax.error.subscript.rethrows.function.can.only.throw.parameter.call.not.marked.with.try.not.handled=El acceso al subíndice puede lanzar, pero no se ha marcado con 'try' y el error no se ha controlado; una función declarada con 'rethrows' solo puede lanzar si su parámetro lanza
syntax.error.thrown.expression.type.0.does.not.conform.to.ErrorType=El tipo de expresión lanzada ''{0}'' no se ajusta a ''{1}''
syntax.error.throws.is.not.allowed.in.subscripts=No se permite 'throws' en los subíndices
syntax.error.try.cannot.appear.to.the.right='try' no puede aparecer a la derecha de un operador que no sea de asignación
syntax.error.try.cannot.appear.to.the.right.fix=Mover 'try' a la izquierda
syntax.error.typealias.without.assignment=Falta una asignación en la declaración del alias de tipo
syntax.error.unrecognized.platform.name.0=Nombre de plataforma no reconocido ''{0}''
syntax.error.variable.declaration.with.multiple.variables.cannot.have.explicit.getters.setters=La declaración 'var' con múltiples variables no puede tener getters/setters explícitos
syntax.error.variable.declaration.with.multiple.variables.cannot.have.implicit.getter.clause=Una declaración 'var' con múltiples variables no puede tener una cláusula getter implícita
syntax.error.variable.declaration.with.multiple.variables.cannot.have.willset.didset.clause=Una declaración 'var' con múltiples variables no puede tener cláusulas willSet/didSet
usage.type.argument.label=Etiqueta de argumento
usage.type.conditionally.not.compiled=Uso potencial en código no compilado condicionalmente
usage.type.extension=Extensión
usage.type.function.declaration=Declaración de función
usage.type.key.path=Expresión de ruta de clave
usage.type.operator.declaration=Declaración de operador
usage.type.precedence.group.declaration=Declaración de grupo de precedencia
usage.type.raw.value=Valor original
usage.type.requirement=Uso en requisitos
usage.type.type.alias=Alias de tipo
usage.type.type.parameter=Parámetro de tipo
