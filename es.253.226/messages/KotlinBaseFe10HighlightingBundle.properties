always.null=Siempre null
cannot.be.inferred=No se puede inferir
defined.in=Definido en
found.space=Encontrado: 推进
function.arguments=Argumentos:
function.receiver.0=Receptor: {0}
gutter.name.suspend.call=Suspender llamada
html.0.has.no.corresponding.expected.declaration.1.html={0} no tiene la declaración esperada correspondiente{1}
html.0.is.not.abstract.and.does.not.implement.abstract.base.class.member.br.1.html={0} no es abstracto y no implementa el miembro de la clase base abstracta<br/>{1}
html.0.is.not.abstract.and.does.not.implement.abstract.member.br.1.html={0} no es abstracto y no implementa el miembro abstracto<br/>{1}
html.0.method.may.be.missing.none.of.the.following.functions.will.be.called.ul.1.ul.html=Es posible que falte el método ''{0}''. No se llamará a ninguna de las siguientes funciones: <ul>{1}</ul>
html.0.must.override.1.br.because.it.inherits.many.implementations.of.it.html={0} debe sobrescribir {1}<br />porque hereda muchas implementaciones del mismo
html.accidental.override.0.html=Sobrescritura accidental: {0}
html.actual.class.0.has.no.corresponding.members.for.expected.class.members.1.html=La clase real ''{0}'' no tiene miembros correspondientes para los miembros de la clase esperada:{1}
html.assignment.operators.ambiguity.all.these.functions.match.ul.0.ul.table.html=Ambigüedad en los operadores de asignación. Todas estas funciones coinciden.<ul>{0}</ul></table>
html.candidate.resolution.will.be.changed.soon.please.use.fully.qualified.name.to.invoke.the.following.closer.candidate.explicitly.ul.0.ul.html=La resolución de candidatos cambiará pronto; utilice el nombre plenamente cualificado para invocar explícitamente al siguiente candidato más cercano: <ul>{0}</ul>
html.cannot.choose.among.the.following.candidates.without.completing.type.inference.ul.0.ul.html=No se puede elegir entre los siguientes candidatos sin completar la inferencia de tipos: <ul>{0}</ul>
html.expected.0.has.no.actual.declaration.in.module.1.2.html=El {0} esperado no tiene una declaración real en el módulo {1}{2}
html.function.return.type.mismatch.table.tr.td.expected.td.td.1.td.tr.tr.td.found.td.td.2.td.tr.table.html=El tipo de retorno de la función no coincide.<table><tr><td>Esperado:</td><td>{1}</td></tr><tr><td>Encontrado:</td><td>{2}</td></tr></table>
html.getter.return.type.must.be.equal.to.the.type.of.the.property.table.tr.td.expected.td.td.0.td.tr.tr.td.found.td.td.1.td.tr.table.html=El tipo de retorno del getter debe ser igual al tipo de la propiedad.<table><tr><td>Esperado:</td><td>{0}</td></tr><tr><td>Encontrado:</td><td>{1}</td></tr></table>
html.internal.error.occurred.while.analyzing.this.expression.br.0.html=<strong>Se produjo un error interno al analizar esta expresión:</strong><br/>{0}
html.javascript.0.html=JavaScript: {0}
html.loop.parameter.type.mismatch.table.tr.td.iterated.values.td.td.0.td.tr.tr.td.parameter.td.td.1.td.tr.table.html=Discrepancia de tipo de parámetro de bucle.<table><tr><td>Valores iterados:</td><td>{0}</td></tr><tr><td>Parámetro:</td><td>{1}</td></tr></table>
html.method.contains.from.concurrenthashmap.may.have.unexpected.semantics.it.calls.containsvalue.instead.of.containskey.br.use.explicit.form.of.the.call.to.containskey.containsvalue.contains.or.cast.the.value.to.kotlin.collections.map.instead.br.see.https.youtrack.jetbrains.com.issue.kt.18053.for.more.details.html=El método 'contains' de ConcurrentHashMap puede tener una semántica inesperada: llama a 'containsValue' en lugar de a 'containsKey'.<br/>Utilice la forma explícita de la llamada a 'containsKey'/'containsValue'/'contains' o convierta el valor a kotlin.collections.Map en su lugar.<br/>Consulte https://youtrack.jetbrains.com/issue/KT-18053 para obtener más detalles
html.method.iterator.is.ambiguous.for.this.expression.ul.0.ul.html=El método ''iterator()'' es ambiguo para esta expresión.<ul>{0}</ul>
html.non.final.expect.class.and.its.actual.class.must.declare.exactly.the.same.non.private.members.html={0}: la clase actual y su clase expect no final deben declarar exactamente los mismos miembros no privados. Los siguientes miembros no privados en la clase actual no coinciden: {1}<br/>Este error ocurre porque la clase expect ''{2}'' no es final. Esta advertencia se convertirá en un error en versiones futuras.<br/>Consulte también https://youtrack.jetbrains.com/issue/KT-22841 para obtener más detalles
html.none.of.the.following.functions.can.be.called.with.the.arguments.supplied.ul.0.ul.html=Ninguna de las siguientes funciones puede llamarse con los argumentos proporcionados. <ul>{0}</ul>
html.overload.resolution.ambiguity.all.these.functions.match.ul.0.ul.html=Ambigüedad en la resolución de sobrecarga. Todas estas funciones coinciden. <ul>{0}</ul>
html.overload.resolution.ambiguity.on.method.0.all.these.functions.match.ul.1.ul.html=Ambigüedad en la resolución de la sobrecarga del método ''{0}''. Todas estas funciones coinciden. <ul>{1}</ul>
html.platform.declaration.clash.0.html=Conflicto de declaración de plataforma: {0}
html.property.delegate.must.have.a.0.method.none.of.the.following.functions.are.suitable.ul.1.ul.html=El delegado de propiedad debe tener un método ''{0}''. Ninguna de las siguientes funciones es adecuada: <ul>{1}</ul>
html.property.type.is.0.which.is.not.a.subtype.type.of.overridden.br.1.html=El tipo de propiedad es {0}, que no es un subtipo del elemento sobreescrito<br/>{1}
html.return.type.is.0.which.is.not.a.subtype.of.overridden.br.1.html=El tipo de retorno es ''{0}'', que no es un subtipo del elemento sobreescrito<br/>{1}
html.return.types.of.inherited.members.are.incompatible.br.0.br.1.html=Los tipos de retorno de los miembros heredados son incompatibles:<br/>{0},<br/>{1}
html.setter.parameter.type.must.be.equal.to.the.type.of.the.property.table.tr.td.expected.td.td.0.td.tr.tr.td.found.td.td.1.td.tr.table.html=El tipo de parámetro del setter debe ser igual al tipo de la propiedad.<table><tr><td>Esperado:</td><td>{0}</td></tr><tr><td>Encontrado:</td><td>{1}</td></tr></table>
html.type.argument.is.not.within.its.bounds.table.tr.td.expected.td.td.0.td.tr.tr.td.found.td.td.1.td.tr.table.html=El argumento de tipo no está dentro de sus límites.<table><tr><td>Esperado:</td><td>{0}</td></tr><tr><td>Encontrado:</td><td>{1}</td></tr></table>
html.type.inference.failed.0.html=Error en la inferencia de tipos: {0}
html.type.mismatch.table.tr.td.required.td.td.0.td.tr.tr.td.found.td.td.1.td.tr.table.br.projected.type.2.restricts.use.of.br.3.html=Discrepancia de tipos.<table><tr><td>Requerido:</td><td>{0}</td></tr><tr><td>Encontrado:</td><td>{1}</td></tr></table><br />\nEl tipo proyectado {2} restringe el uso de <br />\n{3}\n
html.type.mismatch.table.tr.td.required.td.td.0.td.tr.tr.td.found.td.td.1.td.tr.table.html=Discrepancia de tipos.<table><tr><td>Requerido:</td><td>{0}</td></tr><tr><td>Encontrado:</td><td>{1}</td></tr></table>
html.types.of.inherited.properties.are.incompatible.br.0.br.1.html=Los tipos de las propiedades heredadas son incompatibles:<br/>{0},<br/>{1}
html.types.of.inherited.var.properties.do.not.match.br.0.br.1.html=Los tipos de las propiedades var heredadas no coinciden:<br/>{0},<br/>{1}
html.unresolved.reference.br.none.of.the.following.candidates.is.applicable.because.of.receiver.type.mismatch.ul.0.ul.html=Referencia no resuelta. <br/> Ninguno de los siguientes candidatos es aplicable debido a una falta de coincidencia en el tipo del receptor: <ul>{0}</ul>
html.val.property.cannot.override.var.property.br.1.html=La propiedad val no puede sobrescribir la propiedad var<br />{1}
html.var.property.type.is.0.which.is.not.a.type.of.overridden.br.1.html=El tipo de la propiedad var es {0}, que no es un tipo del elemento sobrescrito<br/>{1}
i.for.i.br.0=<i> para </i><br/>{0}
kotlin.compiler.error=Error del compilador de Kotlin
kotlin.compiler.warning=Advertencia del compilador de Kotlin
required.space=Requerido:
root.package=Paquete raíz
smart.cast.to.0.for.1.call=Conversión inteligente a {0} (para la llamada a {1})
the.feature.0.is.not.supported.in.k1.mode=La función {0} no es compatible con el modo K1
the.following.declarations.have.the.same.jvm.signature.code.0.1.code.br.ul.2.ul=Las siguientes declaraciones tienen la misma firma JVM (<code>{0}{1}</code>):<br/>\n<ul>\n{2}</ul>
type.inference.failed.expected.type.mismatch=Error en la inferencia de tipos. Discrepancia en el tipo esperado:
type.parameters.where=Donde
unknown.receiver=Receptor desconocido
value.captured.in.a.closure=Valor capturado en una clausura
wrapped.into.a.reference.object.to.be.modified.when.captured.in.a.closure=Envuelto en un objeto de referencia para ser modificado al capturarse en un closure
