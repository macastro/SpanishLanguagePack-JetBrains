absolute.import.detected=Las declaraciones de importación pueden ser relativas al paquete base.
abstract.value.used.in.trait=Valores abstractos utilizados en atributos.
abstract.variable.used.in.trait=Variables abstractas utilizadas en características.
access.can.be.private=El acceso puede ser privado.
add.call.parentheses=Agregar paréntesis de llamada
add.case=Añadir 'caso'
add.dot.to.method.call=Agregar punto a la llamada al método
add.modifier=Agregar controlador ''{0}''
add.override.modifier.quickfix=Agregar controlador de anulación
add.prefix.to.reference=Agregar prefijo a las referencias
add.return.keyword=Agregar palabra clave de retorno
add.targetname.annotation=Agregar la anotación @targetName
add.type.annotation=Agregar anotación de tipo
advanced.language.feature=Funciones de lenguaje de alto nivel\: {0}
all.but.last.targetname.annotation.ignored=Sólo se ignora la última anotación @targetName. Considere usar solo una anotación @targetName por definición
all.text.from.header.closing.tag.to.end.of.line.will.be.lost=Se pierde todo el texto desde la etiqueta de cierre del encabezado hasta el final de la línea.
annotate.declaration.with.unused=Agregar anotación con @unused a la declaración
applied.type.lambda.can.be.simplified=El tipo lambda aplicado se puede simplificar
argument.cannot.be.used.for.a.format.specifier=El especificador de formato {2} no puede utilizar el argumento {0}({1})
around.function.expr.parameter=Alrededor de parámetros en expresiones de funciones
around.function.type=Alrededor de los tipos de funciones
around.function.type.parameter=Alrededor de los parámetros del tipo de función.
casting.a.to.b.is.redundant=La transmisión de ''{0}'' a ''{1}'' es redundante
casting.left.to.right.is.redundant=La transmisión de ''{0}'' a ''{1}'' es redundante
catch.all=Especificar tipo de excepción
change.modifier=Cambiar controlador
clarifying.parentheses=Paréntesis para separar claramente
comparing.unrelated.types.hint=Comparando tipos no relacionados\: {0} y {1}
condition.always.false=La condición siempre es falsa
condition.always.true=La condición siempre es verdadera
config.description.for.arrays=Para matrices
config.description.for.iterators=Para iteradores
convert.expression.to.sam=Convertir una expresión en un único método abstracto
convert.from.infix.expression=Conversión de notación infija
convert.from.infix.pattern=Conversión de patrón infijo
convert.from.infix.type=Conversión de tipo infijo
convert.match.statement.to.pattern.matching.function=Convierta la declaración de coincidencia en una función anónima de coincidencia de patrones
convert.to.anonymous.function=Convertir a función anónima
convert.to.floating.point=Convertir a {0}
convert.to.function.syntax=Convertir a sintaxis de función
convert.to.interpolated.string=Convertir a cadena interpolada
convert.to.stable.identifier.pattern=Convertir al patrón de identificador ''{0}''
convert.val.to.var=Convertir 'val' en 'var'
convert.var.to.val=Convertir 'var' a 'val'
convertible.to.method.value.anonymous.hint=Convertir al valor del método
convertible.to.method.value.eta.hint=Eliminar marcadores de posición innecesarios
corresponds.unsorted=Cuando se utiliza 'corresponde' en una colección desordenada, los resultados son impredecibles
declaration.is.never.used=La declaración nunca se utiliza
definition.with.operator.name.should.have.targetname.annotation=Dado que la definición tiene un nombre de operador, también debe tener la anotación @targetName
delete.redundant.default.argument=Eliminar argumentos predeterminados innecesarios
display.name.absolute.import=Importación absoluta
display.name.inlined.tag=Etiquetas en línea
display.name.missing.parameter.description=Falta descripción del parámetro
display.name.unclosed.tag=Etiqueta abierta
displayname.abstract.value.in.trait=Valor abstracto dentro del atributo
displayname.access.can.be.weaker=El acceso a la declaración puede restringirse
displayname.access.to.first.element.by.index=Acceder al primer elemento por índice
displayname.access.to.last.element.by.index=Acceder al último elemento por índice
displayname.advanced.language.features=Características del lenguaje de alto nivel
displayname.alphanumeric.definition.used.as.infix.operator.is.not.declared.infix=La definición alfanumérica utilizada con el operador infijo no se declara como 'infijo'
displayname.anonymous.function.convertible.to.a.method.value=Funciones anónimas que se pueden convertir en valores de método.
displayname.applied.type.lambda.can.be.simplified=Los tipos lambda aplicados se pueden simplificar
displayname.argument.duplicates.corresponding.parameter.default.value=El argumento duplica el valor predeterminado para ese parámetro.
displayname.auto.tupling=Tupleización automática
displayname.case.class.parameter=Parámetros de clase de caso
displayname.chained.package.clause.inspection=Declaración de paquete predeterminado
displayname.change.to.filter=Cambiar para filtrar
displayname.collect.and.headoption.to.collectfirst=recoger y headOption con recogerPrimero
displayname.comparing.length.to.lengthcompare=Comparar longitud con longitudComparar
displayname.comparing.unrelated.types=Comparar tipos no relacionados
displayname.constructing.range.for.seq.indices=Crear rango de índice de secuencia
displayname.conversion.to.set.and.back.to.distinct=Convertir a conjunto y restaurar a distinto
displayname.convert.expression.to.single.abstract.method=Convertir una expresión a un método abstracto único (SAM)
displayname.corresponds.sameelements.on.unsorted.collection=Corresponde/sameElements en una colección desordenada
displayname.dataflow.analysis.constant.conditions=Condición constante
displayname.dataflow.analysis.npe.on.invocation=NullPointerException cuando se llama
displayname.dataflow.analysis.nullable.to.notnull=Anulable se pasa al parámetro NotNull
displayname.dataflow.analysis.nullable.to.unannotated=Anulable pasado a un parámetro sin anotaciones
displayname.definition.and.overridden.member.have.different.targetname.annotations=Los miembros definidos y redefinidos tienen diferentes anotaciones @targetName
displayname.definition.misses.targetname.annotation=La definición no tiene la anotación @targetName
displayname.deprecated.identifier=Identificadores obsoletos
displayname.deprecated.kind.projector.syntax=Sintaxis de tipo proyector en desuso
displayname.deprecated.package.object=Objeto de paquete que pronto quedará obsoleto
displayname.directive.dependency.version=Nuevas versiones estables de las dependencias de la biblioteca están disponibles
displayname.double.negation=Doble negativa
displayname.double.negation.in.forall.and.exists=Doble negación dentro de forall y existe.
displayname.drop.and.take.to.slice=Soltar y tomar en rodajas
displayname.emptiness.check.on.get.to.contains=Obtener verificación de espacios en blanco para Contiene
displayname.empty.targetname=Nombre externo @targetName vacío
displayname.emulated.headoption.or.lastoption=HeadOption emulado o lastOption
displayname.emulated.option.x=Opción imitada(x)
displayname.equals.on.arrays.and.iterators=Iguales utilizados en matrices e iteradores
displayname.equals.oncollections.of.different.kinds=Iguales utilizados en diferentes tipos de colecciones.
displayname.equals.some.x.to.contains.x=Signo igual Algunos(x) a contiene(x)
displayname.exists.simplifiable.to.contains=Existe, que se puede simplificar para que contenga
displayname.extracting.keys.manually=Extraer claves manualmente
displayname.extracting.values.manually=Extraer valores manualmente
displayname.field.from.delayedinit=Campos de DelayedInit
displayname.filter.after.sort=Filtrar después de ordenar
displayname.filter.and.contains.to.intersect.or.diff=Filtrar y contiene como intersección o diferencia
displayname.filter.and.emptiness.check.to.exists.forall=Verificación de filtro y espacios en blanco con existe/forall
displayname.filter.and.headoption.to.find=Filtrar y headOption para encontrar
displayname.filter.and.size.to.count=Filtrar y dimensionar como recuento
displayname.find.and.emptiness.check.to.exists=Buscar y verificar espacios en blanco para que exista
displayname.find.and.map.to.get=Buscar y mapear para llegar
displayname.floating.point.literal.ending.with.dot=Literal de coma flotante que termina en '.'
displayname.fold.simplifiable.to.forall=Pliegue que se puede simplificar con forall
displayname.get.and.getorelse.to.getorelse=Obtener y getOrElse como getOrElse
displayname.getorelse.null.to.ornull=GetOrElse(nulo) a orNull
displayname.header.tags.unbalanced=Etiquetas de encabezado no coincidentes
displayname.in.kind.projector.simplify.type=Proyector amable\: Simplificación de tipos
displayname.in.kind.projector.use.correct.lambda.keyword=Kind Proyector\: Uso de la palabra clave Lambda correcta
displayname.index.bounds.check=Verificación vinculada al índice
displayname.inlined.tag=Etiquetas en línea
displayname.isinstanceof=isInstanceOf
displayname.legacy.string.formatting=Formatear una cadena existente
displayname.lift.to.get=Levante para llegar
displayname.loop.variable.not.updated.inside.loop=Variable de bucle no actualizada dentro del bucle
displayname.make.array.to.string=Convertir matriz a cadena
displayname.malformed.format.string=Cadena con formato incorrecto
displayname.manually.zipping.with.indices=Comprimir manualmente usando índices
displayname.map.and.contains.true.false.to.exists.or.forall=Mapea y contiene (verdadero/falso) tal como existe o \!forall
displayname.map.and.flatten.to.flatmap=mapear y aplanar a flatMap
displayname.map.and.getorelse.false.to.exists=Map y getOrElse(false) existen
displayname.map.and.getorelse.to.fold=Mapear y getOrElse como plegar
displayname.match.statement.convertible.to.pattern.matching.anonymous.function=La declaración de coincidencia se puede convertir en una función anónima de coincidencia de patrones.
displayname.member.has.targetname.when.overridden.does.not=El miembro tiene la anotación @targetName, pero el miembro que se anula no la tiene.
displayname.missing.tag.parameter.description=Falta descripción del parámetro de etiqueta
displayname.missing.type.annotation=Anotación de tipo faltante
displayname.multiple.arg.lists.in.annotation.constructor=Múltiples listas de argumentos en constructores anotados
displayname.multiple.targetname.annotations=Múltiples anotaciones @targetName
displayname.multiple.targets.targetname=Múltiples destinos @targetName
displayname.name.boolean.parameters=Especificación de nombres de parámetros booleanos
displayname.nested.stateful.monads=Mónadas con estado anidadas
displayname.no.targetname.annotation.for.operator.like.definition=La definición con nombre de operador no tiene la anotación @targetName
displayname.non.value.field.is.accessed.in.hashcode=Campo sin valor al que se accede en 'hashCode()'
displayname.nonlocal.return=Declaración de devolución no local
displayname.not.implemented.code=Sin implementación de código
displayname.null.initializer.can.be.replaced.by.underscore=Puede reemplazar el inicializador nulo con _
displayname.package.name.inspection=Declaración de paquete no válida
displayname.postfix.unary.operation=Postfix unary operation
displayname.redundant.block=Bloques innecesarios
displayname.redundant.cast.inspection=Comprobación de conversión de tipos innecesaria
displayname.redundant.class.param.clause=Cláusula de parámetro de clase innecesaria
displayname.redundant.collection.conversion=Conversión de colección innecesaria
displayname.redundant.contains.in.filter=Filtrar mis contenidos innecesarios
displayname.redundant.conversion.inspection=Comprobaciones de conversión innecesarias
displayname.redundant.get.when.getting.a.value.from.map=Obtención innecesaria al obtener valor del mapa
displayname.redundant.headoption.or.lastoption=HeadOption o lastOption innecesarias
displayname.redundant.new.on.case.class=Nuevo innecesario en clase de caso.
displayname.redundant.return=Devoluciones innecesarias
displayname.reference.must.be.prefixed=Las referencias requieren prefijo
displayname.relative.import=Declaración de importación relativa
displayname.replace.to.with.until=Cambiar a a hasta
displayname.replace.with.flatten=Cambiar para aplanar
displayname.reverse.and.iterator.to.reverseiterator=Revertir e iterador para revertirIterador
displayname.reverse.find.to.findLast=Invertir y buscar para encontrarLast
displayname.reverse.take.and.reverse.to.takeright=Invertir, tomar y revertir como tomarDerecha
displayname.sameelements.oncollections.of.a.same.kind=SameElements onColecciones del mismo tipo
displayname.scala=Scala
displayname.scala.deprecation=Depreciación de Scala
displayname.scala.style.inspection=Comprobación de estilo Scala
displayname.scala.unnecessary.semicolon.inspection=Comprobación de punto y coma innecesaria de Scala
displayname.side.effects.in.a.monadic.transformation=Efectos secundarios de la conversión unaria
displayname.simplifiable.empty.check=Comprobación simplificada de espacios en blanco
displayname.simplifiable.fold.or.reduce.method=Métodos simplificables de plegar o reducir.
displayname.simplify.boolean.expression=Simplificar expresiones booleanas
displayname.size.to.length.on.arrays.and.strings=Tamaño cambiado a longitud en matrices y cadenas
displayname.some.to.option=Algunos a la opción
displayname.sorted.and.head.last.to.max.min=Ordenado y encabezado/último al máximo/mínimo
displayname.source3.scala2.syntax=Sintaxis de Scala 2 usando -X fuente\:3
displayname.specs2.matchers=Comparador de Specs2
displayname.suspicious.forward.reference=Referencia directa sospechosa
displayname.suspicious.shadowing.by.a.type.parameter=Enmascaramiento sospechoso por parámetros de tipo
displayname.suspicious.shadowing.by.a.variable.pattern=Enmascaramiento sospechoso por patrones variables
displayname.syntactic.sugar=Azúcar gramatical
displayname.tag.unclosed=La etiqueta no está cerrada
displayname.trivial.match.can.be.simplified=Las coincidencias que se explican por sí mismas se pueden simplificar
displayname.type.annotation.required=Se requiere anotación de tipo
displayname.type.check.can.be.pattern.matching=La verificación de tipos puede convertirse en coincidencia de patrones
displayname.unit.return.type.in.the.argument.of.map=Tipo de retorno de unidad en el argumento del mapa
displayname.unknown.parameter=Parámetro desconocido
displayname.unknown.tag=Etiqueta desconocida
displayname.unmatched.tag=Etiquetas que no coinciden
displayname.unnecessary.braces.in.import.inspection=Llaves innecesarias en la comprobación de la declaración de importación
displayname.unnecessary.parentheses=Paréntesis innecesarios
displayname.unnecessary.partial.function=Función parcial innecesaria
displayname.unused.declaration=Declaración obsoleta
displayname.unzip.for.extracting.a.single.element=Descompresión para extracción de un solo elemento.
displayname.use.of.postfix.method.call=Usando llamadas al método postfix
displayname.var.could.be.a.val=Var' puede ser 'val
displayname.view.bounds.are.deprecated=Los límites de vista están en desuso
displayname.wrong.platform.method.usage=Uso de método de plataforma no válido
displayname.wrong.scaladoc.element=Elemento Scaladoc no válido
empty.parameter.clause.is.redundant=La cláusula de parámetro vacía es innecesaria
empty.parentheses=Agregar paréntesis vacíos
enable.in.scala.3=Habilitado en Scala 3
exists.equals.hint=El cambio existe para contener
expression.always.null=La expresión siempre se evalúa como nula
expression.always.zero=La expresión siempre se evalúa como 0
expression.unit.return.in.map=Una expresión con un tipo de retorno de Unidad dentro del argumento de mapa
family.name.enable.full.qualified.imports=Activar declaraciones de importación totalmente calificadas
family.name.rename.package=Cambiar nombre del paquete
family.name.scala.general=Escala\: general
family.name.scala.scaladoc=Scala\: Scaladoc
field.defined.in.delayedinit.is.likely.to.be.null=Los campos definidos en DelayedInit pueden ser nulos
fileName.does.not.match=La clase no corresponde al nombre del archivo.
fileName.rename.class=Cambiar nombre de definición de tipo
fileName.rename.file=Cambiar nombre de archivo
fileName.rename.text={0} {1} a {2}
filter.empty.check.hint=Reemplace el filtro y la verificación de espacios en blanco con \!(...).exists
filter.headOption.hint=Reemplace el filtro y la opción de cabezal con buscar
filter.nonempty.check.hint=Reemplazo de controles de filtro y sin espacios en blanco con existe
filter.size.hint=Cambiar filtro y tamaño para contar
filterNot.empty.check.hint=Reemplazo de filterNot y verificación de espacios en blanco con forall
filterNot.nonempty.check.hint=Reemplace las comprobaciones filterNot y sin espacios en blanco con \!(...).forall
fimaly.name.move.file.to.package=Ir a Paquetes
final.modifier.is.redundant.for.toplevel.objects=El modificador 'final' es redundante con el objeto de nivel superior.
find.isDefined.hint=Reemplace la verificación de búsqueda y sin espacios en blanco con existe
find.isEmpty.hint=Reemplace la búsqueda y la verificación de espacios en blanco con \!(...).exists
fix.nonlocal.return.check.compiler.option=Sólo con -Xlint\:nonlocal-return
fix.private.shadow.compiler.option.label=-Mostrar sólo Xlint\:sombra privada
fix.private.shadow.fatal.warnings.label=-Xlint\:advertencias-fatales marcan como posibles errores
fix.targetname.annotation=Modificar la anotación @targetName
fix.unused.declaration.report.public.declarations=Desactivar informes de declaraciones públicas no utilizadas
fold.product.hint=Cambiar pliegue al producto
fold.product.short=Doblar al producto
fold.sum.hint=Cambiar pliegue a suma
fold.sum.short=Doblar para sumar
fold.true.and.hint=Cambiar pliegue a forall
forall.notEquals.hint=Cambiar forall a no contiene
format.specifier.cannot.be.used.for.an.argument=El especificador de formato {0} no puede utilizar el argumento {1}({2})
format.with.mkstring=Formatee con .mkString("Array(", ", ", ")")
get.get.hint=Cambiar a .(clave)
get.getOrElse.hint=Reemplazar con getOrElse (clave, valor predeterminado)
getOrElse.null.hint=Cambiando getOrElse(nulo) a orNull
group.code.style=Estilo de código
group.collections=Recopilación
group.comparing=Comparación
group.dataflow.analysis=Análisis de flujo de datos
group.directive=Directiva
group.general=Común
group.indices=Índice
group.internal=Internal
group.maps=Mapa
group.method.signature=Firma del método
group.options=Opción
group.other=Otros
group.resource.leaks=Fuga de recursos
group.scaladoc=Scaladoc
group.simplifications.filter.and.exists=Simplificar\: filtrar y existe
group.simplifications.find.and.map.to.apply=Simplificar\: mapa para buscar y aplicar
group.simplifications.forall.and.exists=Simplificar\: para todos y existe
group.simplifications.other=Simplificar\: Otro
group.size=Tamaño
group.specs2=Specs2
group.syntactic.clarification=Aclaración de sintaxis
group.syntactic.simplification=Simplificar la sintaxis
grouppath.scala.collections=Escala, colección
hint.comparing.different.collection.kinds=Comparar diferentes tipos de colecciones
hint.convert.left.hand.side.to.collection=Convertir izquierda a {0}
hint.convert.right.hand.side.to.collection=Convertir a la derecha a {0}
hint.replace.with.indices=Reemplazar con .indices
hint.replace.with.indices.with.preview=Reemplazar con {0}.indices
hint.replace.with.option.expr=Cambiar a la opción (x)
hint.replace.with.option.expr.with.preview=Reemplazar con Opción({0})
ifstmt.to.filteredOption=Cambiar si a Opción con filtro aplicado
ifstmt.to.headOption=Si no como opción principal
ifstmt.to.lastOption=Si no es la última opción
ifstmt.to.lift=Si no para levantar
implement.quickfix.name=avatar
implementation.limitation.multiple.argument.lists=Limitación de implementación\: actualmente no se admiten listas de argumentos múltiples en las anotaciones
import.feature.flag.for.language.feature=Obtener indicadores de funciones para {0}
inheriting.form.name.is.deprecated.message=La herencia {0} está obsoleta. {Uno}
insert.missing.assignment=Insertar tarea faltante
inspection.option.check.compiler.unnamed=Usado en opciones del compilador.
inspection.option.disabled=Desactivado
inspection.option.enabled=Activado
inspection.scaladoc.problem.duplicate.param=Etiqueta @param duplicada para el parámetro ''{0}''
inspection.scaladoc.problem.duplicate.tparam=Etiqueta @tparam duplicada en el parámetro de tipo ''{0}''
inspection.scaladoc.problem.param.not.allowed=La etiqueta @param no está permitida aquí
inspection.scaladoc.problem.tparam.not.allowed=La etiqueta @tparam no está permitida aquí
inspection.scaladoc.problem.tparam.not.supported.by.scaladoc.in.type.alias=Actualmente Scaladoc no puede manejar tparam de tipo alias
intention.category.scala.internal=Escala/interno
internal.api.status.of.symbols=Estado API del símbolo
internal.expression.without.nls.passed.to.nls=Expresión sin @Nls pasada como @Nls
internal.getText.contains.shouldBe.textContains=.getText.contains debe ser .textContains
internal.getText.equals.shouldBe.textMatches=.getText.equals es .getText.equals. Debe ser coincidencias de texto
internal.instanceOf.shouldBe.is=InstanciaDe debe ser:
internal.only.pass.hardcoded.strings.as.property.keys=Sólo se pasan cadenas codificadas como claves de propiedad.
internal.replace.with.textContains=Reemplazar con .textContiene
internal.replace.with.textMatches=Reemplazar con .textMatches
internal.string.should.be.in.bundle=Las cadenas deben extraerse como paquetes.
introduce.implicit.incorrect.count=No se permite la inserción implícita de parámetros porque el número de posiciones de uso de parámetros es incorrecto.
introduce.implicit.incorrect.order=No se permite la inserción implícita de parámetros debido a un orden de parámetros incorrecto
introduce.implicit.not.allowed.here=No se permite la inserción de parámetros implícitos en esta expresión.
invocation.index.out.of.bounds=La llamada produce una excepción IndexOutOfBoundsException. El índice siempre está fuera de rango
invocation.no.such.element=La llamada arroja NoSuchElementException. La colección siempre está vacía.
kind.projector.code.style.setting.use.lambda.char=Kind Proyector\: Cambiar configuración de estilo de código\: Utilice Î» en lugar de lambda
kind.projector.code.style.setting.use.lambda.word=Kind Proyector\: Cambiar configuración de estilo de código\: Usar lambda en lugar de Î»
kind.projector.deprecated.tip='?' Los marcadores de posición están en desuso. Utilice '*' en su lugar.
kind.projector.deprecated.tip.with.update='?' Los marcadores de posición están en desuso. En su lugar, utilice '*' después de actualizar el complemento kind-projector.
kind.projector.replace.lambda.char.with.lambda=Proyector tipo\: Convertir Î» a Lambda
kind.projector.replace.lambda.with.lambda.char=Tipo Proyector\: Cambie lambda a Î»
language.feature.dynamic.member.selection=Selección dinámica de miembros
language.feature.existential.type=Tipo de existencia
language.feature.higher.kinded.type=Súper tipo
language.feature.implicit.conversion=Conversión implícita
language.feature.macro.definition=Definición de macro
language.feature.postfix.operator.notation=Notación del operador postfijo
language.feature.reflective.call=Llamada reflexiva
legacy.string.formatting.use.interpolated.string=Este es el antiguo formato de cadena. Puedes usar una cadena interpolada en su lugar.
lift.to.headOption=.lift como opción de cabeza
lift.to.lastOption=.levantar como última opción
make.private=Hazlo 'privado'
make.tuple.explicit=Crear tuplas explícitamente
malformed.format.specifier=Especificador de formato no válido
map.getOrElse.false.hint=Reemplazar mapa y getOrElse(false) con existe
map.getOrElse.hint=Reemplazo de map y getOrElse con fold
map.getOrElse.true.hint=Reemplazo de map y getOrElse(true) con forall
mark.import.as.always.used.in.this.project=Marcar las declaraciones de importación como siempre utilizadas en este proyecto
mark.inner.case.objects.as.final=Marcar objeto de caso interno como final
method.signature.accessor.empty.parenthesis=Un método como el descriptor de acceso tiene una cláusula de parámetro vacía
method.signature.accessor.unit.return.type=Los métodos como los descriptores de acceso tienen un tipo de resultado Unidad.
method.signature.empty.paren.override.java.accessor=Método de acceso de Java anulado con una cláusula de argumento vacía
method.signature.empty.paren.override.parameterless=Miembro de Scala sin parámetros redefinido con paréntesis vacíos
method.signature.java.accessor.empty.paren=Método de acceso de Java llamado con una cláusula de argumento vacía
method.signature.override.abstract.member=Implementar un método abstracto sin la palabra clave override
method.signature.parameterless.access.empty.paren=Se accede al método de paréntesis vacío sin parámetros
method.signature.parameterless.access.java.mutator=Se accede al método modificador de Java sin parámetros
method.signature.parameterless.override.empty.paren=Paréntesis vacío Método Scala redefinido sin parámetros
method.signature.parameterless.override.java.mutator=Método modificador de Java anulado sin parámetros
method.signature.parameterless.override.mutator.like=Los métodos con nombre, como los modificadores, no tienen parámetros.
method.signature.procedure.declaration=Sintaxis de procedimiento dentro de declaraciones de método
method.signature.procedure.definition=Sintaxis de procedimiento dentro de las definiciones de métodos
method.signature.result.type.refinement=Es necesario mejorar el tipo de resultado para que quede más claro. ¿Faltan admisiones universitarias?
method.signature.unit.parameterless=Método con tipo de resultado Unidad no tiene parámetros
missing.explicit.type.in.isinstanceof.call=Se llamó a isInstanceOf sin un tipo explícito. Esto depende de la versión del compilador porque el comportamiento depende de que el compilador inserte tipos que satisfagan los límites de tipos.
missing.tag.parameter=Parámetro de etiqueta faltante
move.file.to.default.package=Ir al paquete predeterminado
move.file.to.package.package.prefix.error=No se puede crear el paquete ''{0}'' con el prefijo de paquete ''{2}'' en la carpeta de origen ''{1}''
move.file.to.package.with.packagename=Ir al paquete {0}
name.boolean.ignore.single.parameter.methods=Ignorar métodos con un parámetro
name.unused.declaration.report.local.declarations=Ver la declaración local
name.unused.declaration.report.public.declarations=Reportar declaración pública
no.argument.at.position=No hay argumentos en la posición {0}
no.argument.for.a.format.specifier=El especificador de formato {0} no tiene argumentos
no.format.specifier.for.an.argument=El argumento {0} no tiene especificador de formato
nonlocal.return.check.compiler.option=Utilice sólo la opción del compilador -Xlint\:nonlocal-return
nonlocal.return.statement=Se utilizó una declaración de devolución para salir anticipadamente de la función anónima.
not.implemented=No se ha implementado
operation.on.collection.id=OperationsOnCollection
operation.on.collection.like.collection.input.message=En la inspección, estas clases se tratan como colecciones.
operation.on.collection.like.collection.input.title=Agregar clases tipo colección
operation.on.collection.like.collection.panel.title=Clases tipo colección
operation.on.collection.like.option.input.message=En inspección, estas clases se tratan como Scala.Option
operation.on.collection.like.option.input.title=Agregar una clase similar a la opción
operation.on.collection.like.option.panel.title=Clase similar a la opción
operation.on.collection.name=Operaciones simplificadas sobre cobros
override.definition.has.different.target.name=@targetName("{0}") es necesario porque hay otra anotación de nombre de destino en la definición.
override.definition.misses.targetname.annotation=La definición no tiene anotación de nombre de destino @targetName(''{0}'')
override.definition.should.not.have.targetname.annotation=Dado que la anotación @targetName no está en el miembro que se está redefiniendo, tampoco debería estar en la definición.
overriding.is.deprecated=La anulación de {0} está obsoleta. {Uno}
package.declaration.could.use.chained.package.clauses=El paquete base ''{0}'' debe ser una cláusula de paquete independiente
package.names.does.not.correspond.to.directory.structure=El nombre del paquete ''{0}'' no corresponde a la ruta del archivo ''{1}''
package.names.does.not.correspond.to.directory.structure.package.prefix=La carpeta de origen ''{0}'' tiene el prefijo de paquete ''{1}''
package.objects.are.deprecated=Los objetos del paquete están en desuso en Scala 3. Intente utilizar la definición de nivel superior en su lugar.
packagesearch.newer.stable.version.available=Hay una nueva versión estable de {0}\:{1} disponible
parameter.name.is.deprecated=El nombre del parámetro\:{0} está en desuso.
private.shadow.compiler.option.label=Utilice sólo la opción del compilador -Xlint\:private-shadow
private.shadow.description=El parámetro de clase oscurece la superclase var
private.shadow.fatal.warnings.label=<html><code>-Xfatal-warnings</code>(<code>-Werror</code>) Error de opción del compilador</html>
private.shadow.rename.identifier=Cambiar nombre
quickfix.modify.code.style=Editar estilo de código...
reduce.max.hint=Cambiar reducir al máximo
reduce.max.short=Reducir al máximo
reduce.min.hint=Reemplazar reducir con min
reduce.min.short=Reducir al mínimo
reduce.product.hint=Cambiar reducir a producto
reduce.product.short=Reducir al producto
reduce.sum.hint=Cambiar reducir a suma
reduce.sum.short=Reducir a suma
redundant.braces.in.case.clause=Llaves innecesarias en la cláusula del caso
redundant.collection.conversion=Elimine las conversiones de colecciones innecesarias
redundant.parentheses=Eliminar paréntesis innecesarios
relative.import.detected=Importación relativa detectada
remove.call.parentheses=Quitar paréntesis de llamada
remove.double.negation=Eliminar doble negativo
remove.expression=Eliminar expresión
remove.modifier=Eliminar el controlador ''{0}''
remove.only.name.binding=Eliminar solo el enlace {0}
remove.package.statement=Eliminar la sintaxis del paquete
remove.redundant.braces=Quitar brackets innecesarios
remove.redundant.cast=Eliminar la conversión de tipos innecesaria
remove.redundant.contains=Eliminar .contains innecesarios
remove.redundant.conversion=Elimina conversiones innecesarias
remove.redundant.headOption=Eliminar .headOption innecesario
remove.redundant.lastOption=Innecesario . eliminar la última opción
remove.redundant.parameter.clause=Eliminar cláusulas de parámetros innecesarias
remove.unnecessary.parentheses=Eliminar paréntesis innecesarios
remove.unnecessary.parentheses.with.text=Eliminar paréntesis innecesarios {0}
remove.unnecessary.semicolon=Eliminar puntos y comas innecesarios
remove.unnecessary.val=Eliminar 'val' innecesario
remove.unreachable.code=Eliminar código inalcanzable
remove.unused.element=Eliminar elementos no utilizados
remove.val.from.definition=Eliminar 'val' de la definición
remove.whole.definition=Eliminar toda la definición
rename.package.quickfix.command.name=Cambiar nombre del paquete
rename.package.to=Establecer el nombre del paquete en ''{0}''
rename.variable.pattern=Cambiar el nombre del patrón variable
replace.collect.headOption.with.collectFirst=Reemplace .collect y .headOption con .collectFirst
replace.corresponds.with.equals=El cambio corresponde a iguales.
replace.drop.take.with.slice=Reemplace .drop y .take con .slice
replace.equals.with.sameElements=Cambiando iguales a los mismos elementos
replace.filter.with.diff=Reemplazar filtro y no contiene con diff.
replace.filter.with.intersect=Reemplazar filtro y contiene con intersección
replace.find.and.map.with.apply=Reemplazar buscar y mapear con aplicar
replace.get.isEmpty.with.not.contains=Reemplazar con \!.contiene(clave)
replace.get.nonEmpty.with.contains=Reemplazar con .contiene (clave)
replace.map.contains.false.with.not.forall=reemplace .map(...).contains(false) con \! Reemplazar con .forall(...)
replace.map.contains.true.with.exists=Reemplace .map(...).contains(true) con .exists(...)
replace.map.flatten.with.flatMap=Reemplace .map y .flatten con .flatMap
replace.option.with.some=Cambiar opción a alguna
replace.reverse.iterator=Convertir .reverse.iterator a .reverseIterator
replace.reverse.take.reverse.with.takeRight=Reemplace .reverse.take(...).reverse con .takeRight(...)
replace.sameElements.with.equals=Cambiar elementos iguales a iguales
replace.sortBy.head.with.minBy=Reemplazar con .minBy
replace.sortBy.last.with.maxBy=Reemplazar con .maxBy
replace.sorted.head.with.min=Reemplazar con .min
replace.sorted.last.with.max=Reemplazar con .max
replace.take.drop.with.slice=Reemplace .take y .drop con .slice
replace.to.with.until=Cambie 'a' por 'hasta'
replace.toSet.and.back.with.distinct=Convertir y restaurar a Establecer en .distinct
replace.with.and.char=Reemplazar con \\&
replace.with.as=Cambiar a 'como'
replace.with.contains=Reemplazar con .contiene
replace.with.exists=Reemplazar con .existe
replace.with.findlast=Reemplazar con 'buscarÚltimo'
replace.with.flatten=Reemplazar con .aplanar
replace.with.forall=Reemplazar con .forall
replace.with.get=Reemplazar con .get
replace.with.head=Reemplazar con .head
replace.with.headOption=Reemplazar con .headOption
replace.with.implicit.parameters=Convertir a parámetro implícito
replace.with.is=Reemplazar con .is
replace.with.isDefined=Reemplazar con .isDefined
replace.with.isEmpty=Reemplazar con .isEmpty
replace.with.keySet=Reemplazar con .keySet
replace.with.keys=Reemplazar con .keys
replace.with.keysIterator=Reemplazar con .keysIterator
replace.with.last=Reemplazar con .last
replace.with.lastOption=Reemplazar con .lastOption
replace.with.lengthCompare=Reemplazar con .lengthCompare
replace.with.map=Convertir a .map
replace.with.name.followed.by.star=Reemplazar con ''{0}*''
replace.with.nonEmpty=Reemplazar con .nonEmpty
replace.with.not.contains=Reemplazar con \!.contiene
replace.with.option=Cambiar a opción
replace.with.questionmark=Reemplazar con ?
replace.with.sizeIs=Reemplazar con .sizeIs
replace.with.some=Cambiar a algunos
replace.with.star=Reemplazar con *
replace.with.star.syntax=Reemplazar con la sintaxis '*'
replace.with.values=Convertir a .values
replace.with.valuesIterator=Reemplazar con .valuesIterator
replace.with.zipWithIndex=Reemplazar con zipWithIndex
return.keyword.is.redundant=No es necesario devolver palabras clave
sameElements.unsorted=Los resultados son impredecibles cuando se utiliza 'sameElements' con una colección desordenada
scala.compiler.will.replace.this.argument.list.with.tuple=El compilador de Scala convierte esta lista de argumentos en una tupla.
scala3.alphanumeric.definition.is.not.declared.infix=La definición alfanumérica {0} no está declarada como ''infija''. No debe utilizarse como operador infijo.
simplify.match.to.if.statement=Simplifique la coincidencia en una declaración if
simplify.type=Simplificación de tipos
simplify.with.text={0} Simplificación
single.import=Elimine las llaves de las declaraciones de importación que contienen solo una importación
size.to.length=Convierta .size a .length en matrices y cadenas
sort.filter.hint=Cambiar el orden de clasificación y filtro
source.not.closed=La fuente no se cierra.
specs2.builtin.matcher.alternative.exists=Hay coincidencias disponibles
specs2.use.builtin.matcher=Reemplazar con comparador incorporado
suggest.adding.case.in.for.comprehensions=<html>Sugiero agregar <code>case</code> al <code>for</code> comprensión</html>
suggest.converting.named.wildcard.patterns=<html>Sugerir convertir patrones comodín con nombre a (<code>seq@_*</code> \\&rarr; <code>seq*</code>)</html>
suggest.converting.vararg.splices=<html>Sugerir convertir empalmes vararg (<code>seq\: _*</code> \\&rarr; <code>seq*</code>)</html>
suggest.converting.wildcards=<html>Propuesta de conversión comodín (<code>Seq[_]</code> \\&rarr; <code>Seq[?]</code>)</html>
suggest.using.and.instead.of.with=<html>Sugerir usar <code>\\&</code> en lugar de <code>with</code> en tipos complejos</html>
suggest.using.as.instead.of.arrow=<html>Sugiero usar <code>as</code> en lugar de <code>\=\\&gt;</code> dentro de la declaración de importación</html>
suggest.using.star.instead.of.underscore=<html>Sugiero usar <code>*</code> en lugar de <code>_</code> dentro de la declaración de importación</html>
super.method.name.is.deprecated.with.message=El método principal {0} está en desuso. {Uno}
super.method.name.is.marked.as.status=El método principal {0} está marcado como {1}
suppress.inspection.function=Suprimir en función
suppress.inspection.typeAlias=Suprimido contra alias de tipo
suppress.inspection.variable=Suprimir en definición de variable
surround.with.parenthesis=Rodear entre paréntesis
symbol.name.is.deprecated.with.message=El símbolo {0} está en desuso. {Uno}
symbol.name.is.marked.as.status=El símbolo {0} está marcado como {1}
syntactic.sugar.could.be.used=Puedes usar azúcar gramatical.
targetname.cannot.be.empty=El nombre externo de @targetName no debe estar vacío
targetname.multiple.targets=La anotación @targetName tiene múltiples objetivos
the.enclosing.block.is.redundant=No es necesario encerrar bloques
type.annotation.required.for={0} requiere anotación de tipo
type.check.can.be.replaced.by.pattern.matching=Puede reemplazar la verificación de tipos con la coincidencia de patrones
typed.parameter.without.parenthesis.in.function.literal=Parámetros escritos sin paréntesis en literales de función
unary.operation.can.use.prefix.notation=Use prefix notation for unary operators
unknown.scaladoc.tag=Etiqueta Scaladoc desconocida
unnecessary.parentheses.ignore=ignorar
unnecessary.semicolon=Punto y coma innecesario
unreachable.code.name=Código inalcanzable
unused.expression.name=Expresión obsoleta
unused.expression.no.side.effects=Expresiones sin efectos secundarios no utilizados.
unused.expression.throws=Esta expresión está en desuso. Los únicos efectos secundarios que pueden ocurrir son excepciones.
unused.import.statement=Declaración import obsoleta
unwrap.do.statement=Hacer - desenvolver declaración
unwrap.package.object.fix=Mover un miembro al nivel superior
unwrap.the.expression=Desenvolver expresiones
usage.of.deprecatedname.as.identifier.is.deprecated=El uso de {0} como identificador está en desuso. Puede usarse como palabra clave en futuras versiones de Scala.
use.chained.package.clauses=Utilice una cláusula de paquete base separada
use.chained.package.clauses.like=Extracción de cláusula de paquete
use.foreach.instead.of.map=Utilice foreach en lugar de mapa
use.option.type=Usar tipo de opción
use.underscore.initializer=_Usar inicializador
var.could.be.a.val=Var puede ser val
variable.with.null.initializer=Variables con inicializadores nulos
wrap.in.backticks=Envolviendo con comillas invertidas
