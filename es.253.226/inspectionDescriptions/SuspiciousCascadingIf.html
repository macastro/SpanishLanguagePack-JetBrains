<html>
<body>
<p>Reporta expresiones <code>if</code> en cascada en las que la última rama <code>else</code> está calificada por punto o forma parte de una expresión binaria.
</p>
<p>Esto puede provocar un comportamiento inesperado, ya que solo la expresión <code>if-else</code> más interna se convierte en el receptor o en el operando izquierdo de la expresión externa, lo cual podría no coincidir con la lógica prevista.</p>
<p><b>Ejemplo:</b></p>
<pre><code>
fun printNumberSign(num: Int) {
    if (num > 0) {
        "positive"
    } else if (num < 0) {
        "negative"
    } else {
        "zero"
    }.let { print(it) }
}

fun main() {
    printNumberSign(1) // No se imprime nada porque el receptor de 'let' es solo la expresión 'if-else' interna
}
</code></pre>
<p>Tras aplicar la primera corrección rápida (convertir a <code>when</code>):</p>
<pre><code>
fun printNumberSign(num: Int) {
    when {
        num > 0 -> {
            "positive"
        }

        num < 0 -> {
            "negative"
        }

        else -> {
            "zero"
        }
    }.let { print(it) }
}

fun main() {
    printNumberSign(1) // Imprime "positive"
}
</code></pre>
<p>Alternativamente, una segunda corrección rápida añade llaves aclaratorias para preservar la semántica original, haciendo explícita la rama <code>else</code> anidada:</p>
<pre><code>
fun printNumberSign(num: Int) {
    if (num > 0) {
        "positive"
    } else {
        if (num < 0) {
            "negative"
        } else {
            "zero"
        }.let { print(it) }
    }
}

fun main() {
    printNumberSign(1) // No se imprime nada, pero el código es más claro
}
</code></pre>
</body>
</html>